Id,AcceptedAnswerId,CreationDate,Score,ViewCount,Body,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,text,From,processed_text,topics
163527,,2012-09-03 19:27:56,0,13789,"<p>Just going over my school notes, my teacher identifies <em>multi-tasking OS</em>, and <em>time-sharing OS</em> as two different things.<br>
I really don't see a difference between the two.<br>
<strong>MULTI-TASKING</strong>: You load a number of programs in the memory and execute them. You execute another program if the time quantum allocated to the current program expires OR if it goes on to do I/O and leaves the CPU OR if it finishes execution.<br>
<strong>TIME-SHARING</strong>: the same,again.<br>
The same applies in case of <em>serial processing</em> and <em>batch processing</em>. Although they are the same, I guess the only difference would be the way in which control information is passed to the CPU. Maybe, and again MAYBE, in serial processing you need to provide the punch cards with all the processes while in batch, the entire batch uses the same set of control information.<br>
Like all the print jobs would have the same control information.</p>
",Is there a difference between multi-tasking and time-sharing?,<operating-systems>,5,3,,,"Is there a difference between multi-tasking and time-sharing? <p>Just going over my school notes, my teacher identifies <em>multi-tasking OS</em>, and <em>time-sharing OS</em> as two different things.<br>
I really don't see a difference between the two.<br>
<strong>MULTI-TASKING</strong>: You load a number of programs in the memory and execute them. You execute another program if the time quantum allocated to the current program expires OR if it goes on to do I/O and leaves the CPU OR if it finishes execution.<br>
<strong>TIME-SHARING</strong>: the same,again.<br>
The same applies in case of <em>serial processing</em> and <em>batch processing</em>. Although they are the same, I guess the only difference would be the way in which control information is passed to the CPU. Maybe, and again MAYBE, in serial processing you need to provide the punch cards with all the processes while in batch, the entire batch uses the same set of control information.<br>
Like all the print jobs would have the same control information.</p>
",cr,difference p going school notes teacher identifies em os em os two different br really see difference br strong load number programs memory execute execute another program time quantum allocated current program expires goes leaves cpu finishes br strong br applies case em serial processing em batch processing although guess difference would way control information passed cpu maybe maybe serial processing need provide punch cards processes batch entire batch uses set control br like print jobs would control,"[(8, 0.30418384), (9, 0.26469064), (13, 0.1320064), (14, 0.254504), (16, 0.04253662)]"
163527,,2012-09-03 19:27:56,0,13789,"<p>Just going over my school notes, my teacher identifies <em>multi-tasking OS</em>, and <em>time-sharing OS</em> as two different things.<br>
I really don't see a difference between the two.<br>
<strong>MULTI-TASKING</strong>: You load a number of programs in the memory and execute them. You execute another program if the time quantum allocated to the current program expires OR if it goes on to do I/O and leaves the CPU OR if it finishes execution.<br>
<strong>TIME-SHARING</strong>: the same,again.<br>
The same applies in case of <em>serial processing</em> and <em>batch processing</em>. Although they are the same, I guess the only difference would be the way in which control information is passed to the CPU. Maybe, and again MAYBE, in serial processing you need to provide the punch cards with all the processes while in batch, the entire batch uses the same set of control information.<br>
Like all the print jobs would have the same control information.</p>
",Is there a difference between multi-tasking and time-sharing?,<operating-systems>,5,3,,,"Is there a difference between multi-tasking and time-sharing? <p>Just going over my school notes, my teacher identifies <em>multi-tasking OS</em>, and <em>time-sharing OS</em> as two different things.<br>
I really don't see a difference between the two.<br>
<strong>MULTI-TASKING</strong>: You load a number of programs in the memory and execute them. You execute another program if the time quantum allocated to the current program expires OR if it goes on to do I/O and leaves the CPU OR if it finishes execution.<br>
<strong>TIME-SHARING</strong>: the same,again.<br>
The same applies in case of <em>serial processing</em> and <em>batch processing</em>. Although they are the same, I guess the only difference would be the way in which control information is passed to the CPU. Maybe, and again MAYBE, in serial processing you need to provide the punch cards with all the processes while in batch, the entire batch uses the same set of control information.<br>
Like all the print jobs would have the same control information.</p>
",se,difference p going school notes teacher identifies em os em os two different br really see difference br strong load number programs memory execute execute another program time quantum allocated current program expires goes leaves cpu finishes br strong br applies case em serial processing em batch processing although guess difference would way control information passed cpu maybe maybe serial processing need provide punch cards processes batch entire batch uses set control br like print jobs would control,"[(8, 0.3041482), (9, 0.26468587), (13, 0.13200551), (14, 0.25454527), (16, 0.042536657)]"
287397,287445.0,2015-06-20 17:44:49,2,2488,"<p>I am building an API for minecraft called the <a href=""http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/wip-mods/2344753-the-quantum-api-a-better-alternative-to-forge-and"" rel=""nofollow"">Quantum API</a>. We all know that reflection can be used to do some nasty stuff to classes, and even cause undefined behavior if used without care.</p>

<p>Is there a way to make classes and objects immune to reflection? Perhaps with a security manager? Or vice versa, restrict a certain list of classes/objects from using reflection?</p>

<p>My use would be to prevent other mods that are loaded with this API from using reflection to change a RuntimePermission in a SecurityManager, and to prevent modification of minecraft's base classes (and objects) at runtime, as well as the API's own classes (and objects).</p>
",How can I make an object/class inaccessible to Reflection,<java><reflection><code-security>,1,8,,,"How can I make an object/class inaccessible to Reflection <p>I am building an API for minecraft called the <a href=""http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/wip-mods/2344753-the-quantum-api-a-better-alternative-to-forge-and"" rel=""nofollow"">Quantum API</a>. We all know that reflection can be used to do some nasty stuff to classes, and even cause undefined behavior if used without care.</p>

<p>Is there a way to make classes and objects immune to reflection? Perhaps with a security manager? Or vice versa, restrict a certain list of classes/objects from using reflection?</p>

<p>My use would be to prevent other mods that are loaded with this API from using reflection to change a RuntimePermission in a SecurityManager, and to prevent modification of minecraft's base classes (and objects) at runtime, as well as the API's own classes (and objects).</p>
",cr,make inaccessible reflection p building api minecraft called http nofollow quantum api know reflection used nasty stuff classes even cause undefined behavior used without p way make classes objects immune reflection perhaps security manager vice versa restrict certain list using reflection p use would prevent mods loaded api using reflection change runtimepermission securitymanager prevent modification minecraft base classes objects runtime well api classes objects,"[(0, 0.021968668), (8, 0.24548566), (9, 0.12633565), (14, 0.33551204), (16, 0.06714506), (18, 0.20105948)]"
287397,287445.0,2015-06-20 17:44:49,2,2488,"<p>I am building an API for minecraft called the <a href=""http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/wip-mods/2344753-the-quantum-api-a-better-alternative-to-forge-and"" rel=""nofollow"">Quantum API</a>. We all know that reflection can be used to do some nasty stuff to classes, and even cause undefined behavior if used without care.</p>

<p>Is there a way to make classes and objects immune to reflection? Perhaps with a security manager? Or vice versa, restrict a certain list of classes/objects from using reflection?</p>

<p>My use would be to prevent other mods that are loaded with this API from using reflection to change a RuntimePermission in a SecurityManager, and to prevent modification of minecraft's base classes (and objects) at runtime, as well as the API's own classes (and objects).</p>
",How can I make an object/class inaccessible to Reflection,<java><reflection><code-security>,1,8,,,"How can I make an object/class inaccessible to Reflection <p>I am building an API for minecraft called the <a href=""http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/wip-mods/2344753-the-quantum-api-a-better-alternative-to-forge-and"" rel=""nofollow"">Quantum API</a>. We all know that reflection can be used to do some nasty stuff to classes, and even cause undefined behavior if used without care.</p>

<p>Is there a way to make classes and objects immune to reflection? Perhaps with a security manager? Or vice versa, restrict a certain list of classes/objects from using reflection?</p>

<p>My use would be to prevent other mods that are loaded with this API from using reflection to change a RuntimePermission in a SecurityManager, and to prevent modification of minecraft's base classes (and objects) at runtime, as well as the API's own classes (and objects).</p>
",se,make inaccessible reflection p building api minecraft called http nofollow quantum api know reflection used nasty stuff classes even cause undefined behavior used without p way make classes objects immune reflection perhaps security manager vice versa restrict certain list using reflection p use would prevent mods loaded api using reflection change runtimepermission securitymanager prevent modification minecraft base classes objects runtime well api classes objects,"[(0, 0.02197018), (8, 0.24547946), (9, 0.126369), (14, 0.33547917), (16, 0.06714587), (18, 0.20106284)]"
17736,17737.0,2021-05-31 01:53:04,3,1186,"<p>Suppose I have the following 2-qubit quantum circuit:</p>
<pre><code>qrz = QuantumRegister(2,'q')
crz = ClassicalRegister(3,'c')
qc = QuantumCircuit(qrz,crz)
qc.rx(np.pi/3,0)
qc.cry(np.pi/2,0,1)
</code></pre>
<p>I want to run this circuit on a real quantum computer, depending on the real-time error rate, I might want to use different qubits on the hardware. For example, suppose here's the calibration data of my <code>backend</code>:</p>
<p><a href=""https://i.sstatic.net/ZCgIy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZCgIy.png"" alt=""enter image description here"" /></a></p>
<p>Is there a way I can specify that I want to use qubit 4 and 5 on this quantum computer? I tried to generate a quantum circuit with 6 qubits and append my quantum circuit to qubit 4 and 5, then run the entire circuit on that quantum computer. Is there a simpler way I can do that without generating another large circuit? Thanks!</p>
",How can I specify the qubits on quantum computers that I want to use?,<programming><ibm-q-experience><simulation>,2,1,,,"How can I specify the qubits on quantum computers that I want to use? <p>Suppose I have the following 2-qubit quantum circuit:</p>
<pre><code>qrz = QuantumRegister(2,'q')
crz = ClassicalRegister(3,'c')
qc = QuantumCircuit(qrz,crz)
qc.rx(np.pi/3,0)
qc.cry(np.pi/2,0,1)
</code></pre>
<p>I want to run this circuit on a real quantum computer, depending on the real-time error rate, I might want to use different qubits on the hardware. For example, suppose here's the calibration data of my <code>backend</code>:</p>
<p><a href=""https://i.sstatic.net/ZCgIy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZCgIy.png"" alt=""enter image description here"" /></a></p>
<p>Is there a way I can specify that I want to use qubit 4 and 5 on this quantum computer? I tried to generate a quantum circuit with 6 qubits and append my quantum circuit to qubit 4 and 5, then run the entire circuit on that quantum computer. Is there a simpler way I can do that without generating another large circuit? Thanks!</p>
",qc,specify qubits quantum computers want use p suppose following quantum circuit pre code qrz quantumregister 2 q crz classicalregister 3 c qc quantumcircuit qrz crz p want run circuit real quantum computer depending error rate might want use different qubits hardware example suppose calibration data code backend p https nofollow noreferrer img https enter image description p way specify want use qubit 4 5 quantum computer tried generate quantum circuit 6 qubits append quantum circuit qubit 4 5 run entire circuit quantum computer simpler way without generating another large circuit thanks,"[(0, 0.09748317), (1, 0.122280695), (4, 0.13789205), (5, 0.01837234), (6, 0.07721273), (14, 0.5333791), (16, 0.011922103)]"
17742,17744.0,2021-05-31 12:16:23,4,322,"<p>I would like to create a quantum system with the gates for a <a href=""https://quantum-computing.ibm.com/composer/docs/iqx/example-circuits/w-state"" rel=""nofollow noreferrer"">W state</a> where each qubit is at a different location. Entanglement distribution has been proven in several research articles. I'm new to this space and interested:</p>
<ul>
<li>if three qubits W-state can be implemented where each qubit has a different location?</li>
<li>if in this case, measuring q1 will fix the measurement of q2 and q3 (if one is 1 the others are 0) and only one measurement of the distributed qubits will be possible?</li>
<li>if this would also be possible for n qubits W-state over n locations?</li>
</ul>
",Entanglement distribution of W-State over different locations,<quantum-state><entanglement><w-state>,2,2,,,"Entanglement distribution of W-State over different locations <p>I would like to create a quantum system with the gates for a <a href=""https://quantum-computing.ibm.com/composer/docs/iqx/example-circuits/w-state"" rel=""nofollow noreferrer"">W state</a> where each qubit is at a different location. Entanglement distribution has been proven in several research articles. I'm new to this space and interested:</p>
<ul>
<li>if three qubits W-state can be implemented where each qubit has a different location?</li>
<li>if in this case, measuring q1 will fix the measurement of q2 and q3 (if one is 1 the others are 0) and only one measurement of the distributed qubits will be possible?</li>
<li>if this would also be possible for n qubits W-state over n locations?</li>
</ul>
",qc,entanglement distribution different locations p would like create quantum system gates https nofollow noreferrer w state qubit different location entanglement distribution proven several research articles new space interested ul li three qubits implemented qubit different location li case measuring q1 fix measurement q2 q3 one 1 others 0 one measurement distributed qubits possible li would also possible n qubits n locations,"[(1, 0.09565012), (2, 0.029497355), (4, 0.044144485), (7, 0.22373898), (14, 0.24966627), (16, 0.017035805), (18, 0.33814225)]"
17985,17987.0,2021-06-16 12:49:41,5,137,"<p>Let <span class=""math-container"">$\sigma$</span> be a fixed positive semidefinite matrix (edit: need unit trace too as pointed out if we want trace nonincreasing). Is the map</p>
<p><span class=""math-container"">$$N:H\rightarrow\mathbb{C}$$</span></p>
<p>given by <span class=""math-container"">$N(\rho) = Tr(\sigma\rho)$</span> completely positive? Note that it is positive and trace nonincreasing. If yes, what are its Kraus operators?</p>
",Is the map $\rho\rightarrow Tr(\sigma\rho)$ completely positive?,<quantum-operation>,2,5,,,"Is the map $\rho\rightarrow Tr(\sigma\rho)$ completely positive? <p>Let <span class=""math-container"">$\sigma$</span> be a fixed positive semidefinite matrix (edit: need unit trace too as pointed out if we want trace nonincreasing). Is the map</p>
<p><span class=""math-container"">$$N:H\rightarrow\mathbb{C}$$</span></p>
<p>given by <span class=""math-container"">$N(\rho) = Tr(\sigma\rho)$</span> completely positive? Note that it is positive and trace nonincreasing. If yes, what are its Kraus operators?</p>
",qc,map tr completely positive p let span fixed positive semidefinite matrix edit need unit trace pointed want trace nonincreasing map p span n c p given span n tr completely positive note positive trace nonincreasing yes kraus operators,"[(3, 0.59597266), (11, 0.3735747), (16, 0.025755672)]"
18010,18011.0,2021-06-17 19:32:56,4,145,"<p>I have several mixing unitary circuits written using Pennylane to be used in the QAOA algorithm. Furthermore, I'd like to write unit tests for these mixing circuits to ensure that the code is doing what it is supposed to in the future as changes are made to the codebase. Consider the basic example:</p>
<pre><code>def x_mixer(beta, wires):
    for i in wires:
        qml.RX(beta, wires=i)
</code></pre>
<p>Currently, I'm thinking of using assert statements to check that the output of:</p>
<pre><code>dev = qml.device('lightning.qubit', wires=2, shots=10000)
circuit = qml.QNode(mixer_circuit, dev)
result = circuit(0.5, wires=[0, 1])
</code></pre>
<p>is a certain value. Now one issue is that the results themselves are probabilistic and change during each run. My first question: What's the best way to get around this? Can you set random_seed in any of the simulator devices?</p>
<p>In general if someone has ideas on how to do unit testing for Pennylane circuits, it would be really appreciated.</p>
",How can I write unit tests for a pennylane circuit?,<programming><quantum-circuit><pennylane>,1,2,,,"How can I write unit tests for a pennylane circuit? <p>I have several mixing unitary circuits written using Pennylane to be used in the QAOA algorithm. Furthermore, I'd like to write unit tests for these mixing circuits to ensure that the code is doing what it is supposed to in the future as changes are made to the codebase. Consider the basic example:</p>
<pre><code>def x_mixer(beta, wires):
    for i in wires:
        qml.RX(beta, wires=i)
</code></pre>
<p>Currently, I'm thinking of using assert statements to check that the output of:</p>
<pre><code>dev = qml.device('lightning.qubit', wires=2, shots=10000)
circuit = qml.QNode(mixer_circuit, dev)
result = circuit(0.5, wires=[0, 1])
</code></pre>
<p>is a certain value. Now one issue is that the results themselves are probabilistic and change during each run. My first question: What's the best way to get around this? Can you set random_seed in any of the simulator devices?</p>
<p>In general if someone has ideas on how to do unit testing for Pennylane circuits, it would be really appreciated.</p>
",qc,write unit tests pennylane circuit p several mixing unitary circuits written using pennylane used qaoa algorithm furthermore like write unit tests mixing circuits ensure code supposed future changes made codebase consider basic example pre code def beta wires wires beta p currently thinking using assert statements check output pre code dev circuit dev result circuit 0 1 p certain value one issue results probabilistic change run first question best way get around set simulator devices p general someone ideas unit testing pennylane circuits would really,"[(0, 0.19604589), (2, 0.037326258), (3, 0.06754309), (8, 0.1094427), (14, 0.54174316), (16, 0.046234857)]"
18130,,2021-06-24 15:37:45,4,138,"<p>I am trying to better understand (standard, not gauge) 3d color codes. In particular, I am working with the lattice proposed in <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/17/8/083002/meta"" rel=""nofollow noreferrer"">1</a>.</p>
<p>I understand how X error works, forming strings of the kind Vertex -&gt; Cell -&gt; Face -&gt; Cell -&gt; Vertex, where the Vertices and Faces are of the same color. (Notice that this is in the &quot;dual picture&quot;, where qubits are at cells). An X error will happen if there is a string-net starting from one cell (qubit) and propagating to each face of the tetrahedra.</p>
<p>I would like to have a similar understanding of Z errors. From figure 2 in <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.98.160502"" rel=""nofollow noreferrer"">2</a> it can be seen that Z logical errors propagate via the two-colored edges (we are in the dual picture, so faces -&gt; edges) alternating edges of opposite coloring. For example
red-yellow edge -&gt; cell -&gt; blue-green edge -&gt;  cell -&gt; red-yellow edge.</p>
<p>What I am confused about is how Z logical errors look like. From <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.98.160502"" rel=""nofollow noreferrer"">2</a> I would guess these have something to do with error branes encircling the face of the corresponding color, but I do not see it clearly.</p>
<p>My question is How do logical Z errors look like in this situation? Secondly, is it possible that I am getting it wrong that the lattice described in <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/17/8/083002/meta"" rel=""nofollow noreferrer"">1</a> and <a href=""https://www.nature.com/articles/ncomms12302"" rel=""nofollow noreferrer"">3</a> can be used for non-gauge color codes?</p>
<p>Thanks a lot!</p>
<p><a href=""https://iopscience.iop.org/article/10.1088/1367-2630/17/8/083002/meta"" rel=""nofollow noreferrer"">H Bombín, <em>Gauge color codes: optimal transversal gates and gauge fixing in topological stabilizer codes</em></a></p>
<p><a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.98.160502"" rel=""nofollow noreferrer"">H. Bombin and M. A. Martin-Delgado, <em>Topological Computation without Braiding</em></a></p>
<p><a href=""https://www.nature.com/articles/ncomms12302"" rel=""nofollow noreferrer"">Benjamin J. Brown, Naomi H. Nickerson &amp; Dan E. Browne <em>Fault-tolerant error correction with the gauge color code</em></a></p>
",What do Z logical errors look like in 3d color codes?,<error-correction><topological-quantum-computing>,0,1,,,"What do Z logical errors look like in 3d color codes? <p>I am trying to better understand (standard, not gauge) 3d color codes. In particular, I am working with the lattice proposed in <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/17/8/083002/meta"" rel=""nofollow noreferrer"">1</a>.</p>
<p>I understand how X error works, forming strings of the kind Vertex -&gt; Cell -&gt; Face -&gt; Cell -&gt; Vertex, where the Vertices and Faces are of the same color. (Notice that this is in the &quot;dual picture&quot;, where qubits are at cells). An X error will happen if there is a string-net starting from one cell (qubit) and propagating to each face of the tetrahedra.</p>
<p>I would like to have a similar understanding of Z errors. From figure 2 in <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.98.160502"" rel=""nofollow noreferrer"">2</a> it can be seen that Z logical errors propagate via the two-colored edges (we are in the dual picture, so faces -&gt; edges) alternating edges of opposite coloring. For example
red-yellow edge -&gt; cell -&gt; blue-green edge -&gt;  cell -&gt; red-yellow edge.</p>
<p>What I am confused about is how Z logical errors look like. From <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.98.160502"" rel=""nofollow noreferrer"">2</a> I would guess these have something to do with error branes encircling the face of the corresponding color, but I do not see it clearly.</p>
<p>My question is How do logical Z errors look like in this situation? Secondly, is it possible that I am getting it wrong that the lattice described in <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/17/8/083002/meta"" rel=""nofollow noreferrer"">1</a> and <a href=""https://www.nature.com/articles/ncomms12302"" rel=""nofollow noreferrer"">3</a> can be used for non-gauge color codes?</p>
<p>Thanks a lot!</p>
<p><a href=""https://iopscience.iop.org/article/10.1088/1367-2630/17/8/083002/meta"" rel=""nofollow noreferrer"">H Bombín, <em>Gauge color codes: optimal transversal gates and gauge fixing in topological stabilizer codes</em></a></p>
<p><a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.98.160502"" rel=""nofollow noreferrer"">H. Bombin and M. A. Martin-Delgado, <em>Topological Computation without Braiding</em></a></p>
<p><a href=""https://www.nature.com/articles/ncomms12302"" rel=""nofollow noreferrer"">Benjamin J. Brown, Naomi H. Nickerson &amp; Dan E. Browne <em>Fault-tolerant error correction with the gauge color code</em></a></p>
",qc,z logical errors look like 3d color codes p trying better understand standard gauge 3d color codes particular working lattice proposed https nofollow noreferrer 1 p understand x error works forming strings kind vertex gt cell gt face gt cell gt vertex vertices faces color notice quot dual picture quot qubits cells x error happen starting one cell qubit propagating face p would like similar understanding z errors figure 2 https nofollow noreferrer 2 seen z logical errors propagate via edges dual picture faces gt edges alternating edges opposite coloring example edge gt cell gt edge gt cell gt p confused z logical errors look like https nofollow noreferrer 2 would guess something error branes encircling face corresponding color see p question logical z errors look like situation secondly possible getting wrong lattice described https nofollow noreferrer 1 https nofollow noreferrer 3 used color codes p thanks lot p https nofollow noreferrer h bombín em gauge color codes optimal transversal gates gauge fixing topological stabilizer codes p https nofollow noreferrer h bombin em topological computation without braiding p https nofollow noreferrer benjamin brown naomi nickerson amp dan browne em error correction gauge color code,"[(0, 0.06889336), (2, 0.020470604), (4, 0.1941881), (5, 0.3466635), (7, 0.093020245), (9, 0.059288613), (10, 0.014921591), (13, 0.12668134), (16, 0.010782088), (18, 0.042799547)]"
18143,18147.0,2021-06-25 21:23:36,1,1509,"<p>I have this Quantum Fourier Transform (QFT) and I want to know how to find the final state of each qubit if <code>q0</code>, <code>q1</code>, <code>q2</code> start in the states <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|0\rangle$</span>.</p>
<p>Do I go along the wire of each qubit and multiply the operations together. i.e. for <code>q_0</code>:</p>
<p><span class=""math-container"">$|q_0\rangle = |0\rangle * H$</span></p>
<p>For <span class=""math-container"">$|q_1\rangle$</span>:
<span class=""math-container"">$|q_1\rangle = |1\rangle * H$</span></p>
<p>For <span class=""math-container"">$|q_2\rangle$</span>:
<span class=""math-container"">$|q_2\rangle = |0\rangle * H * P(\pi/2)$</span></p>
<p>Then swap for <span class=""math-container"">$|q0\rangle$</span> and <span class=""math-container"">$|q2\rangle$</span>?</p>
<p>Also is there any software that can find the states of the qubits before being measured?</p>
<p>(The circuit is from the Qiskit implementation)
<a href=""https://i.sstatic.net/HLNYj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HLNYj.png"" alt=""enter image description here"" /></a></p>
",How do I find the state of each qubit at the end of the circuit?,<qiskit><quantum-state><quantum-fourier-transform><quantum-circuit>,2,0,,,"How do I find the state of each qubit at the end of the circuit? <p>I have this Quantum Fourier Transform (QFT) and I want to know how to find the final state of each qubit if <code>q0</code>, <code>q1</code>, <code>q2</code> start in the states <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|0\rangle$</span>.</p>
<p>Do I go along the wire of each qubit and multiply the operations together. i.e. for <code>q_0</code>:</p>
<p><span class=""math-container"">$|q_0\rangle = |0\rangle * H$</span></p>
<p>For <span class=""math-container"">$|q_1\rangle$</span>:
<span class=""math-container"">$|q_1\rangle = |1\rangle * H$</span></p>
<p>For <span class=""math-container"">$|q_2\rangle$</span>:
<span class=""math-container"">$|q_2\rangle = |0\rangle * H * P(\pi/2)$</span></p>
<p>Then swap for <span class=""math-container"">$|q0\rangle$</span> and <span class=""math-container"">$|q2\rangle$</span>?</p>
<p>Also is there any software that can find the states of the qubits before being measured?</p>
<p>(The circuit is from the Qiskit implementation)
<a href=""https://i.sstatic.net/HLNYj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HLNYj.png"" alt=""enter image description here"" /></a></p>
",qc,find state qubit end circuit p quantum fourier transform qft want know find final state qubit code q0 code q1 code q2 start states span span span p go along wire qubit multiply operations together code p span h p span span h p span span h p p swap span span p also software find states qubits measured p circuit qiskit implementation https nofollow noreferrer img https enter image description,"[(3, 0.26777548), (4, 0.20779024), (7, 0.0645578), (14, 0.24296802), (16, 0.028950991), (18, 0.18599072)]"
18180,,2021-06-29 11:22:43,2,39,"<p>How do I recover from a certain <code>job_id</code> in the IBM backends which qubits where used?</p>
<p>I would be interested to know if for instance, in a batch of say 50 jobs, 25 of them are run in qubits 0 and 1 but the other half in  say 5 or 7.</p>
",Recover qubits used in an actual computation,<programming><ibm-q-experience>,0,1,,,"Recover qubits used in an actual computation <p>How do I recover from a certain <code>job_id</code> in the IBM backends which qubits where used?</p>
<p>I would be interested to know if for instance, in a batch of say 50 jobs, 25 of them are run in qubits 0 and 1 but the other half in  say 5 or 7.</p>
",qc,recover qubits used actual computation p recover certain code ibm backends qubits used p would interested know instance batch say 50 jobs 25 run qubits 0 1 half say 5,"[(1, 0.061662775), (2, 0.053481497), (6, 0.07338097), (14, 0.50267076), (16, 0.038985662), (18, 0.26518175)]"
18258,,2021-07-02 17:30:13,2,128,"<p>Is it possible to connect a quantum computer to openlibary.org API? How do I find the public IP address to my quantum instance?</p>
",Trying to connect IBM Quantum to External API,<programming><ibm-q-experience>,1,1,,,"Trying to connect IBM Quantum to External API <p>Is it possible to connect a quantum computer to openlibary.org API? How do I find the public IP address to my quantum instance?</p>
",qc,trying connect ibm quantum external api p possible connect quantum computer api find public ip address quantum instance,"[(1, 0.43528315), (9, 0.067061834), (14, 0.3543253), (16, 0.13401894)]"
18320,18329.0,2021-07-06 22:28:38,2,1645,"<p>I remember reading this somewhere... Is there an elegant proof for this?</p>
",Is every single-qubit unitary just a rotation around some unit vector on the Bloch sphere?,<quantum-gate><textbook-and-exercises><resource-request><bloch-sphere>,3,3,,,"Is every single-qubit unitary just a rotation around some unit vector on the Bloch sphere? <p>I remember reading this somewhere... Is there an elegant proof for this?</p>
",qc,every unitary rotation around unit vector bloch sphere p remember reading somewhere elegant proof,"[(3, 0.20330867), (9, 0.2981708), (13, 0.43689123), (16, 0.0503519)]"
18343,18344.0,2021-07-08 00:36:58,0,213,"<p>I have a simple 2 qubit circuit which I am trying to protect from errors using the measurement error mitigation technique laid out here:
<a href=""https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html</a>. My circuit is</p>
<pre><code>qr=QuantumRegister(2)
circuit2 = QuantumCircuit();
circuit2.add_register(qr)
cr=ClassicalRegister(2)
circuit2.add_register(cr)

circuit2.measure(0,0);
circuit2.measure(1,1);
noise_model = NoiseModel()
noise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])
result = execute(circuit2,backend=Aer.get_backend('qasm_simulator'),shots=maxShot,noise_model=noise_model).result()
counts = result.get_counts(0)
</code></pre>
<p>I then get the counts for each outcome and store it in a vector</p>
<pre><code>n00=counts.get('00')
etc..
n2qvec=np.array([n00,n01,n10,n11])
</code></pre>
<p>As is laid out in the tutorial I obtain the calibration matrix and filter</p>
<pre><code>aer_sim = Aer.get_backend('aer_simulator')
qr2q = QuantumRegister(2)
my_layout2q={qr2q[0]:0,qr2q[1]:1}
meas_calibs2q, state_labels2q = complete_meas_cal(qr=qr2q, circlabel='mcal2q')
t_qc = transpile(meas_calibs2q, aer_sim)
qobj = assemble(t_qc, shots=10000)
noise_model = NoiseModel()
noise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])    
cal_results2q = aer_sim.run(qobj, shots=10000,noise_model=noise_model).result()
meas_fitter2q = CompleteMeasFitter(cal_results2q, state_labels2q, circlabel='mcal2q')
meas_filter2q = meas_fitter2q.filter
calmat2q=meas_fitter2q.cal_matrix
import scipy.linalg as la
calmatinv2q = la.inv(calmat2q)
</code></pre>
<p>I then apply this to the earlier results to account for the noise</p>
<pre><code>mitigated_results2q = meas_filter2q.apply(res2q[1])
mitigated_counts2q = mitigated_results2q.get_counts()
print(mitigated_counts2q)
</code></pre>
<p>This works sensibly. However I thought that this is equivalent to applying the inverse of the calibration matrix to the vector of results that I have:</p>
<pre><code>print(np.dot(calmatinv2q,n2qvec))
print(min(np.dot(calmatinv2q,n2qvec)))
</code></pre>
<p>However sometimes this returns a negative counts. Obviously this isn't sensible so I assume that the measurement filter takes care of this somehow. Does anyone know how this is done? I wish to be able to do this manually because ideally I will run multiple two qubit circuits in parallel on the same quantum computer. So rather than running <span class=""math-container"">$2^n$</span> calibration circuits I will run 4 calibration circuits for each pair of qubits in isolation.</p>
",Manual measurement error mitigation returning a negative number of counts,<programming><qiskit><measurement><error-mitigation>,1,0,,,"Manual measurement error mitigation returning a negative number of counts <p>I have a simple 2 qubit circuit which I am trying to protect from errors using the measurement error mitigation technique laid out here:
<a href=""https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html</a>. My circuit is</p>
<pre><code>qr=QuantumRegister(2)
circuit2 = QuantumCircuit();
circuit2.add_register(qr)
cr=ClassicalRegister(2)
circuit2.add_register(cr)

circuit2.measure(0,0);
circuit2.measure(1,1);
noise_model = NoiseModel()
noise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])
result = execute(circuit2,backend=Aer.get_backend('qasm_simulator'),shots=maxShot,noise_model=noise_model).result()
counts = result.get_counts(0)
</code></pre>
<p>I then get the counts for each outcome and store it in a vector</p>
<pre><code>n00=counts.get('00')
etc..
n2qvec=np.array([n00,n01,n10,n11])
</code></pre>
<p>As is laid out in the tutorial I obtain the calibration matrix and filter</p>
<pre><code>aer_sim = Aer.get_backend('aer_simulator')
qr2q = QuantumRegister(2)
my_layout2q={qr2q[0]:0,qr2q[1]:1}
meas_calibs2q, state_labels2q = complete_meas_cal(qr=qr2q, circlabel='mcal2q')
t_qc = transpile(meas_calibs2q, aer_sim)
qobj = assemble(t_qc, shots=10000)
noise_model = NoiseModel()
noise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])    
cal_results2q = aer_sim.run(qobj, shots=10000,noise_model=noise_model).result()
meas_fitter2q = CompleteMeasFitter(cal_results2q, state_labels2q, circlabel='mcal2q')
meas_filter2q = meas_fitter2q.filter
calmat2q=meas_fitter2q.cal_matrix
import scipy.linalg as la
calmatinv2q = la.inv(calmat2q)
</code></pre>
<p>I then apply this to the earlier results to account for the noise</p>
<pre><code>mitigated_results2q = meas_filter2q.apply(res2q[1])
mitigated_counts2q = mitigated_results2q.get_counts()
print(mitigated_counts2q)
</code></pre>
<p>This works sensibly. However I thought that this is equivalent to applying the inverse of the calibration matrix to the vector of results that I have:</p>
<pre><code>print(np.dot(calmatinv2q,n2qvec))
print(min(np.dot(calmatinv2q,n2qvec)))
</code></pre>
<p>However sometimes this returns a negative counts. Obviously this isn't sensible so I assume that the measurement filter takes care of this somehow. Does anyone know how this is done? I wish to be able to do this manually because ideally I will run multiple two qubit circuits in parallel on the same quantum computer. So rather than running <span class=""math-container"">$2^n$</span> calibration circuits I will run 4 calibration circuits for each pair of qubits in isolation.</p>
",qc,manual measurement error mitigation returning negative number counts p simple 2 qubit circuit trying protect errors using measurement error mitigation technique laid https nofollow noreferrer https circuit pre code 2 circuit2 quantumcircuit qr 2 cr noisemodel 1 er0 er0 er1 1 er1 result execute circuit2 counts 0 p get counts outcome store vector pre code etc n00 n01 n10 n11 p laid tutorial obtain calibration matrix filter pre code qr2q quantumregister 2 qr2q 0 qr2q 1 transpile qobj assemble noisemodel 1 er0 er0 er1 1 er1 qobj completemeasfitter import la calmatinv2q calmat2q p apply earlier results account noise pre code res2q 1 print p works sensibly however thought equivalent applying inverse calibration matrix vector results pre code print calmatinv2q n2qvec print min calmatinv2q n2qvec p however sometimes returns negative counts obviously sensible assume measurement filter takes care somehow anyone know done wish able manually ideally run multiple two qubit circuits parallel quantum computer rather running span calibration circuits run 4 calibration circuits pair qubits,"[(0, 0.276518), (2, 0.12093788), (3, 0.020477558), (4, 0.047846388), (11, 0.010083862), (14, 0.4314356), (16, 0.029425), (18, 0.06240627)]"
18346,18353.0,2021-07-08 09:47:41,1,74,"<p>A possibly to ignorant question. <a href=""https://en.wikipedia.org/wiki/Qubit#Quantum_entanglement"" rel=""nofollow noreferrer"">Here</a> I read:</p>
<blockquote>
<p>For example, if she measures a <span class=""math-container"">$|0\rangle$</span>,Bob must measure the same, as <span class=""math-container"">$|00\rangle$</span>
is the only state where Alice's qubit is a <span class=""math-container"">$|0\rangle$</span></p>
</blockquote>
<p>In the Quantum composer, with the &quot;Bell State ZZ-Measurement&quot; code, <code>q0</code> and <code>q1</code> are entagled but, changing the visualization seed (now at 6162), they have distinct measures.</p>
<p>Is this because 'higher correlation' doesn't mean 'identical values' or am I misinterpreting the basic elements?<br />
Many thanks.</p>
<p><a href=""https://i.sstatic.net/Qr8kk.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qr8kk.png"" alt=""Bell State ZZ-Measurement "" /></a></p>
",How can I observe the effects of the entanglement?,<entanglement>,1,2,,,"How can I observe the effects of the entanglement? <p>A possibly to ignorant question. <a href=""https://en.wikipedia.org/wiki/Qubit#Quantum_entanglement"" rel=""nofollow noreferrer"">Here</a> I read:</p>
<blockquote>
<p>For example, if she measures a <span class=""math-container"">$|0\rangle$</span>,Bob must measure the same, as <span class=""math-container"">$|00\rangle$</span>
is the only state where Alice's qubit is a <span class=""math-container"">$|0\rangle$</span></p>
</blockquote>
<p>In the Quantum composer, with the &quot;Bell State ZZ-Measurement&quot; code, <code>q0</code> and <code>q1</code> are entagled but, changing the visualization seed (now at 6162), they have distinct measures.</p>
<p>Is this because 'higher correlation' doesn't mean 'identical values' or am I misinterpreting the basic elements?<br />
Many thanks.</p>
<p><a href=""https://i.sstatic.net/Qr8kk.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qr8kk.png"" alt=""Bell State ZZ-Measurement "" /></a></p>
",qc,observe effects entanglement p possibly ignorant question https nofollow noreferrer read blockquote p example measures span bob must measure span state alice qubit span p quantum composer quot bell state quot code code q0 code q1 entagled changing visualization seed 6162 distinct p correlation mean values misinterpreting basic elements br many p https nofollow noreferrer img https bell state,"[(0, 0.08159492), (3, 0.09210639), (4, 0.30906802), (16, 0.038414035), (18, 0.437262), (19, 0.03901777)]"
18381,,2021-07-10 00:15:54,2,508,"<p>I have a script in the IBM Quantum lab which runs several jobs and stores the result of each job as a .txt file in a results folder. All I want to do is to download the folder of files. I cannot figure out how to do this and so at the moment I have to open the folder in the Quantum Lab and then select each file and individually download it. This is getting very tiresome.</p>
<p>I feel like I must be missing something really simple that would enable me to just download the folder, but when I click on the dropdown menu for the folder, all it allows me to do is to rename or delete it.</p>
<p>Sorry for the stupid question!</p>
",How to download from IBM Quantum lab folder of data .txt files all at once?,<programming><ibm-q-experience>,1,3,,,"How to download from IBM Quantum lab folder of data .txt files all at once? <p>I have a script in the IBM Quantum lab which runs several jobs and stores the result of each job as a .txt file in a results folder. All I want to do is to download the folder of files. I cannot figure out how to do this and so at the moment I have to open the folder in the Quantum Lab and then select each file and individually download it. This is getting very tiresome.</p>
<p>I feel like I must be missing something really simple that would enable me to just download the folder, but when I click on the dropdown menu for the folder, all it allows me to do is to rename or delete it.</p>
<p>Sorry for the stupid question!</p>
",qc,download ibm quantum lab folder data files p script ibm quantum lab runs several jobs stores result job file results folder want download folder files figure moment open folder quantum lab select file individually download getting p feel like must missing something really simple would enable download folder click dropdown menu folder allows rename delete p sorry stupid question,"[(7, 0.07371896), (9, 0.02685556), (14, 0.73094314), (16, 0.12140808), (17, 0.044022497)]"
20757,,2021-08-06 13:21:53,0,203,"<p>I'm going through the tutorials <a href=""https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html#2.-Finding-the-qubit-Frequency-using-a-Frequency-Sweep-"" rel=""nofollow noreferrer"">qiskit</a> and <a href=""https://lab.quantum-computing.ibm.com/user/5ff4d7e704cc3c00142ece32/lab/tree/qiskit-tutorials/qiskit/circuits_advanced/06_building_pulse_schedules.ipynb"" rel=""nofollow noreferrer"">quantum lab 06_building_pulse_sched</a> for qubit calibration. The first pulse is as in the image. There's a couple of things that I still don't understand in it.</p>
<p>(a) The curl arrow is an offset, as described in the quantum lab notebook. In the code of qiskit (first reference), does not seem to be an offset added, why it is present?</p>
<p>(b) Somehow I got lost with the parameters. Why the pulse is centered at around 300ns?</p>
<p><a href=""https://i.sstatic.net/ZeGGA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZeGGA.png"" alt=""enter image description here"" /></a></p>
","Open pulse, simple schedule meaning",<qiskit>,1,0,,,"Open pulse, simple schedule meaning <p>I'm going through the tutorials <a href=""https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html#2.-Finding-the-qubit-Frequency-using-a-Frequency-Sweep-"" rel=""nofollow noreferrer"">qiskit</a> and <a href=""https://lab.quantum-computing.ibm.com/user/5ff4d7e704cc3c00142ece32/lab/tree/qiskit-tutorials/qiskit/circuits_advanced/06_building_pulse_schedules.ipynb"" rel=""nofollow noreferrer"">quantum lab 06_building_pulse_sched</a> for qubit calibration. The first pulse is as in the image. There's a couple of things that I still don't understand in it.</p>
<p>(a) The curl arrow is an offset, as described in the quantum lab notebook. In the code of qiskit (first reference), does not seem to be an offset added, why it is present?</p>
<p>(b) Somehow I got lost with the parameters. Why the pulse is centered at around 300ns?</p>
<p><a href=""https://i.sstatic.net/ZeGGA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZeGGA.png"" alt=""enter image description here"" /></a></p>
",qc,open pulse simple schedule meaning p going tutorials https nofollow noreferrer qiskit https nofollow noreferrer quantum lab qubit calibration first pulse image couple things still understand p curl arrow offset described quantum lab notebook code qiskit first reference seem offset added present p b somehow got lost parameters pulse centered around 300ns p https nofollow noreferrer img https enter image description,"[(0, 0.16929515), (4, 0.57336664), (8, 0.12298089), (9, 0.11046821), (16, 0.0213541)]"
20763,20764.0,2021-08-06 21:41:32,2,461,"<p>When I run <code>provider.backends()</code>, <code>ibmqx2</code> is listed as an available backend, but is not listed on the <a href=""https://quantum-computing.ibm.com/services?services=systems"" rel=""nofollow noreferrer"">IBMQ systems page</a>. <a href=""https://github.com/Qiskit/ibmq-device-information/tree/master/backends/yorktown/V1"" rel=""nofollow noreferrer"">This file</a> from the archived repository <a href=""https://github.com/Qiskit/ibmq-device-information"" rel=""nofollow noreferrer"">ibmq-device-information</a> associates backend name <code>ibmqx2</code> with display name IBM Q 5 Yorktown. The IBMQ systems page does list a 5 qubit Yorktown device, but under the name <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;system=ibmqx2"" rel=""nofollow noreferrer"">ibmq_5_yorktown</a>. This backend is also available via <code>ibmq/open/main</code>, but is not listed by <code>provider.backends()</code>. Are <code>ibmqx2</code> and <code>ibmq_5_yorktown</code> respectively versions 1 and 2 of backend software providing access to a single Yorktown device? Or do these names refer to two distinct Yorktown devices?</p>
",IBM Quantum: Are ibmq_5_yorktown and ibmqx2 different devices?,<programming><qiskit><ibm-q-experience>,2,0,,,"IBM Quantum: Are ibmq_5_yorktown and ibmqx2 different devices? <p>When I run <code>provider.backends()</code>, <code>ibmqx2</code> is listed as an available backend, but is not listed on the <a href=""https://quantum-computing.ibm.com/services?services=systems"" rel=""nofollow noreferrer"">IBMQ systems page</a>. <a href=""https://github.com/Qiskit/ibmq-device-information/tree/master/backends/yorktown/V1"" rel=""nofollow noreferrer"">This file</a> from the archived repository <a href=""https://github.com/Qiskit/ibmq-device-information"" rel=""nofollow noreferrer"">ibmq-device-information</a> associates backend name <code>ibmqx2</code> with display name IBM Q 5 Yorktown. The IBMQ systems page does list a 5 qubit Yorktown device, but under the name <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;system=ibmqx2"" rel=""nofollow noreferrer"">ibmq_5_yorktown</a>. This backend is also available via <code>ibmq/open/main</code>, but is not listed by <code>provider.backends()</code>. Are <code>ibmqx2</code> and <code>ibmq_5_yorktown</code> respectively versions 1 and 2 of backend software providing access to a single Yorktown device? Or do these names refer to two distinct Yorktown devices?</p>
",qc,ibm quantum ibmqx2 different devices p run code code ibmqx2 listed available backend listed https nofollow noreferrer ibmq systems page https nofollow noreferrer file archived repository https nofollow noreferrer associates backend name code ibmqx2 display name ibm q 5 yorktown ibmq systems page list 5 qubit yorktown device name https amp nofollow noreferrer backend also available via code listed code code ibmqx2 code respectively versions 1 2 backend software providing access single yorktown device names refer two distinct yorktown devices,"[(0, 0.32550052), (1, 0.04661627), (4, 0.21326858), (9, 0.26232892), (14, 0.072160155), (15, 0.01576659), (16, 0.06260619)]"
20786,20789.0,2021-08-08 22:36:20,0,431,"<p>I'm trying to simulate the effect of a coherent unitary Z rotation at an arbitrary angle of a single qubit on the fidelity of a quantum circuit. I am using the qiskit Aer noisy simulator. More specifically, my goal is to quantify the loss of fidelity associated with the fact that when attempting to apply any gate with a unitary <span class=""math-container"">$U$</span>, I apply instead the gate</p>
<p><span class=""math-container"">$$
V = R_{i,z}^\dagger(\epsilon)UR_{i,z}(\epsilon)
$$</span></p>
<p>where <span class=""math-container"">$i$</span> is an index of a single qubit.</p>
<p>As a sanity check, I am trying the single qubit case first, where I expect this error to not have any effect, since the initial state of the qubit is <span class=""math-container"">$|0\rangle$</span> and the measurement is in the Z basis. Thus, assuming that the coherent unitary channel acts on the state as <span class=""math-container"">$\mathcal{E}(\rho) = U\rho U^\dagger$</span>, this error should get absorbed into the preperation and measurement and not have any effect on the fidelity.</p>
<p>When I simulate this circuit however, I find that the fidelity <em>does</em> go below 1 as I increase the error. It seems like the qiskit method <code>coherent_unitary_error</code> function from qiskit does not return a QuantumError object which has the effect of applying <span class=""math-container"">$\mathcal{E}(\rho)$</span> as defined above. Does that make sense?</p>
<p>I am including here a self-contained code sample which shows this behavior. One easy way to trigger this effect on and off is to change the <code>optimization_level</code> parameter in line 21 of the attached code. If it is 0, then the two Hadamards don't get merged into one and we see an error. If it is 1 or larger, they get merged and no error appears. Of course, manually adding the Z rotations to the circuit does not lead to an error.</p>
<p>Any ideas? Did I misunderstand how the noise model works, or is there a more fundamental issue here?</p>
<p>Thanks a lot in advance!!</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, transpile
from qiskit.providers.aer import AerSimulator
from qiskit.providers.aer.noise import NoiseModel, coherent_unitary_error

epsilon = 0.1
z_rot = qiskit.circuit.library.U1Gate(epsilon)
z_rot_dg = qiskit.circuit.library.U1Gate(-epsilon)

noise_model = NoiseModel()
noise_model.add_all_qubit_quantum_error(coherent_unitary_error(z_rot), 'u2')
noise_model.add_all_qubit_quantum_error(coherent_unitary_error(z_rot), 'u3')
print(noise_model)
noise_sim = AerSimulator(noise_model=noise_model)

circ = QuantumCircuit(1, 1)
circ.h(0)
circ.h(0)
circ.measure(0, 0)

# change optimization level to 1 to turn off effect of channel
ct = transpile(circ, noise_sim, optimization_level=0) 
print(ct.draw())
nshots=10000
job = noise_sim.run(ct, shots=nshots)
print(job.result().get_counts()['0']/nshots)
<span class=""math-container"">```</span>
</code></pre>
",unexpected effect of coherent unitary error in qiskit,<qiskit><quantum-operation><noise><computational-models>,1,2,,,"unexpected effect of coherent unitary error in qiskit <p>I'm trying to simulate the effect of a coherent unitary Z rotation at an arbitrary angle of a single qubit on the fidelity of a quantum circuit. I am using the qiskit Aer noisy simulator. More specifically, my goal is to quantify the loss of fidelity associated with the fact that when attempting to apply any gate with a unitary <span class=""math-container"">$U$</span>, I apply instead the gate</p>
<p><span class=""math-container"">$$
V = R_{i,z}^\dagger(\epsilon)UR_{i,z}(\epsilon)
$$</span></p>
<p>where <span class=""math-container"">$i$</span> is an index of a single qubit.</p>
<p>As a sanity check, I am trying the single qubit case first, where I expect this error to not have any effect, since the initial state of the qubit is <span class=""math-container"">$|0\rangle$</span> and the measurement is in the Z basis. Thus, assuming that the coherent unitary channel acts on the state as <span class=""math-container"">$\mathcal{E}(\rho) = U\rho U^\dagger$</span>, this error should get absorbed into the preperation and measurement and not have any effect on the fidelity.</p>
<p>When I simulate this circuit however, I find that the fidelity <em>does</em> go below 1 as I increase the error. It seems like the qiskit method <code>coherent_unitary_error</code> function from qiskit does not return a QuantumError object which has the effect of applying <span class=""math-container"">$\mathcal{E}(\rho)$</span> as defined above. Does that make sense?</p>
<p>I am including here a self-contained code sample which shows this behavior. One easy way to trigger this effect on and off is to change the <code>optimization_level</code> parameter in line 21 of the attached code. If it is 0, then the two Hadamards don't get merged into one and we see an error. If it is 1 or larger, they get merged and no error appears. Of course, manually adding the Z rotations to the circuit does not lead to an error.</p>
<p>Any ideas? Did I misunderstand how the noise model works, or is there a more fundamental issue here?</p>
<p>Thanks a lot in advance!!</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, transpile
from qiskit.providers.aer import AerSimulator
from qiskit.providers.aer.noise import NoiseModel, coherent_unitary_error

epsilon = 0.1
z_rot = qiskit.circuit.library.U1Gate(epsilon)
z_rot_dg = qiskit.circuit.library.U1Gate(-epsilon)

noise_model = NoiseModel()
noise_model.add_all_qubit_quantum_error(coherent_unitary_error(z_rot), 'u2')
noise_model.add_all_qubit_quantum_error(coherent_unitary_error(z_rot), 'u3')
print(noise_model)
noise_sim = AerSimulator(noise_model=noise_model)

circ = QuantumCircuit(1, 1)
circ.h(0)
circ.h(0)
circ.measure(0, 0)

# change optimization level to 1 to turn off effect of channel
ct = transpile(circ, noise_sim, optimization_level=0) 
print(ct.draw())
nshots=10000
job = noise_sim.run(ct, shots=nshots)
print(job.result().get_counts()['0']/nshots)
<span class=""math-container"">```</span>
</code></pre>
",qc,unexpected effect coherent unitary error qiskit p trying simulate effect coherent unitary z rotation arbitrary angle single qubit fidelity quantum circuit using qiskit aer noisy simulator specifically goal quantify loss fidelity associated fact attempting apply gate unitary span u apply instead gate p span v z z p span index single p sanity check trying single qubit case first expect error effect since initial state qubit span measurement z basis thus assuming coherent unitary channel acts state span e error get absorbed preperation measurement effect p simulate circuit however find fidelity em go 1 increase error seems like qiskit method code function qiskit return quantumerror object effect applying span e defined make sense p including code sample shows behavior one easy way trigger effect change code parameter line 21 attached code 0 two hadamards get merged one see error 1 larger get merged error appears course manually adding z rotations circuit lead p ideas misunderstand noise model works fundamental issue p thanks lot advance pre code import qiskit qiskit import quantumcircuit transpile import aersimulator import noisemodel epsilon epsilon noisemodel print aersimulator circ quantumcircuit 1 1 0 0 0 0 change optimization level 1 turn effect channel ct transpile circ print job ct print 0 span,"[(0, 0.18312809), (2, 0.067591056), (3, 0.14954472), (5, 0.112743095), (9, 0.096677214), (14, 0.3414271), (16, 0.010025496), (18, 0.032591887)]"
20796,,2021-08-09 12:06:49,0,262,"<p>I want to use historical data for 5 stocks from YahooFinance and then calculate mean vector and covariance matrice, so I can optimize them with QAOA. Anyone know what is wrong with this code:
<a href=""https://i.sstatic.net/IFarj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IFarj.png"" alt=""enter image description here"" /></a></p>
","How to use historical data from YahooFinance, calculate mean vector and covariance matrices, so I can optimize them with QAOA?",<programming><qaoa>,1,2,,,"How to use historical data from YahooFinance, calculate mean vector and covariance matrices, so I can optimize them with QAOA? <p>I want to use historical data for 5 stocks from YahooFinance and then calculate mean vector and covariance matrice, so I can optimize them with QAOA. Anyone know what is wrong with this code:
<a href=""https://i.sstatic.net/IFarj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IFarj.png"" alt=""enter image description here"" /></a></p>
",qc,use historical data yahoofinance calculate mean vector covariance matrices optimize qaoa p want use historical data 5 stocks yahoofinance calculate mean vector covariance matrice optimize qaoa anyone know wrong code https nofollow noreferrer img https enter image description,"[(0, 0.34078994), (4, 0.49543077), (11, 0.0352473), (16, 0.09062503), (17, 0.03364384)]"
20830,20833.0,2021-08-13 06:13:17,1,300,"<p>Using lattice surgery technique, CNOT operation can be implemented as follows.</p>
<ul>
<li>step 1. smooth merging between the control qubit and intermediate qubit</li>
<li>step 2. smooth splitting the merged qubit above</li>
<li>step 3. rough merging between the intermediate qubit and target qubit.</li>
</ul>
<p><strong>Steps 2 and 3 can be performed at the same time.</strong> Therefore, we can implement CNOT in <span class=""math-container"">$2d$</span> (<span class=""math-container"">$d$</span> is a distance) QEC cycles(<span class=""math-container"">$d$</span> for smooth merging and <span class=""math-container"">$d$</span> for smooth splitting and rough merging at the same time).</p>
<p>I understood the bold sentence as follows: whether smooth operation on step 2 and merging operation on step 3 is performed first, the CNOT can be performed.</p>
<p>But when we assume rough merging is performed first and smooth splitting after then, the result is <span class=""math-container"">$a_1(a_2|00\rangle+b_2|11\rangle)+b_1(a_2|11\rangle+b_2|00\rangle)$</span> which is not  CNOT operation. Note that control qubit state is <span class=""math-container"">$a_1|0\rangle+b_1|0\rangle$</span> and target qubit state is <span class=""math-container"">$a_2|0\rangle+b_2|0\rangle$</span>.</p>
<p>So I think we should first perform smooth splitting and after <span class=""math-container"">$d$</span> cycle error correction, and then perform rough merging.</p>
<p>How CNOT can be performed in <span class=""math-container"">$2d$</span> error correction cycle and how can merging and splitting be performed at the same time?</p>
",How can surface codes perform splitting and merging at the same time when they implement logical CNOT operation,<error-correction>,1,0,,,"How can surface codes perform splitting and merging at the same time when they implement logical CNOT operation <p>Using lattice surgery technique, CNOT operation can be implemented as follows.</p>
<ul>
<li>step 1. smooth merging between the control qubit and intermediate qubit</li>
<li>step 2. smooth splitting the merged qubit above</li>
<li>step 3. rough merging between the intermediate qubit and target qubit.</li>
</ul>
<p><strong>Steps 2 and 3 can be performed at the same time.</strong> Therefore, we can implement CNOT in <span class=""math-container"">$2d$</span> (<span class=""math-container"">$d$</span> is a distance) QEC cycles(<span class=""math-container"">$d$</span> for smooth merging and <span class=""math-container"">$d$</span> for smooth splitting and rough merging at the same time).</p>
<p>I understood the bold sentence as follows: whether smooth operation on step 2 and merging operation on step 3 is performed first, the CNOT can be performed.</p>
<p>But when we assume rough merging is performed first and smooth splitting after then, the result is <span class=""math-container"">$a_1(a_2|00\rangle+b_2|11\rangle)+b_1(a_2|11\rangle+b_2|00\rangle)$</span> which is not  CNOT operation. Note that control qubit state is <span class=""math-container"">$a_1|0\rangle+b_1|0\rangle$</span> and target qubit state is <span class=""math-container"">$a_2|0\rangle+b_2|0\rangle$</span>.</p>
<p>So I think we should first perform smooth splitting and after <span class=""math-container"">$d$</span> cycle error correction, and then perform rough merging.</p>
<p>How CNOT can be performed in <span class=""math-container"">$2d$</span> error correction cycle and how can merging and splitting be performed at the same time?</p>
",qc,surface codes perform splitting merging time implement logical cnot operation p using lattice surgery technique cnot operation implemented ul li step smooth merging control qubit intermediate qubit li step smooth splitting merged qubit li step rough merging intermediate qubit target p strong steps 2 3 performed therefore implement cnot span 2d span distance qec cycles span smooth merging span smooth splitting rough merging time p understood bold sentence follows whether smooth operation step 2 merging operation step 3 performed first cnot p assume rough merging performed first smooth splitting result span cnot operation note control qubit state span target qubit state span p think first perform smooth splitting span cycle error correction perform rough p cnot performed span 2d error correction cycle merging splitting performed time,"[(3, 0.0934871), (5, 0.17950924), (7, 0.1058343), (13, 0.12641907), (16, 0.11535967), (18, 0.37828073)]"
20881,,2021-08-20 01:00:31,1,146,"<p>We know the calibration data of IBM's quantum devices can be retrieved through the randomized benchmarking method, which is included in Qiskit. However, the calibaration data about gates just gives the average error rate of all the single-qubit gates or two-qubit gates. If I want to get the error rate of a specific single qubit gate, such as H gate, what should I do? The randomized benchmarking method doesn't seem to work.</p>
","How to measure the error rate (or fidelity) of a particular gate (such a H, T) by Qiskit",<qiskit><quantum-gate><error-mitigation>,0,0,,,"How to measure the error rate (or fidelity) of a particular gate (such a H, T) by Qiskit <p>We know the calibration data of IBM's quantum devices can be retrieved through the randomized benchmarking method, which is included in Qiskit. However, the calibaration data about gates just gives the average error rate of all the single-qubit gates or two-qubit gates. If I want to get the error rate of a specific single qubit gate, such as H gate, what should I do? The randomized benchmarking method doesn't seem to work.</p>
",qc,measure error rate fidelity particular gate h qiskit p know calibration data ibm quantum devices retrieved randomized benchmarking method included qiskit however calibaration data gates gives average error rate gates gates want get error rate specific single qubit gate h gate randomized benchmarking method seem,"[(5, 0.21175265), (9, 0.2074939), (11, 0.12881824), (14, 0.39044964), (16, 0.058091234)]"
20894,,2021-08-20 15:17:55,5,3027,"<p>So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system?</p>
<p>Below you can see the code idea:</p>
<pre><code>q1 = QuantumCircuit(2)
q1.save_statevector() # Save initial state
q1.h(0)
q1.save_statevector() # Save state after Hadamard
q1.cx(0, 1)
q1.save_statevector() # Save state after CNOT (also a final state)
job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024)
statevectors = job.result().get_statevector()
</code></pre>
<p>However, if I were to try and run this, an error occurs upon reaching <code>execute</code> command.
If anyone can provide any insight on this, I would be very grateful.</p>
",Saving statevector on more than one location in a quantum circuit in Qiskit,<programming><qiskit><quantum-state><ibm-q-experience>,3,2,,,"Saving statevector on more than one location in a quantum circuit in Qiskit <p>So, I'm fairly new to Qiskit, and I've been playing around and following the tutorials from the Qiskit textbook. However, there is one thing I fail to understand/implement: for a quantum circuit with multiple gates (e.g. 2-qubit circle, with a simple Hadamard acting on qubit 0 and, let's say, CNOT acting on qubit 1 (controlled by qubit 0)) is it possible somehow to save statevectors more than once, in order to see intermediate state of the system?</p>
<p>Below you can see the code idea:</p>
<pre><code>q1 = QuantumCircuit(2)
q1.save_statevector() # Save initial state
q1.h(0)
q1.save_statevector() # Save state after Hadamard
q1.cx(0, 1)
q1.save_statevector() # Save state after CNOT (also a final state)
job = execute(q1, backend=Aer.get_backend('aer_simulator'), shots=1024)
statevectors = job.result().get_statevector()
</code></pre>
<p>However, if I were to try and run this, an error occurs upon reaching <code>execute</code> command.
If anyone can provide any insight on this, I would be very grateful.</p>
",qc,saving statevector one location quantum circuit qiskit p fairly new qiskit playing around following tutorials qiskit textbook however one thing fail quantum circuit multiple gates circle simple hadamard acting qubit 0 let say cnot acting qubit 1 controlled qubit 0 possible somehow save statevectors order see intermediate state system p see code idea pre code q1 quantumcircuit 2 save initial state 0 save state hadamard 0 1 save state cnot also final state job execute q1 statevectors p however try run error occurs upon reaching code execute command anyone provide insight would,"[(2, 0.08355172), (4, 0.022959556), (8, 0.074448936), (14, 0.5955823), (16, 0.025917437), (18, 0.19602053)]"
21001,21010.0,2021-08-28 19:51:23,2,153,"<p>In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, <code>%simulate</code>, and writes out the inputs as key-value pairs, <code>key=value</code>.</p>
<p>For example, if I had some operation, operation <code>HelloHardy (number : Int) : Unit {...}</code>, then I would run the following <code>%simulate HelloHardy number=1729</code>.</p>
<p>I am currently working with the operation, <code>EvaluatePolynomial</code>, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated.</p>
<pre><code>%simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false.

Received invalid parameters. Please fix and try again:

 coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.

 evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.
</code></pre>
",Passing arrays to operations/functions in Q# Jupyter Notebooks,<programming><q#>,1,0,,,"Passing arrays to operations/functions in Q# Jupyter Notebooks <p>In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, <code>%simulate</code>, and writes out the inputs as key-value pairs, <code>key=value</code>.</p>
<p>For example, if I had some operation, operation <code>HelloHardy (number : Int) : Unit {...}</code>, then I would run the following <code>%simulate HelloHardy number=1729</code>.</p>
<p>I am currently working with the operation, <code>EvaluatePolynomial</code>, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated.</p>
<pre><code>%simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false.

Received invalid parameters. Please fix and try again:

 coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.

 evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.
</code></pre>
",qc,passing arrays q jupyter notebooks p order pass inputs q jupyter notebooks one uses magic command code simulate writes inputs pairs code p example operation operation code hellohardy number int unit would run following code simulate hellohardy p currently working operation code evaluatepolynomial part numerics library takes integers arrays doubles booleans running error message pre code simulate evaluatepolynomial received invalid parameters please fix try coefficients error converting value quot quot type 1 path line 1 position evaluationpoints error converting value quot quot type 1 path line 1 position 11,"[(0, 0.35877362), (2, 0.027157994), (3, 0.04288801), (5, 0.035086203), (6, 0.017649058), (12, 0.024476023), (14, 0.39224973), (16, 0.034302045), (19, 0.06609276)]"
21156,21166.0,2021-09-11 16:08:18,2,374,"<p>I'm working on the readout error mitigation on a set of results obtained from different quantum circuits. The method I want to apply is to generate the confusion matrix for each quantum circuit (as the noise might change with time), and then use a filter to reduce readout errors. However, this might cost a long time since for each circuit in my experiment, I need to generate a set of calibration circuits to obtain the confusion matrix. I wonder is there a way I can import real-time error data of quantum devices in qiskit, so I don't need to repeat the standard <a href=""https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html"" rel=""nofollow noreferrer"">error mitigation procedure</a> many times?</p>
<p><strong>Update</strong>: I found one plausible option would be using qiskit runtime program:</p>
<pre><code># Set the &quot;circuit-runner&quot; program parameters
params = provider.runtime.program(program_id=&quot;circuit-runner&quot;).parameters()
params.circuits = qc
params.measurement_error_mitigation = True

</code></pre>
<p>Where I could also specify the physical qubit on the quantum device that I want to use. I don't know if this will automatically mitigate the readout error for that specific physical qubit(s). Also, if I have 100 quantum circuits with 1 qubit, should I consider running them separately (since the error rate might change), or submitting them all at once? Thanks!</p>
",Is there a faster way to do real-time error mitigation in qiskit?,<qiskit><ibm-q-experience><error-mitigation>,1,0,,,"Is there a faster way to do real-time error mitigation in qiskit? <p>I'm working on the readout error mitigation on a set of results obtained from different quantum circuits. The method I want to apply is to generate the confusion matrix for each quantum circuit (as the noise might change with time), and then use a filter to reduce readout errors. However, this might cost a long time since for each circuit in my experiment, I need to generate a set of calibration circuits to obtain the confusion matrix. I wonder is there a way I can import real-time error data of quantum devices in qiskit, so I don't need to repeat the standard <a href=""https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html"" rel=""nofollow noreferrer"">error mitigation procedure</a> many times?</p>
<p><strong>Update</strong>: I found one plausible option would be using qiskit runtime program:</p>
<pre><code># Set the &quot;circuit-runner&quot; program parameters
params = provider.runtime.program(program_id=&quot;circuit-runner&quot;).parameters()
params.circuits = qc
params.measurement_error_mitigation = True

</code></pre>
<p>Where I could also specify the physical qubit on the quantum device that I want to use. I don't know if this will automatically mitigate the readout error for that specific physical qubit(s). Also, if I have 100 quantum circuits with 1 qubit, should I consider running them separately (since the error rate might change), or submitting them all at once? Thanks!</p>
",qc,faster way error mitigation qiskit p working readout error mitigation set results obtained different quantum circuits method want apply generate confusion matrix quantum circuit noise might change time use filter reduce readout errors however might cost long time since circuit experiment need generate set calibration circuits obtain confusion matrix wonder way import error data quantum devices qiskit need repeat standard https nofollow noreferrer error mitigation procedure many times p strong update found one plausible option would using qiskit runtime program pre code set quot quot program parameters params quot quot qc true p could also specify physical qubit quantum device want use know automatically mitigate readout error specific physical qubit also 100 quantum circuits 1 qubit consider running separately since error rate might change submitting thanks,"[(0, 0.041195016), (4, 0.02602754), (5, 0.15318038), (8, 0.06216272), (11, 0.016585043), (14, 0.62767637), (16, 0.015289453), (19, 0.056932405)]"
21197,,2021-09-15 02:40:42,6,116,"<p>I want to investigate the maximum possible parallelism of quantum operations on a specific IBM device (such as the latest heavy-hex architecture), which requires a basic knowledge of their control electronics. I want to know whether individual qubits have their independent control units or share the same control unit， and how the related control constraints restrict the concurrency of quantum gates. I found some control related knowledges about flux-tuable transmon qubits. However, IBM devices are based on fixed-frequency qubits. Are there any relevant reference papers. Thanks a lot!</p>
",Do individual qubits on IBM quantum processors share the same control unit?,<ibm-q-experience><resource-request><experimental-realization><quantum-control>,1,0,,,"Do individual qubits on IBM quantum processors share the same control unit? <p>I want to investigate the maximum possible parallelism of quantum operations on a specific IBM device (such as the latest heavy-hex architecture), which requires a basic knowledge of their control electronics. I want to know whether individual qubits have their independent control units or share the same control unit， and how the related control constraints restrict the concurrency of quantum gates. I found some control related knowledges about flux-tuable transmon qubits. However, IBM devices are based on fixed-frequency qubits. Are there any relevant reference papers. Thanks a lot!</p>
",qc,individual qubits ibm quantum processors share control unit p want investigate maximum possible parallelism quantum operations specific ibm device latest architecture requires basic knowledge control electronics want know whether individual qubits independent control units share control related control constraints restrict concurrency quantum gates found control related knowledges transmon qubits however ibm devices based qubits relevant reference papers thanks lot,"[(4, 0.024729693), (8, 0.32723925), (9, 0.1914936), (16, 0.098341174), (18, 0.3555261)]"
21286,,2021-09-22 09:37:46,1,116,"<p>In TensorFlow Quantum 0.5.0, the support for Cirq gates that have arbitrary control via the <code>gate.controlled_by</code> function is added.</p>
<p>I would like to know which kind of decomposition method is used for this operation? The current decomposition seems to be efficient and any information related to that is very welcomed.</p>
",Decomposition of the multi-controlled gate in tensorflow quantum,<programming><quantum-gate><cirq><tfq>,1,0,,,"Decomposition of the multi-controlled gate in tensorflow quantum <p>In TensorFlow Quantum 0.5.0, the support for Cirq gates that have arbitrary control via the <code>gate.controlled_by</code> function is added.</p>
<p>I would like to know which kind of decomposition method is used for this operation? The current decomposition seems to be efficient and any information related to that is very welcomed.</p>
",qc,decomposition gate tensorflow quantum p tensorflow quantum support cirq gates arbitrary control via code function p would like know kind decomposition method used operation current decomposition seems efficient information related,"[(8, 0.3769486), (9, 0.33978337), (14, 0.2351867), (16, 0.042782623)]"
21345,21349.0,2021-09-27 04:41:36,1,630,"<p>I'm trying to analyze the following quantum circuit</p>
<p><a href=""https://i.sstatic.net/7RkNH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7RkNH.png"" alt=""enter image description here"" /></a></p>
<p>The goal here is to analyze the final outputs at q3 &amp; q4.</p>
<p>For inputs, at q0 &amp; q1, one of the Bell state
<span class=""math-container"">$$|\psi\rangle = \frac{|01\rangle + |10\rangle}{\sqrt{2}}$$</span>
is fed, and at q2, q3, and q4, the GHZ state
<span class=""math-container"">$$|\text{GHZ}\rangle = \frac{|000\rangle + |111\rangle}{\sqrt{2}}$$</span>
is fed.</p>
<p>I am able to construct the matrix representations for the previous 7 operations; for example, passing the first Hadamard gate, we have
<span class=""math-container"">$$M_1 = I\otimes H\otimes I\otimes I\otimes I$$</span>
and passing the first CNOT gate, we have
<span class=""math-container"">$$M_2 = I\otimes\text{CNOT}\otimes I\otimes I$$</span>
so the first two operations are simply <span class=""math-container"">$M_2M_1$</span>, hence I think I can compute the state after these two operations by
<span class=""math-container"">$$M_2M_1(|\psi\rangle\otimes|\text{GHZ}\rangle)$$</span>
(hope I didn't make a mistake up to this point).</p>
<p>However, I fail to see how to construct the matrix for, e.g., the 8th operation, i.e., the &quot;reversed&quot; CNOT gate for q4 &amp; q3 (and the last one for q4 &amp; q0). And since the output might be entangled, I don't see how to calculate the possible outcomes at q3 and q4.</p>
<p>Any suggestions? Thanks.</p>
",How to analyze the following quantum circuit?,<entanglement><measurement><quantum-circuit><matrix-representation>,2,1,,,"How to analyze the following quantum circuit? <p>I'm trying to analyze the following quantum circuit</p>
<p><a href=""https://i.sstatic.net/7RkNH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7RkNH.png"" alt=""enter image description here"" /></a></p>
<p>The goal here is to analyze the final outputs at q3 &amp; q4.</p>
<p>For inputs, at q0 &amp; q1, one of the Bell state
<span class=""math-container"">$$|\psi\rangle = \frac{|01\rangle + |10\rangle}{\sqrt{2}}$$</span>
is fed, and at q2, q3, and q4, the GHZ state
<span class=""math-container"">$$|\text{GHZ}\rangle = \frac{|000\rangle + |111\rangle}{\sqrt{2}}$$</span>
is fed.</p>
<p>I am able to construct the matrix representations for the previous 7 operations; for example, passing the first Hadamard gate, we have
<span class=""math-container"">$$M_1 = I\otimes H\otimes I\otimes I\otimes I$$</span>
and passing the first CNOT gate, we have
<span class=""math-container"">$$M_2 = I\otimes\text{CNOT}\otimes I\otimes I$$</span>
so the first two operations are simply <span class=""math-container"">$M_2M_1$</span>, hence I think I can compute the state after these two operations by
<span class=""math-container"">$$M_2M_1(|\psi\rangle\otimes|\text{GHZ}\rangle)$$</span>
(hope I didn't make a mistake up to this point).</p>
<p>However, I fail to see how to construct the matrix for, e.g., the 8th operation, i.e., the &quot;reversed&quot; CNOT gate for q4 &amp; q3 (and the last one for q4 &amp; q0). And since the output might be entangled, I don't see how to calculate the possible outcomes at q3 and q4.</p>
<p>Any suggestions? Thanks.</p>
",qc,analyze following quantum circuit p trying analyze following quantum circuit p https nofollow noreferrer img https enter image description p goal analyze final outputs q3 amp p inputs q0 amp q1 one bell state span 2 fed q2 q3 q4 ghz state span ghz 2 p able construct matrix representations previous 7 operations example passing first hadamard gate span passing first cnot gate span cnot first two operations simply span hence think compute state two operations span ghz hope make mistake point p however fail see construct matrix 8th operation quot reversed quot cnot gate q4 amp q3 last one q4 amp q0 since output might entangled see calculate possible outcomes q3 p suggestions,"[(3, 0.057562243), (4, 0.16353266), (6, 0.010534289), (14, 0.29468384), (15, 0.06467039), (16, 0.029129712), (18, 0.3418122), (19, 0.029088086)]"
21364,,2021-09-28 18:49:20,0,130,"<p>Why are not the same unitary matrices in ProjectQ and Qiskit in the following codes:</p>
<h3>ProjectQ:</h3>
<pre><code>drawing_engine = CircuitDrawerMatplotlib()

eng = MainEngine(backend = UnitarySimulator(), engine_list = [drawing_engine]+get_engine_list())
qreg = eng.allocate_qureg(3)

theta1 = pi/4

theta2 = pi/5

X | qreg[2]  

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta2) | qreg[0]  

X | qreg[1] 

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta1) | qreg[0]      

X | qreg[2]  

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta2) | qreg[0]  

X | qreg[1] 

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta1) | qreg[0]    

X | qreg[2]  

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta2) | qreg[0]  

X | qreg[1] 

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta1) | qreg[0]  

eng.flush()

print(eng.backend.unitary.real) 
</code></pre>
<h3>Qiskit:</h3>
<pre><code>qreg = QuantumRegister(3) 

creg = ClassicalRegister(3) 

circuit = QuantumCircuit(qreg,creg)

theta1 = pi/4

theta2 = pi/5

circuit.x(qreg[2])    

circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) 
 
circuit.x(qreg[1])

circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) 

circuit.x(qreg[2])    

circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) 
 
circuit.x(qreg[1])

circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) 

circuit.x(qreg[2])    

circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None)  

circuit.x(qreg[1])

circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) 

job = execute(circuit,Aer.get_backend('unitary_simulator'),optimization_level=0)
unitary_matrix=job.result().get_unitary(circuit,decimals=8)

unitary_matrix.real
</code></pre>
",The difference between the unitary matrix in ProjectQ and Qiskit,<qiskit><programming><projectq>,0,3,,,"The difference between the unitary matrix in ProjectQ and Qiskit <p>Why are not the same unitary matrices in ProjectQ and Qiskit in the following codes:</p>
<h3>ProjectQ:</h3>
<pre><code>drawing_engine = CircuitDrawerMatplotlib()

eng = MainEngine(backend = UnitarySimulator(), engine_list = [drawing_engine]+get_engine_list())
qreg = eng.allocate_qureg(3)

theta1 = pi/4

theta2 = pi/5

X | qreg[2]  

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta2) | qreg[0]  

X | qreg[1] 

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta1) | qreg[0]      

X | qreg[2]  

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta2) | qreg[0]  

X | qreg[1] 

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta1) | qreg[0]    

X | qreg[2]  

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta2) | qreg[0]  

X | qreg[1] 

with Control(eng, [qreg[2],qreg[1]]):

    Ry(2*theta1) | qreg[0]  

eng.flush()

print(eng.backend.unitary.real) 
</code></pre>
<h3>Qiskit:</h3>
<pre><code>qreg = QuantumRegister(3) 

creg = ClassicalRegister(3) 

circuit = QuantumCircuit(qreg,creg)

theta1 = pi/4

theta2 = pi/5

circuit.x(qreg[2])    

circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) 
 
circuit.x(qreg[1])

circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) 

circuit.x(qreg[2])    

circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None) 
 
circuit.x(qreg[1])

circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) 

circuit.x(qreg[2])    

circuit.mcry(2*theta2,[ qreg[2], qreg[1] ],qreg[0],None)  

circuit.x(qreg[1])

circuit.mcry(2*theta1,[ qreg[2], qreg[1] ],qreg[0],None) 

job = execute(circuit,Aer.get_backend('unitary_simulator'),optimization_level=0)
unitary_matrix=job.result().get_unitary(circuit,decimals=8)

unitary_matrix.real
</code></pre>
",qc,difference unitary matrix projectq qiskit p unitary matrices projectq qiskit following codes h3 projectq pre code circuitdrawermatplotlib eng mainengine backend unitarysimulator qreg 3 theta1 theta2 x qreg 2 control eng qreg 2 qreg 1 ry 2 theta2 qreg 0 x qreg 1 control eng qreg 2 qreg 1 ry 2 theta1 qreg 0 x qreg 2 control eng qreg 2 qreg 1 ry 2 theta2 qreg 0 x qreg 1 control eng qreg 2 qreg 1 ry 2 theta1 qreg 0 x qreg 2 control eng qreg 2 qreg 1 ry 2 theta2 qreg 0 x qreg 1 control eng qreg 2 qreg 1 ry 2 theta1 qreg 0 print h3 qiskit pre code qreg quantumregister 3 creg classicalregister 3 circuit quantumcircuit qreg creg theta1 theta2 qreg 2 2 theta2 qreg 2 qreg 1 qreg 0 none qreg 1 2 theta1 qreg 2 qreg 1 qreg 0 none qreg 2 2 theta2 qreg 2 qreg 1 qreg 0 none qreg 1 2 theta1 qreg 2 qreg 1 qreg 0 none qreg 2 2 theta2 qreg 2 qreg 1 qreg 0 none qreg 1 2 theta1 qreg 2 qreg 1 qreg 0 none job execute circuit circuit,"[(0, 0.08341379), (2, 0.752712), (10, 0.12412037), (14, 0.023379901), (16, 0.015554835)]"
21400,,2021-10-04 01:52:00,3,776,"<p>Consider the following problem from Nielsen and Chuang's <em>Quantum Computation and Quantum Information</em>:</p>
<blockquote>
<p>Explain how a device which, upon input of one of two non-orthogonal quantum states <span class=""math-container"">$\left|\psi\right&gt;$</span> or <span class=""math-container"">$\left|\phi\right&gt;$</span> correctly identified the state, could be used to build a device which cloned the states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>, in violation of the no-cloning theorem. Conversely, explain how a device for cloning could be used to distinguish non-orthogonal quantum states.</p>
</blockquote>
<p>I know that this problem has already been posted at least two times <a href=""https://quantumcomputing.stackexchange.com/questions/2255/no-cloning-theorem-and-distinguishing-between-two-non-orthogonal-quantum-states?newreg=3a9bbf46be5e465189d256a01fc3f21e"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/6538/cloning-quantum-states-with-a-device-that-distinguishes-between-two-non-orthogon"">here</a>, but I am not satisfied with the answers to the first part given there. As you can see, all answers to the first part basically tell you to use the device to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span> and then just prepare an identical state. However, nowhere does this exercise say that we know how to prepare states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. Moreover, preparing an identical state is not the same as cloning. A cloning device has to be able to replicate a state without having any prior knowledge about its &quot;internal&quot; structure. With this in mind, I am posting this problem once again.</p>
<p>Here is my attempt to address this problem. Let us say that we have two non-orthogonal states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. We can measure <span class=""math-container"">$\left|\phi\right&gt;$</span> in the basis of <span class=""math-container"">$\left|\psi\right&gt;$</span>, and feed the result to our magical device. Since <span class=""math-container"">$\left|\phi\right&gt;$</span> is non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, there is non-zero probability that measurement will give us another <span class=""math-container"">$\left|\psi\right&gt;$</span>. In this case the device will identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, which means we have created a clone. If the measurement projects <span class=""math-container"">$\left|\phi\right&gt;$</span> to some other state <span class=""math-container"">$\left|\psi'\right&gt;$</span>, orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, then the device will not identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, and we can repeat the process by measuring <span class=""math-container"">$\left|\psi'\right&gt;$</span> again in the basis of <span class=""math-container"">$\left|\phi\right&gt;$</span>, which will create another state non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>.</p>
<p>This solution is also quite flimsy for the following reasons. First, I am not sure if an arbitrary unknown state can be used as a basis for measurement. Second, this solution never actually used the device to distinguish between <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span>. It only used it to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and not <span class=""math-container"">$\left|\psi\right&gt;$</span>, but it is unclear what happens if we try to feed a state other than <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span> to the device, so this way was probably not implied by the authors of the exercise.</p>
<p>Any ideas?</p>
",Using distinguishability of non-orthogonal states to create a cloning device,<textbook-and-exercises><no-cloning-theorem>,2,0,,,"Using distinguishability of non-orthogonal states to create a cloning device <p>Consider the following problem from Nielsen and Chuang's <em>Quantum Computation and Quantum Information</em>:</p>
<blockquote>
<p>Explain how a device which, upon input of one of two non-orthogonal quantum states <span class=""math-container"">$\left|\psi\right&gt;$</span> or <span class=""math-container"">$\left|\phi\right&gt;$</span> correctly identified the state, could be used to build a device which cloned the states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>, in violation of the no-cloning theorem. Conversely, explain how a device for cloning could be used to distinguish non-orthogonal quantum states.</p>
</blockquote>
<p>I know that this problem has already been posted at least two times <a href=""https://quantumcomputing.stackexchange.com/questions/2255/no-cloning-theorem-and-distinguishing-between-two-non-orthogonal-quantum-states?newreg=3a9bbf46be5e465189d256a01fc3f21e"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/6538/cloning-quantum-states-with-a-device-that-distinguishes-between-two-non-orthogon"">here</a>, but I am not satisfied with the answers to the first part given there. As you can see, all answers to the first part basically tell you to use the device to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span> and then just prepare an identical state. However, nowhere does this exercise say that we know how to prepare states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. Moreover, preparing an identical state is not the same as cloning. A cloning device has to be able to replicate a state without having any prior knowledge about its &quot;internal&quot; structure. With this in mind, I am posting this problem once again.</p>
<p>Here is my attempt to address this problem. Let us say that we have two non-orthogonal states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. We can measure <span class=""math-container"">$\left|\phi\right&gt;$</span> in the basis of <span class=""math-container"">$\left|\psi\right&gt;$</span>, and feed the result to our magical device. Since <span class=""math-container"">$\left|\phi\right&gt;$</span> is non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, there is non-zero probability that measurement will give us another <span class=""math-container"">$\left|\psi\right&gt;$</span>. In this case the device will identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, which means we have created a clone. If the measurement projects <span class=""math-container"">$\left|\phi\right&gt;$</span> to some other state <span class=""math-container"">$\left|\psi'\right&gt;$</span>, orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, then the device will not identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, and we can repeat the process by measuring <span class=""math-container"">$\left|\psi'\right&gt;$</span> again in the basis of <span class=""math-container"">$\left|\phi\right&gt;$</span>, which will create another state non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>.</p>
<p>This solution is also quite flimsy for the following reasons. First, I am not sure if an arbitrary unknown state can be used as a basis for measurement. Second, this solution never actually used the device to distinguish between <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span>. It only used it to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and not <span class=""math-container"">$\left|\psi\right&gt;$</span>, but it is unclear what happens if we try to feed a state other than <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span> to the device, so this way was probably not implied by the authors of the exercise.</p>
<p>Any ideas?</p>
",qc,using distinguishability states create cloning device p consider following problem nielsen chuang em quantum computation quantum information blockquote p explain device upon input one two quantum states span gt span gt correctly identified state could used build device cloned states span gt span gt violation theorem conversely explain device cloning could used distinguish quantum p know problem already posted least two times https https satisfied answers first part given see answers first part basically tell use device distinguish span gt span gt prepare identical state however nowhere exercise say know prepare states span gt span gt moreover preparing identical state cloning cloning device able replicate state without prior knowledge quot internal quot structure mind posting problem p attempt address problem let us say two states span gt span gt measure span gt basis span gt feed result magical device since span gt span gt probability measurement give us another span gt case device identify span gt means created clone measurement projects span gt state span gt orthogonal span gt device identify span gt repeat process measuring span gt basis span gt create another state span gt p solution also quite flimsy following reasons first sure arbitrary unknown state used basis measurement second solution never actually used device distinguish span gt span gt used distinguish span gt span gt unclear happens try feed state span gt span gt device way probably implied authors p ideas,"[(0, 0.11069025), (3, 0.30719745), (7, 0.029707717), (13, 0.15161131), (14, 0.0245048), (16, 0.044966776), (17, 0.032038674), (18, 0.2912226)]"
21414,21416.0,2021-10-05 07:53:58,1,2159,"<p>As in the computer world, not all programming languages are suitable for everything.</p>
<p><strong>Php</strong> = Backend<br />
<strong>Javascript</strong> = Frontend<br />
<strong>Data Analsys/ML</strong> = Python<br />
<strong>embedded systems</strong> = C<br />
<strong>Mobilphone/apps</strong> = Android / Swift</p>
<p>As far as I know not all quantum languages solve the same problems. I would like to know which framework(qiskit, cirq..) would be suitable for optimisation problems (for example Travel Salesman Problem).</p>
",Which quantum computing frame is suitable for optimization problems?,<qiskit><programming><q#><cirq>,3,1,,,"Which quantum computing frame is suitable for optimization problems? <p>As in the computer world, not all programming languages are suitable for everything.</p>
<p><strong>Php</strong> = Backend<br />
<strong>Javascript</strong> = Frontend<br />
<strong>Data Analsys/ML</strong> = Python<br />
<strong>embedded systems</strong> = C<br />
<strong>Mobilphone/apps</strong> = Android / Swift</p>
<p>As far as I know not all quantum languages solve the same problems. I would like to know which framework(qiskit, cirq..) would be suitable for optimisation problems (for example Travel Salesman Problem).</p>
",qc,quantum computing frame suitable optimization problems p computer world programming languages suitable p strong php backend br strong javascript frontend br strong data python br strong embedded systems c br strong android swift p far know quantum languages solve problems would like know framework qiskit cirq would suitable optimisation problems example travel salesman problem,"[(0, 0.08042179), (1, 0.20167366), (8, 0.4369121), (9, 0.038990166), (13, 0.21707125), (16, 0.022024937)]"
21446,21447.0,2021-10-07 13:27:40,4,251,"<p>I just want to know if there is a specific name for the implementation of a gate on the top qubit with the help of the bottom qubit, represented on this image:</p>
<p><a href=""https://i.sstatic.net/PwViG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PwViG.png"" alt=""enter image description here"" /></a></p>
<p>It looks like gate teleportation but it is not as you do not need Bell states. The ancilla state is: <span class=""math-container"">$|A_{\theta}\rangle \equiv U_z(\theta) |+ \rangle$</span></p>
<p>You can find such circuit in <a href=""https://arxiv.org/abs/quant-ph/0504218"" rel=""nofollow noreferrer"">this paper</a> (page 28).</p>
","What is the name of this ""ancilla based"" process to implement gates",<quantum-gate><teleportation><terminology-and-notation>,2,0,,,"What is the name of this ""ancilla based"" process to implement gates <p>I just want to know if there is a specific name for the implementation of a gate on the top qubit with the help of the bottom qubit, represented on this image:</p>
<p><a href=""https://i.sstatic.net/PwViG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PwViG.png"" alt=""enter image description here"" /></a></p>
<p>It looks like gate teleportation but it is not as you do not need Bell states. The ancilla state is: <span class=""math-container"">$|A_{\theta}\rangle \equiv U_z(\theta) |+ \rangle$</span></p>
<p>You can find such circuit in <a href=""https://arxiv.org/abs/quant-ph/0504218"" rel=""nofollow noreferrer"">this paper</a> (page 28).</p>
",qc,name ancilla based process implement gates p want know specific name implementation gate top qubit help bottom qubit represented image p https nofollow noreferrer img https enter image description p looks like gate teleportation need bell states ancilla state span p find circuit https nofollow noreferrer paper page 28,"[(4, 0.49527588), (13, 0.19844763), (16, 0.020517236), (18, 0.28250688)]"
21497,,2021-10-11 00:33:28,1,100,"<p>I'm looking at the source code for the Qiskit Experiments module and see that the EFRabi class subclasses the Rabi class with the intent of calibrating rotations between the 1 and 2 states instead of between 0 and 1. The only change I see in the circuit is the addition of an X gate at the beginning. How could this be done for other calibration experiments, e.g. one of the FineAmplitude experiments? Why does the X gate allow us to calibrate on higher energy states?</p>
",Working with higher energy states in Qiskit Experiments,<qiskit><programming><quantum-state><quantum-circuit><experimental-realization>,0,0,,,"Working with higher energy states in Qiskit Experiments <p>I'm looking at the source code for the Qiskit Experiments module and see that the EFRabi class subclasses the Rabi class with the intent of calibrating rotations between the 1 and 2 states instead of between 0 and 1. The only change I see in the circuit is the addition of an X gate at the beginning. How could this be done for other calibration experiments, e.g. one of the FineAmplitude experiments? Why does the X gate allow us to calibrate on higher energy states?</p>
",qc,working higher energy states qiskit experiments p looking source code qiskit experiments module see efrabi class subclasses rabi class intent calibrating rotations 1 2 states instead 0 change see circuit addition x gate beginning could done calibration experiments one fineamplitude experiments x gate allow us calibrate higher energy states,"[(0, 0.07695067), (2, 0.06713051), (10, 0.045319412), (14, 0.5479013), (16, 0.021940146), (17, 0.08671597), (18, 0.15122512)]"
21498,,2021-10-11 01:53:48,5,418,"<p>I'm learning surface codes from a theoretical perspective. In all the literature I read, they just introduced the dual lattice for working with <span class=""math-container"">$Z$</span> strings without many words addressing why we need to do this. And it seems to me that all the stuff they did on the dual lattice can be done in the original lattice.</p>
<p>I can think of two needs for using dual lattice. One is that we only have measure qubits on the facets so need to switch to dual lattice to measure the other set of stabilizers. The other is to make the drawing more clear to the readers.</p>
<p>Are there any deeper mathematical or theoretical motivations?</p>
<p>Literature I have read: <em>An Introduction to Topological Quantum Codes</em> by Bombin; <em>Quantum Error Correction for Beginners</em> by Devitt et al.; <em>Surface codes: Towards practical large-scale quantum computation</em> by Fowler et al.</p>
",What is the motivation for using dual lattice in the surface code?,<error-correction><stabilizer-code><surface-code>,1,0,,,"What is the motivation for using dual lattice in the surface code? <p>I'm learning surface codes from a theoretical perspective. In all the literature I read, they just introduced the dual lattice for working with <span class=""math-container"">$Z$</span> strings without many words addressing why we need to do this. And it seems to me that all the stuff they did on the dual lattice can be done in the original lattice.</p>
<p>I can think of two needs for using dual lattice. One is that we only have measure qubits on the facets so need to switch to dual lattice to measure the other set of stabilizers. The other is to make the drawing more clear to the readers.</p>
<p>Are there any deeper mathematical or theoretical motivations?</p>
<p>Literature I have read: <em>An Introduction to Topological Quantum Codes</em> by Bombin; <em>Quantum Error Correction for Beginners</em> by Devitt et al.; <em>Surface codes: Towards practical large-scale quantum computation</em> by Fowler et al.</p>
",qc,motivation using dual lattice surface code p learning surface codes theoretical perspective literature read introduced dual lattice working span z strings without many words addressing need seems stuff dual lattice done original p think two needs using dual lattice one measure qubits facets need switch dual lattice measure set stabilizers make drawing clear p deeper mathematical theoretical motivations p literature read em introduction topological quantum codes bombin em quantum error correction beginners devitt et al em surface codes towards practical quantum computation fowler et,"[(5, 0.22829884), (7, 0.335987), (8, 0.06226302), (9, 0.27172533), (13, 0.03764162), (16, 0.062359113)]"
21807,21828.0,2021-11-05 09:08:25,3,540,"<p>I hope this is the right place to ask this kind of question. I'm using the Aer simulator in Qiskit to analyze the state vector of some circuits. My program is very parallelizable, but when I try to run these qiskit calculations in parallel (using the multiprocessing library in python), in certain situations the call to Qiskit to simulate the circuit hangs indefinitely. For instance, I may have something like this:</p>
<pre><code>from multiprocessing import Pool

def parallel(circ2):
    
    simulator2 = Aer.get_backend('aer_simulator')
    result2 = simulator.run(circ2).result()
    print(result2)

circ1 = ... #some kind of circuit
simulator1 = Aer.get_backend('aer_simulator')
result1 = simulator1.run(circ1).result()
print(result1)


circs_arr = [...] #some list of different circuits
with Pool(5) as p:
    p.map(parallel,circs_arr)
</code></pre>
<p>The above code does not work. The parallelized call to run the circuit (within the function) hangs indefinitely. However, if I remove the first run of the simulator (that produces result1), then everything is fine and works as expected. Does anyone know how I can fix this? I've read that the problem might have something to do with qiskit Aer utilizing multiprocessing for its own purposes, so using running Aer with multiprocessing can cause a conflict. However, my attempts to turn off qiskit's internal multiprocessing have not worked, or have not fixed my problem.</p>
",Parallelizing Qiskit not working,<qiskit>,1,1,,,"Parallelizing Qiskit not working <p>I hope this is the right place to ask this kind of question. I'm using the Aer simulator in Qiskit to analyze the state vector of some circuits. My program is very parallelizable, but when I try to run these qiskit calculations in parallel (using the multiprocessing library in python), in certain situations the call to Qiskit to simulate the circuit hangs indefinitely. For instance, I may have something like this:</p>
<pre><code>from multiprocessing import Pool

def parallel(circ2):
    
    simulator2 = Aer.get_backend('aer_simulator')
    result2 = simulator.run(circ2).result()
    print(result2)

circ1 = ... #some kind of circuit
simulator1 = Aer.get_backend('aer_simulator')
result1 = simulator1.run(circ1).result()
print(result1)


circs_arr = [...] #some list of different circuits
with Pool(5) as p:
    p.map(parallel,circs_arr)
</code></pre>
<p>The above code does not work. The parallelized call to run the circuit (within the function) hangs indefinitely. However, if I remove the first run of the simulator (that produces result1), then everything is fine and works as expected. Does anyone know how I can fix this? I've read that the problem might have something to do with qiskit Aer utilizing multiprocessing for its own purposes, so using running Aer with multiprocessing can cause a conflict. However, my attempts to turn off qiskit's internal multiprocessing have not worked, or have not fixed my problem.</p>
",qc,parallelizing qiskit working p hope right place ask kind question using aer simulator qiskit analyze state vector circuits program parallelizable try run qiskit calculations parallel using multiprocessing library python certain situations call qiskit simulate circuit hangs indefinitely instance may something like pre code multiprocessing import pool def parallel circ2 simulator2 result2 circ2 print result2 circ1 kind circuit simulator1 result1 circ1 print result1 list different circuits pool 5 p parallel p code work parallelized call run circuit within function hangs indefinitely however remove first run simulator produces result1 everything fine works expected anyone know fix read problem might something qiskit aer utilizing multiprocessing purposes using running aer multiprocessing cause conflict however attempts turn qiskit internal multiprocessing worked fixed,"[(0, 0.094248176), (2, 0.039004836), (8, 0.016024916), (13, 0.1479722), (14, 0.61796045), (16, 0.049116116), (19, 0.03448073)]"
21895,,2021-11-11 22:29:59,4,154,"<p>I was reading about the Toric code and how the boundary codes give it a shape of of a torus. Is it interesting to look at other ways to orient the edges of a square lattice? I.e. a mobius strip, Klein bottle, projective plane. Or are these not useful because objects like the Klein Bottle or projective plane don't exist in real life?</p>
","Is it interesting to look at surface codes where the boundary conditions give the shape of a Mobius strip, Klein bottle, or the projective plane?",<error-correction><surface-code>,0,1,,,"Is it interesting to look at surface codes where the boundary conditions give the shape of a Mobius strip, Klein bottle, or the projective plane? <p>I was reading about the Toric code and how the boundary codes give it a shape of of a torus. Is it interesting to look at other ways to orient the edges of a square lattice? I.e. a mobius strip, Klein bottle, projective plane. Or are these not useful because objects like the Klein Bottle or projective plane don't exist in real life?</p>
",qc,interesting look surface codes boundary conditions give shape mobius strip klein bottle projective plane p reading toric code boundary codes give shape torus interesting look ways orient edges square lattice mobius strip klein bottle projective plane useful objects like klein bottle projective plane exist real life,"[(5, 0.25309938), (9, 0.31292728), (13, 0.20361921), (14, 0.13827445), (16, 0.0288312), (17, 0.059269153)]"
21994,22005.0,2021-11-19 17:51:29,8,334,"<p>I have been checking out the parameters of the new <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;system=ibm_washington"" rel=""noreferrer"">ibm_washington processor</a> and I have the following doubt about the calibration data provided by them. Checking out the relaxation and dephasing times I found out that some of their qubits are said to have <span class=""math-container"">$T_2&gt;2T_1$</span>. For example, see qubits Q2 or Q21. I understand that the dephasing times they provide are the ones obtained by Ramsey's experiments. However, relaxation and dephasing times are related by the expression
<span class=""math-container"">\begin{equation}
\frac{1}{T_2}=\frac{1}{2T_1}+\frac{1}{T_\phi},
\end{equation}</span>
where <span class=""math-container"">$T_\phi$</span> is the pure dephasing time. From this equation, it can be seen that qubits that have <span class=""math-container"">$T_2&gt;2T_1$</span> make no physical sense since that would imply that the pure dephasing time is negative. Therefore, I am wondering what's going on with the decoherence time values that are being provided by IBM for the newest processor. I have thought about measurement error, but qubits Q2 and Q21 are not even close to the Ramsey limit <span class=""math-container"">$T_2\approx 2T_1$</span>. Maybe that due to the novelty of the system the data is not still accurate? Or may I be missing something?</p>
",$T_2>2T_1$ qubits on the ibm_washington quantum processor,<ibm-q-experience><decoherence>,1,0,,,"$T_2>2T_1$ qubits on the ibm_washington quantum processor <p>I have been checking out the parameters of the new <a href=""https://quantum-computing.ibm.com/services?services=systems&amp;system=ibm_washington"" rel=""noreferrer"">ibm_washington processor</a> and I have the following doubt about the calibration data provided by them. Checking out the relaxation and dephasing times I found out that some of their qubits are said to have <span class=""math-container"">$T_2&gt;2T_1$</span>. For example, see qubits Q2 or Q21. I understand that the dephasing times they provide are the ones obtained by Ramsey's experiments. However, relaxation and dephasing times are related by the expression
<span class=""math-container"">\begin{equation}
\frac{1}{T_2}=\frac{1}{2T_1}+\frac{1}{T_\phi},
\end{equation}</span>
where <span class=""math-container"">$T_\phi$</span> is the pure dephasing time. From this equation, it can be seen that qubits that have <span class=""math-container"">$T_2&gt;2T_1$</span> make no physical sense since that would imply that the pure dephasing time is negative. Therefore, I am wondering what's going on with the decoherence time values that are being provided by IBM for the newest processor. I have thought about measurement error, but qubits Q2 and Q21 are not even close to the Ramsey limit <span class=""math-container"">$T_2\approx 2T_1$</span>. Maybe that due to the novelty of the system the data is not still accurate? Or may I be missing something?</p>
",qc,qubits quantum processor p checking parameters new https amp noreferrer processor following doubt calibration data provided checking relaxation dephasing times found qubits said span gt example see qubits q2 q21 understand dephasing times provide ones obtained ramsey experiments however relaxation dephasing times related expression span equation 1 1 1 equation span pure dephasing time equation seen qubits span gt make physical sense since would imply pure dephasing time negative therefore wondering going decoherence time values provided ibm newest processor thought measurement error qubits q2 q21 even close ramsey limit span maybe due novelty system data still accurate may missing something,"[(3, 0.29527274), (4, 0.0605809), (5, 0.13776861), (8, 0.16280593), (9, 0.10690668), (14, 0.20630977), (15, 0.016903337), (16, 0.012204127)]"
22052,22053.0,2021-11-25 06:05:12,2,139,"<p>For a three qubits system to be in an entanglement(GHZ) state, the circuit can be built as per Qiskit,</p>
<p><a href=""https://i.sstatic.net/b20YU.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/b20YU.png"" alt=""GHZ state way 1"" /></a></p>
<p>Here, the control bit of the second X gate is on q0. what if the control bit is shifted to q1. This also leads to entanglement. what is the difference between the two different ways?</p>
<p>Further to my question, I did the same for 5 qubits, I get different results:
<a href=""https://i.sstatic.net/7BCJ4.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7BCJ4.jpg"" alt=""image1_samecontrol_bit"" /></a>
<a href=""https://i.sstatic.net/Wpgf8.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Wpgf8.jpg"" alt=""image_different_control_bits"" /></a></p>
<p>which one is correct?</p>
",What is the difference between the two entanglement circuits?,<qiskit><entanglement><quantum-circuit>,1,0,,,"What is the difference between the two entanglement circuits? <p>For a three qubits system to be in an entanglement(GHZ) state, the circuit can be built as per Qiskit,</p>
<p><a href=""https://i.sstatic.net/b20YU.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/b20YU.png"" alt=""GHZ state way 1"" /></a></p>
<p>Here, the control bit of the second X gate is on q0. what if the control bit is shifted to q1. This also leads to entanglement. what is the difference between the two different ways?</p>
<p>Further to my question, I did the same for 5 qubits, I get different results:
<a href=""https://i.sstatic.net/7BCJ4.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7BCJ4.jpg"" alt=""image1_samecontrol_bit"" /></a>
<a href=""https://i.sstatic.net/Wpgf8.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Wpgf8.jpg"" alt=""image_different_control_bits"" /></a></p>
<p>which one is correct?</p>
",qc,difference two entanglement circuits p three qubits system entanglement ghz state circuit built per qiskit p https nofollow noreferrer img https ghz state way 1 p control bit second x gate q0 control bit shifted q1 also leads entanglement difference two different ways p question 5 qubits get different results https nofollow noreferrer img https https nofollow noreferrer img https p one correct,"[(4, 0.4869144), (10, 0.016907807), (14, 0.079225376), (16, 0.03238903), (18, 0.38218954)]"
22143,22145.0,2021-11-30 17:49:13,4,587,"<p>Consider a 2D cluster state defined on a rectangular lattice, which is universal for one way quantum computers. For a description of the state, see for example question 2 in <a href=""https://www.physik.fu-berlin.de/en/einrichtungen/ag/ag-eisert/teaching/ws20-21/problem11.pdf"" rel=""nofollow noreferrer"">this problem set</a>.</p>
<p>Now, consider a bipartition of this state and look at the entanglement entropy of each partition. Does the entropy follow a volume law or an area law?</p>
",Does entanglement entropy follow a volume or an area law for 2D cluster states?,<quantum-state><entanglement><measurement><entropy>,1,0,,,"Does entanglement entropy follow a volume or an area law for 2D cluster states? <p>Consider a 2D cluster state defined on a rectangular lattice, which is universal for one way quantum computers. For a description of the state, see for example question 2 in <a href=""https://www.physik.fu-berlin.de/en/einrichtungen/ag/ag-eisert/teaching/ws20-21/problem11.pdf"" rel=""nofollow noreferrer"">this problem set</a>.</p>
<p>Now, consider a bipartition of this state and look at the entanglement entropy of each partition. Does the entropy follow a volume law or an area law?</p>
",qc,entanglement entropy follow volume area law 2d cluster states p consider 2d cluster state defined rectangular lattice universal one way quantum computers description state see example question 2 https nofollow noreferrer problem set p consider bipartition state look entanglement entropy partition entropy follow volume law area law,"[(1, 0.050586898), (3, 0.2604947), (4, 0.06389819), (5, 0.02468614), (9, 0.33118555), (13, 0.07573479), (14, 0.047282334), (16, 0.021435577), (18, 0.12236325)]"
22203,,2021-12-06 14:14:29,3,786,"<p>I'm trying to run a series of circuits in a job and I keep getting this error message which I haven't been able to find the meaning of anywhere in qiskit's documentation, online, etc. The job appears to run for 15 minutes and only then does an error appear... Anyone have any clue as to what this could be? The job consists of batches of circuits where each batch is just a certain circuit repeated a different number of times (before measurement), so I don't see any obvious reason why the circuits from one batch work fine but not from another.
<a href=""https://i.sstatic.net/1mXDM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/1mXDM.png"" alt=""Error message"" /></a></p>
",'Internal error. Error code 9999' when running job on IBMQ,<qiskit><programming><ibm-q-experience><experimental-realization>,2,1,,,"'Internal error. Error code 9999' when running job on IBMQ <p>I'm trying to run a series of circuits in a job and I keep getting this error message which I haven't been able to find the meaning of anywhere in qiskit's documentation, online, etc. The job appears to run for 15 minutes and only then does an error appear... Anyone have any clue as to what this could be? The job consists of batches of circuits where each batch is just a certain circuit repeated a different number of times (before measurement), so I don't see any obvious reason why the circuits from one batch work fine but not from another.
<a href=""https://i.sstatic.net/1mXDM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/1mXDM.png"" alt=""Error message"" /></a></p>
",qc,error error code 9999 running job ibmq p trying run series circuits job keep getting error message able find meaning anywhere qiskit documentation online etc job appears run 15 minutes error appear anyone clue could job consists batches circuits batch certain circuit repeated different number times measurement see obvious reason circuits one batch work fine another https nofollow noreferrer img https error message,"[(0, 0.06772816), (4, 0.11873695), (5, 0.09461001), (6, 0.014660687), (13, 0.05981083), (14, 0.61125654), (16, 0.031104432)]"
22252,,2021-12-11 19:22:28,4,126,"<p>Start with an <span class=""math-container"">$n \times n$</span> lattice, with each qubit initialized to the state <span class=""math-container"">$|0\rangle$</span>. Then, apply the Hadamard gate on each qubit. Then, evolve the system under the Hamiltonian
<span class=""math-container"">\begin{equation}
    H = \sum_{l, m \in [n]} \text{Z}_l \text{Z}_m,
\end{equation}</span>
for <span class=""math-container"">$d$</span> time steps.
Note that the final state of the Hamiltonian can be written as
<span class=""math-container"">\begin{equation}
    |\psi\rangle_{\text{final}} = \frac{1}{\sqrt{2^{n^{2}}}} \sum_{x \in \{0, 1\}^{n^{2}}} \sum_{l, m \in [n]} e^{-i d (-1)^{x_l + x_m}} |x\rangle,
\end{equation}</span>
where <span class=""math-container"">$x_i$</span> is the <span class=""math-container"">$i^{\text{th}}$</span> bit of <span class=""math-container"">$x$</span>.</p>
<p>I could not formally prove that this state abides by a volume law entanglement spread and that is where I needed help.</p>
<hr />
<p>Since the Hamiltonian allows for long-range interactions, it is qualitatively evident that the entanglement will follow a volume-law spread.</p>
",Volume law spread after Hamiltonian evolution,<quantum-state><entanglement>,0,5,,,"Volume law spread after Hamiltonian evolution <p>Start with an <span class=""math-container"">$n \times n$</span> lattice, with each qubit initialized to the state <span class=""math-container"">$|0\rangle$</span>. Then, apply the Hadamard gate on each qubit. Then, evolve the system under the Hamiltonian
<span class=""math-container"">\begin{equation}
    H = \sum_{l, m \in [n]} \text{Z}_l \text{Z}_m,
\end{equation}</span>
for <span class=""math-container"">$d$</span> time steps.
Note that the final state of the Hamiltonian can be written as
<span class=""math-container"">\begin{equation}
    |\psi\rangle_{\text{final}} = \frac{1}{\sqrt{2^{n^{2}}}} \sum_{x \in \{0, 1\}^{n^{2}}} \sum_{l, m \in [n]} e^{-i d (-1)^{x_l + x_m}} |x\rangle,
\end{equation}</span>
where <span class=""math-container"">$x_i$</span> is the <span class=""math-container"">$i^{\text{th}}$</span> bit of <span class=""math-container"">$x$</span>.</p>
<p>I could not formally prove that this state abides by a volume law entanglement spread and that is where I needed help.</p>
<hr />
<p>Since the Hamiltonian allows for long-range interactions, it is qualitatively evident that the entanglement will follow a volume-law spread.</p>
",qc,volume law spread hamiltonian evolution p start span n n lattice qubit initialized state span apply hadamard gate qubit evolve system hamiltonian span equation h l n z z equation span time steps note final state hamiltonian written span equation final 1 2 x 0 2 l n equation span span th bit span x p could formally prove state abides volume law entanglement spread needed hr p since hamiltonian allows interactions qualitatively evident entanglement follow,"[(1, 0.10809227), (2, 0.041096453), (3, 0.38782424), (9, 0.17347984), (10, 0.03272821), (15, 0.021640623), (16, 0.01344685), (17, 0.04030385), (18, 0.17992322)]"
22275,,2021-12-14 12:31:48,3,141,"<p>I'm trying to implement a Parametric Hadamard Test.</p>
<p>I have already my parametric evolution gate <span class=""math-container"">$\exp(-i\theta H)$</span> where <span class=""math-container"">$\theta$</span> is the parameter.</p>
<p>When I defined the controlled-gate with Gate.control(1) and add it to the main circuit. I'm unable to correctly bind the parameters after and I can not get the state vector after the binded circuit.</p>
<pre><code>thetas = ParameterVector('T', length=1)
it = iter(theta)

# Define Hadamard Test
qc = QuantumCircuit(3)
qc.initialize(psi_0, [1,2])

qc.h(0)

# Apply control gate

tr_g_k = tr_g(dt=next(it))  # tr_g is the evolution gate <span class=""math-container"">$\exp(-i\theta H)$</span>
tr_g_c = tr_g_k.control(1)

qc.append(tr_g_c, [0,1,2])

qc.h(0)
# --------------------------------------------------------
# Get the StateVector

qc_b = qc.bind_parameters({theta: [np.pi]})

simulator = Aer.get_backend('aer_simulator')

qc_bt = transpile(qc_b, simulator)

qc_bt.save_statevector()

result = simulator.run(qc_bt).result()
statevector = result.get_statevector(qc_bt)

</code></pre>
<p>When running the circuit I get:</p>
<pre><code>TypeError: ParameterExpression with unbound parameters ({ParameterVectorElement(T[0])}) cannot be cast to a float.
</code></pre>
<p>I have tried without the control, i.e, only the evolution in the qubit 1 and 2 and it works.
I think it's because the control, but so far, I have not been able to solve it.</p>
<p>Thanks for any help !</p>
",I can not extract the final statevector when using a binded Parametric Controlled gate,<qiskit><programming><hadamard>,0,2,,,"I can not extract the final statevector when using a binded Parametric Controlled gate <p>I'm trying to implement a Parametric Hadamard Test.</p>
<p>I have already my parametric evolution gate <span class=""math-container"">$\exp(-i\theta H)$</span> where <span class=""math-container"">$\theta$</span> is the parameter.</p>
<p>When I defined the controlled-gate with Gate.control(1) and add it to the main circuit. I'm unable to correctly bind the parameters after and I can not get the state vector after the binded circuit.</p>
<pre><code>thetas = ParameterVector('T', length=1)
it = iter(theta)

# Define Hadamard Test
qc = QuantumCircuit(3)
qc.initialize(psi_0, [1,2])

qc.h(0)

# Apply control gate

tr_g_k = tr_g(dt=next(it))  # tr_g is the evolution gate <span class=""math-container"">$\exp(-i\theta H)$</span>
tr_g_c = tr_g_k.control(1)

qc.append(tr_g_c, [0,1,2])

qc.h(0)
# --------------------------------------------------------
# Get the StateVector

qc_b = qc.bind_parameters({theta: [np.pi]})

simulator = Aer.get_backend('aer_simulator')

qc_bt = transpile(qc_b, simulator)

qc_bt.save_statevector()

result = simulator.run(qc_bt).result()
statevector = result.get_statevector(qc_bt)

</code></pre>
<p>When running the circuit I get:</p>
<pre><code>TypeError: ParameterExpression with unbound parameters ({ParameterVectorElement(T[0])}) cannot be cast to a float.
</code></pre>
<p>I have tried without the control, i.e, only the evolution in the qubit 1 and 2 and it works.
I think it's because the control, but so far, I have not been able to solve it.</p>
<p>Thanks for any help !</p>
",qc,extract final statevector using binded parametric controlled gate p trying implement parametric hadamard p already parametric evolution gate span h span p defined 1 add main circuit unable correctly bind parameters get state vector binded pre code thetas parametervector iter theta define hadamard test qc quantumcircuit 3 0 apply control gate evolution gate span h 1 0 get statevector theta simulator transpile simulator result statevector p running circuit get pre code typeerror parameterexpression unbound parameters parametervectorelement 0 cast float p tried without control evolution qubit 1 2 works think control far able solve p thanks help,"[(0, 0.32119757), (1, 0.04939301), (2, 0.10760423), (3, 0.031592768), (9, 0.05064871), (14, 0.31345493), (16, 0.011185729), (18, 0.11360643)]"
23296,23305.0,2021-12-16 08:25:09,6,280,"<p>I'm new to quantum annealing and D-Wave computer. I saw that it has about 5000 qubits which can solve a QUBO problem with 5000 variables.</p>
<p>From my understanding, if we use a gate model device, say, an IBM quantum device to solve a QUBO problem, the number of variables is equal to the number of qubits. Is that correct? If so, does it mean that DWAVE can solve larger scale problems than these gate model devices?</p>
<p>In terms of the resulting fidelity, which one is better? For example, if we want to solve maxcut problem, is it better to use the D-Wave machine or QAOA?</p>
",Can D-Wave machines solve QUBO problems more efficiently than gate model devices?,<qiskit><d-wave><qubo>,1,0,,,"Can D-Wave machines solve QUBO problems more efficiently than gate model devices? <p>I'm new to quantum annealing and D-Wave computer. I saw that it has about 5000 qubits which can solve a QUBO problem with 5000 variables.</p>
<p>From my understanding, if we use a gate model device, say, an IBM quantum device to solve a QUBO problem, the number of variables is equal to the number of qubits. Is that correct? If so, does it mean that DWAVE can solve larger scale problems than these gate model devices?</p>
<p>In terms of the resulting fidelity, which one is better? For example, if we want to solve maxcut problem, is it better to use the D-Wave machine or QAOA?</p>
",qc,machines solve qubo problems efficiently gate model devices p new quantum annealing computer saw 5000 qubits solve qubo problem 5000 p understanding use gate model device say ibm quantum device solve qubo problem number variables equal number qubits correct mean dwave solve larger scale problems gate model devices p terms resulting fidelity one better example want solve maxcut problem better use machine qaoa,"[(1, 0.48224366), (8, 0.17337178), (14, 0.24871154), (16, 0.04624434), (18, 0.047054663)]"
23371,23409.0,2021-12-22 13:52:56,4,972,"<p>I am trying to get the distance using the swap test circuit.</p>
<p><a href=""https://i.sstatic.net/m2fkq.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m2fkq.png"" alt=""enter image description here"" /></a>,</p>
<p>With the help of the codes I shared, I can only estimate the distance between two vectors. Can it calculate the distances of many vectors from each other with the help of a single circuit?</p>
<pre><code>
# import the necessary libraries 
import math as m
from qiskit import *
from qiskit import BasicAer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit_quantum_knn.encoding import analog
from numpy import linalg as LA
from scipy.spatial import distance



# First step is to encode the data into quantum states. 
#There are some techniques to do it, in this case Amplitude embedding was used.


A= [2,9,8,5,4,18,16,10]
B= [7,5,10,3,14,10,20,6]


A_norm=LA.norm(A)
B_norm=LA.norm(B)
Dist=distance.euclidean(A, B)
Z = round( A_norm**2 + B_norm**2 )
 
# create phi and psi state with the data    
phi = [A_norm/m.sqrt(Z),-B_norm/m.sqrt(Z)]
psi = []

for i in range(len(A)):
    psi.append(((A[i]/A_norm) /m.sqrt(2)))
    psi.append(((B[i]/B_norm) /m.sqrt(2)))
    
# Quantum Circuit
q1 = QuantumRegister(1,name='q1')
q2 = QuantumRegister(1,name='q2')
q3 = QuantumRegister(4,name='q3')
c = ClassicalRegister(1,name='c')
qc= QuantumCircuit(q1,q2,q3,c)

# states initialization
qc.initialize( phi, q2[0] )
qc.initialize( psi, q3[0:4])

# The swap test operator 
qc.h( q1[0])
qc.cswap( q1[0], q2[0], q3[0] )
qc.h( q1[0] )
qc.measure(q1,c)

display(qc.draw(output=&quot;mpl&quot;))


## Results
shots = 1000000
job = execute(qc,Aer.get_backend('qasm_simulator'),shots=shots)
job_result = job.result()
counts = job_result.get_counts(qc)
x = abs(((counts['0']/shots - 0.5)/0.5)*2*Z)
Q_Dist = round(m.sqrt(x),4)
print('Quantum Distance: ', round(Q_Dist,3))    
print('Euclidean Distance: ',round(Dist,3))   

</code></pre>
",Calculating the quantum euclidean distance between vectors,<qiskit><programming><quantum-algorithms><quantum-enhanced-machine-learning>,1,3,,,"Calculating the quantum euclidean distance between vectors <p>I am trying to get the distance using the swap test circuit.</p>
<p><a href=""https://i.sstatic.net/m2fkq.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m2fkq.png"" alt=""enter image description here"" /></a>,</p>
<p>With the help of the codes I shared, I can only estimate the distance between two vectors. Can it calculate the distances of many vectors from each other with the help of a single circuit?</p>
<pre><code>
# import the necessary libraries 
import math as m
from qiskit import *
from qiskit import BasicAer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit_quantum_knn.encoding import analog
from numpy import linalg as LA
from scipy.spatial import distance



# First step is to encode the data into quantum states. 
#There are some techniques to do it, in this case Amplitude embedding was used.


A= [2,9,8,5,4,18,16,10]
B= [7,5,10,3,14,10,20,6]


A_norm=LA.norm(A)
B_norm=LA.norm(B)
Dist=distance.euclidean(A, B)
Z = round( A_norm**2 + B_norm**2 )
 
# create phi and psi state with the data    
phi = [A_norm/m.sqrt(Z),-B_norm/m.sqrt(Z)]
psi = []

for i in range(len(A)):
    psi.append(((A[i]/A_norm) /m.sqrt(2)))
    psi.append(((B[i]/B_norm) /m.sqrt(2)))
    
# Quantum Circuit
q1 = QuantumRegister(1,name='q1')
q2 = QuantumRegister(1,name='q2')
q3 = QuantumRegister(4,name='q3')
c = ClassicalRegister(1,name='c')
qc= QuantumCircuit(q1,q2,q3,c)

# states initialization
qc.initialize( phi, q2[0] )
qc.initialize( psi, q3[0:4])

# The swap test operator 
qc.h( q1[0])
qc.cswap( q1[0], q2[0], q3[0] )
qc.h( q1[0] )
qc.measure(q1,c)

display(qc.draw(output=&quot;mpl&quot;))


## Results
shots = 1000000
job = execute(qc,Aer.get_backend('qasm_simulator'),shots=shots)
job_result = job.result()
counts = job_result.get_counts(qc)
x = abs(((counts['0']/shots - 0.5)/0.5)*2*Z)
Q_Dist = round(m.sqrt(x),4)
print('Quantum Distance: ', round(Q_Dist,3))    
print('Euclidean Distance: ',round(Dist,3))   

</code></pre>
",qc,calculating quantum euclidean distance vectors p trying get distance using swap test p https nofollow noreferrer img https enter image description p help codes shared estimate distance two vectors calculate distances many vectors help single circuit pre code import necessary libraries import math qiskit import qiskit import basicaer qiskit import quantumcircuit classicalregister quantumregister execute import analog numpy import linalg la import distance first step encode data quantum states techniques case amplitude embedding used b b z round 2 2 create phi psi state data phi z z psi range len 2 b 2 quantum circuit q1 quantumregister 1 q2 quantumregister 1 q3 quantumregister 4 c classicalregister 1 c quantumcircuit q1 q2 q3 c states initialization phi q2 0 psi q3 swap test operator q1 0 q1 0 q2 0 q3 0 q1 0 q1 c display quot mpl quot results shots 1000000 job execute qc counts qc x abs counts 0 2 z round x print distance round print distance round,"[(0, 0.35178185), (1, 0.0122182), (2, 0.111359745), (4, 0.07224727), (5, 0.029368771), (10, 0.010889491), (13, 0.08176564), (14, 0.14934658), (16, 0.04010207), (17, 0.095789716), (18, 0.035608742)]"
23494,23502.0,2021-12-30 16:24:50,3,1065,"<p>We are interested in simulating the 1d Ising model Hamiltonian using a Quantum Circuit (QC). <a href=""https://quantumcomputing.stackexchange.com/questions/5945/how-to-build-a-quantum-circuit-representing-the-ising-model"">A similar question was posted before</a> with no answers. Here we will assume, for simplicity, 3 lattice sites and <span class=""math-container"">$J=-1$</span>.</p>
<p>Generically, the Hamiltonian is given as
<span class=""math-container"">$$
H = -J \sum_{ij} \sigma_i^z \otimes \sigma_j^z.\tag{1}
$$</span>
For our case of interest this Hamiltonian becomes:
<span class=""math-container"">$$
H = \sigma^z \otimes \sigma^z \otimes \mathbb{1} + \mathbb{1} \otimes \sigma^z \otimes \sigma^z.\tag{2}
$$</span>
Obviously I have not included any periodic boundary conditions. There are only three lattice sites so there are only two interaction terms. In what follows I will replace <span class=""math-container"">$\sigma^z$</span> with <span class=""math-container"">$Z$</span> implying the corresponding quantum gate.</p>
<p>The evolution operator corresponding to this Hamiltonian is given as
<span class=""math-container"">$$\tag{3}
U(t) = e^{-i (Z \otimes Z\otimes \mathbb{1} + \mathbb{1}\otimes Z \otimes Z)t}.
$$</span>
Should these operators not commute we would have to use the Trotter-Suzuki formula. However, they do commute and as a result there is no need to use it.</p>
<p>In each of the two summands there exists a unit operator which can be completely ignored from the circuit. Now, for the operator <span class=""math-container"">$Z \otimes Z$</span> the curcuit would read
<span class=""math-container"">$$
\mathrm{CNOT} R_z(2t) \mathrm{CNOT}:
$$</span>
<a href=""https://i.sstatic.net/MC9hD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MC9hD.png"" alt=""enter image description here"" /></a></p>
<p><strong>My question is whether as the generalization to the 3 lattice sites Hamiltonian is as simple forward as this</strong>:
<a href=""https://i.sstatic.net/fUC6W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fUC6W.png"" alt=""enter image description here"" /></a></p>
<p>Of course the <span class=""math-container"">$R_Z$</span> gate runs for <span class=""math-container"">$2t$</span> according the unitary <span class=""math-container"">$U(t)$</span>. Finally, does this generalize as simply to the <span class=""math-container"">$n$</span> lattice site Ising model?</p>
",Simulating the Ising-like model as a quantum circuit,<circuit-construction><quantum-circuit><hamiltonian-simulation>,1,0,,,"Simulating the Ising-like model as a quantum circuit <p>We are interested in simulating the 1d Ising model Hamiltonian using a Quantum Circuit (QC). <a href=""https://quantumcomputing.stackexchange.com/questions/5945/how-to-build-a-quantum-circuit-representing-the-ising-model"">A similar question was posted before</a> with no answers. Here we will assume, for simplicity, 3 lattice sites and <span class=""math-container"">$J=-1$</span>.</p>
<p>Generically, the Hamiltonian is given as
<span class=""math-container"">$$
H = -J \sum_{ij} \sigma_i^z \otimes \sigma_j^z.\tag{1}
$$</span>
For our case of interest this Hamiltonian becomes:
<span class=""math-container"">$$
H = \sigma^z \otimes \sigma^z \otimes \mathbb{1} + \mathbb{1} \otimes \sigma^z \otimes \sigma^z.\tag{2}
$$</span>
Obviously I have not included any periodic boundary conditions. There are only three lattice sites so there are only two interaction terms. In what follows I will replace <span class=""math-container"">$\sigma^z$</span> with <span class=""math-container"">$Z$</span> implying the corresponding quantum gate.</p>
<p>The evolution operator corresponding to this Hamiltonian is given as
<span class=""math-container"">$$\tag{3}
U(t) = e^{-i (Z \otimes Z\otimes \mathbb{1} + \mathbb{1}\otimes Z \otimes Z)t}.
$$</span>
Should these operators not commute we would have to use the Trotter-Suzuki formula. However, they do commute and as a result there is no need to use it.</p>
<p>In each of the two summands there exists a unit operator which can be completely ignored from the circuit. Now, for the operator <span class=""math-container"">$Z \otimes Z$</span> the curcuit would read
<span class=""math-container"">$$
\mathrm{CNOT} R_z(2t) \mathrm{CNOT}:
$$</span>
<a href=""https://i.sstatic.net/MC9hD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MC9hD.png"" alt=""enter image description here"" /></a></p>
<p><strong>My question is whether as the generalization to the 3 lattice sites Hamiltonian is as simple forward as this</strong>:
<a href=""https://i.sstatic.net/fUC6W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fUC6W.png"" alt=""enter image description here"" /></a></p>
<p>Of course the <span class=""math-container"">$R_Z$</span> gate runs for <span class=""math-container"">$2t$</span> according the unitary <span class=""math-container"">$U(t)$</span>. Finally, does this generalize as simply to the <span class=""math-container"">$n$</span> lattice site Ising model?</p>
",qc,simulating model quantum circuit p interested simulating 1d ising model hamiltonian using quantum circuit qc https similar question posted answers assume simplicity 3 lattice sites span p generically hamiltonian given span h ij 1 case interest hamiltonian becomes span h 1 1 2 obviously included periodic boundary conditions three lattice sites two interaction terms follows replace span span z implying corresponding quantum p evolution operator corresponding hamiltonian given span 3 u z 1 1 z z operators commute would use formula however commute result need use p two summands exists unit operator completely ignored circuit operator span z z curcuit would read span cnot 2t cnot https nofollow noreferrer img https enter image description p strong question whether generalization 3 lattice sites hamiltonian simple forward https nofollow noreferrer img https enter image description p course span gate runs span 2t according unitary span u finally generalize simply span n lattice site ising model,"[(1, 0.1262043), (2, 0.041379046), (3, 0.46059117), (4, 0.22387388), (5, 0.040724475), (10, 0.029268773), (14, 0.04345645), (16, 0.033707637)]"
23588,,2022-01-07 02:36:26,4,307,"<p>Suppose I have a quantum circuit with a few measurements (say <span class=""math-container"">$N$</span>) on a single qubit. Before all the measurements, I generated calibration circuits and the 2 by 2 calibration matrix for that qubit of interest. However, I wonder after the first mid-circuit measurement, how can I determine if this matrix is still the same? In other words, will one mid-circuit measurement affect the error on the qubit, therefore influencing the following measurement errors (in mid-circuit measurement)?</p>
<p>I wonder if there's a way to test that, and/or generate the calibration circuits and the matrix (with <span class=""math-container"">$2^N$</span> dimensions) in this case.</p>
<p>Please feel free to let me know if anything is unclear in the question. Thanks for the help!</p>
",Does one measurement affect the following measurement errors in mid-circuit measurement?,<qiskit><measurement>,1,5,,,"Does one measurement affect the following measurement errors in mid-circuit measurement? <p>Suppose I have a quantum circuit with a few measurements (say <span class=""math-container"">$N$</span>) on a single qubit. Before all the measurements, I generated calibration circuits and the 2 by 2 calibration matrix for that qubit of interest. However, I wonder after the first mid-circuit measurement, how can I determine if this matrix is still the same? In other words, will one mid-circuit measurement affect the error on the qubit, therefore influencing the following measurement errors (in mid-circuit measurement)?</p>
<p>I wonder if there's a way to test that, and/or generate the calibration circuits and the matrix (with <span class=""math-container"">$2^N$</span> dimensions) in this case.</p>
<p>Please feel free to let me know if anything is unclear in the question. Thanks for the help!</p>
",qc,one measurement affect following measurement errors measurement p suppose quantum circuit measurements say span n single qubit measurements generated calibration circuits 2 2 calibration matrix qubit interest however wonder first measurement determine matrix still words one measurement affect error qubit therefore influencing following measurement errors measurement p wonder way test generate calibration circuits matrix span dimensions p please feel free let know anything unclear question thanks help,"[(3, 0.14952677), (5, 0.07791653), (8, 0.037605163), (11, 0.046726257), (14, 0.27245444), (16, 0.056742232), (18, 0.35709128)]"
23639,23640.0,2022-01-11 06:47:24,2,2808,"<p>I have an IBM Quantum account. How can I save the IBM Quantum API token to local environment so that I can access services including real quantum systems, simulators and Qiskit Runtime programs on my local machine using Qiskit?</p>
",How can I save IBM Quantum API token to local environment?,<qiskit><ibm-q-experience>,4,0,,,"How can I save IBM Quantum API token to local environment? <p>I have an IBM Quantum account. How can I save the IBM Quantum API token to local environment so that I can access services including real quantum systems, simulators and Qiskit Runtime programs on my local machine using Qiskit?</p>
",qc,save ibm quantum api token local environment p ibm quantum account save ibm quantum api token local environment access services including real quantum systems simulators qiskit runtime programs local machine using qiskit,"[(1, 0.33153188), (8, 0.092838235), (14, 0.49120966), (16, 0.07929084)]"
23717,23718.0,2022-01-18 21:01:06,2,469,"<p>I am trying to represent a quantum circuit schematically with some operators in QISKIT. I know I can create some operator with <code>Operator()</code> in quantum_info from a circuit circ like</p>
<pre><code>Q1=quantum_info.Operator(circ)
</code></pre>
<p>To add the <span class=""math-container"">$Q_1$</span> operator to the circuit I can do</p>
<pre><code>circ.append(Q1, [0, 1])
</code></pre>
<p>which adds <span class=""math-container"">$Q_1$</span> operator to the circuit and maps the 0th bit of the circuit to the 0th bit of the <span class=""math-container"">$Q_1$</span> operator and 1st bit of the circuit to the 1st bit of the <span class=""math-container"">$Q_1$</span> operator.  The resulting circuit for a 4-qubit circuit circ is</p>
<p><a href=""https://i.sstatic.net/5RuOa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5RuOa.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering how to edit the label of the operator. Right now it's just showing Unitary in the circuit block. I tried to find this in the QISKIT documentation. So far, no luck!</p>
",Representing Qubit Operator in Circuit,<qiskit><programming><circuit-construction>,1,0,,,"Representing Qubit Operator in Circuit <p>I am trying to represent a quantum circuit schematically with some operators in QISKIT. I know I can create some operator with <code>Operator()</code> in quantum_info from a circuit circ like</p>
<pre><code>Q1=quantum_info.Operator(circ)
</code></pre>
<p>To add the <span class=""math-container"">$Q_1$</span> operator to the circuit I can do</p>
<pre><code>circ.append(Q1, [0, 1])
</code></pre>
<p>which adds <span class=""math-container"">$Q_1$</span> operator to the circuit and maps the 0th bit of the circuit to the 0th bit of the <span class=""math-container"">$Q_1$</span> operator and 1st bit of the circuit to the 1st bit of the <span class=""math-container"">$Q_1$</span> operator.  The resulting circuit for a 4-qubit circuit circ is</p>
<p><a href=""https://i.sstatic.net/5RuOa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5RuOa.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering how to edit the label of the operator. Right now it's just showing Unitary in the circuit block. I tried to find this in the QISKIT documentation. So far, no luck!</p>
",qc,representing qubit operator circuit p trying represent quantum circuit schematically operators qiskit know create operator code operator circuit circ like pre code circ p add span operator circuit pre code q1 0 1 p adds span operator circuit maps 0th bit circuit 0th bit span operator 1st bit circuit 1st bit span operator resulting circuit circuit circ p https nofollow noreferrer img https enter image description p wondering edit label operator right showing unitary circuit block tried find qiskit documentation far luck,"[(0, 0.29856557), (3, 0.18128997), (4, 0.24826808), (14, 0.25753322), (16, 0.012495272)]"
23787,23790.0,2022-01-24 11:08:18,5,1226,"<p>I am currently learning surface code. In this framework, we can either do a quantum memory (for which we have good knowledge of how to do it), but we can also &quot;in principle&quot; perform an arbitrary computation.</p>
<p>So far, to implements non identity logical gates (hence, cNOT, Hadamard,...), there are from my very partial understanding different techniques. Please note that for 1. and 2., I do not know any technical details behind those yet, I just barely know their name.</p>
<ol>
<li>&quot;Lattice surgery&quot;: I don't know exactly in what it consists but I know it can be used to perform logical gates.</li>
<li>Braiding. I actually believe it is the same as lattice surgery but I am not sure.</li>
<li>Transversal operations. We first protect each logical qubit by surface code. Then we can use the concatenated construction (for instance based on the Steane method), and perform transversal Clifford gates with this.</li>
</ol>
<p>Also, we can perform gate by doing magic distillation protocole (but as you typically need to know &quot;at least&quot;  how to perform a logical cNOT, I guess this is more a complementary technique to have the full gateset).</p>
<p><strong>My questions:</strong></p>
<ol>
<li>Is my little summary of techniques more or less complete (and correct).</li>
<li>What is the most seriously considered technique to perform logical gates for the surface code?</li>
<li>What is a good pedagogic reference to learn it?</li>
</ol>
<p>I am currently learning the basics of surface codes using the following refs: <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""noreferrer"">ref1</a> <a href=""https://arxiv.org/abs/1302.3428"" rel=""noreferrer"">ref2</a> <a href=""https://arxiv.org/abs/1208.0928"" rel=""noreferrer"">ref3</a>. They talk a bit about how to do logical gates but they are also some kind of general reviews (and they do not necessarily enter in too much details for this). My goal is to save my energy to focus on learning what is considered to be a good way to do logical gates (and not some historical &quot;abandonned&quot; ways).</p>
",State of the art logical gate implementations for surface code,<error-correction><resource-request><surface-code>,3,0,,,"State of the art logical gate implementations for surface code <p>I am currently learning surface code. In this framework, we can either do a quantum memory (for which we have good knowledge of how to do it), but we can also &quot;in principle&quot; perform an arbitrary computation.</p>
<p>So far, to implements non identity logical gates (hence, cNOT, Hadamard,...), there are from my very partial understanding different techniques. Please note that for 1. and 2., I do not know any technical details behind those yet, I just barely know their name.</p>
<ol>
<li>&quot;Lattice surgery&quot;: I don't know exactly in what it consists but I know it can be used to perform logical gates.</li>
<li>Braiding. I actually believe it is the same as lattice surgery but I am not sure.</li>
<li>Transversal operations. We first protect each logical qubit by surface code. Then we can use the concatenated construction (for instance based on the Steane method), and perform transversal Clifford gates with this.</li>
</ol>
<p>Also, we can perform gate by doing magic distillation protocole (but as you typically need to know &quot;at least&quot;  how to perform a logical cNOT, I guess this is more a complementary technique to have the full gateset).</p>
<p><strong>My questions:</strong></p>
<ol>
<li>Is my little summary of techniques more or less complete (and correct).</li>
<li>What is the most seriously considered technique to perform logical gates for the surface code?</li>
<li>What is a good pedagogic reference to learn it?</li>
</ol>
<p>I am currently learning the basics of surface codes using the following refs: <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""noreferrer"">ref1</a> <a href=""https://arxiv.org/abs/1302.3428"" rel=""noreferrer"">ref2</a> <a href=""https://arxiv.org/abs/1208.0928"" rel=""noreferrer"">ref3</a>. They talk a bit about how to do logical gates but they are also some kind of general reviews (and they do not necessarily enter in too much details for this). My goal is to save my energy to focus on learning what is considered to be a good way to do logical gates (and not some historical &quot;abandonned&quot; ways).</p>
",qc,state art logical gate implementations surface code p currently learning surface code framework either quantum memory good knowledge also quot principle quot perform arbitrary p far implements non identity logical gates hence cnot hadamard partial understanding different techniques please note know technical details behind yet barely know ol li quot lattice surgery quot know exactly consists know used perform logical li braiding actually believe lattice surgery li transversal operations first protect logical qubit surface code use concatenated construction instance based steane method perform transversal clifford gates p also perform gate magic distillation protocole typically need know quot least quot perform logical cnot guess complementary technique full gateset p strong questions ol li little summary techniques less complete correct li seriously considered technique perform logical gates surface code li good pedagogic reference learn p currently learning basics surface codes using following refs https noreferrer ref1 https noreferrer ref2 https noreferrer ref3 talk bit logical gates also kind general reviews necessarily enter much details goal save energy focus learning considered good way logical gates historical quot abandonned quot ways,"[(4, 0.017454604), (5, 0.27016553), (8, 0.20134544), (9, 0.3603896), (14, 0.04886315), (16, 0.030882152), (19, 0.051525626)]"
23800,23827.0,2022-01-25 04:15:11,2,182,"<p>The error rates that I found on the calibration files are given in percentage, but I couldn't find whether it is calculated on full-scale (% FS) or on percentage of reading (% RD). If I do <span class=""math-container"">$20000$</span> shots and found <span class=""math-container"">$|00\rangle$</span>  at <span class=""math-container"">$5000$</span> with an error rate of <span class=""math-container"">$1\%$</span>, should it be <span class=""math-container"">$5000 \pm 200$</span> or <span class=""math-container"">$5000 \pm 50$</span>? Thank you!</p>
",Is the error rate of IBMQ devices full-scale (% FS) or on percentage of reading (% RD)?,<qiskit><ibm-q-experience><ibm-quantum-devices>,1,0,,,"Is the error rate of IBMQ devices full-scale (% FS) or on percentage of reading (% RD)? <p>The error rates that I found on the calibration files are given in percentage, but I couldn't find whether it is calculated on full-scale (% FS) or on percentage of reading (% RD). If I do <span class=""math-container"">$20000$</span> shots and found <span class=""math-container"">$|00\rangle$</span>  at <span class=""math-container"">$5000$</span> with an error rate of <span class=""math-container"">$1\%$</span>, should it be <span class=""math-container"">$5000 \pm 200$</span> or <span class=""math-container"">$5000 \pm 50$</span>? Thank you!</p>
",qc,error rate ibmq devices fs percentage reading rd p error rates found calibration files given percentage could find whether calculated fs percentage reading rd span 20000 shots found span span 5000 error rate span span 5000 200 span 5000 50 thank,"[(0, 0.07778185), (3, 0.20602503), (5, 0.16352952), (8, 0.17889236), (14, 0.30296513), (16, 0.04216386), (17, 0.02539979)]"
23840,23841.0,2022-01-27 18:16:15,2,358,"<p>I am trying to understand the lattice splitting as described in <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Horsman</a> paper. In short: I don't understand why measuring the data qubit to split the surface doesn't change the stabilizer results.</p>
<p><a href=""https://i.sstatic.net/DRWnh.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/DRWnh.png"" alt=""enter image description here"" /></a></p>
<p>The tiny green dots are measurement qubits measuring <span class=""math-container"">$Z$</span> stabilizers (on the center of the plaquettes), or <span class=""math-container"">$X$</span> stabilizers (on each node).</p>
<p>The wide dots are the data qubits.</p>
<p>At time <span class=""math-container"">$0$</span> we have a unique surface. At time <span class=""math-container"">$0^+$</span>, we are measuring in the <span class=""math-container"">$X$</span>-basis the pink &quot;wide&quot; dots representing some the data qubits at the row in the middle.</p>
<h2>My two questions</h2>
<p>In the paper it is said:</p>
<blockquote>
<p>Firstly, we can see that none of the joint Z operators changes at all: measuring out the qubits removes a row of face plaquettes from the error correction entirely,
and leaves the surrounding face plaquettes untouched</p>
</blockquote>
<ol>
<li><p><strong>Why is that true?</strong> If I measure the pink data qubit belonging to the black plaquette with a Pauli <span class=""math-container"">$X$</span> measurement, the black plaquette will have its value changed. Indeed the <span class=""math-container"">$X$</span> Pauli I applied touches one edge of the black plaquette and hence anti-commutes with it. The same reasoning applies for any plaquette below. The upper and bottom edges of the red plaquette are being touched by a Pauli-<span class=""math-container"">$X$</span> measurement. Their product might commute with the plaquette but I am not measuring their product but each Pauli individually (which is equivalent to measuring the product of the Pauli, which would commute with the plaquette, followed by one Pauli applied on one edge, which would anticommute with the plaquette).</p>
</li>
<li><p>Assuming there is no problem, what happens after this <span class=""math-container"">$X$</span> measurements? Do I stop including the pink qubits in any stabilizer measurement?</p>
</li>
</ol>
",I don't understand the lattice splitting procedure for surface code,<error-correction><surface-code>,1,0,,,"I don't understand the lattice splitting procedure for surface code <p>I am trying to understand the lattice splitting as described in <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Horsman</a> paper. In short: I don't understand why measuring the data qubit to split the surface doesn't change the stabilizer results.</p>
<p><a href=""https://i.sstatic.net/DRWnh.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/DRWnh.png"" alt=""enter image description here"" /></a></p>
<p>The tiny green dots are measurement qubits measuring <span class=""math-container"">$Z$</span> stabilizers (on the center of the plaquettes), or <span class=""math-container"">$X$</span> stabilizers (on each node).</p>
<p>The wide dots are the data qubits.</p>
<p>At time <span class=""math-container"">$0$</span> we have a unique surface. At time <span class=""math-container"">$0^+$</span>, we are measuring in the <span class=""math-container"">$X$</span>-basis the pink &quot;wide&quot; dots representing some the data qubits at the row in the middle.</p>
<h2>My two questions</h2>
<p>In the paper it is said:</p>
<blockquote>
<p>Firstly, we can see that none of the joint Z operators changes at all: measuring out the qubits removes a row of face plaquettes from the error correction entirely,
and leaves the surrounding face plaquettes untouched</p>
</blockquote>
<ol>
<li><p><strong>Why is that true?</strong> If I measure the pink data qubit belonging to the black plaquette with a Pauli <span class=""math-container"">$X$</span> measurement, the black plaquette will have its value changed. Indeed the <span class=""math-container"">$X$</span> Pauli I applied touches one edge of the black plaquette and hence anti-commutes with it. The same reasoning applies for any plaquette below. The upper and bottom edges of the red plaquette are being touched by a Pauli-<span class=""math-container"">$X$</span> measurement. Their product might commute with the plaquette but I am not measuring their product but each Pauli individually (which is equivalent to measuring the product of the Pauli, which would commute with the plaquette, followed by one Pauli applied on one edge, which would anticommute with the plaquette).</p>
</li>
<li><p>Assuming there is no problem, what happens after this <span class=""math-container"">$X$</span> measurements? Do I stop including the pink qubits in any stabilizer measurement?</p>
</li>
</ol>
",qc,understand lattice splitting procedure surface code p trying understand lattice splitting described https nofollow noreferrer horsman paper short understand measuring data qubit split surface change stabilizer p https nofollow noreferrer img https enter image description p tiny green dots measurement qubits measuring span z stabilizers center plaquettes span x stabilizers node p wide dots data p time span 0 unique surface time span measuring span x pink quot wide quot dots representing data qubits row h2 two questions p paper said blockquote p firstly see none joint z operators changes measuring qubits removes row face plaquettes error correction entirely leaves surrounding face plaquettes untouched ol li p strong true measure pink data qubit belonging black plaquette pauli span x measurement black plaquette value changed indeed span x pauli applied touches one edge black plaquette hence reasoning applies plaquette upper bottom edges red plaquette touched span x measurement product might commute plaquette measuring product pauli individually equivalent measuring product pauli would commute plaquette followed one pauli applied one edge would anticommute plaquette li p assuming problem happens span x measurements stop including pink qubits stabilizer measurement,"[(3, 0.09157109), (4, 0.0653116), (5, 0.21717225), (7, 0.05787678), (9, 0.21704635), (10, 0.059460554), (13, 0.13838014), (16, 0.0181747), (18, 0.11671539), (19, 0.012168314)]"
23872,23873.0,2022-01-30 17:26:21,5,391,"<p>I am struggling to understand why the lattice splitting procedure works precisely. I am following the appendix in <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">this paper</a>.</p>
<p>[edit]: While the answer in this topic answers the question, the concept that allows to properly understand the solution is solved in this topic <a href=""https://quantumcomputing.stackexchange.com/questions/23891/how-to-find-the-stabilizer-generators-for-a-post-measurement-state/23893#23893"">How to find the stabilizer generators for a post-measurement state?</a></p>
<h2>The context</h2>
<p>I will focus on the merging for rough boundaries as represented in the image below.
<a href=""https://i.sstatic.net/qA5Fm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qA5Fm.png"" alt=""enter image description here"" /></a></p>
<p>I assume that the total state at &quot;time 0&quot; is <span class=""math-container"">$|\psi\rangle=|0_L\rangle |0 \rangle |0_L\rangle$</span> where the first logical qubit is the one on the left surface, the middle one is the measurement qubit <span class=""math-container"">$M$</span> and the right one is the state stored on the right surface.</p>
<p>I need to show that after the lattice merging, which consists in &quot;turning on&quot; the <span class=""math-container"">$X$</span> stabilizers  <span class=""math-container"">$X_2 X_a X_M$</span>, <span class=""math-container"">$X_5 X_d X_M$</span>, and in changing the <span class=""math-container"">$Z$</span> stabilizers: <span class=""math-container"">$Z_a Z_c Z_d \to Z_a Z_c Z_d Z_M$</span>, <span class=""math-container"">$Z_2 Z_3 Z_5 \to Z_2 Z_3 Z_5 Z_M$</span>, the state at the end of the procedure will become <span class=""math-container"">$|\psi \rangle \to |0_L\rangle$</span> which is the logical <span class=""math-container"">$0$</span> of the now merged surface. Here I only described &quot;which stabilizer changed&quot;, but of course we will have all along many other &quot;stabilizers&quot; activated, <span class=""math-container"">$Z_1 Z_3 Z_4$</span> would be an example.</p>
<p>If I properly understand this example, by linearity I could understand what happens for arbitrary initial qubit stored on the two surfaces before merging (as the reasoning would be similar for any computational state).</p>
<h2>My question</h2>
<p>In the paper, it is said that before any merging, the stabilizers for <span class=""math-container"">$|0_L\rangle |0 \rangle |0_L \rangle$</span> are the following:</p>
<p><a href=""https://i.sstatic.net/RoZ76.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RoZ76.png"" alt=""enter image description here"" /></a></p>
<p><strong>I agree with that.</strong> (don't pay attention to the blue lines right now).</p>
<p>Then, the authors reason sequentially. They consider first &quot;turning on&quot; <span class=""math-container"">$X_2 X_M X_a$</span> (and even if not explicitly written, they also do the change <span class=""math-container"">$Z_a Z_c Z_d \to Z_a Z_c Z_d Z_M$</span>, <span class=""math-container"">$Z_2 Z_3 Z_5 \to Z_2 Z_3 Z_5 Z_M$</span>. They obtain the following stabilizer table:</p>
<p><a href=""https://i.sstatic.net/2plfM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2plfM.png"" alt=""enter image description here"" /></a></p>
<p>I agree with everything <strong>but</strong> the red lines. They are corresponding to the blue lines in the previous table (which represented stabilizers for the logical <span class=""math-container"">$|0_L\rangle$</span> for the two surfaces), but now multiplied by <span class=""math-container"">$Z_M$</span>. Indeed, I remind that the logical <span class=""math-container"">$Z$</span> for the first and second surfaces can be written as <span class=""math-container"">$Z_1 Z_2$</span> and <span class=""math-container"">$Z_a Z_b$</span> respectively.</p>
<p>I understood the presence of the blue lines in the previous table. Even though we were not &quot;actively&quot; measuring the associated Pauli, the state was <em>by definition</em> an eigenstate of those. However, I don't understand the red lines in the second table, and this for the following two reasons:</p>
<ol>
<li>We are not actively measuring <span class=""math-container"">$Z_1 Z_2 Z_M$</span> neither <span class=""math-container"">$Z_a Z_b Z_M$</span>.</li>
<li>Even if we are not actively measuring those, nothing tells us that the state would be an eigenstate of those two operators. If it appears to be the case I don't find it obvious and it would have to be shown.</li>
</ol>
<p>In conclusion: could someone explain to me why the red lines are present in the second table? If I understand this I guess I could understand the rest of the proof yielding to <span class=""math-container"">$|\psi \rangle \to |0_L \rangle$</span></p>
",Lattice splitting: understanding mathematically why it works based on the stabilizer formalism,<error-correction><surface-code>,1,0,,,"Lattice splitting: understanding mathematically why it works based on the stabilizer formalism <p>I am struggling to understand why the lattice splitting procedure works precisely. I am following the appendix in <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">this paper</a>.</p>
<p>[edit]: While the answer in this topic answers the question, the concept that allows to properly understand the solution is solved in this topic <a href=""https://quantumcomputing.stackexchange.com/questions/23891/how-to-find-the-stabilizer-generators-for-a-post-measurement-state/23893#23893"">How to find the stabilizer generators for a post-measurement state?</a></p>
<h2>The context</h2>
<p>I will focus on the merging for rough boundaries as represented in the image below.
<a href=""https://i.sstatic.net/qA5Fm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qA5Fm.png"" alt=""enter image description here"" /></a></p>
<p>I assume that the total state at &quot;time 0&quot; is <span class=""math-container"">$|\psi\rangle=|0_L\rangle |0 \rangle |0_L\rangle$</span> where the first logical qubit is the one on the left surface, the middle one is the measurement qubit <span class=""math-container"">$M$</span> and the right one is the state stored on the right surface.</p>
<p>I need to show that after the lattice merging, which consists in &quot;turning on&quot; the <span class=""math-container"">$X$</span> stabilizers  <span class=""math-container"">$X_2 X_a X_M$</span>, <span class=""math-container"">$X_5 X_d X_M$</span>, and in changing the <span class=""math-container"">$Z$</span> stabilizers: <span class=""math-container"">$Z_a Z_c Z_d \to Z_a Z_c Z_d Z_M$</span>, <span class=""math-container"">$Z_2 Z_3 Z_5 \to Z_2 Z_3 Z_5 Z_M$</span>, the state at the end of the procedure will become <span class=""math-container"">$|\psi \rangle \to |0_L\rangle$</span> which is the logical <span class=""math-container"">$0$</span> of the now merged surface. Here I only described &quot;which stabilizer changed&quot;, but of course we will have all along many other &quot;stabilizers&quot; activated, <span class=""math-container"">$Z_1 Z_3 Z_4$</span> would be an example.</p>
<p>If I properly understand this example, by linearity I could understand what happens for arbitrary initial qubit stored on the two surfaces before merging (as the reasoning would be similar for any computational state).</p>
<h2>My question</h2>
<p>In the paper, it is said that before any merging, the stabilizers for <span class=""math-container"">$|0_L\rangle |0 \rangle |0_L \rangle$</span> are the following:</p>
<p><a href=""https://i.sstatic.net/RoZ76.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RoZ76.png"" alt=""enter image description here"" /></a></p>
<p><strong>I agree with that.</strong> (don't pay attention to the blue lines right now).</p>
<p>Then, the authors reason sequentially. They consider first &quot;turning on&quot; <span class=""math-container"">$X_2 X_M X_a$</span> (and even if not explicitly written, they also do the change <span class=""math-container"">$Z_a Z_c Z_d \to Z_a Z_c Z_d Z_M$</span>, <span class=""math-container"">$Z_2 Z_3 Z_5 \to Z_2 Z_3 Z_5 Z_M$</span>. They obtain the following stabilizer table:</p>
<p><a href=""https://i.sstatic.net/2plfM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2plfM.png"" alt=""enter image description here"" /></a></p>
<p>I agree with everything <strong>but</strong> the red lines. They are corresponding to the blue lines in the previous table (which represented stabilizers for the logical <span class=""math-container"">$|0_L\rangle$</span> for the two surfaces), but now multiplied by <span class=""math-container"">$Z_M$</span>. Indeed, I remind that the logical <span class=""math-container"">$Z$</span> for the first and second surfaces can be written as <span class=""math-container"">$Z_1 Z_2$</span> and <span class=""math-container"">$Z_a Z_b$</span> respectively.</p>
<p>I understood the presence of the blue lines in the previous table. Even though we were not &quot;actively&quot; measuring the associated Pauli, the state was <em>by definition</em> an eigenstate of those. However, I don't understand the red lines in the second table, and this for the following two reasons:</p>
<ol>
<li>We are not actively measuring <span class=""math-container"">$Z_1 Z_2 Z_M$</span> neither <span class=""math-container"">$Z_a Z_b Z_M$</span>.</li>
<li>Even if we are not actively measuring those, nothing tells us that the state would be an eigenstate of those two operators. If it appears to be the case I don't find it obvious and it would have to be shown.</li>
</ol>
<p>In conclusion: could someone explain to me why the red lines are present in the second table? If I understand this I guess I could understand the rest of the proof yielding to <span class=""math-container"">$|\psi \rangle \to |0_L \rangle$</span></p>
",qc,lattice splitting understanding mathematically works based stabilizer formalism p struggling understand lattice splitting procedure works precisely following appendix https nofollow noreferrer paper p edit answer topic answers question concept allows properly understand solution solved topic https 23893 find stabilizer generators state h2 context p focus merging rough boundaries represented image https nofollow noreferrer img https enter image description p assume total state quot time 0 quot span first logical qubit one left surface middle one measurement qubit span right one state stored right p need show lattice merging consists quot turning quot span x stabilizers span span changing span z stabilizers span span state end procedure become span logical span 0 merged surface described quot stabilizer changed quot course along many quot stabilizers quot activated span would p properly understand example linearity could understand happens arbitrary initial qubit stored two surfaces merging reasoning would similar computational state h2 question p paper said merging stabilizers span following p https nofollow noreferrer img https enter image description p strong agree pay attention blue lines right p authors reason sequentially consider first quot turning quot span even explicitly written also change span span obtain following stabilizer table p https nofollow noreferrer img https enter image description p agree everything strong red lines corresponding blue lines previous table represented stabilizers logical span two surfaces multiplied span indeed remind logical span z first second surfaces written span span p understood presence blue lines previous table even though quot actively quot measuring associated pauli state em definition eigenstate however understand red lines second table following two reasons ol li actively measuring span neither span li even actively measuring nothing tells us state would eigenstate two operators appears case find obvious would p conclusion could someone explain red lines present second table understand guess could understand rest proof yielding span,"[(3, 0.22290534), (4, 0.19817698), (5, 0.16862047), (13, 0.2408895), (16, 0.028837247), (18, 0.08595965), (19, 0.047294036)]"
23916,,2022-02-02 15:43:05,8,133,"<p>Since DWAVE quantum device is constructed using superconducting flux qubits, each qubit cannot be produced identically so that the fidelity of the qubit must be different.  DWAVE only provides the information of their devices in terms of number of qubits, couplers, etc without any calibration data of each qubit on their <a href=""https://www.dwavesys.com/solutions-and-products/systems/"" rel=""noreferrer"">website</a>.</p>
<p>I was wondering if we can find some information about the qubit fidelity of DWAVE machine. Since the number of qubits is quite huge, I assume it's time-consuming to calibrate the device and methods like randomized benchmarking are not applicable anymore. Is there any specific calibration method for that?</p>
",Qubit fidelity of DWAVE device,<experimental-realization><fidelity><d-wave>,0,0,,,"Qubit fidelity of DWAVE device <p>Since DWAVE quantum device is constructed using superconducting flux qubits, each qubit cannot be produced identically so that the fidelity of the qubit must be different.  DWAVE only provides the information of their devices in terms of number of qubits, couplers, etc without any calibration data of each qubit on their <a href=""https://www.dwavesys.com/solutions-and-products/systems/"" rel=""noreferrer"">website</a>.</p>
<p>I was wondering if we can find some information about the qubit fidelity of DWAVE machine. Since the number of qubits is quite huge, I assume it's time-consuming to calibrate the device and methods like randomized benchmarking are not applicable anymore. Is there any specific calibration method for that?</p>
",qc,qubit fidelity dwave device p since dwave quantum device constructed using superconducting flux qubits qubit produced identically fidelity qubit must different dwave provides information devices terms number qubits couplers etc without calibration data qubit https noreferrer website p wondering find information qubit fidelity dwave machine since number qubits quite huge assume calibrate device methods like randomized benchmarking applicable anymore specific calibration method,"[(8, 0.40766284), (9, 0.24373217), (11, 0.085103266), (13, 0.035737544), (16, 0.09514587), (18, 0.13029064)]"
23966,23968.0,2022-02-05 23:52:34,7,870,"<p>There are two related but distinct parts to my question and I'm happy to hear perspectives on either:</p>
<ol>
<li><p>Any historical details, testimonies, papers that shed insight into what Lov Grover was working on which led him to think up his algorithm.</p>
</li>
<li><p>What sorts of ideas must be one be playing with from which the idea of Grover's algorithm somewhat naturally arises.</p>
</li>
</ol>
",How did Lov Grover think up his search algorithm? How might one have discovered it themselves?,<quantum-algorithms><grovers-algorithm><history>,1,2,,,"How did Lov Grover think up his search algorithm? How might one have discovered it themselves? <p>There are two related but distinct parts to my question and I'm happy to hear perspectives on either:</p>
<ol>
<li><p>Any historical details, testimonies, papers that shed insight into what Lov Grover was working on which led him to think up his algorithm.</p>
</li>
<li><p>What sorts of ideas must be one be playing with from which the idea of Grover's algorithm somewhat naturally arises.</p>
</li>
</ol>
",qc,lov grover think search algorithm might one discovered p two related distinct parts question happy hear perspectives either ol li p historical details testimonies papers shed insight lov grover working led think li p sorts ideas must one playing idea grover algorithm somewhat naturally,"[(7, 0.4446308), (8, 0.24588612), (9, 0.17306058), (13, 0.10824052), (16, 0.024538139)]"
23984,24218.0,2022-02-07 15:47:15,4,243,"<p>My misunderstanding is probably due to a trivial thing I am not seeing.</p>
<p>In lattice surgery for surface code, we can perform a merging operation. This operation should be symmetric as indicated on Eq.5 in <a href=""https://arxiv.org/pdf/1111.4022v3.pdf"" rel=""nofollow noreferrer"">this</a> paper, or Eq on top of page 5 of <a href=""https://arxiv.org/pdf/1608.05208.pdf"" rel=""nofollow noreferrer"">this</a> one (and it is a natural consequences of the sequences of operation you perform on the surface).</p>
<p>More precisely, for a rough merge, calling the two states to be merged:</p>
<p><span class=""math-container"">$$|\psi\rangle= \alpha |0\rangle + \beta |1 \rangle $$</span>
<span class=""math-container"">$$|\phi\rangle= \alpha' |0\rangle + \beta' |1 \rangle $$</span></p>
<p>The merging operation acts on the logical space as:</p>
<p><span class=""math-container"">$$|\psi\rangle \otimes |\phi\rangle \to \alpha |\phi \rangle + (-1)^M \beta X |\phi\rangle$$</span></p>
<p>We see that within the process, a two qubit state is mapped to a single qubit state: the merging operation does not preserve the dimensions. As far as I understand, the &quot;net&quot; process is somewhat equivalent to measure the <span class=""math-container"">$X_1 X_2$</span> observable of the two qubit state and to map the result to a single qubit state. The quantity <span class=""math-container"">$M$</span> is the measurement outcome of the observable <span class=""math-container"">$X_1 X_2$</span> on the initial two qubit state.</p>
<p>By construction, the merging operation is symmetric, hence, by exchanging the role of <span class=""math-container"">$|\phi\rangle$</span> and <span class=""math-container"">$|\psi\rangle$</span>, we expect to have (as indicated in the papers provided):</p>
<p><span class=""math-container"">$$ \alpha |\phi \rangle + (-1)^M \beta X |\phi\rangle=\alpha' |\psi \rangle + (-1)^M \beta' X |\psi\rangle $$</span></p>
<p>However, if you do the calculation you realize that this last equality is not true. Below is a short script illustrating the issue</p>
<p><a href=""https://i.sstatic.net/qByh7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qByh7.png"" alt=""enter image description here"" /></a></p>
<p>How to make sense of this? On one hand I agree with the paper that we should have the equality true (because we are merging two different surface into a single one: the process should be the same if we exchanged the initial two surfaces). But on the other hand the concrete calculation indicates that it is not the case (and is then in contradiction with the papers).</p>
",The merging operation is not symmetric on its inputs in surface code as it should naturally be,<error-correction><surface-code>,1,22,,,"The merging operation is not symmetric on its inputs in surface code as it should naturally be <p>My misunderstanding is probably due to a trivial thing I am not seeing.</p>
<p>In lattice surgery for surface code, we can perform a merging operation. This operation should be symmetric as indicated on Eq.5 in <a href=""https://arxiv.org/pdf/1111.4022v3.pdf"" rel=""nofollow noreferrer"">this</a> paper, or Eq on top of page 5 of <a href=""https://arxiv.org/pdf/1608.05208.pdf"" rel=""nofollow noreferrer"">this</a> one (and it is a natural consequences of the sequences of operation you perform on the surface).</p>
<p>More precisely, for a rough merge, calling the two states to be merged:</p>
<p><span class=""math-container"">$$|\psi\rangle= \alpha |0\rangle + \beta |1 \rangle $$</span>
<span class=""math-container"">$$|\phi\rangle= \alpha' |0\rangle + \beta' |1 \rangle $$</span></p>
<p>The merging operation acts on the logical space as:</p>
<p><span class=""math-container"">$$|\psi\rangle \otimes |\phi\rangle \to \alpha |\phi \rangle + (-1)^M \beta X |\phi\rangle$$</span></p>
<p>We see that within the process, a two qubit state is mapped to a single qubit state: the merging operation does not preserve the dimensions. As far as I understand, the &quot;net&quot; process is somewhat equivalent to measure the <span class=""math-container"">$X_1 X_2$</span> observable of the two qubit state and to map the result to a single qubit state. The quantity <span class=""math-container"">$M$</span> is the measurement outcome of the observable <span class=""math-container"">$X_1 X_2$</span> on the initial two qubit state.</p>
<p>By construction, the merging operation is symmetric, hence, by exchanging the role of <span class=""math-container"">$|\phi\rangle$</span> and <span class=""math-container"">$|\psi\rangle$</span>, we expect to have (as indicated in the papers provided):</p>
<p><span class=""math-container"">$$ \alpha |\phi \rangle + (-1)^M \beta X |\phi\rangle=\alpha' |\psi \rangle + (-1)^M \beta' X |\psi\rangle $$</span></p>
<p>However, if you do the calculation you realize that this last equality is not true. Below is a short script illustrating the issue</p>
<p><a href=""https://i.sstatic.net/qByh7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qByh7.png"" alt=""enter image description here"" /></a></p>
<p>How to make sense of this? On one hand I agree with the paper that we should have the equality true (because we are merging two different surface into a single one: the process should be the same if we exchanged the initial two surfaces). But on the other hand the concrete calculation indicates that it is not the case (and is then in contradiction with the papers).</p>
",qc,merging operation symmetric inputs surface code naturally p misunderstanding probably due trivial thing p lattice surgery surface code perform merging operation operation symmetric indicated https nofollow noreferrer paper eq top page 5 https nofollow noreferrer one natural consequences sequences operation perform surface p precisely rough merge calling two states merged p span span p merging operation acts logical space p span x p see within process two qubit state mapped single qubit state merging operation preserve dimensions far understand quot net quot process somewhat equivalent measure span observable two qubit state map result single qubit state quantity span measurement outcome observable span initial two qubit p construction merging operation symmetric hence exchanging role span span expect indicated papers provided p span x x p however calculation realize last equality true short script illustrating issue p https nofollow noreferrer img https enter image description p make sense one hand agree paper equality true merging two different surface single one process exchanged initial two surfaces hand concrete calculation indicates case contradiction papers,"[(3, 0.28482863), (4, 0.16478118), (5, 0.10293622), (9, 0.084030755), (10, 0.025130456), (13, 0.11605732), (16, 0.0833366), (18, 0.11543423), (19, 0.014053911)]"
24057,24069.0,2022-02-12 03:15:30,2,444,"<p>I have a collection of circuits with cirq that use CNOT(q1, q2).
I would like to be able to find and replace all the instance of this gate in the circuit collection and replace them with a composite gate of single qubit on each qubit and another entanglement gate. So I want to do substitution like this one:</p>
<pre><code>-o-        -X-x-Z- 
 |     =&gt;     |
-o-        -Z-x-Y-
</code></pre>
<p>where I have tried to represent two different entanglement gates.</p>
<p>Is there an efficient way to do this using some cirq function (other than a basic loop over each moment of the circuit) ? I was able to use the <code>findall_operations_with_gate_type()</code> function, but was not able to replace these gate.</p>
",Find and replace gate,<cirq>,1,0,,,"Find and replace gate <p>I have a collection of circuits with cirq that use CNOT(q1, q2).
I would like to be able to find and replace all the instance of this gate in the circuit collection and replace them with a composite gate of single qubit on each qubit and another entanglement gate. So I want to do substitution like this one:</p>
<pre><code>-o-        -X-x-Z- 
 |     =&gt;     |
-o-        -Z-x-Y-
</code></pre>
<p>where I have tried to represent two different entanglement gates.</p>
<p>Is there an efficient way to do this using some cirq function (other than a basic loop over each moment of the circuit) ? I was able to use the <code>findall_operations_with_gate_type()</code> function, but was not able to replace these gate.</p>
",qc,find replace gate p collection circuits cirq use cnot q1 q2 would like able find replace instance gate circuit collection replace composite gate single qubit qubit another entanglement gate want substitution like one pre code gt p tried represent two different entanglement p efficient way using cirq function basic loop moment circuit able use code function able replace,"[(9, 0.035896607), (14, 0.7901686), (16, 0.029509004), (18, 0.14167501)]"
24119,,2022-02-16 10:11:12,0,76,"<p>On page 28 of <a href=""https://www.math.ru.nl/%7Elandsman/Sven2019.pdf"" rel=""nofollow noreferrer"">this paper</a> the following calculation is made:
<span class=""math-container"">$$P\left(\sigma_{\theta}=+1\right)=\left|\left\langle+\mid \Psi_{0}\right\rangle\right|^{2}=\cos ^{2} \frac{\theta}{2}$$</span></p>
<p>Can someone help me with the full calculation?</p>
<p>I wanted to know, how, using <span class=""math-container"">\begin{equation}
|+\rangle=\left(\begin{array}{c}
\cos \frac{\theta}{2} \\
\sin \frac{\theta}{2}
\end{array}\right)
\end{equation}</span></p>
<p>they made the calculation? What are the formulae I have to use?</p>
",Probability that the measurement will give +1 as a result for entangled state,<entanglement>,0,2,,,"Probability that the measurement will give +1 as a result for entangled state <p>On page 28 of <a href=""https://www.math.ru.nl/%7Elandsman/Sven2019.pdf"" rel=""nofollow noreferrer"">this paper</a> the following calculation is made:
<span class=""math-container"">$$P\left(\sigma_{\theta}=+1\right)=\left|\left\langle+\mid \Psi_{0}\right\rangle\right|^{2}=\cos ^{2} \frac{\theta}{2}$$</span></p>
<p>Can someone help me with the full calculation?</p>
<p>I wanted to know, how, using <span class=""math-container"">\begin{equation}
|+\rangle=\left(\begin{array}{c}
\cos \frac{\theta}{2} \\
\sin \frac{\theta}{2}
\end{array}\right)
\end{equation}</span></p>
<p>they made the calculation? What are the formulae I have to use?</p>
",qc,probability measurement give result entangled state p page 28 https nofollow noreferrer paper following calculation made span 0 2 2 2 p someone help full calculation p wanted know using span equation array c 2 2 array equation p made calculation formulae use,"[(2, 0.13483034), (3, 0.17665228), (4, 0.46515667), (15, 0.08102789), (16, 0.026824271), (18, 0.11219066)]"
24198,,2022-02-21 06:01:58,3,1290,"<p>I need an API token to use IBM's real hardware(greater than 5 qubits) in Qiskit, where can I find the price?</p>
",How can I get IBM's API token?,<qiskit><ibm-q-experience><ibm-quantum-devices>,1,1,,,"How can I get IBM's API token? <p>I need an API token to use IBM's real hardware(greater than 5 qubits) in Qiskit, where can I find the price?</p>
",qc,get ibm api token p need api token use ibm real hardware greater 5 qubits qiskit find price,"[(6, 0.043460693), (14, 0.8081441), (16, 0.1385104)]"
24202,,2022-02-21 10:08:36,2,110,"<p>I have to compute the exact expectation value from a state vector obtained after running a circuit. While I was running my code, I found different weird outcome so I decided to create few tests and I got the following results.</p>
<p>If I implement the Hamiltonian <span class=""math-container"">$H = \sigma_{0}^{z}+\sigma_{1}^{z}$</span>:</p>
<pre><code>import cirq

q0 = cirq.NamedQubit('q0')
q1 = cirq.NamedQubit('q1')

qc = cirq.Circuit()
qc.append(cirq.X(q0))
qc.append(cirq.X(q1))

hamiltonian = 0
hamiltonian += cirq.Z(q0)
hamiltonian += cirq.Z(q1)

num_var = { q0: 0, q1: 1 }
expectation_value = cirq.PauliString(hamiltonian).expectation_from_state_vector(qc.final_state_vector(), num_var).real
</code></pre>
<p>The outcome of <code>print(expectation_value)</code> is:</p>
<pre><code>1.0
</code></pre>
<p>The correct result should be <code>-2.0</code> instead. I tried out different combinations and what I obtained is:</p>
<pre><code>qc.append(cirq.I(q0))
qc.append(cirq.I(q1))

# here insert the hamiltonian computation

print(expectation_value) --&gt; 1.0
</code></pre>
<p>Does somebody know what is going on? What is it wrong with my code? I am using <code>cirq 0.13.1</code> but I tested on<code>cirq 0.9.1</code> as well and it gave me the same results.</p>
<p>Thank you in advance! :)</p>
<p>I write down a more complex example with the Hamiltonian <span class=""math-container"">$H = \sigma_{0}^{z} + \sigma_{1}^{z} + \sigma_{0}^{z}\,\sigma_{1}^{z}$</span></p>
<p>import cirq</p>
<pre><code>q0 = cirq.NamedQubit('q0')
q1 = cirq.NamedQubit('q1')

qc = cirq.Circuit()
qc.append(cirq.X(q0))
qc.append(cirq.I(q1))

hamiltonian = 0
hamiltonian += cirq.Z(q0)
hamiltonian += cirq.Z(q1)
hamiltonian += cirq.Z(q0)*cirq.Z(q1)


num_var = { q0: 0, q1: 1 }
expectation_value = cirq.PauliString(hamiltonian).expectation_from_state_vector(qc.final_state_vector(), num_var).real
</code></pre>
<p>The resulr of <code>print(expectation_value)</code> is <code>1.0</code> instead of <code>-1.0</code>.</p>
",Wrong expected value from cirq PauliString,<cirq>,1,0,,,"Wrong expected value from cirq PauliString <p>I have to compute the exact expectation value from a state vector obtained after running a circuit. While I was running my code, I found different weird outcome so I decided to create few tests and I got the following results.</p>
<p>If I implement the Hamiltonian <span class=""math-container"">$H = \sigma_{0}^{z}+\sigma_{1}^{z}$</span>:</p>
<pre><code>import cirq

q0 = cirq.NamedQubit('q0')
q1 = cirq.NamedQubit('q1')

qc = cirq.Circuit()
qc.append(cirq.X(q0))
qc.append(cirq.X(q1))

hamiltonian = 0
hamiltonian += cirq.Z(q0)
hamiltonian += cirq.Z(q1)

num_var = { q0: 0, q1: 1 }
expectation_value = cirq.PauliString(hamiltonian).expectation_from_state_vector(qc.final_state_vector(), num_var).real
</code></pre>
<p>The outcome of <code>print(expectation_value)</code> is:</p>
<pre><code>1.0
</code></pre>
<p>The correct result should be <code>-2.0</code> instead. I tried out different combinations and what I obtained is:</p>
<pre><code>qc.append(cirq.I(q0))
qc.append(cirq.I(q1))

# here insert the hamiltonian computation

print(expectation_value) --&gt; 1.0
</code></pre>
<p>Does somebody know what is going on? What is it wrong with my code? I am using <code>cirq 0.13.1</code> but I tested on<code>cirq 0.9.1</code> as well and it gave me the same results.</p>
<p>Thank you in advance! :)</p>
<p>I write down a more complex example with the Hamiltonian <span class=""math-container"">$H = \sigma_{0}^{z} + \sigma_{1}^{z} + \sigma_{0}^{z}\,\sigma_{1}^{z}$</span></p>
<p>import cirq</p>
<pre><code>q0 = cirq.NamedQubit('q0')
q1 = cirq.NamedQubit('q1')

qc = cirq.Circuit()
qc.append(cirq.X(q0))
qc.append(cirq.I(q1))

hamiltonian = 0
hamiltonian += cirq.Z(q0)
hamiltonian += cirq.Z(q1)
hamiltonian += cirq.Z(q0)*cirq.Z(q1)


num_var = { q0: 0, q1: 1 }
expectation_value = cirq.PauliString(hamiltonian).expectation_from_state_vector(qc.final_state_vector(), num_var).real
</code></pre>
<p>The resulr of <code>print(expectation_value)</code> is <code>1.0</code> instead of <code>-1.0</code>.</p>
",qc,wrong expected value cirq paulistring p compute exact expectation value state vector obtained running circuit running code found different weird outcome decided create tests got following p implement hamiltonian span h 0 z 1 z pre code import cirq q0 q1 qc q0 q1 hamiltonian 0 hamiltonian q0 hamiltonian q1 q0 0 q1 1 hamiltonian p outcome code print pre code p correct result code instead tried different combinations obtained pre code q0 q1 insert hamiltonian computation print gt p somebody know going wrong code using code cirq tested code cirq well gave p thank advance p write complex example hamiltonian span h 0 z 1 z 0 z 1 z p import cirq pre code q0 q1 qc q0 q1 hamiltonian 0 hamiltonian q0 hamiltonian q1 hamiltonian q0 q1 q0 0 q1 1 hamiltonian p resulr code print code instead code,"[(0, 0.32792372), (1, 0.10572719), (2, 0.09826238), (3, 0.053539082), (5, 0.038586993), (13, 0.020501444), (14, 0.16755903), (16, 0.1870439)]"
24204,24210.0,2022-02-21 12:52:36,2,185,"<p>Suppose I have the simple circuit</p>
<pre><code>bell = Circuit().h(0).cnot(control=0, target=1)
</code></pre>
<p>and I am running it in a notebook inside AWS. How can I download the results to my local pc when</p>
<ol>
<li><p>I use the <code>LocalSimulator()</code>.</p>
</li>
<li><p>An IonQ or a Rigetti device?</p>
</li>
</ol>
",Download results in amazon braket,<amazon-braket>,1,0,,,"Download results in amazon braket <p>Suppose I have the simple circuit</p>
<pre><code>bell = Circuit().h(0).cnot(control=0, target=1)
</code></pre>
<p>and I am running it in a notebook inside AWS. How can I download the results to my local pc when</p>
<ol>
<li><p>I use the <code>LocalSimulator()</code>.</p>
</li>
<li><p>An IonQ or a Rigetti device?</p>
</li>
</ol>
",qc,download results amazon braket p suppose simple circuit pre code bell circuit 0 p running notebook inside aws download results local pc ol li p use code localsimulator li p ionq rigetti device,"[(0, 0.05635685), (2, 0.030344848), (7, 0.09150111), (12, 0.030092947), (14, 0.6319804), (16, 0.0808052), (18, 0.044824783), (19, 0.03047121)]"
24208,24209.0,2022-02-21 15:31:25,0,199,"<p><a href=""https://i.sstatic.net/yHTNZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yHTNZ.png"" alt=""The corresponding gates"" /></a></p>
<p>Suppose there are three qubits, q0, q1, and q2, if you perform a <em>CX</em> on q0 and q1, the entire matrix of the operation you performed on the whole quantum circuit will simply be the tensor product of <em>CX</em> and <em>I</em>.</p>
<p>My  question is, how to do so if the irrelevant qubit is between the involved qubits? I have listed three such gates in the upper figure, one <em>CX</em> and two <em>CSWAP</em>s.</p>
<p>P.S. If you do some <em>SWAP</em>s such case can be fixed, but is there a simpler, and more general method?</p>
",Matrix representation of multi-qubit operations when there's irrelevant qubit(s),<quantum-gate><matrix-representation>,1,1,,,"Matrix representation of multi-qubit operations when there's irrelevant qubit(s) <p><a href=""https://i.sstatic.net/yHTNZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yHTNZ.png"" alt=""The corresponding gates"" /></a></p>
<p>Suppose there are three qubits, q0, q1, and q2, if you perform a <em>CX</em> on q0 and q1, the entire matrix of the operation you performed on the whole quantum circuit will simply be the tensor product of <em>CX</em> and <em>I</em>.</p>
<p>My  question is, how to do so if the irrelevant qubit is between the involved qubits? I have listed three such gates in the upper figure, one <em>CX</em> and two <em>CSWAP</em>s.</p>
<p>P.S. If you do some <em>SWAP</em>s such case can be fixed, but is there a simpler, and more general method?</p>
",qc,matrix representation operations irrelevant qubit p https nofollow noreferrer img https corresponding gates p suppose three qubits q0 q1 q2 perform em cx q0 q1 entire matrix operation performed whole quantum circuit simply tensor product em cx em p question irrelevant qubit involved qubits listed three gates upper figure one em cx two em cswap p em swap case fixed simpler general method,"[(3, 0.07605697), (4, 0.11088734), (6, 0.046064902), (9, 0.26434365), (11, 0.07019447), (13, 0.03725858), (14, 0.09928038), (16, 0.07277918), (18, 0.22139314)]"
24447,24450.0,2022-03-09 13:07:52,2,161,"<p>I am currently using the Cirq pakage and when drawing the circuit structure, I constantly encountered the <code>PhISwap</code> gate, like in <a href=""https://quantumai.google/openfermion/tutorials/circuits_3_arbitrary_basis_trotter"" rel=""nofollow noreferrer"">here</a>. What does this gate mean?</p>
",What does PhISwap gate mean in Cirq?,<programming><cirq><openfermion>,1,0,,,"What does PhISwap gate mean in Cirq? <p>I am currently using the Cirq pakage and when drawing the circuit structure, I constantly encountered the <code>PhISwap</code> gate, like in <a href=""https://quantumai.google/openfermion/tutorials/circuits_3_arbitrary_basis_trotter"" rel=""nofollow noreferrer"">here</a>. What does this gate mean?</p>
",qc,phiswap gate mean cirq p currently using cirq pakage drawing circuit structure constantly encountered code phiswap gate like https nofollow noreferrer gate mean,"[(4, 0.43840125), (14, 0.48963255), (16, 0.06354746)]"
24457,24536.0,2022-03-10 05:19:57,1,129,"<p>I know this is supposed to be in cryptography but I think this question is appropriate to be asked here. I am reading the Learning with Errors paper of Oded Regev and I am confused with the uncomputation part in his proof of reduction that states an oracle for the closest vector problem yields a quantum algorithm for solving the discrete Gaussian sampling problem. So here is the setup of my question:</p>
<p>Let <span class=""math-container"">$L$</span> be a lattice in <span class=""math-container"">$\mathbb{R}^n$</span> with fundamental parallelepiped <span class=""math-container"">$\mathcal{P}(L)$</span> relative to some fixed basis of <span class=""math-container"">$L$</span> and <span class=""math-container"">$\rho$</span> be the Gaussian measure on <span class=""math-container"">$\mathbb{R}^n$</span>. Consider that state <span class=""math-container"">$\displaystyle\sum_{x\in \mathbb{R}^n} \rho (x) |x, x\pmod{\mathcal{P}(L)}\rangle$</span>. Then he said that supposed we have an oracle for CVP, we can recover <span class=""math-container"">$x$</span> from <span class=""math-container"">$x\pmod{\mathcal{P}(L)}$</span>, hence we can uncompute the first register, that is we arrive at the state <span class=""math-container"">$\displaystyle\sum_{x\in \mathbb{R}^n} \rho (x) |x\pmod{\mathcal{P}(L)}\rangle$</span> (I know summing over the entire Euclidean space is absurd but he was able to give a valid state exponentially close to the 'state' over <span class=""math-container"">$\mathbb{R}^n$</span>). How does this uncomputing the first register works?</p>
",Quantum part on Regev's LWE paper,<quantum-gate><quantum-state><cryptography>,1,0,,,"Quantum part on Regev's LWE paper <p>I know this is supposed to be in cryptography but I think this question is appropriate to be asked here. I am reading the Learning with Errors paper of Oded Regev and I am confused with the uncomputation part in his proof of reduction that states an oracle for the closest vector problem yields a quantum algorithm for solving the discrete Gaussian sampling problem. So here is the setup of my question:</p>
<p>Let <span class=""math-container"">$L$</span> be a lattice in <span class=""math-container"">$\mathbb{R}^n$</span> with fundamental parallelepiped <span class=""math-container"">$\mathcal{P}(L)$</span> relative to some fixed basis of <span class=""math-container"">$L$</span> and <span class=""math-container"">$\rho$</span> be the Gaussian measure on <span class=""math-container"">$\mathbb{R}^n$</span>. Consider that state <span class=""math-container"">$\displaystyle\sum_{x\in \mathbb{R}^n} \rho (x) |x, x\pmod{\mathcal{P}(L)}\rangle$</span>. Then he said that supposed we have an oracle for CVP, we can recover <span class=""math-container"">$x$</span> from <span class=""math-container"">$x\pmod{\mathcal{P}(L)}$</span>, hence we can uncompute the first register, that is we arrive at the state <span class=""math-container"">$\displaystyle\sum_{x\in \mathbb{R}^n} \rho (x) |x\pmod{\mathcal{P}(L)}\rangle$</span> (I know summing over the entire Euclidean space is absurd but he was able to give a valid state exponentially close to the 'state' over <span class=""math-container"">$\mathbb{R}^n$</span>). How does this uncomputing the first register works?</p>
",qc,quantum part regev lwe paper p know supposed cryptography think question appropriate asked reading learning errors paper oded regev confused uncomputation part proof reduction states oracle closest vector problem yields quantum algorithm solving discrete gaussian sampling problem setup question p let span l lattice span r fundamental parallelepiped span p l relative fixed basis span l span gaussian measure span r consider state span r x p l said supposed oracle cvp recover span x span p l hence uncompute first register arrive state span r x p l know summing entire euclidean space absurd able give valid state exponentially close span r uncomputing first register works,"[(3, 0.55220246), (5, 0.011626838), (8, 0.21127194), (9, 0.023792978), (10, 0.06454953), (15, 0.02477561), (16, 0.010172407), (18, 0.10044398)]"
24458,,2022-03-10 06:33:59,1,168,"<p>I need your expert opinions/comments on this problem.</p>
<p>Suppose I have a database (say 16 entries), such that db[0] = 0.12, db[1] = 0.84, db[2] = 0.55, ..., db[15] = 0.91. I want the oracle to mark those indexes whose value is &gt; 0.8 (for example). In this case the oracle should mark the index of 1 &amp; 15 so that the Grover algo is able to pick out one of the desired index after a certain number of iterations. How should I go about doing this?</p>
<p>My solution (I use Q#):</p>
<ol>
<li>I create 4 quantum registers; targetReg, yReg, x1Reg, x2Reg.</li>
<li>x1Reg has 4 qubits, representing the database indices and in uniform superposition.</li>
<li>x2Reg has qubits enough to represent the real numbers associated with each index. In this case, 7 qubits is suffice (I can simply multiply the values by 100 so that they become integers).</li>
<li>yReg has the same number of qubits as x2Reg and initialized to 0.8 (or 80 after multiplication).</li>
<li>targetReg has a single qubit.</li>
<li>Start iteration {</li>
<li>within {Compare yReg and x2Reg and set yReg to |0&gt; if x@Reg &gt; yReg.}</li>
<li>apply {ControlledOnInt(0, X)(yReg, targetReg)}.</li>
<li>Then perform the reflection.</li>
<li>} End iteration.</li>
<li>Measure x1Reg.</li>
</ol>
<p>Is this how it should be done? I have not actually tried it yet but I believe it should work although I have no clue how to implement Item 7 (the comparison). I was wondering if there are other alternate ways of doing it.</p>
<p>Edit: I have written a Q# program that finds and marked entries that are <strong>equal</strong> to the desired entry. It seems to be working fine although my apologies if my code looks <em>amateurish</em> since I only started to learn Q# a month ago. Now I need to find out how to find and marked entries that are <strong>greater than</strong> the desired entry.</p>
<pre><code>operation GroverSearchIntDatabase() : Unit {

    let indexRegLength = 4;  // number of qubits to represent the database indices
    let intRegLength = 7;  // number of qubits to represent the integers
    
    // Generate the database randomly
    let databaseSize = 2 ^ indexRegLength;
    mutable database = [0, size = databaseSize];
    for idx in 0 .. databaseSize - 1 {
        set database w/= idx &lt;- DrawRandomInt(0, (2 ^ intRegLength) - 1);
    }
    
    // Randomly select an index pointing to the desired integer
    let solutionIndex = DrawRandomInt(0, databaseSize - 1);
    let solutionInt = database[solutionIndex];
    Message($&quot;The desired integer: {solutionInt}&quot;);
    
    // Find out how many indices have the same desired integer
    let predicate = EqualI(_, solutionInt);
    let nSolutions = Count(predicate, database);
    Message($&quot;Number of indices with the same integer: {nSolutions}&quot;);
    
    // Initiailize the quantum registers
    use indexReg = Qubit[indexRegLength];
    use intReg = Qubit[intRegLength];
    use desiredIntReg = Qubit[intRegLength];
    use targetReg = Qubit();
    
    let nIterations = Floor(Sqrt(IntAsDouble(databaseSize) / IntAsDouble(nSolutions)) * PI() / 4.0);
    mutable measuredIndex = 0;
    
    // Theoretical success probability
    let success_prob = Sin((2.0 * IntAsDouble(nIterations) + 1.0) * ArcSin(Sqrt(IntAsDouble(nSolutions)) / Sqrt(IntAsDouble(databaseSize)))) ^ 2.0;
    Message($&quot;Success probability: {success_prob}&quot;);
    
    // Grover Search
    ApplyToEach(H, indexReg);
    
    for _ in 1..nIterations {
    
        // This is the oracle
        within {
            X(targetReg);
            H(targetReg);
            
            // Associate the integers to the corresponding indices
            for idx in 0 .. databaseSize - 1 {
                ControlledOnInt(idx, ApplyXorInPlace)(indexReg, (database[idx], LittleEndian(intReg)));
            }

            // Set the desiredIntReg to |0&gt; if it is equal to solutionInt
            ApplyXorInPlace(solutionInt, LittleEndian(desiredIntReg));
            for (q0, q1) in Zipped(intReg, desiredIntReg) {
                CNOT(q0, q1);
            }
        } apply {
            ControlledOnInt(0, X)(desiredIntReg, targetReg);
        }
        
        // This will be the reflect about uniform
        within {
            ApplyToEachA(H, indexReg);
            ApplyToEachA(X, indexReg);
        } apply {
            Controlled Z(Most(indexReg), Tail(indexReg));
        }
    }
    set measuredIndex = MeasureInteger(LittleEndian(indexReg));
    Message($&quot;Desired integer: {solutionInt}, Integer of measured index: {database[measuredIndex]}&quot;);
    
}
</code></pre>
",Implementing the Oracle in Grover,<grovers-algorithm><q#><oracles>,2,0,,,"Implementing the Oracle in Grover <p>I need your expert opinions/comments on this problem.</p>
<p>Suppose I have a database (say 16 entries), such that db[0] = 0.12, db[1] = 0.84, db[2] = 0.55, ..., db[15] = 0.91. I want the oracle to mark those indexes whose value is &gt; 0.8 (for example). In this case the oracle should mark the index of 1 &amp; 15 so that the Grover algo is able to pick out one of the desired index after a certain number of iterations. How should I go about doing this?</p>
<p>My solution (I use Q#):</p>
<ol>
<li>I create 4 quantum registers; targetReg, yReg, x1Reg, x2Reg.</li>
<li>x1Reg has 4 qubits, representing the database indices and in uniform superposition.</li>
<li>x2Reg has qubits enough to represent the real numbers associated with each index. In this case, 7 qubits is suffice (I can simply multiply the values by 100 so that they become integers).</li>
<li>yReg has the same number of qubits as x2Reg and initialized to 0.8 (or 80 after multiplication).</li>
<li>targetReg has a single qubit.</li>
<li>Start iteration {</li>
<li>within {Compare yReg and x2Reg and set yReg to |0&gt; if x@Reg &gt; yReg.}</li>
<li>apply {ControlledOnInt(0, X)(yReg, targetReg)}.</li>
<li>Then perform the reflection.</li>
<li>} End iteration.</li>
<li>Measure x1Reg.</li>
</ol>
<p>Is this how it should be done? I have not actually tried it yet but I believe it should work although I have no clue how to implement Item 7 (the comparison). I was wondering if there are other alternate ways of doing it.</p>
<p>Edit: I have written a Q# program that finds and marked entries that are <strong>equal</strong> to the desired entry. It seems to be working fine although my apologies if my code looks <em>amateurish</em> since I only started to learn Q# a month ago. Now I need to find out how to find and marked entries that are <strong>greater than</strong> the desired entry.</p>
<pre><code>operation GroverSearchIntDatabase() : Unit {

    let indexRegLength = 4;  // number of qubits to represent the database indices
    let intRegLength = 7;  // number of qubits to represent the integers
    
    // Generate the database randomly
    let databaseSize = 2 ^ indexRegLength;
    mutable database = [0, size = databaseSize];
    for idx in 0 .. databaseSize - 1 {
        set database w/= idx &lt;- DrawRandomInt(0, (2 ^ intRegLength) - 1);
    }
    
    // Randomly select an index pointing to the desired integer
    let solutionIndex = DrawRandomInt(0, databaseSize - 1);
    let solutionInt = database[solutionIndex];
    Message($&quot;The desired integer: {solutionInt}&quot;);
    
    // Find out how many indices have the same desired integer
    let predicate = EqualI(_, solutionInt);
    let nSolutions = Count(predicate, database);
    Message($&quot;Number of indices with the same integer: {nSolutions}&quot;);
    
    // Initiailize the quantum registers
    use indexReg = Qubit[indexRegLength];
    use intReg = Qubit[intRegLength];
    use desiredIntReg = Qubit[intRegLength];
    use targetReg = Qubit();
    
    let nIterations = Floor(Sqrt(IntAsDouble(databaseSize) / IntAsDouble(nSolutions)) * PI() / 4.0);
    mutable measuredIndex = 0;
    
    // Theoretical success probability
    let success_prob = Sin((2.0 * IntAsDouble(nIterations) + 1.0) * ArcSin(Sqrt(IntAsDouble(nSolutions)) / Sqrt(IntAsDouble(databaseSize)))) ^ 2.0;
    Message($&quot;Success probability: {success_prob}&quot;);
    
    // Grover Search
    ApplyToEach(H, indexReg);
    
    for _ in 1..nIterations {
    
        // This is the oracle
        within {
            X(targetReg);
            H(targetReg);
            
            // Associate the integers to the corresponding indices
            for idx in 0 .. databaseSize - 1 {
                ControlledOnInt(idx, ApplyXorInPlace)(indexReg, (database[idx], LittleEndian(intReg)));
            }

            // Set the desiredIntReg to |0&gt; if it is equal to solutionInt
            ApplyXorInPlace(solutionInt, LittleEndian(desiredIntReg));
            for (q0, q1) in Zipped(intReg, desiredIntReg) {
                CNOT(q0, q1);
            }
        } apply {
            ControlledOnInt(0, X)(desiredIntReg, targetReg);
        }
        
        // This will be the reflect about uniform
        within {
            ApplyToEachA(H, indexReg);
            ApplyToEachA(X, indexReg);
        } apply {
            Controlled Z(Most(indexReg), Tail(indexReg));
        }
    }
    set measuredIndex = MeasureInteger(LittleEndian(indexReg));
    Message($&quot;Desired integer: {solutionInt}, Integer of measured index: {database[measuredIndex]}&quot;);
    
}
</code></pre>
",qc,implementing oracle grover p need expert p suppose database say 16 entries db 0 db 1 db 2 db 15 want oracle mark indexes whose value gt example case oracle mark index 1 amp 15 grover algo able pick one desired index certain number iterations go p solution use q ol li create 4 quantum registers targetreg yreg x1reg li x1reg 4 qubits representing database indices uniform li x2reg qubits enough represent real numbers associated index case 7 qubits suffice simply multiply values 100 become integers li yreg number qubits x2reg initialized 80 multiplication li targetreg single li start iteration li within compare yreg x2reg set yreg gt x reg gt yreg li apply controlledonint 0 x yreg targetreg li perform li end li measure p done actually tried yet believe work although clue implement item 7 comparison wondering alternate ways p edit written q program finds marked entries strong equal desired entry seems working fine although apologies code looks em amateurish since started learn q month ago need find find marked entries strong greater desired pre code operation groversearchintdatabase unit let indexreglength 4 number qubits represent database indices let intreglength 7 number qubits represent integers generate database randomly let databasesize 2 indexreglength mutable database 0 size databasesize idx 0 databasesize 1 set database idx lt drawrandomint 0 2 intreglength 1 randomly select index pointing desired integer let solutionindex drawrandomint 0 databasesize 1 let solutionint database solutionindex message quot desired integer solutionint quot find many indices desired integer let predicate equali solutionint let nsolutions count predicate database message quot number indices integer nsolutions quot initiailize quantum registers use indexreg qubit indexreglength use intreg qubit intreglength use desiredintreg qubit intreglength use targetreg qubit let niterations floor sqrt intasdouble databasesize intasdouble nsolutions pi mutable measuredindex 0 theoretical success probability let sin intasdouble niterations arcsin sqrt intasdouble nsolutions sqrt intasdouble databasesize message quot success probability quot grover search applytoeach h indexreg 1 niterations oracle within x targetreg h targetreg associate integers corresponding indices idx 0 databasesize 1 controlledonint idx applyxorinplace indexreg database idx littleendian intreg set desiredintreg gt equal solutionint applyxorinplace solutionint littleendian desiredintreg q0 q1 zipped intreg desiredintreg cnot q0 q1 apply controlledonint 0 x desiredintreg targetreg reflect uniform within applytoeacha h indexreg applytoeacha x indexreg apply controlled z indexreg tail indexreg set measuredindex measureinteger littleendian indexreg message quot desired integer solutionint integer measured index database measuredindex quot,"[(0, 0.11997987), (2, 0.06839511), (3, 0.064706855), (6, 0.03872741), (7, 0.1535393), (8, 0.087178975), (10, 0.03546722), (13, 0.12999837), (16, 0.02857317), (18, 0.22556612), (19, 0.035671365)]"
24467,24492.0,2022-03-10 10:58:49,1,77,"<p>I am developing a sampling algorithm using Fourier analysis of Boolean functions for which I use Google's Cirq to obtain the state vector with .simulate().</p>
<p>I wanted to know what sampling algorithm Google Cirq implements with .sample() so that I can have a better idea of how to benchmark it against my algorithm. I have been looking at the docs and source code of cirq.sim.Simulator (<a href=""https://quantumai.google/reference/python/cirq/sim/Simulator"" rel=""nofollow noreferrer"">https://quantumai.google/reference/python/cirq/sim/Simulator</a>), but I cannot find what sampling algorithm their .run() and .sample() methods use.</p>
",Implementation of .run() methods in google Cirq,<programming><quantum-algorithms><cirq>,1,0,,,"Implementation of .run() methods in google Cirq <p>I am developing a sampling algorithm using Fourier analysis of Boolean functions for which I use Google's Cirq to obtain the state vector with .simulate().</p>
<p>I wanted to know what sampling algorithm Google Cirq implements with .sample() so that I can have a better idea of how to benchmark it against my algorithm. I have been looking at the docs and source code of cirq.sim.Simulator (<a href=""https://quantumai.google/reference/python/cirq/sim/Simulator"" rel=""nofollow noreferrer"">https://quantumai.google/reference/python/cirq/sim/Simulator</a>), but I cannot find what sampling algorithm their .run() and .sample() methods use.</p>
",qc,implementation methods google cirq p developing sampling algorithm using fourier analysis boolean functions use google cirq obtain state vector p wanted know sampling algorithm google cirq implements better idea benchmark algorithm looking docs source code https nofollow noreferrer https find sampling algorithm methods,"[(4, 0.09222767), (7, 0.2614947), (8, 0.33681327), (13, 0.11227033), (14, 0.13032015), (16, 0.063632354)]"
24556,,2022-03-17 19:07:06,2,451,"<p>Let us first introduce two fundamental functions for coordinate transformations:</p>
<pre><code>def to_spherical(state):
    r0 = np.abs(state[0])
    ϕ0 = np.angle(state[0])
    r1 = np.abs(state[1])
    ϕ1 = np.angle(state[1])
    r = np.sqrt(r0 ** 2 + r1 ** 2)
    θ = 2 * np.arccos(r0 / r)
    ϕ = ϕ1 - ϕ0
    return [r, θ, ϕ]

def to_cartesian(polar):
    r = polar[0]
    θ = polar[1]
    ϕ = polar[2]
    x = r * np.sin(θ) * np.cos(ϕ)
    y = r * np.sin(θ) * np.sin(ϕ)
    z = r * np.cos(θ)
    return [x, y, z]
</code></pre>
<p>I am rotating stepwise a qubit using the <span class=""math-container"">$SO(3)$</span> group as follows:</p>
<pre><code>import qutip as qt
from qutip.qip.operations import rx
import numpy as np

def rn_so3(state, theta, phi, delta):
    rn_mat = qt.Qobj(
        [[np.cos(delta/2) - (0+1j)*np.cos(theta)*np.sin(delta/2),
          -(0+1j)*np.exp(-(0+1j)*phi)*np.sin(delta/2)*np.sin(theta)],
         [-(0+1j)*np.exp((0+1j)*phi)*np.sin(delta/2)*np.sin(theta),
          np.cos(delta/2) + (0+1j)*np.cos(theta)*np.sin(delta/2)]]
        )
    r_state = (rn_mat*state)*(rn_mat*state).dag()
    return(r_state)

b = qt.Bloch()
b.clear()
b.make_sphere()

states = []
points = []

alpha = 1/np.sqrt(2)
beta = 1/np.sqrt(2)
s = np.array([alpha,beta])
state = qt.Qobj(s)
states.append(state)

Ψ = [complex(alpha, 0), complex(beta, 0)]
polar = to_spherical(Ψ)
pnt = to_cartesian(polar)
points.append(pnt)

rotated = state
for i in range(0,10):
    rotated = rn_so3(rotated, 0.4, 0.3, 0.2)
    pnt = [(qt.sigmax()*rotated).tr(), (qt.sigmay()*rotated).tr(), (qt.sigmaz()*rotated).tr()]
    states.append(rotated)
    points.append(pnt)

b.add_states(states)
np_points = np.array(points)
b.add_points([np_points[:,0], np_points[:,1], np_points[:,2]])
b.show()
</code></pre>
<p>This seems to work and the corresponding output looks as follows:</p>
<p><a href=""https://i.sstatic.net/hDmqy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hDmqy.png"" alt=""enter image description here"" /></a></p>
<p>To retrace elementary relationships and &quot;mechanics&quot; that happens under the hood, I am now trying to achieve the same using the <span class=""math-container"">$SU(2)$</span> group and coordinate transformations:</p>
<pre><code>def rn_su2(θ, ϕ):
    return (np.sin(θ)*np.cos(ϕ)*qt.sigmax() + np.sin(θ)*np.sin(ϕ)*qt.sigmay() + np.cos(θ)*qt.sigmaz())

b = qt.Bloch()
b.clear()
b.make_sphere()

states = []
points = []

alpha = 1/np.sqrt(2)
beta = 1/np.sqrt(2)
s = np.array([alpha,beta])
state = qt.Qobj(s)
states.append(state)

Ψ = [complex(alpha, 0), complex(beta, 0)]
polar = to_spherical(Ψ)
pnt = to_cartesian(polar)
points.append(pnt)

rotated = state
for i in range(0,10):
    #
    # Here seems to go something wrong
    #
    rotated = rn_su2(0.2*i, 0.3*i)
    states.append(rotated)

    #polar = to_spherical(rotated)
    #pnt = to_cartesian(polar)    
    points.append(pnt)

b.add_states(states)

np_points = np.array(points)
b.add_points([np_points[:,0], np_points[:,1], np_points[:,2]])
b.show()
</code></pre>
<p>Here I have some fundamental error and would appreciate any help or hint. The full notebook is also available <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/playground.ipynb"" rel=""nofollow noreferrer"">here</a> at GitHub.</p>
<p><em><strong>Update 2022-03-19:</strong></em>
I implemented the <span class=""math-container"">$SU(2)$</span> rotation according the useful hint in the comment. It looks better, but unfortunatelly the state lies not on the Bloch Sphere anymore:</p>
<pre><code>def rn_su2(θ, state, nx, ny, nz):
    Ψ = [state.data[0,0], state.data[1,0]]
    arr = to_spherical(Ψ)
    s_θ = arr[1]
    s_ϕ = arr[2]
    M_q = np.sin(s_θ)*np.cos(s_ϕ)*qt.sigmax() + np.sin(s_θ)*np.sin(s_ϕ)*qt.sigmay() + np.cos(s_θ)*qt.sigmaz()
    U_n = qt.qeye(2)*np.cos(θ/2) -1j*(nx*qt.sigmax()+ny*qt.sigmay()+nz*qt.sigmaz())*np.sin(θ/2)
    r_state = U_n*M_q*U_n.dag()
    return r_state
</code></pre>
<p><em><strong>Update 2022-03-20:</strong></em>
Thanks to the unveiling <a href=""https://quantumcomputing.stackexchange.com/questions/25574/how-do-i-implement-su2-rotation-on-the-bloch-sphere-unsing-qutip/25583#25583"">answer here</a>, the <span class=""math-container"">$SU(2)$</span> rotations look good and correct:</p>
<p><a href=""https://i.sstatic.net/ZpJCi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZpJCi.png"" alt=""enter image description here"" /></a></p>
<p>What remains is the question: How do you have to rotate so that both point sequences look the same? In the <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_so3.ipynb"" rel=""nofollow noreferrer""><span class=""math-container"">$SO(3)$</span> implementation</a> case I used <code>rotated = rn_so3(rotated, 0.4, 0.3, 0.2)</code> and to get an almost same looking picture, by trial and error, I obtained for the <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2.ipynb"" rel=""nofollow noreferrer""><span class=""math-container"">$SU(2)$</span> implementation</a>:</p>
<pre><code>rotated = rn_su2(0.05, rotated, 1, 0, 0)
rotated = rn_su2(0.02, rotated, 0, 1, 0)
rotated = rn_su2(0.2, rotated, 0, 0, 1)
</code></pre>
<p>How are the angles to be used related in both cases?</p>
<p><a href=""https://i.sstatic.net/cN5VM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cN5VM.png"" alt=""enter image description here"" /></a></p>
",How do I stepwise rotate a qubit on a Bloch sphere using $SO(3)$ and $SU(2)$ group?,<experimental-realization><bloch-sphere><qutip>,1,0,,,"How do I stepwise rotate a qubit on a Bloch sphere using $SO(3)$ and $SU(2)$ group? <p>Let us first introduce two fundamental functions for coordinate transformations:</p>
<pre><code>def to_spherical(state):
    r0 = np.abs(state[0])
    ϕ0 = np.angle(state[0])
    r1 = np.abs(state[1])
    ϕ1 = np.angle(state[1])
    r = np.sqrt(r0 ** 2 + r1 ** 2)
    θ = 2 * np.arccos(r0 / r)
    ϕ = ϕ1 - ϕ0
    return [r, θ, ϕ]

def to_cartesian(polar):
    r = polar[0]
    θ = polar[1]
    ϕ = polar[2]
    x = r * np.sin(θ) * np.cos(ϕ)
    y = r * np.sin(θ) * np.sin(ϕ)
    z = r * np.cos(θ)
    return [x, y, z]
</code></pre>
<p>I am rotating stepwise a qubit using the <span class=""math-container"">$SO(3)$</span> group as follows:</p>
<pre><code>import qutip as qt
from qutip.qip.operations import rx
import numpy as np

def rn_so3(state, theta, phi, delta):
    rn_mat = qt.Qobj(
        [[np.cos(delta/2) - (0+1j)*np.cos(theta)*np.sin(delta/2),
          -(0+1j)*np.exp(-(0+1j)*phi)*np.sin(delta/2)*np.sin(theta)],
         [-(0+1j)*np.exp((0+1j)*phi)*np.sin(delta/2)*np.sin(theta),
          np.cos(delta/2) + (0+1j)*np.cos(theta)*np.sin(delta/2)]]
        )
    r_state = (rn_mat*state)*(rn_mat*state).dag()
    return(r_state)

b = qt.Bloch()
b.clear()
b.make_sphere()

states = []
points = []

alpha = 1/np.sqrt(2)
beta = 1/np.sqrt(2)
s = np.array([alpha,beta])
state = qt.Qobj(s)
states.append(state)

Ψ = [complex(alpha, 0), complex(beta, 0)]
polar = to_spherical(Ψ)
pnt = to_cartesian(polar)
points.append(pnt)

rotated = state
for i in range(0,10):
    rotated = rn_so3(rotated, 0.4, 0.3, 0.2)
    pnt = [(qt.sigmax()*rotated).tr(), (qt.sigmay()*rotated).tr(), (qt.sigmaz()*rotated).tr()]
    states.append(rotated)
    points.append(pnt)

b.add_states(states)
np_points = np.array(points)
b.add_points([np_points[:,0], np_points[:,1], np_points[:,2]])
b.show()
</code></pre>
<p>This seems to work and the corresponding output looks as follows:</p>
<p><a href=""https://i.sstatic.net/hDmqy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hDmqy.png"" alt=""enter image description here"" /></a></p>
<p>To retrace elementary relationships and &quot;mechanics&quot; that happens under the hood, I am now trying to achieve the same using the <span class=""math-container"">$SU(2)$</span> group and coordinate transformations:</p>
<pre><code>def rn_su2(θ, ϕ):
    return (np.sin(θ)*np.cos(ϕ)*qt.sigmax() + np.sin(θ)*np.sin(ϕ)*qt.sigmay() + np.cos(θ)*qt.sigmaz())

b = qt.Bloch()
b.clear()
b.make_sphere()

states = []
points = []

alpha = 1/np.sqrt(2)
beta = 1/np.sqrt(2)
s = np.array([alpha,beta])
state = qt.Qobj(s)
states.append(state)

Ψ = [complex(alpha, 0), complex(beta, 0)]
polar = to_spherical(Ψ)
pnt = to_cartesian(polar)
points.append(pnt)

rotated = state
for i in range(0,10):
    #
    # Here seems to go something wrong
    #
    rotated = rn_su2(0.2*i, 0.3*i)
    states.append(rotated)

    #polar = to_spherical(rotated)
    #pnt = to_cartesian(polar)    
    points.append(pnt)

b.add_states(states)

np_points = np.array(points)
b.add_points([np_points[:,0], np_points[:,1], np_points[:,2]])
b.show()
</code></pre>
<p>Here I have some fundamental error and would appreciate any help or hint. The full notebook is also available <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/playground.ipynb"" rel=""nofollow noreferrer"">here</a> at GitHub.</p>
<p><em><strong>Update 2022-03-19:</strong></em>
I implemented the <span class=""math-container"">$SU(2)$</span> rotation according the useful hint in the comment. It looks better, but unfortunatelly the state lies not on the Bloch Sphere anymore:</p>
<pre><code>def rn_su2(θ, state, nx, ny, nz):
    Ψ = [state.data[0,0], state.data[1,0]]
    arr = to_spherical(Ψ)
    s_θ = arr[1]
    s_ϕ = arr[2]
    M_q = np.sin(s_θ)*np.cos(s_ϕ)*qt.sigmax() + np.sin(s_θ)*np.sin(s_ϕ)*qt.sigmay() + np.cos(s_θ)*qt.sigmaz()
    U_n = qt.qeye(2)*np.cos(θ/2) -1j*(nx*qt.sigmax()+ny*qt.sigmay()+nz*qt.sigmaz())*np.sin(θ/2)
    r_state = U_n*M_q*U_n.dag()
    return r_state
</code></pre>
<p><em><strong>Update 2022-03-20:</strong></em>
Thanks to the unveiling <a href=""https://quantumcomputing.stackexchange.com/questions/25574/how-do-i-implement-su2-rotation-on-the-bloch-sphere-unsing-qutip/25583#25583"">answer here</a>, the <span class=""math-container"">$SU(2)$</span> rotations look good and correct:</p>
<p><a href=""https://i.sstatic.net/ZpJCi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZpJCi.png"" alt=""enter image description here"" /></a></p>
<p>What remains is the question: How do you have to rotate so that both point sequences look the same? In the <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_so3.ipynb"" rel=""nofollow noreferrer""><span class=""math-container"">$SO(3)$</span> implementation</a> case I used <code>rotated = rn_so3(rotated, 0.4, 0.3, 0.2)</code> and to get an almost same looking picture, by trial and error, I obtained for the <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2.ipynb"" rel=""nofollow noreferrer""><span class=""math-container"">$SU(2)$</span> implementation</a>:</p>
<pre><code>rotated = rn_su2(0.05, rotated, 1, 0, 0)
rotated = rn_su2(0.02, rotated, 0, 1, 0)
rotated = rn_su2(0.2, rotated, 0, 0, 1)
</code></pre>
<p>How are the angles to be used related in both cases?</p>
<p><a href=""https://i.sstatic.net/cN5VM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cN5VM.png"" alt=""enter image description here"" /></a></p>
",qc,stepwise rotate qubit bloch sphere using 3 su 2 group p let us first introduce two fundamental functions coordinate transformations pre code def state r0 state 0 ϕ0 state 0 r1 state 1 ϕ1 state 1 r r0 2 r1 2 θ 2 r0 r ϕ ϕ1 ϕ0 return r θ ϕ def polar r polar 0 θ polar 1 ϕ polar 2 x r θ ϕ r θ ϕ z r θ return x z p rotating stepwise qubit using span 3 group follows pre code import qutip qt import rx import numpy np def state theta phi delta theta phi theta phi theta theta state state return b states points alpha 2 beta 2 alpha beta state state ψ complex alpha 0 complex beta 0 polar ψ pnt polar pnt rotated state range rotated rotated pnt rotated rotated rotated rotated pnt states points p seems work corresponding output looks follows p https nofollow noreferrer img https enter image description p retrace elementary relationships quot mechanics quot happens hood trying achieve using span su 2 group coordinate transformations pre code def θ ϕ return θ ϕ θ ϕ θ b states points alpha 2 beta 2 alpha beta state state ψ complex alpha 0 complex beta 0 polar ψ pnt polar pnt rotated state range seems go something wrong rotated rotated polar rotated pnt polar pnt states points p fundamental error would appreciate help hint full notebook also available https nofollow noreferrer p em strong update implemented span su 2 rotation according useful hint comment looks better unfortunatelly state lies bloch sphere anymore pre code def θ state nx ny nz ψ arr ψ arr 1 arr 2 2 nx return p em strong update thanks unveiling https 25583 answer span su 2 rotations look good correct p https nofollow noreferrer img https enter image description p remains question rotate point sequences look https nofollow noreferrer span 3 implementation case used code rotated rotated get almost looking picture trial error obtained https nofollow noreferrer span su 2 implementation pre code rotated rotated 1 0 0 rotated rotated 0 1 0 rotated rotated 0 0 1 p angles used related cases p https nofollow noreferrer img https enter image description,"[(0, 0.23691659), (2, 0.121539585), (3, 0.09107958), (4, 0.14586063), (8, 0.020409659), (9, 0.24035186), (16, 0.041605774), (18, 0.094234355)]"
24559,25561.0,2022-03-18 00:22:34,2,70,"<p>Currently, I reading the toric code section in the beginning of the paper <em>Topological Quantum Memory</em>. Here are a couple of sections that are somewhat confusing to me.</p>
<p>(1)</p>
<p>This quote below is under a small section that gives general remarks about surface codes.</p>
<blockquote>
<blockquote>
<p>These codes are especially well
suited for fault-tolerant implementation, because the procedure for measuring the error syndrome is highly local.</p>
</blockquote>
</blockquote>
<p><strong>Question: Why is this locality important? My guess is local errors do not destroy the quantum information if the information is distributed throughout the lattice, but I am not sure if this is what the author had in mind.</strong></p>
<p>(3)
<strong>Question: Throughout the section on the toric code, I see the words &quot;preserves the code subspace,&quot; but I am not sure what the meaning is. What is a code subspace and what does it mean to preserve it?</strong></p>
",Questions on Definitions and Concepts Regarding Toric Codes,<stabilizer-code><architecture><fault-tolerance><toric-code>,1,2,,,"Questions on Definitions and Concepts Regarding Toric Codes <p>Currently, I reading the toric code section in the beginning of the paper <em>Topological Quantum Memory</em>. Here are a couple of sections that are somewhat confusing to me.</p>
<p>(1)</p>
<p>This quote below is under a small section that gives general remarks about surface codes.</p>
<blockquote>
<blockquote>
<p>These codes are especially well
suited for fault-tolerant implementation, because the procedure for measuring the error syndrome is highly local.</p>
</blockquote>
</blockquote>
<p><strong>Question: Why is this locality important? My guess is local errors do not destroy the quantum information if the information is distributed throughout the lattice, but I am not sure if this is what the author had in mind.</strong></p>
<p>(3)
<strong>Question: Throughout the section on the toric code, I see the words &quot;preserves the code subspace,&quot; but I am not sure what the meaning is. What is a code subspace and what does it mean to preserve it?</strong></p>
",qc,questions definitions concepts regarding toric codes p currently reading toric code section beginning paper em topological quantum memory couple sections somewhat confusing p 1 p quote small section gives general remarks surface blockquote blockquote p codes especially well suited implementation procedure measuring error syndrome highly p strong question locality important guess local errors destroy quantum information information distributed throughout lattice sure author p 3 strong question throughout section toric code see words quot preserves code subspace quot sure meaning code subspace mean preserve,"[(5, 0.28248978), (7, 0.0491058), (8, 0.10470931), (9, 0.39549187), (13, 0.084634975), (16, 0.012562632), (17, 0.042467672), (19, 0.027059358)]"
25574,25583.0,2022-03-19 10:38:26,1,503,"<p>Using <code>qutip</code> I am trying to implement a qubit rotation according the formula <span class=""math-container"">$(25)$</span> provided in this document <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">&quot;Lecture notes: Qubit representations and rotations</a>&quot;:</p>
<p><span class=""math-container"">$$
U_{\hat n}(\theta)=\sigma_0\cos\frac{\theta}{2}-i(\hat n\cdot \sigma)\sin\frac{\theta}{2}\\
$$</span></p>
<p><span class=""math-container"">$$
M_{q'}=U_{\hat n}(\theta)\cdot M_q\cdot U_{\hat n}^A(\theta)
$$</span></p>
<pre><code>import qutip as qt
from qutip.qip.operations import rx
import numpy as np

def to_spherical(state):
    r0 = np.abs(state[0])
    ϕ0 = np.angle(state[0])
    r1 = np.abs(state[1])
    ϕ1 = np.angle(state[1])
    r = np.sqrt(r0 ** 2 + r1 ** 2)
    θ = 2 * np.arccos(r0 / r)
    ϕ = ϕ1 - ϕ0
    return [r, θ, ϕ]

def rn_su2(θ, state, nx, ny, nz):
    Ψ = [state.data[0,0], state.data[1,0]]
    arr = to_spherical(Ψ)
    s_θ = arr[1]
    s_ϕ = arr[2]
    M_q = np.sin(s_θ)*np.cos(s_ϕ)*qt.sigmax() + np.sin(s_θ)*np.sin(s_ϕ)*qt.sigmay() + np.cos(s_θ)*qt.sigmaz()
    U_n = qt.qeye(2)*np.cos(θ/2) -1j*(nx*qt.sigmax()+ny*qt.sigmay()+nz*qt.sigmaz())*np.sin(θ/2)
    r_state = U_n*M_q*U_n.dag()
    return r_state

b = qt.Bloch()
b.clear()
b.make_sphere()

states = []
alpha = 1/np.sqrt(2)
beta = 1/np.sqrt(2)
s = np.array([alpha,beta])
state = qt.Qobj(s)
states.append(state)

rotated = rn_su2(np.pi/8, state, 0, 0, 1)
states.append(rotated)

rotated = rn_su2(np.pi/8, rotated, 0, 0, 1)
states.append(rotated)

b.add_states(states)
b.show()
</code></pre>
<p>Unfortunatelly the rotated qubits lie not on the Bloch Sphere anymore:</p>
<p><a href=""https://i.sstatic.net/d7LZD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/d7LZD.png"" alt=""enter image description here"" /></a></p>
<p>I would appreciate any help in getting this rotation working. I uploaded the <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2.ipynb"" rel=""nofollow noreferrer"">complete notebook</a> publicly at GitHub.</p>
",How do I implement $SU(2)$ rotation on the Bloch Sphere unsing qutip?,<experimental-realization><bloch-sphere><qutip>,1,0,,,"How do I implement $SU(2)$ rotation on the Bloch Sphere unsing qutip? <p>Using <code>qutip</code> I am trying to implement a qubit rotation according the formula <span class=""math-container"">$(25)$</span> provided in this document <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">&quot;Lecture notes: Qubit representations and rotations</a>&quot;:</p>
<p><span class=""math-container"">$$
U_{\hat n}(\theta)=\sigma_0\cos\frac{\theta}{2}-i(\hat n\cdot \sigma)\sin\frac{\theta}{2}\\
$$</span></p>
<p><span class=""math-container"">$$
M_{q'}=U_{\hat n}(\theta)\cdot M_q\cdot U_{\hat n}^A(\theta)
$$</span></p>
<pre><code>import qutip as qt
from qutip.qip.operations import rx
import numpy as np

def to_spherical(state):
    r0 = np.abs(state[0])
    ϕ0 = np.angle(state[0])
    r1 = np.abs(state[1])
    ϕ1 = np.angle(state[1])
    r = np.sqrt(r0 ** 2 + r1 ** 2)
    θ = 2 * np.arccos(r0 / r)
    ϕ = ϕ1 - ϕ0
    return [r, θ, ϕ]

def rn_su2(θ, state, nx, ny, nz):
    Ψ = [state.data[0,0], state.data[1,0]]
    arr = to_spherical(Ψ)
    s_θ = arr[1]
    s_ϕ = arr[2]
    M_q = np.sin(s_θ)*np.cos(s_ϕ)*qt.sigmax() + np.sin(s_θ)*np.sin(s_ϕ)*qt.sigmay() + np.cos(s_θ)*qt.sigmaz()
    U_n = qt.qeye(2)*np.cos(θ/2) -1j*(nx*qt.sigmax()+ny*qt.sigmay()+nz*qt.sigmaz())*np.sin(θ/2)
    r_state = U_n*M_q*U_n.dag()
    return r_state

b = qt.Bloch()
b.clear()
b.make_sphere()

states = []
alpha = 1/np.sqrt(2)
beta = 1/np.sqrt(2)
s = np.array([alpha,beta])
state = qt.Qobj(s)
states.append(state)

rotated = rn_su2(np.pi/8, state, 0, 0, 1)
states.append(rotated)

rotated = rn_su2(np.pi/8, rotated, 0, 0, 1)
states.append(rotated)

b.add_states(states)
b.show()
</code></pre>
<p>Unfortunatelly the rotated qubits lie not on the Bloch Sphere anymore:</p>
<p><a href=""https://i.sstatic.net/d7LZD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/d7LZD.png"" alt=""enter image description here"" /></a></p>
<p>I would appreciate any help in getting this rotation working. I uploaded the <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2.ipynb"" rel=""nofollow noreferrer"">complete notebook</a> publicly at GitHub.</p>
",qc,implement su 2 rotation bloch sphere unsing qutip p using code qutip trying implement qubit rotation according formula span 25 provided document https nofollow noreferrer quot lecture notes qubit representations rotations quot p span n 2 2 p span q n n pre code import qutip qt import rx import numpy np def state r0 state 0 ϕ0 state 0 r1 state 1 ϕ1 state 1 r r0 2 r1 2 θ 2 r0 r ϕ ϕ1 ϕ0 return r θ ϕ def θ state nx ny nz ψ arr ψ arr 1 arr 2 2 nx return b states alpha 2 beta 2 alpha beta state state rotated state 0 0 1 rotated rotated rotated 0 0 1 rotated states p unfortunatelly rotated qubits lie bloch sphere anymore p https nofollow noreferrer img https enter image description p would appreciate help getting rotation working uploaded https nofollow noreferrer complete notebook publicly,"[(0, 0.24226712), (2, 0.18745118), (3, 0.101797536), (4, 0.14599259), (9, 0.15432185), (11, 0.024003362), (16, 0.039535128), (18, 0.09211093), (19, 0.011694171)]"
25605,25606.0,2022-03-21 14:52:18,1,159,"<p>I am trying to understand why we need to put the boundary data qubits in the ground state <span class=""math-container"">$|0\rangle$</span> for a rough merging procedure.</p>
<p>From my current understanding, if no errors occurred (perfect qubits) it would be unnecessary. The point of doing it is only in order to preserve fault tolerance.</p>
<p><a href=""https://i.sstatic.net/RgTXW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RgTXW.png"" alt=""enter image description here"" /></a></p>
<p>In this image (taken from <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Horsman's</a> paper), we have two surfaces (left and right) containing a single logical qubit. I call the left and right logical states <span class=""math-container"">$|\psi_L\rangle=\alpha|0\rangle+\beta|1\rangle$</span> and <span class=""math-container"">$|\psi_R\rangle=\alpha'|0\rangle+\beta'|1\rangle$</span>. Then we will merge those two surfaces following the two steps:</p>
<ol>
<li>Put all the pink data qubits in <span class=""math-container"">$|0\rangle$</span></li>
<li>Treat all the qubits as if we had a single surface. In practice it means that we include the pink data qubits in the <span class=""math-container"">$Z$</span> stabilizer measurements, and we measure the <span class=""math-container"">$X$</span> stabilizers at the boundary. To ensure fault-tolerance we then measure the stabilizers for <span class=""math-container"">$d$</span> clock cycles (<span class=""math-container"">$d$</span> being the code distance).</li>
</ol>
<p>When doing step 2, we see that the product of the <span class=""math-container"">$X$</span> stabilizer measurement will be equal to <span class=""math-container"">$X_L X_R$</span> (the product of the logical Pauli of the two surfaces). Based on that, and after some calculations and some conventions taken, we can show that the resulting surface will have a quantum state being</p>
<p><span class=""math-container"">$$|\Psi\rangle=\alpha |\psi_R\rangle + \beta X (-1)^M |\psi_R \rangle$$</span></p>
<p>Where <span class=""math-container"">$M$</span> is the eigenvalue of <span class=""math-container"">$X_L X_R$</span>.</p>
<hr />
<p>In the absence of any errors, for me it is unnecessary to put the intermediate pink data qubits in <span class=""math-container"">$|0\rangle$</span> (hence step 1). Indeed, we don't need step 1 to see that <span class=""math-container"">$X_L^1 X_L^2$</span> is being measured. And the reasoning yielding a final state being <span class=""math-container"">$|\Psi\rangle$</span> doesn't need to know that the pink qubits were initially in <span class=""math-container"">$|0\rangle$</span> (at least from my understanding, please correct me if you believe I am wrong).</p>
<p>For this reason, I guess that step 1 is here, to ensure fault tolerance. I would like to understand <strong>precisely</strong> why it is necessary.</p>
<p>While I am here focused on merging procedure, the philosophy behind my question is more general. It is very frequent to have to put qubits in some specific state before turning on or off stabilizer measurements and I really struggle to understand why. A related question has been asked <a href=""https://quantumcomputing.stackexchange.com/questions/23673/initializing-a-logical-qubits-in-g-rangle-for-an-x-cut-logical-qubit-in-surfa"">here</a> (but I don't get the answer there either).</p>
",Why the boundary data qubits have to be put in the ground state for lattice surgery rough merging,<fault-tolerance><surface-code>,1,0,,,"Why the boundary data qubits have to be put in the ground state for lattice surgery rough merging <p>I am trying to understand why we need to put the boundary data qubits in the ground state <span class=""math-container"">$|0\rangle$</span> for a rough merging procedure.</p>
<p>From my current understanding, if no errors occurred (perfect qubits) it would be unnecessary. The point of doing it is only in order to preserve fault tolerance.</p>
<p><a href=""https://i.sstatic.net/RgTXW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RgTXW.png"" alt=""enter image description here"" /></a></p>
<p>In this image (taken from <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Horsman's</a> paper), we have two surfaces (left and right) containing a single logical qubit. I call the left and right logical states <span class=""math-container"">$|\psi_L\rangle=\alpha|0\rangle+\beta|1\rangle$</span> and <span class=""math-container"">$|\psi_R\rangle=\alpha'|0\rangle+\beta'|1\rangle$</span>. Then we will merge those two surfaces following the two steps:</p>
<ol>
<li>Put all the pink data qubits in <span class=""math-container"">$|0\rangle$</span></li>
<li>Treat all the qubits as if we had a single surface. In practice it means that we include the pink data qubits in the <span class=""math-container"">$Z$</span> stabilizer measurements, and we measure the <span class=""math-container"">$X$</span> stabilizers at the boundary. To ensure fault-tolerance we then measure the stabilizers for <span class=""math-container"">$d$</span> clock cycles (<span class=""math-container"">$d$</span> being the code distance).</li>
</ol>
<p>When doing step 2, we see that the product of the <span class=""math-container"">$X$</span> stabilizer measurement will be equal to <span class=""math-container"">$X_L X_R$</span> (the product of the logical Pauli of the two surfaces). Based on that, and after some calculations and some conventions taken, we can show that the resulting surface will have a quantum state being</p>
<p><span class=""math-container"">$$|\Psi\rangle=\alpha |\psi_R\rangle + \beta X (-1)^M |\psi_R \rangle$$</span></p>
<p>Where <span class=""math-container"">$M$</span> is the eigenvalue of <span class=""math-container"">$X_L X_R$</span>.</p>
<hr />
<p>In the absence of any errors, for me it is unnecessary to put the intermediate pink data qubits in <span class=""math-container"">$|0\rangle$</span> (hence step 1). Indeed, we don't need step 1 to see that <span class=""math-container"">$X_L^1 X_L^2$</span> is being measured. And the reasoning yielding a final state being <span class=""math-container"">$|\Psi\rangle$</span> doesn't need to know that the pink qubits were initially in <span class=""math-container"">$|0\rangle$</span> (at least from my understanding, please correct me if you believe I am wrong).</p>
<p>For this reason, I guess that step 1 is here, to ensure fault tolerance. I would like to understand <strong>precisely</strong> why it is necessary.</p>
<p>While I am here focused on merging procedure, the philosophy behind my question is more general. It is very frequent to have to put qubits in some specific state before turning on or off stabilizer measurements and I really struggle to understand why. A related question has been asked <a href=""https://quantumcomputing.stackexchange.com/questions/23673/initializing-a-logical-qubits-in-g-rangle-for-an-x-cut-logical-qubit-in-surfa"">here</a> (but I don't get the answer there either).</p>
",qc,boundary data qubits put ground state lattice surgery rough merging p trying understand need put boundary data qubits ground state span rough merging p current understanding errors occurred perfect qubits would unnecessary point order preserve fault p https nofollow noreferrer img https enter image description p image taken https nofollow noreferrer horsman paper two surfaces left right containing single logical qubit call left right logical states span span merge two surfaces following two steps ol li put pink data qubits span li treat qubits single surface practice means include pink data qubits span z stabilizer measurements measure span x stabilizers boundary ensure measure stabilizers span clock cycles span code distance p step 2 see product span x stabilizer measurement equal span product logical pauli two surfaces based calculations conventions taken show resulting surface quantum state p span x p span eigenvalue span hr p absence errors unnecessary put intermediate pink data qubits span hence step 1 indeed need step 1 see span measured reasoning yielding final state span need know pink qubits initially span least understanding please correct believe wrong p reason guess step 1 ensure fault tolerance would like understand strong precisely p focused merging procedure philosophy behind question general frequent put qubits specific state turning stabilizer measurements really struggle understand related question asked https get answer either,"[(1, 0.011084705), (3, 0.17590792), (4, 0.073648624), (5, 0.25308007), (8, 0.04264416), (9, 0.021288773), (10, 0.013201662), (13, 0.2661917), (16, 0.025897387), (18, 0.11659593)]"
25664,25674.0,2022-03-26 02:14:25,2,303,"<p>I'm trying to find the threshold for dephasing error on a surface code. I've used the <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.8-Python-API-Reference#stimcircuitgeneratedcode_task-str--distance-int-rounds-int-after_clifford_depolarization-float--00-before_round_data_depolarization-float--00-before_measure_flip_probability-float--00-after_reset_flip_probability-float--00---stimcircuit"" rel=""nofollow noreferrer"">stim.Circuit.generated(&quot;surface_code_unrotated_memory_x&quot;)</a> function to generate a surface code lattice. To it, I'm appending the Z_ERROR operation with the specified noise and qubits it needs to act on.</p>
<p>However, when I call the count_logical_errors method that I picked up from the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">getting started tutorial</a>, I get ys = 0.0</p>
<p>Printing the circuit after appending Z_ERROR shows the Z_ERROR is applied. I am not able to figure out why count_logical_errors would return a 0.0</p>
",Adding dephasing to stim's generated surface code circuits,<error-correction><stim>,1,2,,,"Adding dephasing to stim's generated surface code circuits <p>I'm trying to find the threshold for dephasing error on a surface code. I've used the <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.8-Python-API-Reference#stimcircuitgeneratedcode_task-str--distance-int-rounds-int-after_clifford_depolarization-float--00-before_round_data_depolarization-float--00-before_measure_flip_probability-float--00-after_reset_flip_probability-float--00---stimcircuit"" rel=""nofollow noreferrer"">stim.Circuit.generated(&quot;surface_code_unrotated_memory_x&quot;)</a> function to generate a surface code lattice. To it, I'm appending the Z_ERROR operation with the specified noise and qubits it needs to act on.</p>
<p>However, when I call the count_logical_errors method that I picked up from the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">getting started tutorial</a>, I get ys = 0.0</p>
<p>Printing the circuit after appending Z_ERROR shows the Z_ERROR is applied. I am not able to figure out why count_logical_errors would return a 0.0</p>
",qc,adding dephasing stim generated surface code circuits p trying find threshold dephasing error surface code used https 00 nofollow noreferrer quot quot function generate surface code lattice appending operation specified noise qubits needs act p however call method picked https nofollow noreferrer getting started tutorial get ys p printing circuit appending shows applied able figure would return,"[(0, 0.044171214), (4, 0.190937), (5, 0.2564308), (14, 0.3632176), (16, 0.023255777), (18, 0.057054844), (19, 0.06261816)]"
25733,,2022-04-01 02:43:26,1,64,"<p>In Q#,there are lots of expressions like &quot;Qubit[] =&gt; Result&quot;.
It can be the type of return result,like this:</p>
<pre><code>function TailMeasurement(nQubits : Int) : (Qubit[] =&gt; Result) {
        .......
    }
</code></pre>
<p>Sometimes it can be type of arguements,like this:</p>
<pre><code> operation EstimateFrequency (preparation : (Qubit[] =&gt; Unit), measurement : (Qubit[] =&gt; Result), nQubits : Int, nMeasurements : Int) : Double
    {....}
</code></pre>
<p>I think it's a method to declare the type of user-defined. But what's the meaning of it?
After reading the documents, I think it means the left is a detailed explanation of the right.
for example,preparation : (Qubit[] =&gt; Unit) means the type of preparation is Qubit[],and the element type of Qubit[]  is Unit. It may like the List in Java?
I just wondered if my understanding is right?</p>
","What's meaning of the expression like ""Qubit[] => Result""",<programming><q#>,0,8,,,"What's meaning of the expression like ""Qubit[] => Result"" <p>In Q#,there are lots of expressions like &quot;Qubit[] =&gt; Result&quot;.
It can be the type of return result,like this:</p>
<pre><code>function TailMeasurement(nQubits : Int) : (Qubit[] =&gt; Result) {
        .......
    }
</code></pre>
<p>Sometimes it can be type of arguements,like this:</p>
<pre><code> operation EstimateFrequency (preparation : (Qubit[] =&gt; Unit), measurement : (Qubit[] =&gt; Result), nQubits : Int, nMeasurements : Int) : Double
    {....}
</code></pre>
<p>I think it's a method to declare the type of user-defined. But what's the meaning of it?
After reading the documents, I think it means the left is a detailed explanation of the right.
for example,preparation : (Qubit[] =&gt; Unit) means the type of preparation is Qubit[],and the element type of Qubit[]  is Unit. It may like the List in Java?
I just wondered if my understanding is right?</p>
",qc,meaning expression like qubit result p q lots expressions like quot qubit gt result quot type return result like pre code function tailmeasurement nqubits int qubit gt result p sometimes type arguements like pre code operation estimatefrequency preparation qubit gt unit measurement qubit gt result nqubits int nmeasurements int double p think method declare type meaning reading documents think means left detailed explanation right example preparation qubit gt unit means type preparation qubit element type qubit unit may like list java wondered understanding right,"[(0, 0.29123664), (4, 0.05708544), (5, 0.06952413), (9, 0.07024646), (13, 0.31339958), (16, 0.043511037), (18, 0.11094002), (19, 0.042540584)]"
25769,25772.0,2022-04-02 16:21:34,1,673,"<p>Could somebody explain in which way are we able to achieve superposition with Pauli <span class=""math-container"">$X$</span>, <span class=""math-container"">$Y$</span>, <span class=""math-container"">$Z$</span> matrices? In case of <strong>Hadamard gate</strong> <span class=""math-container"">$H$</span> we change coefficients to <span class=""math-container"">$1/\sqrt{2}$</span> directly, in case of <strong><span class=""math-container"">$X$</span> and <span class=""math-container"">$Y$</span> rotation gates</strong> we apply angle of rotation around <span class=""math-container"">$X$</span> and <span class=""math-container"">$Y$</span> and transform qubit to superposition state. But none of Pauli matrices are applying superposition state to qubit; am I missing something?</p>
",How to obtain the state $|0\rangle+|1\rangle$ from $|0\rangle$ via Pauli gates?,<pauli-gates><hadamard><superposition>,2,3,,,"How to obtain the state $|0\rangle+|1\rangle$ from $|0\rangle$ via Pauli gates? <p>Could somebody explain in which way are we able to achieve superposition with Pauli <span class=""math-container"">$X$</span>, <span class=""math-container"">$Y$</span>, <span class=""math-container"">$Z$</span> matrices? In case of <strong>Hadamard gate</strong> <span class=""math-container"">$H$</span> we change coefficients to <span class=""math-container"">$1/\sqrt{2}$</span> directly, in case of <strong><span class=""math-container"">$X$</span> and <span class=""math-container"">$Y$</span> rotation gates</strong> we apply angle of rotation around <span class=""math-container"">$X$</span> and <span class=""math-container"">$Y$</span> and transform qubit to superposition state. But none of Pauli matrices are applying superposition state to qubit; am I missing something?</p>
",qc,obtain state via pauli gates p could somebody explain way able achieve superposition pauli span x span span z matrices case strong hadamard gate span h change coefficients span 2 directly case strong span x span rotation gates apply angle rotation around span x span transform qubit superposition state none pauli matrices applying superposition state qubit missing something,"[(3, 0.42500058), (9, 0.19058722), (10, 0.055497017), (16, 0.017999886), (18, 0.3083376)]"
25808,25813.0,2022-04-05 11:47:50,6,2671,"<p>I have just started learning Quantum computing.</p>
<blockquote>
<p>Pairs of qubits that are “entangled,” which means the two members of a pair exist in a single quantum state. Changing the state of one of the qubits will instantaneously change the state of the other one in a predictable way</p>
</blockquote>
<p>For the below circuit, is this entanglement because changing q0 we are changing q1? if yes, is it so easy to create entanglement?
<a href=""https://i.sstatic.net/if3ie.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/if3ie.png"" alt=""enter image description here"" /></a></p>
",does CNOT gate cause entanglement?,<entanglement><circuit-construction>,3,0,,,"does CNOT gate cause entanglement? <p>I have just started learning Quantum computing.</p>
<blockquote>
<p>Pairs of qubits that are “entangled,” which means the two members of a pair exist in a single quantum state. Changing the state of one of the qubits will instantaneously change the state of the other one in a predictable way</p>
</blockquote>
<p>For the below circuit, is this entanglement because changing q0 we are changing q1? if yes, is it so easy to create entanglement?
<a href=""https://i.sstatic.net/if3ie.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/if3ie.png"" alt=""enter image description here"" /></a></p>
",qc,cnot gate cause entanglement p started learning quantum blockquote p pairs qubits entangled means two members pair exist single quantum state changing state one qubits instantaneously change state one predictable way p circuit entanglement changing q0 changing q1 yes easy create entanglement https noreferrer img https enter image description,"[(4, 0.2535362), (6, 0.02030318), (8, 0.0924466), (16, 0.042684518), (18, 0.5878453)]"
25868,25903.0,2022-04-08 02:13:42,0,327,"<p>For the following code</p>
<pre><code>qc = QuantumCircuit(2)
qc.cx(0,1)
qc.measure_all()
qc.draw()
</code></pre>
<p>Q1: What this vertical dotted line represent in the below circuit diagram?</p>
<p>Q2: 'meas' wire in the circuit is what kind of wire? is this classical wire or qubit wire?</p>
<p>Q3: How qc.measure_all() is different from  qc.measure([0,1],[0,1])[couldn't find a simple answer on internet]</p>
<p><a href=""https://i.sstatic.net/3cKdf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/3cKdf.png"" alt=""Circuit Diagram"" /></a></p>
",What is measure_all function and the vertical dotted line represent in the circuit?,<circuit-construction><quantum-circuit>,2,0,,,"What is measure_all function and the vertical dotted line represent in the circuit? <p>For the following code</p>
<pre><code>qc = QuantumCircuit(2)
qc.cx(0,1)
qc.measure_all()
qc.draw()
</code></pre>
<p>Q1: What this vertical dotted line represent in the below circuit diagram?</p>
<p>Q2: 'meas' wire in the circuit is what kind of wire? is this classical wire or qubit wire?</p>
<p>Q3: How qc.measure_all() is different from  qc.measure([0,1],[0,1])[couldn't find a simple answer on internet]</p>
<p><a href=""https://i.sstatic.net/3cKdf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/3cKdf.png"" alt=""Circuit Diagram"" /></a></p>
",qc,function vertical dotted line represent circuit p following code pre code qc quantumcircuit 2 p q1 vertical dotted line represent circuit diagram p q2 wire circuit kind wire classical wire qubit wire p q3 different could find simple answer internet p https nofollow noreferrer img https circuit diagram,"[(0, 0.22867794), (4, 0.28288263), (8, 0.0528805), (13, 0.17328341), (14, 0.2381336), (16, 0.021235492)]"
25967,,2022-04-14 23:46:22,6,149,"<p>Lattice-based cryptography is said to be the main contender for a post-quantum cryptography framework. It's thought that instead of having to switch everything over to QKD, post-quantum algorithms can instead be used that use a harder problem to solve than the typical RSA.</p>
<p>But is there any general understanding why lattice-based cryptography is actually a hard problem for quantum computers? <a href=""https://crypto.stackexchange.com/questions/50856/why-is-lattice-based-cryptography-believed-to-be-hard-against-quantum-computer"">An answer</a> from the cryptography stack exchange suggests that this is simply because an algorithm hasn't been developed for it yet. This hardly seems like reassurance. Of course a new problem will take time for people to develop a quantum algorithm for.</p>
<p>Is there something about the lattice based method that makes it less susceptible to quantum computers? For example, I believe parallelization to often be a important factor to a problem being speedy on a quantum computer. Perhaps lattice-based methods are less parallelizable?</p>
",Why is lattice-based cryptography believed to be hard to solve for quantum computers?,<quantum-algorithms><cryptography>,0,1,,,"Why is lattice-based cryptography believed to be hard to solve for quantum computers? <p>Lattice-based cryptography is said to be the main contender for a post-quantum cryptography framework. It's thought that instead of having to switch everything over to QKD, post-quantum algorithms can instead be used that use a harder problem to solve than the typical RSA.</p>
<p>But is there any general understanding why lattice-based cryptography is actually a hard problem for quantum computers? <a href=""https://crypto.stackexchange.com/questions/50856/why-is-lattice-based-cryptography-believed-to-be-hard-against-quantum-computer"">An answer</a> from the cryptography stack exchange suggests that this is simply because an algorithm hasn't been developed for it yet. This hardly seems like reassurance. Of course a new problem will take time for people to develop a quantum algorithm for.</p>
<p>Is there something about the lattice based method that makes it less susceptible to quantum computers? For example, I believe parallelization to often be a important factor to a problem being speedy on a quantum computer. Perhaps lattice-based methods are less parallelizable?</p>
",qc,cryptography believed hard solve quantum computers p cryptography said main contender cryptography framework thought instead switch everything qkd algorithms instead used use harder problem solve typical p general understanding cryptography actually hard problem quantum computers https answer cryptography stack exchange suggests simply algorithm developed yet hardly seems like reassurance course new problem take time people develop quantum algorithm p something lattice based method makes less susceptible quantum computers example believe parallelization often important factor problem speedy quantum computer perhaps methods less parallelizable,"[(1, 0.2397605), (6, 0.0149931945), (7, 0.07927816), (8, 0.57111675), (9, 0.047695715), (14, 0.03236464), (16, 0.013104461)]"
26048,26074.0,2022-04-19 20:12:41,1,167,"<p>I was expecting Qiskit to do a upside down version of my unitary as it does for other unitary matrices of CNOT and Toffoli gates given in textbooks : if you convert a toffoli matrix from quantum computing textbooks(target 3rd and ctrl 1st,2nd) you will get an inverted version of it (target as q0 and ctrl as q1,q2).<br />
So I hardcoded a unitary matrix and converted to gate then appended to qc. But the operator returns exactly the same matrix, so I wonder if my unitary is actually upside down but operator just shows flipped output ?</p>
<p>Hard coded matrix :
<a href=""https://i.sstatic.net/HBJts.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HBJts.png"" alt=""Hard coded matrix"" /></a>
Operator output :
<a href=""https://i.sstatic.net/Rh0hV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Rh0hV.png"" alt=""Operator Output"" /></a></p>
<p>Code :</p>
<pre><code>u = QuantumCircuit(qr)
u.unitary(UA, range(qr), label='U')
unitary = u.to_gate()
unitary.name = 'U'
</code></pre>
<p>mpl display :</p>
<pre><code>qc = QuantumCircuit(qr)
qc.append(unitary, range(0, qr))
qc.draw(&quot;mpl&quot;, style='bw')
</code></pre>
<p><a href=""https://i.sstatic.net/ZbSZIt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZbSZIt.png"" alt=""mpl display"" /></a></p>
",Why Qiskit doesn't invert hard coded unitary matrix?,<qiskit><programming><matrix-representation>,1,1,,,"Why Qiskit doesn't invert hard coded unitary matrix? <p>I was expecting Qiskit to do a upside down version of my unitary as it does for other unitary matrices of CNOT and Toffoli gates given in textbooks : if you convert a toffoli matrix from quantum computing textbooks(target 3rd and ctrl 1st,2nd) you will get an inverted version of it (target as q0 and ctrl as q1,q2).<br />
So I hardcoded a unitary matrix and converted to gate then appended to qc. But the operator returns exactly the same matrix, so I wonder if my unitary is actually upside down but operator just shows flipped output ?</p>
<p>Hard coded matrix :
<a href=""https://i.sstatic.net/HBJts.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HBJts.png"" alt=""Hard coded matrix"" /></a>
Operator output :
<a href=""https://i.sstatic.net/Rh0hV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Rh0hV.png"" alt=""Operator Output"" /></a></p>
<p>Code :</p>
<pre><code>u = QuantumCircuit(qr)
u.unitary(UA, range(qr), label='U')
unitary = u.to_gate()
unitary.name = 'U'
</code></pre>
<p>mpl display :</p>
<pre><code>qc = QuantumCircuit(qr)
qc.append(unitary, range(0, qr))
qc.draw(&quot;mpl&quot;, style='bw')
</code></pre>
<p><a href=""https://i.sstatic.net/ZbSZIt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZbSZIt.png"" alt=""mpl display"" /></a></p>
",qc,qiskit invert hard coded unitary matrix p expecting qiskit upside version unitary unitary matrices cnot toffoli gates given textbooks convert toffoli matrix quantum computing textbooks target 3rd ctrl get inverted version target q0 ctrl q1 q2 br hardcoded unitary matrix converted gate appended qc operator returns exactly matrix wonder unitary actually upside operator shows flipped output p hard coded matrix https nofollow noreferrer img https hard coded matrix operator output https nofollow noreferrer img https operator output p code pre code u quantumcircuit qr ua range qr u unitary u p mpl display pre code qc quantumcircuit qr unitary range 0 qr quot mpl quot p https nofollow noreferrer img https mpl display,"[(0, 0.36492658), (3, 0.08737744), (4, 0.2766377), (9, 0.11973387), (11, 0.066784464), (12, 0.02779298), (13, 0.024602398), (16, 0.018536946), (19, 0.012599088)]"
26155,26156.0,2022-04-26 03:31:48,0,56,"<p>I want to know more details about the encoding process in machine learning. I have read the source code about the &quot;ApproximateInputEncoder&quot; method. It seems like a complex method. So is there any paper or document to explain the mechanism in detail of the encoding process?</p>
",Is there any paper about the encoding process in the machine learning API?,<q#>,1,0,,,"Is there any paper about the encoding process in the machine learning API? <p>I want to know more details about the encoding process in machine learning. I have read the source code about the &quot;ApproximateInputEncoder&quot; method. It seems like a complex method. So is there any paper or document to explain the mechanism in detail of the encoding process?</p>
",qc,paper encoding process machine learning api p want know details encoding process machine learning read source code quot approximateinputencoder quot method seems like complex method paper document explain mechanism detail encoding process,"[(5, 0.11790701), (8, 0.60018516), (11, 0.17571193), (16, 0.031726714), (19, 0.06966032)]"
26191,26192.0,2022-04-28 19:54:52,2,469,"<p>I'm trying to show that none of these sets of gates are universal:</p>
<ul>
<li><p><span class=""math-container"">${CNOT^2, H, T}$</span></p>
</li>
<li><p><span class=""math-container"">${CNOT, H^2, T}$</span></p>
</li>
<li><p><span class=""math-container"">${CNOT, H, T^2}$</span></p>
</li>
</ul>
<p>For the first one <span class=""math-container"">$CNOT^2$</span> seems to be the identity gate which means that there's no way this gate set can flip the value of some bits. I'm not sure if this argument is correct/suffices.</p>
<p>For the second one, <span class=""math-container"">$H^2$</span> is the identity gate again(rotation of angle <span class=""math-container"">$2\pi$</span>), so now this gate set can only rotate about 1 axis with the <span class=""math-container"">$T$</span> gate hence it's not a universal gate set.</p>
<p>The third one is the one I'm most unsure about. <span class=""math-container"">$T^2$</span> seems to be a rotation of <span class=""math-container"">$\pi/2$</span> about the <span class=""math-container"">$z$</span> axis and that does not seem to cause any problems (eg: <span class=""math-container"">$HT^2$</span>) still seems to be a rotation about 2 distinct axes by an angle that's an irrational.</p>
","Prove that sets of gates $\{CNOT^a, H^b, T^c\}$ are not universal",<textbook-and-exercises><universal-gates>,1,1,,,"Prove that sets of gates $\{CNOT^a, H^b, T^c\}$ are not universal <p>I'm trying to show that none of these sets of gates are universal:</p>
<ul>
<li><p><span class=""math-container"">${CNOT^2, H, T}$</span></p>
</li>
<li><p><span class=""math-container"">${CNOT, H^2, T}$</span></p>
</li>
<li><p><span class=""math-container"">${CNOT, H, T^2}$</span></p>
</li>
</ul>
<p>For the first one <span class=""math-container"">$CNOT^2$</span> seems to be the identity gate which means that there's no way this gate set can flip the value of some bits. I'm not sure if this argument is correct/suffices.</p>
<p>For the second one, <span class=""math-container"">$H^2$</span> is the identity gate again(rotation of angle <span class=""math-container"">$2\pi$</span>), so now this gate set can only rotate about 1 axis with the <span class=""math-container"">$T$</span> gate hence it's not a universal gate set.</p>
<p>The third one is the one I'm most unsure about. <span class=""math-container"">$T^2$</span> seems to be a rotation of <span class=""math-container"">$\pi/2$</span> about the <span class=""math-container"">$z$</span> axis and that does not seem to cause any problems (eg: <span class=""math-container"">$HT^2$</span>) still seems to be a rotation about 2 distinct axes by an angle that's an irrational.</p>
",qc,prove sets gates universal p trying show none sets gates universal ul li p span h li p span cnot li p span cnot h p first one span seems identity gate means way gate set flip value bits sure argument p second one span identity gate rotation angle span gate set rotate 1 axis span gate hence universal gate p third one one unsure span seems rotation span span z axis seem cause problems eg span still seems rotation 2 distinct axes angle,"[(1, 0.016464904), (3, 0.33360645), (9, 0.52206516), (15, 0.017542005), (16, 0.012132503), (18, 0.0965257)]"
26201,26202.0,2022-04-29 08:01:01,0,26,"<p>Let <span class=""math-container"">$\rho$</span> is a bipartite state.</p>
<p>W is a local filtering operation that acts on a subsystem of the state  <span class=""math-container"">$\rho$</span>.</p>
<p>After the local filtering operation <span class=""math-container"">$\rho$</span> emerges into a <span class=""math-container"">$\tilde{\rho}$</span> i.e</p>
<p><span class=""math-container"">$\tilde{\rho}=\frac{I\otimes W \rho I\otimes W}{\mbox{Tr}(I\otimes W \rho I\otimes W)}$</span></p>
<p>Local filtering operation is trace decreasing?</p>
",Filtering operation is trace decreasing?,<quantum-operation><locc-operation>,1,0,,,"Filtering operation is trace decreasing? <p>Let <span class=""math-container"">$\rho$</span> is a bipartite state.</p>
<p>W is a local filtering operation that acts on a subsystem of the state  <span class=""math-container"">$\rho$</span>.</p>
<p>After the local filtering operation <span class=""math-container"">$\rho$</span> emerges into a <span class=""math-container"">$\tilde{\rho}$</span> i.e</p>
<p><span class=""math-container"">$\tilde{\rho}=\frac{I\otimes W \rho I\otimes W}{\mbox{Tr}(I\otimes W \rho I\otimes W)}$</span></p>
<p>Local filtering operation is trace decreasing?</p>
",qc,filtering operation trace decreasing p let span bipartite p w local filtering operation acts subsystem state span p local filtering operation span emerges span p span w w tr w w p local filtering operation trace decreasing,"[(3, 0.75538605), (8, 0.05884707), (16, 0.06649115), (17, 0.11496883)]"
26212,,2022-04-29 15:28:06,1,65,"<p>I'm trying to build a gaussian pulse in qiskit where I keep the amplitude as a parameter but for the followig code</p>
<pre><code>theta = Parameter('θ')
drive_amps=np.linspace(0.0,0.75,50)

with pulse.build(backend, name='example') as program:
  pulse.set_frequency(fq1,pulse.drive_channel(0))
  dur = 100
  amp = theta
  sig = 20
  gaussian_pulse = library.gaussian(dur, amp, sig)
  pulse.play(gaussian_pulse, pulse.drive_channel(0))
</code></pre>
<p>I get an error that ParametricExpression cannot be cast as complex. From the documentation it seems that
<code>gaussian(duration, amp, sigma)</code> takes the input <code>(Union[complex, ParameterExpression])</code> for amp but I have not been able to get the input to work. Has anyone found a way around this?</p>
",Qiskit library.gaussian() does not accept parametric expression,<qiskit><quantum-gate><ibm-q-experience><quantum-operation>,1,0,,,"Qiskit library.gaussian() does not accept parametric expression <p>I'm trying to build a gaussian pulse in qiskit where I keep the amplitude as a parameter but for the followig code</p>
<pre><code>theta = Parameter('θ')
drive_amps=np.linspace(0.0,0.75,50)

with pulse.build(backend, name='example') as program:
  pulse.set_frequency(fq1,pulse.drive_channel(0))
  dur = 100
  amp = theta
  sig = 20
  gaussian_pulse = library.gaussian(dur, amp, sig)
  pulse.play(gaussian_pulse, pulse.drive_channel(0))
</code></pre>
<p>I get an error that ParametricExpression cannot be cast as complex. From the documentation it seems that
<code>gaussian(duration, amp, sigma)</code> takes the input <code>(Union[complex, ParameterExpression])</code> for amp but I have not been able to get the input to work. Has anyone found a way around this?</p>
",qc,qiskit accept parametric expression p trying build gaussian pulse qiskit keep amplitude parameter followig code pre code theta parameter θ backend program fq1 0 dur 100 amp theta sig 20 dur amp sig 0 p get error parametricexpression cast complex documentation seems code gaussian duration amp sigma takes input code union complex parameterexpression amp able get input work anyone found way around,"[(0, 0.36622205), (7, 0.02687453), (14, 0.43663755), (15, 0.14825918), (16, 0.019185765)]"
26237,,2022-05-02 01:50:49,4,422,"<p>I am trying to understand the lattice surgery technique performed in  the paper <a href=""https://arxiv.org/abs/2006.03071"" rel=""nofollow noreferrer"">Entangling Logical Qubits with Lattice Surgery</a> and I'm running into some confusion with the merging procedure. The setup is as follows:</p>
<ol>
<li><p>First, two logical qubits are separately encoded in 2x2 surface codes (Figure A below). The stabilizer generators are defined as Pauli X's on the vertices of the orange plaquettes and Pauli Z's on the vertices of aqua plaquettes. For example lattice A has stabilizer group generated by <span class=""math-container"">$\langle Z_1 Z_2, Z_3Z_4, X_1X_2X_3X_4 \rangle $</span></p>
</li>
<li><p>Next, the two lattices are merged by projecting onto a joint eigenstate of <span class=""math-container"">$X_L^AX_L^B$</span>. This is accomplished by measuring the 'merging stabilizers' <span class=""math-container"">$X_3X_5$</span> and <span class=""math-container"">$X_4X_6$</span>, which are just the new X type stabilizers that would have been included in the joint lattice.</p>
</li>
</ol>
<p>The paper claims that the merged code is now stabilized by <span class=""math-container"">$\langle  Z_1 Z_2,  X_1X_2X_3X_4, Z_3Z_4Z_5Z_6, X_5X_6X_7X_8, X_3X_5, X_4X_6, Z_7Z_8 \rangle$</span>. This would require that the encoded qubit is in a <span class=""math-container"">$+1$</span> eigenstate of both merging stabilizers (by the fact that it should be stabilized by those operators). However, my understanding is that by measuring those merging stabilizers, we only guarantee that the merged qubit is in <em>an</em> eigenstate of the joint measurement, meaning it could be in a -1 eigenstate. This would suggest to me that the code is not really stabilized by those operators. In fact, the paper acknowledges this fact, but still claims the code is stabilized by the typical stabilizers you would write down based on the color of the plaquettes. Any idea what's going on here? Is it typical to use the merging stabilizer measurements to correct the encoded state to be in the +1 eigenspace?</p>
<p>Any thoughts are appreciated, thanks in advance!</p>
<p><a href=""https://i.sstatic.net/D4fcH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/D4fcH.png"" alt=""lattice surgery on 2x2 lattices"" /></a></p>
",Lattice surgery: how is merged code stabilized by 'merging stabilizers' if their measurement outcome can be -1?,<error-correction><surface-code>,1,0,,,"Lattice surgery: how is merged code stabilized by 'merging stabilizers' if their measurement outcome can be -1? <p>I am trying to understand the lattice surgery technique performed in  the paper <a href=""https://arxiv.org/abs/2006.03071"" rel=""nofollow noreferrer"">Entangling Logical Qubits with Lattice Surgery</a> and I'm running into some confusion with the merging procedure. The setup is as follows:</p>
<ol>
<li><p>First, two logical qubits are separately encoded in 2x2 surface codes (Figure A below). The stabilizer generators are defined as Pauli X's on the vertices of the orange plaquettes and Pauli Z's on the vertices of aqua plaquettes. For example lattice A has stabilizer group generated by <span class=""math-container"">$\langle Z_1 Z_2, Z_3Z_4, X_1X_2X_3X_4 \rangle $</span></p>
</li>
<li><p>Next, the two lattices are merged by projecting onto a joint eigenstate of <span class=""math-container"">$X_L^AX_L^B$</span>. This is accomplished by measuring the 'merging stabilizers' <span class=""math-container"">$X_3X_5$</span> and <span class=""math-container"">$X_4X_6$</span>, which are just the new X type stabilizers that would have been included in the joint lattice.</p>
</li>
</ol>
<p>The paper claims that the merged code is now stabilized by <span class=""math-container"">$\langle  Z_1 Z_2,  X_1X_2X_3X_4, Z_3Z_4Z_5Z_6, X_5X_6X_7X_8, X_3X_5, X_4X_6, Z_7Z_8 \rangle$</span>. This would require that the encoded qubit is in a <span class=""math-container"">$+1$</span> eigenstate of both merging stabilizers (by the fact that it should be stabilized by those operators). However, my understanding is that by measuring those merging stabilizers, we only guarantee that the merged qubit is in <em>an</em> eigenstate of the joint measurement, meaning it could be in a -1 eigenstate. This would suggest to me that the code is not really stabilized by those operators. In fact, the paper acknowledges this fact, but still claims the code is stabilized by the typical stabilizers you would write down based on the color of the plaquettes. Any idea what's going on here? Is it typical to use the merging stabilizer measurements to correct the encoded state to be in the +1 eigenspace?</p>
<p>Any thoughts are appreciated, thanks in advance!</p>
<p><a href=""https://i.sstatic.net/D4fcH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/D4fcH.png"" alt=""lattice surgery on 2x2 lattices"" /></a></p>
",qc,lattice surgery merged code stabilized stabilizers measurement outcome p trying understand lattice surgery technique performed paper https nofollow noreferrer entangling logical qubits lattice surgery running confusion merging procedure setup follows ol li p first two logical qubits separately encoded 2x2 surface codes figure stabilizer generators defined pauli x vertices orange plaquettes pauli z vertices aqua plaquettes example lattice stabilizer group generated span li p next two lattices merged projecting onto joint eigenstate span accomplished measuring stabilizers span span new x type stabilizers would included joint p paper claims merged code stabilized span would require encoded qubit span eigenstate merging stabilizers fact stabilized operators however understanding measuring merging stabilizers guarantee merged qubit em eigenstate joint measurement meaning could eigenstate would suggest code really stabilized operators fact paper acknowledges fact still claims code stabilized typical stabilizers would write based color plaquettes idea going typical use merging stabilizer measurements correct encoded state eigenspace p thoughts appreciated thanks advance p https nofollow noreferrer img https lattice surgery 2x2 lattices,"[(3, 0.22122148), (4, 0.06680151), (5, 0.35173237), (7, 0.12424822), (10, 0.01859797), (13, 0.04999071), (16, 0.12470709), (18, 0.035983846)]"
26244,,2022-05-02 13:34:17,1,58,"<p>Are there any quantum standards already in development and accessible as draft documents?</p>
<p>Any documents describing standardized way of describing and ensuring common meaning/interoperability, like e.g.:</p>
<ul>
<li>device properties and parameters,</li>
<li>unified access control via API over quantum devices,</li>
<li>gate naming convention,</li>
<li>circuit definition portability between various systems,</li>
<li>quantum security aspects (key management and distribution),</li>
<li>standardized benchmarks,</li>
<li>etc.</li>
</ul>
<p>BTW:</p>
<p>I did a quick check and I see some activity in:</p>
<ul>
<li><a href=""https://www.itu.int/en/ITU-T/about/groups/Pages/sg17.aspx"" rel=""nofollow noreferrer"">ITU</a>.</li>
<li><a href=""https://arxiv.org/ftp/arxiv/papers/2203/2203.01622.pdf"" rel=""nofollow noreferrer"">CEN-CENELEC Focus Group on Quantum Technologies (FGQT): &quot;Towards European Standards for Quantum Technologies&quot;</a></li>
</ul>
<p>This is good article describing a raising need for data organization for quantum devices:
<a href=""https://jackkrupansky.medium.com/proposal-for-a-quantum-capabilities-label-for-quantum-computers-algorithms-and-applications-430d3b94c4ca"" rel=""nofollow noreferrer"">https://jackkrupansky.medium.com/proposal-for-a-quantum-capabilities-label-for-quantum-computers-algorithms-and-applications-430d3b94c4ca</a></p>
",Are there any quantum standards already in development and accessible as draft documents?,<programming><architecture><research>,0,0,,,"Are there any quantum standards already in development and accessible as draft documents? <p>Are there any quantum standards already in development and accessible as draft documents?</p>
<p>Any documents describing standardized way of describing and ensuring common meaning/interoperability, like e.g.:</p>
<ul>
<li>device properties and parameters,</li>
<li>unified access control via API over quantum devices,</li>
<li>gate naming convention,</li>
<li>circuit definition portability between various systems,</li>
<li>quantum security aspects (key management and distribution),</li>
<li>standardized benchmarks,</li>
<li>etc.</li>
</ul>
<p>BTW:</p>
<p>I did a quick check and I see some activity in:</p>
<ul>
<li><a href=""https://www.itu.int/en/ITU-T/about/groups/Pages/sg17.aspx"" rel=""nofollow noreferrer"">ITU</a>.</li>
<li><a href=""https://arxiv.org/ftp/arxiv/papers/2203/2203.01622.pdf"" rel=""nofollow noreferrer"">CEN-CENELEC Focus Group on Quantum Technologies (FGQT): &quot;Towards European Standards for Quantum Technologies&quot;</a></li>
</ul>
<p>This is good article describing a raising need for data organization for quantum devices:
<a href=""https://jackkrupansky.medium.com/proposal-for-a-quantum-capabilities-label-for-quantum-computers-algorithms-and-applications-430d3b94c4ca"" rel=""nofollow noreferrer"">https://jackkrupansky.medium.com/proposal-for-a-quantum-capabilities-label-for-quantum-computers-algorithms-and-applications-430d3b94c4ca</a></p>
",qc,quantum standards already development accessible draft documents p quantum standards already development accessible draft documents p documents describing standardized way describing ensuring common like ul li device properties parameters li unified access control via api quantum devices li gate naming convention li circuit definition portability various systems li quantum security aspects key management distribution li standardized benchmarks li p btw p quick check see activity ul li https nofollow noreferrer itu li https nofollow noreferrer focus group quantum technologies fgqt quot towards european standards quantum technologies quot p good article describing raising need data organization quantum devices https nofollow noreferrer https,"[(1, 0.024307376), (4, 0.22756603), (7, 0.23793082), (8, 0.34799623), (9, 0.050256167), (13, 0.03444708), (14, 0.017405786), (16, 0.032277286), (19, 0.02653329)]"
26257,26286.0,2022-05-03 08:38:50,0,1332,"<p>I'm trying to represent Rxx gate as a set of <strong>physical rotations</strong> of two qubits in 3D space (or as rotations of Bloch Spheres that is the same). In some simple cases it works well:
<a href=""https://i.sstatic.net/nAHUu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nAHUu.png"" alt=""enter image description here"" /></a></p>
<p>If q0 is in the state |+⟩ then q1 rotates counterclock-wise, and for |-⟩ it's clockwise. But let's look at a more complicated case when we start from the next state:
<a href=""https://i.sstatic.net/KjT5D.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KjT5D.png"" alt=""enter image description here"" /></a></p>
<p>After Rxx we have:
<a href=""https://i.sstatic.net/hQw0O.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hQw0O.png"" alt=""enter image description here"" /></a></p>
<p>and the angles are the same as in the first example but Qiskit shows the arrows shorter. It looks like q1 rotates p/2 and then additionally ±p/4 with a random sign of the angle:</p>
<p><a href=""https://i.sstatic.net/CCY5u.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CCY5u.png"" alt=""enter image description here"" /></a></p>
<ol>
<li>Why Qiskit shows the arrows shorter? Is it a bug or a feature (partially entangled states)?</li>
<li>What is the second rotation of q1? The sign can't be completely random because an additional Rxx(-pi/2) gate will return the system to its original state. So, what is the dependency?</li>
</ol>
<p>I need Rxx gate to implement CNOT as a set of physical rotations with a correct &quot;Phase Kickback&quot;.</p>
",Rxx gate as a set of rotations,<quantum-gate><quantum-state><bloch-sphere><experimental-realization>,2,0,,,"Rxx gate as a set of rotations <p>I'm trying to represent Rxx gate as a set of <strong>physical rotations</strong> of two qubits in 3D space (or as rotations of Bloch Spheres that is the same). In some simple cases it works well:
<a href=""https://i.sstatic.net/nAHUu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nAHUu.png"" alt=""enter image description here"" /></a></p>
<p>If q0 is in the state |+⟩ then q1 rotates counterclock-wise, and for |-⟩ it's clockwise. But let's look at a more complicated case when we start from the next state:
<a href=""https://i.sstatic.net/KjT5D.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KjT5D.png"" alt=""enter image description here"" /></a></p>
<p>After Rxx we have:
<a href=""https://i.sstatic.net/hQw0O.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hQw0O.png"" alt=""enter image description here"" /></a></p>
<p>and the angles are the same as in the first example but Qiskit shows the arrows shorter. It looks like q1 rotates p/2 and then additionally ±p/4 with a random sign of the angle:</p>
<p><a href=""https://i.sstatic.net/CCY5u.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CCY5u.png"" alt=""enter image description here"" /></a></p>
<ol>
<li>Why Qiskit shows the arrows shorter? Is it a bug or a feature (partially entangled states)?</li>
<li>What is the second rotation of q1? The sign can't be completely random because an additional Rxx(-pi/2) gate will return the system to its original state. So, what is the dependency?</li>
</ol>
<p>I need Rxx gate to implement CNOT as a set of physical rotations with a correct &quot;Phase Kickback&quot;.</p>
",qc,rxx gate set rotations p trying represent rxx gate set strong physical rotations two qubits 3d space rotations bloch spheres simple cases works well https nofollow noreferrer img https enter image description p q0 state q1 rotates clockwise let look complicated case start next state https nofollow noreferrer img https enter image description p rxx https nofollow noreferrer img https enter image description p angles first example qiskit shows arrows shorter looks like q1 rotates additionally random sign angle p https nofollow noreferrer img https enter image description ol li qiskit shows arrows shorter bug feature partially entangled states li second rotation q1 sign ca completely random additional rxx gate return system original state dependency p need rxx gate implement cnot set physical rotations correct quot phase kickback quot,"[(4, 0.4035462), (8, 0.035081767), (9, 0.27953973), (13, 0.054590464), (14, 0.050011504), (16, 0.037836943), (18, 0.11341321), (19, 0.025013033)]"
26350,26354.0,2022-05-11 11:43:00,0,166,"<p>I know that there is connectivity restriction when implementing physical CNOT gate.
But, I wonder if there is a limit to the number of physical CNOT gates that can be performed at the same time.
For example, suppose six qubits are positioned in a row and only nearest qubit physical CNOT is allowed.
q1 q2 q3 q4 q5 q6
I think that CNOT(q1,q2), CNOT(q3,q4), CNOT(q5,q6) gates can be implemented at the same time.
However, is there such a that because at most two CNOT gate is implementable, CNOT(5,6) cannot be implemented with CNOT(q1,q2) and CNOT(q3,q4)?
If so, why this happens?</p>
",Is there the number of CNOT restriction?,<quantum-gate><experimental-realization>,1,4,,,"Is there the number of CNOT restriction? <p>I know that there is connectivity restriction when implementing physical CNOT gate.
But, I wonder if there is a limit to the number of physical CNOT gates that can be performed at the same time.
For example, suppose six qubits are positioned in a row and only nearest qubit physical CNOT is allowed.
q1 q2 q3 q4 q5 q6
I think that CNOT(q1,q2), CNOT(q3,q4), CNOT(q5,q6) gates can be implemented at the same time.
However, is there such a that because at most two CNOT gate is implementable, CNOT(5,6) cannot be implemented with CNOT(q1,q2) and CNOT(q3,q4)?
If so, why this happens?</p>
",qc,number cnot restriction p know connectivity restriction implementing physical cnot gate wonder limit number physical cnot gates performed time example suppose six qubits positioned row nearest qubit physical cnot allowed q1 q2 q3 q4 q5 q6 think cnot q1 q2 cnot q3 q4 cnot q5 q6 gates implemented time however two cnot gate implementable cnot implemented cnot q1 q2 cnot q3 q4 happens,"[(5, 0.057534467), (7, 0.061702043), (9, 0.40473154), (13, 0.025142135), (14, 0.39672193), (16, 0.051760644)]"
26389,,2022-05-13 21:30:49,2,501,"<p>I'm currently trying to understand lattice surgeries. As an exercise I'm currently implementing the lattice surgery operations described in <a href=""https://arxiv.org/abs/2006.03071"" rel=""nofollow noreferrer"">Entangling logical qubits with lattice surgery, by Alexander Erhard et al.</a> on a 7 qubits surface code (distance = 2). The same code described in the article.</p>
<p><a href=""https://i.sstatic.net/yIHw3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yIHw3.png"" alt=""7 qubits surface code"" /></a></p>
<p>The operations I'm trying to implement in Qiskit are the following :</p>
<p><a href=""https://i.sstatic.net/Aao8U.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Aao8U.png"" alt=""CNOT, Teleportation and Hadamard using Lattice Surgery"" /></a></p>
<p>I'm struggling with the CNOT gate and I feel like I'm missing something obvious. I searched around a lot and found ZX-calculus and a lot of other interesting leads but I cannot understand why my code isn't working...</p>
<p>From my basic understanding a logical CNOT gate can be done using a smooth merge of the target and a temporary logical qubits. Which is done by measuring Z1Z3 of the temporary and Z2Z4 of the target into an ancilla qubit. (target above temporary). I did that using CNOT gates and Hadamard gates :</p>
<p><a href=""https://i.sstatic.net/zPhw4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zPhw4.png"" alt=""MZZ measurement"" /></a></p>
<p>Then I measured X1X2X3X4 of the control using 4 CNOT into another ancilla to perform a smooth split.
Finally, I performed a rough merge on the temporary and target by measuring X3 (Temporary) and X1 (Target) into a third ancilla and X4 (Temporary) and X2 (Target) into a fourth ancilla using 2 CNOT each time.
I then tried splitting, or not. Either way, my Target logical qubits doesn't end up in <span class=""math-container"">$|1\rangle_L$</span>...</p>
<p>I'm using <span class=""math-container"">$|0\rangle_L = \frac{1}{\sqrt{2}}(|1010\rangle + |0101\rangle)$</span> and <span class=""math-container"">$|1\rangle_L = \frac{1}{\sqrt{2}}(|1001\rangle + |0110\rangle)$</span> (same as the article.
And initializing the control to <span class=""math-container"">$|1\rangle_L$</span> and the temporary to <span class=""math-container"">$|+\rangle_L = (|0101\rangle + |1010\rangle + |1001\rangle + |0110\rangle)$</span>. The target is initialized to <span class=""math-container"">$|0\rangle_L$</span>.</p>
<p>Is my understanding correct ? Is my way of doing thing also correct?</p>
<p>I'm really sorry if I'm missing something obvious but I don't understand why at the end of this sequence, the target qubit isn't set to <span class=""math-container"">$|1\rangle_L$</span> ? If I'm lacking basic knowledge on Lattice surgeries, could you please provide me some resources I could look at please?</p>
<p>Thank you in advance.</p>
","Lattice surgery on small Surface Code (d=2, 7 qubits)",<error-correction><surface-code>,0,1,,,"Lattice surgery on small Surface Code (d=2, 7 qubits) <p>I'm currently trying to understand lattice surgeries. As an exercise I'm currently implementing the lattice surgery operations described in <a href=""https://arxiv.org/abs/2006.03071"" rel=""nofollow noreferrer"">Entangling logical qubits with lattice surgery, by Alexander Erhard et al.</a> on a 7 qubits surface code (distance = 2). The same code described in the article.</p>
<p><a href=""https://i.sstatic.net/yIHw3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yIHw3.png"" alt=""7 qubits surface code"" /></a></p>
<p>The operations I'm trying to implement in Qiskit are the following :</p>
<p><a href=""https://i.sstatic.net/Aao8U.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Aao8U.png"" alt=""CNOT, Teleportation and Hadamard using Lattice Surgery"" /></a></p>
<p>I'm struggling with the CNOT gate and I feel like I'm missing something obvious. I searched around a lot and found ZX-calculus and a lot of other interesting leads but I cannot understand why my code isn't working...</p>
<p>From my basic understanding a logical CNOT gate can be done using a smooth merge of the target and a temporary logical qubits. Which is done by measuring Z1Z3 of the temporary and Z2Z4 of the target into an ancilla qubit. (target above temporary). I did that using CNOT gates and Hadamard gates :</p>
<p><a href=""https://i.sstatic.net/zPhw4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zPhw4.png"" alt=""MZZ measurement"" /></a></p>
<p>Then I measured X1X2X3X4 of the control using 4 CNOT into another ancilla to perform a smooth split.
Finally, I performed a rough merge on the temporary and target by measuring X3 (Temporary) and X1 (Target) into a third ancilla and X4 (Temporary) and X2 (Target) into a fourth ancilla using 2 CNOT each time.
I then tried splitting, or not. Either way, my Target logical qubits doesn't end up in <span class=""math-container"">$|1\rangle_L$</span>...</p>
<p>I'm using <span class=""math-container"">$|0\rangle_L = \frac{1}{\sqrt{2}}(|1010\rangle + |0101\rangle)$</span> and <span class=""math-container"">$|1\rangle_L = \frac{1}{\sqrt{2}}(|1001\rangle + |0110\rangle)$</span> (same as the article.
And initializing the control to <span class=""math-container"">$|1\rangle_L$</span> and the temporary to <span class=""math-container"">$|+\rangle_L = (|0101\rangle + |1010\rangle + |1001\rangle + |0110\rangle)$</span>. The target is initialized to <span class=""math-container"">$|0\rangle_L$</span>.</p>
<p>Is my understanding correct ? Is my way of doing thing also correct?</p>
<p>I'm really sorry if I'm missing something obvious but I don't understand why at the end of this sequence, the target qubit isn't set to <span class=""math-container"">$|1\rangle_L$</span> ? If I'm lacking basic knowledge on Lattice surgeries, could you please provide me some resources I could look at please?</p>
<p>Thank you in advance.</p>
",qc,lattice surgery small surface code 7 qubits p currently trying understand lattice surgeries exercise currently implementing lattice surgery operations described https nofollow noreferrer entangling logical qubits lattice surgery alexander erhard et 7 qubits surface code distance 2 code described p https nofollow noreferrer img https 7 qubits surface code p operations trying implement qiskit following p https nofollow noreferrer img https cnot teleportation hadamard using lattice surgery p struggling cnot gate feel like missing something obvious searched around lot found lot interesting leads understand code working p basic understanding logical cnot gate done using smooth merge target temporary logical qubits done measuring z1z3 temporary z2z4 target ancilla qubit target temporary using cnot gates hadamard gates p https nofollow noreferrer img https mzz measurement p measured x1x2x3x4 control using 4 cnot another ancilla perform smooth split finally performed rough merge temporary target measuring x3 temporary x1 target third ancilla x4 temporary x2 target fourth ancilla using 2 cnot time tried splitting either way target logical qubits end span p using span 1 2 span 1 2 article initializing control span temporary span target initialized span p understanding correct way thing also correct p really sorry missing something obvious understand end sequence target qubit set span lacking basic knowledge lattice surgeries could please provide resources could look please p thank,"[(4, 0.18303898), (5, 0.086808264), (6, 0.039196294), (9, 0.05562932), (13, 0.15157819), (14, 0.116146445), (16, 0.053003), (17, 0.0112885805), (18, 0.2983248)]"
26455,,2022-05-18 09:46:22,8,1337,"<p>The CNOT gate is usually written as</p>
<blockquote>
<p><span class=""math-container"">$|0\rangle\langle0|\otimes I + 1\rangle\langle1|\otimes X$</span></p>
</blockquote>
<p>(with <span class=""math-container"">$X,Y,Z$</span> being the Pauli Basis and <span class=""math-container"">$I$</span> the Identity).</p>
<p>I have yet to stumble across the representation <a href=""https://en.wikipedia.org/wiki/Controlled_NOT_gate"" rel=""noreferrer"">Wikipedia</a> gives when looking at books on the topic:</p>
<blockquote>
<p><span class=""math-container"">$e^{i\frac{\pi}{4}\left(I-Z\right)\otimes\left(I-X\right)}$</span></p>
</blockquote>
<p>Why is it that none of the books on quantum mechanics / computing /information I have looked at uses this exponential representation? Does somebody know, which book does?</p>
<hr />
<p><a href=""https://physics.stackexchange.com/q/709287/58382"">Cross-posted on physics.SE</a></p>
",Why is the CNOT representation $e^{i\frac{\pi}{4}\left(I-Z\right)\otimes\left(I-X\right)}$ hardly found in books?,<quantum-gate>,2,4,,,"Why is the CNOT representation $e^{i\frac{\pi}{4}\left(I-Z\right)\otimes\left(I-X\right)}$ hardly found in books? <p>The CNOT gate is usually written as</p>
<blockquote>
<p><span class=""math-container"">$|0\rangle\langle0|\otimes I + 1\rangle\langle1|\otimes X$</span></p>
</blockquote>
<p>(with <span class=""math-container"">$X,Y,Z$</span> being the Pauli Basis and <span class=""math-container"">$I$</span> the Identity).</p>
<p>I have yet to stumble across the representation <a href=""https://en.wikipedia.org/wiki/Controlled_NOT_gate"" rel=""noreferrer"">Wikipedia</a> gives when looking at books on the topic:</p>
<blockquote>
<p><span class=""math-container"">$e^{i\frac{\pi}{4}\left(I-Z\right)\otimes\left(I-X\right)}$</span></p>
</blockquote>
<p>Why is it that none of the books on quantum mechanics / computing /information I have looked at uses this exponential representation? Does somebody know, which book does?</p>
<hr />
<p><a href=""https://physics.stackexchange.com/q/709287/58382"">Cross-posted on physics.SE</a></p>
",qc,cnot representation 4 hardly found books p cnot gate usually written blockquote p span x p span x z pauli basis span identity p yet stumble across representation https noreferrer wikipedia gives looking books topic blockquote p span 4 p none books quantum mechanics computing looked uses exponential representation somebody know book hr p https,"[(3, 0.33413506), (4, 0.13444102), (6, 0.025504304), (8, 0.32563066), (9, 0.109180294), (10, 0.04967374), (16, 0.018990684)]"
26566,,2022-05-25 20:46:14,3,124,"<p>I'm interested in learning AWS Braket. Can someone help with basics like creating a circuit and sending a job to the hardware and at the same time how to automatically download the calibration data using python code. For example, IBMQ it is easy to download the calibration data so it is easy to automate the code for IBM. Is there something similar for AWS Braket? In other words I need a method to automate the process of sending jobs and downloading results and the calibration data. Also how to perform compilation to run circuits without further compilation? Thank you</p>
",AWS-Rigetti for beginners,<programming><quantum-gate><amazon-braket>,1,0,,,"AWS-Rigetti for beginners <p>I'm interested in learning AWS Braket. Can someone help with basics like creating a circuit and sending a job to the hardware and at the same time how to automatically download the calibration data using python code. For example, IBMQ it is easy to download the calibration data so it is easy to automate the code for IBM. Is there something similar for AWS Braket? In other words I need a method to automate the process of sending jobs and downloading results and the calibration data. Also how to perform compilation to run circuits without further compilation? Thank you</p>
",qc,beginners p interested learning aws braket someone help basics like creating circuit sending job hardware time automatically download calibration data using python code example ibmq easy download calibration data easy automate code ibm something similar aws braket words need method automate process sending jobs downloading results calibration data also perform compilation run circuits without compilation thank,"[(8, 0.120983265), (14, 0.70288396), (16, 0.1240799), (18, 0.04904388)]"
26601,26602.0,2022-05-27 14:47:18,1,962,"<p>I am trying to run the following circuit:</p>
<pre><code>from qiskit.circuit import ParameterVector, QuantumCircuit
p = qiskit.circuit.ParameterVector('p', 2)
th = qiskit.circuit.ParameterVector('th', 2)

circuit = qiskit.circuit.QuantumCircuit(2)
circuit.rx(p[0], 0) 
circuit.ry(p[1], 1)
circuit.ry(th[1], 1)
circuit.ry(th[0], 1)

qc = transpile(circuit, backend)
</code></pre>
<p>I want to pass parameters from two different lists, inp[0] and theta, each of length 2, like so:</p>
<pre><code>bind_dict = {}
j = 0
for key in qc.parameters:
    while j &lt;= 1: #this is the number of inputs, at the moment we have two inputs
        bind_dict[key] = inp[0][j]
        j+=1
    k = 0
    bind_dict[key] = theta[k]

qc.assign_parameters(bind_dict)
qobj = assemble(qc, shots = 10)
</code></pre>
<p>I get the following error:</p>
<pre><code>Traceback (most recent call last):
  Input In [316] in &lt;cell line: 1&gt;
    qobj = assemble(qc, shots = 10)
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:205 in assemble
    bound_experiments, run_config = _expand_parameters(
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:596 in _expand_parameters
    raise QiskitError(
QiskitError: 'Mismatch between run_config.parameter_binds and all circuit parameters.
Parameter binds: [] Circuit parameters: [ParameterView([ParameterVectorElement(p[0]),     
ParameterVectorElement(p[1]), ParameterVectorElement(th[0]),   
ParameterVectorElement(th[1])])]'

Use %tb to get the full traceback.
</code></pre>
<p>It does not seem to assign the parameters to the circuit?</p>
",Qiskit: Mismatch between run_config.parameter_binds and all circuit parameters,<qiskit><circuit-construction><quantum-circuit>,1,0,,,"Qiskit: Mismatch between run_config.parameter_binds and all circuit parameters <p>I am trying to run the following circuit:</p>
<pre><code>from qiskit.circuit import ParameterVector, QuantumCircuit
p = qiskit.circuit.ParameterVector('p', 2)
th = qiskit.circuit.ParameterVector('th', 2)

circuit = qiskit.circuit.QuantumCircuit(2)
circuit.rx(p[0], 0) 
circuit.ry(p[1], 1)
circuit.ry(th[1], 1)
circuit.ry(th[0], 1)

qc = transpile(circuit, backend)
</code></pre>
<p>I want to pass parameters from two different lists, inp[0] and theta, each of length 2, like so:</p>
<pre><code>bind_dict = {}
j = 0
for key in qc.parameters:
    while j &lt;= 1: #this is the number of inputs, at the moment we have two inputs
        bind_dict[key] = inp[0][j]
        j+=1
    k = 0
    bind_dict[key] = theta[k]

qc.assign_parameters(bind_dict)
qobj = assemble(qc, shots = 10)
</code></pre>
<p>I get the following error:</p>
<pre><code>Traceback (most recent call last):
  Input In [316] in &lt;cell line: 1&gt;
    qobj = assemble(qc, shots = 10)
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:205 in assemble
    bound_experiments, run_config = _expand_parameters(
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:596 in _expand_parameters
    raise QiskitError(
QiskitError: 'Mismatch between run_config.parameter_binds and all circuit parameters.
Parameter binds: [] Circuit parameters: [ParameterView([ParameterVectorElement(p[0]),     
ParameterVectorElement(p[1]), ParameterVectorElement(th[0]),   
ParameterVectorElement(th[1])])]'

Use %tb to get the full traceback.
</code></pre>
<p>It does not seem to assign the parameters to the circuit?</p>
",qc,qiskit mismatch circuit parameters p trying run following circuit pre code import parametervector quantumcircuit p p 2 th 2 circuit 2 p 0 0 p 1 1 th 1 1 th 0 1 qc transpile circuit backend p want pass parameters two different lists inp 0 theta length 2 like pre code j 0 key j lt 1 number inputs moment two inputs key inp 0 j k 0 key theta k qobj assemble qc shots 10 p get following error pre code traceback recent call last input 316 lt cell line 1 gt qobj assemble qc shots 10 file assemble file raise qiskiterror qiskiterror circuit parameters parameter binds circuit parameters parameterview parametervectorelement p 0 parametervectorelement p 1 parametervectorelement th 0 parametervectorelement th 1 use tb get full traceback p seem assign parameters circuit,"[(0, 0.52999127), (2, 0.16171017), (14, 0.21966778), (16, 0.030766841), (17, 0.040622417)]"
26673,26675.0,2022-06-01 12:24:03,0,69,"<p>I implemented teleportation described on this page: <a href=""https://qiskit.org/textbook/ch-algorithms/teleportation.html"" rel=""nofollow noreferrer"">Teleporation</a></p>
<p>Circuit is as follows:
<a href=""https://i.sstatic.net/AVv2L.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AVv2L.png"" alt=""enter image description here"" /></a></p>
<p>Here, as we are trying to teleport the quantum state from Alice (q0) to Bob(q2).</p>
<p>Bob, on receiving the bits from Alice needs to apply appropriate transformations on his qubit based on Alice measurement to reconstruct Alice's state which are as follows:</p>
<p><a href=""https://i.sstatic.net/PNViS.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PNViS.png"" alt=""enter image description here"" /></a></p>
<p>Please help me to understand the logic behind applying X-gate in case bits received are 01 or applying z-gate in case bits received are 10..</p>
",What is the logic behind applying $X$ or $Z$ conditionally to the received bits?,<textbook-and-exercises><teleportation>,1,1,,,"What is the logic behind applying $X$ or $Z$ conditionally to the received bits? <p>I implemented teleportation described on this page: <a href=""https://qiskit.org/textbook/ch-algorithms/teleportation.html"" rel=""nofollow noreferrer"">Teleporation</a></p>
<p>Circuit is as follows:
<a href=""https://i.sstatic.net/AVv2L.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AVv2L.png"" alt=""enter image description here"" /></a></p>
<p>Here, as we are trying to teleport the quantum state from Alice (q0) to Bob(q2).</p>
<p>Bob, on receiving the bits from Alice needs to apply appropriate transformations on his qubit based on Alice measurement to reconstruct Alice's state which are as follows:</p>
<p><a href=""https://i.sstatic.net/PNViS.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PNViS.png"" alt=""enter image description here"" /></a></p>
<p>Please help me to understand the logic behind applying X-gate in case bits received are 01 or applying z-gate in case bits received are 10..</p>
",qc,logic behind applying x z conditionally received bits p implemented teleportation described page https nofollow noreferrer teleporation p circuit follows https nofollow noreferrer img https enter image description p trying teleport quantum state alice q0 bob q2 p bob receiving bits alice needs apply appropriate transformations qubit based alice measurement reconstruct alice state follows p https nofollow noreferrer img https enter image description p please help understand logic behind applying case bits received 01 applying case bits received 10,"[(4, 0.45772618), (9, 0.029128926), (10, 0.013133335), (13, 0.13055314), (16, 0.01303682), (18, 0.35465276)]"
26679,26707.0,2022-06-01 18:29:21,3,235,"<p>Is there any rigorous proof that Quantum Annealing (QA) is of any benefit (e.g. in terms of time to optimal solution, convergence rate, etc.) for a specific problem? Or any empirical evidence for the same?</p>
<p>I can find QUBO-based QA implementation for basically every computational problem from all of the major complexity classes, but what I can’t find is any scientifically reliable and peer-reviewed publication where state-of-the-art classical algorithms are outperformed (theoretically or empirically).</p>
<p>Is this due to me or is there simply none?</p>
",Is there any rigorous proof that Quantum Annealing provides a quantum advantage?,<quantum-advantage><d-wave><annealing><adiabatic-model>,1,0,,,"Is there any rigorous proof that Quantum Annealing provides a quantum advantage? <p>Is there any rigorous proof that Quantum Annealing (QA) is of any benefit (e.g. in terms of time to optimal solution, convergence rate, etc.) for a specific problem? Or any empirical evidence for the same?</p>
<p>I can find QUBO-based QA implementation for basically every computational problem from all of the major complexity classes, but what I can’t find is any scientifically reliable and peer-reviewed publication where state-of-the-art classical algorithms are outperformed (theoretically or empirically).</p>
<p>Is this due to me or is there simply none?</p>
",qc,rigorous proof quantum annealing provides quantum advantage p rigorous proof quantum annealing qa benefit terms time optimal solution convergence rate etc specific problem empirical evidence p find qa implementation basically every computational problem major complexity classes find scientifically reliable publication classical algorithms outperformed theoretically empirically p due simply none,"[(1, 0.32035992), (5, 0.030493405), (7, 0.1734669), (8, 0.28121617), (9, 0.16898285), (16, 0.022378715)]"
26744,,2022-06-06 04:54:39,1,75,"<p>I am trying to perform a lattice surgery. Initial state is <span class=""math-container"">$|0\rangle+|1\rangle$</span> and when I perform a smooth merge and split, I think I get <span class=""math-container"">$|00\rangle+|11\rangle$</span> but it doesn't work. Is there something wrong with the code?</p>
<hr />
<pre><code>
include &quot;qelib1.inc&quot;;
qreg q1[5];
qreg q2[5];
qreg q3[1];
qreg anc[6];
creg c1[5];
creg c2[5];
creg c3[1];


// initial state |+&gt;

h q1[0];
cx q1[0],q1[3];

reset anc;

h anc[0];
cx anc[0],q1[0];
cx anc[0],q1[1];
cx anc[0],q1[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q1[2];
cx anc[0],q1[3];
cx anc[0],q1[4];
h anc[0];


// int bit |+&gt;

h q2[0];
cx q2[0],q2[3];

reset anc;

h anc[0];
cx anc[0],q2[0];
cx anc[0],q2[1];
cx anc[0],q2[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q2[2];
cx anc[0],q2[3];
cx anc[0],q2[4];
h anc[0];

// smooth merge
h q3[0]; 


// Z Stabilizer

reset anc;

h anc[0]; 
cz anc[0],q1[0];
cz anc[0],q2[3];
cz anc[0],q3[0];
h anc[0]; 

reset anc;

h anc[0]; 
cz anc[0],q1[1];
cz anc[0],q2[4];
cz anc[0],q3[0];
h anc[0]; 

measure q3[0] -&gt; c3[0];

measure q1[0] -&gt; c1[0];
measure q1[1] -&gt; c1[1];
measure q1[2] -&gt; c1[2];
measure q1[3] -&gt; c1[3];
measure q1[4] -&gt; c1[4];
measure q2[0] -&gt; c2[0];
measure q2[1] -&gt; c2[1];
measure q2[2] -&gt; c2[2];
measure q2[3] -&gt; c2[3];
measure q2[4] -&gt; c2[4];

</code></pre>
","How to perform lattice surgery with initial state $|0\rangle+|1\rangle$, with qasm?",<programming><error-correction><qasm>,0,0,,,"How to perform lattice surgery with initial state $|0\rangle+|1\rangle$, with qasm? <p>I am trying to perform a lattice surgery. Initial state is <span class=""math-container"">$|0\rangle+|1\rangle$</span> and when I perform a smooth merge and split, I think I get <span class=""math-container"">$|00\rangle+|11\rangle$</span> but it doesn't work. Is there something wrong with the code?</p>
<hr />
<pre><code>
include &quot;qelib1.inc&quot;;
qreg q1[5];
qreg q2[5];
qreg q3[1];
qreg anc[6];
creg c1[5];
creg c2[5];
creg c3[1];


// initial state |+&gt;

h q1[0];
cx q1[0],q1[3];

reset anc;

h anc[0];
cx anc[0],q1[0];
cx anc[0],q1[1];
cx anc[0],q1[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q1[2];
cx anc[0],q1[3];
cx anc[0],q1[4];
h anc[0];


// int bit |+&gt;

h q2[0];
cx q2[0],q2[3];

reset anc;

h anc[0];
cx anc[0],q2[0];
cx anc[0],q2[1];
cx anc[0],q2[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q2[2];
cx anc[0],q2[3];
cx anc[0],q2[4];
h anc[0];

// smooth merge
h q3[0]; 


// Z Stabilizer

reset anc;

h anc[0]; 
cz anc[0],q1[0];
cz anc[0],q2[3];
cz anc[0],q3[0];
h anc[0]; 

reset anc;

h anc[0]; 
cz anc[0],q1[1];
cz anc[0],q2[4];
cz anc[0],q3[0];
h anc[0]; 

measure q3[0] -&gt; c3[0];

measure q1[0] -&gt; c1[0];
measure q1[1] -&gt; c1[1];
measure q1[2] -&gt; c1[2];
measure q1[3] -&gt; c1[3];
measure q1[4] -&gt; c1[4];
measure q2[0] -&gt; c2[0];
measure q2[1] -&gt; c2[1];
measure q2[2] -&gt; c2[2];
measure q2[3] -&gt; c2[3];
measure q2[4] -&gt; c2[4];

</code></pre>
",qc,perform lattice surgery initial state qasm p trying perform lattice surgery initial state span perform smooth merge split think get span work something wrong code hr pre code include quot quot qreg q1 5 qreg q2 5 qreg q3 1 qreg anc 6 creg c1 5 creg c2 5 creg c3 1 initial state gt h q1 0 cx q1 0 q1 3 reset anc h anc 0 cx anc 0 q1 0 cx anc 0 q1 1 cx anc 0 q1 2 h anc 0 reset anc h anc 0 cx anc 0 q1 2 cx anc 0 q1 3 cx anc 0 q1 4 h anc 0 int bit gt h q2 0 cx q2 0 q2 3 reset anc h anc 0 cx anc 0 q2 0 cx anc 0 q2 1 cx anc 0 q2 2 h anc 0 reset anc h anc 0 cx anc 0 q2 2 cx anc 0 q2 3 cx anc 0 q2 4 h anc 0 smooth merge h q3 0 z stabilizer reset anc h anc 0 cz anc 0 q1 0 cz anc 0 q2 3 cz anc 0 q3 0 h anc 0 reset anc h anc 0 cz anc 0 q1 1 cz anc 0 q2 4 cz anc 0 q3 0 h anc 0 measure q3 0 gt c3 0 measure q1 0 gt c1 0 measure q1 1 gt c1 1 measure q1 2 gt c1 2 measure q1 3 gt c1 3 measure q1 4 gt c1 4 measure q2 0 gt c2 0 measure q2 1 gt c2 1 measure q2 2 gt c2 2 measure q2 3 gt c2 3 measure q2 4 gt c2 4,"[(0, 0.08280064), (2, 0.26657593), (5, 0.013555518), (6, 0.19229609), (12, 0.022576414), (14, 0.28718215), (16, 0.073870994), (18, 0.055188883)]"
26780,26799.0,2022-06-08 09:04:12,1,339,"<p>I am trying to write a phase estimation algorithm using Cirq. The algorithm works for different inputs but I receive a few errors in the estimate_phi(mystery) function.</p>
<pre><code>from cirq import CZPowGate

def create_operator(phi):
    CU = CZPowGate(exponent = phi*2)
    return CU

def iqft(n,qubits,circuit):
    
    #Swap the qubits
    for i in range(n//2):
        circuit.append(SWAP(qubits[i],qubits[n-i-1]), strategy = InsertStrategy.NEW)
     
    #For each qubit
    for i in range(n-1,-1,-1):
        #Apply CR_k gates where j is the control and i is the target
        k=n-i #We start with k=n-i
        for j in range(n-1,i,-1):
            #Define and apply CR_k gate
            crk = CZPowGate(exponent = -2/2**(k))
            circuit.append(crk(qubits[j],qubits[i]),strategy = InsertStrategy.NEW)
            k=k-1 #Decrement at each step
            
        #Apply Hadamard to the qubit
        circuit.append(H(qubits[i]),strategy = InsertStrategy.NEW)

def qpe(t,control, target, circuit, CU):
    
    #Apply Hadamard to control qubits
    circuit.append(cirq.H.on_each(control))
    
    #Apply CU gates
    for i in range(t):
        #Obtain the power of CU gate 
        CUi = CU**(2**i)
        #Apply CUi gate where t-i-1 is the control
        circuit.append(CUi(control[t-i-1],*target))
        
    #Apply inverse QFT
    iqft(t,control,circuit)
</code></pre>
<p>This script works for different inputs:</p>
<pre><code>import cirq
from cirq.circuits import InsertStrategy
from cirq          import H, X, SWAP, CZPowGate
# def estimate_phi(mystery):
mystery = 0.30
#     Let the size of the first register equal 10.
n = 1

for t in range (1,10):
    #Create cirucit
    circuit = cirq.Circuit()
    
   
    #Create t control qubits
    control = [cirq.LineQubit(i) for i in range(t) ]

    #Create n target qubits
    target = [cirq.LineQubit(i) for i in range(t, t + n) ]

    #Set target qubit to state |1&gt; 
    circuit.append(X.on_each(target))
    
    #Apply QPE
    CU = create_operator(mystery)
    qpe(t,control, target, circuit, CU)

    circuit.append(cirq.measure(*control, key = 'result'))

    s       = cirq.Simulator()
    samples = s.run(circuit, repetitions = 1000)
    
    #Most frequent observation
    freq = list(samples.histogram(key = 'result').keys())[0]
    print(&quot;t:&quot;, t,&quot;estimation:&quot;, freq/2**t)
</code></pre>
<p>but when I put it in a function, I receive two errors for the print(test_qpe(0.23)) command</p>
<blockquote>
<p>unsupported operand type(s) for ** or pow(): 'complex' and
'LinearCombinationOfGates'</p>
<p>During handling of the above exception, another exception occurred:
Simulator doesn't support
(cirq.CZ<strong>cirq.LinearCombinationOfGates({(cirq.CZ</strong>0.46):
2})).on(cirq.LineQubit(0), cirq.LineQubit(1))</p>
</blockquote>
<pre><code>import cirq
from cirq.circuits import InsertStrategy
from cirq          import H, X, SWAP, CZPowGate

def estimate_phi(mystery):

    for t in range (1,10):
    #Create cirucit
        circuit = cirq.Circuit()
        #Number of qubits in the register storing eigenvector
        n = 1 
    
    
    #Create t control qubits
        control = [cirq.LineQubit(i) for i in range(t) ]

    #Create n target qubits
        target = [cirq.LineQubit(i) for i in range(t, t + n) ]

    #Set target qubit to state |1&gt; 
        circuit.append(X.on_each(target))
    
    #Apply QPE
        CU = create_operator(mystery)
        qpe(t,control, target, circuit, CU)

        circuit.append(cirq.measure(*control, key = 'result'))

        s       = cirq.Simulator()
        samples = s.run(circuit, repetitions = 1000)
    
    #Most frequent observation
        freq = list(samples.histogram(key = 'result').keys())[0]
        
        
    return freq/2**t

import math
def test_qpe(phi):
    operator = CZPowGate(exponent=2*phi)
    return estimate_phi(operator)
</code></pre>
",Writing a Phase Estimation function in Cirq,<cirq><quantum-phase-estimation>,1,0,,,"Writing a Phase Estimation function in Cirq <p>I am trying to write a phase estimation algorithm using Cirq. The algorithm works for different inputs but I receive a few errors in the estimate_phi(mystery) function.</p>
<pre><code>from cirq import CZPowGate

def create_operator(phi):
    CU = CZPowGate(exponent = phi*2)
    return CU

def iqft(n,qubits,circuit):
    
    #Swap the qubits
    for i in range(n//2):
        circuit.append(SWAP(qubits[i],qubits[n-i-1]), strategy = InsertStrategy.NEW)
     
    #For each qubit
    for i in range(n-1,-1,-1):
        #Apply CR_k gates where j is the control and i is the target
        k=n-i #We start with k=n-i
        for j in range(n-1,i,-1):
            #Define and apply CR_k gate
            crk = CZPowGate(exponent = -2/2**(k))
            circuit.append(crk(qubits[j],qubits[i]),strategy = InsertStrategy.NEW)
            k=k-1 #Decrement at each step
            
        #Apply Hadamard to the qubit
        circuit.append(H(qubits[i]),strategy = InsertStrategy.NEW)

def qpe(t,control, target, circuit, CU):
    
    #Apply Hadamard to control qubits
    circuit.append(cirq.H.on_each(control))
    
    #Apply CU gates
    for i in range(t):
        #Obtain the power of CU gate 
        CUi = CU**(2**i)
        #Apply CUi gate where t-i-1 is the control
        circuit.append(CUi(control[t-i-1],*target))
        
    #Apply inverse QFT
    iqft(t,control,circuit)
</code></pre>
<p>This script works for different inputs:</p>
<pre><code>import cirq
from cirq.circuits import InsertStrategy
from cirq          import H, X, SWAP, CZPowGate
# def estimate_phi(mystery):
mystery = 0.30
#     Let the size of the first register equal 10.
n = 1

for t in range (1,10):
    #Create cirucit
    circuit = cirq.Circuit()
    
   
    #Create t control qubits
    control = [cirq.LineQubit(i) for i in range(t) ]

    #Create n target qubits
    target = [cirq.LineQubit(i) for i in range(t, t + n) ]

    #Set target qubit to state |1&gt; 
    circuit.append(X.on_each(target))
    
    #Apply QPE
    CU = create_operator(mystery)
    qpe(t,control, target, circuit, CU)

    circuit.append(cirq.measure(*control, key = 'result'))

    s       = cirq.Simulator()
    samples = s.run(circuit, repetitions = 1000)
    
    #Most frequent observation
    freq = list(samples.histogram(key = 'result').keys())[0]
    print(&quot;t:&quot;, t,&quot;estimation:&quot;, freq/2**t)
</code></pre>
<p>but when I put it in a function, I receive two errors for the print(test_qpe(0.23)) command</p>
<blockquote>
<p>unsupported operand type(s) for ** or pow(): 'complex' and
'LinearCombinationOfGates'</p>
<p>During handling of the above exception, another exception occurred:
Simulator doesn't support
(cirq.CZ<strong>cirq.LinearCombinationOfGates({(cirq.CZ</strong>0.46):
2})).on(cirq.LineQubit(0), cirq.LineQubit(1))</p>
</blockquote>
<pre><code>import cirq
from cirq.circuits import InsertStrategy
from cirq          import H, X, SWAP, CZPowGate

def estimate_phi(mystery):

    for t in range (1,10):
    #Create cirucit
        circuit = cirq.Circuit()
        #Number of qubits in the register storing eigenvector
        n = 1 
    
    
    #Create t control qubits
        control = [cirq.LineQubit(i) for i in range(t) ]

    #Create n target qubits
        target = [cirq.LineQubit(i) for i in range(t, t + n) ]

    #Set target qubit to state |1&gt; 
        circuit.append(X.on_each(target))
    
    #Apply QPE
        CU = create_operator(mystery)
        qpe(t,control, target, circuit, CU)

        circuit.append(cirq.measure(*control, key = 'result'))

        s       = cirq.Simulator()
        samples = s.run(circuit, repetitions = 1000)
    
    #Most frequent observation
        freq = list(samples.histogram(key = 'result').keys())[0]
        
        
    return freq/2**t

import math
def test_qpe(phi):
    operator = CZPowGate(exponent=2*phi)
    return estimate_phi(operator)
</code></pre>
",qc,writing phase estimation function cirq p trying write phase estimation algorithm using cirq algorithm works different inputs receive errors mystery pre code cirq import czpowgate def phi cu czpowgate exponent phi 2 return cu def iqft n qubits circuit swap qubits range swap qubits qubits strategy qubit range apply gates j control target start j range define apply gate crk czpowgate exponent k crk qubits j qubits strategy decrement step apply hadamard qubit h qubits strategy def qpe control target circuit cu apply hadamard control qubits control apply cu gates range obtain power cu gate cui cu 2 apply cui gate control cui control target apply inverse qft iqft control circuit p script works different inputs pre code import cirq import insertstrategy cirq import h x swap czpowgate def mystery mystery let size first register equal n 1 range create cirucit circuit create control qubits control range create n target qubits target range n set target qubit state gt target apply qpe cu mystery qpe control target circuit cu control key samples circuit repetitions 1000 frequent observation freq list key 0 print quot quot quot estimation quot p put function receive two errors print command blockquote p unsupported operand type pow p handling exception another exception occurred simulator support strong 2 0 1 pre code import cirq import insertstrategy cirq import h x swap czpowgate def mystery range create cirucit circuit number qubits register storing eigenvector n 1 create control qubits control range create n target qubits target range n set target qubit state gt target apply qpe cu mystery qpe control target circuit cu control key samples circuit repetitions 1000 frequent observation freq list key 0 return import math def phi operator czpowgate phi return operator,"[(0, 0.33054435), (2, 0.02649505), (7, 0.053844213), (8, 0.010300272), (10, 0.025294138), (14, 0.15556437), (16, 0.019853069), (18, 0.356225), (19, 0.0151508)]"
26783,26791.0,2022-06-08 13:09:21,1,59,"<p>I was going through <a href=""https://quantumai.google/cirq/tutorials/shor#quantum_order_finder"" rel=""nofollow noreferrer"">Cirq tutorial on Shor's algorithm</a> and was able to implement it successfully using cirq. But it takes forever to run for any <code>n &gt; 21</code>; so I tried to use the qsim simulator instead of using cirq.</p>
<p><strong>What I tried to do -</strong></p>
<p>I replaced <code>measurement = cirq.sample(circuit)</code> with <code>measurement = simulator.simulate(circuit)</code>.</p>
<pre><code>def quantum_order_finder(x: int, n: int) -&gt; Optional[int]:
    if x &lt; 2 or n &lt;= x or math.gcd(x, n) &gt; 1:
        raise ValueError(f'Invalid x={x} for modulus n={n}.')

    circuit = make_order_finding_circuit(x, n)
    
    simulator = qsimcirq.QSimSimulator()
    measurement = simulator.simulate(circuit)
    
    return process_measurement(measurement, x, n)
</code></pre>
<p><strong>The error I got -</strong></p>
<pre><code>&lt;ipython-input-21-b2e4008cd3ca&gt; in quantum_order_finder(x, n)
     22
---&gt; 23     measurement = simulator.simulate(circuit)
     24

/usr/local/lib/python3.7/dist-packages/cirq/sim/simulator.py in simulate(self, program, param_resolver, qubit_order, initial_state)
    517         &quot;&quot;&quot;
    518         return self.simulate_sweep(
--&gt; 519             program, study.ParamResolver(param_resolver), qubit_order, initial_state
    520         )[0]
    521 

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in simulate_sweep(self, program, params, qubit_order, initial_state)
    561                 solved_circuit,
    562                 translator_fn_name,
--&gt; 563                 cirq_order,
    564             )
    565             options[&quot;s&quot;] = self.get_seed()

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in _translate_circuit(self, circuit, translator_fn_name, qubit_order)
    858         if translated_circuit is None:
    859             translator_fn = getattr(circuit, translator_fn_name)
--&gt; 860             translated_circuit, moment_indices = translator_fn(qubit_order)
    861             self._translated_circuits.append(
    862                 (circuit, translated_circuit, moment_indices)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in translate_cirq_to_qsim(self, qubit_order)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in &lt;listcomp&gt;(.0)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/cirq/protocols/decompose_protocol.py in decompose(val, intercepting_decomposer, fallback_decomposer, keep, on_stuck_raise, preserve_structure)
    245                 error = on_stuck_raise(item)
    246                 if error is not None:
--&gt; 247                     raise error
    248 
    249         output.append(item)

ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed: &lt;__main__.ModularExp object at 0x7efe3c3e76d0&gt;
</code></pre>
<p>Is there a difference between <code>simulate(circuit)</code> and <code>sample(circuit)</code> ? And if so, then how do i make the algorithm run with <code>qismcirq</code> instead of <code>cirq</code> ?</p>
",ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed,<simulation><shors-algorithm><cirq>,1,0,,,"ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed <p>I was going through <a href=""https://quantumai.google/cirq/tutorials/shor#quantum_order_finder"" rel=""nofollow noreferrer"">Cirq tutorial on Shor's algorithm</a> and was able to implement it successfully using cirq. But it takes forever to run for any <code>n &gt; 21</code>; so I tried to use the qsim simulator instead of using cirq.</p>
<p><strong>What I tried to do -</strong></p>
<p>I replaced <code>measurement = cirq.sample(circuit)</code> with <code>measurement = simulator.simulate(circuit)</code>.</p>
<pre><code>def quantum_order_finder(x: int, n: int) -&gt; Optional[int]:
    if x &lt; 2 or n &lt;= x or math.gcd(x, n) &gt; 1:
        raise ValueError(f'Invalid x={x} for modulus n={n}.')

    circuit = make_order_finding_circuit(x, n)
    
    simulator = qsimcirq.QSimSimulator()
    measurement = simulator.simulate(circuit)
    
    return process_measurement(measurement, x, n)
</code></pre>
<p><strong>The error I got -</strong></p>
<pre><code>&lt;ipython-input-21-b2e4008cd3ca&gt; in quantum_order_finder(x, n)
     22
---&gt; 23     measurement = simulator.simulate(circuit)
     24

/usr/local/lib/python3.7/dist-packages/cirq/sim/simulator.py in simulate(self, program, param_resolver, qubit_order, initial_state)
    517         &quot;&quot;&quot;
    518         return self.simulate_sweep(
--&gt; 519             program, study.ParamResolver(param_resolver), qubit_order, initial_state
    520         )[0]
    521 

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in simulate_sweep(self, program, params, qubit_order, initial_state)
    561                 solved_circuit,
    562                 translator_fn_name,
--&gt; 563                 cirq_order,
    564             )
    565             options[&quot;s&quot;] = self.get_seed()

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in _translate_circuit(self, circuit, translator_fn_name, qubit_order)
    858         if translated_circuit is None:
    859             translator_fn = getattr(circuit, translator_fn_name)
--&gt; 860             translated_circuit, moment_indices = translator_fn(qubit_order)
    861             self._translated_circuits.append(
    862                 (circuit, translated_circuit, moment_indices)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in translate_cirq_to_qsim(self, qubit_order)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in &lt;listcomp&gt;(.0)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/cirq/protocols/decompose_protocol.py in decompose(val, intercepting_decomposer, fallback_decomposer, keep, on_stuck_raise, preserve_structure)
    245                 error = on_stuck_raise(item)
    246                 if error is not None:
--&gt; 247                     raise error
    248 
    249         output.append(item)

ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed: &lt;__main__.ModularExp object at 0x7efe3c3e76d0&gt;
</code></pre>
<p>Is there a difference between <code>simulate(circuit)</code> and <code>sample(circuit)</code> ? And if so, then how do i make the algorithm run with <code>qismcirq</code> instead of <code>cirq</code> ?</p>
",qc,valueerror operation satisfy given keep ca decomposed p going https nofollow noreferrer cirq tutorial shor algorithm able implement successfully using cirq takes forever run code n gt 21 tried use qsim simulator instead using p strong tried p replaced code measurement circuit code measurement circuit pre code def x int n int gt optional int x lt 2 n lt x x n gt 1 raise valueerror x modulus n circuit x n simulator measurement circuit return measurement x n p strong error got pre code lt gt x n 22 gt 23 measurement circuit 24 simulate self program 517 quot quot quot 518 return gt 519 program 520 0 521 self program params 561 562 gt 563 564 565 options quot quot self circuit 858 none 859 getattr circuit gt 860 861 862 circuit self 316 317 op gt 318 op moment 319 320 max len lt listcomp gt 316 317 op gt 318 op moment 319 320 max len decompose val keep 245 error item 246 error none gt 247 raise error 248 249 item valueerror operation satisfy given keep ca decomposed lt object 0x7efe3c3e76d0 gt p difference code simulate circuit code sample circuit make algorithm run code qismcirq instead code cirq,"[(0, 0.46185014), (4, 0.02606865), (6, 0.049196254), (7, 0.017159976), (10, 0.08473356), (12, 0.01679722), (14, 0.2670712), (16, 0.011461457), (19, 0.06505713)]"
26784,,2022-06-08 13:33:20,0,62,"<p>that is <span class=""math-container"">${{U}_{f}}|\varphi \rangle =|00\cdots 1\cdots 00\rangle $</span>,where <span class=""math-container"">$|00\cdots 1\cdots 0\rangle $</span> is a random unit vector</p>
<p>eg.<span class=""math-container"">$${{U}_{f}}(\sqrt{\frac{1}{3}}|0\rangle +\sqrt{\frac{1}{3}}|1\rangle +\sqrt{\frac{1}{3}}|2\rangle )=|4{{\rangle }_{10}}=|00000100{{\rangle }_{2}}$$</span>or<span class=""math-container"">$${{U}_{f}}(\sqrt{\frac{1}{3}}|0\rangle +\sqrt{\frac{1}{3}}|1\rangle +\sqrt{\frac{1}{3}}|2\rangle )=|2{{\rangle }_{10}}=|00000010{{\rangle }_{2}}$$</span></p>
",Is there a quantum gate that can turn any superposition $|\varphi \rangle $ into a unit column vector $|00\cdots 1\cdots 0\rangle $,<quantum-gate><quantum-state>,1,1,,,"Is there a quantum gate that can turn any superposition $|\varphi \rangle $ into a unit column vector $|00\cdots 1\cdots 0\rangle $ <p>that is <span class=""math-container"">${{U}_{f}}|\varphi \rangle =|00\cdots 1\cdots 00\rangle $</span>,where <span class=""math-container"">$|00\cdots 1\cdots 0\rangle $</span> is a random unit vector</p>
<p>eg.<span class=""math-container"">$${{U}_{f}}(\sqrt{\frac{1}{3}}|0\rangle +\sqrt{\frac{1}{3}}|1\rangle +\sqrt{\frac{1}{3}}|2\rangle )=|4{{\rangle }_{10}}=|00000100{{\rangle }_{2}}$$</span>or<span class=""math-container"">$${{U}_{f}}(\sqrt{\frac{1}{3}}|0\rangle +\sqrt{\frac{1}{3}}|1\rangle +\sqrt{\frac{1}{3}}|2\rangle )=|2{{\rangle }_{10}}=|00000010{{\rangle }_{2}}$$</span></p>
",qc,quantum gate turn superposition unit column vector p span u f span random unit vector p span u f 1 3 1 3 1 3 10 2 span u f 1 3 1 3 1 3 10 2,"[(2, 0.3756718), (3, 0.27982673), (6, 0.103023514), (10, 0.09385833), (13, 0.09483666), (16, 0.04911769)]"
26848,26853.0,2022-06-12 14:34:17,2,232,"<p>I am trying to implement qubit rotations using <span class=""math-container"">$SU(2)$</span> from scratch in order to understand and debug what happens under the (physical) hood. The reason why gates and high-level APIs are omitted here is the desired learning effect and the physical understanding of what actually happens beneath the cap.</p>
<p>Implementing the rotation matrix as describes in this <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">lecture notes</a> (equation 25) works fine if I perform one rotation as follows:</p>
<pre><code>from qiskit.visualization.bloch import Bloch
from sympy.physics.matrices import msigma
from sympy import Matrix
from sympy import N, re
import numpy as np

def to_spherical(vec):
    x = np.real(vec[0])
    y = np.real(vec[1])
    z = np.real(vec[2])
    hxy = np.hypot(x, y)
    r = np.hypot(hxy, z)
    ϕ = np.arctan2(y, x) #az
    θ = np.arctan2(z, hxy) #el
    return [r, ϕ, θ]

def to_cartesian(polar):
    r = polar[0]
    ϕ = polar[1]
    θ = polar[2]
    x = r * np.sin(ϕ) * np.cos(θ)
    y = r * np.sin(ϕ) * np.sin(θ)
    z = r * np.cos(ϕ)
    return [np.real(x), np.real(y), np.real(z)]

def rn_su2(vec, rot_angle, n):
    spherical_vec = to_spherical(vec)
    ϕ = spherical_vec[1]
    θ = spherical_vec[2]
    
    sx = msigma(1)
    sy = msigma(2)
    sz = msigma(3)
    M_q = (np.sin(θ)*np.cos(ϕ)*sx + np.sin(θ)*np.sin(ϕ)*sy + np.cos(θ)*sz)
    U_n = np.eye(2)*np.cos(rot_angle/2) -1j*(n[0]*sx+n[1]*sy+n[2]*sz)*np.sin(rot_angle/2)
    M_q_rotated = U_n*M_q*np.matrix(U_n).H
    return M_q_rotated

def extract_angles(M_q_rotated):
    cos_θ_rotated = float(N(re(M_q_rotated[0,0])))
    θ_rotated = np.arccos(cos_θ_rotated)
    
    # e^(ix) = cos(x) + i*sin(x)
    # see https://en.wikipedia.org/wiki/Euler%27s_identity
    temp = float(N(re(M_q_rotated[1,0])))
    temp = temp/np.sin(θ_rotated)
    ϕ_rotated = np.arccos(temp)
    return (ϕ_rotated, θ_rotated)
</code></pre>
<p>After having implemented the fundamental functions, the most interesting part is to perform the rotations of a Qubit. In the following I am trying to take a vector, rotate it by <span class=""math-container"">$\frac{\pi}{8}$</span> around the <span class=""math-container"">$z$</span>-axis, then in the next step I take the resulting rotated vector and rotate it again by <span class=""math-container"">$\frac{\pi}{8}$</span> around the <span class=""math-container"">$z$</span>-axis and so forth:</p>
<pre><code>rot_angle = np.pi/8
n = [0, 0, 1]

start_vec = [1, 0, 0]

num_iterations = 5
_bloch = Bloch()
_bloch.vector_color = ['blue'] * num_iterations

sv = []
vec = start_vec
sv.append(vec)
for i in range(num_iterations):
    M_q_rotated = rn_su2(vec, rot_angle, n)
    (ϕ_rotated, θ_rotated) = extract_angles(M_q_rotated)
    vec = np.array(to_cartesian([1, ϕ_rotated, θ_rotated]))
    sv.append(vec)

_bloch.add_vectors(sv)
_bloch.render()
</code></pre>
<p>I am using qiskit for visualizing the vectors on a blochsphere. The first rotation works really well, but the subsequent ones not:</p>
<p><a href=""https://i.sstatic.net/Ppod7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ppod7.png"" alt=""enter image description here"" /></a></p>
<p>I would really appreciate any help to get the subsequent rotations working. The complete notebook is publicly available <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow.ipynb"" rel=""nofollow noreferrer"">here on GitHub</a>.</p>
<p><em><strong>Update (2022-06-13):</strong></em>
After fixing the issues enlisted in the great answer of Egretta.Thula, the plot looks as follows (see updated code <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow.ipynb"" rel=""nofollow noreferrer"">here on GitHub</a>):</p>
<p><a href=""https://i.sstatic.net/lxZ2o.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lxZ2o.png"" alt=""enter image description here"" /></a></p>
",A fundamental question on multiple rotation of a qubit using $SU(2)$,<qiskit><bloch-sphere><experimental-realization>,1,0,,,"A fundamental question on multiple rotation of a qubit using $SU(2)$ <p>I am trying to implement qubit rotations using <span class=""math-container"">$SU(2)$</span> from scratch in order to understand and debug what happens under the (physical) hood. The reason why gates and high-level APIs are omitted here is the desired learning effect and the physical understanding of what actually happens beneath the cap.</p>
<p>Implementing the rotation matrix as describes in this <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">lecture notes</a> (equation 25) works fine if I perform one rotation as follows:</p>
<pre><code>from qiskit.visualization.bloch import Bloch
from sympy.physics.matrices import msigma
from sympy import Matrix
from sympy import N, re
import numpy as np

def to_spherical(vec):
    x = np.real(vec[0])
    y = np.real(vec[1])
    z = np.real(vec[2])
    hxy = np.hypot(x, y)
    r = np.hypot(hxy, z)
    ϕ = np.arctan2(y, x) #az
    θ = np.arctan2(z, hxy) #el
    return [r, ϕ, θ]

def to_cartesian(polar):
    r = polar[0]
    ϕ = polar[1]
    θ = polar[2]
    x = r * np.sin(ϕ) * np.cos(θ)
    y = r * np.sin(ϕ) * np.sin(θ)
    z = r * np.cos(ϕ)
    return [np.real(x), np.real(y), np.real(z)]

def rn_su2(vec, rot_angle, n):
    spherical_vec = to_spherical(vec)
    ϕ = spherical_vec[1]
    θ = spherical_vec[2]
    
    sx = msigma(1)
    sy = msigma(2)
    sz = msigma(3)
    M_q = (np.sin(θ)*np.cos(ϕ)*sx + np.sin(θ)*np.sin(ϕ)*sy + np.cos(θ)*sz)
    U_n = np.eye(2)*np.cos(rot_angle/2) -1j*(n[0]*sx+n[1]*sy+n[2]*sz)*np.sin(rot_angle/2)
    M_q_rotated = U_n*M_q*np.matrix(U_n).H
    return M_q_rotated

def extract_angles(M_q_rotated):
    cos_θ_rotated = float(N(re(M_q_rotated[0,0])))
    θ_rotated = np.arccos(cos_θ_rotated)
    
    # e^(ix) = cos(x) + i*sin(x)
    # see https://en.wikipedia.org/wiki/Euler%27s_identity
    temp = float(N(re(M_q_rotated[1,0])))
    temp = temp/np.sin(θ_rotated)
    ϕ_rotated = np.arccos(temp)
    return (ϕ_rotated, θ_rotated)
</code></pre>
<p>After having implemented the fundamental functions, the most interesting part is to perform the rotations of a Qubit. In the following I am trying to take a vector, rotate it by <span class=""math-container"">$\frac{\pi}{8}$</span> around the <span class=""math-container"">$z$</span>-axis, then in the next step I take the resulting rotated vector and rotate it again by <span class=""math-container"">$\frac{\pi}{8}$</span> around the <span class=""math-container"">$z$</span>-axis and so forth:</p>
<pre><code>rot_angle = np.pi/8
n = [0, 0, 1]

start_vec = [1, 0, 0]

num_iterations = 5
_bloch = Bloch()
_bloch.vector_color = ['blue'] * num_iterations

sv = []
vec = start_vec
sv.append(vec)
for i in range(num_iterations):
    M_q_rotated = rn_su2(vec, rot_angle, n)
    (ϕ_rotated, θ_rotated) = extract_angles(M_q_rotated)
    vec = np.array(to_cartesian([1, ϕ_rotated, θ_rotated]))
    sv.append(vec)

_bloch.add_vectors(sv)
_bloch.render()
</code></pre>
<p>I am using qiskit for visualizing the vectors on a blochsphere. The first rotation works really well, but the subsequent ones not:</p>
<p><a href=""https://i.sstatic.net/Ppod7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ppod7.png"" alt=""enter image description here"" /></a></p>
<p>I would really appreciate any help to get the subsequent rotations working. The complete notebook is publicly available <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow.ipynb"" rel=""nofollow noreferrer"">here on GitHub</a>.</p>
<p><em><strong>Update (2022-06-13):</strong></em>
After fixing the issues enlisted in the great answer of Egretta.Thula, the plot looks as follows (see updated code <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow.ipynb"" rel=""nofollow noreferrer"">here on GitHub</a>):</p>
<p><a href=""https://i.sstatic.net/lxZ2o.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lxZ2o.png"" alt=""enter image description here"" /></a></p>
",qc,fundamental question multiple rotation qubit using su 2 p trying implement qubit rotations using span su 2 scratch order understand debug happens physical hood reason gates apis omitted desired learning effect physical understanding actually happens beneath p implementing rotation matrix describes https nofollow noreferrer lecture notes equation 25 works fine perform one rotation follows pre code import bloch import msigma sympy import matrix sympy import n import numpy np def vec x vec 0 vec 1 z vec 2 hxy x r hxy z ϕ x az θ z hxy el return r ϕ θ def polar r polar 0 ϕ polar 1 θ polar 2 x r ϕ θ r ϕ θ z r ϕ return x z def vec n vec ϕ 1 θ 2 sx msigma 1 sy msigma 2 sz msigma 3 θ ϕ sx θ ϕ sy θ sz 2 n 0 1 2 sz return def float n ix cos x sin x see https temp float n temp temp return p implemented fundamental functions interesting part perform rotations qubit following trying take vector rotate span 8 around span z next step take resulting rotated vector rotate span 8 around span z forth pre code n 0 0 1 1 0 0 5 bloch sv vec vec range vec n vec 1 vec sv p using qiskit visualizing vectors blochsphere first rotation works really well subsequent ones p https nofollow noreferrer img https enter image description p would really appreciate help get subsequent rotations working complete notebook publicly available https nofollow noreferrer github p em strong update fixing issues enlisted great answer plot looks follows see updated code https nofollow noreferrer github p https nofollow noreferrer img https enter image description,"[(0, 0.18206894), (2, 0.12172239), (3, 0.12362209), (4, 0.17554876), (5, 0.026274305), (6, 0.0211647), (9, 0.14253646), (10, 0.096538685), (13, 0.04278141), (16, 0.03726343), (19, 0.025416335)]"
26851,26856.0,2022-06-12 19:30:36,1,397,"<p>I've been reading <a href=""https://chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://arxiv.org/pdf/1001.3855.pdf"" rel=""nofollow noreferrer"">this paper</a> about the procedure to simulate a many-body quantum system on a quantum device. I got confused by Figure 1. on page 3, and the 3 steps explained below the figure.</p>
<p>It seems to me that given a quantum many-body Hamiltonian, we will first rewrite it in 2nd quantization, and transform the terms into a sum of Pauli matrices using the Jordan-Wigner transform. Then the trotter decomposition follows. This agrees with the 3 steps explained on the paper:</p>
<p><a href=""https://i.sstatic.net/jRwzW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jRwzW.png"" alt=""enter image description here"" /></a></p>
<p>However in fig 1, the JW transform happens after trotterization. So I'm confused about which step goes first? Does JW transform act on the Hamiltonian, <span class=""math-container"">$H$</span>, or the system under time-evolution, <span class=""math-container"">$U = e^{-iHt}$</span>?</p>
<p>Thanks for the help!</p>
<p><a href=""https://i.sstatic.net/fJzx3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fJzx3.png"" alt=""enter image description here"" /></a></p>
",Jordan-Wigner Transform and Trotterization: which goes first?,<hamiltonian-simulation><many-body-systems><trotterization>,1,0,,,"Jordan-Wigner Transform and Trotterization: which goes first? <p>I've been reading <a href=""https://chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://arxiv.org/pdf/1001.3855.pdf"" rel=""nofollow noreferrer"">this paper</a> about the procedure to simulate a many-body quantum system on a quantum device. I got confused by Figure 1. on page 3, and the 3 steps explained below the figure.</p>
<p>It seems to me that given a quantum many-body Hamiltonian, we will first rewrite it in 2nd quantization, and transform the terms into a sum of Pauli matrices using the Jordan-Wigner transform. Then the trotter decomposition follows. This agrees with the 3 steps explained on the paper:</p>
<p><a href=""https://i.sstatic.net/jRwzW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jRwzW.png"" alt=""enter image description here"" /></a></p>
<p>However in fig 1, the JW transform happens after trotterization. So I'm confused about which step goes first? Does JW transform act on the Hamiltonian, <span class=""math-container"">$H$</span>, or the system under time-evolution, <span class=""math-container"">$U = e^{-iHt}$</span>?</p>
<p>Thanks for the help!</p>
<p><a href=""https://i.sstatic.net/fJzx3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fJzx3.png"" alt=""enter image description here"" /></a></p>
",qc,transform trotterization goes first p reading https nofollow noreferrer paper procedure simulate quantum system quantum device got confused figure page 3 3 steps explained p seems given quantum hamiltonian first rewrite 2nd quantization transform terms sum pauli matrices using transform trotter decomposition follows agrees 3 steps explained paper p https nofollow noreferrer img https enter image description p however fig 1 jw transform happens trotterization confused step goes first jw transform act hamiltonian span h system span u p thanks help p https nofollow noreferrer img https enter image description,"[(1, 0.081155844), (3, 0.18742247), (4, 0.45250592), (8, 0.014145198), (9, 0.12303739), (13, 0.12936632), (16, 0.010890314)]"
26993,26996.0,2022-06-22 01:31:11,1,745,"<p>I have read Fujitsu's white paper for a brief introduction to their device:
<a href=""http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf"" rel=""nofollow noreferrer"">http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf</a>
As far as I know, Fujitsu's hardware is not quantum-mechanical. They call it a digital annealer inspired by quantum phenomenon. I'm curious about what it actually is, and what kind of algorithm it runs. Is it a classical computer or some specialized annealing device? If the former, what kind of annealing algorithm does it use? As for the latter, I'm not sure whether that kind of device actually exists. (Quantum annealers like the ones D-wave has belongs to this category, but Fujitsu doesn't have those.)</p>
",How does Fujitsu's digital annealer work?,<classical-computing><annealing><quantum-inspired>,1,0,,,"How does Fujitsu's digital annealer work? <p>I have read Fujitsu's white paper for a brief introduction to their device:
<a href=""http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf"" rel=""nofollow noreferrer"">http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf</a>
As far as I know, Fujitsu's hardware is not quantum-mechanical. They call it a digital annealer inspired by quantum phenomenon. I'm curious about what it actually is, and what kind of algorithm it runs. Is it a classical computer or some specialized annealing device? If the former, what kind of annealing algorithm does it use? As for the latter, I'm not sure whether that kind of device actually exists. (Quantum annealers like the ones D-wave has belongs to this category, but Fujitsu doesn't have those.)</p>
",qc,fujitsu digital annealer work p read fujitsu white paper brief introduction device http nofollow noreferrer http far know fujitsu hardware call digital annealer inspired quantum phenomenon curious actually kind algorithm runs classical computer specialized annealing device former kind annealing algorithm use latter sure whether kind device actually exists quantum annealers like ones belongs category fujitsu,"[(1, 0.1824403), (4, 0.08113847), (8, 0.47408453), (9, 0.17240815), (12, 0.018083671), (15, 0.037731256), (16, 0.03175488)]"
27001,,2022-06-22 10:01:10,1,563,"<p>I'm using qiskit_ionq API for simulating quantum circuits on ionq devices. Currently, I'm using the <code>ionq_simulator</code> backend, but I think it performs noiseless simulations.</p>
<p>Is there any possibility of introducing noise in the simulations?</p>
",Does qiskit_ionq have the possibility of simulating quantum circuits with noise?,<qiskit><simulation><noise><ionq>,4,1,,,"Does qiskit_ionq have the possibility of simulating quantum circuits with noise? <p>I'm using qiskit_ionq API for simulating quantum circuits on ionq devices. Currently, I'm using the <code>ionq_simulator</code> backend, but I think it performs noiseless simulations.</p>
<p>Is there any possibility of introducing noise in the simulations?</p>
",qc,possibility simulating quantum circuits noise p using api simulating quantum circuits ionq devices currently using code backend think performs noiseless p possibility introducing noise simulations,"[(13, 0.16610628), (14, 0.75330585), (16, 0.07383948)]"
27015,27034.0,2022-06-23 10:18:46,2,680,"<p>Based on the useful straight-forward answers to both of my former questions, on <a href=""https://quantumcomputing.stackexchange.com/questions/26848/a-fundamental-question-on-multiple-rotation-of-a-qubit-using-su2"">multiple rotations of a qubit</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/26970/how-to-implement-subplots-several-blochsphere-plots-using-qiskit"">bloch sphere subplots</a>, I was able to implement the following <span class=""math-container"">$SU(2)$</span> rotations:</p>
<p><a href=""https://i.sstatic.net/OHEZO.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/OHEZO.png"" alt=""enter image description here"" /></a></p>
<p>At this point it is worth mentioning that (as a learner) I am really grateful for the high-quality support. The code looks as follows (I mainly used the sources <em>&quot;A Lie Group: Rotations in Quantum Mechanics&quot;</em>, p. 67 from Jean-Marie Normand or equivalently <a href=""https://link.springer.com/content/pdf/bbm%3A978-3-540-29082-7%2F1.pdf"" rel=""nofollow noreferrer"">A Representations of SU(2)</a> and <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">Lecture notes: Qubit representations and rotations</a>, p. 3):</p>
<pre><code>import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import colors
from qiskit.visualization.bloch import Bloch
from qiskit.visualization import plot_bloch_vector
from sympy.physics.matrices import msigma
from sympy.physics.quantum.dagger import Dagger
from sympy import Matrix
from sympy import I, N, re, exp, sin, cos, pi, eye
import numpy as np

def to_spherical(vec):
    x = np.real(vec[0])
    y = np.real(vec[1])
    z = np.real(vec[2])
    hxy = np.hypot(x, y)
    r = np.hypot(hxy, z)
    ϕ = np.arctan2(y, x) #az
    θ = np.arctan2(hxy, z) #el
    return [r, ϕ, θ]

def to_cartesian(polar):
    r = polar[0]
    ϕ = polar[1]
    θ = polar[2]

    x = r * np.sin(θ) * np.cos(ϕ)
    y = r * np.sin(θ) * np.sin(ϕ)
    z = r * np.cos(θ)
    return [np.real(x), np.real(y), np.real(z)]

def rn_su2_euler(vec, rx, ry, rz):
    spherical_vec = to_spherical(vec)
    ϕ = spherical_vec[1]
    θ = spherical_vec[2]

    sx = msigma(1)
    sy = msigma(2)
    sz = msigma(3)
    M_q = (np.sin(θ)*np.cos(ϕ)*sx + np.sin(θ)*np.sin(ϕ)*sy + np.cos(θ)*sz)
    U_n = Matrix([[exp(-I*(rx+rz)/2)*cos(ry/2), -exp(-I*(rx-rz)/2)*sin(ry/2)], [exp(I*(rx-rz)/2)*sin(ry/2), exp(I*(rx+rz)/2)*cos(ry/2)]])
    M_q_rotated = U_n*M_q*Dagger(U_n)
    return M_q_rotated

def extract_angles(M_q_rotated):
    cos_θ_rotated = float(N(re(M_q_rotated[0,0])))
    θ_rotated = np.arccos(cos_θ_rotated)
    temp = float(N(re(M_q_rotated[1,0])))
    temp = temp/np.sin(θ_rotated)
    ϕ_rotated = np.arccos(temp)
    return (ϕ_rotated, θ_rotated)

def get_gradient_colors(rgb, n):
    red=rgb[0] 
    yel=rgb[1]
    blu=rgb[2]
    result = [colors.to_hex([red,yel,blu])]
    cr = red/n
    cy = yel/n
    cb = blu/n
    for i in range(n):
        if(red!=0):
            red -= cr 
        if(yel!=0):
            yel -= cy
        if(blu!=0):
            blu -= cb
        result.append(colors.to_hex([red,yel,blu]))
    return result

fig, ax = plt.subplots(figsize = [8, 12], nrows=3, ncols=2)
fig.patch.set_facecolor('white')
[axis.set_axis_off() for axis in ax.ravel()]

rotations = [[0, 0, pi/8], [0, 0, pi/8], [0, pi/8, 0], [0.00001, -pi/8, 0], [0, pi/8, pi/8], [0, pi/8, -pi/8]]
start_vec = [1, 0, 0]
num_iterations = 8

for m, rotation in enumerate(rotations):
    ax = fig.add_subplot(320+(m+1), axes_class = Axes3D)
    
    rot_x = rotation[0]
    rot_y = rotation[1]
    rot_z = rotation[2]
    _bloch = Bloch(axes=ax)
    _bloch.vector_color = get_gradient_colors([0, 0, 1], num_iterations)
    _bloch.vector_width = 1
    sv = []
    vec = start_vec
    sv.append(vec)
    for i in range(num_iterations):
        M_q_rotated = rn_su2_euler(vec, rot_x, rot_y, rot_z)
        (ϕ_rotated, θ_rotated) = extract_angles(M_q_rotated)
        vec = np.array(to_cartesian([1, ϕ_rotated, θ_rotated]))
        sv.append(vec)

    _bloch.add_vectors(sv)
    _bloch.render()
</code></pre>
<p><em><strong>My question:</strong></em> How can I achieve that the vectors (mirrored) cover the second half of the hemisphere? Analogous to this: How can I make the vectors in the lower right image cover the other half of the hemisphere? What I understood from the sources is that in the function <code>rn_su2_euler</code> the parameters that are the Euler angles <code>rx</code> can take a value from <span class=""math-container"">$0$</span> to <span class=""math-container"">$2\pi$</span> and <code>ry</code> a value from <span class=""math-container"">$0$</span> to <span class=""math-container"">$\pi$</span> and <code>rz</code> from <span class=""math-container"">$0$</span> to <span class=""math-container"">$4\pi$</span>, see for example <a href=""https://link.springer.com/content/pdf/bbm%3A978-3-540-29082-7%2F1.pdf"" rel=""nofollow noreferrer"">A Representations of SU(2)</a>. But somewhere it seems that there is still a minor bug.</p>
<p>For the sake of completeness, I uploaded the notebook <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow-short.ipynb"" rel=""nofollow noreferrer"">here to GitHub</a>.</p>
",Stepwise $SU(2)$ Rotations on the Bloch Sphere from $\pi$ to $2\pi$,<qiskit><bloch-sphere><experimental-realization>,2,0,,,"Stepwise $SU(2)$ Rotations on the Bloch Sphere from $\pi$ to $2\pi$ <p>Based on the useful straight-forward answers to both of my former questions, on <a href=""https://quantumcomputing.stackexchange.com/questions/26848/a-fundamental-question-on-multiple-rotation-of-a-qubit-using-su2"">multiple rotations of a qubit</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/26970/how-to-implement-subplots-several-blochsphere-plots-using-qiskit"">bloch sphere subplots</a>, I was able to implement the following <span class=""math-container"">$SU(2)$</span> rotations:</p>
<p><a href=""https://i.sstatic.net/OHEZO.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/OHEZO.png"" alt=""enter image description here"" /></a></p>
<p>At this point it is worth mentioning that (as a learner) I am really grateful for the high-quality support. The code looks as follows (I mainly used the sources <em>&quot;A Lie Group: Rotations in Quantum Mechanics&quot;</em>, p. 67 from Jean-Marie Normand or equivalently <a href=""https://link.springer.com/content/pdf/bbm%3A978-3-540-29082-7%2F1.pdf"" rel=""nofollow noreferrer"">A Representations of SU(2)</a> and <a href=""https://www.phys.hawaii.edu/%7Eyepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf"" rel=""nofollow noreferrer"">Lecture notes: Qubit representations and rotations</a>, p. 3):</p>
<pre><code>import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import colors
from qiskit.visualization.bloch import Bloch
from qiskit.visualization import plot_bloch_vector
from sympy.physics.matrices import msigma
from sympy.physics.quantum.dagger import Dagger
from sympy import Matrix
from sympy import I, N, re, exp, sin, cos, pi, eye
import numpy as np

def to_spherical(vec):
    x = np.real(vec[0])
    y = np.real(vec[1])
    z = np.real(vec[2])
    hxy = np.hypot(x, y)
    r = np.hypot(hxy, z)
    ϕ = np.arctan2(y, x) #az
    θ = np.arctan2(hxy, z) #el
    return [r, ϕ, θ]

def to_cartesian(polar):
    r = polar[0]
    ϕ = polar[1]
    θ = polar[2]

    x = r * np.sin(θ) * np.cos(ϕ)
    y = r * np.sin(θ) * np.sin(ϕ)
    z = r * np.cos(θ)
    return [np.real(x), np.real(y), np.real(z)]

def rn_su2_euler(vec, rx, ry, rz):
    spherical_vec = to_spherical(vec)
    ϕ = spherical_vec[1]
    θ = spherical_vec[2]

    sx = msigma(1)
    sy = msigma(2)
    sz = msigma(3)
    M_q = (np.sin(θ)*np.cos(ϕ)*sx + np.sin(θ)*np.sin(ϕ)*sy + np.cos(θ)*sz)
    U_n = Matrix([[exp(-I*(rx+rz)/2)*cos(ry/2), -exp(-I*(rx-rz)/2)*sin(ry/2)], [exp(I*(rx-rz)/2)*sin(ry/2), exp(I*(rx+rz)/2)*cos(ry/2)]])
    M_q_rotated = U_n*M_q*Dagger(U_n)
    return M_q_rotated

def extract_angles(M_q_rotated):
    cos_θ_rotated = float(N(re(M_q_rotated[0,0])))
    θ_rotated = np.arccos(cos_θ_rotated)
    temp = float(N(re(M_q_rotated[1,0])))
    temp = temp/np.sin(θ_rotated)
    ϕ_rotated = np.arccos(temp)
    return (ϕ_rotated, θ_rotated)

def get_gradient_colors(rgb, n):
    red=rgb[0] 
    yel=rgb[1]
    blu=rgb[2]
    result = [colors.to_hex([red,yel,blu])]
    cr = red/n
    cy = yel/n
    cb = blu/n
    for i in range(n):
        if(red!=0):
            red -= cr 
        if(yel!=0):
            yel -= cy
        if(blu!=0):
            blu -= cb
        result.append(colors.to_hex([red,yel,blu]))
    return result

fig, ax = plt.subplots(figsize = [8, 12], nrows=3, ncols=2)
fig.patch.set_facecolor('white')
[axis.set_axis_off() for axis in ax.ravel()]

rotations = [[0, 0, pi/8], [0, 0, pi/8], [0, pi/8, 0], [0.00001, -pi/8, 0], [0, pi/8, pi/8], [0, pi/8, -pi/8]]
start_vec = [1, 0, 0]
num_iterations = 8

for m, rotation in enumerate(rotations):
    ax = fig.add_subplot(320+(m+1), axes_class = Axes3D)
    
    rot_x = rotation[0]
    rot_y = rotation[1]
    rot_z = rotation[2]
    _bloch = Bloch(axes=ax)
    _bloch.vector_color = get_gradient_colors([0, 0, 1], num_iterations)
    _bloch.vector_width = 1
    sv = []
    vec = start_vec
    sv.append(vec)
    for i in range(num_iterations):
        M_q_rotated = rn_su2_euler(vec, rot_x, rot_y, rot_z)
        (ϕ_rotated, θ_rotated) = extract_angles(M_q_rotated)
        vec = np.array(to_cartesian([1, ϕ_rotated, θ_rotated]))
        sv.append(vec)

    _bloch.add_vectors(sv)
    _bloch.render()
</code></pre>
<p><em><strong>My question:</strong></em> How can I achieve that the vectors (mirrored) cover the second half of the hemisphere? Analogous to this: How can I make the vectors in the lower right image cover the other half of the hemisphere? What I understood from the sources is that in the function <code>rn_su2_euler</code> the parameters that are the Euler angles <code>rx</code> can take a value from <span class=""math-container"">$0$</span> to <span class=""math-container"">$2\pi$</span> and <code>ry</code> a value from <span class=""math-container"">$0$</span> to <span class=""math-container"">$\pi$</span> and <code>rz</code> from <span class=""math-container"">$0$</span> to <span class=""math-container"">$4\pi$</span>, see for example <a href=""https://link.springer.com/content/pdf/bbm%3A978-3-540-29082-7%2F1.pdf"" rel=""nofollow noreferrer"">A Representations of SU(2)</a>. But somewhere it seems that there is still a minor bug.</p>
<p>For the sake of completeness, I uploaded the notebook <a href=""https://github.com/Sultanow/quantum/blob/main/bloch_sphere/rotate_su2_qiskit_eldar-sultanow-short.ipynb"" rel=""nofollow noreferrer"">here to GitHub</a>.</p>
",qc,stepwise su 2 rotations bloch sphere p based useful answers former questions https multiple rotations qubit https bloch sphere subplots able implement following span su 2 rotations p https nofollow noreferrer img https enter image description p point worth mentioning learner really grateful support code looks follows mainly used sources em quot lie group rotations quantum mechanics quot 67 normand equivalently https nofollow noreferrer representations su 2 https nofollow noreferrer lecture notes qubit representations rotations 3 pre code import plt import axes3d matplotlib import colors import bloch import import msigma import dagger sympy import matrix sympy import n exp sin cos pi eye import numpy np def vec x vec 0 vec 1 z vec 2 hxy x r hxy z ϕ x az θ hxy z el return r ϕ θ def polar r polar 0 ϕ polar 1 θ polar 2 x r θ ϕ r θ ϕ z r θ return x z def vec rx ry rz vec ϕ 1 θ 2 sx msigma 1 sy msigma 2 sz msigma 3 θ ϕ sx θ ϕ sy θ sz matrix exp cos sin exp sin exp cos dagger return def float n temp float n temp temp return def rgb n 0 1 2 result red yel blu cr cy cb range n red red cr yel yel cy blu blu cb red yel blu return result fig ax figsize 8 12 axis rotations 0 0 0 0 0 0 0 0 0 1 0 0 8 rotation enumerate rotations ax axes3d rotation 0 rotation 1 rotation 2 bloch 0 0 1 1 sv vec vec range vec vec 1 vec sv p em strong question achieve vectors mirrored cover second half hemisphere analogous make vectors lower right image cover half hemisphere understood sources function code parameters euler angles code rx take value span 0 span code ry value span 0 span code rz span 0 span see example https nofollow noreferrer representations su 2 somewhere seems still minor p sake completeness uploaded notebook https nofollow noreferrer github,"[(0, 0.21721855), (2, 0.20577593), (3, 0.11512793), (4, 0.09735859), (6, 0.019365119), (8, 0.023945043), (9, 0.12245688), (10, 0.07080298), (13, 0.058822516), (15, 0.014869459), (16, 0.035532873), (19, 0.018459061)]"
27021,27024.0,2022-06-23 13:50:08,0,304,"<p>I am working on a Cirq notebook and the quantum circuit is created in this way:</p>
<pre><code>import cirq
import numpy as np

from cirq import GridQubit, Circuit

from cirq import Simulator
simulator = Simulator()

q = GridQubit(0,0)
circuit = Circuit.from_ops(
    cirq.measure(q, key='m')
)
</code></pre>
<p>and I receive an error:</p>
<pre><code>AttributeError: type object 'Circuit' has no attribute 'from_ops'
</code></pre>
<p>What should I do to fix it?</p>
",type object 'Circuit' has no attribute 'from_ops',<quantum-circuit><cirq>,1,0,,,"type object 'Circuit' has no attribute 'from_ops' <p>I am working on a Cirq notebook and the quantum circuit is created in this way:</p>
<pre><code>import cirq
import numpy as np

from cirq import GridQubit, Circuit

from cirq import Simulator
simulator = Simulator()

q = GridQubit(0,0)
circuit = Circuit.from_ops(
    cirq.measure(q, key='m')
)
</code></pre>
<p>and I receive an error:</p>
<pre><code>AttributeError: type object 'Circuit' has no attribute 'from_ops'
</code></pre>
<p>What should I do to fix it?</p>
",qc,type object attribute p working cirq notebook quantum circuit created way pre code import cirq import numpy np cirq import gridqubit circuit cirq import simulator simulator simulator q gridqubit circuit q p receive error pre code attributeerror type object attribute p fix,"[(0, 0.58212566), (14, 0.33293548), (16, 0.0807096)]"
27064,,2022-06-25 11:39:02,0,480,"<p>Is it possible to get the statevector while running quantum circuits on IBMQ real hardware? If getting the statevector is not possible can I still calculate the fidelity of a qubit somehow?. What I want is to calculate the fidelity of q0, q1 and q2 in the following circuit after running it on real quantum hardware.</p>
<p><a href=""https://i.sstatic.net/7HuCr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7HuCr.png"" alt=""enter image description here"" /></a></p>
<p>The code I am using is as follows:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import IBMQ, Aer, transpile, assemble
from qiskit.visualization import plot_histogram, plot_bloch_multivector, array_to_latex
from qiskit.extensions import Initialize
from qiskit.tools.monitor import job_monitor
from qiskit.quantum_info import random_statevector,partial_trace,state_fidelity
from math import pi, sqrt
from qiskit import IBMQ, transpile
from qiskit import IBMQ


IBMQ.load_account()
IBMQ.providers()
provider = IBMQ.get_provider(hub='ibm-q')  # replace by your runtime provider
backend = provider.get_backend('ibmq_lima')
psi= random_statevector(2)
fidelityQ00=[]

# Display it nicely
display(array_to_latex(psi, prefix=&quot;|\\psi\\rangle =&quot;))
# Show it on a Bloch sphere
plot_bloch_multivector(psi)

qc = QuantumCircuit(3)
qc.initialize(psi, 0)

qc.u(np.arccos(1/sqrt(5)), 0,0,1)
qc.cx(1,2)
qc.u(np.arccos(sqrt(5)/3), 0,0,2)
qc.cx(2,1)
qc.u(np.arccos(2/sqrt(5)), 0,0,1)
qc.cx(0,1)
qc.cx(0,2)
qc.cx(1,0)
qc.cx(2,0)
qc.draw(output='mpl')
#qc.save_statevector()


#t_qc = transpile(qc, backend, optimization_level=3)
#job = backend.run(t_qc)
#job_monitor(job)
#exp_result = job.result()
#exp_counts = exp_result.get_statevector(qc)


  
</code></pre>
",How to get statevector of qubits after running quantum circuits on IBMQ real hardware to calculate the fidelity of all qubits individually?,<qiskit><quantum-state><ibm-q-experience>,1,1,,,"How to get statevector of qubits after running quantum circuits on IBMQ real hardware to calculate the fidelity of all qubits individually? <p>Is it possible to get the statevector while running quantum circuits on IBMQ real hardware? If getting the statevector is not possible can I still calculate the fidelity of a qubit somehow?. What I want is to calculate the fidelity of q0, q1 and q2 in the following circuit after running it on real quantum hardware.</p>
<p><a href=""https://i.sstatic.net/7HuCr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7HuCr.png"" alt=""enter image description here"" /></a></p>
<p>The code I am using is as follows:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import IBMQ, Aer, transpile, assemble
from qiskit.visualization import plot_histogram, plot_bloch_multivector, array_to_latex
from qiskit.extensions import Initialize
from qiskit.tools.monitor import job_monitor
from qiskit.quantum_info import random_statevector,partial_trace,state_fidelity
from math import pi, sqrt
from qiskit import IBMQ, transpile
from qiskit import IBMQ


IBMQ.load_account()
IBMQ.providers()
provider = IBMQ.get_provider(hub='ibm-q')  # replace by your runtime provider
backend = provider.get_backend('ibmq_lima')
psi= random_statevector(2)
fidelityQ00=[]

# Display it nicely
display(array_to_latex(psi, prefix=&quot;|\\psi\\rangle =&quot;))
# Show it on a Bloch sphere
plot_bloch_multivector(psi)

qc = QuantumCircuit(3)
qc.initialize(psi, 0)

qc.u(np.arccos(1/sqrt(5)), 0,0,1)
qc.cx(1,2)
qc.u(np.arccos(sqrt(5)/3), 0,0,2)
qc.cx(2,1)
qc.u(np.arccos(2/sqrt(5)), 0,0,1)
qc.cx(0,1)
qc.cx(0,2)
qc.cx(1,0)
qc.cx(2,0)
qc.draw(output='mpl')
#qc.save_statevector()


#t_qc = transpile(qc, backend, optimization_level=3)
#job = backend.run(t_qc)
#job_monitor(job)
#exp_result = job.result()
#exp_counts = exp_result.get_statevector(qc)


  
</code></pre>
",qc,get statevector qubits running quantum circuits ibmq real hardware calculate fidelity qubits individually p possible get statevector running quantum circuits ibmq real hardware getting statevector possible still calculate fidelity qubit somehow want calculate fidelity q0 q1 q2 following circuit running real quantum p https nofollow noreferrer img https enter image description p code using follows pre code import numpy np qiskit import quantumcircuit quantumregister classicalregister qiskit import ibmq aer transpile assemble import import initialize import import math import pi sqrt qiskit import ibmq transpile qiskit import ibmq provider replace runtime provider backend 2 display nicely display psi quot quot show bloch sphere psi qc quantumcircuit 3 psi 0 5 sqrt 5 5 transpile qc backend job job qc,"[(0, 0.5644337), (4, 0.10424036), (13, 0.02653771), (14, 0.28641972), (16, 0.017099295)]"
27068,,2022-06-25 19:06:51,2,76,"<p>Let <span class=""math-container"">$C$</span> be an <span class=""math-container"">$[[n,k]]$</span> stabilizer code with stabilizers <span class=""math-container"">$(S_1,\cdots,S_m)$</span> and logicals <span class=""math-container"">$(\bar Z_1,\cdots,\bar Z_k)$</span> and <span class=""math-container"">$(\bar X_1,\cdots,\bar X_k)$</span>. Let's also assume that the destabilizers <span class=""math-container"">$(D_1,\cdots,D_m)$</span> have been calculated. I can build a new <span class=""math-container"">$[[n,k-1]]$</span> code <span class=""math-container"">$C^-$</span> by taking one of the logicals and treating it as a new stabilizer; so the stabilizers of <span class=""math-container"">$C^-$</span> are <span class=""math-container"">$(S_1,\cdots,S_m,\bar Z_1)$</span>; the corresponding logical <span class=""math-container"">$\bar X_1$</span> becomes a destabilizer. Going the other way I can build a new <span class=""math-container"">$[[n,k+1]]$</span> code <span class=""math-container"">$C^+$</span> by treating one of the stabilizers as a logical;
the corresponding destabilizer also becomes a logical. So <span class=""math-container"">$C^+$</span> has <span class=""math-container"">$(S_1,\cdots,S_{m-1})$</span> as stabilizers and logicals <span class=""math-container"">$(\bar Z_1,\cdots,\bar Z_k,S_m)$</span> and <span class=""math-container"">$(\bar X_1,\cdots,\bar X_k,D_m)$</span>.</p>
<p>What can be said about <span class=""math-container"">$C^-$</span> and <span class=""math-container"">$C^+$</span> in relation to <span class=""math-container"">$C$</span>?. Some properties are obvious : basis elements of <span class=""math-container"">$C$</span> get merged for <span class=""math-container"">$C^-$</span> and split for <span class=""math-container"">$C^+$</span>. Can anything be said about distance?
weight distribution...</p>
",what can be said about stabilizer codes derived by combining stabilizers and logicals,<error-correction><stabilizer-code>,0,0,,,"what can be said about stabilizer codes derived by combining stabilizers and logicals <p>Let <span class=""math-container"">$C$</span> be an <span class=""math-container"">$[[n,k]]$</span> stabilizer code with stabilizers <span class=""math-container"">$(S_1,\cdots,S_m)$</span> and logicals <span class=""math-container"">$(\bar Z_1,\cdots,\bar Z_k)$</span> and <span class=""math-container"">$(\bar X_1,\cdots,\bar X_k)$</span>. Let's also assume that the destabilizers <span class=""math-container"">$(D_1,\cdots,D_m)$</span> have been calculated. I can build a new <span class=""math-container"">$[[n,k-1]]$</span> code <span class=""math-container"">$C^-$</span> by taking one of the logicals and treating it as a new stabilizer; so the stabilizers of <span class=""math-container"">$C^-$</span> are <span class=""math-container"">$(S_1,\cdots,S_m,\bar Z_1)$</span>; the corresponding logical <span class=""math-container"">$\bar X_1$</span> becomes a destabilizer. Going the other way I can build a new <span class=""math-container"">$[[n,k+1]]$</span> code <span class=""math-container"">$C^+$</span> by treating one of the stabilizers as a logical;
the corresponding destabilizer also becomes a logical. So <span class=""math-container"">$C^+$</span> has <span class=""math-container"">$(S_1,\cdots,S_{m-1})$</span> as stabilizers and logicals <span class=""math-container"">$(\bar Z_1,\cdots,\bar Z_k,S_m)$</span> and <span class=""math-container"">$(\bar X_1,\cdots,\bar X_k,D_m)$</span>.</p>
<p>What can be said about <span class=""math-container"">$C^-$</span> and <span class=""math-container"">$C^+$</span> in relation to <span class=""math-container"">$C$</span>?. Some properties are obvious : basis elements of <span class=""math-container"">$C$</span> get merged for <span class=""math-container"">$C^-$</span> and split for <span class=""math-container"">$C^+$</span>. Can anything be said about distance?
weight distribution...</p>
",qc,said stabilizer codes derived combining stabilizers logicals p let span c span n k stabilizer code stabilizers span logicals span span let also assume destabilizers span calculated build new span n code span taking one logicals treating new stabilizer stabilizers span span corresponding logical span becomes destabilizer going way build new span n code span treating one stabilizers logical corresponding destabilizer also becomes logical span span stabilizers logicals span span p said span span relation span c properties obvious basis elements span c get merged span split span anything said distance weight distribution,"[(3, 0.7019878), (5, 0.23676911), (11, 0.044532698), (16, 0.014992916)]"
27088,27090.0,2022-06-26 18:12:20,1,2002,"<p>I have a simple circuit which I run for 10 shots:</p>
<pre><code>from qiskit.quantum_info import Statevector

from qiskit import Aer, execute, QuantumCircuit
from qiskit.quantum_info import Statevector

backend = Aer.get_backend(&quot;statevector_simulator&quot;)
qc2 = QuantumCircuit(2, 1)
qc2.h(0)
qc2.measure([0], [0])
print(qc2)
result = execute(qc2, backend=backend, shots=10).result()
</code></pre>
<p><a href=""https://i.sstatic.net/VIN5D.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VIN5D.png"" alt=""enter image description here"" /></a></p>
<p>Now, when I print the state vector with:</p>
<pre><code>print('State after measurement:', result.get_statevector())
</code></pre>
<p>The output is:</p>
<blockquote>
<p>State after measurement: Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
dims=(2, 2))</p>
</blockquote>
<p>The question is that to which of the 10 shots does this state vector belong to? Depending on the measurement, the state vector should be different - when q0 is measured as 0 and when q0 is 1.</p>
<p>And how do I get the statevector for each shot?</p>
",Qiskit - How to get statevector for each shot?,<qiskit><measurement>,2,0,,,"Qiskit - How to get statevector for each shot? <p>I have a simple circuit which I run for 10 shots:</p>
<pre><code>from qiskit.quantum_info import Statevector

from qiskit import Aer, execute, QuantumCircuit
from qiskit.quantum_info import Statevector

backend = Aer.get_backend(&quot;statevector_simulator&quot;)
qc2 = QuantumCircuit(2, 1)
qc2.h(0)
qc2.measure([0], [0])
print(qc2)
result = execute(qc2, backend=backend, shots=10).result()
</code></pre>
<p><a href=""https://i.sstatic.net/VIN5D.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VIN5D.png"" alt=""enter image description here"" /></a></p>
<p>Now, when I print the state vector with:</p>
<pre><code>print('State after measurement:', result.get_statevector())
</code></pre>
<p>The output is:</p>
<blockquote>
<p>State after measurement: Statevector([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
dims=(2, 2))</p>
</blockquote>
<p>The question is that to which of the 10 shots does this state vector belong to? Depending on the measurement, the state vector should be different - when q0 is measured as 0 and when q0 is 1.</p>
<p>And how do I get the statevector for each shot?</p>
",qc,qiskit get statevector shot p simple circuit run 10 shots pre code import statevector qiskit import aer execute quantumcircuit import statevector backend quot quot qc2 quantumcircuit 2 1 0 0 0 print qc2 result execute qc2 p https nofollow noreferrer img https enter image description p print state vector pre code print measurement p output blockquote p state measurement statevector 2 2 p question 10 shots state vector belong depending measurement state vector different q0 measured 0 q0 p get statevector shot,"[(0, 0.41468573), (2, 0.14063364), (4, 0.17742486), (14, 0.11033099), (16, 0.025159745), (18, 0.11004786), (19, 0.020135244)]"
27100,27109.0,2022-06-27 10:06:09,0,573,"<p>I need to repeatedly input one random quantum state after another into a quantum circuit that has been designed and assigned parameters, and these quantum states will be used as input. I have tried</p>
<blockquote>
<p>Statevector()</p>
</blockquote>
<p><a href=""https://qiskit.org/documentation/locale/ja_JP/stubs/qiskit.quantum_info.Statevector.html?highlight=statevector#qiskit.quantum_info.Statevector"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/locale/ja_JP/stubs/qiskit.quantum_info.Statevector.html?highlight=statevector#qiskit.quantum_info.Statevector</a></p>
<blockquote>
<p>Custom()</p>
</blockquote>
<p><a href=""https://qiskit.org/documentation/stable/0.19/stubs/qiskit.aqua.components.initial_states.Custom.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.19/stubs/qiskit.aqua.components.initial_states.Custom.html</a></p>
<blockquote>
<p>initialize()</p>
</blockquote>
<p><a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.initialize.html?highlight=initialize#qiskit.circuit.QuantumCircuit.initialize"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.initialize.html?highlight=initialize#qiskit.circuit.QuantumCircuit.initialize</a></p>
<p>, but I found Although these functions can generate new state vectors, they cannot be inserted into already designed quantum circuits, resulting in the same circuit results every time. How should I design it? The three functions mentioned above lack the inplace property and cannot generate a new circuit copy.</p>
<pre><code>{ParameterVectorElement(aa[0]): 0.2379597082677889, ParameterVectorElement(aa[1]): 1.4010239667773599, ParameterVectorElement(aa[2]): 0.10401258494998716, ParameterVectorElement(aa[3]): 0.3326296026269176, ParameterVectorElement(bb[0]): 1.6443757859109702, ParameterVectorElement(bb[1]): 0.8877583818970967, ParameterVectorElement(bb[2]): 0.07150986168780663, ParameterVectorElement(bb[3]): 1.720576457948209, ParameterVectorElement(cc[0]): 1.9974865102845014, ParameterVectorElement(cc[1]): 1.4917958623436192, ParameterVectorElement(cc[2]): 0.7199744574903324, ParameterVectorElement(cc[3]): 2.635969165530908}
WARNING:qiskit.aqua.components.initial_states.custom:The provided state_vector is ignored in favor of the provided custom circuit.
ParameterView([]) [0.00449711 0.         0.         ... 0.         0.         0.        ]
C:\Users\15691\AppData\Local\Temp\ipykernel_347040\162399.py:121: DeprecationWarning: The return type of saved density matrices has been changed from a `numpy.ndarray` to a `qiskit.quantum_info.DensityMatrix` as of qiskit-aer 0.10. Accessing numpy array attributes is deprecated and will result in an error in a future release. To continue using saved result objects as arrays you can explicitly cast them using  `np.asarray(object)`.
  t = np.array(density_matrix.real)
[[0.09660034 0.09656075 0.11104839 0.11262035 0.09307498 0.09300402
  0.10599975 0.10750024]
 [0.09656075 0.0984683  0.11262035 0.11646331 0.09300402 0.0948085
  0.10750024 0.11116849]
 [0.11104839 0.11262035 0.1565212  0.16014388 0.10599975 0.10750024
  0.14853878 0.15202993]
 [0.11262035 0.11646331 0.16014388 0.16699589 0.10750024 0.11116849
  0.15202993 0.15858678]
 [0.09307498 0.09300402 0.10599975 0.10750024 0.09142649 0.09132274
  0.10308861 0.10454789]
 [0.09300402 0.0948085  0.10750024 0.11116849 0.09132274 0.09306052
  0.10454789 0.10811539]
 [0.10599975 0.10750024 0.14853878 0.15202993 0.10308861 0.10454789
  0.14355167 0.14698168]
 [0.10750024 0.11116849 0.15202993 0.15858678 0.10454789 0.10811539
  0.14698168 0.15337558]]
{ParameterVectorElement(aa[0]): 0.2379597082677889, ParameterVectorElement(aa[1]): 1.4010239667773599, ParameterVectorElement(aa[2]): 0.10401258494998716, ParameterVectorElement(aa[3]): 0.3326296026269176, ParameterVectorElement(bb[0]): 1.6443757859109702, ParameterVectorElement(bb[1]): 0.8877583818970967, ParameterVectorElement(bb[2]): 0.07150986168780663, ParameterVectorElement(bb[3]): 1.720576457948209, ParameterVectorElement(cc[0]): 1.9974865102845014, ParameterVectorElement(cc[1]): 1.4917958623436192, ParameterVectorElement(cc[2]): 0.7199744574903324, ParameterVectorElement(cc[3]): 2.635969165530908}
WARNING:qiskit.aqua.components.initial_states.custom:The provided state_vector is ignored in favor of the provided custom circuit.
ParameterView([]) [0.01146697 0.         0.         ... 0.         0.         0.        ]
[[0.09660034 0.09656075 0.11104839 0.11262035 0.09307498 0.09300402
  0.10599975 0.10750024]
 [0.09656075 0.0984683  0.11262035 0.11646331 0.09300402 0.0948085
  0.10750024 0.11116849]
 [0.11104839 0.11262035 0.1565212  0.16014388 0.10599975 0.10750024
  0.14853878 0.15202993]
 [0.11262035 0.11646331 0.16014388 0.16699589 0.10750024 0.11116849
  0.15202993 0.15858678]
 [0.09307498 0.09300402 0.10599975 0.10750024 0.09142649 0.09132274
  0.10308861 0.10454789]
 [0.09300402 0.0948085  0.10750024 0.11116849 0.09132274 0.09306052
  0.10454789 0.10811539]
 [0.10599975 0.10750024 0.14853878 0.15202993 0.10308861 0.10454789
  0.14355167 0.14698168]
 [0.10750024 0.11116849 0.15202993 0.15858678 0.10454789 0.10811539
  0.14698168 0.15337558]]
{ParameterVectorElement(aa[0]): 0.2379597082677889, ParameterVectorElement(aa[1]): 1.4010239667773599, ParameterVectorElement(aa[2]): 0.10401258494998716, ParameterVectorElement(aa[3]): 0.3326296026269176, ParameterVectorElement(bb[0]): 1.6443757859109702, ParameterVectorElement(bb[1]): 0.8877583818970967, ParameterVectorElement(bb[2]): 0.07150986168780663, ParameterVectorElement(bb[3]): 1.720576457948209, ParameterVectorElement(cc[0]): 1.9974865102845014, ParameterVectorElement(cc[1]): 1.4917958623436192, ParameterVectorElement(cc[2]): 0.7199744574903324, ParameterVectorElement(cc[3]): 2.635969165530908}
</code></pre>
","How to repeatedly initialize a fixed quantum circuit, and the initialization vector is random？",<qiskit>,2,1,,,"How to repeatedly initialize a fixed quantum circuit, and the initialization vector is random？ <p>I need to repeatedly input one random quantum state after another into a quantum circuit that has been designed and assigned parameters, and these quantum states will be used as input. I have tried</p>
<blockquote>
<p>Statevector()</p>
</blockquote>
<p><a href=""https://qiskit.org/documentation/locale/ja_JP/stubs/qiskit.quantum_info.Statevector.html?highlight=statevector#qiskit.quantum_info.Statevector"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/locale/ja_JP/stubs/qiskit.quantum_info.Statevector.html?highlight=statevector#qiskit.quantum_info.Statevector</a></p>
<blockquote>
<p>Custom()</p>
</blockquote>
<p><a href=""https://qiskit.org/documentation/stable/0.19/stubs/qiskit.aqua.components.initial_states.Custom.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.19/stubs/qiskit.aqua.components.initial_states.Custom.html</a></p>
<blockquote>
<p>initialize()</p>
</blockquote>
<p><a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.initialize.html?highlight=initialize#qiskit.circuit.QuantumCircuit.initialize"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.initialize.html?highlight=initialize#qiskit.circuit.QuantumCircuit.initialize</a></p>
<p>, but I found Although these functions can generate new state vectors, they cannot be inserted into already designed quantum circuits, resulting in the same circuit results every time. How should I design it? The three functions mentioned above lack the inplace property and cannot generate a new circuit copy.</p>
<pre><code>{ParameterVectorElement(aa[0]): 0.2379597082677889, ParameterVectorElement(aa[1]): 1.4010239667773599, ParameterVectorElement(aa[2]): 0.10401258494998716, ParameterVectorElement(aa[3]): 0.3326296026269176, ParameterVectorElement(bb[0]): 1.6443757859109702, ParameterVectorElement(bb[1]): 0.8877583818970967, ParameterVectorElement(bb[2]): 0.07150986168780663, ParameterVectorElement(bb[3]): 1.720576457948209, ParameterVectorElement(cc[0]): 1.9974865102845014, ParameterVectorElement(cc[1]): 1.4917958623436192, ParameterVectorElement(cc[2]): 0.7199744574903324, ParameterVectorElement(cc[3]): 2.635969165530908}
WARNING:qiskit.aqua.components.initial_states.custom:The provided state_vector is ignored in favor of the provided custom circuit.
ParameterView([]) [0.00449711 0.         0.         ... 0.         0.         0.        ]
C:\Users\15691\AppData\Local\Temp\ipykernel_347040\162399.py:121: DeprecationWarning: The return type of saved density matrices has been changed from a `numpy.ndarray` to a `qiskit.quantum_info.DensityMatrix` as of qiskit-aer 0.10. Accessing numpy array attributes is deprecated and will result in an error in a future release. To continue using saved result objects as arrays you can explicitly cast them using  `np.asarray(object)`.
  t = np.array(density_matrix.real)
[[0.09660034 0.09656075 0.11104839 0.11262035 0.09307498 0.09300402
  0.10599975 0.10750024]
 [0.09656075 0.0984683  0.11262035 0.11646331 0.09300402 0.0948085
  0.10750024 0.11116849]
 [0.11104839 0.11262035 0.1565212  0.16014388 0.10599975 0.10750024
  0.14853878 0.15202993]
 [0.11262035 0.11646331 0.16014388 0.16699589 0.10750024 0.11116849
  0.15202993 0.15858678]
 [0.09307498 0.09300402 0.10599975 0.10750024 0.09142649 0.09132274
  0.10308861 0.10454789]
 [0.09300402 0.0948085  0.10750024 0.11116849 0.09132274 0.09306052
  0.10454789 0.10811539]
 [0.10599975 0.10750024 0.14853878 0.15202993 0.10308861 0.10454789
  0.14355167 0.14698168]
 [0.10750024 0.11116849 0.15202993 0.15858678 0.10454789 0.10811539
  0.14698168 0.15337558]]
{ParameterVectorElement(aa[0]): 0.2379597082677889, ParameterVectorElement(aa[1]): 1.4010239667773599, ParameterVectorElement(aa[2]): 0.10401258494998716, ParameterVectorElement(aa[3]): 0.3326296026269176, ParameterVectorElement(bb[0]): 1.6443757859109702, ParameterVectorElement(bb[1]): 0.8877583818970967, ParameterVectorElement(bb[2]): 0.07150986168780663, ParameterVectorElement(bb[3]): 1.720576457948209, ParameterVectorElement(cc[0]): 1.9974865102845014, ParameterVectorElement(cc[1]): 1.4917958623436192, ParameterVectorElement(cc[2]): 0.7199744574903324, ParameterVectorElement(cc[3]): 2.635969165530908}
WARNING:qiskit.aqua.components.initial_states.custom:The provided state_vector is ignored in favor of the provided custom circuit.
ParameterView([]) [0.01146697 0.         0.         ... 0.         0.         0.        ]
[[0.09660034 0.09656075 0.11104839 0.11262035 0.09307498 0.09300402
  0.10599975 0.10750024]
 [0.09656075 0.0984683  0.11262035 0.11646331 0.09300402 0.0948085
  0.10750024 0.11116849]
 [0.11104839 0.11262035 0.1565212  0.16014388 0.10599975 0.10750024
  0.14853878 0.15202993]
 [0.11262035 0.11646331 0.16014388 0.16699589 0.10750024 0.11116849
  0.15202993 0.15858678]
 [0.09307498 0.09300402 0.10599975 0.10750024 0.09142649 0.09132274
  0.10308861 0.10454789]
 [0.09300402 0.0948085  0.10750024 0.11116849 0.09132274 0.09306052
  0.10454789 0.10811539]
 [0.10599975 0.10750024 0.14853878 0.15202993 0.10308861 0.10454789
  0.14355167 0.14698168]
 [0.10750024 0.11116849 0.15202993 0.15858678 0.10454789 0.10811539
  0.14698168 0.15337558]]
{ParameterVectorElement(aa[0]): 0.2379597082677889, ParameterVectorElement(aa[1]): 1.4010239667773599, ParameterVectorElement(aa[2]): 0.10401258494998716, ParameterVectorElement(aa[3]): 0.3326296026269176, ParameterVectorElement(bb[0]): 1.6443757859109702, ParameterVectorElement(bb[1]): 0.8877583818970967, ParameterVectorElement(bb[2]): 0.07150986168780663, ParameterVectorElement(bb[3]): 1.720576457948209, ParameterVectorElement(cc[0]): 1.9974865102845014, ParameterVectorElement(cc[1]): 1.4917958623436192, ParameterVectorElement(cc[2]): 0.7199744574903324, ParameterVectorElement(cc[3]): 2.635969165530908}
</code></pre>
",qc,repeatedly initialize fixed quantum circuit initialization vector p need repeatedly input one random quantum state another quantum circuit designed assigned parameters quantum states used input tried blockquote p statevector p https nofollow noreferrer https blockquote p custom p https nofollow noreferrer https blockquote p initialize p https nofollow noreferrer https p found although functions generate new state vectors inserted already designed quantum circuits resulting circuit results every time design three functions mentioned lack inplace property generate new circuit pre code parametervectorelement aa 0 parametervectorelement aa 1 parametervectorelement aa 2 parametervectorelement aa 3 parametervectorelement bb 0 parametervectorelement bb 1 parametervectorelement bb 2 parametervectorelement bb 3 parametervectorelement cc 0 parametervectorelement cc 1 parametervectorelement cc 2 parametervectorelement cc 3 warning provided ignored favor provided custom circuit parameterview 0 0 0 0 0 c deprecationwarning return type saved density matrices changed accessing numpy array attributes deprecated result error future release continue using saved result objects arrays explicitly cast using object parametervectorelement aa 0 parametervectorelement aa 1 parametervectorelement aa 2 parametervectorelement aa 3 parametervectorelement bb 0 parametervectorelement bb 1 parametervectorelement bb 2 parametervectorelement bb 3 parametervectorelement cc 0 parametervectorelement cc 1 parametervectorelement cc 2 parametervectorelement cc 3 warning provided ignored favor provided custom circuit parameterview 0 0 0 0 0 parametervectorelement aa 0 parametervectorelement aa 1 parametervectorelement aa 2 parametervectorelement aa 3 parametervectorelement bb 0 parametervectorelement bb 1 parametervectorelement bb 2 parametervectorelement bb 3 parametervectorelement cc 0 parametervectorelement cc 1 parametervectorelement cc 2 parametervectorelement cc 3,"[(0, 0.11145194), (1, 0.0764464), (2, 0.21293001), (4, 0.05699065), (5, 0.07557061), (8, 0.04843248), (9, 0.12112392), (13, 0.03151945), (14, 0.09689734), (16, 0.15759051)]"
27102,27110.0,2022-06-27 10:40:15,0,208,"<p>I came across it as the return type of operations in this paper: <a href=""https://arxiv.org/abs/2204.13835"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2204.13835</a>. It is also used in various places in the Q# documentation.</p>
","What is the data type ""Unit is Adj"" in Q#?",<programming><q#>,1,0,,,"What is the data type ""Unit is Adj"" in Q#? <p>I came across it as the return type of operations in this paper: <a href=""https://arxiv.org/abs/2204.13835"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2204.13835</a>. It is also used in various places in the Q# documentation.</p>
",qc,data type unit adj q p came across return type operations paper https nofollow noreferrer https also used various places q,"[(0, 0.06718244), (4, 0.13151406), (9, 0.5594854), (10, 0.09683411), (16, 0.13790752)]"
27108,,2022-06-27 14:11:51,2,65,"<p>Most of QKD protocols depends on performing measurements on different basis:</p>
<ul>
<li><p>Some performs the measurements on two basis (standard basis (Z) and the Hadamard basis (X)).</p>
</li>
<li><p>some performs the measurements  on three basis (x, y, and z)</p>
</li>
<li><p>some just perform the measurement on the standard basis (Z) and use other measures to secure the protocol</p>
</li>
</ul>
<p>Let us assume I am building the measurement device. <strong>My question</strong> is as follows:</p>
<p><strong>Is having a device that measures only on one basis  better in terms of cost?</strong></p>
<p>Is there any way to find the cost and complicity of building these devices?</p>
<p>Best,</p>
",Alternative measurements cost,<quantum-state><measurement>,0,3,,,"Alternative measurements cost <p>Most of QKD protocols depends on performing measurements on different basis:</p>
<ul>
<li><p>Some performs the measurements on two basis (standard basis (Z) and the Hadamard basis (X)).</p>
</li>
<li><p>some performs the measurements  on three basis (x, y, and z)</p>
</li>
<li><p>some just perform the measurement on the standard basis (Z) and use other measures to secure the protocol</p>
</li>
</ul>
<p>Let us assume I am building the measurement device. <strong>My question</strong> is as follows:</p>
<p><strong>Is having a device that measures only on one basis  better in terms of cost?</strong></p>
<p>Is there any way to find the cost and complicity of building these devices?</p>
<p>Best,</p>
",qc,alternative measurements cost p qkd protocols depends performing measurements different basis ul li p performs measurements two basis standard basis z hadamard basis x li p performs measurements three basis x z li p perform measurement standard basis z use measures secure protocol p let us assume building measurement device strong question follows p strong device measures one basis better terms cost p way find cost complicity building devices p best,"[(8, 0.2505179), (10, 0.033906013), (16, 0.033842485), (18, 0.67945385)]"
27113,,2022-06-28 04:36:53,0,369,"<p>In Chapter 8 of Nielsen and Chuang's Quantum Computation and Quantum Information, a mathematical framework is developed to provide a realization of the quantum operation <span class=""math-container"">$\mathcal{E}$</span> with operation elements <span class=""math-container"">$\{E_k\}$</span>. Here is a picture of a section <a href=""https://i.sstatic.net/7u75U.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7u75U.png"" alt=""enter image description here"" /></a></p>
<p>My question it's about how to construct a unitary operator for a system–environment model of a non-trace-preserving quantum operation, by introducing an extra operator, <span class=""math-container"">$E_\infty$</span>, such that when we introduce <span class=""math-container"">$k=\infty$</span> then we get <span class=""math-container"">$\sum_k E_k^{\dagger}E_k=I$</span>. I think is similar to the process in the picture but with the new element.</p>
",Quantum operation and non-trace-preserving,<quantum-operation>,0,2,,,"Quantum operation and non-trace-preserving <p>In Chapter 8 of Nielsen and Chuang's Quantum Computation and Quantum Information, a mathematical framework is developed to provide a realization of the quantum operation <span class=""math-container"">$\mathcal{E}$</span> with operation elements <span class=""math-container"">$\{E_k\}$</span>. Here is a picture of a section <a href=""https://i.sstatic.net/7u75U.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7u75U.png"" alt=""enter image description here"" /></a></p>
<p>My question it's about how to construct a unitary operator for a system–environment model of a non-trace-preserving quantum operation, by introducing an extra operator, <span class=""math-container"">$E_\infty$</span>, such that when we introduce <span class=""math-container"">$k=\infty$</span> then we get <span class=""math-container"">$\sum_k E_k^{\dagger}E_k=I$</span>. I think is similar to the process in the picture but with the new element.</p>
",qc,quantum operation p chapter 8 nielsen chuang quantum computation quantum information mathematical framework developed provide realization quantum operation span e operation elements span picture section https nofollow noreferrer img https enter image description p question construct unitary operator model quantum operation introducing extra operator span introduce span get span think similar process picture new,"[(3, 0.40104586), (4, 0.2514301), (6, 0.015434928), (8, 0.29019722), (16, 0.03912361)]"
27116,,2022-06-28 11:49:49,1,71,"<p>Is there any way to create a for loop that would send a few jobs to run on a quantum computer simultaneously? I tried:</p>
<pre><code>for i, entanglementor in enumerate(entanglement):
    print('\rentanglement: {}        '.format(entanglement[i]), end='')
    algorithm_globals.random_seed = 50
#ansatz = TwoLocal(rotation_blocks='ry', 
    entanglement_blocks='cz',entanglement=entanglement[i])
    form = EfficientSU2(num_qubits=2, entanglement=entanglement[i])
    #ansatz = RealAmplitudes(2, entanglement[i], reps=2, insert_barriers=True)
    optimizer = COBYLA(maxiter=5)
    counts = []
    values = []
    def store_intermediate_result(eval_count, parameters, mean, std):
    counts.append(eval_count)
    values.append(mean)

    vqe = VQE(form, optimizer, callback=store_intermediate_result,
          quantum_instance=QuantumInstance(backend=device))
    print(&quot;Running VQE algorithm on real hardware with device: &quot;, device)
    vqe.ansatz.draw()
    result = vqe.compute_minimum_eigenvalue(operator=H2_op)
    converge_cnts[i] = np.asarray(counts)
    converge_vals[i] = np.asarray(values)
    print('\rentanglement complete      ');
</code></pre>
<p>The problem is that this sends one job to the QC, and then waits until it gets a result before continuing the loop, which can obviously take quite a while. Is there a method to get the loop to continue while a job is queued?</p>
",How to send another job to a device before finishing the last job?,<ibm-q-experience><vqe>,0,5,,,"How to send another job to a device before finishing the last job? <p>Is there any way to create a for loop that would send a few jobs to run on a quantum computer simultaneously? I tried:</p>
<pre><code>for i, entanglementor in enumerate(entanglement):
    print('\rentanglement: {}        '.format(entanglement[i]), end='')
    algorithm_globals.random_seed = 50
#ansatz = TwoLocal(rotation_blocks='ry', 
    entanglement_blocks='cz',entanglement=entanglement[i])
    form = EfficientSU2(num_qubits=2, entanglement=entanglement[i])
    #ansatz = RealAmplitudes(2, entanglement[i], reps=2, insert_barriers=True)
    optimizer = COBYLA(maxiter=5)
    counts = []
    values = []
    def store_intermediate_result(eval_count, parameters, mean, std):
    counts.append(eval_count)
    values.append(mean)

    vqe = VQE(form, optimizer, callback=store_intermediate_result,
          quantum_instance=QuantumInstance(backend=device))
    print(&quot;Running VQE algorithm on real hardware with device: &quot;, device)
    vqe.ansatz.draw()
    result = vqe.compute_minimum_eigenvalue(operator=H2_op)
    converge_cnts[i] = np.asarray(counts)
    converge_vals[i] = np.asarray(values)
    print('\rentanglement complete      ');
</code></pre>
<p>The problem is that this sends one job to the QC, and then waits until it gets a result before continuing the loop, which can obviously take quite a while. Is there a method to get the loop to continue while a job is queued?</p>
",qc,send another job device finishing last job p way create loop would send jobs run quantum computer simultaneously tried pre code entanglementor enumerate entanglement print entanglement 50 ansatz twolocal form efficientsu2 ansatz realamplitudes 2 entanglement optimizer cobyla counts values def parameters mean std mean vqe vqe form optimizer print quot running vqe algorithm real hardware device quot device result counts values print complete p problem sends one job qc waits gets result continuing loop obviously take quite method get loop continue job queued,"[(0, 0.42235017), (1, 0.046476737), (14, 0.253493), (16, 0.038312145), (18, 0.18103306), (19, 0.056588646)]"
27186,,2022-07-04 05:28:59,2,38,"<p>No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively</p>
",No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively?,<no-cloning-theorem>,0,2,,,"No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively? <p>No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively</p>
",qc,clonning states one clone arbitrary given state device create superposition state repetatively p clonning states one clone arbitrary given state device create superposition state repetatively,"[(8, 0.1047484), (16, 0.082909115), (17, 0.08749123), (18, 0.71793354)]"
27314,,2022-07-12 21:00:37,2,105,"<p>I recently came across <a href=""https://arxiv.org/pdf/1807.07112.pdf"" rel=""nofollow noreferrer"">this paper</a> where the 1d Transverse Field Ising Model (TFIM) with <span class=""math-container"">$n$</span> spins was simulated on a quantum computer. The estimated resources were <span class=""math-container"">$n^2$</span> for the number of gates and the circuit depth was <span class=""math-container"">$n \log(n).$</span> Since the 1d TFIM is equivalent to the 2d Classical Ising Model (CIM) using transfer matrix methods (<a href=""https://phas.ubc.ca/%7Eberciu/TEACHING/PHYS503/PROJECTS/05_mandy.pdf"" rel=""nofollow noreferrer"">see here</a> or <a href=""http://web.mit.edu/8.334/www/grades/projects/projects12/TimHsieh.pdf"" rel=""nofollow noreferrer"">here</a>), I was wondering</p>
<blockquote>
<p>Would the estimated resources for the 2D CIM be the same as the TFIM?</p>
</blockquote>
<p>My intuition says we would need more gates since we have a 2D square lattice of size <span class=""math-container"">$n^2$</span> rather than <span class=""math-container"">$n$</span> spins in the TFIM chain. I'm not certain about the circuit depth however. I would really appreciate anyone's thought process here.</p>
",Qubit Resource Estimates for 2D Ising Model,<quantum-gate><quantum-state><circuit-construction><error-correction><noise>,0,2,,,"Qubit Resource Estimates for 2D Ising Model <p>I recently came across <a href=""https://arxiv.org/pdf/1807.07112.pdf"" rel=""nofollow noreferrer"">this paper</a> where the 1d Transverse Field Ising Model (TFIM) with <span class=""math-container"">$n$</span> spins was simulated on a quantum computer. The estimated resources were <span class=""math-container"">$n^2$</span> for the number of gates and the circuit depth was <span class=""math-container"">$n \log(n).$</span> Since the 1d TFIM is equivalent to the 2d Classical Ising Model (CIM) using transfer matrix methods (<a href=""https://phas.ubc.ca/%7Eberciu/TEACHING/PHYS503/PROJECTS/05_mandy.pdf"" rel=""nofollow noreferrer"">see here</a> or <a href=""http://web.mit.edu/8.334/www/grades/projects/projects12/TimHsieh.pdf"" rel=""nofollow noreferrer"">here</a>), I was wondering</p>
<blockquote>
<p>Would the estimated resources for the 2D CIM be the same as the TFIM?</p>
</blockquote>
<p>My intuition says we would need more gates since we have a 2D square lattice of size <span class=""math-container"">$n^2$</span> rather than <span class=""math-container"">$n$</span> spins in the TFIM chain. I'm not certain about the circuit depth however. I would really appreciate anyone's thought process here.</p>
",qc,qubit resource estimates 2d ising model p recently came across https nofollow noreferrer paper 1d transverse field ising model tfim span n spins simulated quantum computer estimated resources span number gates circuit depth span n n since 1d tfim equivalent 2d classical ising model cim using transfer matrix methods https nofollow noreferrer see http nofollow noreferrer wondering blockquote p would estimated resources 2d cim tfim p intuition says would need gates since 2d square lattice size span rather span n spins tfim chain certain circuit depth however would really appreciate anyone thought process,"[(1, 0.15905672), (3, 0.20542201), (4, 0.12739533), (8, 0.30614778), (9, 0.18864945), (16, 0.011722639)]"
27328,,2022-07-13 19:53:26,0,212,"<p>I am building a custom noise model using Qiskit's NoiseModel class. I want to incorporate full range of calibration data, say for 7 qubit machine. I am not sure how to incorporate calibration features like ['id', 'sx', 'rz', 'rx', 'x', 'reset'] errors besides readout lengths, frequency and anharmonicity into the custom noise model using the inbuilt functions in NoiseModel class. I am not sure under which category will the gate lengths and errors to add since there are:</p>
<ol>
<li>Quantum errors</li>
<li>Readout errors
that can be incorporated into NoiseModel class.
This link <a href=""https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html</a> does not mention how to incorporate frequency and anharmonicity in the NoiseModel object. Since I am new to the world of quantum computing, I do not understand how to use these errors below with regards to calibration data: 1. phase amplitude damping error 2. amplitude damping error 3. phase damping error 4. LocalNoisePass 5. RelaxationNoisePass</li>
</ol>
<p>My calibration data dictionary for 1 qubit is in the form</p>
<p>{'Anharmonicity-Q0': -0.3415,
'Frequency-Q0': 5157553795.720,
'Readout_Length-Q0': 6.7555e-07,
'T1-Q0': 206.1588,
'T2-Q0': 104.1353,
'sx0': 0.00015504,
'sx0_time': 35.5556}</p>
<p>Thanks</p>
",Adding Calibration Data For Noise Model,<qiskit><simulation><noise>,0,9,,,"Adding Calibration Data For Noise Model <p>I am building a custom noise model using Qiskit's NoiseModel class. I want to incorporate full range of calibration data, say for 7 qubit machine. I am not sure how to incorporate calibration features like ['id', 'sx', 'rz', 'rx', 'x', 'reset'] errors besides readout lengths, frequency and anharmonicity into the custom noise model using the inbuilt functions in NoiseModel class. I am not sure under which category will the gate lengths and errors to add since there are:</p>
<ol>
<li>Quantum errors</li>
<li>Readout errors
that can be incorporated into NoiseModel class.
This link <a href=""https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html</a> does not mention how to incorporate frequency and anharmonicity in the NoiseModel object. Since I am new to the world of quantum computing, I do not understand how to use these errors below with regards to calibration data: 1. phase amplitude damping error 2. amplitude damping error 3. phase damping error 4. LocalNoisePass 5. RelaxationNoisePass</li>
</ol>
<p>My calibration data dictionary for 1 qubit is in the form</p>
<p>{'Anharmonicity-Q0': -0.3415,
'Frequency-Q0': 5157553795.720,
'Readout_Length-Q0': 6.7555e-07,
'T1-Q0': 206.1588,
'T2-Q0': 104.1353,
'sx0': 0.00015504,
'sx0_time': 35.5556}</p>
<p>Thanks</p>
",qc,adding calibration data noise model p building custom noise model using qiskit noisemodel class want incorporate full range calibration data say 7 qubit machine sure incorporate calibration features like x errors besides readout lengths frequency anharmonicity custom noise model using inbuilt functions noisemodel class sure category gate lengths errors add since ol li quantum errors li readout errors incorporated noisemodel class link https nofollow noreferrer https mention incorporate frequency anharmonicity noisemodel object since new world quantum computing understand use errors regards calibration data phase amplitude damping error amplitude damping error phase damping error localnoisepass relaxationnoisepass p calibration data dictionary 1 qubit form p p thanks,"[(4, 0.105989605), (5, 0.12108332), (6, 0.014730154), (8, 0.29586214), (14, 0.39756063), (16, 0.054660372)]"
27375,27378.0,2022-07-18 16:14:01,0,288,"<p>I am trying to generate a random quantum circuit with 5 qubits using only CNOT gates. I have modified the source code of the qiskit.circuit.random.random_circuit function to only include CNOT gates (Making <code>num_operands = 2</code> and <code>two_q_ops = [CXGate]</code>) but I am getting an error. My code is as follows -</p>
<pre><code>def random_circuit(num_qubits, depth, max_operands=3, measure=False, conditional=False, reset=False, seed=None):

    if max_operands &lt; 1 or max_operands &gt; 3:
        raise CircuitError(&quot;max_operands must be between 1 and 3&quot;)

    one_q_ops = [IGate, U1Gate, U2Gate, U3Gate, XGate, YGate, ZGate, HGate, SGate, SdgGate, TGate, TdgGate, RXGate, RYGate, RZGate]
    one_param = [U1Gate, RXGate, RYGate, RZGate, RZZGate, CU1Gate, CRZGate]
    two_param = [U2Gate]
    three_param = [U3Gate, CU3Gate]
    two_q_ops = [CXGate]
    three_q_ops = [CCXGate, CSwapGate]

    qr = QuantumRegister(num_qubits, &quot;q&quot;)
    qc = QuantumCircuit(num_qubits)

    if measure or conditional:
        cr = ClassicalRegister(num_qubits, &quot;c&quot;)
        qc.add_register(cr)

    if reset:
        one_q_ops += [Reset]

    if seed is None:
        seed = np.random.randint(0, np.iinfo(np.int32).max)
    rng = np.random.default_rng(seed)

    # apply arbitrary random operations at every depth
    for _ in range(depth):
        # choose either 1, 2, or 3 qubits for the operation
        remaining_qubits = list(range(num_qubits))
        rng.shuffle(remaining_qubits)
        while remaining_qubits:
            max_possible_operands = min(len(remaining_qubits), max_operands)
            num_operands = 2
            operands = [remaining_qubits.pop() for _ in range(num_operands)]
            if num_operands == 1:
                operation = rng.choice(one_q_ops)
            elif num_operands == 2:
                operation = rng.choice(two_q_ops)
            elif num_operands == 3:
                operation = rng.choice(three_q_ops)
            if operation in one_param:
                num_angles = 1
            elif operation in two_param:
                num_angles = 2
            elif operation in three_param:
                num_angles = 3
            else:
                num_angles = 0
            angles = [rng.uniform(0, 2 * np.pi) for x in range(num_angles)]
            register_operands = [qr[i] for i in operands]
            op = operation(*angles)

            # with some low probability, condition on classical bit values
            if conditional and rng.choice(range(10)) == 0:
                value = rng.integers(0, np.power(2, num_qubits))
                op.condition = (cr, value)

            qc.append(op, register_operands)

    if measure:
        qc.measure(qr, cr)

    return qc

qc = random_circuit(num_qubits = 5, depth = 10)
</code></pre>
<p>The error that is thrown up is -</p>
<pre><code>~\AppData\Local\Temp/ipykernel_1268/4128137234.py in &lt;module&gt;
----&gt; 1 qc = random_circuit(num_qubits = 5, depth = 10)
      2 qc.draw(output='mpl')

~\AppData\Local\Temp/ipykernel_1268/430653575.py in random_circuit(num_qubits, depth, max_operands, measure, conditional, reset, seed)
     49             max_possible_operands = min(len(remaining_qubits), max_operands)
     50             num_operands = 2
---&gt; 51             operands = [remaining_qubits.pop() for _ in range(num_operands)]
     52             if num_operands == 1:
     53                 operation = rng.choice(one_q_ops)

~\AppData\Local\Temp/ipykernel_1268/430653575.py in &lt;listcomp&gt;(.0)
     49             max_possible_operands = min(len(remaining_qubits), max_operands)
     50             num_operands = 2
---&gt; 51             operands = [remaining_qubits.pop() for _ in range(num_operands)]
     52             if num_operands == 1:
     53                 operation = rng.choice(one_q_ops)

IndexError: pop from empty list
</code></pre>
<p>This error does not occur when I try the same code for 4 qubits. What can I change so that it works for 5 qubits as well?</p>
",Generating random circuits with only CNOT gates using qiskit.circuit.random.random_circuit,<qiskit><quantum-circuit><random-quantum-circuit>,1,0,,,"Generating random circuits with only CNOT gates using qiskit.circuit.random.random_circuit <p>I am trying to generate a random quantum circuit with 5 qubits using only CNOT gates. I have modified the source code of the qiskit.circuit.random.random_circuit function to only include CNOT gates (Making <code>num_operands = 2</code> and <code>two_q_ops = [CXGate]</code>) but I am getting an error. My code is as follows -</p>
<pre><code>def random_circuit(num_qubits, depth, max_operands=3, measure=False, conditional=False, reset=False, seed=None):

    if max_operands &lt; 1 or max_operands &gt; 3:
        raise CircuitError(&quot;max_operands must be between 1 and 3&quot;)

    one_q_ops = [IGate, U1Gate, U2Gate, U3Gate, XGate, YGate, ZGate, HGate, SGate, SdgGate, TGate, TdgGate, RXGate, RYGate, RZGate]
    one_param = [U1Gate, RXGate, RYGate, RZGate, RZZGate, CU1Gate, CRZGate]
    two_param = [U2Gate]
    three_param = [U3Gate, CU3Gate]
    two_q_ops = [CXGate]
    three_q_ops = [CCXGate, CSwapGate]

    qr = QuantumRegister(num_qubits, &quot;q&quot;)
    qc = QuantumCircuit(num_qubits)

    if measure or conditional:
        cr = ClassicalRegister(num_qubits, &quot;c&quot;)
        qc.add_register(cr)

    if reset:
        one_q_ops += [Reset]

    if seed is None:
        seed = np.random.randint(0, np.iinfo(np.int32).max)
    rng = np.random.default_rng(seed)

    # apply arbitrary random operations at every depth
    for _ in range(depth):
        # choose either 1, 2, or 3 qubits for the operation
        remaining_qubits = list(range(num_qubits))
        rng.shuffle(remaining_qubits)
        while remaining_qubits:
            max_possible_operands = min(len(remaining_qubits), max_operands)
            num_operands = 2
            operands = [remaining_qubits.pop() for _ in range(num_operands)]
            if num_operands == 1:
                operation = rng.choice(one_q_ops)
            elif num_operands == 2:
                operation = rng.choice(two_q_ops)
            elif num_operands == 3:
                operation = rng.choice(three_q_ops)
            if operation in one_param:
                num_angles = 1
            elif operation in two_param:
                num_angles = 2
            elif operation in three_param:
                num_angles = 3
            else:
                num_angles = 0
            angles = [rng.uniform(0, 2 * np.pi) for x in range(num_angles)]
            register_operands = [qr[i] for i in operands]
            op = operation(*angles)

            # with some low probability, condition on classical bit values
            if conditional and rng.choice(range(10)) == 0:
                value = rng.integers(0, np.power(2, num_qubits))
                op.condition = (cr, value)

            qc.append(op, register_operands)

    if measure:
        qc.measure(qr, cr)

    return qc

qc = random_circuit(num_qubits = 5, depth = 10)
</code></pre>
<p>The error that is thrown up is -</p>
<pre><code>~\AppData\Local\Temp/ipykernel_1268/4128137234.py in &lt;module&gt;
----&gt; 1 qc = random_circuit(num_qubits = 5, depth = 10)
      2 qc.draw(output='mpl')

~\AppData\Local\Temp/ipykernel_1268/430653575.py in random_circuit(num_qubits, depth, max_operands, measure, conditional, reset, seed)
     49             max_possible_operands = min(len(remaining_qubits), max_operands)
     50             num_operands = 2
---&gt; 51             operands = [remaining_qubits.pop() for _ in range(num_operands)]
     52             if num_operands == 1:
     53                 operation = rng.choice(one_q_ops)

~\AppData\Local\Temp/ipykernel_1268/430653575.py in &lt;listcomp&gt;(.0)
     49             max_possible_operands = min(len(remaining_qubits), max_operands)
     50             num_operands = 2
---&gt; 51             operands = [remaining_qubits.pop() for _ in range(num_operands)]
     52             if num_operands == 1:
     53                 operation = rng.choice(one_q_ops)

IndexError: pop from empty list
</code></pre>
<p>This error does not occur when I try the same code for 4 qubits. What can I change so that it works for 5 qubits as well?</p>
",qc,generating random circuits cnot gates using p trying generate random quantum circuit 5 qubits using cnot gates modified source code function include cnot gates making code 2 code cxgate getting error code follows pre code def depth lt 1 gt 3 raise circuiterror quot must 1 3 quot igate u1gate u2gate u3gate xgate ygate zgate hgate sgate sdggate tgate tdggate rxgate rygate rzgate u1gate rxgate rygate rzgate rzzgate cu1gate crzgate u2gate u3gate cu3gate cxgate ccxgate cswapgate qr quantumregister quot q quot qc quantumcircuit measure conditional cr classicalregister quot c quot cr reset reset seed none seed 0 rng seed apply arbitrary random operations every depth range depth choose either 1 2 3 qubits operation list range min len 2 operands range 1 operation elif 2 operation elif 3 operation operation 1 elif operation 2 elif operation 3 else 0 angles 0 2 x range qr operands op operation angles low probability condition classical bit values conditional range 10 0 value 0 2 cr value op measure qr cr return qc qc 5 depth 10 p error thrown pre code lt module gt gt 1 qc 5 depth 10 2 depth measure conditional reset seed 49 min len 50 2 gt 51 operands range 52 1 53 operation lt listcomp gt 49 min len 50 2 gt 51 operands range 52 1 53 operation indexerror pop empty list p error occur try code 4 qubits change works 5 qubits well,"[(0, 0.48362595), (2, 0.10237854), (6, 0.04983991), (9, 0.016356342), (13, 0.012943108), (14, 0.23080386), (15, 0.019772032), (16, 0.028268581), (18, 0.0286705), (19, 0.026896331)]"
27424,27427.0,2022-07-21 06:06:22,2,290,"<p>Mathematically, our qubits (pure quantum states) can be represented as a normalized vector (of length 1) in a complex Hilbert space.</p>
<p>is it because of the sum of squares of vertical and horizontal component of a circle with unit radius is always 1 and so is the sum of probabilities of qubit collapsing in either of basis state?</p>
<p><a href=""https://i.sstatic.net/OPOjA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/OPOjA.png"" alt=""enter image description here"" /></a></p>
",Why are qubits represent as unit vectors in an Hilbert space?,<quantum-state><textbook-and-exercises>,1,0,,,"Why are qubits represent as unit vectors in an Hilbert space? <p>Mathematically, our qubits (pure quantum states) can be represented as a normalized vector (of length 1) in a complex Hilbert space.</p>
<p>is it because of the sum of squares of vertical and horizontal component of a circle with unit radius is always 1 and so is the sum of probabilities of qubit collapsing in either of basis state?</p>
<p><a href=""https://i.sstatic.net/OPOjA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/OPOjA.png"" alt=""enter image description here"" /></a></p>
",qc,qubits represent unit vectors hilbert space p mathematically qubits pure quantum states represented normalized vector length 1 complex hilbert p sum squares vertical horizontal component circle unit radius always 1 sum probabilities qubit collapsing either basis state p https nofollow noreferrer img https enter image description,"[(3, 0.4249844), (4, 0.24746737), (13, 0.082368106), (16, 0.039267346), (18, 0.20266314)]"
27444,,2022-07-22 17:21:06,1,49,"<p>I need to use the noise model coming from a large IBM device. Nonetheless, I do not need to use the whole Noise Model. I only need the information of let's say qubits [10:15] and [20:25]. That would be, I only need the noise model information of those 10 qubits. Then, I need to use that reduced noise model into my own simulated device that consists of only 10 qubits. So all in all, I need to copy the noise model from IBM device qubits [10:15], [20:25] and use it in my own devices [0:10] qubits</p>
<p>What I was trying to do was to export the noise model using <code>NoiseModel.to_dict()</code>, modifying that dictionary properly and then using the <code>NoiseModel.from_dict()</code> function. The problem is that <code>from_dict()</code> function is deprecated. I don't have any ideas on how to circumvent the problem.</p>
",Copying a reduced noise model from an IBM device,<qiskit><ibm-q-experience><noise>,0,0,,,"Copying a reduced noise model from an IBM device <p>I need to use the noise model coming from a large IBM device. Nonetheless, I do not need to use the whole Noise Model. I only need the information of let's say qubits [10:15] and [20:25]. That would be, I only need the noise model information of those 10 qubits. Then, I need to use that reduced noise model into my own simulated device that consists of only 10 qubits. So all in all, I need to copy the noise model from IBM device qubits [10:15], [20:25] and use it in my own devices [0:10] qubits</p>
<p>What I was trying to do was to export the noise model using <code>NoiseModel.to_dict()</code>, modifying that dictionary properly and then using the <code>NoiseModel.from_dict()</code> function. The problem is that <code>from_dict()</code> function is deprecated. I don't have any ideas on how to circumvent the problem.</p>
",qc,copying reduced noise model ibm device p need use noise model coming large ibm device nonetheless need use whole noise model need information let say qubits would need noise model information 10 qubits need use reduced noise model simulated device consists 10 qubits need copy noise model ibm device qubits use devices qubits p trying export noise model using code modifying dictionary properly using code function problem code function deprecated ideas circumvent,"[(9, 0.065116234), (14, 0.87695044), (16, 0.055543844)]"
27458,27459.0,2022-07-25 05:41:21,3,185,"<p>I was trying to find a reference for the 7 T-gate decomposition of the Toffoli gate given by Cirq. The decomposition originates from the the one used for CCZPowGate as given in the doc string here</p>
<p><a href=""https://github.com/quantumlib/Cirq/blob/master/cirq-core/cirq/ops/three_qubit_gates.py#L100"" rel=""nofollow noreferrer"">https://github.com/quantumlib/Cirq/blob/master/cirq-core/cirq/ops/three_qubit_gates.py#L100</a></p>
<p>This is mentioned as an adjacency respecting decomposition by which I understand that the CNOTs are nearest neighbour</p>
<p>Most of the literature I have seen on Toffoli gate decompositions seem to use long range CNOTs for example in Neilson and Chuang or here</p>
<p><a href=""https://arxiv.org/abs/2101.04764"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2101.04764</a> .</p>
<p>Does anyone have an idea about the source of the decomposition used?</p>
",Cirq : Reference for Toffoli decomposition,<gate-synthesis><cirq>,1,0,,,"Cirq : Reference for Toffoli decomposition <p>I was trying to find a reference for the 7 T-gate decomposition of the Toffoli gate given by Cirq. The decomposition originates from the the one used for CCZPowGate as given in the doc string here</p>
<p><a href=""https://github.com/quantumlib/Cirq/blob/master/cirq-core/cirq/ops/three_qubit_gates.py#L100"" rel=""nofollow noreferrer"">https://github.com/quantumlib/Cirq/blob/master/cirq-core/cirq/ops/three_qubit_gates.py#L100</a></p>
<p>This is mentioned as an adjacency respecting decomposition by which I understand that the CNOTs are nearest neighbour</p>
<p>Most of the literature I have seen on Toffoli gate decompositions seem to use long range CNOTs for example in Neilson and Chuang or here</p>
<p><a href=""https://arxiv.org/abs/2101.04764"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2101.04764</a> .</p>
<p>Does anyone have an idea about the source of the decomposition used?</p>
",qc,cirq reference toffoli decomposition p trying find reference 7 decomposition toffoli gate given cirq decomposition originates one used cczpowgate given doc string p https l100 nofollow noreferrer https l100 p mentioned adjacency respecting decomposition understand cnots nearest neighbour p literature seen toffoli gate decompositions seem use long range cnots example neilson chuang p https nofollow noreferrer https p anyone idea source decomposition used,"[(3, 0.088872865), (4, 0.2477127), (6, 0.01802394), (7, 0.20114538), (9, 0.3402841), (13, 0.06712367), (16, 0.03460207)]"
27494,27503.0,2022-07-27 08:49:56,0,323,"<blockquote>
<p>Nielsen&amp;Chuang Exercise2.65: Express the states (|0 + |1)/
√
2 and (|0−|1)/
√
2 in a basis in
which they are not the same up to a relative phase shift.</p>
</blockquote>
<p>Consider an orthnormal basis :<span class=""math-container"">$\begin{cases}|w_1\rangle=\sqrt{\frac23}|0\rangle+\sqrt{\frac13}|1\rangle\\|w_2\rangle=\sqrt{\frac13}|0\rangle-\sqrt{\frac23}|1\rangle\end{cases}$</span></p>
<p>In this basis, the states can be expressed as:<span class=""math-container"">$\begin{cases}\frac{|0\rangle+|1\rangle}{\sqrt2}=\frac{\sqrt2+1}{\sqrt6}[|w_1\rangle-(1-\sqrt2)^2|w_2\rangle]\\\frac{|0\rangle-|1\rangle}{\sqrt2}=\frac{\sqrt2-1}{\sqrt6}[|w_1\rangle+(1+\sqrt2)^2|w_2\rangle]\end{cases}$</span></p>
<p>It's easy to verify that <span class=""math-container"">$|\frac{\frac{\sqrt2+1}{\sqrt6}}{\frac{\sqrt2-1}{\sqrt6}}|\neq1$</span>.  But in the Nielsen &amp; Chuang, it says that:</p>
<blockquote>
<p>we say that two amplitudes, a and b, differ by a relative phase if
there is a real θ such that a = exp(iθ)b.</p>
</blockquote>
<p>so clearly the amplitudes must satisfy the equation: <span class=""math-container"">$|\frac{a}b|=|\exp(i\theta)|=1$</span>. So <span class=""math-container"">$|\frac{\frac{\sqrt2+1}{\sqrt6}}{\frac{\sqrt2-1}{\sqrt6}}|\neq1$</span> violates this equation. The question is that can we say in this basis <span class=""math-container"">$|w_1\rangle,\ |w_2\rangle$</span>, these two states are not the same up to a relative phase shift? What's more, if it is true, is my proof right? Additonally, could you please explain the phrase 'up to a relative phase shift' explicitly? I have difficulty grasping this.</p>
",What is the solution to Nielsen and Chuang Exercise 2.65?,<quantum-state><textbook-and-exercises><nielsen-and-chuang>,1,0,,,"What is the solution to Nielsen and Chuang Exercise 2.65? <blockquote>
<p>Nielsen&amp;Chuang Exercise2.65: Express the states (|0 + |1)/
√
2 and (|0−|1)/
√
2 in a basis in
which they are not the same up to a relative phase shift.</p>
</blockquote>
<p>Consider an orthnormal basis :<span class=""math-container"">$\begin{cases}|w_1\rangle=\sqrt{\frac23}|0\rangle+\sqrt{\frac13}|1\rangle\\|w_2\rangle=\sqrt{\frac13}|0\rangle-\sqrt{\frac23}|1\rangle\end{cases}$</span></p>
<p>In this basis, the states can be expressed as:<span class=""math-container"">$\begin{cases}\frac{|0\rangle+|1\rangle}{\sqrt2}=\frac{\sqrt2+1}{\sqrt6}[|w_1\rangle-(1-\sqrt2)^2|w_2\rangle]\\\frac{|0\rangle-|1\rangle}{\sqrt2}=\frac{\sqrt2-1}{\sqrt6}[|w_1\rangle+(1+\sqrt2)^2|w_2\rangle]\end{cases}$</span></p>
<p>It's easy to verify that <span class=""math-container"">$|\frac{\frac{\sqrt2+1}{\sqrt6}}{\frac{\sqrt2-1}{\sqrt6}}|\neq1$</span>.  But in the Nielsen &amp; Chuang, it says that:</p>
<blockquote>
<p>we say that two amplitudes, a and b, differ by a relative phase if
there is a real θ such that a = exp(iθ)b.</p>
</blockquote>
<p>so clearly the amplitudes must satisfy the equation: <span class=""math-container"">$|\frac{a}b|=|\exp(i\theta)|=1$</span>. So <span class=""math-container"">$|\frac{\frac{\sqrt2+1}{\sqrt6}}{\frac{\sqrt2-1}{\sqrt6}}|\neq1$</span> violates this equation. The question is that can we say in this basis <span class=""math-container"">$|w_1\rangle,\ |w_2\rangle$</span>, these two states are not the same up to a relative phase shift? What's more, if it is true, is my proof right? Additonally, could you please explain the phrase 'up to a relative phase shift' explicitly? I have difficulty grasping this.</p>
",qc,solution nielsen chuang exercise blockquote p nielsen amp chuang express states 2 2 basis relative phase p consider orthnormal basis span cases cases p basis states expressed span cases cases p easy verify span nielsen amp chuang says blockquote p say two amplitudes b differ relative phase real θ exp iθ p clearly amplitudes must satisfy equation span span violates equation question say basis span two states relative phase shift true proof right additonally could please explain phrase relative phase shift explicitly difficulty grasping,"[(3, 0.8742556), (7, 0.032680027), (9, 0.04395381), (15, 0.033326205), (16, 0.01391345)]"
27496,27497.0,2022-07-27 11:41:54,4,595,"<p>When I try to draw the quantum circuit it is shown in only one block and not the whole circuit. For example using the code:</p>
<pre><code>from qiskit.circuit.library import RealAmplitudes
ansatz = RealAmplitudes(3, reps=2)
print(ansatz)
</code></pre>
<p>This code only shows the circuit as one block as follows:</p>
<pre><code>     ┌───────────────────────────────────────────────────────────────┐
q_0: ┤0                                                              ├
     │                                                               │
q_1: ┤1 RealAmplitudes(θ[0],θ[1],θ[2],θ[3],θ[4],θ[5],θ[6],θ[7],θ[8]) ├
     │                                                               │
q_2: ┤2                                                              ├
     └───────────────────────────────────────────────────────────────┘
</code></pre>
<p>Do you know how to show the whole circuit with the details of the gates instead?</p>
",Ansatz printing in Qiskit draws a single block,<qiskit><quantum-algorithms><quantum-circuit>,1,0,,,"Ansatz printing in Qiskit draws a single block <p>When I try to draw the quantum circuit it is shown in only one block and not the whole circuit. For example using the code:</p>
<pre><code>from qiskit.circuit.library import RealAmplitudes
ansatz = RealAmplitudes(3, reps=2)
print(ansatz)
</code></pre>
<p>This code only shows the circuit as one block as follows:</p>
<pre><code>     ┌───────────────────────────────────────────────────────────────┐
q_0: ┤0                                                              ├
     │                                                               │
q_1: ┤1 RealAmplitudes(θ[0],θ[1],θ[2],θ[3],θ[4],θ[5],θ[6],θ[7],θ[8]) ├
     │                                                               │
q_2: ┤2                                                              ├
     └───────────────────────────────────────────────────────────────┘
</code></pre>
<p>Do you know how to show the whole circuit with the details of the gates instead?</p>
",qc,ansatz printing qiskit draws single block p try draw quantum circuit shown one block whole circuit example using code pre code import realamplitudes ansatz realamplitudes 3 print ansatz p code shows circuit one block follows pre code realamplitudes θ 0 θ 1 θ 2 θ 3 θ 4 θ 5 θ 6 θ 7 θ 8 p know show whole circuit details gates instead,"[(0, 0.2358413), (4, 0.08477467), (6, 0.15219949), (14, 0.37943527), (16, 0.1454119)]"
27516,,2022-07-28 09:50:50,1,19,"<p>In cirq we have</p>
<blockquote>
<p>calibration = service.get_current_calibration()<br/></p>
</blockquote>
<p>which gives the current calibration of the QPU. How to obtain the same on Azure Quantum ?</p>
",Obtaining device calibration on Azure Quantum,<hardware><azure-quantum>,0,0,,,"Obtaining device calibration on Azure Quantum <p>In cirq we have</p>
<blockquote>
<p>calibration = service.get_current_calibration()<br/></p>
</blockquote>
<p>which gives the current calibration of the QPU. How to obtain the same on Azure Quantum ?</p>
",qc,obtaining device calibration azure quantum p cirq blockquote p calibration p gives current calibration qpu obtain azure quantum,"[(8, 0.31158325), (14, 0.41419148), (16, 0.26488212)]"
27535,27541.0,2022-07-29 23:27:03,1,305,"<p>I apologize in advance for any mistakes as I am new to this field and come from a programming, rather than mathematical/physical background.</p>
<p>I am looking for a way to decompose a given operator <span class=""math-container"">$U$</span> into <span class=""math-container"">$ZYZ$</span> rotations. After searching on the internet, I wrote this Julia function to perform this operation (<code>V[1, 1]</code> represents <span class=""math-container"">$V_{11}$</span>, etc.):</p>
<pre><code>decompose(U::Matrix{ComplexF64}) = begin
    α = atan(imag(det(U)),real(det(U)))/2
    V = exp(-im*α)*U
    θ₁ = magnitude(V[1, 1])≥magnitude(V[1, 2]) ? 2*acos(magnitude(V[1, 1])) : 2*asin(magnitude(V[1, 2]))
    if cos(θ₁/2) == 0
        θ₀ = atan(imag(V[2, 1]/sin(θ₁/2)), real(mag(V[2, 1]/sin(θ₁/2))))
        θ₀ = -θ₂
    elseif sin(θ₁/2) == 0
        θ₀ = atan(imag(V[2, 2]/cos(θ₁/2)), real(V[2, 2]/cos(θ₁/2)))
        θ₂ = θ₀
    else
        θ₀ = atan(imag(V[2, 2]/cos(θ₁/2)), real(V[2, 2]/cos(θ₁/2)))+atan(imag(V[2, 1]/sin(θ₁/2)), real(V[2, 1]/sin(θ₁/2)))
        θ₂ = 2*atan(imag(V[2, 2]/cos(θ₁/2)), real(V[2, 2]/cos(θ₁/2)))-θ₀
    end
    return α, θ₀, θ₁, θ₂
end
</code></pre>
<p>I then plug these values back into <span class=""math-container"">$e^{i*\alpha}*R_z(\theta_0)*R_y(\theta_1)*R_z(\theta_2)$</span>, to 'recompose' the gate and check if the gate decomposed correctly. Here is the compose function for reference:</p>
<pre><code>R_x(θ) = [cos(θ/2) -im*sin(θ/2); -im*sin(θ/2) cos(θ/2)]
R_y(θ) = [cos(θ/2) -sin(θ/2); sin(θ/2) cos(θ/2)]
R_z(θ) = [exp(-im*θ/2) 0; 0 exp(im*θ/2)]
compose(α, θ₀, θ₁, θ₂) = exp(im*α)*R_z(θ₀)*R_y(θ₁)*R_z(θ₂)
</code></pre>
<p>This seems to work for the Hadamard, Pauli-X, and Pauli-Z gates when I test it, but when I test it for S, T, and Pauli-Y gates, it does not seem to work.</p>
<p>For S, I expect <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; i\end{bmatrix}$</span>, but I receive <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}$</span>.</p>
<p>For T, I expect <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; \frac{\sqrt{2}}{2}+\frac{\sqrt{2}}{2}i\end{bmatrix}$</span>, but I receive <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; \sqrt{2}\end{bmatrix}$</span>.</p>
<p>For Pauli-Y, I expect <span class=""math-container"">$\begin{bmatrix}0 &amp; -i \\ i &amp; 0\end{bmatrix}$</span>, but I receive <span class=""math-container"">$\begin{bmatrix}0 &amp; -1 \\ 1 &amp; 0\end{bmatrix}$</span>.</p>
<p>It seems that the 'recomposed' gate has the values of the original gate written as <span class=""math-container"">$\Re(z)+\Im(z)$</span> instead of <span class=""math-container"">$\Re(z)+\Im(z)i$</span>. Does this make any difference functionally or are the gates still equivalent? If there is a difference, is it possible to decompose the original gate and then compose it once again while retaining the complex values?</p>
",Decomposition of unitary operator into rotations around Bloch sphere,<quantum-gate><textbook-and-exercises><gate-synthesis>,1,0,,,"Decomposition of unitary operator into rotations around Bloch sphere <p>I apologize in advance for any mistakes as I am new to this field and come from a programming, rather than mathematical/physical background.</p>
<p>I am looking for a way to decompose a given operator <span class=""math-container"">$U$</span> into <span class=""math-container"">$ZYZ$</span> rotations. After searching on the internet, I wrote this Julia function to perform this operation (<code>V[1, 1]</code> represents <span class=""math-container"">$V_{11}$</span>, etc.):</p>
<pre><code>decompose(U::Matrix{ComplexF64}) = begin
    α = atan(imag(det(U)),real(det(U)))/2
    V = exp(-im*α)*U
    θ₁ = magnitude(V[1, 1])≥magnitude(V[1, 2]) ? 2*acos(magnitude(V[1, 1])) : 2*asin(magnitude(V[1, 2]))
    if cos(θ₁/2) == 0
        θ₀ = atan(imag(V[2, 1]/sin(θ₁/2)), real(mag(V[2, 1]/sin(θ₁/2))))
        θ₀ = -θ₂
    elseif sin(θ₁/2) == 0
        θ₀ = atan(imag(V[2, 2]/cos(θ₁/2)), real(V[2, 2]/cos(θ₁/2)))
        θ₂ = θ₀
    else
        θ₀ = atan(imag(V[2, 2]/cos(θ₁/2)), real(V[2, 2]/cos(θ₁/2)))+atan(imag(V[2, 1]/sin(θ₁/2)), real(V[2, 1]/sin(θ₁/2)))
        θ₂ = 2*atan(imag(V[2, 2]/cos(θ₁/2)), real(V[2, 2]/cos(θ₁/2)))-θ₀
    end
    return α, θ₀, θ₁, θ₂
end
</code></pre>
<p>I then plug these values back into <span class=""math-container"">$e^{i*\alpha}*R_z(\theta_0)*R_y(\theta_1)*R_z(\theta_2)$</span>, to 'recompose' the gate and check if the gate decomposed correctly. Here is the compose function for reference:</p>
<pre><code>R_x(θ) = [cos(θ/2) -im*sin(θ/2); -im*sin(θ/2) cos(θ/2)]
R_y(θ) = [cos(θ/2) -sin(θ/2); sin(θ/2) cos(θ/2)]
R_z(θ) = [exp(-im*θ/2) 0; 0 exp(im*θ/2)]
compose(α, θ₀, θ₁, θ₂) = exp(im*α)*R_z(θ₀)*R_y(θ₁)*R_z(θ₂)
</code></pre>
<p>This seems to work for the Hadamard, Pauli-X, and Pauli-Z gates when I test it, but when I test it for S, T, and Pauli-Y gates, it does not seem to work.</p>
<p>For S, I expect <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; i\end{bmatrix}$</span>, but I receive <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}$</span>.</p>
<p>For T, I expect <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; \frac{\sqrt{2}}{2}+\frac{\sqrt{2}}{2}i\end{bmatrix}$</span>, but I receive <span class=""math-container"">$\begin{bmatrix}1 &amp; 0 \\ 0 &amp; \sqrt{2}\end{bmatrix}$</span>.</p>
<p>For Pauli-Y, I expect <span class=""math-container"">$\begin{bmatrix}0 &amp; -i \\ i &amp; 0\end{bmatrix}$</span>, but I receive <span class=""math-container"">$\begin{bmatrix}0 &amp; -1 \\ 1 &amp; 0\end{bmatrix}$</span>.</p>
<p>It seems that the 'recomposed' gate has the values of the original gate written as <span class=""math-container"">$\Re(z)+\Im(z)$</span> instead of <span class=""math-container"">$\Re(z)+\Im(z)i$</span>. Does this make any difference functionally or are the gates still equivalent? If there is a difference, is it possible to decompose the original gate and then compose it once again while retaining the complex values?</p>
",qc,decomposition unitary operator rotations around bloch sphere p apologize advance mistakes new field come programming rather p looking way decompose given operator span u span zyz rotations searching internet wrote julia function perform operation code v 1 1 represents span 11 etc pre code decompose u complexf64 begin α atan imag det u real det u v exp α u θ₁ magnitude v 1 1 v 1 2 2 acos magnitude v 1 1 2 asin magnitude v 1 2 cos 0 θ₀ atan imag v 2 1 real mag v 2 1 θ₀ elseif sin 0 θ₀ atan imag v 2 2 real v 2 2 θ₂ θ₀ else θ₀ atan imag v 2 2 real v 2 2 imag v 2 1 real v 2 1 θ₂ 2 atan imag v 2 2 real v 2 2 end return α θ₀ θ₁ θ₂ end p plug values back span gate check gate decomposed correctly compose function reference pre code θ cos sin sin cos θ cos sin cos θ exp 0 0 exp im compose α θ₀ θ₁ θ₂ exp im α θ₀ θ₁ θ₂ p seems work hadamard gates test test gates seem p expect span bmatrix 1 amp 0 0 amp bmatrix receive span bmatrix 1 amp 0 0 amp bmatrix p expect span bmatrix 1 amp 0 0 amp 2 2 2 2 bmatrix receive span bmatrix 1 amp 0 0 amp 2 bmatrix p expect span bmatrix 0 amp amp bmatrix receive span bmatrix 0 amp 1 amp bmatrix p seems gate values original gate written span z z instead span z z make difference functionally gates still equivalent difference possible decompose original gate compose retaining complex values,"[(2, 0.3435929), (3, 0.22015278), (7, 0.041772164), (8, 0.039568413), (14, 0.16727586), (15, 0.15710717), (16, 0.013511797)]"
27596,,2022-08-02 20:10:25,0,115,"<p>I am new in IBM composer quantum and I have a doubt.</p>
<p>I have the next circuit</p>
<p><a href=""https://i.sstatic.net/zyy4g.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zyy4g.jpg"" alt=""enter image description here"" /></a></p>
<p>After reinitializing q0 and reading it. (breaking entanglement) The phase disk for qubit q1 says that 100% is 0, but the result when I run it in a simulator is 521 00 and 503 10. The qubit q1 is in a rare indeterminate state, so that if I wanted execute some gate to take it to 0 or 1 (without restarting it) I can't do it. (or I don't know how to do it). and to test something I have to necessarily run in a simulator because what the phase disk says is not true.
Is there something I am doing wrong? Is there a way I'm not aware of to bring q1 to 1 without resetting it?`</p>
<p>Thanks.</p>
",Why after breaking the entanglement does the phase disk in the second qbit not match the result?,<quantum-state><ibm-q-experience><entanglement><measurement><quantum-circuit>,2,2,,,"Why after breaking the entanglement does the phase disk in the second qbit not match the result? <p>I am new in IBM composer quantum and I have a doubt.</p>
<p>I have the next circuit</p>
<p><a href=""https://i.sstatic.net/zyy4g.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zyy4g.jpg"" alt=""enter image description here"" /></a></p>
<p>After reinitializing q0 and reading it. (breaking entanglement) The phase disk for qubit q1 says that 100% is 0, but the result when I run it in a simulator is 521 00 and 503 10. The qubit q1 is in a rare indeterminate state, so that if I wanted execute some gate to take it to 0 or 1 (without restarting it) I can't do it. (or I don't know how to do it). and to test something I have to necessarily run in a simulator because what the phase disk says is not true.
Is there something I am doing wrong? Is there a way I'm not aware of to bring q1 to 1 without resetting it?`</p>
<p>Thanks.</p>
",qc,breaking entanglement phase disk second qbit match result p new ibm composer quantum p next circuit p https nofollow noreferrer img https enter image description p reinitializing q0 reading breaking entanglement phase disk qubit q1 says 100 0 result run simulator 521 00 503 qubit q1 rare indeterminate state wanted execute gate take 0 1 without restarting ca know test something necessarily run simulator phase disk says true something wrong way aware bring q1 1 without resetting p,"[(0, 0.07538243), (2, 0.055591144), (3, 0.046109717), (4, 0.22173488), (13, 0.099202074), (14, 0.26682928), (16, 0.06073625), (18, 0.17277187)]"
27600,,2022-08-03 05:40:06,0,877,"<p>I have just installed Qiskit, Qutip, and Cirq in my Anaconda Enviornment. When I tried to run the test program:</p>
<pre><code>import cirq
from cirq import *
print(cirq.google.Foxtail)
# should print:
# (0, 0)───(0, 1)───(0, 2)───(0, 3)───(0, 4)───(0, 5)───(0, 6)───(0, 7)───(0, 8)───(0, 9)───(0, 10)
# │        │        │        │        │        │        │        │        │        │        │
# │        │        │        │        │        │        │        │        │        │        │
# (1, 0)───(1, 1)───(1, 2)───(1, 3)───(1, 4)───(1, 5)───(1, 6)───(1, 7)───(1, 8)───(1, 9)───(1, 10)
</code></pre>
<p>But it's giving this error:</p>
<pre><code>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [2], in &lt;cell line: 4&gt;()
      1 import cirq
      2 from cirq import *
      ----&gt; 4 print(cirq.google.Foxtail)

      AttributeError: module 'cirq' has no attribute 'google'
</code></pre>
<p>I am new to this field. Please Help.</p>
",AttributeError: module 'cirq' has no attribute 'google',<cirq>,1,0,,,"AttributeError: module 'cirq' has no attribute 'google' <p>I have just installed Qiskit, Qutip, and Cirq in my Anaconda Enviornment. When I tried to run the test program:</p>
<pre><code>import cirq
from cirq import *
print(cirq.google.Foxtail)
# should print:
# (0, 0)───(0, 1)───(0, 2)───(0, 3)───(0, 4)───(0, 5)───(0, 6)───(0, 7)───(0, 8)───(0, 9)───(0, 10)
# │        │        │        │        │        │        │        │        │        │        │
# │        │        │        │        │        │        │        │        │        │        │
# (1, 0)───(1, 1)───(1, 2)───(1, 3)───(1, 4)───(1, 5)───(1, 6)───(1, 7)───(1, 8)───(1, 9)───(1, 10)
</code></pre>
<p>But it's giving this error:</p>
<pre><code>---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [2], in &lt;cell line: 4&gt;()
      1 import cirq
      2 from cirq import *
      ----&gt; 4 print(cirq.google.Foxtail)

      AttributeError: module 'cirq' has no attribute 'google'
</code></pre>
<p>I am new to this field. Please Help.</p>
",qc,attributeerror module attribute p installed qiskit qutip cirq anaconda enviornment tried run test program pre code import cirq cirq import print print 0 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 p giving error pre code attributeerror traceback recent call last input 2 lt cell line 4 gt 1 import cirq 2 cirq import gt 4 print attributeerror module attribute p new field please,"[(0, 0.40657276), (2, 0.31757686), (6, 0.20876934), (11, 0.010478594), (16, 0.05505906)]"
27604,27605.0,2022-08-03 08:26:04,1,360,"<p>Qiskit documentation for <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.u.html#qiskit.circuit.QuantumCircuit.u"" rel=""nofollow noreferrer"">QuantumCircuit.u(theta, phi, lam, qubit)</a> does not mentions the axis against given angle argument for rotation operation.
It just says <code>rotation angle of the gate</code>.</p>
<p>So which angle corresponds to rotation operation along which axis?</p>
",Qiskit UGate - which angles corresponds to which axes,<qiskit>,1,1,,,"Qiskit UGate - which angles corresponds to which axes <p>Qiskit documentation for <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.u.html#qiskit.circuit.QuantumCircuit.u"" rel=""nofollow noreferrer"">QuantumCircuit.u(theta, phi, lam, qubit)</a> does not mentions the axis against given angle argument for rotation operation.
It just says <code>rotation angle of the gate</code>.</p>
<p>So which angle corresponds to rotation operation along which axis?</p>
",qc,qiskit ugate angles corresponds axes p qiskit documentation https nofollow noreferrer theta phi lam qubit mentions axis given angle argument rotation operation says code rotation angle gate p angle corresponds rotation operation along axis,"[(0, 0.23062341), (4, 0.16142835), (9, 0.52986586), (16, 0.07326145)]"
27613,,2022-08-03 16:29:44,2,115,"<p>I've been programming a <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.lattice.FermiHubbardModel.html#qiskit_nature.problems.second_quantization.lattice.FermiHubbardModel"" rel=""nofollow noreferrer"">FermiHubbardModel</a> class with the Qiskit library for a VQE, but the class only shows input options for the U (onsite) and t (hopping) parameters when I construct a LineLattice.</p>
<p><a href=""https://i.sstatic.net/N6Eer.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/N6Eer.png"" alt=""There is no parameter in the LineLattice class to add fermions"" /></a></p>
<p>I've tried to manipulate the lattice with the parameters Qiskit offers, but no attempts have been successful.</p>
<p>Is there a way to add fermions to the FermiHubbardModel class? My code is below.</p>
<pre><code>import numpy as np
from qiskit_nature.problems.second_quantization.lattice import LineLattice, FermiHubbardModel

L = LineLattice(6,onsite_parameter=4,edge_parameter=1)

L.draw()
hamiltonian = FermiHubbardModel(L,4).second_q_ops(display_format='dense')
op = JordanWignerMapper().map(hamiltonian)
</code></pre>
",How do you add spin up and spin down fermions to a FermiHubbardModel class in Qiskit?,<qiskit><hamiltonian-simulation><vqe>,0,0,,,"How do you add spin up and spin down fermions to a FermiHubbardModel class in Qiskit? <p>I've been programming a <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.lattice.FermiHubbardModel.html#qiskit_nature.problems.second_quantization.lattice.FermiHubbardModel"" rel=""nofollow noreferrer"">FermiHubbardModel</a> class with the Qiskit library for a VQE, but the class only shows input options for the U (onsite) and t (hopping) parameters when I construct a LineLattice.</p>
<p><a href=""https://i.sstatic.net/N6Eer.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/N6Eer.png"" alt=""There is no parameter in the LineLattice class to add fermions"" /></a></p>
<p>I've tried to manipulate the lattice with the parameters Qiskit offers, but no attempts have been successful.</p>
<p>Is there a way to add fermions to the FermiHubbardModel class? My code is below.</p>
<pre><code>import numpy as np
from qiskit_nature.problems.second_quantization.lattice import LineLattice, FermiHubbardModel

L = LineLattice(6,onsite_parameter=4,edge_parameter=1)

L.draw()
hamiltonian = FermiHubbardModel(L,4).second_q_ops(display_format='dense')
op = JordanWignerMapper().map(hamiltonian)
</code></pre>
",qc,add spin spin fermions fermihubbardmodel class qiskit p programming https nofollow noreferrer fermihubbardmodel class qiskit library vqe class shows input options u onsite hopping parameters construct p https nofollow noreferrer img https parameter linelattice class add fermions p tried manipulate lattice parameters qiskit offers attempts p way add fermions fermihubbardmodel class code pre code import numpy np import linelattice fermihubbardmodel l linelattice 6 hamiltonian fermihubbardmodel op jordanwignermapper hamiltonian,"[(0, 0.443472), (1, 0.07381564), (4, 0.1981934), (10, 0.058910925), (14, 0.2057739), (16, 0.017427271)]"
27632,27634.0,2022-08-05 08:08:59,1,429,"<p>I'm not sure how to properly bind parameters in the circuit. I don't know why I got the following traceback even though I used .bind_parameters() in my earlier code here:</p>
<pre><code>def run(self, thetas):

    self._circuit = self._circuit.bind_parameters({self.theta: thetas[0]})
    self.mitiq_circuit = convert_to_mitiq(self._circuit)[0]
    self.cirq_circuit = convert_from_mitiq(self.mitiq_circuit, &quot;cirq&quot;)
    
    def simulate(circuit: cirq.Circuit) -&gt; np.ndarray:
        return compute_density_matrix(circuit, noise_level=(0.0,))

    mitigated_measurement = cdr.execute_with_cdr(
        self.cirq_circuit,
        compute_density_matrix,
        observable=self.obs,
        simulator=simulate,
        seed=0,
        scale_factors=(1.0, 3.0),
    ).real
    
    return np.array([mitigated_measurement]) 
</code></pre>
<p>I ran the following code:</p>
<pre><code>circuit = QuantumCircuit(1, simulator, 100)
print('Expected value for rotation pi {}'.format(circuit.run([np.pi])[0]))
</code></pre>
<p>Error traceback:</p>
<pre><code>    ---------------------------------------------------------------------------
CircuitError                              Traceback (most recent call last)
/Users/colinhong/Library/CloudStorage/OneDrive-NanyangTechnologicalUniversity/Summer 2022/QML Intern/Qiskit Tutorials/machine-learning-qiskit-pytorch.ipynb Cell 24 in &lt;cell line: 9&gt;()
     16 loss = loss_func(output, target)
     17 # Backward pass
---&gt; 18 loss.backward()
     19 # Optimize the weights
     20 optimizer.step()

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/torch/_tensor.py:396, in Tensor.backward(self, gradient, retain_graph, create_graph, inputs)
    387 if has_torch_function_unary(self):
    388     return handle_torch_function(
    389         Tensor.backward,
    390         (self,),
   (...)
    394         create_graph=create_graph,
    395         inputs=inputs)
--&gt; 396 torch.autograd.backward(self, gradient, retain_graph, create_graph, inputs=inputs)

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/torch/autograd/__init__.py:173, in backward(tensors, grad_tensors, retain_graph, create_graph, grad_variables, inputs)
    168     retain_graph = create_graph
    170 # The reason we repeat same the comment below is that
    171 # some Python versions print out the first line of a multi-line function
    172 # calls in the traceback and some print out the last line
--&gt; 173 Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass
    174     tensors, grad_tensors_, retain_graph, create_graph, inputs,
    175     allow_unreachable=True, accumulate_grad=True)

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/torch/autograd/function.py:253, in BackwardCFunction.apply(self, *args)
    249     raise RuntimeError(&quot;Implementing both 'backward' and 'vjp' for a custom &quot;
    250                        &quot;Function is not allowed. You should only implement one &quot;
    251                        &quot;of them.&quot;)
    252 user_fn = vjp_fn if vjp_fn is not Function.vjp else backward_fn
--&gt; 253 return user_fn(self, *args)

/Users/colinhong/Library/CloudStorage/OneDrive-NanyangTechnologicalUniversity/Summer 2022/QML Intern/Qiskit Tutorials/machine-learning-qiskit-pytorch.ipynb Cell 24 in HybridFunction.backward(ctx, grad_output)
     25 gradients = []
     26 for i in range(len(input_list)):
---&gt; 27     expectation_right = ctx.quantum_circuit.run(shift_right[i])
     28     expectation_left  = ctx.quantum_circuit.run(shift_left[i])
     30     gradient = torch.tensor([expectation_right]) - torch.tensor([expectation_left])

/Users/colinhong/Library/CloudStorage/OneDrive-NanyangTechnologicalUniversity/Summer 2022/QML Intern/Qiskit Tutorials/machine-learning-qiskit-pytorch.ipynb Cell 24 in QuantumCircuit.run(self, thetas)
     28 def run(self, thetas):
     29 
     30     # self.thetas = qiskit.circuit.ParameterVector('theta', 1)
     31     # self._circuit = self._circuit.bind_parameters({self.theta: n for n in thetas})
---&gt; 32     self._circuit = self._circuit.bind_parameters({self.theta: thetas[0]})
     33     self.mitiq_circuit = convert_to_mitiq(self._circuit)[0]
     34     self.cirq_circuit = convert_from_mitiq(self.mitiq_circuit, &quot;cirq&quot;)

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py:2622, in QuantumCircuit.bind_parameters(self, values)
   2618     if any(isinstance(value, ParameterExpression) for value in values.values()):
   2619         raise TypeError(
   2620             &quot;Found ParameterExpression in values; use assign_parameters() instead.&quot;
   2621         )
-&gt; 2622     return self.assign_parameters(values)
   2623 else:
   2624     if any(isinstance(value, ParameterExpression) for value in values):

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py:2577, in QuantumCircuit.assign_parameters(self, parameters, inplace)
   2571 params_not_in_circuit = [
   2572     param_key
   2573     for param_key in unrolled_param_dict
   2574     if param_key not in unsorted_parameters
   2575 ]
   2576 if len(params_not_in_circuit) &gt; 0:
-&gt; 2577     raise CircuitError(
   2578         &quot;Cannot bind parameters ({}) not present in the circuit.&quot;.format(
   2579             &quot;, &quot;.join(map(str, params_not_in_circuit))
   2580         )
   2581     )
   2583 # replace the parameters with a new Parameter (&quot;substitute&quot;) or numeric value (&quot;bind&quot;)
   2584 for parameter, value in unrolled_param_dict.items():

CircuitError: 'Cannot bind parameters (theta) not present in the circuit.'
</code></pre>
",Qiskit: how to ensure binded parameters in circuit?,<qiskit>,1,0,,,"Qiskit: how to ensure binded parameters in circuit? <p>I'm not sure how to properly bind parameters in the circuit. I don't know why I got the following traceback even though I used .bind_parameters() in my earlier code here:</p>
<pre><code>def run(self, thetas):

    self._circuit = self._circuit.bind_parameters({self.theta: thetas[0]})
    self.mitiq_circuit = convert_to_mitiq(self._circuit)[0]
    self.cirq_circuit = convert_from_mitiq(self.mitiq_circuit, &quot;cirq&quot;)
    
    def simulate(circuit: cirq.Circuit) -&gt; np.ndarray:
        return compute_density_matrix(circuit, noise_level=(0.0,))

    mitigated_measurement = cdr.execute_with_cdr(
        self.cirq_circuit,
        compute_density_matrix,
        observable=self.obs,
        simulator=simulate,
        seed=0,
        scale_factors=(1.0, 3.0),
    ).real
    
    return np.array([mitigated_measurement]) 
</code></pre>
<p>I ran the following code:</p>
<pre><code>circuit = QuantumCircuit(1, simulator, 100)
print('Expected value for rotation pi {}'.format(circuit.run([np.pi])[0]))
</code></pre>
<p>Error traceback:</p>
<pre><code>    ---------------------------------------------------------------------------
CircuitError                              Traceback (most recent call last)
/Users/colinhong/Library/CloudStorage/OneDrive-NanyangTechnologicalUniversity/Summer 2022/QML Intern/Qiskit Tutorials/machine-learning-qiskit-pytorch.ipynb Cell 24 in &lt;cell line: 9&gt;()
     16 loss = loss_func(output, target)
     17 # Backward pass
---&gt; 18 loss.backward()
     19 # Optimize the weights
     20 optimizer.step()

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/torch/_tensor.py:396, in Tensor.backward(self, gradient, retain_graph, create_graph, inputs)
    387 if has_torch_function_unary(self):
    388     return handle_torch_function(
    389         Tensor.backward,
    390         (self,),
   (...)
    394         create_graph=create_graph,
    395         inputs=inputs)
--&gt; 396 torch.autograd.backward(self, gradient, retain_graph, create_graph, inputs=inputs)

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/torch/autograd/__init__.py:173, in backward(tensors, grad_tensors, retain_graph, create_graph, grad_variables, inputs)
    168     retain_graph = create_graph
    170 # The reason we repeat same the comment below is that
    171 # some Python versions print out the first line of a multi-line function
    172 # calls in the traceback and some print out the last line
--&gt; 173 Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass
    174     tensors, grad_tensors_, retain_graph, create_graph, inputs,
    175     allow_unreachable=True, accumulate_grad=True)

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/torch/autograd/function.py:253, in BackwardCFunction.apply(self, *args)
    249     raise RuntimeError(&quot;Implementing both 'backward' and 'vjp' for a custom &quot;
    250                        &quot;Function is not allowed. You should only implement one &quot;
    251                        &quot;of them.&quot;)
    252 user_fn = vjp_fn if vjp_fn is not Function.vjp else backward_fn
--&gt; 253 return user_fn(self, *args)

/Users/colinhong/Library/CloudStorage/OneDrive-NanyangTechnologicalUniversity/Summer 2022/QML Intern/Qiskit Tutorials/machine-learning-qiskit-pytorch.ipynb Cell 24 in HybridFunction.backward(ctx, grad_output)
     25 gradients = []
     26 for i in range(len(input_list)):
---&gt; 27     expectation_right = ctx.quantum_circuit.run(shift_right[i])
     28     expectation_left  = ctx.quantum_circuit.run(shift_left[i])
     30     gradient = torch.tensor([expectation_right]) - torch.tensor([expectation_left])

/Users/colinhong/Library/CloudStorage/OneDrive-NanyangTechnologicalUniversity/Summer 2022/QML Intern/Qiskit Tutorials/machine-learning-qiskit-pytorch.ipynb Cell 24 in QuantumCircuit.run(self, thetas)
     28 def run(self, thetas):
     29 
     30     # self.thetas = qiskit.circuit.ParameterVector('theta', 1)
     31     # self._circuit = self._circuit.bind_parameters({self.theta: n for n in thetas})
---&gt; 32     self._circuit = self._circuit.bind_parameters({self.theta: thetas[0]})
     33     self.mitiq_circuit = convert_to_mitiq(self._circuit)[0]
     34     self.cirq_circuit = convert_from_mitiq(self.mitiq_circuit, &quot;cirq&quot;)

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py:2622, in QuantumCircuit.bind_parameters(self, values)
   2618     if any(isinstance(value, ParameterExpression) for value in values.values()):
   2619         raise TypeError(
   2620             &quot;Found ParameterExpression in values; use assign_parameters() instead.&quot;
   2621         )
-&gt; 2622     return self.assign_parameters(values)
   2623 else:
   2624     if any(isinstance(value, ParameterExpression) for value in values):

File /Users/Shared/anaconda3/envs/mitiq-env/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py:2577, in QuantumCircuit.assign_parameters(self, parameters, inplace)
   2571 params_not_in_circuit = [
   2572     param_key
   2573     for param_key in unrolled_param_dict
   2574     if param_key not in unsorted_parameters
   2575 ]
   2576 if len(params_not_in_circuit) &gt; 0:
-&gt; 2577     raise CircuitError(
   2578         &quot;Cannot bind parameters ({}) not present in the circuit.&quot;.format(
   2579             &quot;, &quot;.join(map(str, params_not_in_circuit))
   2580         )
   2581     )
   2583 # replace the parameters with a new Parameter (&quot;substitute&quot;) or numeric value (&quot;bind&quot;)
   2584 for parameter, value in unrolled_param_dict.items():

CircuitError: 'Cannot bind parameters (theta) not present in the circuit.'
</code></pre>
",qc,qiskit ensure binded parameters circuit p sure properly bind parameters circuit know got following traceback even though used earlier code pre code def run self thetas thetas 0 0 quot cirq quot def simulate circuit gt return circuit return p ran following code pre code circuit quantumcircuit 1 simulator 100 print value rotation pi 0 p error traceback pre code circuiterror traceback recent call last cell 24 lt cell line 9 gt 16 loss output target 17 backward pass gt 18 19 optimize weights 20 file self gradient inputs 387 self 388 return 389 390 self 394 395 gt 396 self gradient file backward tensors inputs 168 170 reason repeat comment 171 python versions print first line function 172 calls traceback print last line gt 173 calls engine run backward pass 174 tensors inputs 175 file self args 249 raise runtimeerror quot implementing custom quot 250 quot function allowed implement one quot 251 quot quot 252 else gt 253 return self args cell 24 ctx 25 gradients 26 range len gt 27 28 30 gradient cell 24 self thetas 28 def run self thetas 29 30 1 31 n n thetas gt 32 thetas 0 33 0 34 quot cirq quot file self values 2618 isinstance value parameterexpression value 2619 raise typeerror 2620 quot found parameterexpression values use quot 2621 gt 2622 return values 2623 else 2624 isinstance value parameterexpression value values file self parameters inplace 2571 2572 2573 2574 2575 2576 len gt 0 gt 2577 raise circuiterror 2578 quot bind parameters present quot 2579 quot quot map str 2580 2581 2583 replace parameters new parameter quot substitute quot numeric value quot bind quot 2584 parameter value circuiterror bind parameters theta present circuit,"[(0, 0.55642563), (2, 0.05463837), (6, 0.049793348), (14, 0.06609585), (16, 0.016636152), (19, 0.25585696)]"
27644,,2022-08-06 03:05:19,1,189,"<p>I’m trying to understand and implement the amplitude amplification algorithm described in the <a href=""https://arxiv.org/pdf/0811.3171.pdf"" rel=""nofollow noreferrer"">HHL paper</a>. I’m using the <a href=""https://github.com/quantumlib/Cirq/blob/master/examples/hhl.py"" rel=""nofollow noreferrer"">cirq implementation of the HHL algorithm</a> as my starting point.</p>
<p>I have a couple of doubts with regard to this:</p>
<ol>
<li>The paper says the number of times the amplitude amplification procedure has to be applied to the HHL algorithm is <img src=""https://i.sstatic.net/Fx9E3.png"" width=""50"" /> and <img src=""https://i.sstatic.net/0ycFX.png"" width=""200"" />.</li>
</ol>
<p>I’m unsure about how to calculate p˜ with regard to the cirq implementation.
I’m also unclear as to how to find the functions f and g and the parameter λ˜. Could someone please help me understand this?</p>
<ol start=""2"">
<li>With regard to the exact procedure to be used for amplitude amplification, the paper defines two new operators <img src=""https://i.sstatic.net/PpSbW.png"" width=""200"" /> and <img src=""https://i.sstatic.net/EEhu5.png"" width=""200"" /></li>
</ol>
<p>From what I understand, I need to loop over the HHL subroutine constantly applying an operator <strong>P = - R<sub>succ</sub>R<sub>init</sub></strong> to it.</p>
<p>Could someone please explain how R<sub>succ</sub> and R<sub>init</sub> are described with respect to the cirq code? Can the P operator be expressed as another oracle?</p>
",Amplitude Amplification applied to HHL Algorithm,<programming><quantum-algorithms><cirq><hhl-algorithm><amplitude-amplification>,0,0,,,"Amplitude Amplification applied to HHL Algorithm <p>I’m trying to understand and implement the amplitude amplification algorithm described in the <a href=""https://arxiv.org/pdf/0811.3171.pdf"" rel=""nofollow noreferrer"">HHL paper</a>. I’m using the <a href=""https://github.com/quantumlib/Cirq/blob/master/examples/hhl.py"" rel=""nofollow noreferrer"">cirq implementation of the HHL algorithm</a> as my starting point.</p>
<p>I have a couple of doubts with regard to this:</p>
<ol>
<li>The paper says the number of times the amplitude amplification procedure has to be applied to the HHL algorithm is <img src=""https://i.sstatic.net/Fx9E3.png"" width=""50"" /> and <img src=""https://i.sstatic.net/0ycFX.png"" width=""200"" />.</li>
</ol>
<p>I’m unsure about how to calculate p˜ with regard to the cirq implementation.
I’m also unclear as to how to find the functions f and g and the parameter λ˜. Could someone please help me understand this?</p>
<ol start=""2"">
<li>With regard to the exact procedure to be used for amplitude amplification, the paper defines two new operators <img src=""https://i.sstatic.net/PpSbW.png"" width=""200"" /> and <img src=""https://i.sstatic.net/EEhu5.png"" width=""200"" /></li>
</ol>
<p>From what I understand, I need to loop over the HHL subroutine constantly applying an operator <strong>P = - R<sub>succ</sub>R<sub>init</sub></strong> to it.</p>
<p>Could someone please explain how R<sub>succ</sub> and R<sub>init</sub> are described with respect to the cirq code? Can the P operator be expressed as another oracle?</p>
",qc,amplitude amplification applied hhl algorithm p trying understand implement amplitude amplification algorithm described https nofollow noreferrer hhl paper using https nofollow noreferrer cirq implementation hhl algorithm starting p couple doubts regard ol li paper says number times amplitude amplification procedure applied hhl algorithm img https 50 img https 200 p unsure calculate regard cirq implementation also unclear find functions f g parameter could someone please help understand ol 2 li regard exact procedure used amplitude amplification paper defines two new operators img https 200 img https 200 p understand need loop hhl subroutine constantly applying operator strong p r sub succ r sub init p could someone please explain r sub succ r sub init described respect cirq code p operator expressed another oracle,"[(3, 0.125097), (4, 0.17804469), (7, 0.3045476), (13, 0.12098509), (14, 0.09746811), (16, 0.020082673), (18, 0.1428445)]"
27657,,2022-08-07 02:03:05,0,169,"<p>How does the <code>Ux(x, N)</code> function implements <code>Ux|y&gt; -&gt; |xy mod N&gt;</code> ?</p>
<pre><code>import numpy as np
import cirq

def Ux(x,N):

    k=1
    while(N&gt;2**k):
        k=k+1
        
    u = np.zeros([2**k, 2**k], dtype = int) 

    for i in range(N):
        u[x*i%N][i]=1
    for i in range(N,2**k):
        u[i][i]=1
        

    XU = cirq.MatrixGate(u).controlled()
    return XU
</code></pre>
",Question about Controlled Modulo Quantum Gate,<quantum-gate><cirq>,1,0,,,"Question about Controlled Modulo Quantum Gate <p>How does the <code>Ux(x, N)</code> function implements <code>Ux|y&gt; -&gt; |xy mod N&gt;</code> ?</p>
<pre><code>import numpy as np
import cirq

def Ux(x,N):

    k=1
    while(N&gt;2**k):
        k=k+1
        
    u = np.zeros([2**k, 2**k], dtype = int) 

    for i in range(N):
        u[x*i%N][i]=1
    for i in range(N,2**k):
        u[i][i]=1
        

    XU = cirq.MatrixGate(u).controlled()
    return XU
</code></pre>
",qc,question controlled modulo quantum gate p code ux x n function implements code gt gt mod n gt pre code import numpy np import cirq def ux x n n gt 2 k u 2 k 2 k dtype int range n u x n range k u xu u return xu,"[(0, 0.52135116), (3, 0.26863852), (6, 0.02635197), (9, 0.04992533), (10, 0.110630915), (16, 0.020310815)]"
27672,,2022-08-08 07:45:11,2,177,"<p>In Qiskit, there are explicit <a href=""https://github.com/Qiskit/qiskit-terra/blob/6a5adf20e86c74ce507dfb82a4d67ab05522048d/qiskit/compiler/transpiler.py#L60"" rel=""nofollow noreferrer"">transpile</a> (where a circuit is transpiled to primitive gates) and <a href=""https://github.com/Qiskit/qiskit-terra/blob/6a5adf20e86c74ce507dfb82a4d67ab05522048d/qiskit/providers/backend.py#L211"" rel=""nofollow noreferrer"">backend.run</a> (where the circuit is executed in either statevector simulation or real hardware) steps. What would be the equivalent in Cirq? In Cirq, you only have 1 API of <a href=""https://quantumai.google/reference/python/cirq/Simulator#simulate"" rel=""nofollow noreferrer"">simulator.simulate()</a>.</p>
<p>Note: I am executing my circuit multiple times under various parameters in a hybrid quantum-classical feedback loop algorithm. And so, using sweep is not possible.</p>
","In Cirq, how do I separate transpilation from execution in simulator.simulate()?",<cirq><transpile>,1,2,,,"In Cirq, how do I separate transpilation from execution in simulator.simulate()? <p>In Qiskit, there are explicit <a href=""https://github.com/Qiskit/qiskit-terra/blob/6a5adf20e86c74ce507dfb82a4d67ab05522048d/qiskit/compiler/transpiler.py#L60"" rel=""nofollow noreferrer"">transpile</a> (where a circuit is transpiled to primitive gates) and <a href=""https://github.com/Qiskit/qiskit-terra/blob/6a5adf20e86c74ce507dfb82a4d67ab05522048d/qiskit/providers/backend.py#L211"" rel=""nofollow noreferrer"">backend.run</a> (where the circuit is executed in either statevector simulation or real hardware) steps. What would be the equivalent in Cirq? In Cirq, you only have 1 API of <a href=""https://quantumai.google/reference/python/cirq/Simulator#simulate"" rel=""nofollow noreferrer"">simulator.simulate()</a>.</p>
<p>Note: I am executing my circuit multiple times under various parameters in a hybrid quantum-classical feedback loop algorithm. And so, using sweep is not possible.</p>
",qc,cirq separate transpilation execution p qiskit explicit https l60 nofollow noreferrer transpile circuit transpiled primitive gates https l211 nofollow noreferrer circuit executed either statevector simulation real hardware steps would equivalent cirq cirq 1 api https simulate nofollow noreferrer p note executing circuit multiple times various parameters hybrid feedback loop algorithm using sweep,"[(4, 0.30401185), (8, 0.048109334), (14, 0.592431), (16, 0.052259196)]"
27720,27722.0,2022-08-10 18:29:54,0,112,"<p>I have a simple qiskit circuit :</p>
<pre><code>import qiskit

def TestA():
 qr=qiskit.QuantumRegister(5)
 cr=qiskit.ClassicalRegister(4)
 qc=qiskit.QuantumCircuit(qr,cr)
 qc.h(0)
 qc.cx(0,4)
 qc.h(1)
 qc.cz(1,0)
 qc.measure([0,1,2,3], [0,1,2,3])
 print(qc)
</code></pre>
<p>If I run TestA more than once it seems that some variables are not cleared.
For example :</p>
<pre><code>&gt;&gt;&gt; import Tests
&gt;&gt;&gt; Tests.TestA()
      ┌───┐           ┌─┐
q0_0: ┤ H ├─────■───■─┤M├───
      ├───┤     │   │ └╥┘┌─┐
q0_1: ┤ H ├─────┼───■──╫─┤M├
      └┬─┬┘     │      ║ └╥┘
q0_2: ─┤M├──────┼──────╫──╫─
       └╥┘ ┌─┐  │      ║  ║
q0_3: ──╫──┤M├──┼──────╫──╫─
        ║  └╥┘┌─┴─┐    ║  ║
q0_4: ──╫───╫─┤ X ├────╫──╫─
        ║   ║ └───┘    ║  ║
c0: 4/══╩═══╩══════════╩══╩═
        2   3          0  1
&gt;&gt;&gt; Tests.TestA()
      ┌───┐           ┌─┐
q1_0: ┤ H ├─────■───■─┤M├───
      ├───┤     │   │ └╥┘┌─┐
q1_1: ┤ H ├─────┼───■──╫─┤M├
      └┬─┬┘     │      ║ └╥┘
q1_2: ─┤M├──────┼──────╫──╫─
       └╥┘ ┌─┐  │      ║  ║
q1_3: ──╫──┤M├──┼──────╫──╫─
        ║  └╥┘┌─┴─┐    ║  ║
q1_4: ──╫───╫─┤ X ├────╫──╫─
        ║   ║ └───┘    ║  ║
c1: 4/══╩═══╩══════════╩══╩═
        2   3          0  1
&gt;&gt;&gt;
</code></pre>
<p>The register names in the first run where q0 and c0; in the second run they're changed to q1 and c1. It makes me suspect that other things are also left over from previous runs. Is there a way to reset everything at the beginning of each test?</p>
<p>I see the same behavior if I reload the module (using importlib.reload(Tests))</p>
",Qiskit : how to reset all variables in a simulation,<qiskit>,2,0,,,"Qiskit : how to reset all variables in a simulation <p>I have a simple qiskit circuit :</p>
<pre><code>import qiskit

def TestA():
 qr=qiskit.QuantumRegister(5)
 cr=qiskit.ClassicalRegister(4)
 qc=qiskit.QuantumCircuit(qr,cr)
 qc.h(0)
 qc.cx(0,4)
 qc.h(1)
 qc.cz(1,0)
 qc.measure([0,1,2,3], [0,1,2,3])
 print(qc)
</code></pre>
<p>If I run TestA more than once it seems that some variables are not cleared.
For example :</p>
<pre><code>&gt;&gt;&gt; import Tests
&gt;&gt;&gt; Tests.TestA()
      ┌───┐           ┌─┐
q0_0: ┤ H ├─────■───■─┤M├───
      ├───┤     │   │ └╥┘┌─┐
q0_1: ┤ H ├─────┼───■──╫─┤M├
      └┬─┬┘     │      ║ └╥┘
q0_2: ─┤M├──────┼──────╫──╫─
       └╥┘ ┌─┐  │      ║  ║
q0_3: ──╫──┤M├──┼──────╫──╫─
        ║  └╥┘┌─┴─┐    ║  ║
q0_4: ──╫───╫─┤ X ├────╫──╫─
        ║   ║ └───┘    ║  ║
c0: 4/══╩═══╩══════════╩══╩═
        2   3          0  1
&gt;&gt;&gt; Tests.TestA()
      ┌───┐           ┌─┐
q1_0: ┤ H ├─────■───■─┤M├───
      ├───┤     │   │ └╥┘┌─┐
q1_1: ┤ H ├─────┼───■──╫─┤M├
      └┬─┬┘     │      ║ └╥┘
q1_2: ─┤M├──────┼──────╫──╫─
       └╥┘ ┌─┐  │      ║  ║
q1_3: ──╫──┤M├──┼──────╫──╫─
        ║  └╥┘┌─┴─┐    ║  ║
q1_4: ──╫───╫─┤ X ├────╫──╫─
        ║   ║ └───┘    ║  ║
c1: 4/══╩═══╩══════════╩══╩═
        2   3          0  1
&gt;&gt;&gt;
</code></pre>
<p>The register names in the first run where q0 and c0; in the second run they're changed to q1 and c1. It makes me suspect that other things are also left over from previous runs. Is there a way to reset everything at the beginning of each test?</p>
<p>I see the same behavior if I reload the module (using importlib.reload(Tests))</p>
",qc,qiskit reset variables simulation p simple qiskit circuit pre code import qiskit def testa 5 4 qr cr 0 1 print qc p run testa seems variables cleared example pre code gt gt gt import tests gt gt gt h h x c0 2 3 0 1 gt gt gt h h x c1 2 3 0 1 gt gt gt p register names first run q0 c0 second run changed q1 c1 makes suspect things also left previous runs way reset everything beginning test p see behavior reload module using tests,"[(0, 0.42094576), (2, 0.118792504), (10, 0.04643792), (13, 0.031994987), (14, 0.3146948), (15, 0.04355291), (16, 0.02215349)]"
27787,27790.0,2022-08-15 17:28:19,1,381,"<p>Is there a way on cirq that I can make a measurement on a qubit, and depending on the outcome of that measurement act with another gate on that qubit. So, I want to measure a qubit (in the computational basis) and then apply a gate (say the Y gate) on that qubit if the measurement outcome was <span class=""math-container"">$|1\rangle$</span>. Is this possible?</p>
",How to measure a qubit and depending on measurement outcome act with a gate (cirq),<cirq>,2,0,,,"How to measure a qubit and depending on measurement outcome act with a gate (cirq) <p>Is there a way on cirq that I can make a measurement on a qubit, and depending on the outcome of that measurement act with another gate on that qubit. So, I want to measure a qubit (in the computational basis) and then apply a gate (say the Y gate) on that qubit if the measurement outcome was <span class=""math-container"">$|1\rangle$</span>. Is this possible?</p>
",qc,measure qubit depending measurement outcome act gate cirq p way cirq make measurement qubit depending outcome measurement act another gate qubit want measure qubit computational basis apply gate say gate qubit measurement outcome span possible,"[(16, 0.05711491), (18, 0.9377712)]"
27824,27847.0,2022-08-17 09:42:37,1,441,"<p>So far, I have my code set up to find the probability distribution using simulator.run(), and I was wondering if I can use the simulator.simulate() function instead to obtain a probability distribution.</p>
<p>The context of my question is quantum walk simulations, but my question doesn't require any knowledge of quantum walks. So, I am looking at quantum walk simulations and want to get the probability distribution of finding the walk in a certain position state (which are represented by the computational basis states of the Hilbert space). The way my code is set up now is as follows: I define the quantum walk in terms of a circuit, where I take a measurement at the end of the circuit (i.e. at the end of each 'walk' I measure which (position) state the walk is found in). I then repeat this process multiple times and find which state is measured each time:</p>
<pre><code>simulator = cirq.Simulator()
result = simulator.run(circuit, repetitions=sample_number)
final = result.histogram(key='x')
</code></pre>
<p>Then for 50 repetitions the final looks like <code>Counter({5: 20, 8: 5, 2: 25})</code> for example, which means that out of 50 runs, I find the walk 20 times in the (position) state 5, 5 times in state 8 etc. I then extract two arrays from this, one with the positions: [5,8,2] and one with the counts: [20,5,25]. I then normalise the latter to obtain probabilities. Then I simply plot these two arrays and find the probability distribution of finding the walk in a certain position.</p>
<p>I was wondering if I can similarly obtain a probability distribution using simulator.simulate() instead of simulator.run(). I still have the same circuit which represents the quantum walk, but now I don't take a measurement, and instead I would like to use</p>
<pre><code>simulator = cirq.Simulator()
result = simulator.simulate(circuit)
</code></pre>
<p>Printing the result will give me something like</p>
<pre><code>qubits: (q0, q1, ...) (list of qubits used)
output vector: [0.      a.      c.    ...      0.] (amplitudes of all different states)
</code></pre>
<p>It seems like this output vector contains all the information necessary to make a probability distribution: I have the amplitudes of each (position) state, and so squaring them will give me the probability of finding the walk in each state.</p>
<p>The only problem is that I am not sure how to actually 'read' this output vector, and find which state the amplitude corresponds to? For example, is there a way to 'translate' the states in the same way the simulator.run() automatically does (so for 4 qubits, state <span class=""math-container"">$|0010\rangle$</span> becomes <span class=""math-container"">$|8\rangle$</span> in binary, which the final in the run function seems to automatically do)?</p>
<p>Many thanks!</p>
",Use simulator.simulate() to obtain probability distribution instead of simulator.run() (cirq),<simulation><cirq>,1,0,,,"Use simulator.simulate() to obtain probability distribution instead of simulator.run() (cirq) <p>So far, I have my code set up to find the probability distribution using simulator.run(), and I was wondering if I can use the simulator.simulate() function instead to obtain a probability distribution.</p>
<p>The context of my question is quantum walk simulations, but my question doesn't require any knowledge of quantum walks. So, I am looking at quantum walk simulations and want to get the probability distribution of finding the walk in a certain position state (which are represented by the computational basis states of the Hilbert space). The way my code is set up now is as follows: I define the quantum walk in terms of a circuit, where I take a measurement at the end of the circuit (i.e. at the end of each 'walk' I measure which (position) state the walk is found in). I then repeat this process multiple times and find which state is measured each time:</p>
<pre><code>simulator = cirq.Simulator()
result = simulator.run(circuit, repetitions=sample_number)
final = result.histogram(key='x')
</code></pre>
<p>Then for 50 repetitions the final looks like <code>Counter({5: 20, 8: 5, 2: 25})</code> for example, which means that out of 50 runs, I find the walk 20 times in the (position) state 5, 5 times in state 8 etc. I then extract two arrays from this, one with the positions: [5,8,2] and one with the counts: [20,5,25]. I then normalise the latter to obtain probabilities. Then I simply plot these two arrays and find the probability distribution of finding the walk in a certain position.</p>
<p>I was wondering if I can similarly obtain a probability distribution using simulator.simulate() instead of simulator.run(). I still have the same circuit which represents the quantum walk, but now I don't take a measurement, and instead I would like to use</p>
<pre><code>simulator = cirq.Simulator()
result = simulator.simulate(circuit)
</code></pre>
<p>Printing the result will give me something like</p>
<pre><code>qubits: (q0, q1, ...) (list of qubits used)
output vector: [0.      a.      c.    ...      0.] (amplitudes of all different states)
</code></pre>
<p>It seems like this output vector contains all the information necessary to make a probability distribution: I have the amplitudes of each (position) state, and so squaring them will give me the probability of finding the walk in each state.</p>
<p>The only problem is that I am not sure how to actually 'read' this output vector, and find which state the amplitude corresponds to? For example, is there a way to 'translate' the states in the same way the simulator.run() automatically does (so for 4 qubits, state <span class=""math-container"">$|0010\rangle$</span> becomes <span class=""math-container"">$|8\rangle$</span> in binary, which the final in the run function seems to automatically do)?</p>
<p>Many thanks!</p>
",qc,use obtain probability distribution instead cirq p far code set find probability distribution using wondering use function instead obtain probability p context question quantum walk simulations question require knowledge quantum walks looking quantum walk simulations want get probability distribution finding walk certain position state represented computational basis states hilbert space way code set follows define quantum walk terms circuit take measurement end circuit end measure position state walk found repeat process multiple times find state measured time pre code simulator result circuit final x p 50 repetitions final looks like code counter 5 20 8 5 2 25 example means 50 runs find walk 20 times position state 5 5 times state 8 etc extract two arrays one positions one counts normalise latter obtain probabilities simply plot two arrays find probability distribution finding walk certain p wondering similarly obtain probability distribution using instead still circuit represents quantum walk take measurement instead would like use pre code simulator result circuit p printing result give something like pre code qubits q0 q1 list qubits used output vector 0 amplitudes different states p seems like output vector contains information necessary make probability distribution amplitudes position state squaring give probability finding walk p problem sure actually output vector find state amplitude corresponds example way states way automatically 4 qubits state span becomes span binary final run function seems automatically p many thanks,"[(3, 0.0722801), (6, 0.04956122), (13, 0.2157992), (14, 0.46570006), (16, 0.010239202), (18, 0.18072031)]"
27829,,2022-08-17 16:22:17,0,112,"<p>I'm having trouble unifying these two ideas. When I read examples using, say, qiskit, it's typical to measure a qubit, so that to find the probability of measuring a state <span class=""math-container"">$|\psi \rangle$</span> in the state <span class=""math-container"">$|x\rangle$</span> is <span class=""math-container"">$p(|x \rangle) = (\langle x | \psi \rangle)^2$</span>.</p>
<p>But when I read quantum computing textbooks, they usually refer to some observable that is getting measured. So what is the operator that gets measured when we &quot;measure a qubit&quot;? Is it the identity operator or something?</p>
",Measuring qubits vs measuring operators,<measurement>,1,1,,,"Measuring qubits vs measuring operators <p>I'm having trouble unifying these two ideas. When I read examples using, say, qiskit, it's typical to measure a qubit, so that to find the probability of measuring a state <span class=""math-container"">$|\psi \rangle$</span> in the state <span class=""math-container"">$|x\rangle$</span> is <span class=""math-container"">$p(|x \rangle) = (\langle x | \psi \rangle)^2$</span>.</p>
<p>But when I read quantum computing textbooks, they usually refer to some observable that is getting measured. So what is the operator that gets measured when we &quot;measure a qubit&quot;? Is it the identity operator or something?</p>
",qc,measuring qubits vs measuring operators p trouble unifying two ideas read examples using say qiskit typical measure qubit find probability measuring state span state span span p x p read quantum computing textbooks usually refer observable getting measured operator gets measured quot measure qubit quot identity operator something,"[(3, 0.23468126), (7, 0.045779824), (8, 0.1696468), (10, 0.022218894), (14, 0.042192526), (16, 0.020655908), (18, 0.41629758), (19, 0.046035714)]"
27837,27841.0,2022-08-18 07:53:28,2,52,"<p>Is there any API provided by Qiskit to ungroup a custom quantum gate into its component quantum gate.</p>
<p>If there is no API, please let me know how to ungroup the custom gate after I made own quantum_circuit by using the <code>QuantumCircuit.from_qasm_file()</code></p>
",Ungroup a custom quantum gate in QASM 2.0,<qiskit><quantum-gate>,1,1,,,"Ungroup a custom quantum gate in QASM 2.0 <p>Is there any API provided by Qiskit to ungroup a custom quantum gate into its component quantum gate.</p>
<p>If there is no API, please let me know how to ungroup the custom gate after I made own quantum_circuit by using the <code>QuantumCircuit.from_qasm_file()</code></p>
",qc,ungroup custom quantum gate qasm p api provided qiskit ungroup custom quantum gate component quantum p api please let know ungroup custom gate made using code,"[(1, 0.100115955), (14, 0.706045), (16, 0.1414706), (19, 0.045470674)]"
27843,27844.0,2022-08-18 12:28:22,2,676,"<p>I'm trying to understand entanglement, superposition and the effects of measurement on entangled qubits a bit better.</p>
<p><strong>About entanglement:</strong></p>
<p>I know that the circuit below will entangle the two qubits:</p>
<p><a href=""https://i.sstatic.net/i16tu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/i16tu.png"" alt=""enter image description here"" /></a></p>
<p>The question is, if I add a third qubit and a CNOT gate, as below, can we say that q2 is entangled with q0 as well?</p>
<p><a href=""https://i.sstatic.net/Y0CXa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Y0CXa.png"" alt=""enter image description here"" /></a></p>
<p>I mean, can I actually use the CNOT gate to entangle multiple qubits like that (considering that the first two are already entangled)?</p>
<p>What if I apply another CNOT like below, will it kill entanglement between q2 and the other two qubits? or will it just have no effect?</p>
<p><a href=""https://i.sstatic.net/41D4W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/41D4W.png"" alt=""enter image description here"" /></a></p>
<p><strong>About measurement:</strong></p>
<p>And if I measure q2 at that point, will q0 and q1 still be entangled?
I assume that if q2 is at any point entangled with the other two qubits, if you measure q2, then the other two qubits will collapse immediately (as per the &quot;spooky action at a distance&quot; behaviour).</p>
",CNOT entangling a third qubit and how measurement impacts entanglement,<quantum-gate><quantum-state><entanglement><measurement><superposition>,3,2,,,"CNOT entangling a third qubit and how measurement impacts entanglement <p>I'm trying to understand entanglement, superposition and the effects of measurement on entangled qubits a bit better.</p>
<p><strong>About entanglement:</strong></p>
<p>I know that the circuit below will entangle the two qubits:</p>
<p><a href=""https://i.sstatic.net/i16tu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/i16tu.png"" alt=""enter image description here"" /></a></p>
<p>The question is, if I add a third qubit and a CNOT gate, as below, can we say that q2 is entangled with q0 as well?</p>
<p><a href=""https://i.sstatic.net/Y0CXa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Y0CXa.png"" alt=""enter image description here"" /></a></p>
<p>I mean, can I actually use the CNOT gate to entangle multiple qubits like that (considering that the first two are already entangled)?</p>
<p>What if I apply another CNOT like below, will it kill entanglement between q2 and the other two qubits? or will it just have no effect?</p>
<p><a href=""https://i.sstatic.net/41D4W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/41D4W.png"" alt=""enter image description here"" /></a></p>
<p><strong>About measurement:</strong></p>
<p>And if I measure q2 at that point, will q0 and q1 still be entangled?
I assume that if q2 is at any point entangled with the other two qubits, if you measure q2, then the other two qubits will collapse immediately (as per the &quot;spooky action at a distance&quot; behaviour).</p>
",qc,cnot entangling third qubit measurement impacts entanglement p trying understand entanglement superposition effects measurement entangled qubits bit p strong entanglement p know circuit entangle two qubits p https nofollow noreferrer img https enter image description p question add third qubit cnot gate say q2 entangled q0 well p https nofollow noreferrer img https enter image description p mean actually use cnot gate entangle multiple qubits like considering first two already entangled p apply another cnot like kill entanglement q2 two qubits effect p https nofollow noreferrer img https enter image description p strong measurement p measure q2 point q0 q1 still entangled assume q2 point entangled two qubits measure q2 two qubits collapse immediately per quot spooky action distance quot behaviour,"[(4, 0.43976626), (5, 0.01344541), (14, 0.019627372), (16, 0.0255593), (18, 0.48062944), (19, 0.01978698)]"
27973,,2022-08-29 06:48:37,2,176,"<p>I'm a beginner in quantum computing and this question has been bugging me for quite some time. I have seen in various articles that a qubit is a device whose state can be represented by a unit vector in a 2-dimensional &quot;complex&quot; vector space. That is <span class=""math-container"">$|\Psi&gt; = a_1 |0&gt; + a_2 |1&gt;$</span> where <span class=""math-container"">$a_1$</span> and <span class=""math-container"">$a_2$</span> are complex numbers that can be represented as <span class=""math-container"">$a_1 = r_1 e^{i\Phi_1}$</span> where <span class=""math-container"">$r_1$</span> the amplitude of the complex number <span class=""math-container"">$a_1$</span>, it represents the square root of the probability of the qubit to be in &quot;state 1&quot; on measurement.</p>
<p>But what confuses me is that what does the phase of <span class=""math-container"">$a_1$</span>, <span class=""math-container"">$\Phi_1$</span> represent about the &quot;state 1&quot;. Does it even represent anything with respect to &quot;state 1&quot;? Or does the qubit just have a global phase (is it the phase difference between the coefficients? ) which has nothing to do with state |0&gt; or |1&gt; individually?</p>
",What does the phase $\phi_1$ in a state $|\psi\rangle=a_1|0\rangle+a_2|1\rangle$ with $a_j=r_j e^{i\phi_j}$ say about state $|1\rangle$?,<quantum-state><textbook-and-exercises>,2,3,,,"What does the phase $\phi_1$ in a state $|\psi\rangle=a_1|0\rangle+a_2|1\rangle$ with $a_j=r_j e^{i\phi_j}$ say about state $|1\rangle$? <p>I'm a beginner in quantum computing and this question has been bugging me for quite some time. I have seen in various articles that a qubit is a device whose state can be represented by a unit vector in a 2-dimensional &quot;complex&quot; vector space. That is <span class=""math-container"">$|\Psi&gt; = a_1 |0&gt; + a_2 |1&gt;$</span> where <span class=""math-container"">$a_1$</span> and <span class=""math-container"">$a_2$</span> are complex numbers that can be represented as <span class=""math-container"">$a_1 = r_1 e^{i\Phi_1}$</span> where <span class=""math-container"">$r_1$</span> the amplitude of the complex number <span class=""math-container"">$a_1$</span>, it represents the square root of the probability of the qubit to be in &quot;state 1&quot; on measurement.</p>
<p>But what confuses me is that what does the phase of <span class=""math-container"">$a_1$</span>, <span class=""math-container"">$\Phi_1$</span> represent about the &quot;state 1&quot;. Does it even represent anything with respect to &quot;state 1&quot;? Or does the qubit just have a global phase (is it the phase difference between the coefficients? ) which has nothing to do with state |0&gt; or |1&gt; individually?</p>
",qc,phase state say state p beginner quantum computing question bugging quite time seen various articles qubit device whose state represented unit vector quot complex quot vector space span gt gt gt span span complex numbers represented span span amplitude complex number span represents square root probability qubit quot state 1 quot p confuses phase span span represent quot state 1 quot even represent anything respect quot state 1 quot qubit global phase phase difference coefficients nothing state gt gt individually,"[(3, 0.39285696), (8, 0.173621), (16, 0.018800618), (18, 0.30236185), (19, 0.11046519)]"
27991,,2022-08-31 01:55:45,4,819,"<p>I would like to ask you a question because I cannot clearly understand the difference between <span class=""math-container"">$T_2$</span> and <span class=""math-container"">$T_2^*$</span> in the decoherence graph provided by IBM. Let me summarize the questions I have as follows.</p>
<p><strong>[Circuit]</strong> The gate-based circuit for measuring the Decoherence characteristics of the device is as follows. It's a common method, so it doesn't seem necessary to explain it.</p>
<p><a href=""https://i.sstatic.net/a9QOK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/a9QOK.png"" alt=""enter image description here"" /></a></p>
<p><strong>[Decoherence Graph]</strong> Below is a graph of the measurements released by IBM.  Of course, there are slight differences between devices, but I think the patterns will be similar.</p>
<p>The results of <span class=""math-container"">$T_1$</span> are very intuitive. As the amplitude decreases gradually, it changes from <span class=""math-container"">$|1\rangle$</span> to <span class=""math-container"">$|0\rangle$</span>, and this pattern seems to be fitable in the form of a function.</p>
<p>The results of <span class=""math-container"">$T_2^*$</span> are understandable to some extent. It seems that the states of <span class=""math-container"">$|1\rangle$</span> and <span class=""math-container"">$|0\rangle$</span> can be measured in the form of sine curves as shown in the graph when measuring after the second H according to the phase change by frequency fluctuation in the state of <span class=""math-container"">$|+\rangle$</span>. In other words, <span class=""math-container"">$T_2^*$</span> can be said to detect a phase change in the qubit.</p>
<ul>
<li><p>Q1) In the case of <span class=""math-container"">$T_2$</span>, I'm not sure what kind of change we're observing.   Unlike <span class=""math-container"">$T_1$</span> and <span class=""math-container"">$T_2^*$</span>, which are interpreted intuitively, I would like to know how to interpret the graph of <span class=""math-container"">$T_2$</span>. In other words, what causes affect <span class=""math-container"">$T_2$</span>, and how does it change the state?</p>
</li>
<li><p>Q2) In addition, if you look at the Legend of each graph, the numerical values are specified, and I am curious about the criteria. For example, <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span>, and <span class=""math-container"">$T_2^*$</span> for qubit0 are 24.1, 21.7, and 22.8, respectively, and I wonder how the constants of <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span>, and <span class=""math-container"">$T_2^*$</span> are determined from the measurement results of the graph.</p>
</li>
</ul>
<p><a href=""https://i.sstatic.net/uJeWl.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uJeWl.png"" alt=""enter image description here"" /></a></p>
","Decoherence graph of $T_1$, $T_2$, $T_2^*$ in IBMQ",<decoherence>,2,1,,,"Decoherence graph of $T_1$, $T_2$, $T_2^*$ in IBMQ <p>I would like to ask you a question because I cannot clearly understand the difference between <span class=""math-container"">$T_2$</span> and <span class=""math-container"">$T_2^*$</span> in the decoherence graph provided by IBM. Let me summarize the questions I have as follows.</p>
<p><strong>[Circuit]</strong> The gate-based circuit for measuring the Decoherence characteristics of the device is as follows. It's a common method, so it doesn't seem necessary to explain it.</p>
<p><a href=""https://i.sstatic.net/a9QOK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/a9QOK.png"" alt=""enter image description here"" /></a></p>
<p><strong>[Decoherence Graph]</strong> Below is a graph of the measurements released by IBM.  Of course, there are slight differences between devices, but I think the patterns will be similar.</p>
<p>The results of <span class=""math-container"">$T_1$</span> are very intuitive. As the amplitude decreases gradually, it changes from <span class=""math-container"">$|1\rangle$</span> to <span class=""math-container"">$|0\rangle$</span>, and this pattern seems to be fitable in the form of a function.</p>
<p>The results of <span class=""math-container"">$T_2^*$</span> are understandable to some extent. It seems that the states of <span class=""math-container"">$|1\rangle$</span> and <span class=""math-container"">$|0\rangle$</span> can be measured in the form of sine curves as shown in the graph when measuring after the second H according to the phase change by frequency fluctuation in the state of <span class=""math-container"">$|+\rangle$</span>. In other words, <span class=""math-container"">$T_2^*$</span> can be said to detect a phase change in the qubit.</p>
<ul>
<li><p>Q1) In the case of <span class=""math-container"">$T_2$</span>, I'm not sure what kind of change we're observing.   Unlike <span class=""math-container"">$T_1$</span> and <span class=""math-container"">$T_2^*$</span>, which are interpreted intuitively, I would like to know how to interpret the graph of <span class=""math-container"">$T_2$</span>. In other words, what causes affect <span class=""math-container"">$T_2$</span>, and how does it change the state?</p>
</li>
<li><p>Q2) In addition, if you look at the Legend of each graph, the numerical values are specified, and I am curious about the criteria. For example, <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span>, and <span class=""math-container"">$T_2^*$</span> for qubit0 are 24.1, 21.7, and 22.8, respectively, and I wonder how the constants of <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span>, and <span class=""math-container"">$T_2^*$</span> are determined from the measurement results of the graph.</p>
</li>
</ul>
<p><a href=""https://i.sstatic.net/uJeWl.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uJeWl.png"" alt=""enter image description here"" /></a></p>
",qc,decoherence graph ibmq p would like ask question clearly understand difference span span decoherence graph provided ibm let summarize questions p strong circuit circuit measuring decoherence characteristics device follows common method seem necessary explain p https nofollow noreferrer img https enter image description p strong decoherence graph graph measurements released ibm course slight differences devices think patterns p results span intuitive amplitude decreases gradually changes span span pattern seems fitable form p results span understandable extent seems states span span measured form sine curves shown graph measuring second h according phase change frequency fluctuation state span words span said detect phase change ul li p q1 case span sure kind change observing unlike span span interpreted intuitively would like know interpret graph span words causes affect span change state li p q2 addition look legend graph numerical values specified curious criteria example span span span qubit0 respectively wonder constants span span span determined measurement results p https nofollow noreferrer img https enter image description,"[(3, 0.29694885), (4, 0.2205027), (8, 0.017775722), (9, 0.16440919), (13, 0.10342059), (14, 0.056605913), (16, 0.020572528), (18, 0.11106274)]"
28231,,2022-09-20 09:55:16,2,68,"<p>I need to build an expression for the objective to be minimized which is based on the L1-norm. For doing this, I need to take the absolute value of a BQM, which is not possible, at least at the moment (switching to a L2-norm would be a good alternative, but squaring a BQM is taking very long time - my problem is large!).</p>
<p>I know the absolute value can be substituted with two constraints (<a href=""https://stackoverflow.com/a/64109078/6498753"">https://stackoverflow.com/a/64109078/6498753</a>), but how would you implement this in the context of QA? Would the equivalent of the dummy variable <code>z</code> be a new BQM to be added to the 'general' one (with something like <code>BQM.update(Abs_Constraint1)</code> and <code>BQM.update(Abs_Constraint1</code>))?</p>
",Absolute value of a BQM: how to substitute it with constraint?,<programming><optimization><d-wave><applications>,0,0,,,"Absolute value of a BQM: how to substitute it with constraint? <p>I need to build an expression for the objective to be minimized which is based on the L1-norm. For doing this, I need to take the absolute value of a BQM, which is not possible, at least at the moment (switching to a L2-norm would be a good alternative, but squaring a BQM is taking very long time - my problem is large!).</p>
<p>I know the absolute value can be substituted with two constraints (<a href=""https://stackoverflow.com/a/64109078/6498753"">https://stackoverflow.com/a/64109078/6498753</a>), but how would you implement this in the context of QA? Would the equivalent of the dummy variable <code>z</code> be a new BQM to be added to the 'general' one (with something like <code>BQM.update(Abs_Constraint1)</code> and <code>BQM.update(Abs_Constraint1</code>))?</p>
",qc,absolute value bqm substitute constraint p need build expression objective minimized based need take absolute value bqm possible least moment switching would good alternative squaring bqm taking long time problem large p know absolute value substituted two constraints https https would implement context qa would equivalent dummy variable code z new bqm added one something like code code,"[(0, 0.1595379), (1, 0.03510873), (8, 0.33717495), (11, 0.03766809), (13, 0.40908423), (16, 0.018888338)]"
28533,,2022-10-13 07:57:56,7,286,"<p>With Yosi Rinott and Tomer Shoham we studied various statistical aspects of samples coming from NISQ computers.</p>
<h2>My question is about available data consisting of samples from NISQ computers</h2>
<p>We would be very happy to get samples from runs of quantum circuits (along with the description of the circuits). If such data is publicly available this will be especially useful.</p>
<p>Here are some specifics about what we would be happy to get and what we intend to try.</p>
<ol>
<li><p>We will be happy to receive samples of 0-1 strings coming from NISQ circuit. Circuits with n qubits where n is between 5 and 30 will be very helpful for us. It will be helpful to have sufficiently many samples so we can get a good picture of the empirical distribution.</p>
</li>
<li><p>What kind of circuits? We will be happy to get any kind of circuit along with the description of the circuit itself. Especially useful for us will be random circuits similar to those that appeared in the Google 2019 &quot;supremacy&quot; experiment, or other kinds of random circuits.</p>
</li>
<li><p>Calibration: If there is a preliminary process of calibration (similar to Google's) so that one haa a description of circuits based on &quot;standard&quot; gates and then a better description of the same circuit based on adjusting the gates to the device, we will be happy to have both descriptions of the circuits.</p>
</li>
</ol>
<h3>What we plan to do with the data:</h3>
<p>a) For random circuits (and perhaps also for other types) we will try to compute various estimators for the fidelity</p>
<p>b) We plan to compare the empirical distribution with theoretical distribution under various noise models</p>
<p>c) We plan to study (non)stationary and chaotic phenomenon in the empirical data</p>
<h3>IBM?</h3>
<p>We are especially interested from data obtained by the IBM quantum computers. The IBM researchers expressed interest in random circuit samples many years ago, but we are not aware of experiments the IBM team or people working with IBM quantum computers conducted in this direction. Any links for data from IBM QC will be most helpful.</p>
<h3>Data from simulators of noisy circuits</h3>
<ol start=""4"">
<li>We would also be happy to get samples based on simulations of noisy NISQ computers. Also here any reference to publicly available data will be helpful.</li>
</ol>
",Publicly available samples for quantum circuits and/or simulators,<ibm-q-experience><resource-request><experimental-realization><nisq><google-sycamore>,1,0,,,"Publicly available samples for quantum circuits and/or simulators <p>With Yosi Rinott and Tomer Shoham we studied various statistical aspects of samples coming from NISQ computers.</p>
<h2>My question is about available data consisting of samples from NISQ computers</h2>
<p>We would be very happy to get samples from runs of quantum circuits (along with the description of the circuits). If such data is publicly available this will be especially useful.</p>
<p>Here are some specifics about what we would be happy to get and what we intend to try.</p>
<ol>
<li><p>We will be happy to receive samples of 0-1 strings coming from NISQ circuit. Circuits with n qubits where n is between 5 and 30 will be very helpful for us. It will be helpful to have sufficiently many samples so we can get a good picture of the empirical distribution.</p>
</li>
<li><p>What kind of circuits? We will be happy to get any kind of circuit along with the description of the circuit itself. Especially useful for us will be random circuits similar to those that appeared in the Google 2019 &quot;supremacy&quot; experiment, or other kinds of random circuits.</p>
</li>
<li><p>Calibration: If there is a preliminary process of calibration (similar to Google's) so that one haa a description of circuits based on &quot;standard&quot; gates and then a better description of the same circuit based on adjusting the gates to the device, we will be happy to have both descriptions of the circuits.</p>
</li>
</ol>
<h3>What we plan to do with the data:</h3>
<p>a) For random circuits (and perhaps also for other types) we will try to compute various estimators for the fidelity</p>
<p>b) We plan to compare the empirical distribution with theoretical distribution under various noise models</p>
<p>c) We plan to study (non)stationary and chaotic phenomenon in the empirical data</p>
<h3>IBM?</h3>
<p>We are especially interested from data obtained by the IBM quantum computers. The IBM researchers expressed interest in random circuit samples many years ago, but we are not aware of experiments the IBM team or people working with IBM quantum computers conducted in this direction. Any links for data from IBM QC will be most helpful.</p>
<h3>Data from simulators of noisy circuits</h3>
<ol start=""4"">
<li>We would also be happy to get samples based on simulations of noisy NISQ computers. Also here any reference to publicly available data will be helpful.</li>
</ol>
",qc,publicly available samples quantum circuits simulators p yosi rinott tomer shoham studied various statistical aspects samples coming nisq h2 question available data consisting samples nisq computers p would happy get samples runs quantum circuits along description circuits data publicly available especially p specifics would happy get intend ol li p happy receive samples strings coming nisq circuit circuits n qubits n 5 30 helpful us helpful sufficiently many samples get good picture empirical li p kind circuits happy get kind circuit along description circuit especially useful us random circuits similar appeared google 2019 quot supremacy quot experiment kinds random li p calibration preliminary process calibration similar google one haa description circuits based quot standard quot gates better description circuit based adjusting gates device happy descriptions h3 plan data p random circuits perhaps also types try compute various estimators fidelity p b plan compare empirical distribution theoretical distribution various noise models p c plan study non stationary chaotic phenomenon empirical data h3 ibm p especially interested data obtained ibm quantum computers ibm researchers expressed interest random circuit samples many years ago aware experiments ibm team people working ibm quantum computers conducted direction links data ibm qc h3 data simulators noisy circuits ol 4 li would also happy get samples based simulations noisy nisq computers also reference publicly available data,"[(1, 0.022422196), (4, 0.07379934), (7, 0.046552278), (8, 0.39391735), (9, 0.089735866), (13, 0.026337368), (14, 0.28951728), (16, 0.014649026), (19, 0.03558912)]"
28544,28551.0,2022-10-14 05:40:21,0,88,"<p>How to print the stabilizers for a given circuit using Cirq (just like in Qiskit)?</p>
<p>For example, if I have the following cluster state and make a circuit using Cirq. I give the circuit as input, and I should have the output as: {+XZII, +ZXZI, +IZXZ, +IIZX}</p>
<p><a href=""https://i.sstatic.net/S6Jrr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/S6Jrr.png"" alt=""4 node cluster state"" /></a></p>
",Printing Stabilizer State of a circuit using Cirq,<programming><cirq><stabilizer-state>,1,0,,,"Printing Stabilizer State of a circuit using Cirq <p>How to print the stabilizers for a given circuit using Cirq (just like in Qiskit)?</p>
<p>For example, if I have the following cluster state and make a circuit using Cirq. I give the circuit as input, and I should have the output as: {+XZII, +ZXZI, +IZXZ, +IIZX}</p>
<p><a href=""https://i.sstatic.net/S6Jrr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/S6Jrr.png"" alt=""4 node cluster state"" /></a></p>
",qc,printing stabilizer state circuit using cirq p print stabilizers given circuit using cirq like qiskit p example following cluster state make circuit using cirq give circuit input output p https nofollow noreferrer img https 4 node cluster state,"[(0, 0.027549913), (4, 0.28039294), (5, 0.06408492), (13, 0.25191602), (14, 0.3134492), (16, 0.05894162)]"
28564,,2022-10-16 11:47:02,1,376,"<p>How we can perform measurements on an X, Y or Z basis in cirq? Is there any function where we can give the list of qubits and measurement basis as an argument and get the output?</p>
","How we can perform measurements on an X, Y or Z basis in cirq?",<measurement><cirq>,1,1,,,"How we can perform measurements on an X, Y or Z basis in cirq? <p>How we can perform measurements on an X, Y or Z basis in cirq? Is there any function where we can give the list of qubits and measurement basis as an argument and get the output?</p>
",qc,perform measurements x z basis cirq p perform measurements x z basis cirq function give list qubits measurement basis argument get output,"[(0, 0.13780968), (10, 0.14531432), (16, 0.090587154), (18, 0.61908084)]"
28577,28842.0,2022-10-17 13:41:29,2,751,"<p>For example, if take the following circuit as the input (either QASM or Qiskit):</p>
<pre><code>qreg q[2];
creg c[2];

x q[1];
h q[0];
h q[1];
cx q[0],q[1];
h q[0];
measure q[0] -&gt; c[0];
measure q[1] -&gt; c[1];
</code></pre>
<p><a href=""https://i.sstatic.net/mZRAW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/mZRAW.png"" alt=""enter image description here"" /></a></p>
<p>The expected output will be:</p>
<pre><code>layer[0] = [H [q0], X [q1]]
layer[1] = [H [q1]]
layer[2] = [cnot [q0] [q1]]
layer[3] = [H [q0]]
layer[4] = [measure [q0]]
layer[5] = [measure [q1]]
</code></pre>
<p>Is there a Qiskit function to achieve this? If not, suggestions to implement this task are also welcomed.</p>
<p>Thanks!</p>
",Is there a way to decompose a quantum circuit into layers?,<qiskit><quantum-circuit><quantum-volume>,1,5,,,"Is there a way to decompose a quantum circuit into layers? <p>For example, if take the following circuit as the input (either QASM or Qiskit):</p>
<pre><code>qreg q[2];
creg c[2];

x q[1];
h q[0];
h q[1];
cx q[0],q[1];
h q[0];
measure q[0] -&gt; c[0];
measure q[1] -&gt; c[1];
</code></pre>
<p><a href=""https://i.sstatic.net/mZRAW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/mZRAW.png"" alt=""enter image description here"" /></a></p>
<p>The expected output will be:</p>
<pre><code>layer[0] = [H [q0], X [q1]]
layer[1] = [H [q1]]
layer[2] = [cnot [q0] [q1]]
layer[3] = [H [q0]]
layer[4] = [measure [q0]]
layer[5] = [measure [q1]]
</code></pre>
<p>Is there a Qiskit function to achieve this? If not, suggestions to implement this task are also welcomed.</p>
<p>Thanks!</p>
",qc,way decompose quantum circuit layers p example take following circuit input either qasm qiskit pre code qreg q 2 creg c 2 x q 1 h q 0 h q 1 cx q 0 q 1 h q 0 measure q 0 gt c 0 measure q 1 gt c 1 p https nofollow noreferrer img https enter image description p expected output pre code layer 0 h q0 x q1 layer 1 h q1 layer 2 cnot q0 q1 layer 3 h q0 layer 4 measure q0 layer 5 measure q1 p qiskit function achieve suggestions implement task also p thanks,"[(0, 0.05786854), (2, 0.20971645), (4, 0.14044124), (6, 0.078761294), (10, 0.13952315), (14, 0.2310209), (16, 0.079034664), (19, 0.06245947)]"
28591,28592.0,2022-10-18 14:08:08,0,130,"<p><a href=""https://i.sstatic.net/rpjBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/rpjBM.png"" alt=""enter image description here"" /></a></p>
<p>Here [+1] represents X gate for qutrit. How the Counter value is coming to 5? which is the measurement outcome(q0q1q2-&gt;102). Even for (q0q1q2-&gt;101) also counter value is 5.
In total, for this 3 qutrits composite system, we have access to 27 levels (0,1,_ _ _ 26) but the counter value is not exceeding more than 7(q0q1q2-&gt;222).</p>
<p>Can someone suggest how to get true levels in Cirq for qudits after measurement? as well as what does counter value represent?</p>
",Interpretation of Qudit measurement output in cirq,<cirq><quantum-state>,1,0,,,"Interpretation of Qudit measurement output in cirq <p><a href=""https://i.sstatic.net/rpjBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/rpjBM.png"" alt=""enter image description here"" /></a></p>
<p>Here [+1] represents X gate for qutrit. How the Counter value is coming to 5? which is the measurement outcome(q0q1q2-&gt;102). Even for (q0q1q2-&gt;101) also counter value is 5.
In total, for this 3 qutrits composite system, we have access to 27 levels (0,1,_ _ _ 26) but the counter value is not exceeding more than 7(q0q1q2-&gt;222).</p>
<p>Can someone suggest how to get true levels in Cirq for qudits after measurement? as well as what does counter value represent?</p>
",qc,interpretation qudit measurement output cirq p https nofollow noreferrer img https enter image description p represents x gate qutrit counter value coming 5 measurement outcome gt 102 even gt 101 also counter value total 3 qutrits composite system access 27 levels 26 counter value exceeding 7 gt 222 p someone suggest get true levels cirq qudits measurement well counter value represent,"[(0, 0.06182274), (4, 0.17921521), (6, 0.07109457), (9, 0.16340142), (10, 0.019193515), (12, 0.01689035), (13, 0.20139953), (16, 0.034193464), (18, 0.25096047)]"
28661,28665.0,2022-10-24 17:19:44,1,289,"<p>The most basic example of entanglement is when we have 2 qubits, where q0 is in the |+&gt; state and connects to q1 (which is in the |0&gt; state) with a cnot gate:</p>
<p><a href=""https://i.sstatic.net/dZoXt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dZoXt.png"" alt=""example taken out of qiskit textbook"" /></a></p>
<p>The state is entangled, as the resulting outputs are either 00 or 11 with equal probability, which cannot be replicated with two unconnected qubits. (Statevector is [<span class=""math-container"">$ \frac{1}{\sqrt{2}}$</span> 0 0 <span class=""math-container"">$\frac{1}{\sqrt{2}}$</span>])
However, q1 is initially not in a superposition (but |0&gt; instead)</p>
<p>So is there a quantum circuit where all qubits are initially in a superposition, but the state is entangled?</p>
<p>If yes, could you please provide an example?
If no, could you explain why?
If nobody knows yet, then is there a general consensus on what likely is the case?</p>
<p>Also a side question:
Would we consider q1 to be in superposition after the cnot gate? Since it kinda is.</p>
","Can you construct a quantum circuit where all qubits are initially in a superposition, but there is still entanglement?",<quantum-gate><quantum-state><entanglement><superposition>,3,0,,,"Can you construct a quantum circuit where all qubits are initially in a superposition, but there is still entanglement? <p>The most basic example of entanglement is when we have 2 qubits, where q0 is in the |+&gt; state and connects to q1 (which is in the |0&gt; state) with a cnot gate:</p>
<p><a href=""https://i.sstatic.net/dZoXt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dZoXt.png"" alt=""example taken out of qiskit textbook"" /></a></p>
<p>The state is entangled, as the resulting outputs are either 00 or 11 with equal probability, which cannot be replicated with two unconnected qubits. (Statevector is [<span class=""math-container"">$ \frac{1}{\sqrt{2}}$</span> 0 0 <span class=""math-container"">$\frac{1}{\sqrt{2}}$</span>])
However, q1 is initially not in a superposition (but |0&gt; instead)</p>
<p>So is there a quantum circuit where all qubits are initially in a superposition, but the state is entangled?</p>
<p>If yes, could you please provide an example?
If no, could you explain why?
If nobody knows yet, then is there a general consensus on what likely is the case?</p>
<p>Also a side question:
Would we consider q1 to be in superposition after the cnot gate? Since it kinda is.</p>
",qc,construct quantum circuit qubits initially superposition still entanglement p basic example entanglement 2 qubits q0 gt state connects q1 gt state cnot gate p https nofollow noreferrer img https example taken qiskit textbook p state entangled resulting outputs either 00 11 equal probability replicated two unconnected qubits statevector span 1 2 0 0 span 1 2 however q1 initially superposition gt instead p quantum circuit qubits initially superposition state entangled p yes could please provide example could explain nobody knows yet general consensus likely case p also side question would consider q1 superposition cnot gate since kinda,"[(2, 0.06483264), (3, 0.07012624), (4, 0.16322626), (6, 0.012263799), (7, 0.016848609), (8, 0.1306532), (16, 0.04409424), (18, 0.49669167)]"
28711,,2022-10-28 06:42:51,1,146,"<p>Given an arbitrary <a href=""https://tensorcircuit.readthedocs.io/en/latest/search.html?q=c.state%28%29&amp;check_keywords=yes&amp;area=default"" rel=""nofollow noreferrer"">TensorCircuit</a>, is there a convient way to get a plot of the circuit?</p>
",Plot circuit within TensorCircuit,<quantum-circuit><tensor-networks><tensorcircuit>,2,0,,,"Plot circuit within TensorCircuit <p>Given an arbitrary <a href=""https://tensorcircuit.readthedocs.io/en/latest/search.html?q=c.state%28%29&amp;check_keywords=yes&amp;area=default"" rel=""nofollow noreferrer"">TensorCircuit</a>, is there a convient way to get a plot of the circuit?</p>
",qc,plot circuit within tensorcircuit p given arbitrary https 28 29 amp amp nofollow noreferrer tensorcircuit convient way get plot circuit,"[(4, 0.5466945), (9, 0.16257282), (14, 0.10139342), (15, 0.12891069), (16, 0.05261342)]"
28955,28962.0,2022-11-11 03:29:45,2,96,"<p>For the following sample circuit I want to reduce the number of gates in pytket:
<a href=""https://i.sstatic.net/IOSXl.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IOSXl.png"" alt=""pytket circuit before"" /></a></p>
<p>for example, I know:</p>
<ul>
<li>Adjacent Rx gates can be merged</li>
<li>CZ is self-inverse and cancels itself out because any Hermitian gate is &quot;self-canceling&quot;</li>
<li>A zero-angle rotation does nothing and the corresponding gate can be removed</li>
<li>The effect of RZ is eliminated by measurement because we are just rotating around the z-axis which does not change the measurement in the z-basis.</li>
</ul>
<p><code>from pytket import Circuit, OpType</code></p>
<pre><code>circ = Circuit(3)
circ.Rx(0.92, 0).CX(1, 2).Rx(-0.18, 0)   
circ.CZ(0, 1).Ry(0.11, 2).CZ(0, 1)       
circ.add_gate(OpType.XXPhase, 0.6, [0, 1])
circ.add_gate(OpType.YYPhase, 0, [0, 1])     
circ.add_gate(OpType.ZZPhase, -0.84, [0, 1])
circ.Rx(0.03, 0).Rz(-0.9, 1).Ry(0.13, 2)    
</code></pre>
",Does pytket have an optimization pass that removes gate-inverse pairs & identity rotations & redundant gates and/or merges rotations?,<optimization><pytket>,1,0,,,"Does pytket have an optimization pass that removes gate-inverse pairs & identity rotations & redundant gates and/or merges rotations? <p>For the following sample circuit I want to reduce the number of gates in pytket:
<a href=""https://i.sstatic.net/IOSXl.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IOSXl.png"" alt=""pytket circuit before"" /></a></p>
<p>for example, I know:</p>
<ul>
<li>Adjacent Rx gates can be merged</li>
<li>CZ is self-inverse and cancels itself out because any Hermitian gate is &quot;self-canceling&quot;</li>
<li>A zero-angle rotation does nothing and the corresponding gate can be removed</li>
<li>The effect of RZ is eliminated by measurement because we are just rotating around the z-axis which does not change the measurement in the z-basis.</li>
</ul>
<p><code>from pytket import Circuit, OpType</code></p>
<pre><code>circ = Circuit(3)
circ.Rx(0.92, 0).CX(1, 2).Rx(-0.18, 0)   
circ.CZ(0, 1).Ry(0.11, 2).CZ(0, 1)       
circ.add_gate(OpType.XXPhase, 0.6, [0, 1])
circ.add_gate(OpType.YYPhase, 0, [0, 1])     
circ.add_gate(OpType.ZZPhase, -0.84, [0, 1])
circ.Rx(0.03, 0).Rz(-0.9, 1).Ry(0.13, 2)    
</code></pre>
",qc,pytket optimization pass removes pairs identity rotations redundant gates merges rotations p following sample circuit want reduce number gates pytket https nofollow noreferrer img https pytket circuit p example know ul li adjacent rx gates merged li cz cancels hermitian gate quot quot li rotation nothing corresponding gate removed li effect rz eliminated measurement rotating around change measurement p code pytket import circuit optype pre code circ circuit 3 0 1 2 0 0 1 2 0 1 0 1 0 0 1 0 1 0 1 2,"[(0, 0.045833826), (2, 0.2585535), (3, 0.046346363), (4, 0.05384794), (9, 0.2654143), (13, 0.013543196), (14, 0.2718619), (16, 0.01213401), (19, 0.03119493)]"
28993,,2022-11-14 16:09:09,0,61,"<br>
After I read the ""[Quantum computing foundations](https://learn.microsoft.com/en-us/training/paths/quantum-computing-fundamentals/)
of Microsoft I would like to be sure I understand a little the things. So, I code my own Groover search. The problem is simple. My code wants retrieve the index in array given a value. The very simple example is I have an array [""A"", ""B"", ""C"", ""D""] and the given value is ""B"" so I would like have as result 1.
<p>I have 2 errors for the moment:
<br>
First, I have an error with my function to retrieve the index, but I think it's a  little thing.
<a href=""https://i.sstatic.net/c6Hlf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/c6Hlf.png"" alt=""enter image description here"" /></a></p>
<br>
Secondly (and most important), the output register returns me an array of bits matching with ""A"" and not ""B"" as I wish.
<p><a href=""https://i.sstatic.net/2YIv4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2YIv4.png"" alt=""enter image description here"" /></a></p>
<p>Someone could help me understand what I am doing wrong.</p>
<pre><code>namespace MyFirstOwnGroversSearch {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Measurement;


    
    @EntryPoint()
    operation MyFirstOwnGroverSearch() : Unit {
        Message(&quot;Hello quantum world!&quot;);
        let values = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
        let asciiValues = [65,66,67,68];
        let asciiValuesAsBooleans = [IntAsBoolArray(65,7), IntAsBoolArray(66,7), IntAsBoolArray(67,7), IntAsBoolArray(68,7)];

        use (registerToBeMatched) = (Qubit[7]);
        // prepare registerToBeMatched -&gt; apply an X gate to each qubit that corresponds to &quot;true&quot; bit in the bit string.
        let targetValue = 66; // &quot;B&quot;;
        let targetValueAsBool = IntAsBoolArray(targetValue,7); 
        ApplyPauliFromBitString(PauliX, true, asciiValuesAsBooleans[0], registerToBeMatched);
        
        use target = Qubit();

        let markingOracle = MarkEquality(_,_,_); // put target to 1 if arrays bits are equals ( first and second args)
        let phaseOracle = ApplyMarkingOracleAsPhaseOracle(markingOracle,_,registerToBeMatched);

        // Define the parameters of the search.
        // Each character is described using 7 bits (or qubits).
        let nQubits = 7;
        // The search space is all bit strings of length nQubits.
        let searchSpaceSize = 2 ^ (nQubits);
        let nSolutions = 1;
        // The number of iterations can be computed using a formula.
        let nIterations = Round(PI() / 4.0 * Sqrt(IntAsDouble(searchSpaceSize) / IntAsDouble(nSolutions)));

        mutable answer = new Bool[nQubits];
        use (register, output) = (Qubit[nQubits], Qubit());
        mutable isCorrect = false;
        repeat {
            RunGroversSearch(register, phaseOracle, nIterations);
            let res = MultiM(register);
            // Check whether the result is correct.
            markingOracle(register, registerToBeMatched, output);
            if (MResetZ(output) == One) {
                set isCorrect = true;
                set answer = ResultArrayAsBoolArray(res);
            }
            ResetAll(register);
        } until (isCorrect);

        // Convert the answer to readable format (actual graph coloring).
        let resultAsInt = BoolArrayAsInt(answer);
        let idx = IndexOf(isEqual(resultAsInt,targetValue), asciiValues);
        //Message(<span class=""math-container"">$""result: {BoolArrayAsInt(answer)} and index is {idx}"");
    Message($</span>&quot;result: {BoolArrayAsInt(answer)}&quot;);
        Reset(output);
        ResetAll(registerToBeMatched);
    }

    operation isEqual (a: Int, b: Int) :  Bool {
        return (a == b);
    }
    
    operation MarkEquality(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl {
        within {
            for (q0, q1) in Zipped(c0, c1) {
                // Compute XOR of bits q0 and q1 in place (storing it in q1).
                CNOT(q0, q1);
            }
        } apply {
            // If all computed XORs are 0, the bit strings are equal - flip the state of the target.
            (ControlledOnInt(0, X))(c1, target);
        }
    }    

    operation ApplyMarkingOracleAsPhaseOracle(
        markingOracle : ((Qubit[], Qubit[], Qubit) =&gt; Unit is Adj), 
        c0 : Qubit[],
        c1 : Qubit[]
    ) : Unit is Adj {
        use target = Qubit();
        within {
            // Put the target qubit into the |-⟩ state.
            X(target);
            H(target);
        } apply {
            // Apply the marking oracle; since the target is in the |-⟩ state,
            // flipping the target if the register state satisfies the condition 
            // will apply a -1 relative phase to the register state.
            markingOracle(c0, c1, target);
        }
    }

    operation RunGroversSearch(register : Qubit[], phaseOracle : ((Qubit[]) =&gt; Unit is Adj), iterations : Int) : Unit {
        ApplyToEach(H, register);
        
        for _ in 1 .. iterations {
            phaseOracle(register);
            within {
                ApplyToEachA(H, register);
                ApplyToEachA(X, register);
            } apply {
                Controlled Z(Most(register), Tail(register));
            }
        }
    }

}
<span class=""math-container"">```</span>
</code></pre>
",My First Own Grover Search with Q#,<q#>,0,3,,,"My First Own Grover Search with Q# <br>
After I read the ""[Quantum computing foundations](https://learn.microsoft.com/en-us/training/paths/quantum-computing-fundamentals/)
of Microsoft I would like to be sure I understand a little the things. So, I code my own Groover search. The problem is simple. My code wants retrieve the index in array given a value. The very simple example is I have an array [""A"", ""B"", ""C"", ""D""] and the given value is ""B"" so I would like have as result 1.
<p>I have 2 errors for the moment:
<br>
First, I have an error with my function to retrieve the index, but I think it's a  little thing.
<a href=""https://i.sstatic.net/c6Hlf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/c6Hlf.png"" alt=""enter image description here"" /></a></p>
<br>
Secondly (and most important), the output register returns me an array of bits matching with ""A"" and not ""B"" as I wish.
<p><a href=""https://i.sstatic.net/2YIv4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2YIv4.png"" alt=""enter image description here"" /></a></p>
<p>Someone could help me understand what I am doing wrong.</p>
<pre><code>namespace MyFirstOwnGroversSearch {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Measurement;


    
    @EntryPoint()
    operation MyFirstOwnGroverSearch() : Unit {
        Message(&quot;Hello quantum world!&quot;);
        let values = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
        let asciiValues = [65,66,67,68];
        let asciiValuesAsBooleans = [IntAsBoolArray(65,7), IntAsBoolArray(66,7), IntAsBoolArray(67,7), IntAsBoolArray(68,7)];

        use (registerToBeMatched) = (Qubit[7]);
        // prepare registerToBeMatched -&gt; apply an X gate to each qubit that corresponds to &quot;true&quot; bit in the bit string.
        let targetValue = 66; // &quot;B&quot;;
        let targetValueAsBool = IntAsBoolArray(targetValue,7); 
        ApplyPauliFromBitString(PauliX, true, asciiValuesAsBooleans[0], registerToBeMatched);
        
        use target = Qubit();

        let markingOracle = MarkEquality(_,_,_); // put target to 1 if arrays bits are equals ( first and second args)
        let phaseOracle = ApplyMarkingOracleAsPhaseOracle(markingOracle,_,registerToBeMatched);

        // Define the parameters of the search.
        // Each character is described using 7 bits (or qubits).
        let nQubits = 7;
        // The search space is all bit strings of length nQubits.
        let searchSpaceSize = 2 ^ (nQubits);
        let nSolutions = 1;
        // The number of iterations can be computed using a formula.
        let nIterations = Round(PI() / 4.0 * Sqrt(IntAsDouble(searchSpaceSize) / IntAsDouble(nSolutions)));

        mutable answer = new Bool[nQubits];
        use (register, output) = (Qubit[nQubits], Qubit());
        mutable isCorrect = false;
        repeat {
            RunGroversSearch(register, phaseOracle, nIterations);
            let res = MultiM(register);
            // Check whether the result is correct.
            markingOracle(register, registerToBeMatched, output);
            if (MResetZ(output) == One) {
                set isCorrect = true;
                set answer = ResultArrayAsBoolArray(res);
            }
            ResetAll(register);
        } until (isCorrect);

        // Convert the answer to readable format (actual graph coloring).
        let resultAsInt = BoolArrayAsInt(answer);
        let idx = IndexOf(isEqual(resultAsInt,targetValue), asciiValues);
        //Message(<span class=""math-container"">$""result: {BoolArrayAsInt(answer)} and index is {idx}"");
    Message($</span>&quot;result: {BoolArrayAsInt(answer)}&quot;);
        Reset(output);
        ResetAll(registerToBeMatched);
    }

    operation isEqual (a: Int, b: Int) :  Bool {
        return (a == b);
    }
    
    operation MarkEquality(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl {
        within {
            for (q0, q1) in Zipped(c0, c1) {
                // Compute XOR of bits q0 and q1 in place (storing it in q1).
                CNOT(q0, q1);
            }
        } apply {
            // If all computed XORs are 0, the bit strings are equal - flip the state of the target.
            (ControlledOnInt(0, X))(c1, target);
        }
    }    

    operation ApplyMarkingOracleAsPhaseOracle(
        markingOracle : ((Qubit[], Qubit[], Qubit) =&gt; Unit is Adj), 
        c0 : Qubit[],
        c1 : Qubit[]
    ) : Unit is Adj {
        use target = Qubit();
        within {
            // Put the target qubit into the |-⟩ state.
            X(target);
            H(target);
        } apply {
            // Apply the marking oracle; since the target is in the |-⟩ state,
            // flipping the target if the register state satisfies the condition 
            // will apply a -1 relative phase to the register state.
            markingOracle(c0, c1, target);
        }
    }

    operation RunGroversSearch(register : Qubit[], phaseOracle : ((Qubit[]) =&gt; Unit is Adj), iterations : Int) : Unit {
        ApplyToEach(H, register);
        
        for _ in 1 .. iterations {
            phaseOracle(register);
            within {
                ApplyToEachA(H, register);
                ApplyToEachA(X, register);
            } apply {
                Controlled Z(Most(register), Tail(register));
            }
        }
    }

}
<span class=""math-container"">```</span>
</code></pre>
",qc,first grover search q br read quantum computing foundations https microsoft would like sure understand little things code groover search problem simple code wants retrieve index array given value simple example array b c given value b would like result 1 p 2 errors moment br first error function retrieve index think little thing https nofollow noreferrer img https enter image description br secondly important output register returns array bits matching b wish p https nofollow noreferrer img https enter image description p someone could help understand pre code namespace myfirstowngroverssearch open open open open open open open entrypoint operation myfirstowngroversearch unit message quot hello quantum world quot let values quot quot quot b quot quot c quot quot quot let asciivalues let asciivaluesasbooleans intasboolarray intasboolarray intasboolarray intasboolarray use registertobematched qubit 7 prepare registertobematched gt apply x gate qubit corresponds quot true quot bit bit string let targetvalue 66 quot b quot let targetvalueasbool intasboolarray applypaulifrombitstring paulix true asciivaluesasbooleans 0 registertobematched use target qubit let markingoracle markequality put target 1 arrays bits equals first second args let phaseoracle applymarkingoracleasphaseoracle markingoracle registertobematched define parameters search character described using 7 bits qubits let nqubits 7 search space bit strings length nqubits let searchspacesize 2 nqubits let nsolutions 1 number iterations computed using formula let niterations round pi sqrt intasdouble searchspacesize intasdouble nsolutions mutable answer new bool nqubits use register output qubit nqubits qubit mutable iscorrect false repeat rungroverssearch register phaseoracle niterations let res multim register check whether result correct markingoracle register registertobematched output mresetz output one set iscorrect true set answer resultarrayasboolarray res resetall register iscorrect convert answer readable format actual graph coloring let resultasint boolarrayasint answer let idx indexof isequal resultasint targetvalue asciivalues span result boolarrayasint answer index idx message quot result boolarrayasint answer quot reset output resetall registertobematched operation isequal int b int bool return b operation markequality c0 qubit c1 qubit target qubit unit within q0 q1 zipped c0 c1 compute xor bits q0 q1 place storing q1 cnot q0 q1 apply computed xors 0 bit strings equal flip state target controlledonint 0 x c1 target operation applymarkingoracleasphaseoracle markingoracle qubit qubit qubit gt unit adj c0 qubit c1 qubit unit adj use target qubit within put target qubit state x target h target apply apply marking oracle since target state flipping target register state satisfies condition apply relative phase register state markingoracle c0 c1 target operation rungroverssearch register qubit phaseoracle qubit gt unit adj iterations int unit applytoeach h register 1 iterations phaseoracle register within applytoeacha h register applytoeacha x register apply controlled z register tail register span,"[(0, 0.13179857), (2, 0.01687887), (4, 0.0806392), (6, 0.020952933), (7, 0.03741616), (10, 0.023512166), (13, 0.14580496), (14, 0.0673588), (16, 0.08936225), (17, 0.020114344), (18, 0.28704107), (19, 0.07890204)]"
29002,,2022-11-15 21:59:26,1,212,"<p>I was trying to run a QAOA job using the below script:</p>
<pre><code>job = provider.runtime.run(
    program_id=program_id,
    options=options,
    inputs=runtime_inputs,
)

from qiskit.tools import job_monitor
job_monitor(job)
</code></pre>
<p>But I'm getting the below error:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Cell In [24], line 73
     65 #Now, we run the program using the provider.
     67 job = provider.runtime.run(
     68     program_id=program_id,
     69     options=options,
     70     inputs=runtime_inputs,
     71 )
---&gt; 73 job_monitor(job)
     75 #Job Status: job has successfully run
     77 print(f&quot;Job id: {job.job_id()}&quot;)

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:89, in job_monitor(job, interval, quiet, output, line_discipline)
     86 else:
     87     _interval_set = True
---&gt; 89 _text_checker(
     90     job, interval, _interval_set, quiet=quiet, output=output, line_discipline=line_discipline
     91 )

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:49, in _text_checker(job, interval, _interval_set, quiet, output, line_discipline)
     46 msg = status.value
     48 if status.name == &quot;QUEUED&quot;:
---&gt; 49     msg += &quot; (%s)&quot; % job.queue_position()
     50     if job.queue_position() is None:
     51         interval = 2

AttributeError: 'RuntimeJob' object has no attribute 'queue_position'
</code></pre>
<p>In the IBM portal, it is showing my job is queued, but my code is failing at job_monitor(job)</p>
<p><a href=""https://i.sstatic.net/aKKpv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/aKKpv.png"" alt=""enter image description here"" /></a></p>
<p>Can anyone suggest what can be done for this issue?</p>
",'RuntimeJob' object has no attribute 'queue_position',<qiskit><ibm-quantum-devices><qiskit-runtime>,0,4,,,"'RuntimeJob' object has no attribute 'queue_position' <p>I was trying to run a QAOA job using the below script:</p>
<pre><code>job = provider.runtime.run(
    program_id=program_id,
    options=options,
    inputs=runtime_inputs,
)

from qiskit.tools import job_monitor
job_monitor(job)
</code></pre>
<p>But I'm getting the below error:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Cell In [24], line 73
     65 #Now, we run the program using the provider.
     67 job = provider.runtime.run(
     68     program_id=program_id,
     69     options=options,
     70     inputs=runtime_inputs,
     71 )
---&gt; 73 job_monitor(job)
     75 #Job Status: job has successfully run
     77 print(f&quot;Job id: {job.job_id()}&quot;)

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:89, in job_monitor(job, interval, quiet, output, line_discipline)
     86 else:
     87     _interval_set = True
---&gt; 89 _text_checker(
     90     job, interval, _interval_set, quiet=quiet, output=output, line_discipline=line_discipline
     91 )

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:49, in _text_checker(job, interval, _interval_set, quiet, output, line_discipline)
     46 msg = status.value
     48 if status.name == &quot;QUEUED&quot;:
---&gt; 49     msg += &quot; (%s)&quot; % job.queue_position()
     50     if job.queue_position() is None:
     51         interval = 2

AttributeError: 'RuntimeJob' object has no attribute 'queue_position'
</code></pre>
<p>In the IBM portal, it is showing my job is queued, but my code is failing at job_monitor(job)</p>
<p><a href=""https://i.sstatic.net/aKKpv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/aKKpv.png"" alt=""enter image description here"" /></a></p>
<p>Can anyone suggest what can be done for this issue?</p>
",qc,object attribute p trying run qaoa job using script pre code job import job p getting error pre code attributeerror traceback recent call last cell 24 line 73 65 run program using provider 67 job 68 69 70 71 gt 73 job 75 job status job successfully run 77 print f quot job id quot file job interval quiet output 86 else 87 true gt 89 90 job interval 91 file job interval quiet output 46 msg 48 quot queued quot gt 49 msg quot quot 50 none 51 interval 2 attributeerror object attribute p ibm portal showing job queued code failing job p https nofollow noreferrer img https enter image description p anyone suggest done issue,"[(0, 0.5525913), (4, 0.12088762), (5, 0.057393465), (6, 0.0420615), (12, 0.025638651), (16, 0.021462068), (19, 0.17077897)]"
29062,,2022-11-19 10:05:29,1,46,"<p>I am aware that there are algorithms that can clone states with unit fidelity but with a positive probability of failure. What would be the best known algorithms to create a perfect clone of an arbitrary unknown single qubit state with minimum probability of failure?</p>
",What are the best algorithms to achieve probabilistic quantum cloning?,<no-cloning-theorem><cloning>,0,1,,,"What are the best algorithms to achieve probabilistic quantum cloning? <p>I am aware that there are algorithms that can clone states with unit fidelity but with a positive probability of failure. What would be the best known algorithms to create a perfect clone of an arbitrary unknown single qubit state with minimum probability of failure?</p>
",qc,best algorithms achieve probabilistic quantum cloning p aware algorithms clone states unit fidelity positive probability failure would best known algorithms create perfect clone arbitrary unknown single qubit state minimum probability failure,"[(5, 0.14462636), (8, 0.31497693), (11, 0.060759567), (16, 0.028037319), (17, 0.118338436), (18, 0.32877308)]"
29113,,2022-11-24 02:12:13,1,208,"<p>I have a following example problem in Cirq, representing a very simple operator given by</p>
<p><span class=""math-container"">$$
\hat{H} = a^\dagger_0a_2 + a_0a^\dagger_1 + 0.9\, a^\dagger_0a_1a^\dagger_2a^\dagger_3 + a^\dagger_0a_1a_2a_3
$$</span></p>
<p>and an example ansatz, obtaining the expectation value in the end.</p>
<pre><code>import cirq
import numpy as np
import openfermion as of
import sympy

H = of.FermionOperator('0^ 2', 1) + of.FermionOperator('0 1^', 1) + of.FermionOperator('0^ 1 2^ 3^', 0.9) \
    + of.FermionOperator('0^ 1 2 3', -0.1)

H = of.FermionOperator('0^ 1', 1) + of.FermionOperator('0 2^', 1) + of.FermionOperator('0^ 2 1^ 3^', 0.9) \
    + of.FermionOperator('0^ 2 1 3', -0.1)

Hmat = of.get_sparse_operator(H, n_qubits=4).A

print(H)
print(sorted(np.linalg.eig(Hmat)[0]))

circuit = cirq.Circuit()
qubits = cirq.LineQubit.range(4)

alpha = sympy.Symbol('alpha')
beta = sympy.Symbol('beta')
gamma = sympy.Symbol('gamma')
delta = sympy.Symbol('delta')

circuit.append(cirq.ry(alpha).on(qubits[0]))
circuit.append(cirq.ry(beta).on(qubits[1]))
circuit.append(cirq.ry(gamma).on(qubits[2]))
circuit.append(cirq.ry(delta).on(qubits[3]))
circuit.append(cirq.X(qubits[2]).controlled_by(qubits[0]))

full_circ = cirq.resolve_parameters(circuit, {'alpha': 1, 'beta': 1, 'gamma': 1, 'delta': 1})
sv = full_circ.final_state_vector()

print(sv)
print(sv.conj().T @ Hmat @ sv)
</code></pre>
<p>This Cirq code is giving the following output:</p>
<pre><code>1.0 [0 2^] +
1 [0^ 1] +
-0.1 [0^ 2 1 3] +
0.9 [0^ 2 1^ 3^]
[(-0.547722557505166+5.551115123125783e-17j), (-7.994927024450326e-17-0.5477225575051663j), 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, (4.85722573273506e-17+0.5477225575051662j), (0.5477225575051663+0j)]
[0.5931328 +0.j 0.32402992+0.j 0.32402992+0.j 0.17701835+0.j
 0.32402992+0.j 0.17701835+0.j 0.17701835+0.j 0.09670557+0.j
 0.17701835+0.j 0.09670557+0.j 0.32402992+0.j 0.17701835+0.j
 0.09670557+0.j 0.05283049+0.j 0.17701835+0.j 0.09670557+0.j]
(0.11040049624731614+0j)
</code></pre>
<p>I'd like to be able to rewrite this example into an equivalent code in Qiskit, where, as I'm aware is a different spin-orbital mapping, so that I switched 1st and 2nd qubits in ansatz. The code looks like this:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit import ParameterVector
from qiskit.quantum_info import Statevector
from qiskit_nature.operators.second_quantization import FermionicOp
import numpy as np

H = FermionicOp([('+_0 -_2', 1), ('-_0 +_1', 1), ('+_0 -_1 +_2 +_3', 0.9), ('+_0 -_1 -_2 -_3', -0.1)], register_length=4)


print(H)
print(sorted(np.linalg.eig(H.to_matrix().A)[0]))

ansatz = QuantumCircuit(4)
p = ParameterVector('theta', length=4)
for i, q in enumerate(ansatz.qubits):
    ansatz.ry(p[i], q)
ansatz.cx(0, 1)

params = [1]*4

vecA = Statevector(ansatz.bind_parameters(params)).data

print(vecA)
print((vecA.conj().T @ H.to_matrix() @ vecA).real)
</code></pre>
<p>But the output is different:</p>
<pre><code>Fermionic Operator
register length=4, number terms=4
  (1+0j) * ( +_0 -_2 )
+ (1+0j) * ( -_0 +_1 )
+ (0.9+0j) * ( +_0 -_1 +_2 +_3 )
+ (-0.1+0j) * ( +_0 -_1 -_2 -_3 )
[(-0.547722557505166+5.551115123125783e-17j), (-7.997636868137208e-17-0.5477225575051663j), 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, (4.85722573273506e-17+0.5477225575051662j), (0.5477225575051663+0j)]
[0.5931328 +0.j 0.17701835+0.j 0.32402992+0.j 0.32402992+0.j
 0.32402992+0.j 0.09670557+0.j 0.17701835+0.j 0.17701835+0.j
 0.32402992+0.j 0.09670557+0.j 0.17701835+0.j 0.17701835+0.j
 0.17701835+0.j 0.05283049+0.j 0.09670557+0.j 0.09670557+0.j]
-0.02401568533842704
</code></pre>
<p>Why are the expectation values different? Is the operator rewritten in an incorrect way or does the ansatz need different treatment, when rewritten to Qiskit?</p>
",How to rewrite this Cirq problem into Qiskit?,<qiskit><programming><cirq><openfermion>,0,0,,,"How to rewrite this Cirq problem into Qiskit? <p>I have a following example problem in Cirq, representing a very simple operator given by</p>
<p><span class=""math-container"">$$
\hat{H} = a^\dagger_0a_2 + a_0a^\dagger_1 + 0.9\, a^\dagger_0a_1a^\dagger_2a^\dagger_3 + a^\dagger_0a_1a_2a_3
$$</span></p>
<p>and an example ansatz, obtaining the expectation value in the end.</p>
<pre><code>import cirq
import numpy as np
import openfermion as of
import sympy

H = of.FermionOperator('0^ 2', 1) + of.FermionOperator('0 1^', 1) + of.FermionOperator('0^ 1 2^ 3^', 0.9) \
    + of.FermionOperator('0^ 1 2 3', -0.1)

H = of.FermionOperator('0^ 1', 1) + of.FermionOperator('0 2^', 1) + of.FermionOperator('0^ 2 1^ 3^', 0.9) \
    + of.FermionOperator('0^ 2 1 3', -0.1)

Hmat = of.get_sparse_operator(H, n_qubits=4).A

print(H)
print(sorted(np.linalg.eig(Hmat)[0]))

circuit = cirq.Circuit()
qubits = cirq.LineQubit.range(4)

alpha = sympy.Symbol('alpha')
beta = sympy.Symbol('beta')
gamma = sympy.Symbol('gamma')
delta = sympy.Symbol('delta')

circuit.append(cirq.ry(alpha).on(qubits[0]))
circuit.append(cirq.ry(beta).on(qubits[1]))
circuit.append(cirq.ry(gamma).on(qubits[2]))
circuit.append(cirq.ry(delta).on(qubits[3]))
circuit.append(cirq.X(qubits[2]).controlled_by(qubits[0]))

full_circ = cirq.resolve_parameters(circuit, {'alpha': 1, 'beta': 1, 'gamma': 1, 'delta': 1})
sv = full_circ.final_state_vector()

print(sv)
print(sv.conj().T @ Hmat @ sv)
</code></pre>
<p>This Cirq code is giving the following output:</p>
<pre><code>1.0 [0 2^] +
1 [0^ 1] +
-0.1 [0^ 2 1 3] +
0.9 [0^ 2 1^ 3^]
[(-0.547722557505166+5.551115123125783e-17j), (-7.994927024450326e-17-0.5477225575051663j), 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, (4.85722573273506e-17+0.5477225575051662j), (0.5477225575051663+0j)]
[0.5931328 +0.j 0.32402992+0.j 0.32402992+0.j 0.17701835+0.j
 0.32402992+0.j 0.17701835+0.j 0.17701835+0.j 0.09670557+0.j
 0.17701835+0.j 0.09670557+0.j 0.32402992+0.j 0.17701835+0.j
 0.09670557+0.j 0.05283049+0.j 0.17701835+0.j 0.09670557+0.j]
(0.11040049624731614+0j)
</code></pre>
<p>I'd like to be able to rewrite this example into an equivalent code in Qiskit, where, as I'm aware is a different spin-orbital mapping, so that I switched 1st and 2nd qubits in ansatz. The code looks like this:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit import ParameterVector
from qiskit.quantum_info import Statevector
from qiskit_nature.operators.second_quantization import FermionicOp
import numpy as np

H = FermionicOp([('+_0 -_2', 1), ('-_0 +_1', 1), ('+_0 -_1 +_2 +_3', 0.9), ('+_0 -_1 -_2 -_3', -0.1)], register_length=4)


print(H)
print(sorted(np.linalg.eig(H.to_matrix().A)[0]))

ansatz = QuantumCircuit(4)
p = ParameterVector('theta', length=4)
for i, q in enumerate(ansatz.qubits):
    ansatz.ry(p[i], q)
ansatz.cx(0, 1)

params = [1]*4

vecA = Statevector(ansatz.bind_parameters(params)).data

print(vecA)
print((vecA.conj().T @ H.to_matrix() @ vecA).real)
</code></pre>
<p>But the output is different:</p>
<pre><code>Fermionic Operator
register length=4, number terms=4
  (1+0j) * ( +_0 -_2 )
+ (1+0j) * ( -_0 +_1 )
+ (0.9+0j) * ( +_0 -_1 +_2 +_3 )
+ (-0.1+0j) * ( +_0 -_1 -_2 -_3 )
[(-0.547722557505166+5.551115123125783e-17j), (-7.997636868137208e-17-0.5477225575051663j), 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, 0j, (4.85722573273506e-17+0.5477225575051662j), (0.5477225575051663+0j)]
[0.5931328 +0.j 0.17701835+0.j 0.32402992+0.j 0.32402992+0.j
 0.32402992+0.j 0.09670557+0.j 0.17701835+0.j 0.17701835+0.j
 0.32402992+0.j 0.09670557+0.j 0.17701835+0.j 0.17701835+0.j
 0.17701835+0.j 0.05283049+0.j 0.09670557+0.j 0.09670557+0.j]
-0.02401568533842704
</code></pre>
<p>Why are the expectation values different? Is the operator rewritten in an incorrect way or does the ansatz need different treatment, when rewritten to Qiskit?</p>
",qc,rewrite cirq problem qiskit p following example problem cirq representing simple operator given p span h p example ansatz obtaining expectation value pre code import cirq import numpy np import openfermion import sympy h 2 1 0 1 1 1 2 3 h 1 1 0 1 2 2 1 3 hmat h print h print sorted hmat 0 circuit qubits 4 alpha beta gamma delta alpha qubits 0 beta qubits 1 gamma qubits 2 delta qubits 3 qubits 2 qubits 0 circuit 1 1 1 1 sv print sv print hmat sv p cirq code giving following output pre code 0 1 1 2 1 3 2 0j 0j 0j 0j 0j 0j 0j 0j 0j 0j 0j 0j p like able rewrite example equivalent code qiskit aware different mapping switched 1st 2nd qubits ansatz code looks like pre code qiskit import quantumcircuit import parametervector import statevector import fermionicop import numpy np h fermionicop 1 1 print h print sorted 0 ansatz quantumcircuit 4 p parametervector q enumerate p q 0 1 params 1 4 veca statevector params print veca print veca p output different pre code fermionic operator register number 0j 0j 0j 0j 0j 0j 0j 0j 0j 0j 0j 0j p expectation values different operator rewritten incorrect way ansatz need different treatment rewritten qiskit,"[(0, 0.45117873), (2, 0.24247949), (7, 0.18998148), (14, 0.065414764), (16, 0.016043978), (18, 0.03422852)]"
29143,,2022-11-26 10:23:10,1,82,"<p>The [[3,0,2]] code, stabilizers are X<sub>1</sub>Z<sub>2</sub>I<sub>3</sub>,Z<sub>1</sub>X<sub>2</sub>Z<sub>3</sub>,I<sub>1</sub>Z<sub>2</sub>X<sub>3</sub>.
Use the circuit to decode and measure stabilizers:
<a href=""https://i.sstatic.net/VFrJH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VFrJH.png"" alt=""enter image description here"" /></a></p>
<p>As for amplitude damping error syndrome,  use <span class=""math-container"">$\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \sqrt{1-\gamma}\end{array}\right], \quad\left[\begin{array}{cc}0 &amp; \sqrt{\gamma} \\ 0 &amp; 0\end{array}\right], \gamma=1$</span></p>
<p><span class=""math-container"">$\rho \prime=E_0 \rho E_0^{\dagger}+E_1 \rho E_1^{\dagger}$</span>, <span class=""math-container"">$
\langle S\rangle_\rho=\operatorname{Tr}(\rho S)
$</span> to compute.</p>
<p>The result is :
<span class=""math-container"">$$
\begin{array}{c|c|c|c}
 &amp; \mathrm{X}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{I}_{\mathrm{c}} &amp; \mathrm{Z}_{\mathrm{a}} \mathrm{X}_{\mathrm{b}} \mathrm{Z}_{\mathrm{c}} &amp; \mathrm{I}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{X}_{\mathrm{c}} \\
\hline ap_{a} &amp; 0 &amp; 0 &amp; +1 \\
\hline ap_{b} &amp; 0 &amp; 0 &amp; 0 \\
\hline ap_{c} &amp; +1 &amp; 0 &amp; 0\\
\end{array}
$$</span></p>
<p>Then simulate the circuit in qiskit.
Add  amplitude damping error to one of the three qubit, get the result:</p>
<p>Add  amplitude damping error to q0(a):</p>
<p><a href=""https://i.sstatic.net/yOHqa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yOHqa.png"" alt=""enter image description here"" /></a> which is the same as error syndrome.(The stabilizer order is from top to bottom)</p>
<p>But for q1(b):</p>
<p><a href=""https://i.sstatic.net/hRQ1g.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hRQ1g.png"" alt=""enter image description here"" /></a>
The result is +1  0  0  , but the syndrome is 0  0  0.</p>
<p>For q2(c):</p>
<p><a href=""https://i.sstatic.net/hmQs7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hmQs7.png"" alt=""enter image description here"" /></a>
The result is +1  +1  0  , but the syndrome is +1  0  0.</p>
<p>Why the results don't correspond ?
And where my mistake was in the process?</p>
<pre><code>#add identity gates to qubit and add amplitude damping error
p = 1
amplitude_error = amplitude_damping_error(p)
noise_model = NoiseModel()
noise_model.add_quantum_error(amplitude_error, ['id'], [2])

simulator = provider.get_backend('ibmq_qasm_simulator')
noise_job = execute(circuit, backend=simulator, shots=8192, optimization_level = 0, noise_model=noise_model)
result = noise_job.result()  
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
",Why QECC amplitude damping error syndrome and qiskit simulation are different?,<qiskit><error-correction><stabilizer-code>,0,4,,,"Why QECC amplitude damping error syndrome and qiskit simulation are different? <p>The [[3,0,2]] code, stabilizers are X<sub>1</sub>Z<sub>2</sub>I<sub>3</sub>,Z<sub>1</sub>X<sub>2</sub>Z<sub>3</sub>,I<sub>1</sub>Z<sub>2</sub>X<sub>3</sub>.
Use the circuit to decode and measure stabilizers:
<a href=""https://i.sstatic.net/VFrJH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VFrJH.png"" alt=""enter image description here"" /></a></p>
<p>As for amplitude damping error syndrome,  use <span class=""math-container"">$\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \sqrt{1-\gamma}\end{array}\right], \quad\left[\begin{array}{cc}0 &amp; \sqrt{\gamma} \\ 0 &amp; 0\end{array}\right], \gamma=1$</span></p>
<p><span class=""math-container"">$\rho \prime=E_0 \rho E_0^{\dagger}+E_1 \rho E_1^{\dagger}$</span>, <span class=""math-container"">$
\langle S\rangle_\rho=\operatorname{Tr}(\rho S)
$</span> to compute.</p>
<p>The result is :
<span class=""math-container"">$$
\begin{array}{c|c|c|c}
 &amp; \mathrm{X}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{I}_{\mathrm{c}} &amp; \mathrm{Z}_{\mathrm{a}} \mathrm{X}_{\mathrm{b}} \mathrm{Z}_{\mathrm{c}} &amp; \mathrm{I}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{X}_{\mathrm{c}} \\
\hline ap_{a} &amp; 0 &amp; 0 &amp; +1 \\
\hline ap_{b} &amp; 0 &amp; 0 &amp; 0 \\
\hline ap_{c} &amp; +1 &amp; 0 &amp; 0\\
\end{array}
$$</span></p>
<p>Then simulate the circuit in qiskit.
Add  amplitude damping error to one of the three qubit, get the result:</p>
<p>Add  amplitude damping error to q0(a):</p>
<p><a href=""https://i.sstatic.net/yOHqa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yOHqa.png"" alt=""enter image description here"" /></a> which is the same as error syndrome.(The stabilizer order is from top to bottom)</p>
<p>But for q1(b):</p>
<p><a href=""https://i.sstatic.net/hRQ1g.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hRQ1g.png"" alt=""enter image description here"" /></a>
The result is +1  0  0  , but the syndrome is 0  0  0.</p>
<p>For q2(c):</p>
<p><a href=""https://i.sstatic.net/hmQs7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hmQs7.png"" alt=""enter image description here"" /></a>
The result is +1  +1  0  , but the syndrome is +1  0  0.</p>
<p>Why the results don't correspond ?
And where my mistake was in the process?</p>
<pre><code>#add identity gates to qubit and add amplitude damping error
p = 1
amplitude_error = amplitude_damping_error(p)
noise_model = NoiseModel()
noise_model.add_quantum_error(amplitude_error, ['id'], [2])

simulator = provider.get_backend('ibmq_qasm_simulator')
noise_job = execute(circuit, backend=simulator, shots=8192, optimization_level = 0, noise_model=noise_model)
result = noise_job.result()  
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
",qc,qecc amplitude damping error syndrome qiskit simulation different p code stabilizers x sub 1 z sub 2 sub 3 z sub 1 x sub 2 z sub 3 sub 1 z sub 2 x sub 3 use circuit decode measure stabilizers https nofollow noreferrer img https enter image description p amplitude damping error syndrome use span array cc 1 amp 0 0 amp array array cc 0 amp 0 amp array p span span tr p result span array amp x z b c amp z x b z c amp z b x c amp 0 amp 0 amp b amp 0 amp 0 amp 0 c amp amp 0 amp array p simulate circuit qiskit add amplitude damping error one three qubit get result p add amplitude damping error q0 p https nofollow noreferrer img https enter image description error syndrome stabilizer order top bottom p q1 b p https nofollow noreferrer img https enter image description result 0 0 syndrome 0 0 p q2 c p https nofollow noreferrer img https enter image description result 0 syndrome 0 p results correspond mistake process pre code add identity gates qubit add amplitude damping error p 1 p noisemodel 2 simulator execute circuit 0 result counts counts,"[(0, 0.027373608), (2, 0.15444854), (4, 0.2664075), (5, 0.122683465), (10, 0.030890087), (14, 0.043529674), (15, 0.33074528), (16, 0.010406227), (17, 0.012987235)]"
29148,,2022-11-27 05:11:53,1,27,"<p>I've been following upon this document for device calibration.
<a href=""https://qiskit.org/documentation/experiments/tutorials/calibrating_real_device.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/experiments/tutorials/calibrating_real_device.html</a></p>
<p>Is there any way to specify the pulse shape for the RoughFrequencyCal experiment? I think the default pulse shape being used is the Gaussian. I wanted to use a different pulse shape for the experiment. Any idea on how can I achieve this?</p>
",Specifying the shape of pulse in RoughFrequencyCal,<qiskit><openpulse><ibm-q-experience>,0,0,,,"Specifying the shape of pulse in RoughFrequencyCal <p>I've been following upon this document for device calibration.
<a href=""https://qiskit.org/documentation/experiments/tutorials/calibrating_real_device.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/experiments/tutorials/calibrating_real_device.html</a></p>
<p>Is there any way to specify the pulse shape for the RoughFrequencyCal experiment? I think the default pulse shape being used is the Gaussian. I wanted to use a different pulse shape for the experiment. Any idea on how can I achieve this?</p>
",qc,specifying shape pulse roughfrequencycal p following upon document device calibration https nofollow noreferrer https p way specify pulse shape roughfrequencycal experiment think default pulse shape used gaussian wanted use different pulse shape experiment idea achieve,"[(0, 0.14988111), (4, 0.26201907), (14, 0.5381036), (16, 0.04517506)]"
29182,,2022-11-30 00:52:49,1,206,"<p>I want to implement a Hadamard gate on a single qubit in a register.<br />
Given two qubits<br />
q0 := <span class=""math-container"">$|0\rangle$</span> and<br />
q1 := <span class=""math-container"">$|+\rangle$</span><br />
I would like to use a Hadamard gate on the first qubit (q0).</p>
<p>My intuition is that</p>
<ul>
<li><p>using Hadamard on the first qubit and building the register afterwards:<br />
Apply: q0' = Had(q0) = <span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} \\ 1/\sqrt{2} \end{bmatrix}</span><br />
Build Register: reg0 := q0' tensor q1 = <span class=""math-container"">\begin{bmatrix} 1/2 \\ 1/2 \\ 1/2 \\ 1/2 \end{bmatrix}</span><br />
would lead to the same result as</p>
</li>
<li><p>using Hadamard Gate (<strong>H</strong>) on the first qubit after building the register:<br />
Building the register: reg1 := q0 tensor q1 = <span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} \\ 0 \\ 1/\sqrt{2} \\ 0 \end{bmatrix}</span>
Apply: <strong>H</strong> tensor <strong>I</strong> mul reg1 =<br />
<span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 \\
            0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} \\
            1/\sqrt{2} &amp;&amp; 0 &amp;&amp; -1/\sqrt{2} &amp;&amp; 0 \\
            0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; -1/\sqrt{2} \end{bmatrix}</span>
mul
reg1
= <span class=""math-container"">\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}</span>
So this is not the same.
But what would be same is when we swap <strong>H</strong> and <strong>I</strong>:
<strong>I</strong> tensor <strong>H</strong> mul reg1 =
<span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 0 \\
1/\sqrt{2} &amp;&amp; -1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 0 \\
0 &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 1/\sqrt{2} \\
0 &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} &amp;&amp; -1/\sqrt{2} \end{bmatrix}</span>
mul
reg1
=
<span class=""math-container"">\begin{bmatrix} 1/2 \\ 1/2 \\ 1/2 \\ 1/2 \end{bmatrix}</span></p>
</li>
</ul>
<p>I found a <a href=""https://learn.microsoft.com/en-us/azure/quantum/concepts-circuits"" rel=""nofollow noreferrer"">Microsoft article</a> and I think it has something to with that. It says:</p>
<p><a href=""https://i.sstatic.net/OKaAu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/OKaAu.png"" alt=""Microsoft Article"" /></a></p>
<p>I think this is weird. Can someone explain it?</p>
",Apply Hadamard on a qubit in a register,<programming><quantum-gate><hadamard>,1,3,,,"Apply Hadamard on a qubit in a register <p>I want to implement a Hadamard gate on a single qubit in a register.<br />
Given two qubits<br />
q0 := <span class=""math-container"">$|0\rangle$</span> and<br />
q1 := <span class=""math-container"">$|+\rangle$</span><br />
I would like to use a Hadamard gate on the first qubit (q0).</p>
<p>My intuition is that</p>
<ul>
<li><p>using Hadamard on the first qubit and building the register afterwards:<br />
Apply: q0' = Had(q0) = <span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} \\ 1/\sqrt{2} \end{bmatrix}</span><br />
Build Register: reg0 := q0' tensor q1 = <span class=""math-container"">\begin{bmatrix} 1/2 \\ 1/2 \\ 1/2 \\ 1/2 \end{bmatrix}</span><br />
would lead to the same result as</p>
</li>
<li><p>using Hadamard Gate (<strong>H</strong>) on the first qubit after building the register:<br />
Building the register: reg1 := q0 tensor q1 = <span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} \\ 0 \\ 1/\sqrt{2} \\ 0 \end{bmatrix}</span>
Apply: <strong>H</strong> tensor <strong>I</strong> mul reg1 =<br />
<span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 \\
            0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} \\
            1/\sqrt{2} &amp;&amp; 0 &amp;&amp; -1/\sqrt{2} &amp;&amp; 0 \\
            0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; -1/\sqrt{2} \end{bmatrix}</span>
mul
reg1
= <span class=""math-container"">\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}</span>
So this is not the same.
But what would be same is when we swap <strong>H</strong> and <strong>I</strong>:
<strong>I</strong> tensor <strong>H</strong> mul reg1 =
<span class=""math-container"">\begin{bmatrix} 1/\sqrt{2} &amp;&amp; 1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 0 \\
1/\sqrt{2} &amp;&amp; -1/\sqrt{2} &amp;&amp; 0 &amp;&amp; 0 \\
0 &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} &amp;&amp; 1/\sqrt{2} \\
0 &amp;&amp; 0 &amp;&amp; 1/\sqrt{2} &amp;&amp; -1/\sqrt{2} \end{bmatrix}</span>
mul
reg1
=
<span class=""math-container"">\begin{bmatrix} 1/2 \\ 1/2 \\ 1/2 \\ 1/2 \end{bmatrix}</span></p>
</li>
</ul>
<p>I found a <a href=""https://learn.microsoft.com/en-us/azure/quantum/concepts-circuits"" rel=""nofollow noreferrer"">Microsoft article</a> and I think it has something to with that. It says:</p>
<p><a href=""https://i.sstatic.net/OKaAu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/OKaAu.png"" alt=""Microsoft Article"" /></a></p>
<p>I think this is weird. Can someone explain it?</p>
",qc,apply hadamard qubit register p want implement hadamard gate single qubit br given two qubits br q0 span br q1 span br would like use hadamard gate first qubit q0 p intuition ul li p using hadamard first qubit building register afterwards br apply q0 q0 span bmatrix 2 2 bmatrix br build register reg0 q0 tensor q1 span bmatrix bmatrix br would lead result li p using hadamard gate strong h first qubit building register br building register reg1 q0 tensor q1 span bmatrix 2 0 2 0 bmatrix apply strong h tensor strong mul reg1 br span bmatrix 2 amp amp 0 amp amp 2 amp amp 0 0 amp amp 2 amp amp 0 amp amp 2 2 amp amp 0 amp amp 2 amp amp 0 0 amp amp 2 amp amp 0 amp amp 2 bmatrix mul reg1 span bmatrix 1 0 0 0 bmatrix would swap strong h strong strong tensor strong h mul reg1 span bmatrix 2 amp amp 2 amp amp 0 amp amp 0 2 amp amp 2 amp amp 0 amp amp 0 0 amp amp 0 amp amp 2 amp amp 2 0 amp amp 0 amp amp 2 amp amp 2 bmatrix mul reg1 span bmatrix bmatrix p found https nofollow noreferrer microsoft article think something says p https nofollow noreferrer img https microsoft article p think weird someone explain,"[(2, 0.18419838), (4, 0.05436338), (10, 0.022293296), (13, 0.10558254), (15, 0.45889246), (16, 0.040593583), (18, 0.1335014)]"
29208,29239.0,2022-12-02 10:37:22,4,403,"<p>I am trying to import the noise model of an IBM 'large' device. I don't have access to the devices with more than 7 qubits so it doesn't allow me to import the backend and then do</p>
<p><code>noise_model = NoiseModel.from_backend(backend)</code></p>
<p>Is there another way I can import the noise model from those devices?</p>
",How to import noise model from IBM qiskit real device?,<qiskit><simulation><noise>,1,0,,,"How to import noise model from IBM qiskit real device? <p>I am trying to import the noise model of an IBM 'large' device. I don't have access to the devices with more than 7 qubits so it doesn't allow me to import the backend and then do</p>
<p><code>noise_model = NoiseModel.from_backend(backend)</code></p>
<p>Is there another way I can import the noise model from those devices?</p>
",qc,import noise model ibm qiskit real device p trying import noise model ibm device access devices 7 qubits allow import backend p code backend p another way import noise model devices,"[(0, 0.20332286), (6, 0.03366604), (14, 0.62276), (16, 0.13512269)]"
29288,29291.0,2022-12-07 16:38:31,2,270,"<p>Premise: I am not sure whether I am missing something theoretically.</p>
<p>Given a circuit creating a GHZ state over 3 qubits, say q1, q2 and q3. If I do not consider q3 and perform a state tomography over q1 and q2, then intuitively, I should get a Bell state as output, i.e. <span class=""math-container"">$|\Phi^+\rangle\langle\Phi^+|$</span>.</p>
<p>Nevertheless the output is the following matrix:</p>
<pre><code>[[ 0.5, -0. ,  0. , -0. ],
   [-0. ,  0. ,  0. , -0. ],
   [ 0. ,  0. ,  0. ,  0. ],
   [-0. , -0. ,  0. ,  0.5]]
</code></pre>
<p>I am not observing q3. I also tried to reset it with the command <code>circuit.reset(2)</code>.</p>
<p>This is how may look one of the 9 circuits prepared for the tomography:</p>
<p><a href=""https://i.sstatic.net/8MtjB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8MtjB.png"" alt=""enter image description here"" /></a></p>
<p>EDIT: <a href=""https://algassert.com/quantum/2015/09/02/Partially-Erasing-Entanglement-with-Measurement.html#:%7E:text=A%20Bell%20pair%20is%20a,1%E2%88%9A2%7C111%E2%9F%A9."" rel=""nofollow noreferrer"">here</a> there is a partial answer, however, I'd still like to understand what is the meaning of my output matrix.</p>
",State tomography on a subsystem of the GHZ state,<qiskit><quantum-state><state-tomography><bell-basis>,2,0,,,"State tomography on a subsystem of the GHZ state <p>Premise: I am not sure whether I am missing something theoretically.</p>
<p>Given a circuit creating a GHZ state over 3 qubits, say q1, q2 and q3. If I do not consider q3 and perform a state tomography over q1 and q2, then intuitively, I should get a Bell state as output, i.e. <span class=""math-container"">$|\Phi^+\rangle\langle\Phi^+|$</span>.</p>
<p>Nevertheless the output is the following matrix:</p>
<pre><code>[[ 0.5, -0. ,  0. , -0. ],
   [-0. ,  0. ,  0. , -0. ],
   [ 0. ,  0. ,  0. ,  0. ],
   [-0. , -0. ,  0. ,  0.5]]
</code></pre>
<p>I am not observing q3. I also tried to reset it with the command <code>circuit.reset(2)</code>.</p>
<p>This is how may look one of the 9 circuits prepared for the tomography:</p>
<p><a href=""https://i.sstatic.net/8MtjB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8MtjB.png"" alt=""enter image description here"" /></a></p>
<p>EDIT: <a href=""https://algassert.com/quantum/2015/09/02/Partially-Erasing-Entanglement-with-Measurement.html#:%7E:text=A%20Bell%20pair%20is%20a,1%E2%88%9A2%7C111%E2%9F%A9."" rel=""nofollow noreferrer"">here</a> there is a partial answer, however, I'd still like to understand what is the meaning of my output matrix.</p>
",qc,state tomography subsystem ghz state p premise sure whether missing something p given circuit creating ghz state 3 qubits say q1 q2 q3 consider q3 perform state tomography q1 q2 intuitively get bell state output span p nevertheless output following matrix pre code 0 p observing q3 also tried reset command code 2 p may look one 9 circuits prepared tomography p https nofollow noreferrer img https enter image description p edit https 7e 20bell 20pair 20is e2 88 9a2 7c111 e2 9f a9 nofollow noreferrer partial answer however still like understand meaning output,"[(2, 0.019805636), (4, 0.2446583), (6, 0.017333867), (9, 0.07763796), (12, 0.034813404), (13, 0.15043126), (14, 0.25227466), (16, 0.023388814), (18, 0.16906561)]"
29303,29314.0,2022-12-08 19:26:51,1,458,"<p>I created a circuit in qiskit and then converted it into a QASM string. When I try to make a circuit out of the QASM string I get the error:</p>
<pre><code>QasmError: &quot;Cannot find gate definition for 'mcphase', line 3 file circuit.qasm&quot;
</code></pre>
<p>I used the following code to convert a circuit into a QASM file:</p>
<pre><code>qasm_file_name = &quot;circuit.qasm&quot;
main_circuit.qasm(formatted=True, filename=qasm_file_name)

</code></pre>
<p>Then I loaded the QASM string like so:</p>
<pre><code>circuit = QuantumCircuit.from_qasm_file(qasm_file_name)
</code></pre>
<p>After this, I get the QASM error above.</p>
<p>I believe <code>mcphase</code> gate was generated automatically during the conversion to QASM. It seems the mapping from a qiskit circuit to QASM string is not reversible. How this can be fixed?</p>
<p>This is a toy QASM file that produces the error.</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;
gate ccircuit_87_dg q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,q10,q11,q12,q13,q14,q15,q16,q17,q18,q19,q20 { cx q0,q4; cu(pi/2,0,pi,0) q0,q4; mcphase(pi/8) q0,q4; cu(pi/2,0,pi,0) q0,q6;}
</code></pre>
<p>This is a full qiskit version printout:</p>
<pre><code>{'qiskit-terra': '0.22.2', 'qiskit-aer': '0.11.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.19.2', 'qiskit': '0.39.2', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}
</code></pre>
<p>Ubuntu 20.04.5 LTS</p>
",Conversion error: from a QISKIT circuit to a QASM string and back,<qiskit><circuit-construction><quantum-circuit><qasm>,2,8,,,"Conversion error: from a QISKIT circuit to a QASM string and back <p>I created a circuit in qiskit and then converted it into a QASM string. When I try to make a circuit out of the QASM string I get the error:</p>
<pre><code>QasmError: &quot;Cannot find gate definition for 'mcphase', line 3 file circuit.qasm&quot;
</code></pre>
<p>I used the following code to convert a circuit into a QASM file:</p>
<pre><code>qasm_file_name = &quot;circuit.qasm&quot;
main_circuit.qasm(formatted=True, filename=qasm_file_name)

</code></pre>
<p>Then I loaded the QASM string like so:</p>
<pre><code>circuit = QuantumCircuit.from_qasm_file(qasm_file_name)
</code></pre>
<p>After this, I get the QASM error above.</p>
<p>I believe <code>mcphase</code> gate was generated automatically during the conversion to QASM. It seems the mapping from a qiskit circuit to QASM string is not reversible. How this can be fixed?</p>
<p>This is a toy QASM file that produces the error.</p>
<pre><code>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;
gate ccircuit_87_dg q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,q10,q11,q12,q13,q14,q15,q16,q17,q18,q19,q20 { cx q0,q4; cu(pi/2,0,pi,0) q0,q4; mcphase(pi/8) q0,q4; cu(pi/2,0,pi,0) q0,q6;}
</code></pre>
<p>This is a full qiskit version printout:</p>
<pre><code>{'qiskit-terra': '0.22.2', 'qiskit-aer': '0.11.1', 'qiskit-ignis': '0.7.0', 'qiskit-ibmq-provider': '0.19.2', 'qiskit': '0.39.2', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}
</code></pre>
<p>Ubuntu 20.04.5 LTS</p>
",qc,conversion error qiskit circuit qasm string back p created circuit qiskit converted qasm string try make circuit qasm string get error pre code qasmerror quot find gate definition line 3 file quot p used following code convert circuit qasm file pre code quot quot p loaded qasm string like pre code circuit p get qasm error p believe code mcphase gate generated automatically conversion qasm seems mapping qiskit circuit qasm string reversible fixed p toy qasm file produces pre code openqasm include quot quot gate q0 q1 q2 q3 q4 q5 q6 q7 q8 q9 q10 q11 q12 q13 q14 q15 q16 q17 q18 q19 q20 cx q0 q4 cu q0 q4 mcphase q0 q4 cu q0 q6 p full qiskit version printout pre code none none none none p ubuntu lts,"[(0, 0.10791606), (8, 0.01221696), (9, 0.019595448), (14, 0.6668225), (16, 0.0872873), (18, 0.024024526), (19, 0.08096661)]"
29418,29419.0,2022-12-19 04:23:38,0,104,"<p>I am qurious about the order of ctrl_state</p>
<p>The Quantum Circuit what I expected is this.</p>
<p><a href=""https://i.sstatic.net/49OyB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/49OyB.png"" alt=""enter image description here"" /></a></p>
<p>q1 is controled when '0' and q2 and a3 is controled when '1'</p>
<p>So I wirte code that is</p>
<blockquote>
<p>ctrl_state='011'</p>
</blockquote>
<p>But what I got is this. Why I got oposite form like this...
What is the principle of this.</p>
<p><a href=""https://i.sstatic.net/vY9rG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/vY9rG.png"" alt=""enter image description here"" /></a></p>
<pre><code>from qiskit import*
from qiskit.extensions import UnitaryGate
matrix_V2_2=[[1,0],[0,1]]
Won_gate = UnitaryGate(matrix_V2_2,label='Won').control(num_ctrl_qubits=3, ctrl_state='011')
main_circuit=QuantumCircuit(4,4)
main_circuit.append(Won_gate ,[1,2,3,0])
%matplotlib inline
main_circuit.draw(output='mpl')
</code></pre>
",ctrl_state 'order' of control( ),<qiskit><programming><quantum-gate>,1,0,,,"ctrl_state 'order' of control( ) <p>I am qurious about the order of ctrl_state</p>
<p>The Quantum Circuit what I expected is this.</p>
<p><a href=""https://i.sstatic.net/49OyB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/49OyB.png"" alt=""enter image description here"" /></a></p>
<p>q1 is controled when '0' and q2 and a3 is controled when '1'</p>
<p>So I wirte code that is</p>
<blockquote>
<p>ctrl_state='011'</p>
</blockquote>
<p>But what I got is this. Why I got oposite form like this...
What is the principle of this.</p>
<p><a href=""https://i.sstatic.net/vY9rG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/vY9rG.png"" alt=""enter image description here"" /></a></p>
<pre><code>from qiskit import*
from qiskit.extensions import UnitaryGate
matrix_V2_2=[[1,0],[0,1]]
Won_gate = UnitaryGate(matrix_V2_2,label='Won').control(num_ctrl_qubits=3, ctrl_state='011')
main_circuit=QuantumCircuit(4,4)
main_circuit.append(Won_gate ,[1,2,3,0])
%matplotlib inline
main_circuit.draw(output='mpl')
</code></pre>
",qc,control p qurious order p quantum circuit expected p https nofollow noreferrer img https enter image description p q1 controled 0 q2 a3 controled 1 p wirte code blockquote p p got got oposite form like principle p https nofollow noreferrer img https enter image description pre code qiskit import import unitarygate unitarygate matplotlib inline,"[(0, 0.23179898), (2, 0.031096928), (4, 0.713109), (16, 0.020742098)]"
29575,29576.0,2023-01-05 17:51:03,2,171,"<p><a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.62.062314"" rel=""nofollow noreferrer"">Dur, 2000</a> states that</p>
<blockquote>
<p>(...)But even in the simplest systems, <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi\rangle$</span> are typically not related by LU, and continuous parameters are needed to label all equivalence classes.</p>
</blockquote>
<p>I've found some similar explanation in <a href=""https://dspace.ub.uni-siegen.de/handle/ubsi/1429"" rel=""nofollow noreferrer"">Ritz,2018</a></p>
<blockquote>
<p>(...)The Schmidt
decomposition of a two-qubit state has only one free parameter <span class=""math-container"">$$|\psi\rangle = \sqrt{\lambda_{0}}|00\rangle+\sqrt{\lambda_{1}}|11\rangle \quad ;\lambda_{0}+\lambda_{1}=1 \qquad\tag{2.85}$$</span>
Thus, we can rewrite eq. (2.85) in terms of new parameter <span class=""math-container"">$\theta$</span> as
<span class=""math-container"">$$|\psi\rangle = \cos \theta |00\rangle+\sin \theta|11\rangle  \qquad \qquad \qquad \qquad \quad\tag{2.86}$$</span>
Therefore, any two-qubit state can, under LU, be transformed to Eq. (2.86). Obviously there is still one continuous parameter, i.e. <span class=""math-container"">$θ$</span>, left. Hence, even for the lowest possible dimension
and particles, the number of equivalence classes under LU is infinite.</p>
</blockquote>
<p>I couldn't understand, why any abritary two-qubit states under LU can be transformed to eq. (2.86)? If it's LU transformation, I think we should start from the general form of Unitary matrices itself, but it seems that we choose convinient transformation such that <span class=""math-container"">$\lambda_0 = \cos^2 \theta$</span> and <span class=""math-container"">$\lambda_1 = \sin^2 \theta$</span>. If that so, why does continuous parameter make the number of classes infinte? I feel kinda clueless here.</p>
",Prove that there are infinitely many two-qubit entanglement classes under LU,<quantum-state><entanglement><locc-operation><schmidt-decomposition>,1,2,,,"Prove that there are infinitely many two-qubit entanglement classes under LU <p><a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.62.062314"" rel=""nofollow noreferrer"">Dur, 2000</a> states that</p>
<blockquote>
<p>(...)But even in the simplest systems, <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi\rangle$</span> are typically not related by LU, and continuous parameters are needed to label all equivalence classes.</p>
</blockquote>
<p>I've found some similar explanation in <a href=""https://dspace.ub.uni-siegen.de/handle/ubsi/1429"" rel=""nofollow noreferrer"">Ritz,2018</a></p>
<blockquote>
<p>(...)The Schmidt
decomposition of a two-qubit state has only one free parameter <span class=""math-container"">$$|\psi\rangle = \sqrt{\lambda_{0}}|00\rangle+\sqrt{\lambda_{1}}|11\rangle \quad ;\lambda_{0}+\lambda_{1}=1 \qquad\tag{2.85}$$</span>
Thus, we can rewrite eq. (2.85) in terms of new parameter <span class=""math-container"">$\theta$</span> as
<span class=""math-container"">$$|\psi\rangle = \cos \theta |00\rangle+\sin \theta|11\rangle  \qquad \qquad \qquad \qquad \quad\tag{2.86}$$</span>
Therefore, any two-qubit state can, under LU, be transformed to Eq. (2.86). Obviously there is still one continuous parameter, i.e. <span class=""math-container"">$θ$</span>, left. Hence, even for the lowest possible dimension
and particles, the number of equivalence classes under LU is infinite.</p>
</blockquote>
<p>I couldn't understand, why any abritary two-qubit states under LU can be transformed to eq. (2.86)? If it's LU transformation, I think we should start from the general form of Unitary matrices itself, but it seems that we choose convinient transformation such that <span class=""math-container"">$\lambda_0 = \cos^2 \theta$</span> and <span class=""math-container"">$\lambda_1 = \sin^2 \theta$</span>. If that so, why does continuous parameter make the number of classes infinte? I feel kinda clueless here.</p>
",qc,prove infinitely many entanglement classes lu p https nofollow noreferrer dur 2000 states blockquote p even simplest systems span span typically related lu continuous parameters needed label equivalence p found similar explanation https nofollow noreferrer blockquote p schmidt decomposition state one free parameter span 0 1 0 1 thus rewrite eq terms new parameter span span therefore state lu transformed eq obviously still one continuous parameter span θ left hence even lowest possible dimension particles number equivalence classes lu p could understand abritary states lu transformed eq lu transformation think start general form unitary matrices seems choose convinient transformation span span continuous parameter make number classes infinte feel kinda clueless,"[(2, 0.033970565), (3, 0.4166355), (7, 0.019107997), (8, 0.24370815), (9, 0.2749565), (16, 0.010209268)]"
29618,,2023-01-09 09:57:46,2,135,"<p>I am using stim and sinter to compute the logical error rate of a QEC code.<br />
For the code I am testing, calling the function <code>sinter.collect()</code> triggers the following error:</p>
<pre><code>ValueError                                Traceback (most recent call last)
ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D31, D34, D58, D82, D994'.

In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to `stim.Circuit.detector_error_model(...)`.
From the command line, you can ignore this error by passing the flag `--ignore_decomposition_failures` to `stim analyze_errors`.
 
The function was called with arguments:
collected_qec_stats: List[sinter.TaskStats] = sinter.collect(
     20     num_workers=4,
     21     tasks=qec_tasks,
     22     decoders=['pymatching'],
     23     max_shots=100_000,
     24     max_errors=100,
     25     print_progress=True)
</code></pre>
<p>I was wondering if there is a way to enable the <code>ignore_decomposition_failures</code> from sinter API. If not, would this be possible by extending sinter API?
(the latter question might be more suitable as an issue in stim's repo)</p>
<p>What are the implications of ignoring decomposition failures in the computation of the logical error rates?</p>
",How to enable ignore_decomposition_failures in sinter.collect()?,<stim>,1,0,,,"How to enable ignore_decomposition_failures in sinter.collect()? <p>I am using stim and sinter to compute the logical error rate of a QEC code.<br />
For the code I am testing, calling the function <code>sinter.collect()</code> triggers the following error:</p>
<pre><code>ValueError                                Traceback (most recent call last)
ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D31, D34, D58, D82, D994'.

In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to `stim.Circuit.detector_error_model(...)`.
From the command line, you can ignore this error by passing the flag `--ignore_decomposition_failures` to `stim analyze_errors`.
 
The function was called with arguments:
collected_qec_stats: List[sinter.TaskStats] = sinter.collect(
     20     num_workers=4,
     21     tasks=qec_tasks,
     22     decoders=['pymatching'],
     23     max_shots=100_000,
     24     max_errors=100,
     25     print_progress=True)
</code></pre>
<p>I was wondering if there is a way to enable the <code>ignore_decomposition_failures</code> from sinter API. If not, would this be possible by extending sinter API?
(the latter question might be more suitable as an issue in stim's repo)</p>
<p>What are the implications of ignoring decomposition failures in the computation of the logical error rates?</p>
",qc,enable p using stim sinter compute logical error rate qec br code testing calling function code triggers following error pre code valueerror traceback recent call last valueerror failed decompose errors graphlike components two symptoms error component failed decompose d34 d58 d82 d994 python ignore error passing command line ignore error passing flag stim function called arguments list 20 21 22 23 24 25 p wondering way enable code sinter api would possible extending sinter api latter question might suitable issue stim repo p implications ignoring decomposition failures computation logical error rates,"[(0, 0.15786745), (5, 0.24787317), (6, 0.062744826), (9, 0.08874514), (12, 0.02304674), (14, 0.26986796), (16, 0.016489835), (19, 0.13198675)]"
29711,,2023-01-16 12:54:26,1,95,"<p>I'm studying about the surface code in quantum computing.
I'm targeting NxN lattice surface code.
While I'm reading this following paper; <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/aa5918/pdf"" rel=""nofollow noreferrer"">https://iopscience.iop.org/article/10.1088/1367-2630/aa5918/pdf</a> ; I really wonder how many holes (that occur because of fabrication error) a specific code distance 'd' surface code can handle. In the research paper, they only handle 1 defect in the surface code.</p>
<p>If you have any references about this question, please let me know.</p>
",How do we know specific surface code has defected?,<stabilizer-code><surface-code>,1,0,,,"How do we know specific surface code has defected? <p>I'm studying about the surface code in quantum computing.
I'm targeting NxN lattice surface code.
While I'm reading this following paper; <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/aa5918/pdf"" rel=""nofollow noreferrer"">https://iopscience.iop.org/article/10.1088/1367-2630/aa5918/pdf</a> ; I really wonder how many holes (that occur because of fabrication error) a specific code distance 'd' surface code can handle. In the research paper, they only handle 1 defect in the surface code.</p>
<p>If you have any references about this question, please let me know.</p>
",qc,know specific surface code defected p studying surface code quantum computing targeting nxn lattice surface code reading following paper https nofollow noreferrer https really wonder many holes occur fabrication error specific code distance surface code handle research paper handle 1 defect surface p references question please let,"[(4, 0.15435618), (5, 0.38510948), (7, 0.08411129), (8, 0.23546207), (13, 0.055208832), (15, 0.036132626), (16, 0.046607908)]"
29730,,2023-01-17 04:04:59,2,342,"<p>Surface code is one of types of Quantum error correction code.
Also capability of error correction of surface code depends on the code distance.
As I know, if surface code's distance is 5, then it can detect up to 'd-1' (4, in this case) and correct up to '(d-1)/2' (2, in this case) errors. Is this error meaning logical-level error (error cause by logical operation applied on surface code) or physical qubit error occurred by physical error chain to apply logical operation?</p>
<p>Also I want to know what is the exact condition for occurring logical operation error on surface code. What I know is, logical operation can be applied to surface code by applying gates to the same number of physical qubits as code distance. What is the condition for occurring error on this logical operator?</p>
<p>If you have any reference (Research paper) please let me know.</p>
",Can surface code detect and correct physical qubit errors and logical operation error?,<stabilizer-code><surface-code>,1,0,,,"Can surface code detect and correct physical qubit errors and logical operation error? <p>Surface code is one of types of Quantum error correction code.
Also capability of error correction of surface code depends on the code distance.
As I know, if surface code's distance is 5, then it can detect up to 'd-1' (4, in this case) and correct up to '(d-1)/2' (2, in this case) errors. Is this error meaning logical-level error (error cause by logical operation applied on surface code) or physical qubit error occurred by physical error chain to apply logical operation?</p>
<p>Also I want to know what is the exact condition for occurring logical operation error on surface code. What I know is, logical operation can be applied to surface code by applying gates to the same number of physical qubits as code distance. What is the condition for occurring error on this logical operator?</p>
<p>If you have any reference (Research paper) please let me know.</p>
",qc,surface code detect correct physical qubit errors logical operation error p surface code one types quantum error correction code also capability error correction surface code depends code distance know surface code distance 5 detect 4 case correct 2 case errors error meaning error error cause logical operation applied surface code physical qubit error occurred physical error chain apply logical operation p also want know exact condition occurring logical operation error surface code know logical operation applied surface code applying gates number physical qubits code distance condition occurring error logical operator p reference research paper please let,"[(5, 0.8043638), (6, 0.031654306), (8, 0.08005638), (9, 0.021596583), (13, 0.025531713), (16, 0.035341475)]"
29822,,2023-01-23 19:00:28,3,144,"<p>I am looking at the calibration data for IBMQ's washington device (which is published daily) and am finding non-zero values for the field &quot;rz_gate_error_value&quot;.</p>
<p>I used to think that RZ gates are implemented purely in software and have no errors (exactly zero error).</p>
<p>Please help me understand why is it not exactly zero.</p>
<p>Thanks!</p>
",Why is rz gate error not exactly zero in IBMQ washington device?,<quantum-gate><ibm-q-experience>,2,1,,,"Why is rz gate error not exactly zero in IBMQ washington device? <p>I am looking at the calibration data for IBMQ's washington device (which is published daily) and am finding non-zero values for the field &quot;rz_gate_error_value&quot;.</p>
<p>I used to think that RZ gates are implemented purely in software and have no errors (exactly zero error).</p>
<p>Please help me understand why is it not exactly zero.</p>
<p>Thanks!</p>
",qc,rz gate error exactly zero ibmq washington device p looking calibration data ibmq washington device published daily finding values field quot quot p used think rz gates implemented purely software errors exactly zero error p please help understand exactly p thanks,"[(5, 0.08494807), (7, 0.14417517), (8, 0.14912905), (14, 0.39740786), (16, 0.1639655), (19, 0.05670857)]"
29941,,2023-01-30 13:35:00,2,43,"<p>I am using the following code for building a quantum circuit as a custom <code>tf.keras.layers.Layer</code>:</p>
<pre class=""lang-python prettyprint-override""><code>import tensorflow as tf
import tensorflow_quantum as tfq
import numpy as np
import sympy
import cirq


class QuantumLayer(tf.keras.layers.Layer):

  def __init__(self) -&gt; None:
    super(QuantumLayer, self).__init__()
    self.qubits = [cirq.GridQubit(1, 0), cirq.GridQubit(1, 1)]
    self.num_params = 2
    self.params = sympy.symbols(&quot;params0:%d&quot;%self.num_params)
    self.theta = tf.Variable(initial_value=np.random.uniform(0, 2*np.pi, (1, self.num_params)), dtype=&quot;float32&quot;, trainable=True)
    self.operation = tfq.layers.State()
  
  def quantum_circ(self, param):
    c = cirq.Circuit()
    for i in range(len(self.qubits)):
      c += cirq.ry(param[i]).on(self.qubits[i])
    return c

  def __call__(self, inputs):
    res = self.operation(self.quantum_circ(self.params), symbol_names=self.params, 
                         symbol_values=self.theta)
    out = tf.squeeze(tf.abs(res.to_tensor() ** 2))

    return out

layer = QuantumLayer()
inputs = tfq.convert_to_tensor([cirq.Circuit()])
with tf.GradientTape() as tape:
  result = layer(inputs)
grad = tape.gradient(result[1], layer.trainable_variables)
print(grad)


&gt;&gt;&gt; [None]
</code></pre>
<p>I think this is mostly because of the fact that the output <code>res</code> in the <code>class QuantumLayer</code> is a <code>tf.RaggedTensor</code> which cannot be differentiated (Also, mentioned here that the output quantum state is not differentiable, but here I am using the probability of the state of the quantum state to get the output (as shown in the <code>out</code> of the class). Where am I wrong in this case to get the gradient right and how can I achieve this?</p>
",How to take gradient of the `tfq.layers.State` output?,<quantum-state><cirq><quantum-enhanced-machine-learning><quantum-neural-network><tfq>,0,0,,,"How to take gradient of the `tfq.layers.State` output? <p>I am using the following code for building a quantum circuit as a custom <code>tf.keras.layers.Layer</code>:</p>
<pre class=""lang-python prettyprint-override""><code>import tensorflow as tf
import tensorflow_quantum as tfq
import numpy as np
import sympy
import cirq


class QuantumLayer(tf.keras.layers.Layer):

  def __init__(self) -&gt; None:
    super(QuantumLayer, self).__init__()
    self.qubits = [cirq.GridQubit(1, 0), cirq.GridQubit(1, 1)]
    self.num_params = 2
    self.params = sympy.symbols(&quot;params0:%d&quot;%self.num_params)
    self.theta = tf.Variable(initial_value=np.random.uniform(0, 2*np.pi, (1, self.num_params)), dtype=&quot;float32&quot;, trainable=True)
    self.operation = tfq.layers.State()
  
  def quantum_circ(self, param):
    c = cirq.Circuit()
    for i in range(len(self.qubits)):
      c += cirq.ry(param[i]).on(self.qubits[i])
    return c

  def __call__(self, inputs):
    res = self.operation(self.quantum_circ(self.params), symbol_names=self.params, 
                         symbol_values=self.theta)
    out = tf.squeeze(tf.abs(res.to_tensor() ** 2))

    return out

layer = QuantumLayer()
inputs = tfq.convert_to_tensor([cirq.Circuit()])
with tf.GradientTape() as tape:
  result = layer(inputs)
grad = tape.gradient(result[1], layer.trainable_variables)
print(grad)


&gt;&gt;&gt; [None]
</code></pre>
<p>I think this is mostly because of the fact that the output <code>res</code> in the <code>class QuantumLayer</code> is a <code>tf.RaggedTensor</code> which cannot be differentiated (Also, mentioned here that the output quantum state is not differentiable, but here I am using the probability of the state of the quantum state to get the output (as shown in the <code>out</code> of the class). Where am I wrong in this case to get the gradient right and how can I achieve this?</p>
",qc,take gradient output p using following code building quantum circuit custom code pre code import tensorflow tf import tfq import numpy np import sympy import cirq class quantumlayer def self gt none super quantumlayer self 1 0 1 1 2 quot params0 quot 0 2 1 quot float32 quot def self param c range len c param return c def self inputs res 2 return layer quantumlayer inputs tape result layer inputs grad result 1 print grad gt gt gt none p think mostly fact output code res code class quantumlayer code differentiated also mentioned output quantum state differentiable using probability state quantum state get output shown code class wrong case get gradient right achieve,"[(0, 0.6883643), (2, 0.07816234), (8, 0.09957343), (16, 0.010771809), (18, 0.04169477), (19, 0.0801148)]"
29968,,2023-02-01 07:23:34,1,75,"<p>When I submit a parametrized circuit as an input for the mixed operator in <code>QAOAAnsatz</code>, some strange results appear.</p>
<p>For example, when I submit a parametrized circuit with a parameter <code>b</code> as the input for the mixed operator, and set <code>reps=4</code>, the parameters of the circuit are <code>ParameterView([ParameterVectorElement(β[0]), ParameterVectorElement(β[1]), ParameterVectorElement(β[2]), ParameterVectorElement(β[3]), ParameterVectorElement(γ[0]), ParameterVectorElement(γ[1]), ParameterVectorElement(γ[2]), ParameterVectorElement(γ[3])])</code></p>
<p>which is correct because parameter <span class=""math-container"">$\beta$</span> will substitute parameter <code>b</code> in <code>QAOAAnsatz</code>.</p>
<p>But if I transpile this circuit or decompose this circuit, the parameters change to <code>ParameterView([Parameter(b), ParameterVectorElement(β[0]), ParameterVectorElement(β[1]), ParameterVectorElement(β[2]), ParameterVectorElement(β[3]), ParameterVectorElement(γ[0]), ParameterVectorElement(γ[1]), ParameterVectorElement(γ[2]), ParameterVectorElement(γ[3])])</code>.</p>
<p><a href=""https://i.sstatic.net/AvXks.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AvXks.png"" alt=""The change of the parameters"" /></a></p>
<p>Could anyone tell me what is wrong with my code?</p>
",Qiskit: The parameters of the circuits constructed by QAOAAnsatz will change after decomposition and transpilation,<qiskit><qaoa>,0,1,,,"Qiskit: The parameters of the circuits constructed by QAOAAnsatz will change after decomposition and transpilation <p>When I submit a parametrized circuit as an input for the mixed operator in <code>QAOAAnsatz</code>, some strange results appear.</p>
<p>For example, when I submit a parametrized circuit with a parameter <code>b</code> as the input for the mixed operator, and set <code>reps=4</code>, the parameters of the circuit are <code>ParameterView([ParameterVectorElement(β[0]), ParameterVectorElement(β[1]), ParameterVectorElement(β[2]), ParameterVectorElement(β[3]), ParameterVectorElement(γ[0]), ParameterVectorElement(γ[1]), ParameterVectorElement(γ[2]), ParameterVectorElement(γ[3])])</code></p>
<p>which is correct because parameter <span class=""math-container"">$\beta$</span> will substitute parameter <code>b</code> in <code>QAOAAnsatz</code>.</p>
<p>But if I transpile this circuit or decompose this circuit, the parameters change to <code>ParameterView([Parameter(b), ParameterVectorElement(β[0]), ParameterVectorElement(β[1]), ParameterVectorElement(β[2]), ParameterVectorElement(β[3]), ParameterVectorElement(γ[0]), ParameterVectorElement(γ[1]), ParameterVectorElement(γ[2]), ParameterVectorElement(γ[3])])</code>.</p>
<p><a href=""https://i.sstatic.net/AvXks.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AvXks.png"" alt=""The change of the parameters"" /></a></p>
<p>Could anyone tell me what is wrong with my code?</p>
",qc,qiskit parameters circuits constructed qaoaansatz change decomposition transpilation p submit parametrized circuit input mixed operator code qaoaansatz strange results p example submit parametrized circuit parameter code b input mixed operator set code parameters circuit code parameterview parametervectorelement β 0 parametervectorelement β 1 parametervectorelement β 2 parametervectorelement β 3 parametervectorelement γ 0 parametervectorelement γ 1 parametervectorelement γ 2 parametervectorelement γ 3 p correct parameter span substitute parameter code b code qaoaansatz p transpile circuit decompose circuit parameters change code parameterview parameter b parametervectorelement β 0 parametervectorelement β 1 parametervectorelement β 2 parametervectorelement β 3 parametervectorelement γ 0 parametervectorelement γ 1 parametervectorelement γ 2 parametervectorelement γ 3 p https nofollow noreferrer img https change parameters p could anyone tell wrong code,"[(0, 0.13861291), (2, 0.1578158), (3, 0.04253538), (4, 0.07309618), (14, 0.4393809), (16, 0.14736363)]"
29992,,2023-02-02 12:26:15,1,103,"<p>I am trying to run some Monte-Carlo simulations whereby I have to call the TableauSimulator N times and use the measurement results to get an average. Is there any way to parallelise this loop? I am getting this sort of error:</p>
<p>TypeError: cannot pickle 'stim._stim_sse2.TableauSimulator' object</p>
<p>Much appreciated.</p>
",Using stim.TableauSimulator with python multiprocessing,<stim><programming>,1,0,,,"Using stim.TableauSimulator with python multiprocessing <p>I am trying to run some Monte-Carlo simulations whereby I have to call the TableauSimulator N times and use the measurement results to get an average. Is there any way to parallelise this loop? I am getting this sort of error:</p>
<p>TypeError: cannot pickle 'stim._stim_sse2.TableauSimulator' object</p>
<p>Much appreciated.</p>
",qc,using python multiprocessing p trying run simulations whereby call tableausimulator n times use measurement results get average way parallelise loop getting sort error p typeerror pickle object p much,"[(0, 0.1168559), (13, 0.17056414), (14, 0.67237455), (16, 0.03471208)]"
30030,30036.0,2023-02-04 13:57:45,2,145,"<p>Nobody seems to define the term anywhere.  It's in the abstract of <a href=""https://arxiv.org/abs/2212.12372"" rel=""nofollow noreferrer"">&quot;Factoring integers with sublinear resources on a superconducting quantum processor&quot;</a> by Bao Yan, Ziqi Tan, Shijie Wei et alia, 2022.</p>
<blockquote>
<p>Shor's algorithm has seriously challenged information security based on public key cryptosystems. However, to break the widely used RSA-2048 scheme, one needs millions of physical qubits, which is far beyond current technical capabilities. Here, we report a <strong>universal quantum algorithm</strong> for integer factorization by combining the classical lattice reduction with a quantum approximate optimization algorithm (QAOA).</p>
</blockquote>
",What is a universal quantum algorithm?,<quantum-algorithms>,2,0,,,"What is a universal quantum algorithm? <p>Nobody seems to define the term anywhere.  It's in the abstract of <a href=""https://arxiv.org/abs/2212.12372"" rel=""nofollow noreferrer"">&quot;Factoring integers with sublinear resources on a superconducting quantum processor&quot;</a> by Bao Yan, Ziqi Tan, Shijie Wei et alia, 2022.</p>
<blockquote>
<p>Shor's algorithm has seriously challenged information security based on public key cryptosystems. However, to break the widely used RSA-2048 scheme, one needs millions of physical qubits, which is far beyond current technical capabilities. Here, we report a <strong>universal quantum algorithm</strong> for integer factorization by combining the classical lattice reduction with a quantum approximate optimization algorithm (QAOA).</p>
</blockquote>
",qc,universal quantum algorithm p nobody seems define term anywhere abstract https nofollow noreferrer quot factoring integers sublinear resources superconducting quantum processor quot bao yan ziqi tan shijie wei et alia blockquote p shor algorithm seriously challenged information security based public key cryptosystems however break widely used scheme one needs millions physical qubits far beyond current technical capabilities report strong universal quantum algorithm integer factorization combining classical lattice reduction quantum approximate optimization algorithm qaoa,"[(1, 0.04941425), (3, 0.055365544), (7, 0.2910727), (8, 0.28182158), (9, 0.17568526), (13, 0.09395102), (16, 0.016029641), (19, 0.03475563)]"
30090,30124.0,2023-02-07 06:39:55,0,2141,"<p>I do this but it still gives an error for load account</p>
<ul>
<li>IBMQ.delete_account()</li>
<li>IBMQ.active_account()</li>
<li>IBMQ.save_account('myAPI toke ')</li>
<li>IBMQ.save_account('my API toke')</li>
<li>IBMQ.load_account()</li>
</ul>
<p><strong>entire error</strong></p>
<p>HTTPError               Traceback (most recent call last)
C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
277             response = super().request(method, final_url, headers=headers, **kwargs)
--&gt; 278             response.raise_for_status()
279         except RequestException as ex:</p>
<p>C:\111\lib\site-packages\requests\models.py in raise_for_status(self)
1020         if http_error_msg:
-&gt; 1021             raise HTTPError(http_error_msg, response=self)
1022</p>
<p>HTTPError: 403 Client Error: Forbidden for url: <a href=""https://auth.quantum-computing.ibm.com/api/version"" rel=""nofollow noreferrer"">https://auth.quantum-computing.ibm.com/api/version</a></p>
<p>The above exception was the direct cause of the following exception:</p>
<p>RequestsApiError                          Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_297760\485379158.py in 
----&gt; 1 IBMQ.load_account()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in load_account(self)
175         # Explicitly check via a server call, to allow environment auth URLs
176         # contain IBM Quantum Experience v2 URL (but not auth) slipping through.
--&gt; 177         version_info = self._check_api_version(credentials)
178
179         # Check the URL is a valid authentication URL.</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in _check_api_version(credentials)
442         version_finder = VersionClient(credentials.base_url,
443                                        **credentials.connection_parameters())
--&gt; 444         return version_finder.version()
445
446     def _initialize_providers(</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\clients\version.py in version(self)
47                 * <code>api-*</code> (str): The versions of each individual API component
48         &quot;&quot;&quot;
---&gt; 49         return self.client_version_finder.version()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py in version(self)
100         &quot;&quot;&quot;
101         url = self.get_url('version')
--&gt; 102         response = self.session.get(url)
103
104         try:</p>
<p>C:\111\lib\site-packages\requests\sessions.py in get(self, url, **kwargs)
598
599         kwargs.setdefault(&quot;allow_redirects&quot;, True)
--&gt; 600         return self.request(&quot;GET&quot;, url, **kwargs)
601
602     def options(self, url, **kwargs):</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
298                 self._modify_chained_exception_messages(ex)
299
--&gt; 300             raise RequestsApiError(message, status_code) from ex
301
302         return response</p>
<p><strong>I perform this operation, but again it gives an error for load account</strong></p>
",I can't load account on IBM's qiskit,<qiskit><programming><ibm-q-experience><quantum-circuit><qiskit-runtime>,1,10,,,"I can't load account on IBM's qiskit <p>I do this but it still gives an error for load account</p>
<ul>
<li>IBMQ.delete_account()</li>
<li>IBMQ.active_account()</li>
<li>IBMQ.save_account('myAPI toke ')</li>
<li>IBMQ.save_account('my API toke')</li>
<li>IBMQ.load_account()</li>
</ul>
<p><strong>entire error</strong></p>
<p>HTTPError               Traceback (most recent call last)
C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
277             response = super().request(method, final_url, headers=headers, **kwargs)
--&gt; 278             response.raise_for_status()
279         except RequestException as ex:</p>
<p>C:\111\lib\site-packages\requests\models.py in raise_for_status(self)
1020         if http_error_msg:
-&gt; 1021             raise HTTPError(http_error_msg, response=self)
1022</p>
<p>HTTPError: 403 Client Error: Forbidden for url: <a href=""https://auth.quantum-computing.ibm.com/api/version"" rel=""nofollow noreferrer"">https://auth.quantum-computing.ibm.com/api/version</a></p>
<p>The above exception was the direct cause of the following exception:</p>
<p>RequestsApiError                          Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_297760\485379158.py in 
----&gt; 1 IBMQ.load_account()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in load_account(self)
175         # Explicitly check via a server call, to allow environment auth URLs
176         # contain IBM Quantum Experience v2 URL (but not auth) slipping through.
--&gt; 177         version_info = self._check_api_version(credentials)
178
179         # Check the URL is a valid authentication URL.</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in _check_api_version(credentials)
442         version_finder = VersionClient(credentials.base_url,
443                                        **credentials.connection_parameters())
--&gt; 444         return version_finder.version()
445
446     def _initialize_providers(</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\clients\version.py in version(self)
47                 * <code>api-*</code> (str): The versions of each individual API component
48         &quot;&quot;&quot;
---&gt; 49         return self.client_version_finder.version()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py in version(self)
100         &quot;&quot;&quot;
101         url = self.get_url('version')
--&gt; 102         response = self.session.get(url)
103
104         try:</p>
<p>C:\111\lib\site-packages\requests\sessions.py in get(self, url, **kwargs)
598
599         kwargs.setdefault(&quot;allow_redirects&quot;, True)
--&gt; 600         return self.request(&quot;GET&quot;, url, **kwargs)
601
602     def options(self, url, **kwargs):</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
298                 self._modify_chained_exception_messages(ex)
299
--&gt; 300             raise RequestsApiError(message, status_code) from ex
301
302         return response</p>
<p><strong>I perform this operation, but again it gives an error for load account</strong></p>
",qc,ca load account ibm qiskit p still gives error load account ul li li li toke li api toke li p strong entire error p httperror traceback recent call last c request self method url bare kwargs 277 response super method kwargs gt 278 279 except requestexception ex p c self 1020 gt 1021 raise httperror 1022 p httperror 403 client error forbidden url https nofollow noreferrer https p exception direct cause following exception p requestsapierror traceback recent call last gt 1 p c self 175 explicitly check via server call allow environment auth urls 176 contain ibm quantum experience v2 url auth slipping gt 177 credentials 178 179 check url valid authentication p c credentials 442 versionclient 443 gt 444 return 445 446 def p c version self 47 code str versions individual api component 48 quot quot quot gt 49 return p c version self 100 quot quot quot 101 url gt 102 response url 103 104 try p c get self url kwargs 598 599 quot quot true gt 600 return quot get quot url kwargs 601 602 def options self url kwargs p c request self method url bare kwargs 298 ex 299 gt 300 raise requestsapierror message ex 301 302 return response p strong perform operation gives error load account,"[(0, 0.29626927), (4, 0.033600237), (6, 0.041599315), (7, 0.05819105), (8, 0.06621414), (9, 0.033106774), (16, 0.011647101), (17, 0.0133340005), (19, 0.44545218)]"
30143,,2023-02-09 15:00:33,1,153,"<p>I am reading the mechanism of the Rydberg blockade as a quantum gate. For a two-atom system with Rabi frequency <span class=""math-container"">$\Omega$</span>, detuning <span class=""math-container"">$\Delta$</span> and blockade potential <span class=""math-container"">$V$</span>, the system Hamiltonian is given by</p>
<p><span class=""math-container"">$H = \frac{1}{2}(\Omega |01\rangle\langle0r|+\Omega |10\rangle\langle r0|+\Omega |11\rangle{}\langle{1r}|+ \Omega |11\rangle{}\langle{r1}| +\Omega |r1\rangle\langle rr|+\Omega |1r\rangle\langle rr|+ h.c.)-\Delta(|r0\rangle{}\langle{r0}|+|0r\rangle{}\langle{0r}|+|r1\rangle{}\langle{r1}|+|1r\rangle{}\langle{1r}|+2|rr\rangle\langle rr|)+V|rr\rangle{}\langle{rr}|$</span></p>
<p>If the initial state starts from <span class=""math-container"">$|00\rangle$</span>, nothing will change under the Hamiltonian evolution.</p>
<p>If the initial state starts from <span class=""math-container"">$|01\rangle$</span> or <span class=""math-container"">$|10\rangle$</span>, The equivalent Hamiltonian will be a two-level system(assume state <span class=""math-container"">$|01\rangle$</span>):</p>
<p><span class=""math-container"">$H_1 = \frac{1}{2}(\Omega|01\rangle\langle0r|+h.c.)-\Delta |0r\rangle\langle 0r|$</span></p>
<p>If the initial state starts from <span class=""math-container"">$|11\rangle$</span> and <span class=""math-container"">$V$</span> is very large, The equivalent Hamiltonian is still a two-level system with:</p>
<p><span class=""math-container"">$H_2 = \frac{1}{\sqrt{2}}(\Omega|11\rangle\langle \psi|+h.c.)-\Delta |\psi\rangle\langle \psi|$</span></p>
<p>Where <span class=""math-container"">$|\psi \rangle = \frac{1}{\sqrt{2}}(|1r\rangle + |r1\rangle)$</span>. you can find more on page 9 of <a href=""https://arxiv.org/pdf/1908.06101.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1908.06101.pdf</a>.</p>
<p>I am trying to figure out how the detuning terms(with coefficient <span class=""math-container"">$\Delta$</span>) go from <span class=""math-container"">$H$</span> to <span class=""math-container"">$H_2$</span>. If we expand the detuning term in <span class=""math-container"">$H_2$</span>, it will be</p>
<p><span class=""math-container"">$-\frac{1}{2}\Delta(|1r\rangle\langle1r|+|1r\rangle\langle r1|+|r1\rangle\langle1r|+|r1\rangle\langle r1|)
$</span></p>
<p>However, the term <span class=""math-container"">$|1r\rangle\langle r1|$</span> and <span class=""math-container"">$|r1\rangle\langle1r|$</span> don't appear in <span class=""math-container"">$H$</span> explicitly, as we can only find in <span class=""math-container"">$H$</span>:</p>
<p><span class=""math-container"">$-\Delta(|1r\rangle\langle1r|+|r1\rangle\langle r1|)
$</span></p>
<p>Can we just say <span class=""math-container"">$|1r\rangle\langle 1r|+|r1\rangle\langle r1|$</span> equal to <span class=""math-container"">$|1r\rangle\langle r1|+|r1\rangle\langle 1r|$</span> in this system? Or how should we understand the terms out of nowhere？</p>
",Detuning in Rydberg blockade Hamiltonian,<experimental-realization>,0,0,,,"Detuning in Rydberg blockade Hamiltonian <p>I am reading the mechanism of the Rydberg blockade as a quantum gate. For a two-atom system with Rabi frequency <span class=""math-container"">$\Omega$</span>, detuning <span class=""math-container"">$\Delta$</span> and blockade potential <span class=""math-container"">$V$</span>, the system Hamiltonian is given by</p>
<p><span class=""math-container"">$H = \frac{1}{2}(\Omega |01\rangle\langle0r|+\Omega |10\rangle\langle r0|+\Omega |11\rangle{}\langle{1r}|+ \Omega |11\rangle{}\langle{r1}| +\Omega |r1\rangle\langle rr|+\Omega |1r\rangle\langle rr|+ h.c.)-\Delta(|r0\rangle{}\langle{r0}|+|0r\rangle{}\langle{0r}|+|r1\rangle{}\langle{r1}|+|1r\rangle{}\langle{1r}|+2|rr\rangle\langle rr|)+V|rr\rangle{}\langle{rr}|$</span></p>
<p>If the initial state starts from <span class=""math-container"">$|00\rangle$</span>, nothing will change under the Hamiltonian evolution.</p>
<p>If the initial state starts from <span class=""math-container"">$|01\rangle$</span> or <span class=""math-container"">$|10\rangle$</span>, The equivalent Hamiltonian will be a two-level system(assume state <span class=""math-container"">$|01\rangle$</span>):</p>
<p><span class=""math-container"">$H_1 = \frac{1}{2}(\Omega|01\rangle\langle0r|+h.c.)-\Delta |0r\rangle\langle 0r|$</span></p>
<p>If the initial state starts from <span class=""math-container"">$|11\rangle$</span> and <span class=""math-container"">$V$</span> is very large, The equivalent Hamiltonian is still a two-level system with:</p>
<p><span class=""math-container"">$H_2 = \frac{1}{\sqrt{2}}(\Omega|11\rangle\langle \psi|+h.c.)-\Delta |\psi\rangle\langle \psi|$</span></p>
<p>Where <span class=""math-container"">$|\psi \rangle = \frac{1}{\sqrt{2}}(|1r\rangle + |r1\rangle)$</span>. you can find more on page 9 of <a href=""https://arxiv.org/pdf/1908.06101.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1908.06101.pdf</a>.</p>
<p>I am trying to figure out how the detuning terms(with coefficient <span class=""math-container"">$\Delta$</span>) go from <span class=""math-container"">$H$</span> to <span class=""math-container"">$H_2$</span>. If we expand the detuning term in <span class=""math-container"">$H_2$</span>, it will be</p>
<p><span class=""math-container"">$-\frac{1}{2}\Delta(|1r\rangle\langle1r|+|1r\rangle\langle r1|+|r1\rangle\langle1r|+|r1\rangle\langle r1|)
$</span></p>
<p>However, the term <span class=""math-container"">$|1r\rangle\langle r1|$</span> and <span class=""math-container"">$|r1\rangle\langle1r|$</span> don't appear in <span class=""math-container"">$H$</span> explicitly, as we can only find in <span class=""math-container"">$H$</span>:</p>
<p><span class=""math-container"">$-\Delta(|1r\rangle\langle1r|+|r1\rangle\langle r1|)
$</span></p>
<p>Can we just say <span class=""math-container"">$|1r\rangle\langle 1r|+|r1\rangle\langle r1|$</span> equal to <span class=""math-container"">$|1r\rangle\langle r1|+|r1\rangle\langle 1r|$</span> in this system? Or how should we understand the terms out of nowhere？</p>
",qc,detuning rydberg blockade hamiltonian p reading mechanism rydberg blockade quantum gate system rabi frequency span detuning span blockade potential span v system hamiltonian given p span h 1 2 1r r1 r0 0r r1 1r rr p initial state starts span nothing change hamiltonian p initial state starts span span equivalent hamiltonian system assume state span p span 1 2 p initial state starts span span v large equivalent hamiltonian still system p span 1 2 p span 1 2 find page 9 https nofollow noreferrer https p trying figure detuning terms coefficient span go span h span expand detuning term span p span 1 2 p however term span span appear span h explicitly find span h p span p say span equal span system understand terms,"[(1, 0.1232752), (2, 0.06868089), (3, 0.50889444), (4, 0.1702815), (6, 0.021199856), (9, 0.09037402), (16, 0.016245194)]"
30169,,2023-02-11 21:13:15,0,128,"<p>I know there are some good journals that accept quantum computing articles, but unfortunately they charge authors a fee.</p>
<p>Are there any Q1 journals in this field which don't charge authors?</p>
",Is there any Q1 journal for quantum computing that is free for authors?,<resource-request>,0,2,,,"Is there any Q1 journal for quantum computing that is free for authors? <p>I know there are some good journals that accept quantum computing articles, but unfortunately they charge authors a fee.</p>
<p>Are there any Q1 journals in this field which don't charge authors?</p>
",qc,q1 journal quantum computing free authors p know good journals accept quantum computing articles unfortunately charge authors p q1 journals field charge authors,"[(8, 0.8914618), (16, 0.09962519)]"
30314,30316.0,2023-02-21 17:45:43,0,36,"<p>Is it possible to retrieve gate fidelities, T1 and T2 times, etc. from old jobs in a rigetti device via braket and the amazon api?</p>
",retrieve gate errors from rigetti devices via braket,<amazon-braket><rigetti>,1,0,,,"retrieve gate errors from rigetti devices via braket <p>Is it possible to retrieve gate fidelities, T1 and T2 times, etc. from old jobs in a rigetti device via braket and the amazon api?</p>
",qc,retrieve gate errors rigetti devices via braket p possible retrieve gate fidelities t1 t2 times etc old jobs rigetti device via braket amazon api,"[(0, 0.08181761), (9, 0.10890284), (14, 0.6372577), (16, 0.10662805), (19, 0.05918987)]"
31446,31448.0,2023-03-02 10:58:54,0,499,"<p>When you run a job on an IBM device you can download a json file which contains among other things the description of the circuit. Is there a simple way in qiskit to create a QuantumCircuit object from this file without writing your own parser?</p>
<p>Below is an example for the content of this file.</p>
<pre><code>{&quot;config&quot;: {&quot;n_qubits&quot;: 5, &quot;memory_slots&quot;: 3}, &quot;header&quot;: {&quot;qubit_labels&quot;: [[&quot;q&quot;, 0], [&quot;q&quot;, 1], [&quot;q&quot;, 2], [&quot;q&quot;, 3], [&quot;q&quot;, 4]], &quot;n_qubits&quot;: 5, &quot;qreg_sizes&quot;: [[&quot;q&quot;, 5]], &quot;clbit_labels&quot;: [[&quot;meas&quot;, 0], [&quot;meas&quot;, 1], [&quot;meas&quot;, 2]], &quot;memory_slots&quot;: 3, &quot;creg_sizes&quot;: [[&quot;meas&quot;, 3]], &quot;name&quot;: &quot;circuit-103&quot;, &quot;global_phase&quot;: 2.356194490192345, &quot;metadata&quot;: {}}, &quot;instructions&quot;: [{&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966], &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;sx&quot;, &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966], &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966],...
</code></pre>
",Create circuit from qiskit json format,<qiskit><quantum-circuit><programming>,1,0,,,"Create circuit from qiskit json format <p>When you run a job on an IBM device you can download a json file which contains among other things the description of the circuit. Is there a simple way in qiskit to create a QuantumCircuit object from this file without writing your own parser?</p>
<p>Below is an example for the content of this file.</p>
<pre><code>{&quot;config&quot;: {&quot;n_qubits&quot;: 5, &quot;memory_slots&quot;: 3}, &quot;header&quot;: {&quot;qubit_labels&quot;: [[&quot;q&quot;, 0], [&quot;q&quot;, 1], [&quot;q&quot;, 2], [&quot;q&quot;, 3], [&quot;q&quot;, 4]], &quot;n_qubits&quot;: 5, &quot;qreg_sizes&quot;: [[&quot;q&quot;, 5]], &quot;clbit_labels&quot;: [[&quot;meas&quot;, 0], [&quot;meas&quot;, 1], [&quot;meas&quot;, 2]], &quot;memory_slots&quot;: 3, &quot;creg_sizes&quot;: [[&quot;meas&quot;, 3]], &quot;name&quot;: &quot;circuit-103&quot;, &quot;global_phase&quot;: 2.356194490192345, &quot;metadata&quot;: {}}, &quot;instructions&quot;: [{&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966], &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;sx&quot;, &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966], &quot;qubits&quot;: [0]}, {&quot;name&quot;: &quot;rz&quot;, &quot;params&quot;: [1.5707963267948966],...
</code></pre>
",qc,create circuit qiskit json format p run job ibm device download json file contains among things description circuit simple way qiskit create quantumcircuit object file without writing parser p example content pre code quot config quot quot quot 5 quot quot 3 quot header quot quot quot quot q quot 0 quot q quot 1 quot q quot 2 quot q quot 3 quot q quot 4 quot quot 5 quot quot quot q quot 5 quot quot quot meas quot 0 quot meas quot 1 quot meas quot 2 quot quot 3 quot quot quot meas quot 3 quot name quot quot quot quot quot quot metadata quot quot instructions quot quot name quot quot rz quot quot params quot quot qubits quot 0 quot name quot quot sx quot quot qubits quot 0 quot name quot quot rz quot quot params quot quot qubits quot 0 quot name quot quot rz quot quot params quot,"[(0, 0.109707505), (2, 0.07163023), (6, 0.052475043), (10, 0.030457476), (14, 0.11480998), (16, 0.014561001), (19, 0.5978732)]"
31462,31489.0,2023-03-03 10:58:33,1,247,"<p>I would like to compute the <em>number of columns</em> in a Qiskit <code>QuantumCircuit</code>. To be clear about what I mean by <em>number of columns</em>, consider the following circuit as an example:</p>
<pre><code>from qiskit.circuit.random import random_circuit

qc = random_circuit(4, 3, seed=0)
qc.draw('mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/Wwzeo.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Wwzeo.png"" alt=""enter image description here"" /></a></p>
<p>In this case, I would expect <em>number of columns</em> = 5 since I have 5 &quot;serial steps&quot; (in the first layer the <span class=""math-container"">$CY_{q1 \rightarrow q0}$</span> and <span class=""math-container"">$SWAP_{q2, q3}$</span> gates act in parallel, same for the <span class=""math-container"">$RY$</span> and <span class=""math-container"">$I$</span> gates in the second layer).</p>
<p>Note that the method <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.depth.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.depth</code></a> returns the &quot;length of critical path&quot; (i.e. maximum number of operations on a single qubit/wire). So the circuit depth is in general different from the <em>number of columns</em> I need; in particular, in the example above, <code>qc.depth()</code> evaluates to 3.</p>
","How to get the ""number of columns"" in a Qiskit quantum circuit?",<qiskit><quantum-circuit>,1,4,,,"How to get the ""number of columns"" in a Qiskit quantum circuit? <p>I would like to compute the <em>number of columns</em> in a Qiskit <code>QuantumCircuit</code>. To be clear about what I mean by <em>number of columns</em>, consider the following circuit as an example:</p>
<pre><code>from qiskit.circuit.random import random_circuit

qc = random_circuit(4, 3, seed=0)
qc.draw('mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/Wwzeo.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Wwzeo.png"" alt=""enter image description here"" /></a></p>
<p>In this case, I would expect <em>number of columns</em> = 5 since I have 5 &quot;serial steps&quot; (in the first layer the <span class=""math-container"">$CY_{q1 \rightarrow q0}$</span> and <span class=""math-container"">$SWAP_{q2, q3}$</span> gates act in parallel, same for the <span class=""math-container"">$RY$</span> and <span class=""math-container"">$I$</span> gates in the second layer).</p>
<p>Note that the method <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.depth.html"" rel=""nofollow noreferrer""><code>QuantumCircuit.depth</code></a> returns the &quot;length of critical path&quot; (i.e. maximum number of operations on a single qubit/wire). So the circuit depth is in general different from the <em>number of columns</em> I need; in particular, in the example above, <code>qc.depth()</code> evaluates to 3.</p>
",qc,get number columns qiskit quantum circuit p would like compute em number columns qiskit code quantumcircuit clear mean em number columns consider following circuit example pre code import qc 4 3 p https nofollow noreferrer img https enter image description p case would expect em number columns 5 since 5 quot serial steps quot first layer span q1 q0 span q2 q3 gates act parallel span ry span gates second layer p note method https nofollow noreferrer code returns quot length critical path quot maximum number operations single circuit depth general different em number columns need particular example code evaluates,"[(0, 0.06668296), (3, 0.15772069), (4, 0.17372549), (6, 0.026922798), (9, 0.12837821), (14, 0.36786997), (16, 0.020353535), (19, 0.057147972)]"
31572,,2023-03-10 13:36:37,2,312,"<p>I was curious to whether the two logical qubits on the toric code can be entangled through, for instance, a logical CNOT operation. However, I cannot find any information on this, only how you can do this on the surface code through braiding defects. I was wondering if people already looked into this because I haven't been able to find anything yet in literature. Does lattice surgery provide an option?</p>
",Is there a way to perform a defect-free logical CNOT on the toric code?,<entanglement><error-correction><surface-code><topological-quantum-computing><toric-code>,1,1,,,"Is there a way to perform a defect-free logical CNOT on the toric code? <p>I was curious to whether the two logical qubits on the toric code can be entangled through, for instance, a logical CNOT operation. However, I cannot find any information on this, only how you can do this on the surface code through braiding defects. I was wondering if people already looked into this because I haven't been able to find anything yet in literature. Does lattice surgery provide an option?</p>
",qc,way perform logical cnot toric code p curious whether two logical qubits toric code entangled instance logical cnot operation however find information surface code braiding defects wondering people already looked able find anything yet literature lattice surgery provide option,"[(5, 0.3432273), (7, 0.22766945), (11, 0.02581153), (13, 0.07964531), (16, 0.066976756), (17, 0.05352013), (18, 0.199832)]"
31694,31700.0,2023-03-16 11:23:31,2,333,"<p>Does Stim support classical-bit controlled gates?</p>
<p>I want to apply a gate based on a certain measurement outcome, e.g. do <code>Z^a</code> on qubit B, where <code>a</code> is the measurement outcome (0 or 1) of qubit A. That is, we do nothing if we measure a '0' on qubit A, and we apply a <code>Z</code> gate on qubit B if we measure a '1' on qubit A.</p>
<p>This kind of classical-bit controlled gate is very useful in many schemes such as lattice surgery and teleportation. So I want to know how to implement this kind of gate in Stim. I checked it here <a href=""https://github.com/quantumlib/Stim/blob/main/doc/gates.md#DEPOLARIZE1"" rel=""nofollow noreferrer"">Gates supported by Stim</a>, and it seems Stim doesn't include it directly. So it seems we have to use tricks like <code>if else</code> to implement it.</p>
<p>So how could I implement this kind of gate by Stim?</p>
",Does Stim support classical-bit controlled gates?,<stim>,1,0,,,"Does Stim support classical-bit controlled gates? <p>Does Stim support classical-bit controlled gates?</p>
<p>I want to apply a gate based on a certain measurement outcome, e.g. do <code>Z^a</code> on qubit B, where <code>a</code> is the measurement outcome (0 or 1) of qubit A. That is, we do nothing if we measure a '0' on qubit A, and we apply a <code>Z</code> gate on qubit B if we measure a '1' on qubit A.</p>
<p>This kind of classical-bit controlled gate is very useful in many schemes such as lattice surgery and teleportation. So I want to know how to implement this kind of gate in Stim. I checked it here <a href=""https://github.com/quantumlib/Stim/blob/main/doc/gates.md#DEPOLARIZE1"" rel=""nofollow noreferrer"">Gates supported by Stim</a>, and it seems Stim doesn't include it directly. So it seems we have to use tricks like <code>if else</code> to implement it.</p>
<p>So how could I implement this kind of gate by Stim?</p>
",qc,stim support controlled gates p stim support controlled gates p want apply gate based certain measurement outcome code qubit b code measurement outcome 0 1 qubit nothing measure 0 qubit apply code z gate qubit b measure 1 qubit p kind controlled gate useful many schemes lattice surgery teleportation want know implement kind gate stim checked https depolarize1 nofollow noreferrer gates supported stim seems stim include directly seems use tricks like code else implement p could implement kind gate stim,"[(2, 0.06511195), (5, 0.15812553), (6, 0.015125225), (9, 0.23382536), (14, 0.25890347), (16, 0.025335178), (18, 0.24195188)]"
31701,31702.0,2023-03-16 18:45:41,1,1069,"<p>I'm trying to use QiskitRuntimeService() and start a session to find the expectation value of some operator but I keep getting this error:</p>
<blockquote>
<p>ApiException: Error: Provided API key could not be found., Code: 400.</p>
</blockquote>
<p>The line that gives me the error is:</p>
<pre><code>service = QiskitRuntimeService()
</code></pre>
<p>How can I fix it?</p>
",QiskitRuntimeService error - Provided API key could not be found,<qiskit>,1,0,,,"QiskitRuntimeService error - Provided API key could not be found <p>I'm trying to use QiskitRuntimeService() and start a session to find the expectation value of some operator but I keep getting this error:</p>
<blockquote>
<p>ApiException: Error: Provided API key could not be found., Code: 400.</p>
</blockquote>
<p>The line that gives me the error is:</p>
<pre><code>service = QiskitRuntimeService()
</code></pre>
<p>How can I fix it?</p>
",qc,qiskitruntimeservice error provided api key could found p trying use qiskitruntimeservice start session find expectation value operator keep getting error blockquote p apiexception error provided api key could code p line gives error pre code service qiskitruntimeservice p fix,"[(0, 0.7028704), (5, 0.13092992), (7, 0.108875915), (16, 0.053134754)]"
31761,,2023-03-22 12:45:43,1,418,"<p>In Stim, logical observable has to be deterministic. To calculate the logical error rate, we compare the <code>actual_observables</code> sampled with stim circuit and <code>predicted_observables</code> which is the prediction from PyMatching.</p>
<p>I wander if we can analyze logical error rate for non-deterministic observable. For example we have a logical state |0&gt;+2|1&gt; (up to a normalization factor), we perform d rounds of error correction and measure in logical X basis. Is it possible to do this? (Though probably it would be tricky to define what logical error rate is in this case).</p>
<p>A more useful application of analyzing non-deterministic observable is lattice surgery, in which we perform logical XX or ZZ measurement on two patches of surface code. However, the joint measurement result is generally random. We perform d rounds of error correction after the merging operation and decode the defect graph to get the predicted value of joint measurement outcome (which is given by the parity of the new stabilizers in the first round of error correction after merging). So how could we determine the measurement outcome of this non-deterministic joint observable fault-tolerantly in this case?</p>
<p>Thanks very much!</p>
",Can Stim and PyMatching analyze logical error rate of non-deterministic observable?,<stim><pymatching>,1,0,,,"Can Stim and PyMatching analyze logical error rate of non-deterministic observable? <p>In Stim, logical observable has to be deterministic. To calculate the logical error rate, we compare the <code>actual_observables</code> sampled with stim circuit and <code>predicted_observables</code> which is the prediction from PyMatching.</p>
<p>I wander if we can analyze logical error rate for non-deterministic observable. For example we have a logical state |0&gt;+2|1&gt; (up to a normalization factor), we perform d rounds of error correction and measure in logical X basis. Is it possible to do this? (Though probably it would be tricky to define what logical error rate is in this case).</p>
<p>A more useful application of analyzing non-deterministic observable is lattice surgery, in which we perform logical XX or ZZ measurement on two patches of surface code. However, the joint measurement result is generally random. We perform d rounds of error correction after the merging operation and decode the defect graph to get the predicted value of joint measurement outcome (which is given by the parity of the new stabilizers in the first round of error correction after merging). So how could we determine the measurement outcome of this non-deterministic joint observable fault-tolerantly in this case?</p>
<p>Thanks very much!</p>
",qc,stim pymatching analyze logical error rate observable p stim logical observable deterministic calculate logical error rate compare code sampled stim circuit code prediction p wander analyze logical error rate observable example logical state gt gt normalization factor perform rounds error correction measure logical x basis possible though probably would tricky define logical error rate case p useful application analyzing observable lattice surgery perform logical xx zz measurement two patches surface code however joint measurement result generally random perform rounds error correction merging operation decode defect graph get predicted value joint measurement outcome given parity new stabilizers first round error correction merging could determine measurement outcome joint observable case p thanks much,"[(3, 0.092956305), (5, 0.49479204), (11, 0.019095689), (13, 0.019552879), (14, 0.1996986), (16, 0.04216774), (17, 0.011725981), (18, 0.11891998)]"
31921,,2023-03-30 21:19:50,1,44,"<p>Let us consider, we can easily prepare 2 distinct single qubit quantum states psi1 and psi2 in quantum registers (q1 and q2) in a quantum circuit. How to find out the entanglement status of these two quantum states using quantum circuit?</p>
",How to find that if two quantum states are entangled or not using quantum circuit?,<measurement>,0,3,,,"How to find that if two quantum states are entangled or not using quantum circuit? <p>Let us consider, we can easily prepare 2 distinct single qubit quantum states psi1 and psi2 in quantum registers (q1 and q2) in a quantum circuit. How to find out the entanglement status of these two quantum states using quantum circuit?</p>
",qc,find two quantum states entangled using quantum circuit p let us consider easily prepare 2 distinct single qubit quantum states psi1 psi2 quantum registers q1 q2 quantum circuit find entanglement status two quantum states using quantum circuit,"[(1, 0.23488745), (14, 0.26426837), (16, 0.03740622), (18, 0.45889077)]"
31973,31974.0,2023-04-04 08:38:48,0,77,"<p>I am using RGQFTMultiplier for multiplying two unsigned integers. Starting from simpler example of 2 qbits input, I reached 24 and all worked fine. I am using MPS as backend and my RAM is 32. However from 28 bit numbers and onwards, it started generating error in LSBs of the result.</p>
<p>For example:
input1 = 0xc452632
input2 = 0x8fac911</p>
<p>The result of multiplication should be 31013219982691154 but my result is 31013219982691153 (893 count). And the error increases with the number of bits.</p>
<p>As another example for 32 bits numbers</p>
<p>input1 = 0xc4526324
input2 = 0x8fac9115</p>
<p>Answer should be 7939384341679408628 but function is returning 7939384341679408319 (432 counts)</p>
<p>I need to multiply large numbers and 28 bits is a very small number. Is there any threshold level of this function or I need to use a different simulator/way?</p>
",Qiskit: RGQFTMultiplier is giving wrong answers for 28 bits number multiplication with MPS simulator,<qiskit><simulation><arithmetic>,1,0,,,"Qiskit: RGQFTMultiplier is giving wrong answers for 28 bits number multiplication with MPS simulator <p>I am using RGQFTMultiplier for multiplying two unsigned integers. Starting from simpler example of 2 qbits input, I reached 24 and all worked fine. I am using MPS as backend and my RAM is 32. However from 28 bit numbers and onwards, it started generating error in LSBs of the result.</p>
<p>For example:
input1 = 0xc452632
input2 = 0x8fac911</p>
<p>The result of multiplication should be 31013219982691154 but my result is 31013219982691153 (893 count). And the error increases with the number of bits.</p>
<p>As another example for 32 bits numbers</p>
<p>input1 = 0xc4526324
input2 = 0x8fac9115</p>
<p>Answer should be 7939384341679408628 but function is returning 7939384341679408319 (432 counts)</p>
<p>I need to multiply large numbers and 28 bits is a very small number. Is there any threshold level of this function or I need to use a different simulator/way?</p>
",qc,qiskit rgqftmultiplier giving wrong answers 28 bits number multiplication mps simulator p using rgqftmultiplier multiplying two unsigned integers starting simpler example 2 qbits input reached 24 worked fine using mps backend ram however 28 bit numbers onwards started generating error lsbs p example input1 0xc452632 input2 0x8fac911 p result multiplication 31013219982691154 result 31013219982691153 893 count error increases number p another example 32 bits numbers p input1 0xc4526324 input2 0x8fac9115 p answer 7939384341679408628 function returning 7939384341679408319 432 counts p need multiply large numbers 28 bits small number threshold level function need use different,"[(0, 0.16033274), (2, 0.065656774), (5, 0.03313884), (8, 0.114816174), (13, 0.2123463), (14, 0.3732512), (16, 0.038854614)]"
31977,31979.0,2023-04-04 10:58:20,1,276,"<p>The question concerns logical to physical qubit mapping when compiling quantum circuits with <a href=""https://bqskit.lbl.gov/"" rel=""nofollow noreferrer"">BQSKit</a>. In Qiskit, I can specify the <a href=""https://qiskit.org/documentation/apidoc/transpiler.html"" rel=""nofollow noreferrer"">initial layout</a> for the transpilation. It is also possible to retrieve the <a href=""https://github.com/Qiskit/qiskit-terra/pull/9486"" rel=""nofollow noreferrer"">final layout</a>. With Qiskit Transpiler and BQSKit Compiler, the final layout generally differs from the initial layout because the compiler can permute logical qubits. My question is whether I can specify the <code>initial layout</code> and retrieve the <code>final layout</code> with BQSKit.</p>
<p>I found the following way to retrieve the final layout:</p>
<pre><code> 1. Add measurements on all active qubits of a Qiskit circuit.
 2. Compile the circuit with BQSKit.
 3. Translate back to Qiskit and draw.
 4. Read out the mapping from the positions of final measurements. 
 5. Notice that q1 and q2 are permuted at the end.
</code></pre>
<p><a href=""https://i.sstatic.net/QImbg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QImbg.png"" alt=""enter image description here"" /></a></p>
<p>However, I am interested in a programmatic solution.</p>
",Initial and final circuit layout with BQSKit compiler,<programming><quantum-circuit><transpile>,2,0,,,"Initial and final circuit layout with BQSKit compiler <p>The question concerns logical to physical qubit mapping when compiling quantum circuits with <a href=""https://bqskit.lbl.gov/"" rel=""nofollow noreferrer"">BQSKit</a>. In Qiskit, I can specify the <a href=""https://qiskit.org/documentation/apidoc/transpiler.html"" rel=""nofollow noreferrer"">initial layout</a> for the transpilation. It is also possible to retrieve the <a href=""https://github.com/Qiskit/qiskit-terra/pull/9486"" rel=""nofollow noreferrer"">final layout</a>. With Qiskit Transpiler and BQSKit Compiler, the final layout generally differs from the initial layout because the compiler can permute logical qubits. My question is whether I can specify the <code>initial layout</code> and retrieve the <code>final layout</code> with BQSKit.</p>
<p>I found the following way to retrieve the final layout:</p>
<pre><code> 1. Add measurements on all active qubits of a Qiskit circuit.
 2. Compile the circuit with BQSKit.
 3. Translate back to Qiskit and draw.
 4. Read out the mapping from the positions of final measurements. 
 5. Notice that q1 and q2 are permuted at the end.
</code></pre>
<p><a href=""https://i.sstatic.net/QImbg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QImbg.png"" alt=""enter image description here"" /></a></p>
<p>However, I am interested in a programmatic solution.</p>
",qc,initial final circuit layout bqskit compiler p question concerns logical physical qubit mapping compiling quantum circuits https nofollow noreferrer bqskit qiskit specify https nofollow noreferrer initial layout transpilation also possible retrieve https nofollow noreferrer final layout qiskit transpiler bqskit compiler final layout generally differs initial layout compiler permute logical qubits question whether specify code initial layout retrieve code final layout p found following way retrieve final layout pre code add measurements active qubits qiskit circuit compile circuit bqskit translate back qiskit draw read mapping positions final measurements notice q1 q2 permuted end p https nofollow noreferrer img https enter image description p however interested programmatic,"[(4, 0.26680768), (5, 0.049629733), (8, 0.01576073), (9, 0.013990451), (14, 0.6423614), (16, 0.010078843)]"
31993,31995.0,2023-04-05 06:04:17,1,49,"<p>Let <span class=""math-container"">$G = (V,E)$</span> be a graph that defines the graph state
<span class=""math-container"">$$
|G\rangle = \prod_{(i,j)\in E} CZ_{i,j}|+\rangle^{\otimes |V|}.
$$</span>
Alternatively, we can write
<span class=""math-container"">$$
| G \rangle = \sum_{x \in \{0,1\}^{|V|}} f_G(x)|x\rangle,
$$</span>
for some function <span class=""math-container"">$f_G$</span> that can be determined by expanding the definition of <span class=""math-container"">$|G\rangle$</span>.</p>
<p>In the case where <span class=""math-container"">$G$</span> is a 2d lattice graph, then <span class=""math-container"">$|G\rangle$</span> is a cluster state, and <span class=""math-container"">$|G\rangle$</span> is also a universal resource for measurement-based quantum computing. Thus, with post-selection, one can simulate any BQP circuit.</p>
<p>My question is the following. Let <span class=""math-container"">$G$</span> be a 2d lattice graph and consider the state
<span class=""math-container"">$$
| G' \rangle = \sum_{x \in \{0,1\}^{|V|}} f_G(x)|x\rangle \otimes | x\rangle.
$$</span>
Is this universal for MBQC? What if I restrict to post-selecting on only the upper <span class=""math-container"">$|V|$</span> registers?</p>
",Is this generalized 2D cluster state still a universal resource?,<graph-states><postselection><cluster-states><measurement-based-qc>,1,0,,,"Is this generalized 2D cluster state still a universal resource? <p>Let <span class=""math-container"">$G = (V,E)$</span> be a graph that defines the graph state
<span class=""math-container"">$$
|G\rangle = \prod_{(i,j)\in E} CZ_{i,j}|+\rangle^{\otimes |V|}.
$$</span>
Alternatively, we can write
<span class=""math-container"">$$
| G \rangle = \sum_{x \in \{0,1\}^{|V|}} f_G(x)|x\rangle,
$$</span>
for some function <span class=""math-container"">$f_G$</span> that can be determined by expanding the definition of <span class=""math-container"">$|G\rangle$</span>.</p>
<p>In the case where <span class=""math-container"">$G$</span> is a 2d lattice graph, then <span class=""math-container"">$|G\rangle$</span> is a cluster state, and <span class=""math-container"">$|G\rangle$</span> is also a universal resource for measurement-based quantum computing. Thus, with post-selection, one can simulate any BQP circuit.</p>
<p>My question is the following. Let <span class=""math-container"">$G$</span> be a 2d lattice graph and consider the state
<span class=""math-container"">$$
| G' \rangle = \sum_{x \in \{0,1\}^{|V|}} f_G(x)|x\rangle \otimes | x\rangle.
$$</span>
Is this universal for MBQC? What if I restrict to post-selecting on only the upper <span class=""math-container"">$|V|$</span> registers?</p>
",qc,generalized 2d cluster state still universal resource p let span g v e graph defines graph state span j e j alternatively write span g x x function span determined expanding definition span p case span g 2d lattice graph span cluster state span also universal resource quantum computing thus one simulate bqp p question following let span g 2d lattice graph consider state span g x x universal mbqc restrict upper span registers,"[(1, 0.042953838), (3, 0.5877093), (9, 0.09232787), (10, 0.07885106), (13, 0.16541137), (16, 0.030859247)]"
32129,,2023-04-14 07:14:32,1,79,"<p>Recently I am trying to do some simulations on the surface code to get the empirical curve of logical error(P_L) corresponding with physical error rate(p) and code distance(d) as <a href=""https://arxiv.org/abs/1110.5133v2"" rel=""nofollow noreferrer"">Towards practical classical processing for the surface code</a> do. However, after several rounds of simulation, I found something weird happened in my work. I can't get the result of threshold theorem do! No matter how low the physical error rate is, adding more qubits always introduce more errors.</p>
<p>So I want to know which part of my simulation is wrong.</p>
<p>The following is my simulation route. Let's take d=5 as example.</p>
<p>Step1: First in my program, I will generate a 5*5 lattice of physical qubits. And in each round of stabilizer measurement simulation, I randomly put errors using the standard Depolarizing noise model on each qubits in the lattice, which means every qubits in the lattice will store an information of one of ['I', 'X', 'Y', 'Z'] with the probability [1 - 8p, 8p/3, 8p/3, 8p/3].</p>
<p>Step2: In this step, I perform stabilizer measurement on the measure qubit to get the &quot;-1&quot; syndrome outcome.(Suppose the measure qubit is to measure the &quot;Z&quot; type stabilizer, then one neighbouring physical qubits containing &quot;X&quot; or &quot;Y&quot; will flip the outcome.) Now, I just consider the perfect measurement case to simpilify the simulation. As a consequence, I just need to do one round of stabilizer measurement, and ignore the time boundary.</p>
<p>Step3: Once I get all of the &quot;-1&quot; syndrome in the stabilizer measurement step, I just perform MWPM algorithm using the library of &quot;networkX&quot;. And the distance of two stabilizer is defined as the Manhattan distance.</p>
<p>Step4: With all &quot;-1&quot; pairs as the outcome of MWPM, I generate the operators of the qubits in the shortest path of these pairs. And applying these operators is the error correction step.</p>
<p>Step5: After recovering the error. I combined the simulated error in step1 and the recovery operator in step4 to detect if this round of simulation occurs a logical error. If it does, count it. Return to step1.</p>
<p>The simulation result of my work is:</p>
<p><a href=""https://i.sstatic.net/taWTu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/taWTu.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>I possiblly find out where the problem is. Seems like there are some weird results in the usage of the <code>nx.min_weigh_matching</code> <a href=""https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.matching.min_weight_matching.html#networkx.algorithms.matching.min_weight_matching"" rel=""nofollow noreferrer"">min_weight_matching implemented by the networkX lib</a>.</p>
<p>Here is the proof. The code is running in the python.</p>
<pre><code>import networkx as nx

G = nx.Graph()
edges = [(0, 1, {'weight': 3}), (1, 2, {'weight': 1}), (0, 3, {'weight': 1}), (2, 3, {'weight': 0})]
G.add_edges_from(edges)
print(nx.min_weight_matching(G))
</code></pre>
<p>I generate a complete graph of 4 nodes with the above weight. However, the result is:</p>
<pre><code>{(0, 1), (2, 3)}
</code></pre>
<p>And the total weight(3) of this matching is larger than the total weight(2) of matching {(0, 3), (1, 2)}.</p>
",Some problems when trying to reproduce the threshold result of simulation of surface code,<surface-code><minimum-weight-perfect-matching>,0,4,,,"Some problems when trying to reproduce the threshold result of simulation of surface code <p>Recently I am trying to do some simulations on the surface code to get the empirical curve of logical error(P_L) corresponding with physical error rate(p) and code distance(d) as <a href=""https://arxiv.org/abs/1110.5133v2"" rel=""nofollow noreferrer"">Towards practical classical processing for the surface code</a> do. However, after several rounds of simulation, I found something weird happened in my work. I can't get the result of threshold theorem do! No matter how low the physical error rate is, adding more qubits always introduce more errors.</p>
<p>So I want to know which part of my simulation is wrong.</p>
<p>The following is my simulation route. Let's take d=5 as example.</p>
<p>Step1: First in my program, I will generate a 5*5 lattice of physical qubits. And in each round of stabilizer measurement simulation, I randomly put errors using the standard Depolarizing noise model on each qubits in the lattice, which means every qubits in the lattice will store an information of one of ['I', 'X', 'Y', 'Z'] with the probability [1 - 8p, 8p/3, 8p/3, 8p/3].</p>
<p>Step2: In this step, I perform stabilizer measurement on the measure qubit to get the &quot;-1&quot; syndrome outcome.(Suppose the measure qubit is to measure the &quot;Z&quot; type stabilizer, then one neighbouring physical qubits containing &quot;X&quot; or &quot;Y&quot; will flip the outcome.) Now, I just consider the perfect measurement case to simpilify the simulation. As a consequence, I just need to do one round of stabilizer measurement, and ignore the time boundary.</p>
<p>Step3: Once I get all of the &quot;-1&quot; syndrome in the stabilizer measurement step, I just perform MWPM algorithm using the library of &quot;networkX&quot;. And the distance of two stabilizer is defined as the Manhattan distance.</p>
<p>Step4: With all &quot;-1&quot; pairs as the outcome of MWPM, I generate the operators of the qubits in the shortest path of these pairs. And applying these operators is the error correction step.</p>
<p>Step5: After recovering the error. I combined the simulated error in step1 and the recovery operator in step4 to detect if this round of simulation occurs a logical error. If it does, count it. Return to step1.</p>
<p>The simulation result of my work is:</p>
<p><a href=""https://i.sstatic.net/taWTu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/taWTu.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>I possiblly find out where the problem is. Seems like there are some weird results in the usage of the <code>nx.min_weigh_matching</code> <a href=""https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.matching.min_weight_matching.html#networkx.algorithms.matching.min_weight_matching"" rel=""nofollow noreferrer"">min_weight_matching implemented by the networkX lib</a>.</p>
<p>Here is the proof. The code is running in the python.</p>
<pre><code>import networkx as nx

G = nx.Graph()
edges = [(0, 1, {'weight': 3}), (1, 2, {'weight': 1}), (0, 3, {'weight': 1}), (2, 3, {'weight': 0})]
G.add_edges_from(edges)
print(nx.min_weight_matching(G))
</code></pre>
<p>I generate a complete graph of 4 nodes with the above weight. However, the result is:</p>
<pre><code>{(0, 1), (2, 3)}
</code></pre>
<p>And the total weight(3) of this matching is larger than the total weight(2) of matching {(0, 3), (1, 2)}.</p>
",qc,problems trying reproduce threshold result simulation surface code p recently trying simulations surface code get empirical curve logical error corresponding physical error rate p code distance https nofollow noreferrer towards practical classical processing surface code however several rounds simulation found something weird happened work ca get result threshold theorem matter low physical error rate adding qubits always introduce p want know part simulation p following simulation route let take p step1 first program generate 5 5 lattice physical qubits round stabilizer measurement simulation randomly put errors using standard depolarizing noise model qubits lattice means every qubits lattice store information one x z probability 1 8p p step2 step perform stabilizer measurement measure qubit get quot quot syndrome outcome suppose measure qubit measure quot z quot type stabilizer one neighbouring physical qubits containing quot x quot quot quot flip outcome consider perfect measurement case simpilify simulation consequence need one round stabilizer measurement ignore time p step3 get quot quot syndrome stabilizer measurement step perform mwpm algorithm using library quot networkx quot distance two stabilizer defined manhattan p step4 quot quot pairs outcome mwpm generate operators qubits shortest path pairs applying operators error correction p step5 recovering error combined simulated error step1 recovery operator step4 detect round simulation occurs logical error count return p simulation result work p https nofollow noreferrer img https enter image description hr p possiblly find problem seems like weird results usage code https nofollow noreferrer implemented networkx lib p proof code running pre code import networkx nx g edges 0 1 3 1 2 1 0 3 1 2 3 0 edges print g p generate complete graph 4 nodes weight however result pre code 0 1 2 3 p total weight 3 matching larger total weight 2 matching 0 3 1 2,"[(0, 0.078964725), (1, 0.025137883), (2, 0.08172856), (4, 0.081903115), (5, 0.29353544), (9, 0.036451224), (13, 0.053529684), (14, 0.15260537), (16, 0.01296794), (17, 0.013126897), (18, 0.100965366), (19, 0.06880115)]"
32141,32146.0,2023-04-15 08:14:42,1,312,"<p>I am trying to find a simple proof that <span class=""math-container"">$\|v \otimes u\| = 1 $</span> if <span class=""math-container"">$\|v\|=1$</span> and <span class=""math-container"">$\|u\|=1$</span>.</p>
<p>I have a proof by induction, where I can fix the length of <span class=""math-container"">$u$</span> and show by induction on the length of <span class=""math-container"">$v$</span> that the previous statement is true. The base case is for length of <span class=""math-container"">$v=2$</span>.</p>
<p>Let <span class=""math-container"">$u = [\alpha_1, \alpha_2]$</span> and <span class=""math-container"">$v=[v_1, \dots, v_n]$</span>, we get a formula of the kind</p>
<p><span class=""math-container"">$$ \sum_{i=1}^n (\alpha_1v_i)^2 + \sum_{i=1}^n (\alpha_2v_i)^2 = \sum_{i=1}^n v_i^2(\alpha_1+\alpha_2)^2 = 1$$</span></p>
<p>Do you have a another idea, maybe using properties of the tensor product or properties of the norm?</p>
",Proof that tensor product of unit vectors is a unit vector,<linear-algebra>,1,0,,,"Proof that tensor product of unit vectors is a unit vector <p>I am trying to find a simple proof that <span class=""math-container"">$\|v \otimes u\| = 1 $</span> if <span class=""math-container"">$\|v\|=1$</span> and <span class=""math-container"">$\|u\|=1$</span>.</p>
<p>I have a proof by induction, where I can fix the length of <span class=""math-container"">$u$</span> and show by induction on the length of <span class=""math-container"">$v$</span> that the previous statement is true. The base case is for length of <span class=""math-container"">$v=2$</span>.</p>
<p>Let <span class=""math-container"">$u = [\alpha_1, \alpha_2]$</span> and <span class=""math-container"">$v=[v_1, \dots, v_n]$</span>, we get a formula of the kind</p>
<p><span class=""math-container"">$$ \sum_{i=1}^n (\alpha_1v_i)^2 + \sum_{i=1}^n (\alpha_2v_i)^2 = \sum_{i=1}^n v_i^2(\alpha_1+\alpha_2)^2 = 1$$</span></p>
<p>Do you have a another idea, maybe using properties of the tensor product or properties of the norm?</p>
",qc,proof tensor product unit vectors unit vector p trying find simple proof span 1 span span p proof induction fix length span u show induction length span v previous statement true base case length span p let span u span get formula kind p span 1 p another idea maybe using properties tensor product properties norm,"[(3, 0.9077667), (10, 0.056896355), (16, 0.032310497)]"
32227,,2023-04-19 18:59:32,0,380,"<p>I have a simple parameterized quantum circuit which looks like the image attached. Here is the code used to create it:</p>
<pre><code>from qiskit import QuantumCircuit, Aer, execute
import numpy as np
from qiskit.circuit import ParameterVector, QuantumCircuit

def add_layer(kernel, params, n_qubits):

    qubits = list(range(n_qubits))

    for i in range(n_qubits):
        kernel.rx(params[i], qubits[i])

    for i in range(n_qubits):
        kernel.ry(params[i + n_qubits], qubits[i])

    for i in range(n_qubits):
        kernel.rz(params[i + n_qubits*2], qubits[i])

    for q1, q2 in zip(qubits[0::2], qubits[1::2]):
        kernel.cz(qubits[q1], qubits[q2])

    return kernel


n_qubits = 2
n_samples = 5
simulator = Aer.get_backend('statevector_simulator')

n_parameters = n_qubits*3
parameters = np.random.default_rng(13).uniform(low=0, high=1, size = (n_samples,n_parameters))
np.random.seed(1)

p = ParameterVector('p', length = n_parameters)  

kernel = QuantumCircuit(n_qubits)
kernel = add_layer(kernel, p, n_qubits)

bc = kernel.bind_parameters({p: parameters[0]})

result = execute(bc, simulator).result().get_statevector()
</code></pre>
<p>Currently I am only running this for <code>parameters[0]</code> but I would like to run this for all 5 samples in parameters. How do I bind all of them?</p>
<p>Moreover, I would like to calculate the Z expectation value of the final qubit from the statevector with a built in method if there is one available.</p>
<p>Thanks for your help.</p>
",Parameterized circuits and Z expectation values - Qiskit,<qiskit>,1,0,,,"Parameterized circuits and Z expectation values - Qiskit <p>I have a simple parameterized quantum circuit which looks like the image attached. Here is the code used to create it:</p>
<pre><code>from qiskit import QuantumCircuit, Aer, execute
import numpy as np
from qiskit.circuit import ParameterVector, QuantumCircuit

def add_layer(kernel, params, n_qubits):

    qubits = list(range(n_qubits))

    for i in range(n_qubits):
        kernel.rx(params[i], qubits[i])

    for i in range(n_qubits):
        kernel.ry(params[i + n_qubits], qubits[i])

    for i in range(n_qubits):
        kernel.rz(params[i + n_qubits*2], qubits[i])

    for q1, q2 in zip(qubits[0::2], qubits[1::2]):
        kernel.cz(qubits[q1], qubits[q2])

    return kernel


n_qubits = 2
n_samples = 5
simulator = Aer.get_backend('statevector_simulator')

n_parameters = n_qubits*3
parameters = np.random.default_rng(13).uniform(low=0, high=1, size = (n_samples,n_parameters))
np.random.seed(1)

p = ParameterVector('p', length = n_parameters)  

kernel = QuantumCircuit(n_qubits)
kernel = add_layer(kernel, p, n_qubits)

bc = kernel.bind_parameters({p: parameters[0]})

result = execute(bc, simulator).result().get_statevector()
</code></pre>
<p>Currently I am only running this for <code>parameters[0]</code> but I would like to run this for all 5 samples in parameters. How do I bind all of them?</p>
<p>Moreover, I would like to calculate the Z expectation value of the final qubit from the statevector with a built in method if there is one available.</p>
<p>Thanks for your help.</p>
",qc,parameterized circuits z expectation values qiskit p simple parameterized quantum circuit looks like image attached code used create pre code qiskit import quantumcircuit aer execute import numpy np import parametervector quantumcircuit def kernel params qubits list range range params qubits range params qubits range params 2 qubits q1 q2 zip qubits 0 qubits 1 qubits q1 qubits q2 return kernel 2 5 simulator 3 parameters 13 size 1 p parametervector p length kernel quantumcircuit kernel kernel p bc p parameters 0 result execute bc simulator p currently running code parameters 0 would like run 5 samples parameters bind p moreover would like calculate z expectation value final qubit statevector built method one p thanks,"[(0, 0.47778374), (2, 0.057727654), (3, 0.03493552), (4, 0.01491507), (6, 0.022189952), (14, 0.37352604), (16, 0.01778319)]"
32290,,2023-04-24 07:25:27,0,179,"<p>What would be the circuit for operation exp(iθZ⊗Z⊗Z⊗X) by only using CNOTs and single-qubit gates. And How we can improve the circuit to implement the operation exp(iφZ⊗Z⊗X⊗Z ).exp(iθZ⊗Z⊗Z⊗X).Are there are multiple ways to do it?</p>
",circuit for quantum simulation?,<quantum-state><quantum-algorithms><quantum-circuit><hamiltonian-simulation>,2,0,,,"circuit for quantum simulation? <p>What would be the circuit for operation exp(iθZ⊗Z⊗Z⊗X) by only using CNOTs and single-qubit gates. And How we can improve the circuit to implement the operation exp(iφZ⊗Z⊗X⊗Z ).exp(iθZ⊗Z⊗Z⊗X).Are there are multiple ways to do it?</p>
",qc,circuit quantum simulation p would circuit operation exp using cnots gates improve circuit implement operation exp multiple ways,"[(2, 0.114712715), (9, 0.11983125), (14, 0.7020853), (16, 0.054576382)]"
32304,,2023-04-25 07:44:24,2,152,"<p>I was quite confused about the definition of physical error rate in the paper <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""nofollow noreferrer"">Topological quantum memory</a>, which is famous because it estimate the accurate threshold by using Ising model.</p>
<p>In this paper, the author said that Let us imagine that, in a single time step, we will execute
a measurement of each stabilizer operator at each site and each plaquette of the lattice. During each time step, new qubit errors might occur. To be concrete and to simplify the discussion, we assume that all qubit errors are stochastic, and so can be assigned probabilities. (For example, errors that arise from decoherence have this property.) We will also assume that the errors acting
on different qubits are independent, that bit-flip (X) errors and phase (Z) errors are uncorrelated with one another, and that X and Z errors are equally likely. Thus the error in each time step acting on a qubit with state ρ can be represented by the quantum channel. [located in Sec4.A]</p>
<p>And the result of this paper is 11% if perfect measurement and 1.1% if imperfect measurement.</p>
<p>So, my question is:</p>
<p>What does this error rate mean? The probability of occuring error in the whole stabilizer measurement or the probability of occuring error in just one gate time which might be in the order of 1/8 less than the previous one if using the standard X(Z) stabilizer measurement circuit.</p>
",The definition of physical error rate in the threshold theorem,<surface-code>,1,0,,,"The definition of physical error rate in the threshold theorem <p>I was quite confused about the definition of physical error rate in the paper <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""nofollow noreferrer"">Topological quantum memory</a>, which is famous because it estimate the accurate threshold by using Ising model.</p>
<p>In this paper, the author said that Let us imagine that, in a single time step, we will execute
a measurement of each stabilizer operator at each site and each plaquette of the lattice. During each time step, new qubit errors might occur. To be concrete and to simplify the discussion, we assume that all qubit errors are stochastic, and so can be assigned probabilities. (For example, errors that arise from decoherence have this property.) We will also assume that the errors acting
on different qubits are independent, that bit-flip (X) errors and phase (Z) errors are uncorrelated with one another, and that X and Z errors are equally likely. Thus the error in each time step acting on a qubit with state ρ can be represented by the quantum channel. [located in Sec4.A]</p>
<p>And the result of this paper is 11% if perfect measurement and 1.1% if imperfect measurement.</p>
<p>So, my question is:</p>
<p>What does this error rate mean? The probability of occuring error in the whole stabilizer measurement or the probability of occuring error in just one gate time which might be in the order of 1/8 less than the previous one if using the standard X(Z) stabilizer measurement circuit.</p>
",qc,definition physical error rate threshold theorem p quite confused definition physical error rate paper https nofollow noreferrer topological quantum memory famous estimate accurate threshold using ising p paper author said let us imagine single time step execute measurement stabilizer operator site plaquette lattice time step new qubit errors might occur concrete simplify discussion assume qubit errors stochastic assigned probabilities example errors arise decoherence property also assume errors acting different qubits independent x errors phase z errors uncorrelated one another x z errors equally likely thus error time step acting qubit state ρ represented quantum channel located p result paper 11 perfect measurement imperfect p question p error rate mean probability occuring error whole stabilizer measurement probability occuring error one gate time might order less previous one using standard x z stabilizer measurement,"[(1, 0.032089613), (5, 0.42110643), (8, 0.06392825), (9, 0.2629501), (10, 0.025158295), (13, 0.043846384), (14, 0.02789898), (16, 0.010915757), (17, 0.012357036), (18, 0.09130391)]"
32323,,2023-04-26 16:34:48,3,82,"<p>I'm trying to learn QAOA and how to apply it to a complex combinatorial problem.  But for the purpose of this question I'll use the common example
MaxCut.</p>
<p>I'd like to know if I've set up my cost Hamiltonian correctly.  To check that, would I would do for MaxCut, is set up the circuit using only the cost Hamiltonian, and then set the initial states to of all qubits such that they're in the ground state.  (In the following example of MaxCut, the ground state is <code>00011</code>, as you'll see from the graph <code>G</code>).</p>
<p>Then, I would <em>expect</em> that all of the counts outputted by running the state simulator would correspond to the ground state given as input.  However, when I set the initial state as <code>00000</code>, running the following code ALSO returns all counts in the state given as input.  So, I'm guessing this is not the proper way to debug my cost Hamiltonian.  The code to reproduce this behavior is below:</p>
<pre><code>G = nx.Graph()
G.add_edges_from([[0,3],[0,4],[1,3],[1,4],[2,3],[2,4]])
def append_zz_term(qc, q1, q2, gamma):
    qc.cx(q1, q2)
    qc.rz(2*gamma, q2)
    qc.cx(q1, q2)
def get_cost_operator_circuit(G, gamma):
    N = G.number_of_nodes()
    qc = QuantumCircuit(N, N)
    for i, j in G.edges():
        qc.barrier()
        append_zz_term(qc, i, j, gamma)
    return qc

def invert_counts(counts):
    return {k[::-1]:v for k, v in counts.items()}

N = G.number_of_nodes()
qc = QuantumCircuit(N,N)
# Removing the following line ALSO returns all counts in the initial state 00000, which is NOT the ground state
qc.x([3,4])
qc = qc.compose(get_cost_operator_circuit(G, np.pi/3))
qc.barrier(range(N))
qc.measure(range(N), range(N))
qc.draw()

backend = Aer.get_backend('qasm_simulator')
job = execute(qc, backend, shots=1000)
result = job.result()
print(invert_counts(result.get_counts()))

</code></pre>
<p>This tells me that this isn't the right way to debug my cost Hamiltonian.  What would be the proper way to check if the cost Hamiltonian represents the objective function faithfully?</p>
",How to sanity check QAOA cost Hamiltonian?,<qiskit><optimization><qaoa>,1,0,,,"How to sanity check QAOA cost Hamiltonian? <p>I'm trying to learn QAOA and how to apply it to a complex combinatorial problem.  But for the purpose of this question I'll use the common example
MaxCut.</p>
<p>I'd like to know if I've set up my cost Hamiltonian correctly.  To check that, would I would do for MaxCut, is set up the circuit using only the cost Hamiltonian, and then set the initial states to of all qubits such that they're in the ground state.  (In the following example of MaxCut, the ground state is <code>00011</code>, as you'll see from the graph <code>G</code>).</p>
<p>Then, I would <em>expect</em> that all of the counts outputted by running the state simulator would correspond to the ground state given as input.  However, when I set the initial state as <code>00000</code>, running the following code ALSO returns all counts in the state given as input.  So, I'm guessing this is not the proper way to debug my cost Hamiltonian.  The code to reproduce this behavior is below:</p>
<pre><code>G = nx.Graph()
G.add_edges_from([[0,3],[0,4],[1,3],[1,4],[2,3],[2,4]])
def append_zz_term(qc, q1, q2, gamma):
    qc.cx(q1, q2)
    qc.rz(2*gamma, q2)
    qc.cx(q1, q2)
def get_cost_operator_circuit(G, gamma):
    N = G.number_of_nodes()
    qc = QuantumCircuit(N, N)
    for i, j in G.edges():
        qc.barrier()
        append_zz_term(qc, i, j, gamma)
    return qc

def invert_counts(counts):
    return {k[::-1]:v for k, v in counts.items()}

N = G.number_of_nodes()
qc = QuantumCircuit(N,N)
# Removing the following line ALSO returns all counts in the initial state 00000, which is NOT the ground state
qc.x([3,4])
qc = qc.compose(get_cost_operator_circuit(G, np.pi/3))
qc.barrier(range(N))
qc.measure(range(N), range(N))
qc.draw()

backend = Aer.get_backend('qasm_simulator')
job = execute(qc, backend, shots=1000)
result = job.result()
print(invert_counts(result.get_counts()))

</code></pre>
<p>This tells me that this isn't the right way to debug my cost Hamiltonian.  What would be the proper way to check if the cost Hamiltonian represents the objective function faithfully?</p>
",qc,sanity check qaoa cost hamiltonian p trying learn qaoa apply complex combinatorial problem purpose question use common example p like know set cost hamiltonian correctly check would would maxcut set circuit using cost hamiltonian set initial states qubits ground state following example maxcut ground state code 00011 see graph code g p would em expect counts outputted running state simulator would correspond ground state given input however set initial state code 00000 running following code also returns counts state given input guessing proper way debug cost hamiltonian code reproduce behavior pre code g def qc q1 q2 gamma q1 q2 2 gamma q2 q1 q2 def g gamma n qc quantumcircuit n n j qc j gamma return qc def counts return k v k v n qc quantumcircuit n n removing following line also returns counts initial state 00000 ground state qc g range n range n range n backend job execute qc backend result print p tells right way debug cost hamiltonian would proper way check cost hamiltonian represents objective function faithfully,"[(0, 0.48049852), (1, 0.12784004), (3, 0.107989594), (5, 0.027814385), (14, 0.17113358), (16, 0.017748805), (18, 0.058896188)]"
32382,,2023-05-01 07:16:14,1,457,"<p>Is there a circuit in stim that performs lattice surgery?</p>
<p>Was lattice surgery ever implemented in stim?</p>
<p>I wonder how the relevant detectors will look like - especially in the initial and final rounds of the surgery.</p>
",How to implement lattice surgery in stim?,<stim><surface-code>,1,0,,,"How to implement lattice surgery in stim? <p>Is there a circuit in stim that performs lattice surgery?</p>
<p>Was lattice surgery ever implemented in stim?</p>
<p>I wonder how the relevant detectors will look like - especially in the initial and final rounds of the surgery.</p>
",qc,implement lattice surgery stim p circuit stim performs lattice surgery p lattice surgery ever implemented stim p wonder relevant detectors look like especially initial final rounds,"[(5, 0.13329467), (9, 0.16259715), (14, 0.46817276), (16, 0.22982597)]"
32402,32416.0,2023-05-02 16:03:03,1,107,"<p>The Qiskit API defines the electronic dipole moment as</p>
<p><span class=""math-container"">$$
\hat{d} = \sum_{p,q} d_{pq}^x a_p^\dagger a_q ,
$$</span>
where
<span class=""math-container"">$d_{pq}^x,d_{pq}^y,$</span> and <span class=""math-container"">$d_{pq}^z$</span> are the Cartesian components of the vector
<span class=""math-container"">$$
\textbf{d}_{pq}
=
\int d\tau \phi_p \frac{1}{\textbf{r}} \phi_q .
$$</span></p>
<p>(Link to the API : <a href=""https://qiskit.org/ecosystem/nature/stubs/qiskit_nature.second_q.properties.ElectronicDipoleMoment.html#qiskit_nature.second_q.properties.ElectronicDipoleMoment"" rel=""nofollow noreferrer"">https://qiskit.org/ecosystem/nature/stubs/qiskit_nature.second_q.properties.ElectronicDipoleMoment.html#qiskit_nature.second_q.properties.ElectronicDipoleMoment</a>)</p>
<p>Can someone please explain how the dipole moment operator can be expressed in the second quantised form this way? I follow that for a discrete one-dimensional system, the expectation value of the dipole moment is easily evaluated by
<span class=""math-container"">$$
\langle \mu \rangle = \langle \psi | \hat{\mu} | \psi \rangle
$$</span>
where <span class=""math-container"">$\hat{\mu} = \sum_i \hat{N}_i x_i$</span> but I cannot extend this to a three-dimensional system with continuous wavefunctions.</p>
<p>Specifically, I cannot see how the term <span class=""math-container"">$\frac{1}{\textbf{r}}$</span> arises in the equation for <span class=""math-container"">$\textbf{d}_{pq}$</span>. From dimensional analysis it makes sense to have this form as one needs a factor of <span class=""math-container"">$d \tau = 4 \pi r^2 dr$</span> to convert from Cartesian to spherical polar coordinates, but I'd like to know how it's derived and what happens to the <span class=""math-container"">$4 \pi$</span> factor.</p>
",Can someone explain how Qiskit defines the electronic dipole moments?,<qiskit><chemistry>,1,0,,,"Can someone explain how Qiskit defines the electronic dipole moments? <p>The Qiskit API defines the electronic dipole moment as</p>
<p><span class=""math-container"">$$
\hat{d} = \sum_{p,q} d_{pq}^x a_p^\dagger a_q ,
$$</span>
where
<span class=""math-container"">$d_{pq}^x,d_{pq}^y,$</span> and <span class=""math-container"">$d_{pq}^z$</span> are the Cartesian components of the vector
<span class=""math-container"">$$
\textbf{d}_{pq}
=
\int d\tau \phi_p \frac{1}{\textbf{r}} \phi_q .
$$</span></p>
<p>(Link to the API : <a href=""https://qiskit.org/ecosystem/nature/stubs/qiskit_nature.second_q.properties.ElectronicDipoleMoment.html#qiskit_nature.second_q.properties.ElectronicDipoleMoment"" rel=""nofollow noreferrer"">https://qiskit.org/ecosystem/nature/stubs/qiskit_nature.second_q.properties.ElectronicDipoleMoment.html#qiskit_nature.second_q.properties.ElectronicDipoleMoment</a>)</p>
<p>Can someone please explain how the dipole moment operator can be expressed in the second quantised form this way? I follow that for a discrete one-dimensional system, the expectation value of the dipole moment is easily evaluated by
<span class=""math-container"">$$
\langle \mu \rangle = \langle \psi | \hat{\mu} | \psi \rangle
$$</span>
where <span class=""math-container"">$\hat{\mu} = \sum_i \hat{N}_i x_i$</span> but I cannot extend this to a three-dimensional system with continuous wavefunctions.</p>
<p>Specifically, I cannot see how the term <span class=""math-container"">$\frac{1}{\textbf{r}}$</span> arises in the equation for <span class=""math-container"">$\textbf{d}_{pq}$</span>. From dimensional analysis it makes sense to have this form as one needs a factor of <span class=""math-container"">$d \tau = 4 \pi r^2 dr$</span> to convert from Cartesian to spherical polar coordinates, but I'd like to know how it's derived and what happens to the <span class=""math-container"">$4 \pi$</span> factor.</p>
",qc,someone explain qiskit defines electronic dipole moments p qiskit api defines electronic dipole moment p span p q pq span pq pq span pq cartesian components vector span pq 1 r p link api https nofollow noreferrer https p someone please explain dipole moment operator expressed second quantised form way follow discrete system expectation value dipole moment easily evaluated span span n extend system continuous p specifically see term span 1 r arises equation span pq dimensional analysis makes sense form one needs factor span 4 dr convert cartesian spherical polar coordinates like know derived happens span 4,"[(3, 0.49594718), (4, 0.0888744), (7, 0.01941747), (10, 0.10664973), (13, 0.2333116), (15, 0.032305334), (16, 0.02211167)]"
32429,32433.0,2023-05-04 04:48:49,2,1482,"<p>I have a 2 qubit (+1 ancillary qubit) circuit in Qiskit which calculates the classical OR gate (q0 or q1) as follows:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer

for input in ['00','01','10','11']:
    
    mycircuit1 = QuantumCircuit(3,1)
    
    #Initialization - Note qiskit order
    if input[0] == '1':
        mycircuit1.x(1)
    if input[1] == '1':
        mycircuit1.x(0)

    mycircuit1.cx(0,2)
    mycircuit1.cx(1,2)
    mycircuit1.ccx(0,1,2)

    mycircuit1.measure(2,0)

    job    = execute(mycircuit1, Aer.get_backend('qasm_simulator'), shots = 1000)
    counts = job.result().get_counts(mycircuit1)
    print(&quot;Input:&quot;, input, &quot;Output:&quot;, counts)
</code></pre>
<p>that returns:</p>
<pre><code>Input: 00 Output: {'0': 1000}
Input: 01 Output: {'1': 1000}
Input: 10 Output: {'1': 1000}
Input: 11 Output: {'1': 1000}
</code></pre>
<p>and and I want to expand it to a 3 qubit(+1 ancillary qubit) circuit that calculates (q0 or q1 or q2) but I do not know how. One way of thinking is that (q0 OR q1 OR q2) = (qo OR q1) OR q2
so I can put the gates from the previous circuit and repeat the process. However, I do not know how to bind these two together. Here is the circuit that I have at the moment:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer

for input in ['000','100','010','001', '110','011','101','111']:
    
    mycircuit1 = QuantumCircuit(4,1)
    
    #Initialization - Note qiskit order
    if input[0] == '1':
        mycircuit1.x(1)
    if input[1] == '1':
        mycircuit1.x(0)

    mycircuit1.cx(0,2)
    mycircuit1.cx(1,2)
    mycircuit1.ccx(0,1,2)

    mycircuit1.barrier()

    mycircuit1.cx(1,3)
    mycircuit1.cx(2,3)
    mycircuit1.ccx(1,2,3)
    
    mycircuit1.measure(3,0)

    job    = execute(mycircuit1, Aer.get_backend('qasm_simulator'), shots = 1000)
    counts = job.result().get_counts(mycircuit1)
    print(&quot;Input:&quot;, input, &quot;Output:&quot;, counts)
</code></pre>
<p>that returns:</p>
<pre><code>Input: 000 Output: {'0': 1000}
Input: 100 Output: {'1': 1000}
Input: 010 Output: {'1': 1000}
Input: 001 Output: {'0': 1000}
Input: 110 Output: {'1': 1000}
Input: 011 Output: {'1': 1000}
Input: 101 Output: {'1': 1000}
Input: 111 Output: {'1': 1000}
</code></pre>
<p>I am stuck at this point and I do not know what to do next. As demonstrated in the results if q0 or q1 equals one, the final result would be one, so if I can fix the problem in the 001 input, I can say I implemented the classical OR gate for three inputs.</p>
",Calculating the classical OR gate in a 3 qubit (+1 ancillary qubit) circuit,<qiskit><circuit-construction><universal-gates>,2,1,,,"Calculating the classical OR gate in a 3 qubit (+1 ancillary qubit) circuit <p>I have a 2 qubit (+1 ancillary qubit) circuit in Qiskit which calculates the classical OR gate (q0 or q1) as follows:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer

for input in ['00','01','10','11']:
    
    mycircuit1 = QuantumCircuit(3,1)
    
    #Initialization - Note qiskit order
    if input[0] == '1':
        mycircuit1.x(1)
    if input[1] == '1':
        mycircuit1.x(0)

    mycircuit1.cx(0,2)
    mycircuit1.cx(1,2)
    mycircuit1.ccx(0,1,2)

    mycircuit1.measure(2,0)

    job    = execute(mycircuit1, Aer.get_backend('qasm_simulator'), shots = 1000)
    counts = job.result().get_counts(mycircuit1)
    print(&quot;Input:&quot;, input, &quot;Output:&quot;, counts)
</code></pre>
<p>that returns:</p>
<pre><code>Input: 00 Output: {'0': 1000}
Input: 01 Output: {'1': 1000}
Input: 10 Output: {'1': 1000}
Input: 11 Output: {'1': 1000}
</code></pre>
<p>and and I want to expand it to a 3 qubit(+1 ancillary qubit) circuit that calculates (q0 or q1 or q2) but I do not know how. One way of thinking is that (q0 OR q1 OR q2) = (qo OR q1) OR q2
so I can put the gates from the previous circuit and repeat the process. However, I do not know how to bind these two together. Here is the circuit that I have at the moment:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer

for input in ['000','100','010','001', '110','011','101','111']:
    
    mycircuit1 = QuantumCircuit(4,1)
    
    #Initialization - Note qiskit order
    if input[0] == '1':
        mycircuit1.x(1)
    if input[1] == '1':
        mycircuit1.x(0)

    mycircuit1.cx(0,2)
    mycircuit1.cx(1,2)
    mycircuit1.ccx(0,1,2)

    mycircuit1.barrier()

    mycircuit1.cx(1,3)
    mycircuit1.cx(2,3)
    mycircuit1.ccx(1,2,3)
    
    mycircuit1.measure(3,0)

    job    = execute(mycircuit1, Aer.get_backend('qasm_simulator'), shots = 1000)
    counts = job.result().get_counts(mycircuit1)
    print(&quot;Input:&quot;, input, &quot;Output:&quot;, counts)
</code></pre>
<p>that returns:</p>
<pre><code>Input: 000 Output: {'0': 1000}
Input: 100 Output: {'1': 1000}
Input: 010 Output: {'1': 1000}
Input: 001 Output: {'0': 1000}
Input: 110 Output: {'1': 1000}
Input: 011 Output: {'1': 1000}
Input: 101 Output: {'1': 1000}
Input: 111 Output: {'1': 1000}
</code></pre>
<p>I am stuck at this point and I do not know what to do next. As demonstrated in the results if q0 or q1 equals one, the final result would be one, so if I can fix the problem in the 001 input, I can say I implemented the classical OR gate for three inputs.</p>
",qc,calculating classical gate 3 qubit ancillary qubit circuit p 2 qubit ancillary qubit circuit qiskit calculates classical gate q0 q1 follows pre code qiskit import quantumregister classicalregister quantumcircuit execute aer input mycircuit1 quantumcircuit initialization note qiskit order input 0 1 1 input 1 1 0 job execute mycircuit1 shots 1000 counts mycircuit1 print quot input quot input quot output quot counts p returns pre code input 00 output 0 1000 input 01 output 1 1000 input 10 output 1 1000 input 11 output 1 1000 p want expand 3 qubit ancillary qubit circuit calculates q0 q1 q2 know one way thinking q0 q1 q2 qo q1 q2 put gates previous circuit repeat process however know bind two together circuit moment pre code qiskit import quantumregister classicalregister quantumcircuit execute aer input mycircuit1 quantumcircuit initialization note qiskit order input 0 1 1 input 1 1 0 job execute mycircuit1 shots 1000 counts mycircuit1 print quot input quot input quot output quot counts p returns pre code input 000 output 0 1000 input 100 output 1 1000 input 010 output 1 1000 input 001 output 0 1000 input 110 output 1 1000 input 011 output 1 1000 input 101 output 1 1000 input 111 output 1 1000 p stuck point know next demonstrated results q0 q1 equals one final result would one fix problem 001 input say implemented classical gate three,"[(0, 0.24051408), (2, 0.115956366), (6, 0.018135179), (13, 0.047461104), (14, 0.34562495), (16, 0.040019054), (18, 0.14802907), (19, 0.037843022)]"
32567,32569.0,2023-05-13 00:37:35,2,94,"<p>Consider a polynomial time quantum circuit on <span class=""math-container"">$n$</span> qubits. The class of circuits under consideration encompasses the complexity class <span class=""math-container"">$\mathsf{BQP}$</span>.</p>
<p>Now, say we have an <span class=""math-container"">$n-1$</span> qubit polynomial time circuit (for example, say, after being given an <span class=""math-container"">$n$</span> qubit polynomial time circuit, we always throw away one qubit.) Is this circuit still <span class=""math-container"">$\mathsf{BQP}$</span> (or something like <span class=""math-container"">$\mathsf{BQP}_{n-1}$</span> — where this complexity class means all the computation you can do with <span class=""math-container"">$n-1$</span> qubits)? Does it make sense to ask such a question?</p>
<p>Note that if we only have <span class=""math-container"">$\log n$</span> qubits, the class is simulable in classical polynomial time. But I’m not sure how to coarse grain the hardness depending on the number of qubits. My intuition is that <span class=""math-container"">$n$</span> qubit computations cannot, in general, be done with <span class=""math-container"">$n-1$</span> qubits, but none of these classes should be classically simulable.</p>
",Confusion regarding hardness of BQP,<quantum-circuit><simulation><complexity-theory><bqp>,1,0,,,"Confusion regarding hardness of BQP <p>Consider a polynomial time quantum circuit on <span class=""math-container"">$n$</span> qubits. The class of circuits under consideration encompasses the complexity class <span class=""math-container"">$\mathsf{BQP}$</span>.</p>
<p>Now, say we have an <span class=""math-container"">$n-1$</span> qubit polynomial time circuit (for example, say, after being given an <span class=""math-container"">$n$</span> qubit polynomial time circuit, we always throw away one qubit.) Is this circuit still <span class=""math-container"">$\mathsf{BQP}$</span> (or something like <span class=""math-container"">$\mathsf{BQP}_{n-1}$</span> — where this complexity class means all the computation you can do with <span class=""math-container"">$n-1$</span> qubits)? Does it make sense to ask such a question?</p>
<p>Note that if we only have <span class=""math-container"">$\log n$</span> qubits, the class is simulable in classical polynomial time. But I’m not sure how to coarse grain the hardness depending on the number of qubits. My intuition is that <span class=""math-container"">$n$</span> qubit computations cannot, in general, be done with <span class=""math-container"">$n-1$</span> qubits, but none of these classes should be classically simulable.</p>
",qc,confusion regarding hardness bqp p consider polynomial time quantum circuit span n qubits class circuits consideration encompasses complexity class span bqp p say span qubit polynomial time circuit example say given span n qubit polynomial time circuit always throw away one qubit circuit still span bqp something like span bqp complexity class means computation span qubits make sense ask question p note span n qubits class simulable classical polynomial time sure coarse grain hardness depending number qubits intuition span n qubit computations general done span qubits none classes classically,"[(1, 0.26532236), (3, 0.30381534), (9, 0.096473366), (14, 0.1946826), (16, 0.011590981), (18, 0.126508)]"
32606,32614.0,2023-05-16 22:00:34,0,70,"<p>I am trying to create a custom ansatz to use the built-in Qiskit VQE() function. My ansatz is composed of single qubit gates and a hamiltonian gate which cannot be decomposed into  Qiskit supported gates. Here is my ansatz function:</p>
<pre><code>def quantum_state_preparation(sites, reps):
qc = QuantumCircuit(sites)
num_params = reps*(2*sites+1)
params = ParameterVector('θ', num_params)  

H = 0*SparsePauliOp('I'*(sites))
for j in range(1, sites):
    H -= 1/2 * (SparsePauliOp('I'*(j-1) + 'XX' + 'I'*(sites-j-1)) + SparsePauliOp('I'*(j-1) + 'YY' + 'I'*(sites-j-1)))
ham_op = H.simplify()

for n in range(reps):
    ham_gate = HamiltonianGate(ham_op, params[n*(2*sites+1)]/2)
    qc.append(ham_gate, range(sites))

    for i in range(sites): #single qubit gates
        qc.p(params[n*(2*sites+1)+1+2*i] ,i)
        qc.rx(params[n*(2*sites+1)+2+2*i] ,i)
qc.parameter_bounds=[[0,2*np.pi]]*num_params 
return qc
</code></pre>
<p>When I plug quantum_state_preparation(sites, reps) into the VQE() function it fails. I am pretty sure it is because HamiltonianGate() is unable to handle unbound parameters but I don't know a way around this.</p>
",Creating a parameterized Operator in Qiskit that cannot be decomposed into Qiskit supported gates,<qiskit><quantum-gate><hamiltonian-simulation><vqe>,1,0,,,"Creating a parameterized Operator in Qiskit that cannot be decomposed into Qiskit supported gates <p>I am trying to create a custom ansatz to use the built-in Qiskit VQE() function. My ansatz is composed of single qubit gates and a hamiltonian gate which cannot be decomposed into  Qiskit supported gates. Here is my ansatz function:</p>
<pre><code>def quantum_state_preparation(sites, reps):
qc = QuantumCircuit(sites)
num_params = reps*(2*sites+1)
params = ParameterVector('θ', num_params)  

H = 0*SparsePauliOp('I'*(sites))
for j in range(1, sites):
    H -= 1/2 * (SparsePauliOp('I'*(j-1) + 'XX' + 'I'*(sites-j-1)) + SparsePauliOp('I'*(j-1) + 'YY' + 'I'*(sites-j-1)))
ham_op = H.simplify()

for n in range(reps):
    ham_gate = HamiltonianGate(ham_op, params[n*(2*sites+1)]/2)
    qc.append(ham_gate, range(sites))

    for i in range(sites): #single qubit gates
        qc.p(params[n*(2*sites+1)+1+2*i] ,i)
        qc.rx(params[n*(2*sites+1)+2+2*i] ,i)
qc.parameter_bounds=[[0,2*np.pi]]*num_params 
return qc
</code></pre>
<p>When I plug quantum_state_preparation(sites, reps) into the VQE() function it fails. I am pretty sure it is because HamiltonianGate() is unable to handle unbound parameters but I don't know a way around this.</p>
",qc,creating parameterized operator qiskit decomposed qiskit supported gates p trying create custom ansatz use qiskit vqe function ansatz composed single qubit gates hamiltonian gate decomposed qiskit supported gates ansatz function pre code def sites reps qc quantumcircuit sites reps 2 params parametervector θ h 0 sparsepauliop sites j range 1 sites h sparsepauliop sparsepauliop n range reps hamiltoniangate params n 2 range sites range sites single qubit gates params n 2 params n 2 return qc p plug sites reps vqe function fails pretty sure hamiltoniangate unable handle unbound parameters know way around,"[(0, 0.4685547), (2, 0.04975377), (3, 0.0148573695), (9, 0.07145312), (10, 0.12328702), (12, 0.021684514), (14, 0.23823857), (16, 0.010879513)]"
32616,,2023-05-17 14:27:24,4,389,"<p>I'm interested in making a little list of papers that include a proof that lattice surgery really does what it claims to do; namely, performs a pairwise logical measurement. The <a href=""https://doi.org/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">original paper</a> (<a href=""https://doi.org/10.48550/arXiv.1111.4022"" rel=""nofollow noreferrer"">arXiv</a>) gives a detailed sketch of what the protocol does but perhaps doesn't quite constitute a rigorous proof that it really works. A couple of papers (1: <a href=""https://doi.org/10.1088/1367-2630/ab0199"" rel=""nofollow noreferrer"">published</a>, <a href=""https://doi.org/10.48550/arXiv.1810.10037"" rel=""nofollow noreferrer"">arXiv</a>, 2: <a href=""https://doi.org/10.22331/q-2020-01-09-218"" rel=""nofollow noreferrer"">published</a>, <a href=""https://doi.org/10.48550/arXiv.1704.08670"" rel=""nofollow noreferrer"">arXiv</a>) prove that the <em>merge step</em> of the protocol is a projector at the logical level, and the <em>splitting step</em> is its adjoint. A third <a href=""https://doi.org/10.48550/arXiv.2204.14038"" rel=""nofollow noreferrer"">uses low-level ZX-calculus</a>,
and a fourth <a href=""https://doi.org/10.1038/s41586-020-03079-6"" rel=""nofollow noreferrer"">uses the stabilizer formalism</a> (<a href=""https://doi.org/10.48550/arXiv.2006.03071"" rel=""nofollow noreferrer"">arXiv</a>).</p>
<p>Are there other papers out there you know of that contain a proof that lattice surgery works as described? Only needs to be for a specific example code (e.g. surface code of a certain size). Thanks in advance!</p>
",Proofs that lattice surgery does what it claims to do,<error-correction><resource-request><stabilizer-code>,1,0,,,"Proofs that lattice surgery does what it claims to do <p>I'm interested in making a little list of papers that include a proof that lattice surgery really does what it claims to do; namely, performs a pairwise logical measurement. The <a href=""https://doi.org/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">original paper</a> (<a href=""https://doi.org/10.48550/arXiv.1111.4022"" rel=""nofollow noreferrer"">arXiv</a>) gives a detailed sketch of what the protocol does but perhaps doesn't quite constitute a rigorous proof that it really works. A couple of papers (1: <a href=""https://doi.org/10.1088/1367-2630/ab0199"" rel=""nofollow noreferrer"">published</a>, <a href=""https://doi.org/10.48550/arXiv.1810.10037"" rel=""nofollow noreferrer"">arXiv</a>, 2: <a href=""https://doi.org/10.22331/q-2020-01-09-218"" rel=""nofollow noreferrer"">published</a>, <a href=""https://doi.org/10.48550/arXiv.1704.08670"" rel=""nofollow noreferrer"">arXiv</a>) prove that the <em>merge step</em> of the protocol is a projector at the logical level, and the <em>splitting step</em> is its adjoint. A third <a href=""https://doi.org/10.48550/arXiv.2204.14038"" rel=""nofollow noreferrer"">uses low-level ZX-calculus</a>,
and a fourth <a href=""https://doi.org/10.1038/s41586-020-03079-6"" rel=""nofollow noreferrer"">uses the stabilizer formalism</a> (<a href=""https://doi.org/10.48550/arXiv.2006.03071"" rel=""nofollow noreferrer"">arXiv</a>).</p>
<p>Are there other papers out there you know of that contain a proof that lattice surgery works as described? Only needs to be for a specific example code (e.g. surface code of a certain size). Thanks in advance!</p>
",qc,proofs lattice surgery claims p interested making little list papers include proof lattice surgery really claims namely performs pairwise logical measurement https nofollow noreferrer original paper https nofollow noreferrer arxiv gives detailed sketch protocol perhaps quite constitute rigorous proof really works couple papers 1 https nofollow noreferrer published https nofollow noreferrer arxiv 2 https nofollow noreferrer published https nofollow noreferrer arxiv prove em merge step protocol projector logical level em splitting step adjoint third https nofollow noreferrer uses fourth https nofollow noreferrer uses stabilizer formalism https nofollow noreferrer arxiv p papers know contain proof lattice surgery works described needs specific example code surface code certain size thanks advance,"[(3, 0.03923602), (4, 0.27448708), (5, 0.0954624), (7, 0.15811765), (9, 0.3018178), (16, 0.06023999), (18, 0.0694364)]"
32684,32696.0,2023-05-22 20:48:16,1,637,"<p>I am trying to run the quantum communication algorithm from qiskit textbook &quot;Entangled States&quot; using my IBM API key, however, it throws the error <code>RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment.</code>. What am I doing wrong? This is my code:</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY])
backend = service.least_busy(simulator=False, operational=True)
print(f'Running on {backend}')

qc_charlie = QuantumCircuit(2,2)

qc_charlie.h(1)
qc_charlie.cx(1,0)


MESSAGE = '01'

qc_alice = QuantumCircuit(2,2)

if MESSAGE[-2]=='1':
    qc_alice.z(1)
if MESSAGE[-1]=='1':
    qc_alice.x(1)

qc_bob = QuantumCircuit(2,2)
# Bob disentangles
qc_bob.cx(1,0)
qc_bob.h(1)
# Then measures
qc_bob.measure([0,1],[0,1])


complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob))
backend.run(complete_qc).result().get_counts()
</code></pre>
<p>I know the API works since I get <code>Running on &lt;IBMBackend('ibmq_belem')&gt;</code> and the circuit is ok as i can see it using <code>qc_charlie.draw()</code>, <code>qc_alice.draw()</code> and <code>qc_bob.draw()</code>.</p>
",qiskit textbook code throws RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment,<qiskit><programming>,2,0,,,"qiskit textbook code throws RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment <p>I am trying to run the quantum communication algorithm from qiskit textbook &quot;Entangled States&quot; using my IBM API key, however, it throws the error <code>RuntimeError: IBMBackend.run() is not supported in the Qiskit Runtime environment.</code>. What am I doing wrong? This is my code:</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=[REDACTED API KEY])
backend = service.least_busy(simulator=False, operational=True)
print(f'Running on {backend}')

qc_charlie = QuantumCircuit(2,2)

qc_charlie.h(1)
qc_charlie.cx(1,0)


MESSAGE = '01'

qc_alice = QuantumCircuit(2,2)

if MESSAGE[-2]=='1':
    qc_alice.z(1)
if MESSAGE[-1]=='1':
    qc_alice.x(1)

qc_bob = QuantumCircuit(2,2)
# Bob disentangles
qc_bob.cx(1,0)
qc_bob.h(1)
# Then measures
qc_bob.measure([0,1],[0,1])


complete_qc = qc_charlie.compose(qc_alice.compose(qc_bob))
backend.run(complete_qc).result().get_counts()
</code></pre>
<p>I know the API works since I get <code>Running on &lt;IBMBackend('ibmq_belem')&gt;</code> and the circuit is ok as i can see it using <code>qc_charlie.draw()</code>, <code>qc_alice.draw()</code> and <code>qc_bob.draw()</code>.</p>
",qc,qiskit textbook code throws runtimeerror supported qiskit runtime environment p trying run quantum communication algorithm qiskit textbook quot entangled states quot using ibm api key however throws error code runtimeerror supported qiskit runtime wrong code pre code service qiskitruntimeservice quot quot redacted api key backend print backend quantumcircuit 1 message quantumcircuit message 1 1 message 1 1 quantumcircuit bob disentangles 1 measures p know api works since get code running lt ibmbackend gt circuit ok see using code code code,"[(0, 0.47355494), (2, 0.058286462), (14, 0.26275018), (16, 0.037921242), (18, 0.09926509), (19, 0.06643122)]"
32700,32714.0,2023-05-24 08:00:15,3,240,"<p>In the <a href=""https://learn.qiskit.org/course/ch-algorithms/quantum-fourier-transform#example1"" rel=""nofollow noreferrer"">qiskit</a> example for QFT demonstration the ibm_q_bogota is used, it has the following layout:</p>
<p><a href=""https://i.sstatic.net/GjgVw.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GjgVw.png"" alt=""enter image description here"" /></a></p>
<p>in the same time the measurement circuit for QFT demonstration is:</p>
<p><a href=""https://i.sstatic.net/1LcsC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/1LcsC.png"" alt=""enter image description here"" /></a></p>
<p>For such a linear layout how is it possible to implement CPHASE gate between Q0 and Q2? According to the layout, there is no physical connection between them.</p>
","In the qiskit QFT demonstration, how to implement CPHASE between Q0 and Q1?",<qiskit><quantum-fourier-transform>,2,0,,,"In the qiskit QFT demonstration, how to implement CPHASE between Q0 and Q1? <p>In the <a href=""https://learn.qiskit.org/course/ch-algorithms/quantum-fourier-transform#example1"" rel=""nofollow noreferrer"">qiskit</a> example for QFT demonstration the ibm_q_bogota is used, it has the following layout:</p>
<p><a href=""https://i.sstatic.net/GjgVw.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GjgVw.png"" alt=""enter image description here"" /></a></p>
<p>in the same time the measurement circuit for QFT demonstration is:</p>
<p><a href=""https://i.sstatic.net/1LcsC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/1LcsC.png"" alt=""enter image description here"" /></a></p>
<p>For such a linear layout how is it possible to implement CPHASE gate between Q0 and Q2? According to the layout, there is no physical connection between them.</p>
",qc,qiskit qft demonstration implement cphase q0 q1 p https example1 nofollow noreferrer qiskit example qft demonstration used following layout p https nofollow noreferrer img https enter image description p time measurement circuit qft demonstration p https nofollow noreferrer img https enter image description p linear layout possible implement cphase gate q0 q2 according layout physical connection,"[(4, 0.5246042), (7, 0.08768424), (9, 0.12614484), (14, 0.20420583), (16, 0.054639272)]"
32732,32739.0,2023-05-26 07:22:29,1,2307,"<p>I have a quantum circuit that loads the data and is acting on qubit <code>q0,q1,q2</code> then another circuit that does the same on <code>q3,q4,q5</code> then I have to apply an <code>CDKMRippleCarryAdder</code> and few other ansatz parameterized gates acting on specific qubits.
How can I add this all to one big circuit and run it. I already tried <code>add</code> function, but it doesn't specify which qubits should it be applied. I also tried <code>compose</code> function, although it has the parameter of specific qubits, it adds classical registers to the circuit, which in the end are giving me trouble in applying the <code>GroverOperator</code> of the <code>EstimationProblem</code> function. Is there any other way</p>
",How to join different quantum circuits into one big circuit on specific qubits in qiskit?,<qiskit><quantum-gate><quantum-circuit>,3,0,,,"How to join different quantum circuits into one big circuit on specific qubits in qiskit? <p>I have a quantum circuit that loads the data and is acting on qubit <code>q0,q1,q2</code> then another circuit that does the same on <code>q3,q4,q5</code> then I have to apply an <code>CDKMRippleCarryAdder</code> and few other ansatz parameterized gates acting on specific qubits.
How can I add this all to one big circuit and run it. I already tried <code>add</code> function, but it doesn't specify which qubits should it be applied. I also tried <code>compose</code> function, although it has the parameter of specific qubits, it adds classical registers to the circuit, which in the end are giving me trouble in applying the <code>GroverOperator</code> of the <code>EstimationProblem</code> function. Is there any other way</p>
",qc,join different quantum circuits one big circuit specific qubits qiskit p quantum circuit loads data acting qubit code q0 q1 q2 another circuit code q3 q4 q5 apply code cdkmripplecarryadder ansatz parameterized gates acting specific qubits add one big circuit run already tried code add function specify qubits applied also tried code compose function although parameter specific qubits adds classical registers circuit end giving trouble applying code groveroperator code estimationproblem function way,"[(6, 0.013246054), (14, 0.9098928), (16, 0.031006219), (19, 0.043537963)]"
32759,,2023-05-29 01:32:14,1,436,"<p>In qiskit the method to apply a multi control with more than 2 control qubits is:</p>
<pre><code>qc.mct ( listcontrols,targetbit,listancillas, mode=mode[i])
</code></pre>
<p>What is the equivalent in Cirq for creating that operation to append to a cirquit?. <BR>
What i need  is to decompose that operation into [RX,RY,RZ, X,H,CX], like in qiskit with transpile.</p>
",How to create a multicontrol mcx gate or operation in cirq,<quantum-gate><cirq>,2,0,,,"How to create a multicontrol mcx gate or operation in cirq <p>In qiskit the method to apply a multi control with more than 2 control qubits is:</p>
<pre><code>qc.mct ( listcontrols,targetbit,listancillas, mode=mode[i])
</code></pre>
<p>What is the equivalent in Cirq for creating that operation to append to a cirquit?. <BR>
What i need  is to decompose that operation into [RX,RY,RZ, X,H,CX], like in qiskit with transpile.</p>
",qc,create multicontrol mcx gate operation cirq p qiskit method apply multi control 2 control qubits pre code listcontrols targetbit listancillas p equivalent cirq creating operation append cirquit br need decompose operation rx ry rz x h cx like qiskit,"[(6, 0.07383176), (10, 0.03155969), (14, 0.6129699), (16, 0.14376648), (18, 0.1334851)]"
32782,32785.0,2023-05-30 07:46:57,0,232,"<p>I have installed <code>cirq</code> in my anaconda environment by using the command:
<code>pip install cirq</code></p>
<p>When I ran the code below to print the topology of Google Sycamore device:</p>
<pre><code>import cirq_google
print(cirq_google.Sycamore)
</code></pre>
<p>It gave the following output.</p>
<pre><code>                                             (0, 5)───(0, 6)
                                             │        │
                                             │        │
                                    (1, 4)───(1, 5)───(1, 6)───(1, 7)
                                    │        │        │        │
                                    │        │        │        │
                           (2, 3)───(2, 4)───(2, 5)───(2, 6)───(2, 7)───(2, 8)
                           │        │        │        │        │        │
                           │        │        │        │        │        │
                  (3, 2)───(3, 3)───(3, 4)───(3, 5)───(3, 6)───(3, 7)───(3, 8)───(3, 9)
                  │        │        │        │        │        │        │        │
                  │        │        │        │        │        │        │        │
         (4, 1)───(4, 2)───(4, 3)───(4, 4)───(4, 5)───(4, 6)───(4, 7)───(4, 8)───(4, 9)
         │        │        │        │        │        │        │        │
         │        │        │        │        │        │        │        │
(5, 0)───(5, 1)───(5, 2)───(5, 3)───(5, 4)───(5, 5)───(5, 6)───(5, 7)───(5, 8)
         │        │        │        │        │        │        │
         │        │        │        │        │        │        │
         (6, 1)───(6, 2)───(6, 3)───(6, 4)───(6, 5)───(6, 6)───(6, 7)
                  │        │        │        │        │
                  │        │        │        │        │
                  (7, 2)───(7, 3)───(7, 4)───(7, 5)───(7, 6)
                           │        │        │
                           │        │        │
                           (8, 3)───(8, 4)───(8, 5)
                                    │
                                    │
                                    (9, 4)
</code></pre>
<p><strong>But</strong> when I tried to run for Google Foxtail device:</p>
<pre><code>print(cirq_google.Foxtail)
</code></pre>
<p>The following error occurs-
<code>AttributeError: module 'cirq_google' has no attribute 'Foxtail'</code></p>
<p>Please help me to solve the issue.</p>
",AttributeError: module 'cirq_google' has no attribute 'Foxtail',<programming><cirq>,1,0,,,"AttributeError: module 'cirq_google' has no attribute 'Foxtail' <p>I have installed <code>cirq</code> in my anaconda environment by using the command:
<code>pip install cirq</code></p>
<p>When I ran the code below to print the topology of Google Sycamore device:</p>
<pre><code>import cirq_google
print(cirq_google.Sycamore)
</code></pre>
<p>It gave the following output.</p>
<pre><code>                                             (0, 5)───(0, 6)
                                             │        │
                                             │        │
                                    (1, 4)───(1, 5)───(1, 6)───(1, 7)
                                    │        │        │        │
                                    │        │        │        │
                           (2, 3)───(2, 4)───(2, 5)───(2, 6)───(2, 7)───(2, 8)
                           │        │        │        │        │        │
                           │        │        │        │        │        │
                  (3, 2)───(3, 3)───(3, 4)───(3, 5)───(3, 6)───(3, 7)───(3, 8)───(3, 9)
                  │        │        │        │        │        │        │        │
                  │        │        │        │        │        │        │        │
         (4, 1)───(4, 2)───(4, 3)───(4, 4)───(4, 5)───(4, 6)───(4, 7)───(4, 8)───(4, 9)
         │        │        │        │        │        │        │        │
         │        │        │        │        │        │        │        │
(5, 0)───(5, 1)───(5, 2)───(5, 3)───(5, 4)───(5, 5)───(5, 6)───(5, 7)───(5, 8)
         │        │        │        │        │        │        │
         │        │        │        │        │        │        │
         (6, 1)───(6, 2)───(6, 3)───(6, 4)───(6, 5)───(6, 6)───(6, 7)
                  │        │        │        │        │
                  │        │        │        │        │
                  (7, 2)───(7, 3)───(7, 4)───(7, 5)───(7, 6)
                           │        │        │
                           │        │        │
                           (8, 3)───(8, 4)───(8, 5)
                                    │
                                    │
                                    (9, 4)
</code></pre>
<p><strong>But</strong> when I tried to run for Google Foxtail device:</p>
<pre><code>print(cirq_google.Foxtail)
</code></pre>
<p>The following error occurs-
<code>AttributeError: module 'cirq_google' has no attribute 'Foxtail'</code></p>
<p>Please help me to solve the issue.</p>
",qc,attributeerror module attribute p installed code cirq anaconda environment using command code pip install cirq p ran code print topology google sycamore device pre code import print p gave following pre code 0 5 0 6 1 4 1 5 1 6 1 7 2 3 2 4 2 5 2 6 2 7 2 8 3 2 3 3 3 4 3 5 3 6 3 7 3 8 3 9 4 1 4 2 4 3 4 4 4 5 4 6 4 7 4 8 4 9 5 0 5 1 5 2 5 3 5 4 5 5 5 6 5 7 5 8 6 1 6 2 6 3 6 4 6 5 6 6 6 7 7 2 7 3 7 4 7 5 7 6 8 3 8 4 8 5 9 4 p strong tried run google foxtail device pre code print p following error code attributeerror module attribute p please help solve,"[(0, 0.2088842), (4, 0.03653683), (6, 0.6925938), (14, 0.039014697), (16, 0.022028035)]"
32833,,2023-06-02 12:41:32,0,109,"<p><a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.67.661"" rel=""nofollow noreferrer"">Ekert's 1999 paper</a> (<a href=""https://drive.google.com/file/d/1Xp6Z8j04aF-BOdHODTk83khATlc7fD3H/view?usp=sharing"" rel=""nofollow noreferrer"">link to download</a>) cites the classic CHSH paper on generalized Bell inequality and says</p>
<p>(2) <span class=""math-container"">$E(a,b)=-a\cdot b$</span></p>
<p>(3) <span class=""math-container"">$S = E(a_1,b_1)-E(a_1,b_3)+E(a_3,b_1)_E(a_3,b_3)$</span></p>
<p>(4) <span class=""math-container"">$S = -2\sqrt(2)$</span> This is the CSHS score</p>
<p>They state that for certain choices of a and b from <span class=""math-container"">$a\in\{0,\pi/4,\pi/2\}$</span> and <span class=""math-container"">$b\in\{\pi/4,\pi/2,3\pi/4\}$</span>, equation 4 holds. Not having read the paper carefully enough, I believed that a and b were random angles on the unit circle. When I calculated it that way, equation (4) was not satified. That is why I posted the question.</p>
<p>However, for <span class=""math-container"">$a_1=0, a_3=\pi/2,b_1=\pi.4,b_2=3\pi/4$</span>, it is satisfied.</p>
","Verifying equation 4 in Ekert's paper ""Quantum Cryptography Based on Bell's Theorem""",<bell-experiment>,1,6,,,"Verifying equation 4 in Ekert's paper ""Quantum Cryptography Based on Bell's Theorem"" <p><a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.67.661"" rel=""nofollow noreferrer"">Ekert's 1999 paper</a> (<a href=""https://drive.google.com/file/d/1Xp6Z8j04aF-BOdHODTk83khATlc7fD3H/view?usp=sharing"" rel=""nofollow noreferrer"">link to download</a>) cites the classic CHSH paper on generalized Bell inequality and says</p>
<p>(2) <span class=""math-container"">$E(a,b)=-a\cdot b$</span></p>
<p>(3) <span class=""math-container"">$S = E(a_1,b_1)-E(a_1,b_3)+E(a_3,b_1)_E(a_3,b_3)$</span></p>
<p>(4) <span class=""math-container"">$S = -2\sqrt(2)$</span> This is the CSHS score</p>
<p>They state that for certain choices of a and b from <span class=""math-container"">$a\in\{0,\pi/4,\pi/2\}$</span> and <span class=""math-container"">$b\in\{\pi/4,\pi/2,3\pi/4\}$</span>, equation 4 holds. Not having read the paper carefully enough, I believed that a and b were random angles on the unit circle. When I calculated it that way, equation (4) was not satified. That is why I posted the question.</p>
<p>However, for <span class=""math-container"">$a_1=0, a_3=\pi/2,b_1=\pi.4,b_2=3\pi/4$</span>, it is satisfied.</p>
",qc,verifying equation 4 ekert paper quantum cryptography based bell theorem p https nofollow noreferrer ekert 1999 paper https nofollow noreferrer link download cites classic chsh paper generalized bell inequality says p 2 span e b b p 3 span e p 4 span 2 cshs score p state certain choices b span 0 span equation 4 holds read paper carefully enough believed b random angles unit circle calculated way equation 4 satified posted p however span,"[(2, 0.042458303), (3, 0.42699593), (4, 0.14550617), (6, 0.04819516), (7, 0.05069494), (11, 0.033487316), (13, 0.14609435), (15, 0.023823837), (16, 0.024521822), (18, 0.056872424)]"
32863,,2023-06-05 19:24:29,1,355,"<p>This is an understanding check more than an actual question. Implementing lattice surgery has already been discussed on the forum: <a href=""https://quantumcomputing.stackexchange.com/questions/32382/how-to-implement-lattice-surgery-in-stim"">How to implement lattice surgery in stim?</a> -- I'm just trying to make sure I understand everything perfectly (including lattice surgery itself).</p>
<p><a href=""https://i.sstatic.net/Jd4Ro.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Jd4Ro.png"" alt=""Initial state with two patches and a column of uninitialized data qubits"" /></a></p>
<p>The figure above shows the initial condition for two d=3 patches (rotated) before a lattice surgery <code>merge</code> operation.</p>
<p>Next, as soon as a <code>merge</code> operation starts, the combined patch looks like the figure below:</p>
<p><a href=""https://i.sstatic.net/UqjyQ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UqjyQ.png"" alt=""Merged patch"" /></a></p>
<p>A few questions up till this point:</p>
<ul>
<li>Are X-measure qubits <strong>10</strong> and <strong>12</strong> needed at all? Or can I get away by ignoring them?</li>
<li>Data qubits <strong>j</strong>, <strong>k</strong>, <strong>l</strong> will be initialized in the Z-basis since it's the basis of the lattice surgery. Consequently, in Stim, the detector annotations for X-measure qubits <strong>9, 10, 12, 13</strong> will not be included in the first round of the <code>merge</code> operation?</li>
<li>The Z-measure qubits <strong>7</strong>, <strong>15</strong> are changing from 2-body operators to 4-body operators, but the corresponding detector annotations will keep comparing the measurement in the first round after the <code>merge</code> operation with the measurement just prior to <code>merge</code>?</li>
<li>Will the two qubits be considered <em>merged</em> after <em>d</em> rounds of syndrome measurements? What would the logical observable now be for Stim?</li>
</ul>
<p>Next, suppose I want to perform a <code>split</code> operation on the same merged patch. This would involve measuring the intermediate data qubits <strong>j, k, l</strong>:</p>
<ul>
<li>The intermediate qubits will be measured in the basis of the lattice surgery (Z) and then used in the detector annotations of the Z-measure qubits <strong>7</strong> and <strong>15</strong>? More specifically, if the measurement records for the intermediate qubits are <code>rec[-5] rec[-6] rec[-7]</code> and the measurement records for qubits <strong>7</strong> and <strong>15</strong> just before the split are <code>rec[-8] rec[-9]</code> (for simplicity), the detector annotation for qubits <strong>7</strong> and <strong>15</strong> in the first round of the <code>split</code> operation would be (assuming <code>rec[-1] rec[-2]</code> are the most recent measurements for qubits <strong>7</strong> and <strong>15</strong>:</li>
</ul>
<pre><code>DETECTOR(Qubit 7) rec[-1] rec[-8] rec[-5] rec[-6] rec[-7]
DETECTOR(Qubit 15) rec[-2] rec[-9] rec[-5] rec[-6] rec[-7]
</code></pre>
<p>I'm still in the process of understanding surface codes and lattice surgery, so it's very likely I'm missing fundamental things here but I would really appreciate all answers and explanations, thank you!</p>
",Stim: Implementing lattice surgery,<stim><surface-code>,0,7,,,"Stim: Implementing lattice surgery <p>This is an understanding check more than an actual question. Implementing lattice surgery has already been discussed on the forum: <a href=""https://quantumcomputing.stackexchange.com/questions/32382/how-to-implement-lattice-surgery-in-stim"">How to implement lattice surgery in stim?</a> -- I'm just trying to make sure I understand everything perfectly (including lattice surgery itself).</p>
<p><a href=""https://i.sstatic.net/Jd4Ro.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Jd4Ro.png"" alt=""Initial state with two patches and a column of uninitialized data qubits"" /></a></p>
<p>The figure above shows the initial condition for two d=3 patches (rotated) before a lattice surgery <code>merge</code> operation.</p>
<p>Next, as soon as a <code>merge</code> operation starts, the combined patch looks like the figure below:</p>
<p><a href=""https://i.sstatic.net/UqjyQ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UqjyQ.png"" alt=""Merged patch"" /></a></p>
<p>A few questions up till this point:</p>
<ul>
<li>Are X-measure qubits <strong>10</strong> and <strong>12</strong> needed at all? Or can I get away by ignoring them?</li>
<li>Data qubits <strong>j</strong>, <strong>k</strong>, <strong>l</strong> will be initialized in the Z-basis since it's the basis of the lattice surgery. Consequently, in Stim, the detector annotations for X-measure qubits <strong>9, 10, 12, 13</strong> will not be included in the first round of the <code>merge</code> operation?</li>
<li>The Z-measure qubits <strong>7</strong>, <strong>15</strong> are changing from 2-body operators to 4-body operators, but the corresponding detector annotations will keep comparing the measurement in the first round after the <code>merge</code> operation with the measurement just prior to <code>merge</code>?</li>
<li>Will the two qubits be considered <em>merged</em> after <em>d</em> rounds of syndrome measurements? What would the logical observable now be for Stim?</li>
</ul>
<p>Next, suppose I want to perform a <code>split</code> operation on the same merged patch. This would involve measuring the intermediate data qubits <strong>j, k, l</strong>:</p>
<ul>
<li>The intermediate qubits will be measured in the basis of the lattice surgery (Z) and then used in the detector annotations of the Z-measure qubits <strong>7</strong> and <strong>15</strong>? More specifically, if the measurement records for the intermediate qubits are <code>rec[-5] rec[-6] rec[-7]</code> and the measurement records for qubits <strong>7</strong> and <strong>15</strong> just before the split are <code>rec[-8] rec[-9]</code> (for simplicity), the detector annotation for qubits <strong>7</strong> and <strong>15</strong> in the first round of the <code>split</code> operation would be (assuming <code>rec[-1] rec[-2]</code> are the most recent measurements for qubits <strong>7</strong> and <strong>15</strong>:</li>
</ul>
<pre><code>DETECTOR(Qubit 7) rec[-1] rec[-8] rec[-5] rec[-6] rec[-7]
DETECTOR(Qubit 15) rec[-2] rec[-9] rec[-5] rec[-6] rec[-7]
</code></pre>
<p>I'm still in the process of understanding surface codes and lattice surgery, so it's very likely I'm missing fundamental things here but I would really appreciate all answers and explanations, thank you!</p>
",qc,stim implementing lattice surgery p understanding check actual question implementing lattice surgery already discussed forum https implement lattice surgery stim trying make sure understand everything perfectly including lattice surgery p https nofollow noreferrer img https initial state two patches column uninitialized data qubits p figure shows initial condition two patches rotated lattice surgery code merge p next soon code merge operation starts combined patch looks like figure p https nofollow noreferrer img https merged patch p questions till point ul li qubits strong 10 strong 12 needed get away ignoring li data qubits strong j strong k strong l initialized since basis lattice surgery consequently stim detector annotations qubits strong 9 10 12 13 included first round code merge operation li qubits strong 7 strong 15 changing operators operators corresponding detector annotations keep comparing measurement first round code merge operation measurement prior code merge li two qubits considered em merged em rounds syndrome measurements would logical observable stim p next suppose want perform code split operation merged patch would involve measuring intermediate data qubits strong j k l ul li intermediate qubits measured basis lattice surgery z used detector annotations qubits strong 7 strong 15 specifically measurement records intermediate qubits code rec rec rec measurement records qubits strong 7 strong 15 split code rec rec simplicity detector annotation qubits strong 7 strong 15 first round code split operation would assuming code rec rec recent measurements qubits strong 7 strong 15 pre code detector qubit 7 rec rec rec rec rec detector qubit 15 rec rec rec rec rec p still process understanding surface codes lattice surgery likely missing fundamental things would really appreciate answers explanations thank,"[(3, 0.02948777), (4, 0.058258317), (5, 0.25176227), (6, 0.17653298), (7, 0.07684208), (8, 0.012008629), (9, 0.06603949), (13, 0.051826235), (16, 0.09132684), (18, 0.18555175)]"
32925,32950.0,2023-06-10 21:45:50,2,252,"<p>I've only recently, and still only haphazardly and rather poorly, begun to understand Ising models with local interactions.  I'm interested in particular in the simple one-dimensional Ising model with nearest <em>and next-nearest</em> neighbor interactions, which have been referred to in the literature as ANNNI Hamiltonians, or anisotropic, next-nearest neighbor interactions (with none, either, or both a transverse and longitudinal external magnetic field).</p>
<p>Depending on the strengths of the nearest-neighbor interactions relative to the next-nearest neighbor interactions (and also to the external magnetic fields) there could be very lovely and dynamic frustration going on - the nearest neighbor might favor parallel spins <span class=""math-container"">$\mid\uparrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\downarrow\downarrow\rangle$</span> but the next-nearest neighbor interactions might force antiparallel spins <span class=""math-container"">$\mid\downarrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\uparrow\downarrow\rangle$</span>, or <em>vice-versa</em>.</p>
<ul>
<li><strong>Can we say anything about if and when frustration leads to an entangled ground state?</strong></li>
</ul>
<p>The answer might be related to so-called area laws, which consider the amount of entanglement relative to the dimension of the chain.  For a one-dimensional chain an area law suggests that there may be little entanglement, but is there any additional entanglement borne out of frustration?</p>
<hr />
<p>This was also partly inspired by Sandy Irani's presentation at the Israeli Institute for Advanced Studies <a href=""https://www.youtube.com/watch?v=L8o_M8twaOs"" rel=""nofollow noreferrer"">here</a>, where she mentions frustration in the context of a <a href=""https://www.manybody.phy.cam.ac.uk/Research/kagome#:%7E:text=The%20Kagome%20lattice%20consists%20of,both%20possible%20configurations%20will%20always"" rel=""nofollow noreferrer"">Kagome lattice</a>.</p>
<p><a href=""https://i.sstatic.net/coxqj.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/coxqj.jpg"" alt=""Kagome Lattice"" /></a></p>
<p>I gathered from her talk that the Kagome lattice puts some stress on naive implementations of classical many-body algorithms like DMRG, but nonetheless from clever DMRG simulations there's some evidence that the lattice does indeed have a uniquely quantum (non-degenerate and highly entangled) ground state.</p>
",(When) must the ground state of a frustrated Hamiltonian be entangled?,<entanglement><hamiltonian-simulation><ion-trap-quantum-computing><ising-model>,1,1,,,"(When) must the ground state of a frustrated Hamiltonian be entangled? <p>I've only recently, and still only haphazardly and rather poorly, begun to understand Ising models with local interactions.  I'm interested in particular in the simple one-dimensional Ising model with nearest <em>and next-nearest</em> neighbor interactions, which have been referred to in the literature as ANNNI Hamiltonians, or anisotropic, next-nearest neighbor interactions (with none, either, or both a transverse and longitudinal external magnetic field).</p>
<p>Depending on the strengths of the nearest-neighbor interactions relative to the next-nearest neighbor interactions (and also to the external magnetic fields) there could be very lovely and dynamic frustration going on - the nearest neighbor might favor parallel spins <span class=""math-container"">$\mid\uparrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\downarrow\downarrow\rangle$</span> but the next-nearest neighbor interactions might force antiparallel spins <span class=""math-container"">$\mid\downarrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\uparrow\downarrow\rangle$</span>, or <em>vice-versa</em>.</p>
<ul>
<li><strong>Can we say anything about if and when frustration leads to an entangled ground state?</strong></li>
</ul>
<p>The answer might be related to so-called area laws, which consider the amount of entanglement relative to the dimension of the chain.  For a one-dimensional chain an area law suggests that there may be little entanglement, but is there any additional entanglement borne out of frustration?</p>
<hr />
<p>This was also partly inspired by Sandy Irani's presentation at the Israeli Institute for Advanced Studies <a href=""https://www.youtube.com/watch?v=L8o_M8twaOs"" rel=""nofollow noreferrer"">here</a>, where she mentions frustration in the context of a <a href=""https://www.manybody.phy.cam.ac.uk/Research/kagome#:%7E:text=The%20Kagome%20lattice%20consists%20of,both%20possible%20configurations%20will%20always"" rel=""nofollow noreferrer"">Kagome lattice</a>.</p>
<p><a href=""https://i.sstatic.net/coxqj.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/coxqj.jpg"" alt=""Kagome Lattice"" /></a></p>
<p>I gathered from her talk that the Kagome lattice puts some stress on naive implementations of classical many-body algorithms like DMRG, but nonetheless from clever DMRG simulations there's some evidence that the lattice does indeed have a uniquely quantum (non-degenerate and highly entangled) ground state.</p>
",qc,must ground state frustrated hamiltonian entangled p recently still haphazardly rather poorly begun understand ising models local interactions interested particular simple ising model nearest em neighbor interactions referred literature annni hamiltonians anisotropic neighbor interactions none either transverse longitudinal external magnetic field p depending strengths interactions relative neighbor interactions also external magnetic fields could lovely dynamic frustration going nearest neighbor might favor parallel spins span span neighbor interactions might force antiparallel spins span span em ul li strong say anything frustration leads entangled ground state p answer might related area laws consider amount entanglement relative dimension chain chain area law suggests may little entanglement additional entanglement borne frustration hr p also partly inspired sandy irani presentation israeli institute advanced studies https nofollow noreferrer mentions frustration context https 7e 20kagome 20lattice 20consists 20of 20possible 20configurations 20will 20always nofollow noreferrer kagome lattice p https nofollow noreferrer img https kagome lattice p gathered talk kagome lattice puts stress naive implementations classical algorithms like dmrg nonetheless clever dmrg simulations evidence lattice indeed uniquely quantum highly entangled ground,"[(1, 0.10728454), (4, 0.015326524), (8, 0.09365161), (9, 0.5426447), (13, 0.1013161), (15, 0.0128625315), (16, 0.033076875), (17, 0.014590369), (18, 0.06956488)]"
32946,32952.0,2023-06-12 14:10:43,0,193,"<p>In this paper: <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011</a>, the authors describes how to inject a magic state into a small planar surface code, and then how to expand the code (see figures 8d and 8e).<a href=""https://i.sstatic.net/wOwmL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wOwmL.png"" alt=""The figure from the paper showing the state injection and lattice expansion process"" /></a>.</p>
<p>I cannot understand the expansion process. Since the additional qubits are initialized to the |0&gt; state, a transversal ZZZZ operator (the logical Z) is a stabilizer of the system before and after the syndrome measurements. Therefore, the system must end in either the logical 0 or logical 1, and cannot be in any superposition.</p>
<p>Another point of view on my question is that the suggested process &quot;measures&quot; the original (pink) surface code in the z basis. If the original (pink) code is in the 0 logical state, the four bottom face syndrome measurements must give even parity. If the original code is in the 1 logical state, these four syndrome measurements must give an odd parity. this is because the bottom row of green qubits are initialized in the 0 state, and their multiplication with the original logical Z (and one another green qubit in the same row of the original logical Z) equals the parity of the four bottom face syndrome measurements.</p>
<p>We can therefore identify the original state of the code in the Z basis, so this is a measurement. But if this is a measurement, we are no more in a superposition, and the state injection procedure fails.</p>
<p>Where is my mistake?</p>
",Surface code expansion in the lattice surgery context,<stabilizer-code><surface-code><topological-quantum-computing>,1,0,,,"Surface code expansion in the lattice surgery context <p>In this paper: <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011</a>, the authors describes how to inject a magic state into a small planar surface code, and then how to expand the code (see figures 8d and 8e).<a href=""https://i.sstatic.net/wOwmL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wOwmL.png"" alt=""The figure from the paper showing the state injection and lattice expansion process"" /></a>.</p>
<p>I cannot understand the expansion process. Since the additional qubits are initialized to the |0&gt; state, a transversal ZZZZ operator (the logical Z) is a stabilizer of the system before and after the syndrome measurements. Therefore, the system must end in either the logical 0 or logical 1, and cannot be in any superposition.</p>
<p>Another point of view on my question is that the suggested process &quot;measures&quot; the original (pink) surface code in the z basis. If the original (pink) code is in the 0 logical state, the four bottom face syndrome measurements must give even parity. If the original code is in the 1 logical state, these four syndrome measurements must give an odd parity. this is because the bottom row of green qubits are initialized in the 0 state, and their multiplication with the original logical Z (and one another green qubit in the same row of the original logical Z) equals the parity of the four bottom face syndrome measurements.</p>
<p>We can therefore identify the original state of the code in the Z basis, so this is a measurement. But if this is a measurement, we are no more in a superposition, and the state injection procedure fails.</p>
<p>Where is my mistake?</p>
",qc,surface code expansion lattice surgery context p paper https nofollow noreferrer https authors describes inject magic state small planar surface code expand code see figures 8d 8e https nofollow noreferrer img https figure paper showing state injection lattice expansion process p understand expansion process since additional qubits initialized gt state transversal zzzz operator logical z stabilizer system syndrome measurements therefore system must end either logical 0 logical 1 p another point view question suggested process quot measures quot original pink surface code z basis original pink code 0 logical state four bottom face syndrome measurements must give even parity original code 1 logical state four syndrome measurements must give odd parity bottom row green qubits initialized 0 state multiplication original logical z one another green qubit row original logical z equals parity four bottom face syndrome p therefore identify original state code z basis measurement measurement superposition state injection procedure p mistake,"[(2, 0.03210644), (3, 0.06376075), (4, 0.08782678), (5, 0.3865035), (13, 0.19362481), (16, 0.020262681), (18, 0.20142458), (19, 0.013690763)]"
33045,,2023-06-19 14:19:46,2,61,"<p>In Cirq <a href=""https://quantumai.google/cirq/google/best_practices#align_single-qubit_and_two-qubit_layers"" rel=""nofollow noreferrer"">document</a> that describes 'best practices' for manually optimizing circuits, they recommend to construct a circuit in a pattern that alternate 'single-qubit gates with two-qubit gates in each layer'.</p>
<p>Regarding this, I have few questions:</p>
<p>(1) The reason for such recommendation, appeared in the document, is because they calibrated devices optimally to such pattern. Yet, why such specific pattern must have been considered as calibration object?</p>
<p>(2) Will there be any other patterns in circuit layers to be considered for optimal circuit runs?</p>
",Reasons for Google's calibration policy of fitting to Alternating Single/Two-qubit gate pattern,<circuit-construction>,0,0,,,"Reasons for Google's calibration policy of fitting to Alternating Single/Two-qubit gate pattern <p>In Cirq <a href=""https://quantumai.google/cirq/google/best_practices#align_single-qubit_and_two-qubit_layers"" rel=""nofollow noreferrer"">document</a> that describes 'best practices' for manually optimizing circuits, they recommend to construct a circuit in a pattern that alternate 'single-qubit gates with two-qubit gates in each layer'.</p>
<p>Regarding this, I have few questions:</p>
<p>(1) The reason for such recommendation, appeared in the document, is because they calibrated devices optimally to such pattern. Yet, why such specific pattern must have been considered as calibration object?</p>
<p>(2) Will there be any other patterns in circuit layers to be considered for optimal circuit runs?</p>
",qc,reasons google calibration policy fitting alternating gate pattern p cirq https nofollow noreferrer document describes practices manually optimizing circuits recommend construct circuit pattern alternate gates gates p regarding questions p 1 reason recommendation appeared document calibrated devices optimally pattern yet specific pattern must considered calibration object p 2 patterns circuit layers considered optimal circuit runs,"[(2, 0.03579936), (4, 0.10241901), (8, 0.18949077), (13, 0.1045998), (14, 0.43715215), (16, 0.070467606), (17, 0.03698596), (19, 0.020783592)]"
33060,,2023-06-20 11:26:30,1,197,"<p>In the book &quot;Introduction to quantum algorithms via linear algebra&quot;, there is a problem 6.8, that said: &quot;Show that CV can be written as a composition of (appropriate powers of) T gates before and after a controlled rotation CRx(θ). Deduce that CNOT is the only two-qubit gate needed to simulate CV&quot;
I tried many cases but can't make it true. Does anyone know how to do that? Thanks!</p>
",Decomposition of Control-V gates using CNOT and single qubit gate?,<quantum-gate><linear-algebra><quantum-control>,0,4,,,"Decomposition of Control-V gates using CNOT and single qubit gate? <p>In the book &quot;Introduction to quantum algorithms via linear algebra&quot;, there is a problem 6.8, that said: &quot;Show that CV can be written as a composition of (appropriate powers of) T gates before and after a controlled rotation CRx(θ). Deduce that CNOT is the only two-qubit gate needed to simulate CV&quot;
I tried many cases but can't make it true. Does anyone know how to do that? Thanks!</p>
",qc,decomposition gates using cnot single qubit gate p book quot introduction quantum algorithms via linear algebra quot problem said quot show cv written composition appropriate powers gates controlled rotation crx θ deduce cnot gate needed simulate cv quot tried many cases ca make true anyone know thanks,"[(1, 0.122279346), (3, 0.30264252), (9, 0.44730812), (16, 0.022436725), (19, 0.1020131)]"
33068,33079.0,2023-06-20 19:19:55,0,102,"<p>Is there a gate that can perform the matrix exponential operation</p>
<p><span class=""math-container"">$$e^{iA}|\Psi\rangle$$</span></p>
<p>in IBM quantum experience API?</p>
<p><a href=""https://i.sstatic.net/2nl09.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2nl09.png"" alt=""enter image description here"" /></a></p>
<p>What is the name and symbol for this type of gate (or some other gates that can perform operations like the matrix exponential)?</p>
<hr />
<p>I need a 2nd opinion that can confirm whether or not</p>
<p><span class=""math-container"">$$ e^{i\begin{bmatrix} 8 &amp; 6+i \\ 6-i &amp; -1\end{bmatrix}} = \begin{bmatrix} -0.06558 -0.63357i &amp; 0.38542 -0.66763i \\ 0.14805  -0.75654i &amp; -0.46568 + 0.43456i \end{bmatrix}$$</span></p>
<p>is correct?</p>
",Is there a matrix exponential $e^{iA}$ gate in IBM Quantum Experience?,<ibm-q-experience><gate-synthesis>,2,6,,,"Is there a matrix exponential $e^{iA}$ gate in IBM Quantum Experience? <p>Is there a gate that can perform the matrix exponential operation</p>
<p><span class=""math-container"">$$e^{iA}|\Psi\rangle$$</span></p>
<p>in IBM quantum experience API?</p>
<p><a href=""https://i.sstatic.net/2nl09.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2nl09.png"" alt=""enter image description here"" /></a></p>
<p>What is the name and symbol for this type of gate (or some other gates that can perform operations like the matrix exponential)?</p>
<hr />
<p>I need a 2nd opinion that can confirm whether or not</p>
<p><span class=""math-container"">$$ e^{i\begin{bmatrix} 8 &amp; 6+i \\ 6-i &amp; -1\end{bmatrix}} = \begin{bmatrix} -0.06558 -0.63357i &amp; 0.38542 -0.66763i \\ 0.14805  -0.75654i &amp; -0.46568 + 0.43456i \end{bmatrix}$$</span></p>
<p>is correct?</p>
",qc,matrix exponential ia gate ibm quantum experience p gate perform matrix exponential operation p span ia p ibm quantum experience api p https nofollow noreferrer img https enter image description p name symbol type gate gates perform operations like matrix exponential hr p need 2nd opinion confirm whether p span bmatrix 8 amp amp bmatrix bmatrix amp amp bmatrix p correct,"[(4, 0.26131353), (7, 0.21901514), (9, 0.09531464), (11, 0.025127096), (15, 0.2424893), (16, 0.035397604), (17, 0.017265182), (18, 0.10211617)]"
33086,,2023-06-21 14:08:11,0,72,"<p>Can we initialize two different arrays in two different qubits in a 2 qubit quantum circuit?
I tried in IBMq but it showing error.
So don't understand.</p>
<p><a href=""https://i.sstatic.net/UaQ5Z.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UaQ5Z.png"" alt=""enter image description here"" /></a></p>
<p>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
num_of_qubits = 2
q1,q2 = QuantumRegister(1, 'q1'),QuantumRegister(1, 'q2')
creg_c = ClassicalRegister(2, 'c')
qc = QuantumCircuit(q1,q2,creg_c)
qc.initialize(message_chunks,q1)
qc.initialize(key_chunks,q2)</p>
<p>tried with this. but this error is showing..&quot;'Desired statevector length not a positive power of 2.'&quot;
kindly help..</p>
",Can we initialize two arrays in two different qubits in a 2-qubit quantum circuit in IBMq?,<quantum-gate>,1,3,,,"Can we initialize two arrays in two different qubits in a 2-qubit quantum circuit in IBMq? <p>Can we initialize two different arrays in two different qubits in a 2 qubit quantum circuit?
I tried in IBMq but it showing error.
So don't understand.</p>
<p><a href=""https://i.sstatic.net/UaQ5Z.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UaQ5Z.png"" alt=""enter image description here"" /></a></p>
<p>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
num_of_qubits = 2
q1,q2 = QuantumRegister(1, 'q1'),QuantumRegister(1, 'q2')
creg_c = ClassicalRegister(2, 'c')
qc = QuantumCircuit(q1,q2,creg_c)
qc.initialize(message_chunks,q1)
qc.initialize(key_chunks,q2)</p>
<p>tried with this. but this error is showing..&quot;'Desired statevector length not a positive power of 2.'&quot;
kindly help..</p>
",qc,initialize two arrays two different qubits quantum circuit ibmq p initialize two different arrays two different qubits 2 qubit quantum circuit tried ibmq showing error p https nofollow noreferrer img https enter image description p qiskit import quantumregister classicalregister quantumcircuit 2 q1 q2 quantumregister 1 quantumregister 1 classicalregister 2 c qc quantumcircuit q1 q2 q1 q2 p tried error showing quot statevector length positive power 2 quot kindly help,"[(0, 0.25872457), (2, 0.09406334), (4, 0.28970763), (11, 0.014721833), (14, 0.2547586), (16, 0.044709254), (19, 0.041435853)]"
33124,,2023-06-23 17:18:11,0,202,"<p>Is there a standard quantum algorithm (adiabatic or density matrix based) that can output the answer to a 2-dimensional closest vector problem:</p>
<p><a href=""https://i.sstatic.net/m0rbn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m0rbn.png"" alt=""enter image description here"" /></a></p>
<p>ie. find the closest lattice point (the blue one) that is closest to a random point in 2-dimension (the red point)?</p>
",Is there a quantum algorithm for the closest vector problem on a 2-dimensional lattice?,<quantum-algorithms><adiabatic-model>,2,0,,,"Is there a quantum algorithm for the closest vector problem on a 2-dimensional lattice? <p>Is there a standard quantum algorithm (adiabatic or density matrix based) that can output the answer to a 2-dimensional closest vector problem:</p>
<p><a href=""https://i.sstatic.net/m0rbn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m0rbn.png"" alt=""enter image description here"" /></a></p>
<p>ie. find the closest lattice point (the blue one) that is closest to a random point in 2-dimension (the red point)?</p>
",qc,quantum algorithm closest vector problem lattice p standard quantum algorithm adiabatic density matrix based output answer closest vector problem p https nofollow noreferrer img https enter image description p ie find closest lattice point blue one closest random point red point,"[(3, 0.041153274), (4, 0.3075506), (7, 0.24328505), (11, 0.0483595), (13, 0.30739054), (16, 0.048859343)]"
33282,33396.0,2023-07-05 10:08:46,2,463,"<p>I am working with a Tight Binding Hamiltonian with N sites and one orbital at each site in a closed chain. I have converted the fermionic expression to a spin expression using Jordan Wigner Transformation. I want to apply this as a gate in qiskit without using the built-in lattice model functions.<br />
This is the Hamiltonian in terms of fermionic operators :
<span class=""math-container"">$$ H_{\text{sys}} = \sum_{i} \epsilon_i c_{i }^{\dagger} c_{i } + t \sum_{i } (c_{i}^\dagger c_{i+1 } + c_{i+1}^\dagger c_{i } ) $$</span></p>
<p>This is the expression of the transformed Hamiltonian :<br />
<span class=""math-container"">$$ H_{\text{sys}} = \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \epsilon _k \big( \sigma ^- . \sigma ^+ \big)_k \otimes \textbf{I}^{\otimes(N-k)} + \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^- \big) _k \otimes \big( \sigma^+\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} \\ - \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^+ \big) _k \otimes \big( \sigma^-\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} $$</span></p>
<p><span class=""math-container"">$ \sigma _{\pm} = \frac{X \pm i Y}{2}$</span></p>
<p>I want to know how I can implement this as a gate in qiskit without creating the matrix first, and by simply tensoring the Pauli operators and summing them up using PauliSumOp.</p>
<p>What is the best way to implement it in general?</p>
",How can I implement a Hamiltonian which is sum of tensored pauli operators on qiskit?,<qiskit><quantum-gate><pauli-gates><hamiltonian>,2,0,,,"How can I implement a Hamiltonian which is sum of tensored pauli operators on qiskit? <p>I am working with a Tight Binding Hamiltonian with N sites and one orbital at each site in a closed chain. I have converted the fermionic expression to a spin expression using Jordan Wigner Transformation. I want to apply this as a gate in qiskit without using the built-in lattice model functions.<br />
This is the Hamiltonian in terms of fermionic operators :
<span class=""math-container"">$$ H_{\text{sys}} = \sum_{i} \epsilon_i c_{i }^{\dagger} c_{i } + t \sum_{i } (c_{i}^\dagger c_{i+1 } + c_{i+1}^\dagger c_{i } ) $$</span></p>
<p>This is the expression of the transformed Hamiltonian :<br />
<span class=""math-container"">$$ H_{\text{sys}} = \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \epsilon _k \big( \sigma ^- . \sigma ^+ \big)_k \otimes \textbf{I}^{\otimes(N-k)} + \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^- \big) _k \otimes \big( \sigma^+\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} \\ - \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^+ \big) _k \otimes \big( \sigma^-\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} $$</span></p>
<p><span class=""math-container"">$ \sigma _{\pm} = \frac{X \pm i Y}{2}$</span></p>
<p>I want to know how I can implement this as a gate in qiskit without creating the matrix first, and by simply tensoring the Pauli operators and summing them up using PauliSumOp.</p>
<p>What is the best way to implement it in general?</p>
",qc,implement hamiltonian sum tensored pauli operators qiskit p working tight binding hamiltonian n sites one orbital site closed chain converted fermionic expression spin expression using jordan wigner transformation want apply gate qiskit without using lattice model br hamiltonian terms fermionic operators span sys p expression transformed hamiltonian br span sys n n n p span x 2 p want know implement gate qiskit without creating matrix first simply tensoring pauli operators summing using p best way implement general,"[(1, 0.09341689), (3, 0.42175797), (8, 0.040258978), (9, 0.04026785), (10, 0.049179416), (13, 0.04142811), (14, 0.28418684), (16, 0.013484624), (17, 0.0145543525)]"
33379,,2023-07-12 03:32:33,0,96,"<p>In a five qubit (q0, q1, q2, q3 and q4) quantum circuit, I need to consider only those measurement readings of q0, q1 and q2 for which q3 and q4 measures 0. More specifically, I am trying to implement a protocol using <a href=""https://arxiv.org/pdf/1202.5822.pdf"" rel=""nofollow noreferrer"">this</a> (see eq. 3). I use two ancilla qubits (q3 and q4) instead of one (as descried in this paper) and the protocol will be executed only if both the ancillaries measure 0. In the end I need the readouts for q0, q1 and q2. How to implement this in Qiskit (also I need to execute the code on a IBM Quantum computer)?</p>
","In qiskit, how to consider only readings conditioned to some measurement outcome?",<qiskit><ibm-q-experience><quantum-circuit>,1,6,,,"In qiskit, how to consider only readings conditioned to some measurement outcome? <p>In a five qubit (q0, q1, q2, q3 and q4) quantum circuit, I need to consider only those measurement readings of q0, q1 and q2 for which q3 and q4 measures 0. More specifically, I am trying to implement a protocol using <a href=""https://arxiv.org/pdf/1202.5822.pdf"" rel=""nofollow noreferrer"">this</a> (see eq. 3). I use two ancilla qubits (q3 and q4) instead of one (as descried in this paper) and the protocol will be executed only if both the ancillaries measure 0. In the end I need the readouts for q0, q1 and q2. How to implement this in Qiskit (also I need to execute the code on a IBM Quantum computer)?</p>
",qc,qiskit consider readings conditioned measurement outcome p five qubit q0 q1 q2 q3 q4 quantum circuit need consider measurement readings q0 q1 q2 q3 q4 measures specifically trying implement protocol using https nofollow noreferrer see eq 3 use two ancilla qubits q3 q4 instead one descried paper protocol executed ancillaries measure end need readouts q0 q1 q2 implement qiskit also need execute code ibm quantum computer,"[(2, 0.022317268), (3, 0.02469618), (4, 0.088667445), (14, 0.57047373), (16, 0.096894756), (18, 0.19479929)]"
33423,,2023-07-15 10:05:35,1,34,"<p>I'm just getting into the baffling world of Quantum Computing so forgive me if this is straightforward...</p>
<p>I'm using Microsoft's Q# simulator so I know I'm allowed to peek into the internals of a Qubit in the way hardware would not allow. Specifically using <code>DumpRegister()</code> to look into the Qubit state - however, I think that's not telling me anything about entanglement:</p>
<ul>
<li>If I <code>CNOT</code> two bits, the <code>DumpRegister</code> output is the same before as after, but the state machine must know about that relationship beyond just the current probabilities of values for the register</li>
<li>If I <code>MultiplyI</code> two registers to a third, the <code>DumpRegister</code> output is entirely blank, it's not showing any Qubits at all</li>
</ul>
<p>Is there a way I can get a deeper snapshot view of the machine state? Why is it that <code>MultiplyI</code> causes the Qubits to be not reported at all by <code>DumpRegister</code>?</p>
<p>Example code:</p>
<pre><code>    operation CNot() : Unit
    {
        use reg=Qubit[2];
        ApplyToEachCA(H,reg); 
        DumpRegister((),reg);
        CNOT(reg[0],reg[1]);
        DumpRegister((),reg);
        ResetAll(reg);
    }

    operation Multiply() : Unit
    {
        use r1=Qubit[2];
        use r2=Qubit[2];
        use r3=Qubit[4];

        ApplyToEachCA(H,r1);
        ApplyToEachCA(H,r2);

        for q in r3
        {
            SetQubitState(Zero, q);
        }

        let le1=LittleEndian(r1);
        let le2=LittleEndian(r2);
        let le3=LittleEndian(r3);

        MultiplyI (le1,le2,le3);
    
        DumpRegister ((),r1);
        DumpRegister ((),r2);
        DumpRegister ((),r3);

        let m1=MeasureInteger (le1);
        let m2=MeasureInteger (le2);
        let m3=MeasureInteger (le3);

        Message($&quot;{m1} * {m2} = {m3}&quot;);

        ResetAll(r1);
        ResetAll(r2);
        ResetAll(r3);
    }
</code></pre>
<p><code>CNot()</code> produces <code>0.500000 +  0.000000 i</code> for each value before and after - I can see <code>DumpRegister()</code> is just showing the probabilities of values in the register which I guess is the same before and after, but there's some other state it's not showing. <code>DumpMachine()</code> is no more informative.</p>
<p><code>Multiply()</code> produces an output like <code>3 * 2 = 6</code> but each <code>DumpRegister()</code> line only produces a blank line.</p>
",DumpRegister sometimes blank?,<entanglement><q#>,1,2,,,"DumpRegister sometimes blank? <p>I'm just getting into the baffling world of Quantum Computing so forgive me if this is straightforward...</p>
<p>I'm using Microsoft's Q# simulator so I know I'm allowed to peek into the internals of a Qubit in the way hardware would not allow. Specifically using <code>DumpRegister()</code> to look into the Qubit state - however, I think that's not telling me anything about entanglement:</p>
<ul>
<li>If I <code>CNOT</code> two bits, the <code>DumpRegister</code> output is the same before as after, but the state machine must know about that relationship beyond just the current probabilities of values for the register</li>
<li>If I <code>MultiplyI</code> two registers to a third, the <code>DumpRegister</code> output is entirely blank, it's not showing any Qubits at all</li>
</ul>
<p>Is there a way I can get a deeper snapshot view of the machine state? Why is it that <code>MultiplyI</code> causes the Qubits to be not reported at all by <code>DumpRegister</code>?</p>
<p>Example code:</p>
<pre><code>    operation CNot() : Unit
    {
        use reg=Qubit[2];
        ApplyToEachCA(H,reg); 
        DumpRegister((),reg);
        CNOT(reg[0],reg[1]);
        DumpRegister((),reg);
        ResetAll(reg);
    }

    operation Multiply() : Unit
    {
        use r1=Qubit[2];
        use r2=Qubit[2];
        use r3=Qubit[4];

        ApplyToEachCA(H,r1);
        ApplyToEachCA(H,r2);

        for q in r3
        {
            SetQubitState(Zero, q);
        }

        let le1=LittleEndian(r1);
        let le2=LittleEndian(r2);
        let le3=LittleEndian(r3);

        MultiplyI (le1,le2,le3);
    
        DumpRegister ((),r1);
        DumpRegister ((),r2);
        DumpRegister ((),r3);

        let m1=MeasureInteger (le1);
        let m2=MeasureInteger (le2);
        let m3=MeasureInteger (le3);

        Message($&quot;{m1} * {m2} = {m3}&quot;);

        ResetAll(r1);
        ResetAll(r2);
        ResetAll(r3);
    }
</code></pre>
<p><code>CNot()</code> produces <code>0.500000 +  0.000000 i</code> for each value before and after - I can see <code>DumpRegister()</code> is just showing the probabilities of values in the register which I guess is the same before and after, but there's some other state it's not showing. <code>DumpMachine()</code> is no more informative.</p>
<p><code>Multiply()</code> produces an output like <code>3 * 2 = 6</code> but each <code>DumpRegister()</code> line only produces a blank line.</p>
",qc,dumpregister sometimes blank p getting baffling world quantum computing forgive straightforward p using microsoft q simulator know allowed peek internals qubit way hardware would allow specifically using code dumpregister look qubit state however think telling anything entanglement ul li code cnot two bits code dumpregister output state machine must know relationship beyond current probabilities values register li code multiplyi two registers third code dumpregister output entirely blank showing qubits p way get deeper snapshot view machine state code multiplyi causes qubits reported code dumpregister p example code pre code operation cnot unit use 2 applytoeachca h reg dumpregister reg cnot reg 0 reg 1 dumpregister reg resetall reg operation multiply unit use 2 use 2 use 4 applytoeachca h r1 applytoeachca h r2 q r3 setqubitstate zero q let r1 let r2 let r3 multiplyi le1 le2 le3 dumpregister r1 dumpregister r2 dumpregister r3 let le1 let le2 let le3 message quot m1 m2 m3 quot resetall r1 resetall r2 resetall r3 p code cnot produces code value see code dumpregister showing probabilities values register guess state showing code dumpmachine p code multiply produces output like code 3 2 6 code dumpregister line produces blank,"[(0, 0.16226725), (2, 0.07484208), (6, 0.013954582), (7, 0.057824336), (8, 0.09012422), (10, 0.015844133), (14, 0.24588718), (16, 0.09714987), (17, 0.04850738), (18, 0.17458373), (19, 0.012281772)]"
33446,33572.0,2023-07-17 09:02:41,1,83,"<p>I would like to evolve a quantum state through an entire sub-circuit in my circuit based on classical control. I am aware of the current state of classical control in cirq (<a href=""https://quantumai.google/cirq/build/classical_control"" rel=""nofollow noreferrer"">https://quantumai.google/cirq/build/classical_control</a>) but this only deals with fundamental operations. Suppose I wanted to treat the sub-circuit as an atomic structure, which will be fully evolved or not evolved at all based on the classical condition, is it possible to achieve that?</p>
<p>In qiskit I could to the following:</p>
<pre class=""lang-py prettyprint-override""><code>with circuit.if_test((c_reg, 0b110)):
        circuit.x(0)
        circuit.z(1)
</code></pre>
<p>I could add any number of circuit operations inside the <code>with</code> context and it will be treated as an atomic unit. I could not find a way to convert a <code>cirq.Circuit</code> into <code>cirq.Operation</code> either, I am not entirely sure if that would achieve my goal, but it was worth a shot.</p>
",Classical control of an entire sub-circuit in cirq,<circuit-construction><cirq>,1,0,,,"Classical control of an entire sub-circuit in cirq <p>I would like to evolve a quantum state through an entire sub-circuit in my circuit based on classical control. I am aware of the current state of classical control in cirq (<a href=""https://quantumai.google/cirq/build/classical_control"" rel=""nofollow noreferrer"">https://quantumai.google/cirq/build/classical_control</a>) but this only deals with fundamental operations. Suppose I wanted to treat the sub-circuit as an atomic structure, which will be fully evolved or not evolved at all based on the classical condition, is it possible to achieve that?</p>
<p>In qiskit I could to the following:</p>
<pre class=""lang-py prettyprint-override""><code>with circuit.if_test((c_reg, 0b110)):
        circuit.x(0)
        circuit.z(1)
</code></pre>
<p>I could add any number of circuit operations inside the <code>with</code> context and it will be treated as an atomic unit. I could not find a way to convert a <code>cirq.Circuit</code> into <code>cirq.Operation</code> either, I am not entirely sure if that would achieve my goal, but it was worth a shot.</p>
",qc,classical control entire cirq p would like evolve quantum state entire circuit based classical control aware current state classical control cirq https nofollow noreferrer https deals fundamental operations suppose wanted treat atomic structure fully evolved evolved based classical condition possible achieve p qiskit could following pre code 0b110 0 1 p could add number circuit operations inside code context treated atomic unit could find way convert code code either entirely sure would achieve goal worth,"[(1, 0.1438373), (2, 0.027742656), (7, 0.03170229), (9, 0.25256562), (14, 0.4498068), (16, 0.025046097), (18, 0.06754611)]"
33486,,2023-07-19 13:14:05,1,48,"<p>I'm struggling to find if <span class=""math-container"">$\text{Rx}(\theta)$</span> gate would convert a pure state qubit <span class=""math-container"">$|0\rangle$</span> to a superposition <span class=""math-container"">$\cos( \theta) |0\rangle + \sin(\theta) |1\rangle$</span>.</p>
<p>A definitive answer with reference will be appreciated.</p>
",Does Rx(θ) applied on pure states create superposition?,<superposition>,1,2,,,"Does Rx(θ) applied on pure states create superposition? <p>I'm struggling to find if <span class=""math-container"">$\text{Rx}(\theta)$</span> gate would convert a pure state qubit <span class=""math-container"">$|0\rangle$</span> to a superposition <span class=""math-container"">$\cos( \theta) |0\rangle + \sin(\theta) |1\rangle$</span>.</p>
<p>A definitive answer with reference will be appreciated.</p>
",qc,rx θ applied pure states create superposition p struggling find span rx gate would convert pure state qubit span superposition span p definitive answer reference,"[(0, 0.15762554), (3, 0.37940493), (16, 0.041764293), (18, 0.41459194)]"
33500,33501.0,2023-07-20 06:21:26,2,32,"<p>We consider the group of unitary matrices, <span class=""math-container"">$G$</span> that generated by the Hadamard matrices <span class=""math-container"">$H_2$</span>,<span class=""math-container"">$H_4$</span> and and SWAP matrix (i.e., permutation matrices that swap two qubit lines). Consider all unit vectors whose components are all either 1/2 or -1/2 (that is, <span class=""math-container"">$2^4=16$</span> vectors).
My question is: <strong><em>Can we show that all unit vectors can be obtained from one another by using only the transformations in <span class=""math-container"">$G$</span></em>?</strong></p>
<p>NOTE: I think of group <span class=""math-container"">$G$</span> with 8 possible matrices that can represent combinations of Hadamard and SWAP transformations such as <span class=""math-container"">$H_4=H_2\otimes H_2$</span>, <span class=""math-container"">$H_2 \otimes I$</span>, <span class=""math-container"">$I \otimes H_2$</span>, <span class=""math-container"">$SWAP$</span>, <span class=""math-container"">$(H_2 \otimes H_2)SWAP$</span>, <span class=""math-container"">$(H_2\otimes I)SWAP$</span>, <span class=""math-container"">$(I\otimes H_2)SWAP$</span> and <span class=""math-container"">$I \otimes I$</span> (note that SWAP Matrix is commutative). But, I cannot infer that we can only use representation matrices corresponding to the transformations in group G to all unit vectors of dimension 4 that have <span class=""math-container"">$\pm 1/2$</span> as entries can be obtained from one another.</p>
",How to get all unit vectors of 4 dimension with all entries $\pm 1/2$ using only Hadamard and SWAP transformations,<quantum-state><hadamard>,1,0,,,"How to get all unit vectors of 4 dimension with all entries $\pm 1/2$ using only Hadamard and SWAP transformations <p>We consider the group of unitary matrices, <span class=""math-container"">$G$</span> that generated by the Hadamard matrices <span class=""math-container"">$H_2$</span>,<span class=""math-container"">$H_4$</span> and and SWAP matrix (i.e., permutation matrices that swap two qubit lines). Consider all unit vectors whose components are all either 1/2 or -1/2 (that is, <span class=""math-container"">$2^4=16$</span> vectors).
My question is: <strong><em>Can we show that all unit vectors can be obtained from one another by using only the transformations in <span class=""math-container"">$G$</span></em>?</strong></p>
<p>NOTE: I think of group <span class=""math-container"">$G$</span> with 8 possible matrices that can represent combinations of Hadamard and SWAP transformations such as <span class=""math-container"">$H_4=H_2\otimes H_2$</span>, <span class=""math-container"">$H_2 \otimes I$</span>, <span class=""math-container"">$I \otimes H_2$</span>, <span class=""math-container"">$SWAP$</span>, <span class=""math-container"">$(H_2 \otimes H_2)SWAP$</span>, <span class=""math-container"">$(H_2\otimes I)SWAP$</span>, <span class=""math-container"">$(I\otimes H_2)SWAP$</span> and <span class=""math-container"">$I \otimes I$</span> (note that SWAP Matrix is commutative). But, I cannot infer that we can only use representation matrices corresponding to the transformations in group G to all unit vectors of dimension 4 that have <span class=""math-container"">$\pm 1/2$</span> as entries can be obtained from one another.</p>
",qc,get unit vectors 4 dimension entries using hadamard swap transformations p consider group unitary matrices span g generated hadamard matrices span span swap matrix permutation matrices swap two qubit lines consider unit vectors whose components either span vectors question strong em show unit vectors obtained one another using transformations span g p note think group span g 8 possible matrices represent combinations hadamard swap transformations span span span span swap span swap span swap span swap span note swap matrix commutative infer use representation matrices corresponding transformations group g unit vectors dimension 4 span entries obtained one,"[(3, 0.690287), (6, 0.018756805), (11, 0.027933545), (13, 0.2282375), (16, 0.03324161)]"
33541,33544.0,2023-07-23 08:51:38,1,89,"<p>It is clear that a Clifford feedback is necessary for performing a non-Clifford gate with measurement-based quantum computing (for example with Lattice surgery in surface codes).</p>
<p>But, given many logical qubits and non-Clifford gates, can you delay any feedback to the very end of the circuit without modifying anything along the way?</p>
<p>Mathematically, can you always find a Clifford operator <span class=""math-container"">$C_2$</span> such that <span class=""math-container"">$C_2P=PC_1$</span> for any Pauli projection operator <span class=""math-container"">$P$</span> and Clifford operator <span class=""math-container"">$C_1$</span>?</p>
<p>If so, is it true to say that you do not need any real-time feedback (or gate modification) apart of just before the final measurement of the computational qubits?</p>
",Which feedback is *necessary* for surface-code based and measurement based quantum computing?,<clifford-group><surface-code><measurement-based-qc>,2,0,,,"Which feedback is *necessary* for surface-code based and measurement based quantum computing? <p>It is clear that a Clifford feedback is necessary for performing a non-Clifford gate with measurement-based quantum computing (for example with Lattice surgery in surface codes).</p>
<p>But, given many logical qubits and non-Clifford gates, can you delay any feedback to the very end of the circuit without modifying anything along the way?</p>
<p>Mathematically, can you always find a Clifford operator <span class=""math-container"">$C_2$</span> such that <span class=""math-container"">$C_2P=PC_1$</span> for any Pauli projection operator <span class=""math-container"">$P$</span> and Clifford operator <span class=""math-container"">$C_1$</span>?</p>
<p>If so, is it true to say that you do not need any real-time feedback (or gate modification) apart of just before the final measurement of the computational qubits?</p>
",qc,feedback necessary based measurement based quantum computing p clear clifford feedback necessary performing gate quantum computing example lattice surgery surface codes p given many logical qubits gates delay feedback end circuit without modifying anything along way p mathematically always find clifford operator span span pauli projection operator span p clifford operator span p true say need feedback gate modification apart final measurement computational qubits,"[(0, 0.018175645), (1, 0.07732148), (3, 0.22693558), (5, 0.10850565), (9, 0.23809801), (14, 0.29758888), (16, 0.0313483)]"
33573,,2023-07-26 03:32:50,1,64,"<p>for some reason <code>cirq_google</code> is not quite picking up on <code>Foxtail</code> and <code>Bristlecone</code> .</p>
<p>I just installed <code>cirq</code> and <code>cirq_google</code> today (7/25/2023), and for some reason my code with <code>Foxtail</code> is not being picked up. Here is the code I have right now:</p>
<pre><code>import cirq
import cirq_google

circuit = cirq.Circuit()
(q0, q1) = cirq.LineQubit.range(2)

circuit.append([cirq.H(q0), cirq.CNOT(q0, q1)])
circuit.append([cirq.measure(q0), cirq.measure(q1)])

sim = cirq.Simulator()
results = sim.run(circuit, repetitions=10)
print(results)
print()
print(cirq_google.Foxtail)
</code></pre>
<p>I previously had code that was using <code>Bristlecone</code>, but I have since modified my code.</p>
<p>If someone can please help me out, that would be greatly appreciated!</p>
","Foxtail, Bristlecone, etc not being recognized",<bristlecone>,1,1,,,"Foxtail, Bristlecone, etc not being recognized <p>for some reason <code>cirq_google</code> is not quite picking up on <code>Foxtail</code> and <code>Bristlecone</code> .</p>
<p>I just installed <code>cirq</code> and <code>cirq_google</code> today (7/25/2023), and for some reason my code with <code>Foxtail</code> is not being picked up. Here is the code I have right now:</p>
<pre><code>import cirq
import cirq_google

circuit = cirq.Circuit()
(q0, q1) = cirq.LineQubit.range(2)

circuit.append([cirq.H(q0), cirq.CNOT(q0, q1)])
circuit.append([cirq.measure(q0), cirq.measure(q1)])

sim = cirq.Simulator()
results = sim.run(circuit, repetitions=10)
print(results)
print()
print(cirq_google.Foxtail)
</code></pre>
<p>I previously had code that was using <code>Bristlecone</code>, but I have since modified my code.</p>
<p>If someone can please help me out, that would be greatly appreciated!</p>
",qc,foxtail bristlecone etc recognized p reason code quite picking code foxtail code bristlecone p installed code cirq code today reason code code foxtail picked code right pre code import cirq import circuit q0 q1 2 q0 q0 q1 q0 q1 sim results circuit print results print print p previously code using code bristlecone since modified p someone please help would greatly appreciated,"[(0, 0.44765455), (7, 0.026932018), (14, 0.3102927), (16, 0.21222101)]"
33592,33594.0,2023-07-27 13:44:07,2,349,"<p>I would like to have a controlled NOT gate which flips my target qubit when <strong>at least</strong> one of the control qubits is |1&gt;.</p>
<p>I would like to be able to do this for arbitrary n. For a system with 2 control qubits this can be achieved as follows: <a href=""https://i.sstatic.net/cQ5x2.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cQ5x2.png"" alt=""enter image description here"" /></a></p>
<p>But this gets harder as n gets larger.</p>
<p>So I have 2 questions:</p>
<ol>
<li><p>[General question] How can I construct such a gate? Is there a simple custom gate I can make, or a sequence of gates?</p>
</li>
<li><p>[Cirq question] How would I implement this using Cirq?</p>
</li>
</ol>
",Controlled NOT gate which flips target when at least one of the control qubits is |1>,<quantum-circuit><cirq>,3,0,,,"Controlled NOT gate which flips target when at least one of the control qubits is |1> <p>I would like to have a controlled NOT gate which flips my target qubit when <strong>at least</strong> one of the control qubits is |1&gt;.</p>
<p>I would like to be able to do this for arbitrary n. For a system with 2 control qubits this can be achieved as follows: <a href=""https://i.sstatic.net/cQ5x2.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cQ5x2.png"" alt=""enter image description here"" /></a></p>
<p>But this gets harder as n gets larger.</p>
<p>So I have 2 questions:</p>
<ol>
<li><p>[General question] How can I construct such a gate? Is there a simple custom gate I can make, or a sequence of gates?</p>
</li>
<li><p>[Cirq question] How would I implement this using Cirq?</p>
</li>
</ol>
",qc,controlled gate flips target least one control qubits p would like controlled gate flips target qubit strong least one control qubits gt p would like able arbitrary system 2 control qubits achieved follows https nofollow noreferrer img https enter image description p gets harder n gets p 2 questions ol li p general question construct gate simple custom gate make sequence gates li p cirq question would implement using cirq,"[(4, 0.24054313), (9, 0.23368149), (16, 0.028752185), (18, 0.49474356)]"
33598,,2023-07-28 02:41:10,1,1480,"<p>I have coded this from a tutorial:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram
import cirq

m_simulator = Aer.backends(name=&quot;Quantum_Simulation&quot;)
qreg = QuantumRegister(2)
creg = ClassicalRegister(2)
entangler = QuantumCircuit(qreg, creg)
entangler.h(0)
entangler.cx(0, 1)
entangler.measure(0, 0)
entangler.measure(1, 1)
entangler.draw(output=&quot;mpl&quot;)
</code></pre>
<p>For some reason, <code>entangler.draw(output=&quot;mpl&quot;)</code> is not working. If someone can let me know why, that would be greatly appreciated. The link I am using is: <a href=""https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e"" rel=""nofollow noreferrer"">https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e</a></p>
",Quantum Circuit not drawing?,<qiskit><programming><quantum-circuit>,3,0,,,"Quantum Circuit not drawing? <p>I have coded this from a tutorial:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram
import cirq

m_simulator = Aer.backends(name=&quot;Quantum_Simulation&quot;)
qreg = QuantumRegister(2)
creg = ClassicalRegister(2)
entangler = QuantumCircuit(qreg, creg)
entangler.h(0)
entangler.cx(0, 1)
entangler.measure(0, 0)
entangler.measure(1, 1)
entangler.draw(output=&quot;mpl&quot;)
</code></pre>
<p>For some reason, <code>entangler.draw(output=&quot;mpl&quot;)</code> is not working. If someone can let me know why, that would be greatly appreciated. The link I am using is: <a href=""https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e"" rel=""nofollow noreferrer"">https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e</a></p>
",qc,quantum circuit drawing p coded tutorial pre code qiskit import quantumregister classicalregister quantumcircuit aer execute import import cirq quot quot qreg quantumregister 2 creg classicalregister 2 entangler quantumcircuit qreg creg 0 0 1 0 0 1 1 quot mpl quot p reason code quot mpl quot working someone let know would greatly appreciated link using https nofollow noreferrer https,"[(0, 0.3995569), (2, 0.24435814), (4, 0.19657947), (12, 0.01723738), (16, 0.037750263), (19, 0.102111146)]"
33599,33656.0,2023-07-28 03:22:54,0,276,"<p>Hey Quantum Computing community,</p>
<p>I cannot get TensorFlow Quantum to work even though I am using</p>
<p><code>pip install tensorflow-quantum</code></p>
<p>I have TensorFlow already on Visual Studio Code, and I know it is a prerequisite for being able to download TensorFlow Quantum. I even tried going down a level of TensorFlow (I think it is called downgrading), but unfortunately, my Visual Studio Code terminal does not recognize it.</p>
<p>Thank You!</p>
<p>Update: Including image down below:<a href=""https://i.sstatic.net/8QIyM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8QIyM.png"" alt=""What I tried doing"" /></a></p>
",Cannot Download TensorFlow Quantum,<programming><tfq>,2,3,,,"Cannot Download TensorFlow Quantum <p>Hey Quantum Computing community,</p>
<p>I cannot get TensorFlow Quantum to work even though I am using</p>
<p><code>pip install tensorflow-quantum</code></p>
<p>I have TensorFlow already on Visual Studio Code, and I know it is a prerequisite for being able to download TensorFlow Quantum. I even tried going down a level of TensorFlow (I think it is called downgrading), but unfortunately, my Visual Studio Code terminal does not recognize it.</p>
<p>Thank You!</p>
<p>Update: Including image down below:<a href=""https://i.sstatic.net/8QIyM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8QIyM.png"" alt=""What I tried doing"" /></a></p>
",qc,download tensorflow quantum p hey quantum computing community p get tensorflow quantum work even though using p code pip install p tensorflow already visual studio code know prerequisite able download tensorflow quantum even tried going level tensorflow think called downgrading unfortunately visual studio code terminal recognize p thank p update including image https nofollow noreferrer img https tried,"[(0, 0.100992784), (4, 0.19672541), (7, 0.050436094), (8, 0.43016002), (12, 0.09494004), (14, 0.08651167), (16, 0.037877746)]"
33667,,2023-08-03 15:37:13,1,111,"<p>Months or years ago, in a remote part of the globe, someone accessed an IBM Quantum computer online to perform a real experiment. She saved the resulting measurement outcomes of the algorithm in csv format on her computer, and she doesn't have access to IBM's experimental data files or job IDs anymore. She was cautious with her methods, so while she took the steps to perform measurement error mitigation, she kept raw measurement data separate from the data used to calibrate the error mitigation fitter. As a result, she now has two tables in her computer, which can be imported as Pandas dataframes: <code>calibration_df</code> and <code>raw_results_df</code>.</p>
<p>In both dataframes, each row represents a circuit, and there are only two columns: 0 and 1, containing the counts of each possible output of the single qubit measured. Naturally, the <code>calibration_df</code> contains only two rows: &quot;Prep 0&quot; and &quot;Prep 1&quot;, the circuits used to gather the data for calibration of measurement error mitigation. The <code>raw_results_df</code> contains the results of the circuits used for the actual experiment. Let's say it has 10 rows.</p>
<p>Since she only has access to these two dataframes and she knows that, in principle, the data in <code>calibration_df</code> could be used to mitigate the <code>raw_results_df</code> and produce the corresponding <code>mitigated_results_df</code>, she would like to do just that using the latest <code>Qiskit</code> methods.  All the measurement error mitigation tutorials she has been able to find seem to require the calibration results in the form of a <code>Result</code> object, however, which she doesn't have access to anymore. Furthermore, trying to import and use <code>CompleteMeasFitter</code>, she runs into <code>DeprecationWarning: The class ``qiskit.utils.mitigation.fitters.CompleteMeasFitter`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi_migration.</code>.</p>
<p>Do you have an idea how she could achieve that? Some help would be appreciated.</p>
<pre><code>import pandas as pd
calibration_df = pd.DataFrame([{'0':9293,'1':707},{'0':434,'1':9566}], index=[['Prep 0','Prep 1']])
raw_results_df = pd.DataFrame([{'0':1500,'1':8500},{'0':6234,'1':3766},{'0':4213,'1':5787},{'0':8124,'1':1876},{'0':3198,'1':6802},
                               {'0':8462,'1':1538},{'0':5791,'1':4209},{'0':2443,'1':7557},{'0':4897,'1':5103},{'0':9001,'1':999}])
</code></pre>
","Qiskit's measurement error mitigation from counts data only, in 2023",<qiskit><ibm-q-experience><error-mitigation>,1,0,,,"Qiskit's measurement error mitigation from counts data only, in 2023 <p>Months or years ago, in a remote part of the globe, someone accessed an IBM Quantum computer online to perform a real experiment. She saved the resulting measurement outcomes of the algorithm in csv format on her computer, and she doesn't have access to IBM's experimental data files or job IDs anymore. She was cautious with her methods, so while she took the steps to perform measurement error mitigation, she kept raw measurement data separate from the data used to calibrate the error mitigation fitter. As a result, she now has two tables in her computer, which can be imported as Pandas dataframes: <code>calibration_df</code> and <code>raw_results_df</code>.</p>
<p>In both dataframes, each row represents a circuit, and there are only two columns: 0 and 1, containing the counts of each possible output of the single qubit measured. Naturally, the <code>calibration_df</code> contains only two rows: &quot;Prep 0&quot; and &quot;Prep 1&quot;, the circuits used to gather the data for calibration of measurement error mitigation. The <code>raw_results_df</code> contains the results of the circuits used for the actual experiment. Let's say it has 10 rows.</p>
<p>Since she only has access to these two dataframes and she knows that, in principle, the data in <code>calibration_df</code> could be used to mitigate the <code>raw_results_df</code> and produce the corresponding <code>mitigated_results_df</code>, she would like to do just that using the latest <code>Qiskit</code> methods.  All the measurement error mitigation tutorials she has been able to find seem to require the calibration results in the form of a <code>Result</code> object, however, which she doesn't have access to anymore. Furthermore, trying to import and use <code>CompleteMeasFitter</code>, she runs into <code>DeprecationWarning: The class ``qiskit.utils.mitigation.fitters.CompleteMeasFitter`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi_migration.</code>.</p>
<p>Do you have an idea how she could achieve that? Some help would be appreciated.</p>
<pre><code>import pandas as pd
calibration_df = pd.DataFrame([{'0':9293,'1':707},{'0':434,'1':9566}], index=[['Prep 0','Prep 1']])
raw_results_df = pd.DataFrame([{'0':1500,'1':8500},{'0':6234,'1':3766},{'0':4213,'1':5787},{'0':8124,'1':1876},{'0':3198,'1':6802},
                               {'0':8462,'1':1538},{'0':5791,'1':4209},{'0':2443,'1':7557},{'0':4897,'1':5103},{'0':9001,'1':999}])
</code></pre>
",qc,qiskit measurement error mitigation counts data 2023 p months years ago remote part globe someone accessed ibm quantum computer online perform real experiment saved resulting measurement outcomes algorithm csv format computer access ibm experimental data files job ids anymore cautious methods took steps perform measurement error mitigation kept raw measurement data separate data used calibrate error mitigation fitter result two tables computer imported pandas dataframes code code p dataframes row represents circuit two columns 0 1 containing counts possible output single qubit measured naturally code contains two rows quot prep 0 quot quot prep 1 quot circuits used gather data calibration measurement error mitigation code contains results circuits used actual experiment let say 10 p since access two dataframes knows principle data code could used mitigate code produce corresponding code would like using latest code qiskit methods measurement error mitigation tutorials able find seem require calibration results form code result object however access anymore furthermore trying import use code completemeasfitter runs code deprecationwarning class deprecated removed earlier 3 months release date code migration guidelines visit https p idea could achieve help would pre code import pandas pd 0 1,"[(0, 0.12535465), (2, 0.036341686), (8, 0.15372951), (13, 0.04199205), (14, 0.5758412), (16, 0.019053284), (17, 0.020814713), (19, 0.026209459)]"
33700,33703.0,2023-08-06 11:27:01,1,155,"<p>I want to simulate the error correction procedure for a CNOT gate on surface code and RHG cube, made by the lattice surgery process of &quot;merge and split&quot;.</p>
<p>In this case, the code has an H-shape, with four &quot;Z&quot; (smooth) surface boundaries (two in spatial directions and two in the time direction), four &quot;X&quot; (rough) surface boundaries in the time direction, and two &quot;X&quot; (rough) surface boundaries in the spatial direction.</p>
<p>How should I define the logical error chains in this situation? Can I use Pymatching in this situation? How can I verify whether the decoding produced a logical error?</p>
",Using Pymatching to decode lattice surgery process,<surface-code><pymatching><measurement-based-qc><lattice-surgery><logical-gates>,1,0,,,"Using Pymatching to decode lattice surgery process <p>I want to simulate the error correction procedure for a CNOT gate on surface code and RHG cube, made by the lattice surgery process of &quot;merge and split&quot;.</p>
<p>In this case, the code has an H-shape, with four &quot;Z&quot; (smooth) surface boundaries (two in spatial directions and two in the time direction), four &quot;X&quot; (rough) surface boundaries in the time direction, and two &quot;X&quot; (rough) surface boundaries in the spatial direction.</p>
<p>How should I define the logical error chains in this situation? Can I use Pymatching in this situation? How can I verify whether the decoding produced a logical error?</p>
",qc,using pymatching decode lattice surgery process p want simulate error correction procedure cnot gate surface code rhg cube made lattice surgery process quot merge split quot p case code four quot z quot smooth surface boundaries two spatial directions two time direction four quot x quot rough surface boundaries time direction two quot x quot rough surface boundaries spatial p define logical error chains situation use pymatching situation verify whether decoding produced logical error,"[(5, 0.33371723), (7, 0.07862895), (10, 0.025237098), (13, 0.22461347), (14, 0.044949774), (16, 0.054625783), (17, 0.050158355), (18, 0.06140853), (19, 0.12517501)]"
33939,33946.0,2023-08-26 21:58:23,3,656,"<p>I want to create the GHZ-like state, <span class=""math-container"">$|\Psi\rangle = \frac{1}{\sqrt{2}} \left(|011\rangle - |100 \rangle \right)$</span>.
I build my circuit in the following way.</p>
<ol>
<li>apply the x gate to the first and third qubits to make the input as <span class=""math-container"">$|101\rangle$</span></li>
<li>apply the Hadamard gate to the first qubit</li>
<li>apply the CNOT gate to (q0,q1) and (q1, q2)
<a href=""https://i.sstatic.net/6k7fZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6k7fZ.png"" alt=""enter image description here"" /></a> <a href=""https://i.sstatic.net/yRl61.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yRl61.png"" alt=""enter image description here"" /></a></li>
</ol>
<p>I run the simulation to make sure that I get the right reult.
However, I failed to get the expected state mathematically. Here is how I do the calculation:</p>
<p><span class=""math-container"">$(H\otimes I \otimes I)|101\rangle = H|1\rangle \otimes I|0\rangle \otimes I|1\rangle = \frac{1}{\sqrt 2} (|0\rangle - |1\rangle) \otimes |0\rangle \otimes|1\rangle = \frac{1}{\sqrt 2} (|001\rangle - |101\rangle)$</span></p>
<p>Apply CNOT gates: <span class=""math-container"">$\frac{1}{\sqrt 2} (|001\rangle - |101\rangle) \rightarrow \frac{1}{\sqrt 2} (|001\rangle - |111\rangle) \frac{1}{\sqrt 2} (|001\rangle - |110\rangle)$</span></p>
<p>My calculation tells me I should input <span class=""math-container"">$|110\rangle$</span> instead :
<span class=""math-container"">$(H\otimes I \otimes I)|110\rangle = H|1\rangle \otimes I|1\rangle \otimes I|0\rangle = \frac{1}{\sqrt 2} (|0\rangle - |1\rangle) \otimes |1\rangle \otimes0\rangle = \frac{1}{\sqrt 2} (|010\rangle - |110\rangle)$</span></p>
<p>Apply CNOT gates: <span class=""math-container"">$\frac{1}{\sqrt 2} (|010\rangle - |110\rangle) \rightarrow \frac{1}{\sqrt 2} (|010\rangle - |100\rangle) \frac{1}{\sqrt 2} (|011\rangle - |100\rangle)$</span></p>
<p>Could anyone tell me what's wrong with my calculation?</p>
",Output of my quantum circuit to create 3-qubit GHZ-like state does not make sense mathematically,<quantum-state><ibm-q-experience><quantum-circuit><ghz-state>,1,4,,,"Output of my quantum circuit to create 3-qubit GHZ-like state does not make sense mathematically <p>I want to create the GHZ-like state, <span class=""math-container"">$|\Psi\rangle = \frac{1}{\sqrt{2}} \left(|011\rangle - |100 \rangle \right)$</span>.
I build my circuit in the following way.</p>
<ol>
<li>apply the x gate to the first and third qubits to make the input as <span class=""math-container"">$|101\rangle$</span></li>
<li>apply the Hadamard gate to the first qubit</li>
<li>apply the CNOT gate to (q0,q1) and (q1, q2)
<a href=""https://i.sstatic.net/6k7fZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6k7fZ.png"" alt=""enter image description here"" /></a> <a href=""https://i.sstatic.net/yRl61.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yRl61.png"" alt=""enter image description here"" /></a></li>
</ol>
<p>I run the simulation to make sure that I get the right reult.
However, I failed to get the expected state mathematically. Here is how I do the calculation:</p>
<p><span class=""math-container"">$(H\otimes I \otimes I)|101\rangle = H|1\rangle \otimes I|0\rangle \otimes I|1\rangle = \frac{1}{\sqrt 2} (|0\rangle - |1\rangle) \otimes |0\rangle \otimes|1\rangle = \frac{1}{\sqrt 2} (|001\rangle - |101\rangle)$</span></p>
<p>Apply CNOT gates: <span class=""math-container"">$\frac{1}{\sqrt 2} (|001\rangle - |101\rangle) \rightarrow \frac{1}{\sqrt 2} (|001\rangle - |111\rangle) \frac{1}{\sqrt 2} (|001\rangle - |110\rangle)$</span></p>
<p>My calculation tells me I should input <span class=""math-container"">$|110\rangle$</span> instead :
<span class=""math-container"">$(H\otimes I \otimes I)|110\rangle = H|1\rangle \otimes I|1\rangle \otimes I|0\rangle = \frac{1}{\sqrt 2} (|0\rangle - |1\rangle) \otimes |1\rangle \otimes0\rangle = \frac{1}{\sqrt 2} (|010\rangle - |110\rangle)$</span></p>
<p>Apply CNOT gates: <span class=""math-container"">$\frac{1}{\sqrt 2} (|010\rangle - |110\rangle) \rightarrow \frac{1}{\sqrt 2} (|010\rangle - |100\rangle) \frac{1}{\sqrt 2} (|011\rangle - |100\rangle)$</span></p>
<p>Could anyone tell me what's wrong with my calculation?</p>
",qc,output quantum circuit create state make sense mathematically p want create state span 1 2 build circuit following ol li apply x gate first third qubits make input span li apply hadamard gate first qubit li apply cnot gate q0 q1 q1 q2 https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description p run simulation make sure get right reult however failed get expected state mathematically calculation p span 1 2 1 2 p apply cnot gates span 1 2 1 2 1 2 p calculation tells input span instead span 1 2 1 2 p apply cnot gates span 1 2 1 2 1 2 p could anyone tell wrong calculation,"[(2, 0.19120747), (3, 0.051197957), (4, 0.37480953), (10, 0.010193407), (14, 0.06392381), (16, 0.025478318), (18, 0.28208944)]"
33959,,2023-08-29 09:13:45,2,173,"<p>I am reading <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">2013, Horsman D. et al. - <em>Surface code quantum computing by lattice surgery</em></a>. I have been trying to understand how the outcome of rough lattice merging, which is discussed using both stabilizer formalism and logical qubit formalism, can be retrieved by carrying out operations on physical qubits. My current understanding is that, while logically lattice merging is equivalent to measuring the product of logical operators <span class=""math-container"">$X_1X_2$</span>, this measurement procedure would not involve the merge qubits introduced at the boundary at all, effectively leaving them in their initial <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>I am therefore assuming that either:</p>
<p>a) one physically measures each <span class=""math-container"">$A_{V}$</span> separately and shows that, depending on the sign of the product of these <span class=""math-container"">$A_V$</span>, you can identify the output state with the logical state of the extended code as shown in eq. (4).</p>
<p>b) one measures <span class=""math-container"">$X_1X_2$</span> (independent of the merge qubits) and that a subsequent decoding procedure is required to fix the potential syndrome along the line of merging qubits.</p>
<p>I know the stabilizer analysis in the appendix A is much clearer and is supporting the former hypothesis, but then why does the main text use the latter and, most importantly, why is it correct?</p>
",Lattice Surgery: how does lattice merging act on the physical qubits?,<surface-code><lattice-surgery>,1,0,,,"Lattice Surgery: how does lattice merging act on the physical qubits? <p>I am reading <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">2013, Horsman D. et al. - <em>Surface code quantum computing by lattice surgery</em></a>. I have been trying to understand how the outcome of rough lattice merging, which is discussed using both stabilizer formalism and logical qubit formalism, can be retrieved by carrying out operations on physical qubits. My current understanding is that, while logically lattice merging is equivalent to measuring the product of logical operators <span class=""math-container"">$X_1X_2$</span>, this measurement procedure would not involve the merge qubits introduced at the boundary at all, effectively leaving them in their initial <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>I am therefore assuming that either:</p>
<p>a) one physically measures each <span class=""math-container"">$A_{V}$</span> separately and shows that, depending on the sign of the product of these <span class=""math-container"">$A_V$</span>, you can identify the output state with the logical state of the extended code as shown in eq. (4).</p>
<p>b) one measures <span class=""math-container"">$X_1X_2$</span> (independent of the merge qubits) and that a subsequent decoding procedure is required to fix the potential syndrome along the line of merging qubits.</p>
<p>I know the stabilizer analysis in the appendix A is much clearer and is supporting the former hypothesis, but then why does the main text use the latter and, most importantly, why is it correct?</p>
",qc,lattice surgery lattice merging act physical qubits p reading https nofollow noreferrer 2013 horsman et al em surface code quantum computing lattice surgery trying understand outcome rough lattice merging discussed using stabilizer formalism logical qubit formalism retrieved carrying operations physical qubits current understanding logically lattice merging equivalent measuring product logical operators span measurement procedure would involve merge qubits introduced boundary effectively leaving initial span p therefore assuming either p one physically measures span v separately shows depending sign product span identify output state logical state extended code shown eq 4 p b one measures span independent merge qubits subsequent decoding procedure required fix potential syndrome along line merging p know stabilizer analysis appendix much clearer supporting former hypothesis main text use latter importantly correct,"[(3, 0.16555122), (4, 0.032976184), (5, 0.24051334), (9, 0.13276492), (13, 0.15315212), (16, 0.102757476), (18, 0.1712192)]"
33970,,2023-08-29 19:54:26,3,335,"<p>Let's say I have a universal quantum computer that can perform anything.</p>
<p>In this case, any VQE algorithm can use any operation, so no ansatz is needed to implement it.</p>
<p>My question is, is the usage of the ansatz for the VQE algorithms because current quantum computers lack the ability to perfrom the universal quantum computations within a given coherence time?</p>
",The importance of the ansatz in VQE algorithm,<vqe>,2,3,,,"The importance of the ansatz in VQE algorithm <p>Let's say I have a universal quantum computer that can perform anything.</p>
<p>In this case, any VQE algorithm can use any operation, so no ansatz is needed to implement it.</p>
<p>My question is, is the usage of the ansatz for the VQE algorithms because current quantum computers lack the ability to perfrom the universal quantum computations within a given coherence time?</p>
",qc,importance ansatz vqe algorithm p let say universal quantum computer perform p case vqe algorithm use operation ansatz needed implement p question usage ansatz vqe algorithms current quantum computers lack ability perfrom universal quantum computations within given coherence time,"[(1, 0.27420527), (8, 0.504454), (9, 0.072278105), (14, 0.11267045), (16, 0.03246355)]"
34123,34125.0,2023-09-12 14:36:03,3,251,"<p>A few weeks ago I was on a website that had a list of IBM quantum devices and it showed the topology and frequency of each of the qubits but I can't seem to find that anymore. I was hoping that someone here could point me in that direction.</p>
",List of IBM devices,<ibm-quantum-devices>,1,0,,,"List of IBM devices <p>A few weeks ago I was on a website that had a list of IBM quantum devices and it showed the topology and frequency of each of the qubits but I can't seem to find that anymore. I was hoping that someone here could point me in that direction.</p>
",qc,list ibm devices p weeks ago website list ibm quantum devices showed topology frequency qubits ca seem find anymore hoping someone could point,"[(0, 0.06053849), (7, 0.40820828), (14, 0.40653813), (16, 0.11781369)]"
34176,34184.0,2023-09-15 10:52:54,0,124,"<p>I have the calibration data of an Ibm backend and now I want to plot the error map of the device at that specific time.
How can I do this?</p>
",How can visualise the old error map of Ibm backend if one save the calibration data of the backend at that time?,<qiskit><noise><ibm-quantum-devices>,2,0,,,"How can visualise the old error map of Ibm backend if one save the calibration data of the backend at that time? <p>I have the calibration data of an Ibm backend and now I want to plot the error map of the device at that specific time.
How can I do this?</p>
",qc,visualise old error map ibm backend one save calibration data backend time p calibration data ibm backend want plot error map device specific time,"[(0, 0.1264685), (5, 0.11292177), (11, 0.08696966), (14, 0.34337202), (16, 0.2418357), (19, 0.08263767)]"
34185,34187.0,2023-09-16 10:51:33,0,316,"<p>I want to plot the error map of an IBM Quantum backend from the calibration data I saved a month ago. The saved file just contain qubit properties and to plot error map I would need all information including gate error ( as in csv file when download calibration data from the backend). I used <code>prop_2023 = backend.properties(datetime=dt)</code> to get backend properties of that specific time and use this command to read <code>prop_2023.to_dict()</code> but still I don't know how to extract the information I needed to plot error map of the backend! Any idea how to do this?</p>
",How can one obtain all calibration data which is needed to plot error_map of the ibm backend from few month ago?,<qiskit><ibm-q-experience><noise>,1,0,,,"How can one obtain all calibration data which is needed to plot error_map of the ibm backend from few month ago? <p>I want to plot the error map of an IBM Quantum backend from the calibration data I saved a month ago. The saved file just contain qubit properties and to plot error map I would need all information including gate error ( as in csv file when download calibration data from the backend). I used <code>prop_2023 = backend.properties(datetime=dt)</code> to get backend properties of that specific time and use this command to read <code>prop_2023.to_dict()</code> but still I don't know how to extract the information I needed to plot error map of the backend! Any idea how to do this?</p>
",qc,one obtain calibration data needed plot ibm backend month ago p want plot error map ibm quantum backend calibration data saved month ago saved file contain qubit properties plot error map would need information including gate error csv file download calibration data backend used code get backend properties specific time use command read code still know extract information needed plot error map backend idea,"[(0, 0.33144426), (8, 0.18861961), (11, 0.04063196), (14, 0.3482798), (16, 0.08868667)]"
34208,38588.0,2023-09-18 17:37:23,2,55,"<p>Suppose I have two quantum channels. Assume they they consist of <span class=""math-container"">$r\in \mathbb{Z}$</span> applications of unitaries, <span class=""math-container"">$U$</span> and <span class=""math-container"">$V$</span> respectively. Let the error between the channels acting on some state <span class=""math-container"">$\rho$</span> be:
<span class=""math-container"">$$\varepsilon(U,V) =   U^{\dagger r} \rho U^r - V^{\dagger r} \rho V^r.  $$</span></p>
<p>Ideally, I want an expression for <span class=""math-container"">$\epsilon(U,V)$</span> in terms of the difference between these unitaries and <span class=""math-container"">$r$</span>. Ideally I want an expression for <span class=""math-container"">$\varepsilon(U,V)$</span> as defined above, not the norm of the expression.</p>
<p>My first attempt was to write that <span class=""math-container"">$U^r - V^r = \sum_{k=1}^{r-1} U^{r-k}(U-V)V^k$</span> and substitute into the expression for <span class=""math-container"">$\varepsilon(U,V)$</span>. However, this introduces a lot of cross terms which make things messy, and one ends up with <span class=""math-container"">$O(r^2)$</span> many terms when it feels like there should only be <span class=""math-container"">$O(r)$</span>. Is there a better way to do this?</p>
",Error in repeated applications of a quantum channel?,<quantum-circuit><quantum-operation><unitarity>,1,6,,,"Error in repeated applications of a quantum channel? <p>Suppose I have two quantum channels. Assume they they consist of <span class=""math-container"">$r\in \mathbb{Z}$</span> applications of unitaries, <span class=""math-container"">$U$</span> and <span class=""math-container"">$V$</span> respectively. Let the error between the channels acting on some state <span class=""math-container"">$\rho$</span> be:
<span class=""math-container"">$$\varepsilon(U,V) =   U^{\dagger r} \rho U^r - V^{\dagger r} \rho V^r.  $$</span></p>
<p>Ideally, I want an expression for <span class=""math-container"">$\epsilon(U,V)$</span> in terms of the difference between these unitaries and <span class=""math-container"">$r$</span>. Ideally I want an expression for <span class=""math-container"">$\varepsilon(U,V)$</span> as defined above, not the norm of the expression.</p>
<p>My first attempt was to write that <span class=""math-container"">$U^r - V^r = \sum_{k=1}^{r-1} U^{r-k}(U-V)V^k$</span> and substitute into the expression for <span class=""math-container"">$\varepsilon(U,V)$</span>. However, this introduces a lot of cross terms which make things messy, and one ends up with <span class=""math-container"">$O(r^2)$</span> many terms when it feels like there should only be <span class=""math-container"">$O(r)$</span>. Is there a better way to do this?</p>
",qc,error repeated applications quantum channel p suppose two quantum channels assume consist span z applications unitaries span u span v respectively let error channels acting state span span u v r r p ideally want expression span u v terms difference unitaries span r ideally want expression span u v defined norm p first attempt write span substitute expression span u v however introduces lot cross terms make things messy one ends span many terms feels like span r better way,"[(3, 0.85162526), (5, 0.033688966), (8, 0.099888824), (16, 0.012825648)]"
34312,34314.0,2023-09-28 20:19:16,1,85,"<p>Using one seed to generate one batch of sample and then compute the logical error rate is obviously statistically safe.
But in case I want to sample one small batch at a time, how can I configure the measurement sampler(s) to make different batches independent at the stim Python API level? Should I use different seeds, or is there a way to configure the seeds to make it safe?</p>
<p>Or, can I just call <code>Circuit.sampler()</code> without providing a seed, since <code>sinter</code> also creates <code>detector_sampler</code> without a seed and sample in small batches?</p>
",Whether/How can I combine logical error rates of the same circuit from different batches of samples in stim,<stim>,1,0,,,"Whether/How can I combine logical error rates of the same circuit from different batches of samples in stim <p>Using one seed to generate one batch of sample and then compute the logical error rate is obviously statistically safe.
But in case I want to sample one small batch at a time, how can I configure the measurement sampler(s) to make different batches independent at the stim Python API level? Should I use different seeds, or is there a way to configure the seeds to make it safe?</p>
<p>Or, can I just call <code>Circuit.sampler()</code> without providing a seed, since <code>sinter</code> also creates <code>detector_sampler</code> without a seed and sample in small batches?</p>
",qc,combine logical error rates circuit different batches samples stim p using one seed generate one batch sample compute logical error rate obviously statistically safe case want sample one small batch time configure measurement sampler make different batches independent stim python api level use different seeds way configure seeds make safe p call code without providing seed since code sinter also creates code without seed sample small batches,"[(5, 0.21499902), (8, 0.059544735), (14, 0.65062463), (16, 0.045240466), (19, 0.02725277)]"
34355,,2023-10-04 00:40:11,2,162,"<p><a href=""https://i.sstatic.net/nQf5D.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nQf5D.png"" alt=""The Question"" /></a></p>
<p>How do I prove that the equation on the right is <span class=""math-container"">$CX$</span> and <span class=""math-container"">$CZ$</span> gate? I don't think that reaching the matrix of the CX or CZ is possible with the given equation.</p>
<p>For (b) I keep getting <span class=""math-container"">$I \otimes I$</span> while on (c), I keep getting crazy matrix after evaluation.</p>
<p>I have tried to substitute the equation provided, used the tensor product, and then multiply them all together.</p>
",How to prove that these equations are correct for $CZ$ and $CX$?,<quantum-gate><pauli-gates><matrix-representation>,2,3,,,"How to prove that these equations are correct for $CZ$ and $CX$? <p><a href=""https://i.sstatic.net/nQf5D.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nQf5D.png"" alt=""The Question"" /></a></p>
<p>How do I prove that the equation on the right is <span class=""math-container"">$CX$</span> and <span class=""math-container"">$CZ$</span> gate? I don't think that reaching the matrix of the CX or CZ is possible with the given equation.</p>
<p>For (b) I keep getting <span class=""math-container"">$I \otimes I$</span> while on (c), I keep getting crazy matrix after evaluation.</p>
<p>I have tried to substitute the equation provided, used the tensor product, and then multiply them all together.</p>
",qc,prove equations correct cz cx p https nofollow noreferrer img https question p prove equation right span cx span cz gate think reaching matrix cx cz possible given p b keep getting span c keep getting crazy matrix p tried substitute equation provided used tensor product multiply,"[(3, 0.45064604), (4, 0.3303321), (6, 0.13489255), (11, 0.05952401), (16, 0.021422887)]"
34446,,2023-10-12 08:02:13,4,179,"<p>I tried to make a cirq program calculating an eigenvalue of the observable by VQE. Inspired by <a href=""https://docs.qulacs.org/en/latest/apply/6.2_vqe.html"" rel=""nofollow noreferrer"">the qulacs VQE tutorial</a>, I defined a cost function from the expectation value of the observable with hardware efficient ansatz.</p>
<pre><code>import cirq
import sympy
import numpy as np

def hea_multilayer(qubits, depth):
    n_qubits = len(qubits)
    n_params = 2*n_qubits*(depth + 1)
    theta = sympy.symbols(f'a:{n_params}')
    for j in range(depth):
        for i in range(n_qubits):
            yield cirq.ry(theta[2*j*n_qubits + i])(qubits[i])
            yield cirq.rz(theta[2*j*n_qubits + i + n_qubits])(qubits[i])

        for i in range(n_qubits - 1):
            yield cirq.CNOT(qubits[i], qubits[i+1])

    for i in range(n_qubits):
        yield cirq.ry(theta[2*depth*n_qubits + i])(qubits[i])
        yield cirq.rz(theta[2*depth*n_qubits + n_qubits + i])(qubits[i])

n_qubits = 2
depth = 1
qubits = cirq.LineQubit.range(n_qubits)
qc = cirq.Circuit()
qc.append(hea_multilayer(qubits, depth))

observable = cirq.PauliSum.from_pauli_strings([
    cirq.PauliString(1.0, cirq.I(qubits[0]), cirq.I(qubits[1])),
    cirq.PauliString(1.0, cirq.X(qubits[0]), cirq.X(qubits[1])),
    cirq.PauliString(-1.0, cirq.Y(qubits[0]), cirq.Y(qubits[1])),
    cirq.PauliString(1.0, cirq.Z(qubits[0]), cirq.Z(qubits[1]))
])
print(observable)
print(qc)

sim = cirq.Simulator()
def cost(parameter):
    subs = {}
    for i in range(2*n_qubits*(depth+1)):
        subs[f'a{i}'] = parameter[i]

    result = sim.simulate_expectation_values(qc, observable, subs)
    return result[0].real

</code></pre>
<p>After that, I minimized this cost function using scipy minimize function.</p>
<pre><code>np.random.seed(2023)
parameter = np.random.random(8)

from scipy.optimize import minimize
cost_history = []
cost_history.append(cost(parameter))
min_result = minimize(cost, parameter, method=&quot;BFGS&quot;, callback=lambda x: cost_history.append(cost(x)))
print(min_result)
print(cost_history)
</code></pre>
<p>However, this minimization did not work with the following message:</p>
<pre><code>  message: Desired error not necessarily achieved due to precision loss.
  success: False
   status: 2
      fun: 0.2531989514827728
        x: [ 3.220e-01  8.904e-01  5.881e-01 -1.969e-01 -6.673e-01
             6.296e-01  2.209e-02  2.421e-01]
      nit: 7
      jac: [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
             2.000e+00  0.000e+00  0.000e+00]
 hess_inv: [[ 1.000e+00  0.000e+00 ...  0.000e+00  0.000e+00]
            [ 0.000e+00  1.000e+00 ...  0.000e+00  0.000e+00]
            ...
            [ 0.000e+00  0.000e+00 ...  2.805e-06 -5.530e-06]
            [ 0.000e+00  0.000e+00 ... -5.530e-06  1.104e-05]]
     nfev: 993
     njev: 109
[0.36777588725090027, 0.25321047008037567, 0.2532104179263115, 0.25321032106876373, 0.2532094195485115, 0.25320935994386673, 0.2532089278101921, 0.2531989514827728]
</code></pre>
<p>I implemented this program using qiskit, and compared the result to the qiskit VQE solver:</p>
<pre><code>from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2
import numpy as np

np.random.seed(2023)

qc = EfficientSU2(2, reps = 1, insert_barriers=True, flatten=True)

observable = SparsePauliOp([&quot;II&quot;, &quot;XX&quot;, &quot;YY&quot;, &quot;ZZ&quot;], coeffs = [1, 1, -1, 1])

estimator = Estimator()

parameter = np.random.random(8)
job = estimator.run(qc, observable, parameter_values = parameter)
print(f'Parameter: {parameter}')
print(f'Circuit:\n{qc}')
print(f'Job result: {job.result()}')

def cost(parameter):
    job = estimator.run(qc, observable, parameter_values=parameter)
    return job.result().values[0]

from scipy.optimize import minimize
cost_history = []
cost_history.append(cost(parameter))
min_result = minimize(cost, parameter, method=&quot;L-BFGS-B&quot;, callback=lambda x: cost_history.append(cost(x)))
print(min_result)
print(cost_history)

from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import L_BFGS_B

cost_history = []
cost_history.append(cost(parameter))
vqe = VQE(estimator=estimator, ansatz=qc, optimizer=L_BFGS_B(), initial_point=parameter)
result = vqe.compute_minimum_eigenvalue(observable)
print(result)
print(cost_history)
</code></pre>
<p>And my result is similar to the qiskit VQE solver result.</p>
<pre><code>Job result: EstimatorResult(values=array([1.43214656]), metadata=[{}])
  message: CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL
  success: True
   status: 0
      fun: 5.907418998418734e-11
        x: [ 2.681e-01  1.710e+00  8.852e-01  1.201e-02 -1.934e-01
             1.231e+00  3.499e-01  1.055e+00]
      nit: 6
      jac: [-2.187e-06 -9.281e-06 -2.776e-06 -4.619e-06  6.217e-06
            -9.692e-06 -1.099e-06 -1.099e-06]
     nfev: 63
     njev: 7
 hess_inv: &lt;8x8 LbfgsInvHessProduct with dtype=float64&gt;
[1.432146558079639, 0.2513704685300491, 0.15156282475910865, 0.0019124923978873776, 3.6796306554398583e-05, 1.1992205672939349e-08, 5.907418998418734e-11]
/home/wleelinux/sources/qiskit_expect/hea_estimator.py:31: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed no earlier than 3 months after the release date. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.
  from qiskit.algorithms.minimum_eigensolvers import VQE
{   'aux_operators_evaluated': None,
    'cost_function_evals': 63,
    'eigenvalue': 2.642741581126984e-11,
    'optimal_circuit': &lt;qiskit.circuit.library.n_local.efficient_su2.EfficientSU2 object at 0x7ff1ac903590&gt;,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): -0.08608117349727416,
                              ParameterVectorElement(θ[1]): 1.9438040339495675,
                              ParameterVectorElement(θ[2]): 1.1497492983826083,
                              ParameterVectorElement(θ[3]): -0.1815167532084752,
                              ParameterVectorElement(θ[4]): -0.23455036012933897,
                              ParameterVectorElement(θ[5]): 1.413331393301791,
                              ParameterVectorElement(θ[6]): 0.7537967436651564,
                              ParameterVectorElement(θ[7]): 1.4589817775219438},
    'optimal_point': array([-0.08608117,  1.94380403,  1.1497493 , -0.18151675, -0.23455036,
        1.41333139,  0.75379674,  1.45898178]),
    'optimal_value': 2.642741581126984e-11,
    'optimizer_evals': None,
    'optimizer_result': &lt;qiskit.algorithms.optimizers.optimizer.OptimizerResult object at 0x7ff1a92233d0&gt;,
    'optimizer_time': 0.2594926357269287}
</code></pre>
<p>Why my cirq code failed? Is it wrong to use <code>simulate_expectation_values</code> method and should I implement the expectation value from the measure of the quantum circuit in cirq?</p>
",Variational Quantum Eigensolver (VQE) by scipy minimize in cirq does not work,<vqe><cirq>,0,1,,,"Variational Quantum Eigensolver (VQE) by scipy minimize in cirq does not work <p>I tried to make a cirq program calculating an eigenvalue of the observable by VQE. Inspired by <a href=""https://docs.qulacs.org/en/latest/apply/6.2_vqe.html"" rel=""nofollow noreferrer"">the qulacs VQE tutorial</a>, I defined a cost function from the expectation value of the observable with hardware efficient ansatz.</p>
<pre><code>import cirq
import sympy
import numpy as np

def hea_multilayer(qubits, depth):
    n_qubits = len(qubits)
    n_params = 2*n_qubits*(depth + 1)
    theta = sympy.symbols(f'a:{n_params}')
    for j in range(depth):
        for i in range(n_qubits):
            yield cirq.ry(theta[2*j*n_qubits + i])(qubits[i])
            yield cirq.rz(theta[2*j*n_qubits + i + n_qubits])(qubits[i])

        for i in range(n_qubits - 1):
            yield cirq.CNOT(qubits[i], qubits[i+1])

    for i in range(n_qubits):
        yield cirq.ry(theta[2*depth*n_qubits + i])(qubits[i])
        yield cirq.rz(theta[2*depth*n_qubits + n_qubits + i])(qubits[i])

n_qubits = 2
depth = 1
qubits = cirq.LineQubit.range(n_qubits)
qc = cirq.Circuit()
qc.append(hea_multilayer(qubits, depth))

observable = cirq.PauliSum.from_pauli_strings([
    cirq.PauliString(1.0, cirq.I(qubits[0]), cirq.I(qubits[1])),
    cirq.PauliString(1.0, cirq.X(qubits[0]), cirq.X(qubits[1])),
    cirq.PauliString(-1.0, cirq.Y(qubits[0]), cirq.Y(qubits[1])),
    cirq.PauliString(1.0, cirq.Z(qubits[0]), cirq.Z(qubits[1]))
])
print(observable)
print(qc)

sim = cirq.Simulator()
def cost(parameter):
    subs = {}
    for i in range(2*n_qubits*(depth+1)):
        subs[f'a{i}'] = parameter[i]

    result = sim.simulate_expectation_values(qc, observable, subs)
    return result[0].real

</code></pre>
<p>After that, I minimized this cost function using scipy minimize function.</p>
<pre><code>np.random.seed(2023)
parameter = np.random.random(8)

from scipy.optimize import minimize
cost_history = []
cost_history.append(cost(parameter))
min_result = minimize(cost, parameter, method=&quot;BFGS&quot;, callback=lambda x: cost_history.append(cost(x)))
print(min_result)
print(cost_history)
</code></pre>
<p>However, this minimization did not work with the following message:</p>
<pre><code>  message: Desired error not necessarily achieved due to precision loss.
  success: False
   status: 2
      fun: 0.2531989514827728
        x: [ 3.220e-01  8.904e-01  5.881e-01 -1.969e-01 -6.673e-01
             6.296e-01  2.209e-02  2.421e-01]
      nit: 7
      jac: [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
             2.000e+00  0.000e+00  0.000e+00]
 hess_inv: [[ 1.000e+00  0.000e+00 ...  0.000e+00  0.000e+00]
            [ 0.000e+00  1.000e+00 ...  0.000e+00  0.000e+00]
            ...
            [ 0.000e+00  0.000e+00 ...  2.805e-06 -5.530e-06]
            [ 0.000e+00  0.000e+00 ... -5.530e-06  1.104e-05]]
     nfev: 993
     njev: 109
[0.36777588725090027, 0.25321047008037567, 0.2532104179263115, 0.25321032106876373, 0.2532094195485115, 0.25320935994386673, 0.2532089278101921, 0.2531989514827728]
</code></pre>
<p>I implemented this program using qiskit, and compared the result to the qiskit VQE solver:</p>
<pre><code>from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2
import numpy as np

np.random.seed(2023)

qc = EfficientSU2(2, reps = 1, insert_barriers=True, flatten=True)

observable = SparsePauliOp([&quot;II&quot;, &quot;XX&quot;, &quot;YY&quot;, &quot;ZZ&quot;], coeffs = [1, 1, -1, 1])

estimator = Estimator()

parameter = np.random.random(8)
job = estimator.run(qc, observable, parameter_values = parameter)
print(f'Parameter: {parameter}')
print(f'Circuit:\n{qc}')
print(f'Job result: {job.result()}')

def cost(parameter):
    job = estimator.run(qc, observable, parameter_values=parameter)
    return job.result().values[0]

from scipy.optimize import minimize
cost_history = []
cost_history.append(cost(parameter))
min_result = minimize(cost, parameter, method=&quot;L-BFGS-B&quot;, callback=lambda x: cost_history.append(cost(x)))
print(min_result)
print(cost_history)

from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import L_BFGS_B

cost_history = []
cost_history.append(cost(parameter))
vqe = VQE(estimator=estimator, ansatz=qc, optimizer=L_BFGS_B(), initial_point=parameter)
result = vqe.compute_minimum_eigenvalue(observable)
print(result)
print(cost_history)
</code></pre>
<p>And my result is similar to the qiskit VQE solver result.</p>
<pre><code>Job result: EstimatorResult(values=array([1.43214656]), metadata=[{}])
  message: CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_&lt;=_PGTOL
  success: True
   status: 0
      fun: 5.907418998418734e-11
        x: [ 2.681e-01  1.710e+00  8.852e-01  1.201e-02 -1.934e-01
             1.231e+00  3.499e-01  1.055e+00]
      nit: 6
      jac: [-2.187e-06 -9.281e-06 -2.776e-06 -4.619e-06  6.217e-06
            -9.692e-06 -1.099e-06 -1.099e-06]
     nfev: 63
     njev: 7
 hess_inv: &lt;8x8 LbfgsInvHessProduct with dtype=float64&gt;
[1.432146558079639, 0.2513704685300491, 0.15156282475910865, 0.0019124923978873776, 3.6796306554398583e-05, 1.1992205672939349e-08, 5.907418998418734e-11]
/home/wleelinux/sources/qiskit_expect/hea_estimator.py:31: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed no earlier than 3 months after the release date. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.
  from qiskit.algorithms.minimum_eigensolvers import VQE
{   'aux_operators_evaluated': None,
    'cost_function_evals': 63,
    'eigenvalue': 2.642741581126984e-11,
    'optimal_circuit': &lt;qiskit.circuit.library.n_local.efficient_su2.EfficientSU2 object at 0x7ff1ac903590&gt;,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): -0.08608117349727416,
                              ParameterVectorElement(θ[1]): 1.9438040339495675,
                              ParameterVectorElement(θ[2]): 1.1497492983826083,
                              ParameterVectorElement(θ[3]): -0.1815167532084752,
                              ParameterVectorElement(θ[4]): -0.23455036012933897,
                              ParameterVectorElement(θ[5]): 1.413331393301791,
                              ParameterVectorElement(θ[6]): 0.7537967436651564,
                              ParameterVectorElement(θ[7]): 1.4589817775219438},
    'optimal_point': array([-0.08608117,  1.94380403,  1.1497493 , -0.18151675, -0.23455036,
        1.41333139,  0.75379674,  1.45898178]),
    'optimal_value': 2.642741581126984e-11,
    'optimizer_evals': None,
    'optimizer_result': &lt;qiskit.algorithms.optimizers.optimizer.OptimizerResult object at 0x7ff1a92233d0&gt;,
    'optimizer_time': 0.2594926357269287}
</code></pre>
<p>Why my cirq code failed? Is it wrong to use <code>simulate_expectation_values</code> method and should I implement the expectation value from the measure of the quantum circuit in cirq?</p>
",qc,variational quantum eigensolver vqe scipy minimize cirq work p tried make cirq program calculating eigenvalue observable vqe inspired https nofollow noreferrer qulacs vqe tutorial defined cost function expectation value observable hardware efficient pre code import cirq import sympy import numpy np def qubits depth len qubits 2 depth 1 theta f j range depth range yield theta 2 j qubits yield theta 2 j qubits range 1 yield qubits qubits range yield theta 2 depth qubits yield theta 2 depth qubits 2 depth 1 qubits qc qubits depth observable qubits 0 qubits 1 qubits 0 qubits 1 qubits 0 qubits 1 qubits 0 qubits 1 print observable print qc sim def cost parameter subs range 2 subs f parameter result qc observable subs return result 0 p minimized cost function using scipy minimize pre code 2023 parameter 8 import minimize cost parameter minimize cost parameter quot bfgs quot x cost x print print p however minimization work following message pre code message desired error necessarily achieved due precision loss success false status 2 fun x nit 7 jac nfev 993 njev 109 p implemented program using qiskit compared result qiskit vqe solver pre code import estimator import sparsepauliop import efficientsu2 import numpy np 2023 qc efficientsu2 2 reps 1 observable sparsepauliop quot ii quot quot xx quot quot yy quot quot zz quot coeffs 1 1 1 estimator estimator parameter 8 job qc observable parameter print parameter print qc print result def cost parameter job qc observable return 0 import minimize cost parameter minimize cost parameter quot quot x cost x print print import vqe import cost parameter vqe vqe result observable print result print p result similar qiskit vqe solver pre code job result estimatorresult message convergence lt success true status 0 fun x nit 6 jac nfev 63 njev 7 lt 8x8 lbfgsinvhessproduct gt deprecationwarning migrated independent package https import path deprecated removed earlier 3 months release date please run pip install use import instead import vqe none 63 lt object 0x7ff1ac903590 gt parametervectorelement θ 0 parametervectorelement θ 1 parametervectorelement θ 2 parametervectorelement θ 3 parametervectorelement θ 4 parametervectorelement θ 5 parametervectorelement θ 6 parametervectorelement θ 7 array none lt object 0x7ff1a92233d0 gt p cirq code failed wrong use code method implement expectation value measure quantum circuit cirq,"[(0, 0.5861337), (2, 0.07640689), (6, 0.028688584), (7, 0.04644112), (10, 0.022065904), (14, 0.100624286), (16, 0.061326742), (19, 0.07798216)]"
34455,34461.0,2023-10-12 16:34:29,2,79,"<p>I am doing some analysis from a  now retired device (<code>lima</code>) and I would like to access its &quot;logic&quot; construction in qiskit. Specifically, I would like to print the circuits in the specific transpilation for the device, print the circuits to external files, and make use of callbacks in order to check the flow of the circuit during the transpilation procedure. How can I access this?</p>
<p>Note that I don't want to retrieve jobs (a.k.a. numerical data).</p>
<p>The error arises in the code</p>
<pre><code>provider = IBMProvider(instance=&quot;ibm-q/open/main&quot;)
backend = provider.get_backend('ibmq_lima')
(...)
# The error:
QiskitBackendNotFoundError: 'No backend matches the criteria'
</code></pre>
<p>What is the &quot;backend access&quot; for retired devices?</p>
",Retrieve backend functionality of retired qiskit device,<qiskit>,1,0,,,"Retrieve backend functionality of retired qiskit device <p>I am doing some analysis from a  now retired device (<code>lima</code>) and I would like to access its &quot;logic&quot; construction in qiskit. Specifically, I would like to print the circuits in the specific transpilation for the device, print the circuits to external files, and make use of callbacks in order to check the flow of the circuit during the transpilation procedure. How can I access this?</p>
<p>Note that I don't want to retrieve jobs (a.k.a. numerical data).</p>
<p>The error arises in the code</p>
<pre><code>provider = IBMProvider(instance=&quot;ibm-q/open/main&quot;)
backend = provider.get_backend('ibmq_lima')
(...)
# The error:
QiskitBackendNotFoundError: 'No backend matches the criteria'
</code></pre>
<p>What is the &quot;backend access&quot; for retired devices?</p>
",qc,retrieve backend functionality retired qiskit device p analysis retired device code lima would like access quot logic quot construction qiskit specifically would like print circuits specific transpilation device print circuits external files make use callbacks order check flow circuit transpilation procedure access p note want retrieve jobs numerical data p error arises code pre code provider ibmprovider quot quot backend error qiskitbackendnotfounderror backend matches criteria p quot backend access quot retired devices,"[(0, 0.09002673), (9, 0.023902338), (14, 0.61283123), (15, 0.06392981), (16, 0.032236267), (17, 0.014724542), (19, 0.16052142)]"
34456,34462.0,2023-10-12 20:02:52,2,49,"<p>Is it possible to do the transpilation with &quot;any&quot; device in qiskit? I would be interested in doing this with already retired devices.</p>
",Is it possible to do the transpilation with a priori retired devices?,<qiskit><ibm-q-experience>,1,0,,,"Is it possible to do the transpilation with a priori retired devices? <p>Is it possible to do the transpilation with &quot;any&quot; device in qiskit? I would be interested in doing this with already retired devices.</p>
",qc,possible transpilation priori retired devices p possible transpilation quot quot device qiskit would interested already retired,"[(14, 0.45337188), (15, 0.13423772), (16, 0.12696876), (18, 0.13760269), (19, 0.13855313)]"
34534,,2023-10-19 21:04:22,1,44,"<p>Is there a way to run a Pulse schedule with different resilience levels? I was thinking about passing the resilience level values in the options of Sampler primitive, but when I tried to run, it says Pulse Schedule is not supported, getting the below error:</p>
<pre><code>QpyError: &quot;Object type '&lt;class 'qiskit.pulse.schedule.Schedule'&gt;' is not supported in Program namespace.&quot;
</code></pre>
<p>Is there any other way to run my Pulse schedule with ZNE or M3 error mitigation strategy?</p>
",Running Pulse Schedules with different resilience levels,<qiskit><ibm-q-experience><ibm-quantum-devices><qiskit-runtime>,0,0,,,"Running Pulse Schedules with different resilience levels <p>Is there a way to run a Pulse schedule with different resilience levels? I was thinking about passing the resilience level values in the options of Sampler primitive, but when I tried to run, it says Pulse Schedule is not supported, getting the below error:</p>
<pre><code>QpyError: &quot;Object type '&lt;class 'qiskit.pulse.schedule.Schedule'&gt;' is not supported in Program namespace.&quot;
</code></pre>
<p>Is there any other way to run my Pulse schedule with ZNE or M3 error mitigation strategy?</p>
",qc,running pulse schedules different resilience levels p way run pulse schedule different resilience levels thinking passing resilience level values options sampler primitive tried run says pulse schedule supported getting error pre code qpyerror quot object type lt class gt supported program quot p way run pulse schedule zne m3 error mitigation strategy,"[(0, 0.4504901), (14, 0.41329512), (16, 0.02120659), (19, 0.11168595)]"
34539,,2023-10-19 23:08:49,2,54,"<p>I was following <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">Surface code quantum computing by lattice surgery</a>.
A few questions about this paper have been asked in this forum, but I believe my question is new.
The main text took a 'state picture' of what happens and in the appendix, the authors provides the stabilizer description.
I want to ask specifically about the rough merge.</p>
<p>Just by the definition 'a rough merge measures <span class=""math-container"">$XX$</span> of two qubits, we can derive the quantum states after the merge, as in Eq.(3)
<a href=""https://i.sstatic.net/MGexv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MGexv.png"" alt=""enter image description here"" /></a></p>
<p>where <span class=""math-container"">$M$</span> is the measurement result, and the states of the qubits before the measurement are <span class=""math-container"">$|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$</span> and <span class=""math-container"">$|\phi\rangle=\alpha'|0\rangle+\beta'|1\rangle$</span>.
Then, by defining the basis states of the merged patch as Eq.(4)
<a href=""https://i.sstatic.net/LzB7V.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LzB7V.png"" alt=""enter image description here"" /></a></p>
<p>we can express rough merge in the state picture as Eq.(5)
<a href=""https://i.sstatic.net/hElqn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hElqn.png"" alt=""enter image description here"" /></a></p>
<p>In the stabilizer description, I can follow the updates of stabilizer table, e.g. if we start from <span class=""math-container"">$|00\rangle$</span>, we get this table in Eq.(A.4)
<a href=""https://i.sstatic.net/DGVaI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/DGVaI.png"" alt=""enter image description here"" /></a></p>
<p>Eq.(6) is the superposition of four cases
<a href=""https://i.sstatic.net/t7o7i.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/t7o7i.png"" alt=""enter image description here"" /></a></p>
<p>In this notation of a state, <span class=""math-container"">$[S]$</span> are the usual stabilizers in a surface code and additionally, the state is stabilized by the Pauli in the second line.
My first issue is that Eq.(A.6) has a typo? If we're factoring out the common terms, should the first and the fourth states be combined together since they have the same state? And the middle two terms should be combined together? This is not the same with what the authors do.
I think the correct result should be something like
<a href=""https://i.sstatic.net/8P7S4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8P7S4.png"" alt=""enter image description here"" /></a></p>
<p>The next step is to map the states of the two qubits before to basis states of the merged patch.
This map is given in Eq.(4). And the authors got Eq.(A.7)
<a href=""https://i.sstatic.net/6VWde.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6VWde.png"" alt=""enter image description here"" /></a></p>
<p>This is my second issue: I fail to see how we can get to Eq.(A.7) from Eq.(A.6) and Eq.(4).
A state stabilized by <span class=""math-container"">$Z_1Z_2Z_aZ_b$</span> just means the parity of the two qubits are even, which can be anything in the span of <span class=""math-container"">$|00\rangle$</span> and <span class=""math-container"">$|11\rangle$</span>? How does the sign before <span class=""math-container"">$\beta$</span> come about? Given a set of stabilizers, we don't know what the sign of the state is, or more generally, its phase.</p>
",lattice surgery in state picture,<error-correction><stabilizer-code><stabilizer-state><lattice-surgery>,0,0,,,"lattice surgery in state picture <p>I was following <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011"" rel=""nofollow noreferrer"">Surface code quantum computing by lattice surgery</a>.
A few questions about this paper have been asked in this forum, but I believe my question is new.
The main text took a 'state picture' of what happens and in the appendix, the authors provides the stabilizer description.
I want to ask specifically about the rough merge.</p>
<p>Just by the definition 'a rough merge measures <span class=""math-container"">$XX$</span> of two qubits, we can derive the quantum states after the merge, as in Eq.(3)
<a href=""https://i.sstatic.net/MGexv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MGexv.png"" alt=""enter image description here"" /></a></p>
<p>where <span class=""math-container"">$M$</span> is the measurement result, and the states of the qubits before the measurement are <span class=""math-container"">$|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$</span> and <span class=""math-container"">$|\phi\rangle=\alpha'|0\rangle+\beta'|1\rangle$</span>.
Then, by defining the basis states of the merged patch as Eq.(4)
<a href=""https://i.sstatic.net/LzB7V.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LzB7V.png"" alt=""enter image description here"" /></a></p>
<p>we can express rough merge in the state picture as Eq.(5)
<a href=""https://i.sstatic.net/hElqn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hElqn.png"" alt=""enter image description here"" /></a></p>
<p>In the stabilizer description, I can follow the updates of stabilizer table, e.g. if we start from <span class=""math-container"">$|00\rangle$</span>, we get this table in Eq.(A.4)
<a href=""https://i.sstatic.net/DGVaI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/DGVaI.png"" alt=""enter image description here"" /></a></p>
<p>Eq.(6) is the superposition of four cases
<a href=""https://i.sstatic.net/t7o7i.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/t7o7i.png"" alt=""enter image description here"" /></a></p>
<p>In this notation of a state, <span class=""math-container"">$[S]$</span> are the usual stabilizers in a surface code and additionally, the state is stabilized by the Pauli in the second line.
My first issue is that Eq.(A.6) has a typo? If we're factoring out the common terms, should the first and the fourth states be combined together since they have the same state? And the middle two terms should be combined together? This is not the same with what the authors do.
I think the correct result should be something like
<a href=""https://i.sstatic.net/8P7S4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8P7S4.png"" alt=""enter image description here"" /></a></p>
<p>The next step is to map the states of the two qubits before to basis states of the merged patch.
This map is given in Eq.(4). And the authors got Eq.(A.7)
<a href=""https://i.sstatic.net/6VWde.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6VWde.png"" alt=""enter image description here"" /></a></p>
<p>This is my second issue: I fail to see how we can get to Eq.(A.7) from Eq.(A.6) and Eq.(4).
A state stabilized by <span class=""math-container"">$Z_1Z_2Z_aZ_b$</span> just means the parity of the two qubits are even, which can be anything in the span of <span class=""math-container"">$|00\rangle$</span> and <span class=""math-container"">$|11\rangle$</span>? How does the sign before <span class=""math-container"">$\beta$</span> come about? Given a set of stabilizers, we don't know what the sign of the state is, or more generally, its phase.</p>
",qc,lattice surgery state picture p following https nofollow noreferrer surface code quantum computing lattice surgery questions paper asked forum believe question new main text took picture happens appendix authors provides stabilizer description want ask specifically rough p definition rough merge measures span xx two qubits derive quantum states merge eq 3 https nofollow noreferrer img https enter image description p span measurement result states qubits measurement span span defining basis states merged patch eq 4 https nofollow noreferrer img https enter image description p express rough merge state picture eq 5 https nofollow noreferrer img https enter image description p stabilizer description follow updates stabilizer table start span get table eq https nofollow noreferrer img https enter image description p eq 6 superposition four cases https nofollow noreferrer img https enter image description p notation state span usual stabilizers surface code additionally state stabilized pauli second line first issue eq typo factoring common terms first fourth states combined together since state middle two terms combined together authors think correct result something like https nofollow noreferrer img https enter image description p next step map states two qubits basis states merged patch map given 4 authors got eq https nofollow noreferrer img https enter image description p second issue fail see get eq eq 4 state stabilized span means parity two qubits even anything span span span sign span come given set stabilizers know sign state generally,"[(3, 0.220852), (4, 0.39303872), (5, 0.06450815), (6, 0.01110023), (11, 0.010223824), (13, 0.13695805), (16, 0.026169335), (18, 0.13664113)]"
34571,34572.0,2023-10-23 16:01:19,3,355,"<p>Suppose I have a quantum circuit defined in pytket, qiskit or some other quantum SDK.</p>
<p>How do I compile my circuit to be in the native gateset of the Quantinuum trapped ion device/emulators?</p>
",How do I compile a circuit to the native gateset of Quantinuum's trapped-ion devices?,<compiling><trapped-ion><pytket>,1,0,,,"How do I compile a circuit to the native gateset of Quantinuum's trapped-ion devices? <p>Suppose I have a quantum circuit defined in pytket, qiskit or some other quantum SDK.</p>
<p>How do I compile my circuit to be in the native gateset of the Quantinuum trapped ion device/emulators?</p>
",qc,compile circuit native gateset quantinuum devices p suppose quantum circuit defined pytket qiskit quantum p compile circuit native gateset quantinuum trapped ion,"[(4, 0.13994817), (9, 0.12108494), (13, 0.10873462), (14, 0.58501494), (16, 0.038455307)]"
34687,,2023-11-02 09:50:51,1,29,"<p>To evaluate <span class=""math-container"">$Tr[M\rho]$</span> with <span class=""math-container"">$M$</span> and <span class=""math-container"">$\rho$</span> a tensor product of Pauli operators and a density matrix, respectively, we just need to prepare the state <span class=""math-container"">$\rho$</span> and then measure it in the <span class=""math-container"">$M$</span>-eigenbasis.</p>
<p>Then how to evaluate <span class=""math-container"">$Tr[\rho_1\rho_2]$</span> on NISQ devices? I considered using the SWAP test and it works, but it requires controlled-SWAP operations, which is not achievable on NISQ devices, where only two-qubit gates between couped-qubits can be applied.</p>
",how to measure $Tr[M\rho_1N\rho_2]$ on NISQ devices?,<quantum-algorithms>,0,3,,,"how to measure $Tr[M\rho_1N\rho_2]$ on NISQ devices? <p>To evaluate <span class=""math-container"">$Tr[M\rho]$</span> with <span class=""math-container"">$M$</span> and <span class=""math-container"">$\rho$</span> a tensor product of Pauli operators and a density matrix, respectively, we just need to prepare the state <span class=""math-container"">$\rho$</span> and then measure it in the <span class=""math-container"">$M$</span>-eigenbasis.</p>
<p>Then how to evaluate <span class=""math-container"">$Tr[\rho_1\rho_2]$</span> on NISQ devices? I considered using the SWAP test and it works, but it requires controlled-SWAP operations, which is not achievable on NISQ devices, where only two-qubit gates between couped-qubits can be applied.</p>
",qc,measure tr nisq devices p evaluate span tr span span tensor product pauli operators density matrix respectively need prepare state span measure span p evaluate span tr nisq devices considered using swap test works requires operations achievable nisq devices gates,"[(3, 0.42357376), (8, 0.19900797), (9, 0.100359134), (11, 0.061493784), (16, 0.055295616), (18, 0.15678607)]"
34703,35043.0,2023-11-03 15:22:38,1,77,"<p>I see that there is a way to access historical IBM backend properties such as gate errors and gate lengths (discussed <a href=""https://quantumcomputing.stackexchange.com/questions/11754/is-there-an-archive-of-ibmq-calibration-data"">here</a>). Is there any way to also get pulse-level historical calibration data for OpenPulse devices, such as calibrated pulse amplitudes (the info contained in backend.defaults())?</p>
",How to get pulse-level historical calibration data for OpenPulse devices?,<ibm-quantum-devices>,1,0,,,"How to get pulse-level historical calibration data for OpenPulse devices? <p>I see that there is a way to access historical IBM backend properties such as gate errors and gate lengths (discussed <a href=""https://quantumcomputing.stackexchange.com/questions/11754/is-there-an-archive-of-ibmq-calibration-data"">here</a>). Is there any way to also get pulse-level historical calibration data for OpenPulse devices, such as calibrated pulse amplitudes (the info contained in backend.defaults())?</p>
",qc,get historical calibration data openpulse devices p see way access historical ibm backend properties gate errors gate lengths discussed https way also get historical calibration data openpulse devices calibrated pulse amplitudes info contained,"[(4, 0.06692602), (8, 0.23020357), (14, 0.35238752), (16, 0.30566096), (19, 0.04030108)]"
34766,,2023-11-08 15:52:40,2,48,"<p>I want to understand in some detail why superconducting qubits need periodic calibration. The usual, hand wavy explanation is environmental effects that tend to vary. However, I suspect that the actual picture is more complex than that. I want to understand in particular which effects are purely external, like the earth magnetic field (in lack of a better example) and which are internal to the superconducting device. I am especially interested in those factors that are internal to the qubit itself, like manufacturing defects and physical characteristics that may change in time. A good reference on this subject would be appreciated.</p>
",Why superconducting qubits need periodic calibration?,<superconducting-quantum-computing>,0,0,,,"Why superconducting qubits need periodic calibration? <p>I want to understand in some detail why superconducting qubits need periodic calibration. The usual, hand wavy explanation is environmental effects that tend to vary. However, I suspect that the actual picture is more complex than that. I want to understand in particular which effects are purely external, like the earth magnetic field (in lack of a better example) and which are internal to the superconducting device. I am especially interested in those factors that are internal to the qubit itself, like manufacturing defects and physical characteristics that may change in time. A good reference on this subject would be appreciated.</p>
",qc,superconducting qubits need periodic calibration p want understand detail superconducting qubits need periodic calibration usual hand wavy explanation environmental effects tend vary however suspect actual picture complex want understand particular effects purely external like earth magnetic field lack better example internal superconducting device especially interested factors internal qubit like manufacturing defects physical characteristics may change time good reference subject would,"[(7, 0.026537558), (8, 0.54365075), (9, 0.2531558), (13, 0.12545787), (16, 0.04861227)]"
34773,34774.0,2023-11-09 00:40:08,3,367,"<p>I'm aware, that if you measure just a subset of a circuit, which is entangled to another subset, it'll be in a mixed state. For example, if you measure <code>q1</code> in the circuit</p>
<p><a href=""https://i.sstatic.net/Vayc9.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Vayc9.png"" alt=""enter image description here"" /></a></p>
<p>its purity will be 0.5. But, if you measure the full circuit, it's purity will be 1.</p>
<p>Is it a general fact, that the &quot;full&quot; circuit as a theoretically isolated system will be always in a pure state?</p>
",Is the full quantum circuit always in a pure state?,<quantum-state><quantum-circuit>,1,0,,,"Is the full quantum circuit always in a pure state? <p>I'm aware, that if you measure just a subset of a circuit, which is entangled to another subset, it'll be in a mixed state. For example, if you measure <code>q1</code> in the circuit</p>
<p><a href=""https://i.sstatic.net/Vayc9.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Vayc9.png"" alt=""enter image description here"" /></a></p>
<p>its purity will be 0.5. But, if you measure the full circuit, it's purity will be 1.</p>
<p>Is it a general fact, that the &quot;full&quot; circuit as a theoretically isolated system will be always in a pure state?</p>
",qc,full quantum circuit always pure state p aware measure subset circuit entangled another subset mixed state example measure code q1 circuit p https nofollow noreferrer img https enter image description p purity measure full circuit purity p general fact quot full quot circuit theoretically isolated system always pure state,"[(3, 0.2714121), (4, 0.28777307), (14, 0.18550342), (16, 0.020721685), (18, 0.18725191), (19, 0.04449008)]"
77451506,77451755.0,2023-11-09 08:21:55,1,448,"<p>I am looking to work with loops in quantum computing, but when I run my circuit I get this error: <strong>Some classical bits are not used for measurements. the number of classical bits (2), the used classical bits (set()).</strong></p>
<pre><code>qubits = QuantumRegister(1)
clbits = ClassicalRegister(1)
circuit = QuantumCircuit(qubits, clbits)
(q0,) = qubits
(c0,) = clbits
 
with circuit.for_loop(range(5)) as _:
    circuit.x(q0)
circuit.measure(q0, c0)
circuit.draw(&quot;mpl&quot;)

result = Sampler().run(circuit).result()
result.quasi_dists[0] 
# example output counts: {'1': 1024}
</code></pre>
<p><em>QiskitError: 'Some classical bits are not used for measurements. the number of classical bits (2), the used classical bits (set()).'</em></p>
","Some classical bits are not used for measurements. the number of classical bits (2), the used classical bits (set())",<quantum-computing><qiskit>,1,2,,,"Some classical bits are not used for measurements. the number of classical bits (2), the used classical bits (set()) <p>I am looking to work with loops in quantum computing, but when I run my circuit I get this error: <strong>Some classical bits are not used for measurements. the number of classical bits (2), the used classical bits (set()).</strong></p>
<pre><code>qubits = QuantumRegister(1)
clbits = ClassicalRegister(1)
circuit = QuantumCircuit(qubits, clbits)
(q0,) = qubits
(c0,) = clbits
 
with circuit.for_loop(range(5)) as _:
    circuit.x(q0)
circuit.measure(q0, c0)
circuit.draw(&quot;mpl&quot;)

result = Sampler().run(circuit).result()
result.quasi_dists[0] 
# example output counts: {'1': 1024}
</code></pre>
<p><em>QiskitError: 'Some classical bits are not used for measurements. the number of classical bits (2), the used classical bits (set()).'</em></p>
",so_new,classical bits used measurements number classical bits 2 used classical bits set p looking work loops quantum computing run circuit get error strong classical bits used measurements number classical bits 2 used classical bits set pre code qubits quantumregister 1 clbits classicalregister 1 circuit quantumcircuit qubits clbits q0 qubits c0 clbits range 5 q0 q0 c0 quot mpl quot result sampler circuit 0 example output counts 1 1024 p em qiskiterror classical bits used measurements number classical bits 2 used classical bits set,"[(0, 0.13617298), (1, 0.2684408), (2, 0.08580156), (14, 0.43809462), (16, 0.03688525), (19, 0.032921806)]"
34894,,2023-11-17 15:33:07,4,116,"<p>I am interested in the spectrum of unital quantum channels <span class=""math-container"">$\Phi$</span> (which act on finite dimensional spaces). The literature is extremely vast on such objects so I hope some experts can point me along the right direction or references.</p>
<p>I know that the spectrum (i.e. eigenvalues <span class=""math-container"">$\lambda$</span> appearing in the eigenvalue-eigenvector equation <span class=""math-container"">$\Phi(X) = \lambda X$</span> ) lies within the unit disk <span class=""math-container"">$|\lambda|\leq 1$</span>.  Because of unitality <span class=""math-container"">$\mathbb{I}$</span> is always an eigenvector with eigenvalue <span class=""math-container"">$1$</span> because <span class=""math-container"">$\Phi(\mathbb{I}) = \mathbb{I}$</span>. There may be other eigenvectors that lie on the unit disk <span class=""math-container"">$|\lambda| = 1$</span> (called `peripheral eigenvectors/eigenvalues').</p>
<p>My question is what is known about the size of the <strong>gap</strong> of unital quantum channels, defined as <span class=""math-container"">$1 - |\lambda|$</span> such that <span class=""math-container"">$\lambda$</span> is the eigenvalue with largest magnitude that is not <span class=""math-container"">$1$</span>? The physical reason why I am interested in because this sets the rate of convergence to the peripheral eigenvectors.</p>
<p>Perhaps what I am asking is too general, and it depends on the explicit quantum channel in question? In which case my question would then be, is there a way to estimate the magnitude of the gap? Like a variational principle of sorts?</p>
",What is known about the size of the spectral gap of unital quantum channels?,<linear-algebra><quantum-operation>,1,3,,,"What is known about the size of the spectral gap of unital quantum channels? <p>I am interested in the spectrum of unital quantum channels <span class=""math-container"">$\Phi$</span> (which act on finite dimensional spaces). The literature is extremely vast on such objects so I hope some experts can point me along the right direction or references.</p>
<p>I know that the spectrum (i.e. eigenvalues <span class=""math-container"">$\lambda$</span> appearing in the eigenvalue-eigenvector equation <span class=""math-container"">$\Phi(X) = \lambda X$</span> ) lies within the unit disk <span class=""math-container"">$|\lambda|\leq 1$</span>.  Because of unitality <span class=""math-container"">$\mathbb{I}$</span> is always an eigenvector with eigenvalue <span class=""math-container"">$1$</span> because <span class=""math-container"">$\Phi(\mathbb{I}) = \mathbb{I}$</span>. There may be other eigenvectors that lie on the unit disk <span class=""math-container"">$|\lambda| = 1$</span> (called `peripheral eigenvectors/eigenvalues').</p>
<p>My question is what is known about the size of the <strong>gap</strong> of unital quantum channels, defined as <span class=""math-container"">$1 - |\lambda|$</span> such that <span class=""math-container"">$\lambda$</span> is the eigenvalue with largest magnitude that is not <span class=""math-container"">$1$</span>? The physical reason why I am interested in because this sets the rate of convergence to the peripheral eigenvectors.</p>
<p>Perhaps what I am asking is too general, and it depends on the explicit quantum channel in question? In which case my question would then be, is there a way to estimate the magnitude of the gap? Like a variational principle of sorts?</p>
",qc,known size spectral gap unital quantum channels p interested spectrum unital quantum channels span act finite dimensional spaces literature extremely vast objects hope experts point along right direction p know spectrum eigenvalues span appearing equation span x x lies within unit disk span 1 unitality span always eigenvector eigenvalue span 1 span may eigenvectors lie unit disk span 1 called peripheral p question known size strong gap unital quantum channels defined span 1 span eigenvalue largest magnitude span 1 physical reason interested sets rate convergence peripheral p perhaps asking general depends explicit quantum channel question case question would way estimate magnitude gap like variational principle sorts,"[(0, 0.021818964), (1, 0.020225497), (3, 0.573269), (5, 0.010656217), (7, 0.09892585), (8, 0.13546698), (9, 0.10458784), (10, 0.020420028), (16, 0.0135914525)]"
34896,34900.0,2023-11-17 17:33:23,2,683,"<p>I am trying to run a dynamic circuit by having mid-measurement in my code as follows:</p>
<pre><code>from qiskit import *
from math import *
from qiskit.providers.fake_provider import FakeJakarta

backend = FakeJakarta()

q0 = QuantumRegister(1)
q1 = QuantumRegister(1)
c  = ClassicalRegister(2)
qc = QuantumCircuit(q0, q1, c)
result_ = []
for i in range(2):
    qc.ry(2*pi/3, q0)
    qc.cx(q0, q1)
    qc.h(q1)
    qc.measure(q1, c[i])
    with qc.if_test((c[i], 0)) as _else:
        result_.append(0)
    with _else:
        result_.append(1)
job = backend.run(qc)
print(result_)
</code></pre>
<p>As it is obvious we must have a result like [0, 1, 0]. However, the list that I receive always is [0, 1, 0, 1]. Does anyone know how to solve this matter?</p>
",If_test() - Dynamic Circuits in qiskit,<qiskit><quantum-gate><programming>,1,4,,,"If_test() - Dynamic Circuits in qiskit <p>I am trying to run a dynamic circuit by having mid-measurement in my code as follows:</p>
<pre><code>from qiskit import *
from math import *
from qiskit.providers.fake_provider import FakeJakarta

backend = FakeJakarta()

q0 = QuantumRegister(1)
q1 = QuantumRegister(1)
c  = ClassicalRegister(2)
qc = QuantumCircuit(q0, q1, c)
result_ = []
for i in range(2):
    qc.ry(2*pi/3, q0)
    qc.cx(q0, q1)
    qc.h(q1)
    qc.measure(q1, c[i])
    with qc.if_test((c[i], 0)) as _else:
        result_.append(0)
    with _else:
        result_.append(1)
job = backend.run(qc)
print(result_)
</code></pre>
<p>As it is obvious we must have a result like [0, 1, 0]. However, the list that I receive always is [0, 1, 0, 1]. Does anyone know how to solve this matter?</p>
",qc,dynamic circuits qiskit p trying run dynamic circuit code follows pre code qiskit import math import import fakejakarta backend fakejakarta q0 quantumregister 1 q1 quantumregister 1 c classicalregister 2 qc quantumcircuit q0 q1 c range 2 2 q0 q0 q1 q1 q1 c c 0 0 1 job qc print p obvious must result like 0 1 0 however list receive always 0 1 0 1 anyone know solve matter,"[(0, 0.37146646), (2, 0.27393267), (14, 0.21708392), (16, 0.13517044)]"
34937,34944.0,2023-11-21 05:37:53,5,144,"<p>I am working on the following problem from the book &quot;Quantum Computation and Quantum Information&quot; by Nielsen and Chuang.</p>
<blockquote>
<p>Problem 9.2: Let <span class=""math-container"">$\mathcal{E}$</span> be a trace-preserving quantum
operation. Show that for each <span class=""math-container"">$\rho$</span> there is a set of operation
elements <span class=""math-container"">$\{E_i\}$</span> for <span class=""math-container"">$\mathcal{E}$</span> such that
<span class=""math-container"">$$F(ρ, \mathcal{E}) = |\operatorname{tr}(\rho E_1)|^2 .\tag{1}$$</span></p>
</blockquote>
<p>Some background:</p>
<p>The <span class=""math-container"">$F(\rho,\mathcal{E})$</span> here is the <strong>entanglement fidelity</strong>. In addition, for quantum operation <span class=""math-container"">$\mathcal{E}$</span> such that <span class=""math-container"">$\mathcal{E}(\rho)=\sum_kE_k\rho E_k^{\dagger}$</span>, we have <span class=""math-container"">$F(\rho,\mathcal{E})=\sum_k|\operatorname{tr}(\rho E_k)|^2$</span>.</p>
<hr />
<p>My attempt:</p>
<p>Given <span class=""math-container"">$\rho$</span> and a set of operation elements <span class=""math-container"">$\{E_k\}_{k=1}^K$</span> for a trace-preserving quantum operation <span class=""math-container"">$\mathcal{E}$</span>, I'd like to find another set of operation elements <span class=""math-container"">$\{F_j\}$</span> such that</p>
<p><span class=""math-container"">$$
F(ρ, \mathcal{E}) =\sum_k|\operatorname{tr}(\rho E_k)|^2= |\operatorname{tr}(\rho F_1)|^2 \tag{2}.
$$</span></p>
<p>In particular, I consider <span class=""math-container"">$\{E_k\}$</span> such that <span class=""math-container"">$\operatorname{tr}(E_k^{\dagger}E_l)\propto\delta_{kl}$</span>. (As the entanglement fidelity is independent of the choice of <span class=""math-container"">$\{E_k\}$</span> and such <span class=""math-container"">$\{E_k\}$</span> can always be found).</p>
<p>I then tried with <span class=""math-container"">$F_1=\sum_kE_k/\operatorname{tr}(\rho E_k)\cdot\sqrt{F(\rho,\mathcal{E})}/K$</span>, which gives me the desired property <span class=""math-container"">$(2)$</span>. But then I find it hard to come up with the remaining <span class=""math-container"">$F_j$</span>s so that it forms a set of operation elements for <span class=""math-container"">$\mathcal{E}$</span>.</p>
<p>I have also checked various solutions to this book, but none solve this problem. Much appreciate any hints or suggestions.</p>
",Question about Nielson & Chuang Problem 9.2,<textbook-and-exercises><quantum-operation><nielsen-and-chuang>,1,0,,,"Question about Nielson & Chuang Problem 9.2 <p>I am working on the following problem from the book &quot;Quantum Computation and Quantum Information&quot; by Nielsen and Chuang.</p>
<blockquote>
<p>Problem 9.2: Let <span class=""math-container"">$\mathcal{E}$</span> be a trace-preserving quantum
operation. Show that for each <span class=""math-container"">$\rho$</span> there is a set of operation
elements <span class=""math-container"">$\{E_i\}$</span> for <span class=""math-container"">$\mathcal{E}$</span> such that
<span class=""math-container"">$$F(ρ, \mathcal{E}) = |\operatorname{tr}(\rho E_1)|^2 .\tag{1}$$</span></p>
</blockquote>
<p>Some background:</p>
<p>The <span class=""math-container"">$F(\rho,\mathcal{E})$</span> here is the <strong>entanglement fidelity</strong>. In addition, for quantum operation <span class=""math-container"">$\mathcal{E}$</span> such that <span class=""math-container"">$\mathcal{E}(\rho)=\sum_kE_k\rho E_k^{\dagger}$</span>, we have <span class=""math-container"">$F(\rho,\mathcal{E})=\sum_k|\operatorname{tr}(\rho E_k)|^2$</span>.</p>
<hr />
<p>My attempt:</p>
<p>Given <span class=""math-container"">$\rho$</span> and a set of operation elements <span class=""math-container"">$\{E_k\}_{k=1}^K$</span> for a trace-preserving quantum operation <span class=""math-container"">$\mathcal{E}$</span>, I'd like to find another set of operation elements <span class=""math-container"">$\{F_j\}$</span> such that</p>
<p><span class=""math-container"">$$
F(ρ, \mathcal{E}) =\sum_k|\operatorname{tr}(\rho E_k)|^2= |\operatorname{tr}(\rho F_1)|^2 \tag{2}.
$$</span></p>
<p>In particular, I consider <span class=""math-container"">$\{E_k\}$</span> such that <span class=""math-container"">$\operatorname{tr}(E_k^{\dagger}E_l)\propto\delta_{kl}$</span>. (As the entanglement fidelity is independent of the choice of <span class=""math-container"">$\{E_k\}$</span> and such <span class=""math-container"">$\{E_k\}$</span> can always be found).</p>
<p>I then tried with <span class=""math-container"">$F_1=\sum_kE_k/\operatorname{tr}(\rho E_k)\cdot\sqrt{F(\rho,\mathcal{E})}/K$</span>, which gives me the desired property <span class=""math-container"">$(2)$</span>. But then I find it hard to come up with the remaining <span class=""math-container"">$F_j$</span>s so that it forms a set of operation elements for <span class=""math-container"">$\mathcal{E}$</span>.</p>
<p>I have also checked various solutions to this book, but none solve this problem. Much appreciate any hints or suggestions.</p>
",qc,question nielson chuang problem p working following problem book quot quantum computation quantum information quot nielsen blockquote p problem let span e quantum operation show span set operation elements span span e span f ρ e tr 1 p background p span f e strong entanglement fidelity addition quantum operation span e span e span f e tr hr p attempt p given span set operation elements span quantum operation span e like find another set operation elements span p span f ρ e tr tr 2 p particular consider span span tr kl entanglement fidelity independent choice span span always found p tried span tr f e gives desired property span 2 find hard come remaining span forms set operation elements span e p also checked various solutions book none solve problem much appreciate hints,"[(1, 0.08289972), (3, 0.7979313), (9, 0.0334969), (10, 0.045298047), (16, 0.022410596), (19, 0.016935177)]"
34998,34999.0,2023-11-27 03:44:16,0,68,"<p>I am trying to study the effect of dynamical decoupling sequences (Hahn Echo and CPMG) using qiskit's <code>qasm_simulator</code> with an added noise model from <code>ibm_lagos</code>. While debugging, I realised that I needed the resonant frequency of the qubit to choose the delay times between the rotation gates. Following instructions from here: <a href=""https://qiskit.org/documentation/tutorials/circuits_advanced/08_gathering_system_information.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/circuits_advanced/08_gathering_system_information.html</a>, the resonant frequency is <span class=""math-container"">$5.23$</span> GHz. For sanity check, I ran the following circuit:<a href=""https://i.sstatic.net/cqQen.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cqQen.png"" alt=""The delay correcponds to 1/resonant frequency"" /></a>.</p>
<p>The delay corresponds to a time of 1/resonant frequency or a rotation of <span class=""math-container"">$\pi$</span> in the Bloch sphere. I expect to get measure the state <span class=""math-container"">$|1\rangle$</span> with unit probability. Instead, I get the state <span class=""math-container"">$|0\rangle$</span> with unit probability.</p>
<p>Does this implies that the qubit has no resonant frequency owing to the backend being a simulator? If yes, how do I model the system correctly? Or am I missing something?</p>
",Frequency of qubits in qiskit simulators,<qiskit><quantum-gate><ibm-q-experience>,1,0,,,"Frequency of qubits in qiskit simulators <p>I am trying to study the effect of dynamical decoupling sequences (Hahn Echo and CPMG) using qiskit's <code>qasm_simulator</code> with an added noise model from <code>ibm_lagos</code>. While debugging, I realised that I needed the resonant frequency of the qubit to choose the delay times between the rotation gates. Following instructions from here: <a href=""https://qiskit.org/documentation/tutorials/circuits_advanced/08_gathering_system_information.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/tutorials/circuits_advanced/08_gathering_system_information.html</a>, the resonant frequency is <span class=""math-container"">$5.23$</span> GHz. For sanity check, I ran the following circuit:<a href=""https://i.sstatic.net/cqQen.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cqQen.png"" alt=""The delay correcponds to 1/resonant frequency"" /></a>.</p>
<p>The delay corresponds to a time of 1/resonant frequency or a rotation of <span class=""math-container"">$\pi$</span> in the Bloch sphere. I expect to get measure the state <span class=""math-container"">$|1\rangle$</span> with unit probability. Instead, I get the state <span class=""math-container"">$|0\rangle$</span> with unit probability.</p>
<p>Does this implies that the qubit has no resonant frequency owing to the backend being a simulator? If yes, how do I model the system correctly? Or am I missing something?</p>
",qc,frequency qubits qiskit simulators p trying study effect dynamical decoupling sequences hahn echo cpmg using qiskit code added noise model code debugging realised needed resonant frequency qubit choose delay times rotation gates following instructions https nofollow noreferrer https resonant frequency span ghz sanity check ran following circuit https nofollow noreferrer img https delay correcponds frequency p delay corresponds time frequency rotation span bloch sphere expect get measure state span unit probability instead get state span unit p implies qubit resonant frequency owing backend simulator yes model system correctly missing something,"[(4, 0.13167447), (9, 0.36348283), (14, 0.37889162), (16, 0.02167066), (18, 0.102539524)]"
35030,,2023-11-29 12:42:21,2,122,"<p>Let's assume I want to implement a rotation <span class=""math-container"">$R_Z(\theta)$</span> for a lattice-surgery based computation, for <span class=""math-container"">$\theta$</span> being an arbitrary angle (i.e. the gate is not necessarily Clifford nor a <span class=""math-container"">$T$</span>-gate).</p>
<p>It can typically be done by</p>
<ol>
<li>Decomposing <span class=""math-container"">$R_Z(\theta)$</span> on Clifford+T gateset (possible up to some approximation <span class=""math-container"">$\epsilon$</span>). I call <span class=""math-container"">$N_T$</span> the number of <span class=""math-container"">$T$</span>-gates in the decomposition.</li>
<li>The Clifford are &quot;commuted&quot; toward the end of the algorithm (we do the measurement based lattice surgery framework), which changes each of the <span class=""math-container"">$T$</span>-gate in <span class=""math-container"">$\exp(-i P \pi/8)$</span> for some single-qubit Pauli <span class=""math-container"">$P$</span> (not anymore necessarily <span class=""math-container"">$Z$</span>).</li>
</ol>
<p>Hence, the duration of one <span class=""math-container"">$R_Z(\theta)$</span> should from my understanding be equal to <span class=""math-container"">$N_T$</span> logical timesteps. If we have many <span class=""math-container"">$R_Z(\theta)$</span> gates, the total duration of these gates should be <span class=""math-container"">$N_T \times D_R$</span> where <span class=""math-container"">$D_R$</span> is the depth associated to these gates (the number of layers containing at least one gate <span class=""math-container"">$R_Z(\theta)$</span>).</p>
<p>However, while reading <a href=""https://arxiv.org/pdf/2211.07629.pdf"" rel=""nofollow noreferrer"">this paper</a> (which explains the assumptions behind the Azure resource estimator), assuming no <span class=""math-container"">$T$</span>-gates nor Toffoli nor measurements are in the end-user algorithm, they would find a total number of logical timestep, based on Eq (D3) on page 30:</p>
<p><span class=""math-container"">$$C_{\min}=M_R+N_T \times D_R$$</span></p>
<p>What I call <span class=""math-container"">$N_T$</span> correspond to their <span class=""math-container"">$A \log_2(M_R/\epsilon)+B$</span> in their notation.</p>
<p>Basically, they add on my counting <span class=""math-container"">$M_R$</span> which is the total number of <span class=""math-container"">$R_Z(\theta)$</span> gates. <strong>Why should it be added? Isn't the term <span class=""math-container"">$N_T \times D_R$</span> sufficient?</strong></p>
<hr />
<p>[Edit]: Below is a concrete example showing why for me <span class=""math-container"">$C_{\min}=N_T \times D_R$</span> should be the formula (without <span class=""math-container"">$M_R$</span>):</p>
<p>Left: two logical qubits are shown, on each of them I implement a <span class=""math-container"">$R_Z$</span> (of an angle that is not Clifford, and neither the one of a <span class=""math-container"">$T$</span>-gate (i.e. not <span class=""math-container"">$\pi/4$</span>).</p>
<p>Middle: this rotation is decomposed on Clifford+T gateset (the gates with label &quot;C&quot; represent single qubit Clifford).</p>
<p>Right: The Clifford are commuted through the <span class=""math-container"">$T$</span>-gates. It results a circuit with only &quot;generalized&quot; <span class=""math-container"">$T$</span>-gates (i.e. the rotation angle are <span class=""math-container"">$\pi/4$</span> but not necessarily around the <span class=""math-container"">$Z$</span> axis for the <span class=""math-container"">$T_i$</span>).</p>
<p>In this example the circuit depth would be <span class=""math-container"">$N_T \times D_R$</span>: I don't get why we should add <span class=""math-container"">$M_R$</span> on top.</p>
<p><a href=""https://i.sstatic.net/CM58f.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CM58f.png"" alt=""enter image description here"" /></a></p>
<p>The ancilla doing state injection are not represented in this image, but they would not change the number of logical timesteps (as doing one of the <span class=""math-container"">$T$</span>-gate is essentially measuring a multi-Pauli observable which is done in a single timestep).</p>
",Number of logical cycles to implement $R_Z(\theta)$ gates in lattice surgery: why isn't it the number of layers $\times$ the $T$-count in $R_Z$?,<surface-code><azure-quantum><lattice-surgery>,1,0,,,"Number of logical cycles to implement $R_Z(\theta)$ gates in lattice surgery: why isn't it the number of layers $\times$ the $T$-count in $R_Z$? <p>Let's assume I want to implement a rotation <span class=""math-container"">$R_Z(\theta)$</span> for a lattice-surgery based computation, for <span class=""math-container"">$\theta$</span> being an arbitrary angle (i.e. the gate is not necessarily Clifford nor a <span class=""math-container"">$T$</span>-gate).</p>
<p>It can typically be done by</p>
<ol>
<li>Decomposing <span class=""math-container"">$R_Z(\theta)$</span> on Clifford+T gateset (possible up to some approximation <span class=""math-container"">$\epsilon$</span>). I call <span class=""math-container"">$N_T$</span> the number of <span class=""math-container"">$T$</span>-gates in the decomposition.</li>
<li>The Clifford are &quot;commuted&quot; toward the end of the algorithm (we do the measurement based lattice surgery framework), which changes each of the <span class=""math-container"">$T$</span>-gate in <span class=""math-container"">$\exp(-i P \pi/8)$</span> for some single-qubit Pauli <span class=""math-container"">$P$</span> (not anymore necessarily <span class=""math-container"">$Z$</span>).</li>
</ol>
<p>Hence, the duration of one <span class=""math-container"">$R_Z(\theta)$</span> should from my understanding be equal to <span class=""math-container"">$N_T$</span> logical timesteps. If we have many <span class=""math-container"">$R_Z(\theta)$</span> gates, the total duration of these gates should be <span class=""math-container"">$N_T \times D_R$</span> where <span class=""math-container"">$D_R$</span> is the depth associated to these gates (the number of layers containing at least one gate <span class=""math-container"">$R_Z(\theta)$</span>).</p>
<p>However, while reading <a href=""https://arxiv.org/pdf/2211.07629.pdf"" rel=""nofollow noreferrer"">this paper</a> (which explains the assumptions behind the Azure resource estimator), assuming no <span class=""math-container"">$T$</span>-gates nor Toffoli nor measurements are in the end-user algorithm, they would find a total number of logical timestep, based on Eq (D3) on page 30:</p>
<p><span class=""math-container"">$$C_{\min}=M_R+N_T \times D_R$$</span></p>
<p>What I call <span class=""math-container"">$N_T$</span> correspond to their <span class=""math-container"">$A \log_2(M_R/\epsilon)+B$</span> in their notation.</p>
<p>Basically, they add on my counting <span class=""math-container"">$M_R$</span> which is the total number of <span class=""math-container"">$R_Z(\theta)$</span> gates. <strong>Why should it be added? Isn't the term <span class=""math-container"">$N_T \times D_R$</span> sufficient?</strong></p>
<hr />
<p>[Edit]: Below is a concrete example showing why for me <span class=""math-container"">$C_{\min}=N_T \times D_R$</span> should be the formula (without <span class=""math-container"">$M_R$</span>):</p>
<p>Left: two logical qubits are shown, on each of them I implement a <span class=""math-container"">$R_Z$</span> (of an angle that is not Clifford, and neither the one of a <span class=""math-container"">$T$</span>-gate (i.e. not <span class=""math-container"">$\pi/4$</span>).</p>
<p>Middle: this rotation is decomposed on Clifford+T gateset (the gates with label &quot;C&quot; represent single qubit Clifford).</p>
<p>Right: The Clifford are commuted through the <span class=""math-container"">$T$</span>-gates. It results a circuit with only &quot;generalized&quot; <span class=""math-container"">$T$</span>-gates (i.e. the rotation angle are <span class=""math-container"">$\pi/4$</span> but not necessarily around the <span class=""math-container"">$Z$</span> axis for the <span class=""math-container"">$T_i$</span>).</p>
<p>In this example the circuit depth would be <span class=""math-container"">$N_T \times D_R$</span>: I don't get why we should add <span class=""math-container"">$M_R$</span> on top.</p>
<p><a href=""https://i.sstatic.net/CM58f.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CM58f.png"" alt=""enter image description here"" /></a></p>
<p>The ancilla doing state injection are not represented in this image, but they would not change the number of logical timesteps (as doing one of the <span class=""math-container"">$T$</span>-gate is essentially measuring a multi-Pauli observable which is done in a single timestep).</p>
",qc,number logical cycles implement gates lattice surgery number layers p let assume want implement rotation span based computation span arbitrary angle gate necessarily clifford span p typically done ol li decomposing span gateset possible approximation span call span number span li clifford quot commuted quot toward end algorithm measurement based lattice surgery framework changes span span p pauli span p anymore necessarily span z p hence duration one span understanding equal span logical timesteps many span gates total duration gates span span depth associated gates number layers containing least one gate span p however reading https nofollow noreferrer paper explains assumptions behind azure resource estimator assuming span toffoli measurements algorithm would find total number logical timestep based eq d3 page 30 p span p call span correspond span p basically add counting span total number span gates strong added term span sufficient hr p edit concrete example showing span formula without span p left two logical qubits shown implement span angle clifford neither one span span p middle rotation decomposed gateset gates label quot c quot represent single qubit clifford p right clifford commuted span results circuit quot generalized quot span rotation angle span necessarily around span z axis span p example circuit depth would span get add span p https nofollow noreferrer img https enter image description p ancilla state injection represented image would change number logical timesteps one span essentially measuring observable done single timestep,"[(3, 0.35101825), (4, 0.06535368), (5, 0.058018707), (7, 0.04463938), (8, 0.048503343), (9, 0.3062141), (14, 0.071484864), (16, 0.017618507), (19, 0.03668492)]"
35092,35095.0,2023-12-04 22:58:34,0,119,"<p>I have an exercise in QEC, where I have given a hexagonal lattice with periodic boundary conditions (wrapped around a torus), with a qubit at each vertex. I have also given the Stabilizer generators <span class=""math-container"">$X \otimes Y \otimes Z \otimes X \otimes Y \otimes Z$</span> and <span class=""math-container"">$Z \otimes Z$</span> on the vertical lines of the hexagon. So how is it possible to deduce the logical operator <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> on both logical qubits. Or a in a more general way, how can I find by a given lattice and stabilizer generators the logical operations?</p>
<p>In the lecture we have just looked at some QEC like the surface Code (and a version of the surface Code where it is wrapped around the torus) and we have put some lines through the lattice and named it the logical X and Z. If I understood it right we used some stabilizers to change some of the code-qubit values such that it represents the same logical value in the logical qubits. So how can I use this Information to create the logical X and Z operation?</p>
",Quantum Error Correction on a hexagonal lattice,<error-correction><surface-code>,1,0,,,"Quantum Error Correction on a hexagonal lattice <p>I have an exercise in QEC, where I have given a hexagonal lattice with periodic boundary conditions (wrapped around a torus), with a qubit at each vertex. I have also given the Stabilizer generators <span class=""math-container"">$X \otimes Y \otimes Z \otimes X \otimes Y \otimes Z$</span> and <span class=""math-container"">$Z \otimes Z$</span> on the vertical lines of the hexagon. So how is it possible to deduce the logical operator <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> on both logical qubits. Or a in a more general way, how can I find by a given lattice and stabilizer generators the logical operations?</p>
<p>In the lecture we have just looked at some QEC like the surface Code (and a version of the surface Code where it is wrapped around the torus) and we have put some lines through the lattice and named it the logical X and Z. If I understood it right we used some stabilizers to change some of the code-qubit values such that it represents the same logical value in the logical qubits. So how can I use this Information to create the logical X and Z operation?</p>
",qc,quantum error correction hexagonal lattice p exercise qec given hexagonal lattice periodic boundary conditions wrapped around torus qubit vertex also given stabilizer generators span x z x z span z z vertical lines hexagon possible deduce logical operator span x span z logical qubits general way find given lattice stabilizer generators logical operations p lecture looked qec like surface code version surface code wrapped around torus put lines lattice named logical x understood right used stabilizers change values represents logical value logical qubits use information create logical x z operation,"[(3, 0.1541958), (5, 0.41903675), (9, 0.039968163), (10, 0.0679471), (13, 0.10605539), (15, 0.042194247), (16, 0.050985392), (17, 0.025396211), (18, 0.092998244)]"
35100,,2023-12-05 22:26:38,0,57,"<h1>Edit</h1>
<p>I tried using python multiprocessing library. The result with 8 cores isn't always faster than the original script that uses only one core. How can i improve the algorithm?</p>
<hr />
<p>Suppose i've a matrix of <span class=""math-container"">$n \times n$</span> quantum circuits, and each circuit has <span class=""math-container"">$k$</span> parameters. I want to calculate the expectation value for a given operator <span class=""math-container"">$\hat{O}$</span> for all circuits. For example the following code (<strong>old</strong>):</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

from qiskit              import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives   import Estimator


n = 10
estimator   = Estimator()
matrix_circ = np.zeros((n,n),dtype=QuantumCircuit)
# a random operator 
operator    =  SparsePauliOp(['II', 'XZ'],coeffs=[1.0, 0.5])

#define matrix of circuits. Each circuit has k parameters
for i in range(n):
    for j in range(n):
        matrix_circ[i,j] = # ... a circuit with k parameters

parameters = np.random.random(len(matrix[0,0].parameters))

matrix_values = np.zeros((n,n))
for i in range(n):
    for j in range(n):
        job = estimator.run( matrix_circ[i,j] ,  operator , parameters)
        estimator_result   = job.result()
        values             = estimator_result.values
        matrix_values[i,j] = values[0]

</code></pre>
<p><strong>New code</strong>:</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

from qiskit              import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives   import Estimator

import multiprocessing as mp

n = 10
estimator   = Estimator()
matrix_circ = np.zeros((n,n),dtype=QuantumCircuit)
# a random operator 
operator    =  SparsePauliOp(['II', 'XZ'],coeffs=[1.0, 0.5])

#define matrix of circuits. Each circuit has k parameters
for i in range(n):
    for j in range(n):
        matrix_circ[i,j] = # ... a circuit with k parameters

parameters = np.random.random(len(matrix[0,0].parameters))

def exp_val(i , j , operator , estimator , parameters):
        job = estimator.run( matrix_circ[i,j] ,  operator , parameters)
        estimator_result   = job.result()
        values             = estimator_result.values
        result = values[0]
        return result

elements = []
for i in range(n):
    for j in range(n):   
        elements.append([i , j , operator , estimator , parameters])
processes = 8
pool = mp.Pool(processes=processes)
r = pool.starmap(exp_val, elements)

matrix_values = np.zeros((n,n))
for i in range(n):
    for j in range(n):
        matrix_values[i,j] = r[j + i * n]




</code></pre>
<p>Since the parameters are fixed before the for-loop, it doesn't need to be sequential. Is it possible to parallelize the for-loop?</p>
",Parallelize estimation of expectation values in Qiskit,<qiskit><quantum-circuit><optimization>,0,0,,,"Parallelize estimation of expectation values in Qiskit <h1>Edit</h1>
<p>I tried using python multiprocessing library. The result with 8 cores isn't always faster than the original script that uses only one core. How can i improve the algorithm?</p>
<hr />
<p>Suppose i've a matrix of <span class=""math-container"">$n \times n$</span> quantum circuits, and each circuit has <span class=""math-container"">$k$</span> parameters. I want to calculate the expectation value for a given operator <span class=""math-container"">$\hat{O}$</span> for all circuits. For example the following code (<strong>old</strong>):</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

from qiskit              import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives   import Estimator


n = 10
estimator   = Estimator()
matrix_circ = np.zeros((n,n),dtype=QuantumCircuit)
# a random operator 
operator    =  SparsePauliOp(['II', 'XZ'],coeffs=[1.0, 0.5])

#define matrix of circuits. Each circuit has k parameters
for i in range(n):
    for j in range(n):
        matrix_circ[i,j] = # ... a circuit with k parameters

parameters = np.random.random(len(matrix[0,0].parameters))

matrix_values = np.zeros((n,n))
for i in range(n):
    for j in range(n):
        job = estimator.run( matrix_circ[i,j] ,  operator , parameters)
        estimator_result   = job.result()
        values             = estimator_result.values
        matrix_values[i,j] = values[0]

</code></pre>
<p><strong>New code</strong>:</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

from qiskit              import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives   import Estimator

import multiprocessing as mp

n = 10
estimator   = Estimator()
matrix_circ = np.zeros((n,n),dtype=QuantumCircuit)
# a random operator 
operator    =  SparsePauliOp(['II', 'XZ'],coeffs=[1.0, 0.5])

#define matrix of circuits. Each circuit has k parameters
for i in range(n):
    for j in range(n):
        matrix_circ[i,j] = # ... a circuit with k parameters

parameters = np.random.random(len(matrix[0,0].parameters))

def exp_val(i , j , operator , estimator , parameters):
        job = estimator.run( matrix_circ[i,j] ,  operator , parameters)
        estimator_result   = job.result()
        values             = estimator_result.values
        result = values[0]
        return result

elements = []
for i in range(n):
    for j in range(n):   
        elements.append([i , j , operator , estimator , parameters])
processes = 8
pool = mp.Pool(processes=processes)
r = pool.starmap(exp_val, elements)

matrix_values = np.zeros((n,n))
for i in range(n):
    for j in range(n):
        matrix_values[i,j] = r[j + i * n]




</code></pre>
<p>Since the parameters are fixed before the for-loop, it doesn't need to be sequential. Is it possible to parallelize the for-loop?</p>
",qc,parallelize estimation expectation values qiskit h1 edit p tried using python multiprocessing library result 8 cores always faster original script uses one core improve algorithm hr p suppose matrix span n n quantum circuits circuit span k parameters want calculate expectation value given operator span circuits example following code strong old pre code import numpy np qiskit import quantumcircuit import sparsepauliop import estimator n 10 estimator estimator n n random operator operator sparsepauliop define matrix circuits circuit k parameters range n j range n j circuit k parameters parameters len matrix n n range n j range n job j operator parameters values j values 0 p strong new code pre code import numpy np qiskit import quantumcircuit import sparsepauliop import estimator import multiprocessing mp n 10 estimator estimator n n random operator operator sparsepauliop define matrix circuits circuit k parameters range n j range n j circuit k parameters parameters len matrix def j operator estimator parameters job j operator parameters values result values 0 return result elements range n j range n j operator estimator parameters processes 8 pool r elements n n range n j range n j r j n p since parameters fixed need sequential possible parallelize,"[(0, 0.6796711), (3, 0.16355066), (8, 0.074363254), (11, 0.025233395), (14, 0.046343468), (16, 0.01013854)]"
35106,35134.0,2023-12-06 09:05:27,2,100,"<p>The probability of measurement is the square of amplitude.
After measurement, how to guess the original amplitude of state??</p>
<p>For example, in linear problem, we would like to know the exact solution, which has both of the positive and negative values.</p>
<p>In case of one qubit, the negative amplitude may be decided by estimating relative phase.</p>
<p>By measuring Z, X and Y basis, we can decide the <span class=""math-container"">$θ$</span> and <span class=""math-container"">$\phi$</span> in the state of Bloche sphere. <br />
If <span class=""math-container"">$\phi &gt;\pi$</span>, we can guess that <span class=""math-container"">$|0\rangle $</span> and <span class=""math-container"">$|1\rangle $</span> have different sign of amplitude.<br />
The method is available : <a href=""https://quantumcomputing.stackexchange.com/questions/13051/how-is-it-possible-to-guess-what-state-the-qubit-was-in-by-measuring-it/13055#13055"">How is it possible to guess what state the qubit was in by measuring it?</a></p>
<p>But how to estimate the negative amplitude of multiple qubits in one register? <br />
What if the solution of value is all negative??</p>
<p>(Actually, I'd like to solve linear problem by quantum linear solver such as HHL algorithm )</p>
",How to estimate the negative amplitude of multiple qubits?,<quantum-state><measurement><quantum-phase-estimation><hhl-algorithm>,2,0,,,"How to estimate the negative amplitude of multiple qubits? <p>The probability of measurement is the square of amplitude.
After measurement, how to guess the original amplitude of state??</p>
<p>For example, in linear problem, we would like to know the exact solution, which has both of the positive and negative values.</p>
<p>In case of one qubit, the negative amplitude may be decided by estimating relative phase.</p>
<p>By measuring Z, X and Y basis, we can decide the <span class=""math-container"">$θ$</span> and <span class=""math-container"">$\phi$</span> in the state of Bloche sphere. <br />
If <span class=""math-container"">$\phi &gt;\pi$</span>, we can guess that <span class=""math-container"">$|0\rangle $</span> and <span class=""math-container"">$|1\rangle $</span> have different sign of amplitude.<br />
The method is available : <a href=""https://quantumcomputing.stackexchange.com/questions/13051/how-is-it-possible-to-guess-what-state-the-qubit-was-in-by-measuring-it/13055#13055"">How is it possible to guess what state the qubit was in by measuring it?</a></p>
<p>But how to estimate the negative amplitude of multiple qubits in one register? <br />
What if the solution of value is all negative??</p>
<p>(Actually, I'd like to solve linear problem by quantum linear solver such as HHL algorithm )</p>
",qc,estimate negative amplitude multiple qubits p probability measurement square amplitude measurement guess original amplitude state p example linear problem would like know exact solution positive negative p case one qubit negative amplitude may decided estimating relative p measuring z x basis decide span θ span state bloche sphere br span gt guess span span different sign br method available https 13055 possible guess state qubit measuring p estimate negative amplitude multiple qubits one register br solution value negative p actually like solve linear problem quantum linear solver hhl algorithm,"[(3, 0.051984712), (7, 0.2119738), (10, 0.013552965), (11, 0.0122742485), (13, 0.3082638), (16, 0.011652122), (18, 0.38880727)]"
35140,,2023-12-09 03:56:34,1,28,"<p>If one imagines the nodes of the classical weighted graph as atoms, and paths between them as bonding strength, then to find the shortest path in the weighted graph, can one also look at the minima/maxima of the correlation function of the spin of the atoms? Correlation function of the spins along <span class=""math-container"">$z$</span>-axis might look like:</p>
<p><span class=""math-container"">$$G_z(i_1, \cdots i_n) = \langle T\bigr\{\sigma_{i_1, z}(t_1)\sigma_{i_2, z}(t_2),\cdots,\sigma_{i_n, z}(t_n)\bigr\}\rangle\tag{1}$$</span></p>
<p>Where <span class=""math-container"">$\sigma_{i_k, z}(t_k)$</span> denotes spin-<span class=""math-container"">$z$</span> component at the site <span class=""math-container"">$i_k$</span> and instant <span class=""math-container"">$t_k$</span> on the lattice, and where <span class=""math-container"">$T$</span> is time-ordering operator. The lower bonding strength between atoms is, the lower the correlation between their spins should be. In which case I thought optimal classical path can be associated with the sites of the lattice that exhibit the weakest/strongest correlation, yet I am not really sure whether there's a theoretical flaw in this idea (highly likely).</p>
",Quantum optimization and correlation function,<optimization><ising-model>,0,0,,,"Quantum optimization and correlation function <p>If one imagines the nodes of the classical weighted graph as atoms, and paths between them as bonding strength, then to find the shortest path in the weighted graph, can one also look at the minima/maxima of the correlation function of the spin of the atoms? Correlation function of the spins along <span class=""math-container"">$z$</span>-axis might look like:</p>
<p><span class=""math-container"">$$G_z(i_1, \cdots i_n) = \langle T\bigr\{\sigma_{i_1, z}(t_1)\sigma_{i_2, z}(t_2),\cdots,\sigma_{i_n, z}(t_n)\bigr\}\rangle\tag{1}$$</span></p>
<p>Where <span class=""math-container"">$\sigma_{i_k, z}(t_k)$</span> denotes spin-<span class=""math-container"">$z$</span> component at the site <span class=""math-container"">$i_k$</span> and instant <span class=""math-container"">$t_k$</span> on the lattice, and where <span class=""math-container"">$T$</span> is time-ordering operator. The lower bonding strength between atoms is, the lower the correlation between their spins should be. In which case I thought optimal classical path can be associated with the sites of the lattice that exhibit the weakest/strongest correlation, yet I am not really sure whether there's a theoretical flaw in this idea (highly likely).</p>
",qc,quantum optimization correlation function p one imagines nodes classical weighted graph atoms paths bonding strength find shortest path weighted graph one also look correlation function spin atoms correlation function spins along span z might look like p span z z z 1 p span z denotes span z component site span instant span lattice span operator lower bonding strength atoms lower correlation spins case thought optimal classical path associated sites lattice exhibit correlation yet really sure whether theoretical flaw idea highly likely,"[(1, 0.039848104), (3, 0.4365871), (8, 0.1946377), (10, 0.05205111), (11, 0.03881002), (13, 0.21059985), (16, 0.025822155)]"
35281,,2023-12-22 04:13:19,2,89,"<p>I have an error when I want to run the <code>'LocalSimulator'</code>. I am not inside AWS, its mean I runnig from Google Colab. The code is the same on the notebooks from <a href=""https://amazon-braket-conexionaws.notebook.us-east-1.sagemaker.aws/lab/tree/Braket%20examples/getting_started/0_Getting_started/0_Getting_started.ipynb"" rel=""nofollow noreferrer"">0_Getting_started</a></p>
<pre><code>    # general imports
    import matplotlib.pyplot as plt
    %matplotlib inline

    # AWS imports: Import Braket SDK modules
    from braket.circuits import Circuit
    from braket.devices import LocalSimulator

    # build a Bell state with two qubits. Here 'cnot(control=0, target=1)' can be 
     simplified as 'cnot(0,1)'
    bell = Circuit().h(0).cnot(control=0, target=1)
    # set up device
    device = LocalSimulator()

    # run circuit
     result = device.run(bell, shots=1000).result()
    # get measurement shots
    counts = result.measurement_counts
    # print counts
    print(counts)
</code></pre>
<p>And the result is</p>
<p><code>ValueError: Only the following devices are available dict_keys([])</code></p>
",Error 'LocalSimulator' with Googlecolab,<textbook-and-exercises><simulation><amazon-braket>,1,3,,,"Error 'LocalSimulator' with Googlecolab <p>I have an error when I want to run the <code>'LocalSimulator'</code>. I am not inside AWS, its mean I runnig from Google Colab. The code is the same on the notebooks from <a href=""https://amazon-braket-conexionaws.notebook.us-east-1.sagemaker.aws/lab/tree/Braket%20examples/getting_started/0_Getting_started/0_Getting_started.ipynb"" rel=""nofollow noreferrer"">0_Getting_started</a></p>
<pre><code>    # general imports
    import matplotlib.pyplot as plt
    %matplotlib inline

    # AWS imports: Import Braket SDK modules
    from braket.circuits import Circuit
    from braket.devices import LocalSimulator

    # build a Bell state with two qubits. Here 'cnot(control=0, target=1)' can be 
     simplified as 'cnot(0,1)'
    bell = Circuit().h(0).cnot(control=0, target=1)
    # set up device
    device = LocalSimulator()

    # run circuit
     result = device.run(bell, shots=1000).result()
    # get measurement shots
    counts = result.measurement_counts
    # print counts
    print(counts)
</code></pre>
<p>And the result is</p>
<p><code>ValueError: Only the following devices are available dict_keys([])</code></p>
",qc,error googlecolab p error want run code inside aws mean runnig google colab code notebooks https nofollow noreferrer pre code general imports import plt matplotlib inline aws imports import braket sdk modules import circuit import localsimulator build bell state two qubits simplified bell circuit 0 set device device localsimulator run circuit result bell get measurement shots counts print counts print counts p result p code valueerror following devices available,"[(0, 0.4130085), (4, 0.09622813), (12, 0.049080182), (14, 0.28716898), (16, 0.026907543), (18, 0.108287245), (19, 0.017383516)]"
35327,35328.0,2023-12-27 20:01:54,3,210,"<p>In the context of Ising models, some Hamiltonians can be described as geometrically frustrated - such as, I think, the antiferromagnetic <a href=""https://en.wikipedia.org/wiki/Kagome_metal"" rel=""nofollow noreferrer"">kagome</a> lattice, as well as a one-dimensional <a href=""https://en.wikipedia.org/wiki/ANNNI_model"" rel=""nofollow noreferrer"">anisotropic, next-nearest neighbor Ising</a> chain.  There appears to be a competition between spin-up and spin-down qubits, influenced by the geometry/topology of the lattice.</p>
<p>But we can also describe certain local Hamiltonians as being &quot;frustration free&quot;, where, in the ground state of the global Hamiltonian, each local term also obtains its own lowest energy configuration.</p>
<p>Apparently there is a difference between the two terms - but I'm not entirely sure why?</p>
<p>Certainly a Hamiltonian can be &quot;computationally local&quot; with each term acting only on a subset of <span class=""math-container"">$n$</span> qubits, without being &quot;geometrically local&quot; where each of the <span class=""math-container"">$k$</span> qubits are near to each other.  But if a lattice is geometrically frustrated, then surely its natural description as a Hamiltonian is not frustration free?</p>
",How is geometric frustration different from (not) being frustration free?,<hamiltonian-simulation><terminology-and-notation>,1,0,,,"How is geometric frustration different from (not) being frustration free? <p>In the context of Ising models, some Hamiltonians can be described as geometrically frustrated - such as, I think, the antiferromagnetic <a href=""https://en.wikipedia.org/wiki/Kagome_metal"" rel=""nofollow noreferrer"">kagome</a> lattice, as well as a one-dimensional <a href=""https://en.wikipedia.org/wiki/ANNNI_model"" rel=""nofollow noreferrer"">anisotropic, next-nearest neighbor Ising</a> chain.  There appears to be a competition between spin-up and spin-down qubits, influenced by the geometry/topology of the lattice.</p>
<p>But we can also describe certain local Hamiltonians as being &quot;frustration free&quot;, where, in the ground state of the global Hamiltonian, each local term also obtains its own lowest energy configuration.</p>
<p>Apparently there is a difference between the two terms - but I'm not entirely sure why?</p>
<p>Certainly a Hamiltonian can be &quot;computationally local&quot; with each term acting only on a subset of <span class=""math-container"">$n$</span> qubits, without being &quot;geometrically local&quot; where each of the <span class=""math-container"">$k$</span> qubits are near to each other.  But if a lattice is geometrically frustrated, then surely its natural description as a Hamiltonian is not frustration free?</p>
",qc,geometric frustration different frustration free p context ising models hamiltonians described geometrically frustrated think antiferromagnetic https nofollow noreferrer kagome lattice well https nofollow noreferrer anisotropic neighbor ising chain appears competition qubits influenced p also describe certain local hamiltonians quot frustration free quot ground state global hamiltonian local term also obtains lowest energy p apparently difference two terms entirely sure p certainly hamiltonian quot computationally local quot term acting subset span n qubits without quot geometrically local quot span k qubits near lattice geometrically frustrated surely natural description hamiltonian frustration free,"[(1, 0.11445829), (3, 0.06726055), (4, 0.025633926), (9, 0.6972745), (16, 0.022783827), (19, 0.071017966)]"
35344,35361.0,2023-12-29 21:45:55,2,134,"<p>Gidney's <a href=""https://docs.google.com/presentation/d/1IjZ-0W9Y22wNG5036WFnnkF5Az1Zt8jTHFTC1-e7Em4/edit#slide=id.p"" rel=""nofollow noreferrer"">Understanding Defect Diagrams</a> has been helpful to better understand defect diagrams. The pictures are cool, I'm just struggling to connect them to specific questions we can answer with them.</p>
<p>My key question is: what types of questions can you answer with a defect diagram? What is the workflow?</p>
<p>Q1: Is the following correct about the use cases and workflow of defect diagrams?</p>
<p><strong>Use cases</strong></p>
<ol>
<li>Validating operations -- as in <a href=""https://quantumcomputing.stackexchange.com/questions/32616/proofs-that-lattice-surgery-does-what-it-claims-to-do/32622#32622"">here</a>, operations like lattice surgery preserve some spacetime stabilizers. Thus, demonstrating that these spacetime stabilizers remain constant via defect diagrams is analogous to a proof of validity.</li>
<li>Analyzing error strings in spacetime -- as in <a href=""https://arxiv.org/pdf/2109.02746.pdf"" rel=""nofollow noreferrer"">Figure 8 here</a>, defect diagrams can be used to identify spacetime errors which cause logical errors / classify these errors.</li>
</ol>
<p><strong>Defect diagram workflow</strong></p>
<ol>
<li>For each point in time, draw the defect diagram of the surface code. These will likely be deformed over time, in which case boundaries will change as time progresses.</li>
<li>Through the computation, correlation surfaces can be identified. These surfaces represent stabilizers in spacetime, i.e. the product of the stabilizers at multiple times which should be constant.</li>
<li>Correlation surfaces, like boundaries, will absorb some excitations but not others. Pauli errors of a different type than the surface will cause an incorrect measurement.</li>
</ol>
<p>Q2: As seen in <a href=""https://arxiv.org/pdf/2302.07395.pdf"" rel=""nofollow noreferrer"">Figure 15</a>, what types of questions can be answered / what is the workflow for this defect diagram?
<a href=""https://i.sstatic.net/eTAAA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eTAAA.png"" alt=""enter image description here"" /></a></p>
",What is the point of defect diagrams?,<stim>,1,0,,,"What is the point of defect diagrams? <p>Gidney's <a href=""https://docs.google.com/presentation/d/1IjZ-0W9Y22wNG5036WFnnkF5Az1Zt8jTHFTC1-e7Em4/edit#slide=id.p"" rel=""nofollow noreferrer"">Understanding Defect Diagrams</a> has been helpful to better understand defect diagrams. The pictures are cool, I'm just struggling to connect them to specific questions we can answer with them.</p>
<p>My key question is: what types of questions can you answer with a defect diagram? What is the workflow?</p>
<p>Q1: Is the following correct about the use cases and workflow of defect diagrams?</p>
<p><strong>Use cases</strong></p>
<ol>
<li>Validating operations -- as in <a href=""https://quantumcomputing.stackexchange.com/questions/32616/proofs-that-lattice-surgery-does-what-it-claims-to-do/32622#32622"">here</a>, operations like lattice surgery preserve some spacetime stabilizers. Thus, demonstrating that these spacetime stabilizers remain constant via defect diagrams is analogous to a proof of validity.</li>
<li>Analyzing error strings in spacetime -- as in <a href=""https://arxiv.org/pdf/2109.02746.pdf"" rel=""nofollow noreferrer"">Figure 8 here</a>, defect diagrams can be used to identify spacetime errors which cause logical errors / classify these errors.</li>
</ol>
<p><strong>Defect diagram workflow</strong></p>
<ol>
<li>For each point in time, draw the defect diagram of the surface code. These will likely be deformed over time, in which case boundaries will change as time progresses.</li>
<li>Through the computation, correlation surfaces can be identified. These surfaces represent stabilizers in spacetime, i.e. the product of the stabilizers at multiple times which should be constant.</li>
<li>Correlation surfaces, like boundaries, will absorb some excitations but not others. Pauli errors of a different type than the surface will cause an incorrect measurement.</li>
</ol>
<p>Q2: As seen in <a href=""https://arxiv.org/pdf/2302.07395.pdf"" rel=""nofollow noreferrer"">Figure 15</a>, what types of questions can be answered / what is the workflow for this defect diagram?
<a href=""https://i.sstatic.net/eTAAA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eTAAA.png"" alt=""enter image description here"" /></a></p>
",qc,point defect diagrams p gidney https nofollow noreferrer understanding defect diagrams helpful better understand defect diagrams pictures cool struggling connect specific questions answer p key question types questions answer defect diagram workflow p q1 following correct use cases workflow defect diagrams p strong use cases ol li validating operations https 32622 operations like lattice surgery preserve spacetime stabilizers thus demonstrating spacetime stabilizers remain constant via defect diagrams analogous proof li analyzing error strings spacetime https nofollow noreferrer figure 8 defect diagrams used identify spacetime errors cause logical errors classify p strong defect diagram workflow ol li point time draw defect diagram surface code likely deformed time case boundaries change time li computation correlation surfaces identified surfaces represent stabilizers spacetime product stabilizers multiple times li correlation surfaces like boundaries absorb excitations others pauli errors different type surface cause incorrect p q2 seen https nofollow noreferrer figure 15 types questions answered workflow defect diagram https nofollow noreferrer img https enter image description,"[(4, 0.17748155), (5, 0.14581302), (7, 0.1365885), (13, 0.50092745), (14, 0.011586706), (16, 0.019165944)]"
35364,,2024-01-02 14:16:48,2,141,"<p>I use the IBM' Qiskit Runtime Sampler on a 4 qubits circuit.</p>
<pre><code>with Session(backend=backend):
            sampler = Sampler()
            result = sampler.run(qc, shots=nshots).result()
            qd = result.quasi_dists[0]
            print(&quot;qd&quot;,qd)
</code></pre>
<p>I get the following quasi-distribution:</p>
<p>qd {44: 0.0830078125, 36: 0.060546875, 4: 0.0595703125, 56: 0.0673828125, 40: 0.0634765625, 52: 0.0576171875, 8: 0.0625, 0: 0.0673828125, 48: 0.0615234375, 60: 0.0634765625, 12: 0.07421875, 16: 0.0556640625, 28: 0.0634765625, 20: 0.0478515625, 32: 0.0546875, 24: 0.0576171875}</p>
<p>How it is possible for some key values need more than 4 qubits?
(same behavior with different backends)</p>
",Why are keys in the quasidistribution larger than the maximum number allowed by the number of qubits?,<qiskit><programming>,1,1,,,"Why are keys in the quasidistribution larger than the maximum number allowed by the number of qubits? <p>I use the IBM' Qiskit Runtime Sampler on a 4 qubits circuit.</p>
<pre><code>with Session(backend=backend):
            sampler = Sampler()
            result = sampler.run(qc, shots=nshots).result()
            qd = result.quasi_dists[0]
            print(&quot;qd&quot;,qd)
</code></pre>
<p>I get the following quasi-distribution:</p>
<p>qd {44: 0.0830078125, 36: 0.060546875, 4: 0.0595703125, 56: 0.0673828125, 40: 0.0634765625, 52: 0.0576171875, 8: 0.0625, 0: 0.0673828125, 48: 0.0615234375, 60: 0.0634765625, 12: 0.07421875, 16: 0.0556640625, 28: 0.0634765625, 20: 0.0478515625, 32: 0.0546875, 24: 0.0576171875}</p>
<p>How it is possible for some key values need more than 4 qubits?
(same behavior with different backends)</p>
",qc,keys quasidistribution larger maximum number allowed number qubits p use ibm qiskit runtime sampler 4 qubits pre code session sampler sampler result qc qd 0 print quot qd quot qd p get following p qd 44 36 4 56 40 52 8 0 48 60 12 16 28 20 32 24 p possible key values need 4 qubits behavior different backends,"[(0, 0.363605), (6, 0.1723027), (14, 0.28907454), (15, 0.110507354), (16, 0.013116772), (19, 0.049064253)]"
35383,35392.0,2024-01-05 11:26:52,1,85,"<p>I'm trying to write a code to find a minimum in a list. I follow this paper : <a href=""https://arxiv.org/pdf/quant-ph/9607014.pdf"" rel=""nofollow noreferrer"">A quantum algorithm for finding the minimum</a>. So I need to write an operator to mark the case <span class=""math-container"">$T
[j] &lt; T[y]$</span>.</p>
<p>My idea is to use the method describe <a href=""https://en.wikipedia.org/wiki/Digital_comparator"" rel=""nofollow noreferrer"">here</a>:</p>
<blockquote>
<p>In order to manually determine the greater of two binary numbers, we inspect the relative magnitudes of pairs of significant digits, starting from the most significant bit, gradually proceeding towards lower significant bits until an inequality is found. When an inequality is found, if the corresponding bit of A is 1 and that of B is 0 then we conclude that A&gt;B.</p>
</blockquote>
<p>So I wrote this code:</p>
<pre class=""lang-csharp prettyprint-override""><code>    operation MarkIfGreaterThan(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl {
           use q0IsGreaterThanQ1 = Qubit();
           use isFirstDifference = Qubit();
           for (q0, q1) in Zipped(c0, c1) {
               // do as https://en.wikipedia.org/wiki/Digital_comparator
               // https://pyqml.medium.com/the-quantum-bit-comparator-463911f7bcd3
               X(q1);
               CCNOT(q0,q1,q0IsGreaterThanQ1);
               X(q1);

               // How to find out a way to don't repeat the code above for the less significant qbits 
               X(isFirstDifference);
               CCNOT(q0IsGreaterThanQ1,isFirstDifference,target);
           }
   }  
</code></pre>
<p>I'm wondering how find a way to &quot;stop&quot; the loop i.e don't affect my target qubit for the less significant qubits. I find <a href=""https://www.researchgate.net/publication/228574906_Quantum_bit_string_comparator_Circuits_and_applications"" rel=""nofollow noreferrer"">this paper</a> but in this quantum circuits they apply the comparison for all bits. In my situation I just want compare the most significant.</p>
<p>One idea would be to record the comparisons in an array of qubits (<code>q0IsGreaterThanQ1[]</code>) and then go through this array to stop at the value representing my most significant qubit. However, this would cost me unnecessary qubits. And as you know, we need to save them.</p>
",How write a marking oracle if greater than with Q#?,<quantum-algorithms><grovers-algorithm><q#>,1,0,,,"How write a marking oracle if greater than with Q#? <p>I'm trying to write a code to find a minimum in a list. I follow this paper : <a href=""https://arxiv.org/pdf/quant-ph/9607014.pdf"" rel=""nofollow noreferrer"">A quantum algorithm for finding the minimum</a>. So I need to write an operator to mark the case <span class=""math-container"">$T
[j] &lt; T[y]$</span>.</p>
<p>My idea is to use the method describe <a href=""https://en.wikipedia.org/wiki/Digital_comparator"" rel=""nofollow noreferrer"">here</a>:</p>
<blockquote>
<p>In order to manually determine the greater of two binary numbers, we inspect the relative magnitudes of pairs of significant digits, starting from the most significant bit, gradually proceeding towards lower significant bits until an inequality is found. When an inequality is found, if the corresponding bit of A is 1 and that of B is 0 then we conclude that A&gt;B.</p>
</blockquote>
<p>So I wrote this code:</p>
<pre class=""lang-csharp prettyprint-override""><code>    operation MarkIfGreaterThan(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl {
           use q0IsGreaterThanQ1 = Qubit();
           use isFirstDifference = Qubit();
           for (q0, q1) in Zipped(c0, c1) {
               // do as https://en.wikipedia.org/wiki/Digital_comparator
               // https://pyqml.medium.com/the-quantum-bit-comparator-463911f7bcd3
               X(q1);
               CCNOT(q0,q1,q0IsGreaterThanQ1);
               X(q1);

               // How to find out a way to don't repeat the code above for the less significant qbits 
               X(isFirstDifference);
               CCNOT(q0IsGreaterThanQ1,isFirstDifference,target);
           }
   }  
</code></pre>
<p>I'm wondering how find a way to &quot;stop&quot; the loop i.e don't affect my target qubit for the less significant qubits. I find <a href=""https://www.researchgate.net/publication/228574906_Quantum_bit_string_comparator_Circuits_and_applications"" rel=""nofollow noreferrer"">this paper</a> but in this quantum circuits they apply the comparison for all bits. In my situation I just want compare the most significant.</p>
<p>One idea would be to record the comparisons in an array of qubits (<code>q0IsGreaterThanQ1[]</code>) and then go through this array to stop at the value representing my most significant qubit. However, this would cost me unnecessary qubits. And as you know, we need to save them.</p>
",qc,write marking oracle greater q p trying write code find minimum list follow paper https nofollow noreferrer quantum algorithm finding minimum need write operator mark case span j lt p idea use method describe https nofollow noreferrer blockquote p order manually determine greater two binary numbers inspect relative magnitudes pairs significant digits starting significant bit gradually proceeding towards lower significant bits inequality found inequality found corresponding bit 1 b 0 conclude gt p wrote code pre code operation markifgreaterthan c0 qubit c1 qubit target qubit unit use q0isgreaterthanq1 qubit use isfirstdifference qubit q0 q1 zipped c0 c1 https https x q1 ccnot q0 q1 q0isgreaterthanq1 x q1 find way repeat code less significant qbits x isfirstdifference ccnot q0isgreaterthanq1 isfirstdifference target p wondering find way quot stop quot loop affect target qubit less significant qubits find https nofollow noreferrer paper quantum circuits apply comparison bits situation want compare p one idea would record comparisons array qubits code q0isgreaterthanq1 go array stop value representing significant qubit however would cost unnecessary qubits know need save,"[(0, 0.040766113), (3, 0.057201482), (4, 0.088931285), (7, 0.034112513), (8, 0.12028049), (10, 0.031275183), (13, 0.17638296), (14, 0.19267514), (15, 0.07896353), (16, 0.04553592), (18, 0.119660795), (19, 0.013746361)]"
35478,35481.0,2024-01-14 07:58:19,0,51,"<p>How the shots belonging to the same job are scheduled to run on IBM quantum devices? Suppose my job has 1000 shots. Will all shots be executed in series, or is it possible they will be interleaved with shots corresponding to jobs submitted by other users?</p>
",How the shots belonging to the same job are scheduled to run on IBM quantum devices?,<ibm-q-experience>,1,0,,,"How the shots belonging to the same job are scheduled to run on IBM quantum devices? <p>How the shots belonging to the same job are scheduled to run on IBM quantum devices? Suppose my job has 1000 shots. Will all shots be executed in series, or is it possible they will be interleaved with shots corresponding to jobs submitted by other users?</p>
",qc,shots belonging job scheduled run ibm quantum devices p shots belonging job scheduled run ibm quantum devices suppose job 1000 shots shots executed series possible interleaved shots corresponding jobs submitted users,"[(9, 0.069089256), (11, 0.03262401), (14, 0.7924354), (16, 0.068565816), (17, 0.032469507)]"
35611,,2024-01-26 11:16:00,2,104,"<p>From my understanding so far: Code switching is essentially just a fault-tolerant mapping between two codes. It's called code conversion if it's gradational, i.e. changes to stabilizer generators are measured in each round of error correction. A non-fault tolerant code conversion is called code deformation. Then you have gauge fixing of which code deformation is an example of (see <a href=""https://arxiv.org/abs/1810.10037"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1810.10037</a>), but then gauge fixing is also an example of code switching according to table 1 of <a href=""https://arxiv.org/abs/2012.05260"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2012.05260</a>?</p>
<p>Another example of code switching btw are lattice surgery (which is also example of gauge fixing) and Floquet codes (which cannot be thought of as gauge fixing).</p>
<p>I guess I'm looking for some Venn diagram where I suppose code switching and gauge fixing would be umbrella terms.</p>
","What are the differences between code deformation, code conversion, code switching and gauge fixing?",<universal-gates><fault-tolerance><lattice-surgery>,0,0,,,"What are the differences between code deformation, code conversion, code switching and gauge fixing? <p>From my understanding so far: Code switching is essentially just a fault-tolerant mapping between two codes. It's called code conversion if it's gradational, i.e. changes to stabilizer generators are measured in each round of error correction. A non-fault tolerant code conversion is called code deformation. Then you have gauge fixing of which code deformation is an example of (see <a href=""https://arxiv.org/abs/1810.10037"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1810.10037</a>), but then gauge fixing is also an example of code switching according to table 1 of <a href=""https://arxiv.org/abs/2012.05260"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2012.05260</a>?</p>
<p>Another example of code switching btw are lattice surgery (which is also example of gauge fixing) and Floquet codes (which cannot be thought of as gauge fixing).</p>
<p>I guess I'm looking for some Venn diagram where I suppose code switching and gauge fixing would be umbrella terms.</p>
",qc,differences code deformation code conversion code switching gauge fixing p understanding far code switching essentially mapping two codes called code conversion gradational changes stabilizer generators measured round error correction tolerant code conversion called code deformation gauge fixing code deformation example see https nofollow noreferrer https gauge fixing also example code switching according table 1 https nofollow noreferrer https p another example code switching btw lattice surgery also example gauge fixing floquet codes thought gauge fixing p guess looking venn diagram suppose code switching gauge fixing would umbrella,"[(4, 0.18364196), (5, 0.49945715), (11, 0.24995399), (14, 0.041785985), (16, 0.023438789)]"
35637,,2024-01-29 15:11:40,1,109,"<p>I have <code>encoder()</code> and <code>decoder()</code> functions as follows:</p>
<pre class=""lang-python prettyprint-override""><code>def encoder(x: int=0, y: int=0, n=4):
    &quot;&quot;&quot;
    An encoder to convert two n-bit nonnegative integers (uint) x and y to a 2n-qubit QuantumCircuit.
    This encoder will be used by autograder.
    &quot;&quot;&quot;
    assert x &gt;= 0 and x &lt; 2**n and isinstance(n,int), f&quot;Your input x must be an integer in the range [0,{(2**n)-1}].&quot;
    assert y &gt;= 0 and y &lt; 2**n and isinstance(n,int), f&quot;Your input y must be an integer in the range [0,{(2**n)-1}].&quot;

    qc = QuantumCircuit(n*2)
    
    for i in range(n):
        if x &gt;= 2**(n-i-1):
            qc.x(n-i-1)
            x -= 2**(n-i-1)

    for i in range(n):
        if y &gt;= 2**(n-i-1):
            qc.x(2*n-i-1)
            y -= 2**(n-i-1)
    
    return qc

def decoder(qc: QuantumCircuit, n=4):
    &quot;&quot;&quot;
    A decoder to convert a QuantumCircuit to an n-bit nonnegative integer from the simulation histogram
    by measuring the first n qubits in the quantum circuit.
    The result should be deterministic on a noise-free machine, hence shot=1 is used for simulation.
    This decoder will be used by autograder.
    &quot;&quot;&quot;
    assert n &gt;= 1
    assert isinstance(qc, QuantumCircuit)
    assert qc.num_qubits &gt;= n

    n_qubits = qc.num_qubits
    n_clbits = max(n, qc.num_clbits)

    qr = QuantumRegister(n_qubits)
    cr = ClassicalRegister(n_clbits)
    qc_base = QuantumCircuit(qr, cr)
    qc = qc_base.compose(qc)

    simulator = QasmSimulator()
    qc.measure(list(range(n)), list(range(n)))
    cc = transpile(qc, simulator)
    job = simulator.run(cc, shots=1)
    result = list(job.result().get_counts(cc).keys())[0]

    z = 0
    for i in range(n):
        z += int(result[i])*2**(n-i-1)

    return z
</code></pre>
<p>How to implement the <code>quantum_and</code> gate? Any suggestions and clues would be helpful.</p>
<pre class=""lang-python prettyprint-override""><code>def quantum_and():
    &quot;&quot;&quot;
    An N-qubit quantum circuit which calculates the AND result of input1 on [q0] and input2 on [q1],
    The output will be measured on [q0].
    You need to decide the amount of additional qubits needed to implement the function.
    The function must be compatible with the provided encoder(n=1) and decoder(n=1).
    N must be either 2 or 3.
    Args: 
        None
    Return:
        qc: Your QuantumCircuit
    &quot;&quot;&quot;
</code></pre>
",How to implement a quantum_and() gate,<quantum-gate><programming>,0,1,,,"How to implement a quantum_and() gate <p>I have <code>encoder()</code> and <code>decoder()</code> functions as follows:</p>
<pre class=""lang-python prettyprint-override""><code>def encoder(x: int=0, y: int=0, n=4):
    &quot;&quot;&quot;
    An encoder to convert two n-bit nonnegative integers (uint) x and y to a 2n-qubit QuantumCircuit.
    This encoder will be used by autograder.
    &quot;&quot;&quot;
    assert x &gt;= 0 and x &lt; 2**n and isinstance(n,int), f&quot;Your input x must be an integer in the range [0,{(2**n)-1}].&quot;
    assert y &gt;= 0 and y &lt; 2**n and isinstance(n,int), f&quot;Your input y must be an integer in the range [0,{(2**n)-1}].&quot;

    qc = QuantumCircuit(n*2)
    
    for i in range(n):
        if x &gt;= 2**(n-i-1):
            qc.x(n-i-1)
            x -= 2**(n-i-1)

    for i in range(n):
        if y &gt;= 2**(n-i-1):
            qc.x(2*n-i-1)
            y -= 2**(n-i-1)
    
    return qc

def decoder(qc: QuantumCircuit, n=4):
    &quot;&quot;&quot;
    A decoder to convert a QuantumCircuit to an n-bit nonnegative integer from the simulation histogram
    by measuring the first n qubits in the quantum circuit.
    The result should be deterministic on a noise-free machine, hence shot=1 is used for simulation.
    This decoder will be used by autograder.
    &quot;&quot;&quot;
    assert n &gt;= 1
    assert isinstance(qc, QuantumCircuit)
    assert qc.num_qubits &gt;= n

    n_qubits = qc.num_qubits
    n_clbits = max(n, qc.num_clbits)

    qr = QuantumRegister(n_qubits)
    cr = ClassicalRegister(n_clbits)
    qc_base = QuantumCircuit(qr, cr)
    qc = qc_base.compose(qc)

    simulator = QasmSimulator()
    qc.measure(list(range(n)), list(range(n)))
    cc = transpile(qc, simulator)
    job = simulator.run(cc, shots=1)
    result = list(job.result().get_counts(cc).keys())[0]

    z = 0
    for i in range(n):
        z += int(result[i])*2**(n-i-1)

    return z
</code></pre>
<p>How to implement the <code>quantum_and</code> gate? Any suggestions and clues would be helpful.</p>
<pre class=""lang-python prettyprint-override""><code>def quantum_and():
    &quot;&quot;&quot;
    An N-qubit quantum circuit which calculates the AND result of input1 on [q0] and input2 on [q1],
    The output will be measured on [q0].
    You need to decide the amount of additional qubits needed to implement the function.
    The function must be compatible with the provided encoder(n=1) and decoder(n=1).
    N must be either 2 or 3.
    Args: 
        None
    Return:
        qc: Your QuantumCircuit
    &quot;&quot;&quot;
</code></pre>
",qc,implement gate p code encoder code decoder functions follows pre code def encoder x quot quot quot encoder convert two nonnegative integers uint x quantumcircuit encoder used autograder quot quot quot assert x gt 0 x lt 2 n isinstance n int f quot input x must integer range 0 2 n quot assert gt 0 lt 2 n isinstance n int f quot input must integer range 0 2 n quot qc quantumcircuit n 2 range n x gt 2 x 2 range n gt 2 2 2 return qc def decoder qc quantumcircuit quot quot quot decoder convert quantumcircuit nonnegative integer simulation histogram measuring first n qubits quantum circuit result deterministic machine hence used simulation decoder used autograder quot quot quot assert n gt 1 assert isinstance qc quantumcircuit assert gt n max n qr quantumregister cr classicalregister quantumcircuit qr cr qc qc simulator qasmsimulator list range n list range n cc transpile qc simulator job cc result list cc 0 z 0 range n z int result 2 return z p implement code gate suggestions clues would pre code def quot quot quot quantum circuit calculates result input1 q0 input2 q1 output measured q0 need decide amount additional qubits needed implement function function must compatible provided encoder decoder n must either 2 args none return qc quantumcircuit quot quot quot,"[(0, 0.4900366), (1, 0.081089325), (2, 0.14871061), (5, 0.060019016), (10, 0.08801815), (16, 0.014350931), (19, 0.11718711)]"
35677,35681.0,2024-01-31 15:34:02,1,136,"<p>This question pertains to the real-time classical processing required while running the surface code.</p>
<p>Consider two logical patches <span class=""math-container"">$P$</span>, <span class=""math-container"">$P'$</span>. Let's assume that after <span class=""math-container"">$d$</span> rounds, a <code>merge</code> operation is performed on the two patches to produce a merged patch <span class=""math-container"">$PP'$</span>. Considering we have <span class=""math-container"">$d$</span> rounds worth of syndromes immediately before the <code>merge</code> operation is performed, does the decoder need to decode errors for both <span class=""math-container"">$P$</span> and <span class=""math-container"">$P'$</span> before the <code>merge</code> operation can start?</p>
<p>I have the same question for splits. Let's assume that after <span class=""math-container"">$d$</span> rounds, a <code>split</code> operation is performed on a patch <span class=""math-container"">$PP'$</span> to produce <span class=""math-container"">$P$</span>, <span class=""math-container"">$P'$</span>. In this case, does the decoder need to decode <span class=""math-container"">$d$</span> rounds worth of syndromes before the <code>split</code> operation is performed?</p>
<p>Additional clarification: When I say the decoder needs to decode errors before a <code>merge</code>/<code>split</code> operation is performed, I imply that the patches will remain idle until decoding is complete after which the lattice surgery operation is performed.</p>
",Lattice surgery and real-time decoding,<error-correction><surface-code><lattice-surgery>,1,0,,,"Lattice surgery and real-time decoding <p>This question pertains to the real-time classical processing required while running the surface code.</p>
<p>Consider two logical patches <span class=""math-container"">$P$</span>, <span class=""math-container"">$P'$</span>. Let's assume that after <span class=""math-container"">$d$</span> rounds, a <code>merge</code> operation is performed on the two patches to produce a merged patch <span class=""math-container"">$PP'$</span>. Considering we have <span class=""math-container"">$d$</span> rounds worth of syndromes immediately before the <code>merge</code> operation is performed, does the decoder need to decode errors for both <span class=""math-container"">$P$</span> and <span class=""math-container"">$P'$</span> before the <code>merge</code> operation can start?</p>
<p>I have the same question for splits. Let's assume that after <span class=""math-container"">$d$</span> rounds, a <code>split</code> operation is performed on a patch <span class=""math-container"">$PP'$</span> to produce <span class=""math-container"">$P$</span>, <span class=""math-container"">$P'$</span>. In this case, does the decoder need to decode <span class=""math-container"">$d$</span> rounds worth of syndromes before the <code>split</code> operation is performed?</p>
<p>Additional clarification: When I say the decoder needs to decode errors before a <code>merge</code>/<code>split</code> operation is performed, I imply that the patches will remain idle until decoding is complete after which the lattice surgery operation is performed.</p>
",qc,lattice surgery decoding p question pertains classical processing required running surface p consider two logical patches span p span p let assume span rounds code merge operation performed two patches produce merged patch span pp considering span rounds worth syndromes immediately code merge operation performed decoder need decode errors span p span p code merge operation start p question splits let assume span rounds code split operation performed patch span pp produce span p span p case decoder need decode span rounds worth syndromes code split operation performed p additional clarification say decoder needs decode errors code merge code split operation performed imply patches remain idle decoding complete lattice surgery operation,"[(3, 0.22984962), (5, 0.29492974), (14, 0.20942403), (16, 0.104116686), (18, 0.16030496)]"
77932318,,2024-02-03 13:46:17,5,204,"<p>I was trying to write a script that obtains current Information about a Job on the IBM Quantum Platform using Qiskit.</p>
<p>I managed to call the current status with the JobID, but it seems, like there is no function or API call that makes it possible to display the current estimated waiting time for the Job.</p>
<p>In addition, although I managed to gather the information about the current status of the Job (e.g. queued) the output I get is NONE, maybe we can manage to fix this aswell.</p>
<p>Can anybody help me out?</p>
<p>I tried including a function to call the estimated waiting time, but it seems, that there is no API call.</p>
",Is there a function to call the estimated waiting time for a Job on the IBM Quantum Platform?,<quantum-computing><qiskit>,1,1,,,"Is there a function to call the estimated waiting time for a Job on the IBM Quantum Platform? <p>I was trying to write a script that obtains current Information about a Job on the IBM Quantum Platform using Qiskit.</p>
<p>I managed to call the current status with the JobID, but it seems, like there is no function or API call that makes it possible to display the current estimated waiting time for the Job.</p>
<p>In addition, although I managed to gather the information about the current status of the Job (e.g. queued) the output I get is NONE, maybe we can manage to fix this aswell.</p>
<p>Can anybody help me out?</p>
<p>I tried including a function to call the estimated waiting time, but it seems, that there is no API call.</p>
",so_new,function call estimated waiting time job ibm quantum platform p trying write script obtains current information job ibm quantum platform using p managed call current status jobid seems like function api call makes possible display current estimated waiting time p addition although managed gather information current status job queued output get none maybe manage fix p anybody help p tried including function call estimated waiting time seems api,"[(4, 0.06657725), (8, 0.4463233), (13, 0.024233801), (14, 0.25891858), (16, 0.062303014), (19, 0.13955812)]"
35771,,2024-02-09 16:19:36,1,64,"<p>I want to decompose a two-qubit unitary gate <span class=""math-container"">$U$</span>,
<span class=""math-container"">$$U = e^{-i \cdot \frac{t}{2} \cdot Z_1 \cdot Z_2}\,,$$</span> where <span class=""math-container"">$t$</span> is an angle.</p>
<p>I already know the right decomposition but Qiskit gives me an inefficent one. I want to know why. This is the code.</p>
<pre><code>import numpy as np
from scipy.linalg import expm
from qiskit.compiler import transpile
from qiskit import QuantumCircuit, QuantumRegister
import qiskit.quantum_info as qi 

pauli_str = qi.Pauli('ZZ')

# define your matrix
A = np.array(pauli_str)
t = np.pi / 6

# expm is a matrix exponential 
U = expm(-1j * t * A)

# create a 1 qubit circuit
q1 = QuantumRegister(2, name='q')
circuit1 = QuantumCircuit(q1)

# apply a single-qubit unitary gate, this will do the decomposition
circuit1.unitary(U, [0, 1])

res1 = qi.Operator(circuit1)
print(&quot;\nFirst circuit:\n&quot;)

basis_gates=['id', 'rz', 'ry', 'rx', 'cx']
result = transpile(circuit1, basis_gates=basis_gates, optimization_level=3, seed_transpiler=1)
print(result)

q2 = QuantumRegister(2, name='q')
circuit2 = QuantumCircuit(q2)
 
circuit2.cx(0, 1)
circuit2.rz(t*2, 1)
circuit2.cx(0, 1)

res2 = qi.Operator(circuit2)
print(&quot;\nSecond circuit:\n&quot;)
print(circuit2)
</code></pre>
<p>This is the result I get<a href=""https://i.sstatic.net/9cTyb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9cTyb.png"" alt=""enter image description here"" /></a></p>
",Qiskit bad unitary decomposition,<qiskit><quantum-gate><circuit-construction><qaoa>,0,1,,,"Qiskit bad unitary decomposition <p>I want to decompose a two-qubit unitary gate <span class=""math-container"">$U$</span>,
<span class=""math-container"">$$U = e^{-i \cdot \frac{t}{2} \cdot Z_1 \cdot Z_2}\,,$$</span> where <span class=""math-container"">$t$</span> is an angle.</p>
<p>I already know the right decomposition but Qiskit gives me an inefficent one. I want to know why. This is the code.</p>
<pre><code>import numpy as np
from scipy.linalg import expm
from qiskit.compiler import transpile
from qiskit import QuantumCircuit, QuantumRegister
import qiskit.quantum_info as qi 

pauli_str = qi.Pauli('ZZ')

# define your matrix
A = np.array(pauli_str)
t = np.pi / 6

# expm is a matrix exponential 
U = expm(-1j * t * A)

# create a 1 qubit circuit
q1 = QuantumRegister(2, name='q')
circuit1 = QuantumCircuit(q1)

# apply a single-qubit unitary gate, this will do the decomposition
circuit1.unitary(U, [0, 1])

res1 = qi.Operator(circuit1)
print(&quot;\nFirst circuit:\n&quot;)

basis_gates=['id', 'rz', 'ry', 'rx', 'cx']
result = transpile(circuit1, basis_gates=basis_gates, optimization_level=3, seed_transpiler=1)
print(result)

q2 = QuantumRegister(2, name='q')
circuit2 = QuantumCircuit(q2)
 
circuit2.cx(0, 1)
circuit2.rz(t*2, 1)
circuit2.cx(0, 1)

res2 = qi.Operator(circuit2)
print(&quot;\nSecond circuit:\n&quot;)
print(circuit2)
</code></pre>
<p>This is the result I get<a href=""https://i.sstatic.net/9cTyb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9cTyb.png"" alt=""enter image description here"" /></a></p>
",qc,qiskit bad unitary decomposition p want decompose unitary gate span u span u 2 span p already know right decomposition qiskit gives inefficent one want know pre code import numpy np import expm import transpile qiskit import quantumcircuit quantumregister import qi define matrix 6 expm matrix exponential u expm create 1 qubit circuit q1 quantumregister 2 q circuit1 quantumcircuit q1 apply unitary gate decomposition u 0 1 res1 circuit1 print quot circuit quot result transpile circuit1 print result q2 quantumregister 2 q circuit2 quantumcircuit q2 0 1 2 1 0 1 res2 circuit2 print quot circuit quot print circuit2 p result get https nofollow noreferrer img https enter image description,"[(0, 0.29348361), (2, 0.29826412), (3, 0.10511898), (4, 0.14671074), (7, 0.01131177), (14, 0.0826263), (16, 0.018710367), (19, 0.042683892)]"
35843,,2024-02-15 22:42:07,0,24,"<p>I'm working to optimize mappings from virtual to hardware qubits using error and calibration data from the backend. I've implemented my algorithm. When I submit a job, it of course takes 1-5 hours to work its way through the queue. By the time it executes, the data for the backend as changed. Is there support in qiskit to write a custom transpilation pass, send it in with my job, and have it execute when my circuit is at the front of the queue and about to run?</p>
<p>My gut says no since this would allow arbitrary code execution on IBM's systems, but it's worth checking anyways.</p>
",Custom Mapping using up-to-date Machine Characteristics,<qiskit><qubit-mapping>,0,0,,,"Custom Mapping using up-to-date Machine Characteristics <p>I'm working to optimize mappings from virtual to hardware qubits using error and calibration data from the backend. I've implemented my algorithm. When I submit a job, it of course takes 1-5 hours to work its way through the queue. By the time it executes, the data for the backend as changed. Is there support in qiskit to write a custom transpilation pass, send it in with my job, and have it execute when my circuit is at the front of the queue and about to run?</p>
<p>My gut says no since this would allow arbitrary code execution on IBM's systems, but it's worth checking anyways.</p>
",qc,custom mapping using machine characteristics p working optimize mappings virtual hardware qubits using error calibration data backend implemented algorithm submit job course takes hours work way queue time executes data backend changed support qiskit write custom transpilation pass send job execute circuit front queue run p gut says since would allow arbitrary code execution ibm systems worth checking,"[(8, 0.13487035), (14, 0.84185255), (16, 0.020303173)]"
35867,,2024-02-19 08:07:59,2,95,"<p><a href=""https://i.sstatic.net/E82TN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/E82TN.png"" alt=""enter image description here"" /></a></p>
<p>Hello, can you explain how to see in Google Cirq that the figure above is a 54 qubits quantum computer ? thanks</p>
",How can we see on Cirq that Google Sycamore has 54 qubits?,<quantum-gate><cirq><google-sycamore>,2,1,,,"How can we see on Cirq that Google Sycamore has 54 qubits? <p><a href=""https://i.sstatic.net/E82TN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/E82TN.png"" alt=""enter image description here"" /></a></p>
<p>Hello, can you explain how to see in Google Cirq that the figure above is a 54 qubits quantum computer ? thanks</p>
",qc,see cirq google sycamore 54 qubits p https nofollow noreferrer img https enter image description p hello explain see google cirq figure 54 qubits quantum computer thanks,"[(1, 0.055720147), (4, 0.86410195), (16, 0.07392687)]"
36985,,2024-02-27 11:05:37,1,78,"<p>The following code originates from a third-party, although, I have added the commented line containing &quot;UNCOMMENT THE START OF THIS LINE&quot;.</p>
<pre><code>import random
import numpy as np
import cirq

# Create a circuit
circuit = cirq.Circuit()
(q0, q1) = cirq.LineQubit.range(2)

# Apply the X-Pauli gate to each qubit
circuit.append([cirq.X(q0), cirq.X(q1)])

# Apply the Hadamard gate to first qubit and CNOT gate to both qubits
circuit.append([cirq.H(q0), cirq.CNOT(q0, q1)])

# Make a change to q1, to see if q0 shows a corresponding change
#circuit.append([cirq.X(q1)]) # UNCOMMENT THE START OF THIS LINE

#Measure both qubits
circuit.append([cirq.measure(q0), cirq.measure(q1)])

#Print the Circuit
print(&quot;Circuit:&quot;)
print(circuit)

# Simulate the circuit several times.
simulator = cirq.Simulator()
result = simulator.run(circuit, repetitions=10)

#Print the results
print(&quot;\nResults:&quot;)
print(result)
</code></pre>
<p>The code is intended to demonstrate <strong>entanglement</strong>, which the output suggests it achieves.</p>
<pre><code>Circuit:
0: ───X───H───@───M───
              │
1: ───X───────X───M───

Results:
q(0)=1000000111
q(1)=0111111000
</code></pre>
<p>Yet, if the commented line I added is uncommented, and the code run, the output no longer suggests entanglement.</p>
<pre><code>Circuit:
0: ───X───H───@───M───────
              │
1: ───X───────X───X───M───

Results:
q(0)=0100000001
q(1)=0100000001
</code></pre>
<p>I expected the q(0) results to be the opposite of those seen for q(1).</p>
<p>That is what I understand entanglement would achieve; you change q(1) and q(0) changes too.</p>
<p>As such, at the moment, the original code is not producing entanglement at all, but, merely, forcing the result to show opposite values; giving the illusion of entanglement.</p>
<p>Is there something I'm missing that will further my understanding, or, perhaps, even some Python/cirq code that delivers a simulation of entanglement that sees qubits behave as I'm expecting them to?</p>
",cirq entanglement qubits,<programming><entanglement><cirq>,1,0,,,"cirq entanglement qubits <p>The following code originates from a third-party, although, I have added the commented line containing &quot;UNCOMMENT THE START OF THIS LINE&quot;.</p>
<pre><code>import random
import numpy as np
import cirq

# Create a circuit
circuit = cirq.Circuit()
(q0, q1) = cirq.LineQubit.range(2)

# Apply the X-Pauli gate to each qubit
circuit.append([cirq.X(q0), cirq.X(q1)])

# Apply the Hadamard gate to first qubit and CNOT gate to both qubits
circuit.append([cirq.H(q0), cirq.CNOT(q0, q1)])

# Make a change to q1, to see if q0 shows a corresponding change
#circuit.append([cirq.X(q1)]) # UNCOMMENT THE START OF THIS LINE

#Measure both qubits
circuit.append([cirq.measure(q0), cirq.measure(q1)])

#Print the Circuit
print(&quot;Circuit:&quot;)
print(circuit)

# Simulate the circuit several times.
simulator = cirq.Simulator()
result = simulator.run(circuit, repetitions=10)

#Print the results
print(&quot;\nResults:&quot;)
print(result)
</code></pre>
<p>The code is intended to demonstrate <strong>entanglement</strong>, which the output suggests it achieves.</p>
<pre><code>Circuit:
0: ───X───H───@───M───
              │
1: ───X───────X───M───

Results:
q(0)=1000000111
q(1)=0111111000
</code></pre>
<p>Yet, if the commented line I added is uncommented, and the code run, the output no longer suggests entanglement.</p>
<pre><code>Circuit:
0: ───X───H───@───M───────
              │
1: ───X───────X───X───M───

Results:
q(0)=0100000001
q(1)=0100000001
</code></pre>
<p>I expected the q(0) results to be the opposite of those seen for q(1).</p>
<p>That is what I understand entanglement would achieve; you change q(1) and q(0) changes too.</p>
<p>As such, at the moment, the original code is not producing entanglement at all, but, merely, forcing the result to show opposite values; giving the illusion of entanglement.</p>
<p>Is there something I'm missing that will further my understanding, or, perhaps, even some Python/cirq code that delivers a simulation of entanglement that sees qubits behave as I'm expecting them to?</p>
",qc,cirq entanglement qubits p following code originates although added commented line containing quot uncomment start line quot pre code import random import numpy np import cirq create circuit circuit q0 q1 2 apply gate qubit q0 q1 apply hadamard gate first qubit cnot gate qubits q0 q0 q1 make change q1 see q0 shows corresponding change q1 uncomment start line measure qubits q0 q1 print circuit print quot circuit quot print circuit simulate circuit several times simulator result circuit print results print quot quot print result p code intended demonstrate strong entanglement output suggests pre code circuit 0 1 results q 0 q 1 p yet commented line added uncommented code run output longer suggests pre code circuit 0 1 results q 0 q 1 p expected q 0 results opposite seen q 1 p understand entanglement would achieve change q 1 q 0 changes p moment original code producing entanglement merely forcing result show opposite values giving illusion p something missing understanding perhaps even code delivers simulation entanglement sees qubits behave expecting,"[(0, 0.1616593), (2, 0.081252426), (10, 0.056080293), (14, 0.45245576), (16, 0.08309538), (18, 0.11930832), (19, 0.045392778)]"
37166,,2024-03-09 06:11:56,2,42,"<p>I am trying to bulid a quantum convolutional neural network for image classification with Pennylane and Keras but the model isn't training and I keep getting the warning:</p>
<blockquote>
<p>WARNING:tensorflow:Gradients do not exist for variables ['params:0',
'params:0'] when minimizing the loss. If you're using
<code>model.compile()</code>, did you forget to provide a <code>loss</code> argument?</p>
</blockquote>
<p>How do I fix this issue?</p>
<p>I have used code from <a href=""https://discuss.pennylane.ai/t/quantum-convolution-neural-network-using-keras/2905"" rel=""nofollow noreferrer"">Quantum Convolutional Neural Network using Keras</a> and <a href=""https://pennylane.ai/qml/demos/tutorial_quanvolution/"" rel=""nofollow noreferrer"">Quanvolutional Neural Network</a>.</p>
<p>Here are the relavent snippents of my code:</p>
<pre><code>import pennylane as qml
from pennylane import numpy as np
import tensorflow as tf
from tensorflow import keras
</code></pre>
<p>This code creates the quantum circuit to act as a filter:</p>
<pre><code>q = 4

layers=2

dev = qml.device(&quot;lightning.qubit&quot;, wires=q)

#params has dimension 2
def unit2(params, wires=[0, 1]):
    for j in range(2):
        qml.RY(params[j], wires=wires[j])
    qml.CNOT(wires=wires)

##### POOLING UNITS

#ZX pooling, params has dimensions 2
def pool1(params, wires=[0, 1]):
    qml.CRZ(params[0], wires=wires)
    qml.CRX(params[1], wires=wires)

@qml.qnode(dev, diff_method='parameter-shift')
def circuit(inputs, params):
    height = int(q/2)
    site = range(int(q))
    
    ##### ENCODING
    for i in range(q):
        qml.RX(inputs[i]*2*np.pi, wires=i)
    
    count = 0
    pdim = 2 #param dimension of unit
    for t in range(1, layers + 1):
        l = int(len(site)/2)
        
        ### CONVOLUTION
        for i in range(l):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i], site[2*i + 1]])
            count += pdim
        for i in range(l-1):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i + 1], site[2*i + 2]])
            count += pdim
        
        ### POOLING
        for i in range(l):
            ## Change unit here
            pool1(params[count:count + 2], wires=[site[2*i], site[2*i + 1]])
            count += 2
            
        trial = []
        for u in range(int(len(site)/2)):
            trial = trial + [site[2*u+1]]
        site = trial
    #print(count)
        
    return [qml.expval(qml.PauliZ(q-1))] #### Only measures off final qubit
</code></pre>
<p>which looks like this where I only read off the final qubit (numbers on gates are placeholders for the filters weights):
<a href=""https://i.sstatic.net/iQkMe.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/iQkMe.png"" alt=""graph of quantum circuit defined above"" /></a></p>
<p>I create the model here:</p>
<pre><code>class QuantumClassifier(tf.keras.Model):

    def __init__(self, filter_channels, kernal_params):
        super(QuantumClassifier,self).__init__()
        self.filters = filter_channels
        self.qfilters = []
        weight_shapes = {&quot;params&quot;: (kernal_params)}
        for i in range(filter_channels):
            self.qfilters.append(qml.qnn.KerasLayer(circuit, weight_shapes,output_dim=1, name='quantum_filter')) 
        self.hidden = tf.keras.layers.Dense(128, activation = 'relu')
        self.flatten = tf.keras.layers.Flatten()
        self.dense = tf.keras.layers.Dense(10, activation='softmax')
        print('INITILIZED')


    def call(self, inputs):
 
        width, length = inputs.shape[1], inputs.shape[2]
        batch_size = inputs.shape[0]

        total_out = tf.TensorArray(tf.float32, size=batch_size)
        count = 0
        #perform convolution with no padding and stride of 2
        for a in range(batch_size):
            
            out = np.zeros((width//2, length//2, self.filters))
            print(f&quot;Image: {a}&quot;)
            
            
            for i in range(0, width, 2):
                
                for j in range(0, length, 2):
                    
                    for f in range(self.filters):
                        
                        # convolution windows, now only applying to one channel image
                        sub_input =  inputs[a,i:i+q, j:j+q, :]
                        # flatten into 1-D
                        sub_input = tf.reshape(sub_input, [-1])
                        quantum_filter = self.qfilters[f]
                    
                        
                        out[i//2][j//2][f] = quantum_filter(sub_input)
                                

            total_out = total_out.write(count, out)
            count += 1
            
        total_out = total_out.stack()
        print(&quot;All input data for one batch have been convolved!&quot;)

        x = self.flatten(total_out)

        x = self.hidden(x)

        x = self.dense(x)
        return x
</code></pre>
<p>I created the model for 2 quantum filters where each one has 14 parameters:</p>
<pre><code>model = QuantumClassifier(2, 14)
model.compile(loss='sparse_categorical_crossentropy',
             optimizer='adam',
             metrics=['accuracy'])
r = model.fit(x_train_small, y_train, epochs=10, batch_size=16, validation_data=(x_test_small, y_test))
</code></pre>
<p>Here is the dataset I am using:</p>
<pre><code>mnist_dataset = keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist_dataset.load_data()
# Reduce dataset size
x_train = x_train[:n_train]
y_train = y_train[:n_train]
x_test = x_test[:n_test]
y_test = y_test[:n_test]
# Normalize pixel values within 0 and 1
x_train = x_train / 255
x_test = x_test / 255
# # Add extra dimension for &quot;color&quot; channels
x_train = np.array(x_train[..., tf.newaxis])
x_test = np.array(x_test[..., tf.newaxis])
print(f&quot;train_images_shape: {x_train.shape}&quot;)
# use Bilinear Interpolation for downscaling
x_train_small = tf.image.resize(x_train, (10,10)).numpy()
x_test_small = tf.image.resize(x_test, (10,10)).numpy()
print(f&quot;x_train_reshape: {x_train_small.shape}&quot;)
</code></pre>
<p>This is all in:
python==3.11.5
tensorflow==2.15.0
PennyLane==0.34.0</p>
<p>Any solutions (or ways to speed up my code) greatly appreciated!</p>
",Quantum Convolutional Neural Network not producing gradients,<programming><machine-learning><pennylane><neural-network><quantum-neural-network>,0,1,,,"Quantum Convolutional Neural Network not producing gradients <p>I am trying to bulid a quantum convolutional neural network for image classification with Pennylane and Keras but the model isn't training and I keep getting the warning:</p>
<blockquote>
<p>WARNING:tensorflow:Gradients do not exist for variables ['params:0',
'params:0'] when minimizing the loss. If you're using
<code>model.compile()</code>, did you forget to provide a <code>loss</code> argument?</p>
</blockquote>
<p>How do I fix this issue?</p>
<p>I have used code from <a href=""https://discuss.pennylane.ai/t/quantum-convolution-neural-network-using-keras/2905"" rel=""nofollow noreferrer"">Quantum Convolutional Neural Network using Keras</a> and <a href=""https://pennylane.ai/qml/demos/tutorial_quanvolution/"" rel=""nofollow noreferrer"">Quanvolutional Neural Network</a>.</p>
<p>Here are the relavent snippents of my code:</p>
<pre><code>import pennylane as qml
from pennylane import numpy as np
import tensorflow as tf
from tensorflow import keras
</code></pre>
<p>This code creates the quantum circuit to act as a filter:</p>
<pre><code>q = 4

layers=2

dev = qml.device(&quot;lightning.qubit&quot;, wires=q)

#params has dimension 2
def unit2(params, wires=[0, 1]):
    for j in range(2):
        qml.RY(params[j], wires=wires[j])
    qml.CNOT(wires=wires)

##### POOLING UNITS

#ZX pooling, params has dimensions 2
def pool1(params, wires=[0, 1]):
    qml.CRZ(params[0], wires=wires)
    qml.CRX(params[1], wires=wires)

@qml.qnode(dev, diff_method='parameter-shift')
def circuit(inputs, params):
    height = int(q/2)
    site = range(int(q))
    
    ##### ENCODING
    for i in range(q):
        qml.RX(inputs[i]*2*np.pi, wires=i)
    
    count = 0
    pdim = 2 #param dimension of unit
    for t in range(1, layers + 1):
        l = int(len(site)/2)
        
        ### CONVOLUTION
        for i in range(l):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i], site[2*i + 1]])
            count += pdim
        for i in range(l-1):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i + 1], site[2*i + 2]])
            count += pdim
        
        ### POOLING
        for i in range(l):
            ## Change unit here
            pool1(params[count:count + 2], wires=[site[2*i], site[2*i + 1]])
            count += 2
            
        trial = []
        for u in range(int(len(site)/2)):
            trial = trial + [site[2*u+1]]
        site = trial
    #print(count)
        
    return [qml.expval(qml.PauliZ(q-1))] #### Only measures off final qubit
</code></pre>
<p>which looks like this where I only read off the final qubit (numbers on gates are placeholders for the filters weights):
<a href=""https://i.sstatic.net/iQkMe.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/iQkMe.png"" alt=""graph of quantum circuit defined above"" /></a></p>
<p>I create the model here:</p>
<pre><code>class QuantumClassifier(tf.keras.Model):

    def __init__(self, filter_channels, kernal_params):
        super(QuantumClassifier,self).__init__()
        self.filters = filter_channels
        self.qfilters = []
        weight_shapes = {&quot;params&quot;: (kernal_params)}
        for i in range(filter_channels):
            self.qfilters.append(qml.qnn.KerasLayer(circuit, weight_shapes,output_dim=1, name='quantum_filter')) 
        self.hidden = tf.keras.layers.Dense(128, activation = 'relu')
        self.flatten = tf.keras.layers.Flatten()
        self.dense = tf.keras.layers.Dense(10, activation='softmax')
        print('INITILIZED')


    def call(self, inputs):
 
        width, length = inputs.shape[1], inputs.shape[2]
        batch_size = inputs.shape[0]

        total_out = tf.TensorArray(tf.float32, size=batch_size)
        count = 0
        #perform convolution with no padding and stride of 2
        for a in range(batch_size):
            
            out = np.zeros((width//2, length//2, self.filters))
            print(f&quot;Image: {a}&quot;)
            
            
            for i in range(0, width, 2):
                
                for j in range(0, length, 2):
                    
                    for f in range(self.filters):
                        
                        # convolution windows, now only applying to one channel image
                        sub_input =  inputs[a,i:i+q, j:j+q, :]
                        # flatten into 1-D
                        sub_input = tf.reshape(sub_input, [-1])
                        quantum_filter = self.qfilters[f]
                    
                        
                        out[i//2][j//2][f] = quantum_filter(sub_input)
                                

            total_out = total_out.write(count, out)
            count += 1
            
        total_out = total_out.stack()
        print(&quot;All input data for one batch have been convolved!&quot;)

        x = self.flatten(total_out)

        x = self.hidden(x)

        x = self.dense(x)
        return x
</code></pre>
<p>I created the model for 2 quantum filters where each one has 14 parameters:</p>
<pre><code>model = QuantumClassifier(2, 14)
model.compile(loss='sparse_categorical_crossentropy',
             optimizer='adam',
             metrics=['accuracy'])
r = model.fit(x_train_small, y_train, epochs=10, batch_size=16, validation_data=(x_test_small, y_test))
</code></pre>
<p>Here is the dataset I am using:</p>
<pre><code>mnist_dataset = keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist_dataset.load_data()
# Reduce dataset size
x_train = x_train[:n_train]
y_train = y_train[:n_train]
x_test = x_test[:n_test]
y_test = y_test[:n_test]
# Normalize pixel values within 0 and 1
x_train = x_train / 255
x_test = x_test / 255
# # Add extra dimension for &quot;color&quot; channels
x_train = np.array(x_train[..., tf.newaxis])
x_test = np.array(x_test[..., tf.newaxis])
print(f&quot;train_images_shape: {x_train.shape}&quot;)
# use Bilinear Interpolation for downscaling
x_train_small = tf.image.resize(x_train, (10,10)).numpy()
x_test_small = tf.image.resize(x_test, (10,10)).numpy()
print(f&quot;x_train_reshape: {x_train_small.shape}&quot;)
</code></pre>
<p>This is all in:
python==3.11.5
tensorflow==2.15.0
PennyLane==0.34.0</p>
<p>Any solutions (or ways to speed up my code) greatly appreciated!</p>
",qc,quantum convolutional neural network producing gradients p trying bulid quantum convolutional neural network image classification pennylane keras model training keep getting warning blockquote p warning tensorflow gradients exist variables minimizing loss using code forget provide code loss argument p fix issue p used code https nofollow noreferrer quantum convolutional neural network using keras https nofollow noreferrer quanvolutional neural network p relavent snippents code pre code import pennylane qml pennylane import numpy np import tensorflow tf tensorflow import keras p code creates quantum circuit act filter pre code q 4 dev quot quot params dimension 2 def unit2 params 0 1 j range 2 params j j pooling units zx pooling params dimensions 2 def pool1 params 0 1 params 0 params 1 dev def circuit inputs params height int site range int q encoding range q inputs 2 count 0 pdim 2 param dimension unit range 1 layers 1 l int len site convolution range l change unit unit2 params count count pdim site 2 site 2 1 count pdim range change unit unit2 params count count pdim site 2 1 site 2 2 count pdim pooling range l change unit pool1 params count count 2 site 2 site 2 1 count 2 trial u range int len site trial trial site 2 site trial print count return measures final qubit p looks like read final qubit numbers gates placeholders filters weights https nofollow noreferrer img https graph quantum circuit defined p create model pre code class quantumclassifier def self super quantumclassifier self quot params quot range circuit 128 activation 10 print def call self inputs width length 1 2 0 count 0 perform convolution padding stride 2 range print f quot image quot range 0 width 2 j range 0 length 2 f range convolution windows applying one channel image inputs j flatten f f count count 1 print quot input data one batch convolved quot x x x x x return x p created model 2 quantum filters one 14 parameters pre code model quantumclassifier 2 14 r p dataset using pre code reduce dataset size normalize pixel values within 0 1 255 255 add extra dimension quot color quot channels print f quot quot use bilinear interpolation downscaling print f quot quot p p solutions ways speed code greatly appreciated,"[(0, 0.3993897), (2, 0.102175035), (3, 0.014965662), (4, 0.05334218), (8, 0.1444807), (10, 0.07506502), (12, 0.07879626), (14, 0.03565863), (16, 0.01086846), (19, 0.0702024)]"
37227,,2024-03-13 08:11:48,1,83,"<p>I am quite confused with the MatrixOp.to_pauli_op() API.</p>
<p>I have a hamiltonian, and it is given as input to a
API <code>MatrixOp</code>.</p>
<pre><code>import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.utils import QuantumInstance 
from qiskit import IBMQ, transpile
from qiskit import Aer

from qiskit.algorithms import VQE
    
# This Hamiltonian is not unitary.It is generated from matrix A and B (AX =B)
Hamiltonian =  np.array([[ 4.07981221, -3.6713615,   1.3943662,  -1.05164319], 
 [-3.6713615,   5.88262911, -4.14084507,  1.37558685],
 [ 1.3943662,  -4.14084507,  5.83098592, -3.54929577],
 [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
    

H_op = MatrixOp(Hamiltonian).to_pauli_op()
print(H_op)
print(type(H_op)) 
</code></pre>
<p>How can a non-unitary matrix be given as input to a qiskit API?</p>
",Usage of qiskit API MatrixOp.to_pauli_op(),<qiskit><programming><vqe>,0,3,,,"Usage of qiskit API MatrixOp.to_pauli_op() <p>I am quite confused with the MatrixOp.to_pauli_op() API.</p>
<p>I have a hamiltonian, and it is given as input to a
API <code>MatrixOp</code>.</p>
<pre><code>import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.utils import QuantumInstance 
from qiskit import IBMQ, transpile
from qiskit import Aer

from qiskit.algorithms import VQE
    
# This Hamiltonian is not unitary.It is generated from matrix A and B (AX =B)
Hamiltonian =  np.array([[ 4.07981221, -3.6713615,   1.3943662,  -1.05164319], 
 [-3.6713615,   5.88262911, -4.14084507,  1.37558685],
 [ 1.3943662,  -4.14084507,  5.83098592, -3.54929577],
 [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
    

H_op = MatrixOp(Hamiltonian).to_pauli_op()
print(H_op)
print(type(H_op)) 
</code></pre>
<p>How can a non-unitary matrix be given as input to a qiskit API?</p>
",qc,usage qiskit api p quite confused p hamiltonian given input api code matrixop pre code import numpy np import matrixop import efficientsu2 import cobyla import quantuminstance qiskit import ibmq transpile qiskit import aer import vqe hamiltonian generated matrix b ax hamiltonian matrixop hamiltonian print print type p matrix given input qiskit api,"[(0, 0.6238338), (1, 0.07392214), (11, 0.03843962), (12, 0.057908766), (14, 0.1462138), (16, 0.05699866)]"
37265,,2024-03-15 07:45:36,1,50,"<p>In <a href=""https://arxiv.org/pdf/1208.5791.pdf"" rel=""nofollow noreferrer"">this paper</a> from 2014, Lidar defines: &quot;an open system which undergoes purely unitary evolution (possibly only in a subspace of its Hilbert space) is said to be decoherence-free.&quot; Why is this the chosen definition? Naively, it seems to be overly strict.</p>
<p>In particular, I would guess that we would want to call a subspace &quot;decoherence-free&quot; when there exists a pointer basis for that subspace according to the predictability sieve criterion (or a better criterion). I.e., not that the effective dynamics have to be unitary within the subspace, but that the there exists a basis for this subspace such that each basis vector does not entangle (very much) with the environment (modeled a certain way) under evolution of the total Hamiltonian.</p>
","Why does Lidar define a decoherence-free subspace as ""a subspace that undergoes purely unitary evolution""",<entanglement><decoherence>,1,0,,,"Why does Lidar define a decoherence-free subspace as ""a subspace that undergoes purely unitary evolution"" <p>In <a href=""https://arxiv.org/pdf/1208.5791.pdf"" rel=""nofollow noreferrer"">this paper</a> from 2014, Lidar defines: &quot;an open system which undergoes purely unitary evolution (possibly only in a subspace of its Hilbert space) is said to be decoherence-free.&quot; Why is this the chosen definition? Naively, it seems to be overly strict.</p>
<p>In particular, I would guess that we would want to call a subspace &quot;decoherence-free&quot; when there exists a pointer basis for that subspace according to the predictability sieve criterion (or a better criterion). I.e., not that the effective dynamics have to be unitary within the subspace, but that the there exists a basis for this subspace such that each basis vector does not entangle (very much) with the environment (modeled a certain way) under evolution of the total Hamiltonian.</p>
",qc,lidar define subspace subspace undergoes purely unitary evolution p https nofollow noreferrer paper 2014 lidar defines quot open system undergoes purely unitary evolution possibly subspace hilbert space said quot chosen definition naively seems overly p particular would guess would want call subspace quot quot exists pointer basis subspace according predictability sieve criterion better criterion effective dynamics unitary within subspace exists basis subspace basis vector entangle much environment modeled certain way evolution total,"[(1, 0.10669459), (3, 0.51026064), (9, 0.18569025), (16, 0.094599165), (18, 0.028972888), (19, 0.07184057)]"
37283,,2024-03-15 21:42:51,1,1221,"<p>I am quite struggling with the usage of <code>QuantumInstance</code> API.
This API is present in <code>qiskit version 0.32.1</code>
Below is small code:</p>
<pre><code>from qiskit.utils import QuantumInstance 
from qiskit import Aer
simulator_used = &quot;qasm_simulator&quot;
backend = Aer.get_backend(simulator_used)



quantum_instance = QuantumInstance(backend = backend,
                                   shots = 2000,
                                   seed_simulator= 28,
                                   seed_transpiler = 28,
                                   basis_gates = None,
                                   optimization_level =1)
</code></pre>
<p>Suppose, I want to make a simulator as <code>statevector_simulator</code>. Then do I have to make shots =1?</p>
<p>Suppose I want to use the <code>QuantumInstance</code> in the code below. Then how should I modify the code below? If <code>QuantumInstance</code> cannot be used in the code below, then where should it be used?</p>
<pre><code>from qiskit import Aer
from qiskit import execute
from qiskit import QuantumCircuit


circ = QuantumCircuit(3,3)
circ.h(0)
circ.cx(0,1)
circ.cx(0,2)

backend = Aer.get_backend(&quot;qasm_simulator&quot;)  

job = execute(circ, backend, shots = 100000)
result = job.result()
counts = result.get_counts(circ)
print(counts)
</code></pre>
",How to use qiskit.utils.QuantumInstance API of qiskit?,<qiskit><programming><simulation>,1,0,,,"How to use qiskit.utils.QuantumInstance API of qiskit? <p>I am quite struggling with the usage of <code>QuantumInstance</code> API.
This API is present in <code>qiskit version 0.32.1</code>
Below is small code:</p>
<pre><code>from qiskit.utils import QuantumInstance 
from qiskit import Aer
simulator_used = &quot;qasm_simulator&quot;
backend = Aer.get_backend(simulator_used)



quantum_instance = QuantumInstance(backend = backend,
                                   shots = 2000,
                                   seed_simulator= 28,
                                   seed_transpiler = 28,
                                   basis_gates = None,
                                   optimization_level =1)
</code></pre>
<p>Suppose, I want to make a simulator as <code>statevector_simulator</code>. Then do I have to make shots =1?</p>
<p>Suppose I want to use the <code>QuantumInstance</code> in the code below. Then how should I modify the code below? If <code>QuantumInstance</code> cannot be used in the code below, then where should it be used?</p>
<pre><code>from qiskit import Aer
from qiskit import execute
from qiskit import QuantumCircuit


circ = QuantumCircuit(3,3)
circ.h(0)
circ.cx(0,1)
circ.cx(0,2)

backend = Aer.get_backend(&quot;qasm_simulator&quot;)  

job = execute(circ, backend, shots = 100000)
result = job.result()
counts = result.get_counts(circ)
print(counts)
</code></pre>
",qc,use api qiskit p quite struggling usage code quantuminstance api api present code qiskit version small code pre code import quantuminstance qiskit import aer quot quot backend quantuminstance backend backend shots 2000 28 28 none p suppose want make simulator code make shots p suppose want use code quantuminstance code modify code code quantuminstance used code used pre code qiskit import aer qiskit import execute qiskit import quantumcircuit circ quantumcircuit 0 backend quot quot job execute circ backend shots 100000 result counts circ print counts,"[(0, 0.60009456), (14, 0.2713562), (16, 0.06619964), (19, 0.06047109)]"
37309,37312.0,2024-03-17 18:32:04,1,61,"<p>I am trying to understand the usage of <code>vqe.compute_minimum_eigenvalue</code>  API of qiskit for the statevector_simulator and qasm_simulator. I am only interested in the <code>eigenstate</code> and <code>eigenvalue</code>.
When I run the below code for <code>statevector_simulator</code>, I get the below as shown below:</p>
<pre><code>backend = Aer.get_backend(&quot;statevector_simulator&quot;)
    quantum_instance = QuantumInstance(backend= backend, 
                                       shots= 1
                                       seed_simulator= 28,    
                                       seed_transpiler= 28, 
                                       basis_gates= None,                                                 
                                       optimization_level=0)

    vqe = VQE(ansatz=ansatz_opt, 
                optimizer= optimizer,
                quantum_instance=quantum_instance,
                initial_point=initial_point_values
                )
    result = vqe.compute_minimum_eigenvalue(H_op)
    print(&quot;The value of result is =&quot;, result)
</code></pre>
<p>The value of result is:</p>
<pre><code>The value of result is = {   'aux_operator_eigenvalues': None,
    'cost_function_evals': 1352,
    'eigenstate': array([0.01715463+0.42191317j, 0.02261512+0.55615892j,
       0.02288142+0.56255103j, 0.01794385+0.44109138j]),
    'eigenvalue': (1.2502114e-10+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[3]): 1.8871963979619928,
                              ParameterVectorElement(θ[0]): 3.4198843373829284,
                              ParameterVectorElement(θ[2]): 4.2904615454665835,
                              ParameterVectorElement(θ[1]): 0.8448563317717608,
                              ParameterVectorElement(θ[4]): 3.448308970824199,
                              ParameterVectorElement(θ[5]): 3.5108928973122078,
                              ParameterVectorElement(θ[6]): 4.155936156778078,
                              ParameterVectorElement(θ[7]): 5.828853129364108,
                              ParameterVectorElement(θ[8]): 2.717512248330424,
                              ParameterVectorElement(θ[9]): 1.1104402869985177,
                              ParameterVectorElement(θ[10]): 0.35997873578438755,
                              ParameterVectorElement(θ[11]): 5.383757228721264,
                              ParameterVectorElement(θ[12]): 2.2265588674752292,
                              ParameterVectorElement(θ[13]): -0.524391503109095,
                              ParameterVectorElement(θ[14]): 2.721212459791864,
                              ParameterVectorElement(θ[15]): 1.584924993236795,
                              ParameterVectorElement(θ[16]): -0.49539861026959436,
                              ParameterVectorElement(θ[17]): 4.162724464416642,
                              ParameterVectorElement(θ[18]): 3.6325193273490144,
                              ParameterVectorElement(θ[19]): 6.662136048337769},
    'optimal_point': array([ 3.41988434,  0.84485633,  4.29046155,  1.8871964 ,  3.44830897,
        3.5108929 ,  4.15593616,  5.82885313,  2.71751225,  1.11044029,
        0.35997874,  5.38375723,  2.22655887, -0.5243915 ,  2.72121246,
        1.58492499, -0.49539861,  4.16272446,  3.63251933,  6.66213605]),
    'optimal_value': 1.2502114e-10,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 52.66859722137451}
</code></pre>
<p>But when I run the code for qasm_simulator, I get the results as below:</p>
<pre><code>backend = Aer.get_backend(&quot;qasm_simulator&quot;)
    quantum_instance = QuantumInstance(backend= backend, 
                                       shots= 1000000
                                       seed_simulator= 28,    
                                       seed_transpiler= 28, 
                                       basis_gates= None,                                                 
                                       optimization_level=0)

    vqe = VQE(ansatz=ansatz_opt, 
                optimizer= optimizer,
                quantum_instance=quantum_instance,
                initial_point=initial_point_values
                )
    result = vqe.compute_minimum_eigenvalue(H_op)
    print(&quot;The value of result is =&quot;, result)
</code></pre>
<p>The value of result is</p>
<pre><code>The value of result is = {   'aux_operator_eigenvalues': None,
    'cost_function_evals': 1,
    'eigenstate': {   '00': 0.13272528018429647,
                      '01': 0.3030214513858714,
                      '10': 0.7196895163888384,
                      '11': 0.610417070534565},
    'eigenvalue': (5.67387294600939+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[2]): 4.224454970398236,
                              ParameterVectorElement(θ[0]): 5.863937784019204,
                              ParameterVectorElement(θ[1]): 3.4455864378670014,
                              ParameterVectorElement(θ[4]): 0.506017439486799,
                              ParameterVectorElement(θ[3]): 2.3690675120103775,
                              ParameterVectorElement(θ[5]): 4.79940129981895,
                              ParameterVectorElement(θ[6]): 0.09967770119784523,
                              ParameterVectorElement(θ[7]): 1.8225430500149276,
                              ParameterVectorElement(θ[8]): 1.1087175676599133,
                              ParameterVectorElement(θ[9]): 2.650606283797435,
                              ParameterVectorElement(θ[10]): 1.932734623597688,
                              ParameterVectorElement(θ[11]): 4.6581354731326785,
                              ParameterVectorElement(θ[12]): 5.42013877739097,
                              ParameterVectorElement(θ[13]): 5.232441413652715,
                              ParameterVectorElement(θ[14]): 0.2577507460800755,
                              ParameterVectorElement(θ[15]): 3.8652580750273775,
                              ParameterVectorElement(θ[16]): 3.133086142322153,
                              ParameterVectorElement(θ[17]): 5.98592177389689,
                              ParameterVectorElement(θ[18]): 2.0935707919171658,
                              ParameterVectorElement(θ[19]): 0.40662390687216604},
    'optimal_point': array([5.86393778, 3.44558644, 4.22445497, 2.36906751, 0.50601744,
       4.7994013 , 0.0996777 , 1.82254305, 1.10871757, 2.65060628,
       1.93273462, 4.65813547, 5.42013878, 5.23244141, 0.25775075,
       3.86525808, 3.13308614, 5.98592177, 2.09357079, 0.40662391]),
    'optimal_value': 5.67387294600939,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 163.65113639831543}
</code></pre>
<p>What I understand looking at <code>statevector</code> values is that they are coefficients, but these values are not unifying (they are completely different results). I am not able to understand the reason? Is I am doing something wrong? Please guide me. Thank for great help.</p>
",vqe.compute_minimum_eigenvalue API of qiskit produces different eigenstate results for statevector_simulator ands qasm_simulator,<qiskit><programming><vqe>,1,0,,,"vqe.compute_minimum_eigenvalue API of qiskit produces different eigenstate results for statevector_simulator ands qasm_simulator <p>I am trying to understand the usage of <code>vqe.compute_minimum_eigenvalue</code>  API of qiskit for the statevector_simulator and qasm_simulator. I am only interested in the <code>eigenstate</code> and <code>eigenvalue</code>.
When I run the below code for <code>statevector_simulator</code>, I get the below as shown below:</p>
<pre><code>backend = Aer.get_backend(&quot;statevector_simulator&quot;)
    quantum_instance = QuantumInstance(backend= backend, 
                                       shots= 1
                                       seed_simulator= 28,    
                                       seed_transpiler= 28, 
                                       basis_gates= None,                                                 
                                       optimization_level=0)

    vqe = VQE(ansatz=ansatz_opt, 
                optimizer= optimizer,
                quantum_instance=quantum_instance,
                initial_point=initial_point_values
                )
    result = vqe.compute_minimum_eigenvalue(H_op)
    print(&quot;The value of result is =&quot;, result)
</code></pre>
<p>The value of result is:</p>
<pre><code>The value of result is = {   'aux_operator_eigenvalues': None,
    'cost_function_evals': 1352,
    'eigenstate': array([0.01715463+0.42191317j, 0.02261512+0.55615892j,
       0.02288142+0.56255103j, 0.01794385+0.44109138j]),
    'eigenvalue': (1.2502114e-10+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[3]): 1.8871963979619928,
                              ParameterVectorElement(θ[0]): 3.4198843373829284,
                              ParameterVectorElement(θ[2]): 4.2904615454665835,
                              ParameterVectorElement(θ[1]): 0.8448563317717608,
                              ParameterVectorElement(θ[4]): 3.448308970824199,
                              ParameterVectorElement(θ[5]): 3.5108928973122078,
                              ParameterVectorElement(θ[6]): 4.155936156778078,
                              ParameterVectorElement(θ[7]): 5.828853129364108,
                              ParameterVectorElement(θ[8]): 2.717512248330424,
                              ParameterVectorElement(θ[9]): 1.1104402869985177,
                              ParameterVectorElement(θ[10]): 0.35997873578438755,
                              ParameterVectorElement(θ[11]): 5.383757228721264,
                              ParameterVectorElement(θ[12]): 2.2265588674752292,
                              ParameterVectorElement(θ[13]): -0.524391503109095,
                              ParameterVectorElement(θ[14]): 2.721212459791864,
                              ParameterVectorElement(θ[15]): 1.584924993236795,
                              ParameterVectorElement(θ[16]): -0.49539861026959436,
                              ParameterVectorElement(θ[17]): 4.162724464416642,
                              ParameterVectorElement(θ[18]): 3.6325193273490144,
                              ParameterVectorElement(θ[19]): 6.662136048337769},
    'optimal_point': array([ 3.41988434,  0.84485633,  4.29046155,  1.8871964 ,  3.44830897,
        3.5108929 ,  4.15593616,  5.82885313,  2.71751225,  1.11044029,
        0.35997874,  5.38375723,  2.22655887, -0.5243915 ,  2.72121246,
        1.58492499, -0.49539861,  4.16272446,  3.63251933,  6.66213605]),
    'optimal_value': 1.2502114e-10,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 52.66859722137451}
</code></pre>
<p>But when I run the code for qasm_simulator, I get the results as below:</p>
<pre><code>backend = Aer.get_backend(&quot;qasm_simulator&quot;)
    quantum_instance = QuantumInstance(backend= backend, 
                                       shots= 1000000
                                       seed_simulator= 28,    
                                       seed_transpiler= 28, 
                                       basis_gates= None,                                                 
                                       optimization_level=0)

    vqe = VQE(ansatz=ansatz_opt, 
                optimizer= optimizer,
                quantum_instance=quantum_instance,
                initial_point=initial_point_values
                )
    result = vqe.compute_minimum_eigenvalue(H_op)
    print(&quot;The value of result is =&quot;, result)
</code></pre>
<p>The value of result is</p>
<pre><code>The value of result is = {   'aux_operator_eigenvalues': None,
    'cost_function_evals': 1,
    'eigenstate': {   '00': 0.13272528018429647,
                      '01': 0.3030214513858714,
                      '10': 0.7196895163888384,
                      '11': 0.610417070534565},
    'eigenvalue': (5.67387294600939+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[2]): 4.224454970398236,
                              ParameterVectorElement(θ[0]): 5.863937784019204,
                              ParameterVectorElement(θ[1]): 3.4455864378670014,
                              ParameterVectorElement(θ[4]): 0.506017439486799,
                              ParameterVectorElement(θ[3]): 2.3690675120103775,
                              ParameterVectorElement(θ[5]): 4.79940129981895,
                              ParameterVectorElement(θ[6]): 0.09967770119784523,
                              ParameterVectorElement(θ[7]): 1.8225430500149276,
                              ParameterVectorElement(θ[8]): 1.1087175676599133,
                              ParameterVectorElement(θ[9]): 2.650606283797435,
                              ParameterVectorElement(θ[10]): 1.932734623597688,
                              ParameterVectorElement(θ[11]): 4.6581354731326785,
                              ParameterVectorElement(θ[12]): 5.42013877739097,
                              ParameterVectorElement(θ[13]): 5.232441413652715,
                              ParameterVectorElement(θ[14]): 0.2577507460800755,
                              ParameterVectorElement(θ[15]): 3.8652580750273775,
                              ParameterVectorElement(θ[16]): 3.133086142322153,
                              ParameterVectorElement(θ[17]): 5.98592177389689,
                              ParameterVectorElement(θ[18]): 2.0935707919171658,
                              ParameterVectorElement(θ[19]): 0.40662390687216604},
    'optimal_point': array([5.86393778, 3.44558644, 4.22445497, 2.36906751, 0.50601744,
       4.7994013 , 0.0996777 , 1.82254305, 1.10871757, 2.65060628,
       1.93273462, 4.65813547, 5.42013878, 5.23244141, 0.25775075,
       3.86525808, 3.13308614, 5.98592177, 2.09357079, 0.40662391]),
    'optimal_value': 5.67387294600939,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 163.65113639831543}
</code></pre>
<p>What I understand looking at <code>statevector</code> values is that they are coefficients, but these values are not unifying (they are completely different results). I am not able to understand the reason? Is I am doing something wrong? Please guide me. Thank for great help.</p>
",qc,api qiskit produces different eigenstate results ands p trying understand usage code api qiskit interested code eigenstate code eigenvalue run code code get shown pre code backend quot quot quantuminstance backend 1 28 28 none vqe vqe optimizer result print quot value result quot result p value result pre code value result none 1352 array none parametervectorelement θ 3 parametervectorelement θ 0 parametervectorelement θ 2 parametervectorelement θ 1 parametervectorelement θ 4 parametervectorelement θ 5 parametervectorelement θ 6 parametervectorelement θ 7 parametervectorelement θ 8 parametervectorelement θ 9 parametervectorelement θ 10 parametervectorelement θ 11 parametervectorelement θ 12 parametervectorelement θ 13 parametervectorelement θ 14 parametervectorelement θ 15 parametervectorelement θ 16 parametervectorelement θ 17 parametervectorelement θ 18 parametervectorelement θ 19 array none none p run code get results pre code backend quot quot quantuminstance backend 1000000 28 28 none vqe vqe optimizer result print quot value result quot result p value result pre code value result none 1 none parametervectorelement θ 2 parametervectorelement θ 0 parametervectorelement θ 1 parametervectorelement θ 4 parametervectorelement θ 3 parametervectorelement θ 5 parametervectorelement θ 6 parametervectorelement θ 7 parametervectorelement θ 8 parametervectorelement θ 9 parametervectorelement θ 10 parametervectorelement θ 11 parametervectorelement θ 12 parametervectorelement θ 13 parametervectorelement θ 14 parametervectorelement θ 15 parametervectorelement θ 16 parametervectorelement θ 17 parametervectorelement θ 18 parametervectorelement θ 19 array none none p understand looking code statevector values coefficients values unifying completely different results able understand reason something wrong please guide thank great,"[(0, 0.25959152), (6, 0.18045215), (16, 0.51301384), (19, 0.043060895)]"
37340,37341.0,2024-03-18 21:50:31,1,50,"<p>I am trying to do some state tomography to generate GHZ states and calculate fidelity. For running the code, I want to execute my code with the qubits with the lowest readout error using initial layout in the transpilation process. However, I arrive at this error and I can not specify the qubits .</p>
<pre><code>Traceback (most recent call last):
  Cell In[28], line 2
    best_qc = transpile(st, backend, initial_layout=[90,94,95])
  File /opt/conda/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:338 in transpile
    output_name = _parse_output_name(output_name, circuits)
  File /opt/conda/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:593 in _parse_output_name
    return [circuit.name for circuit in circuits]
  File /opt/conda/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:593 in &lt;listcomp&gt;
    return [circuit.name for circuit in circuits]
AttributeError: 'StateTomography' object has no attribute 'name' 




from qiskit import *
from qiskit.visualization import array_to_latex
from qiskit_experiments.library import StateTomography
q1 = QuantumRegister(1)
q2 = QuantumRegister(1)
q3 = QuantumRegister(1)
c = ClassicalRegister(3)
qc = QuantumCircuit(q1, q2, q3, c)
qc.h(q1)
qc.cx(q1, q2)
qc.ccx(q1, q2, q3)
st = StateTomography(qc)
best_qc = transpile(st, backend, initial_layout=[90,94,95])
stdata = st.run(backend).block_for_results()
state_result = stdata.analysis_results(&quot;state&quot;)
array_to_latex(state_result.value)
fid_result = stdata.analysis_results(&quot;state_fidelity&quot;)
print(f&quot;state Fidelity = {fid_result.value}&quot;) 




                                                                                                                                                                                                                                                                                                                                                                                              
</code></pre>
",Set Initial Layout for State Tomography,<qiskit><ibm-quantum-devices><qiskit-runtime>,1,0,,,"Set Initial Layout for State Tomography <p>I am trying to do some state tomography to generate GHZ states and calculate fidelity. For running the code, I want to execute my code with the qubits with the lowest readout error using initial layout in the transpilation process. However, I arrive at this error and I can not specify the qubits .</p>
<pre><code>Traceback (most recent call last):
  Cell In[28], line 2
    best_qc = transpile(st, backend, initial_layout=[90,94,95])
  File /opt/conda/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:338 in transpile
    output_name = _parse_output_name(output_name, circuits)
  File /opt/conda/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:593 in _parse_output_name
    return [circuit.name for circuit in circuits]
  File /opt/conda/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:593 in &lt;listcomp&gt;
    return [circuit.name for circuit in circuits]
AttributeError: 'StateTomography' object has no attribute 'name' 




from qiskit import *
from qiskit.visualization import array_to_latex
from qiskit_experiments.library import StateTomography
q1 = QuantumRegister(1)
q2 = QuantumRegister(1)
q3 = QuantumRegister(1)
c = ClassicalRegister(3)
qc = QuantumCircuit(q1, q2, q3, c)
qc.h(q1)
qc.cx(q1, q2)
qc.ccx(q1, q2, q3)
st = StateTomography(qc)
best_qc = transpile(st, backend, initial_layout=[90,94,95])
stdata = st.run(backend).block_for_results()
state_result = stdata.analysis_results(&quot;state&quot;)
array_to_latex(state_result.value)
fid_result = stdata.analysis_results(&quot;state_fidelity&quot;)
print(f&quot;state Fidelity = {fid_result.value}&quot;) 




                                                                                                                                                                                                                                                                                                                                                                                              
</code></pre>
",qc,set initial layout state tomography p trying state tomography generate ghz states calculate fidelity running code want execute code qubits lowest readout error using initial layout transpilation process however arrive error specify qubits pre code traceback recent call last cell 28 line 2 transpile st backend file transpile circuits file return circuit circuits file lt listcomp gt return circuit circuits attributeerror object attribute qiskit import import import statetomography q1 quantumregister 1 q2 quantumregister 1 q3 quantumregister 1 c classicalregister 3 qc quantumcircuit q1 q2 q3 c q1 q1 q2 q1 q2 q3 st statetomography qc transpile st backend stdata backend quot state quot quot quot print f quot state fidelity quot,"[(0, 0.39198095), (2, 0.025602857), (14, 0.38581598), (16, 0.054428056), (18, 0.048047192), (19, 0.09286437)]"
37357,,2024-03-19 16:06:10,1,64,"<p>I am just trying to calculate the highest fidelity of preparing GHZ states on IBM quantum computers and I run my circuit on qubits with the lowest readout error. However, I just obtain fidelity of the state about 0.5 to 0.6. like the following:</p>
<p>state Fidelity = 0.5924363421816463</p>
<p>is it OK? or I am doing something wrong. Because I suppose it must be higher than this.</p>
<p>Here is my code:</p>
<pre><code>q1 = QuantumRegister(1)
q2 = QuantumRegister(1)
q3 = QuantumRegister(1)
c = ClassicalRegister(3)
qc = QuantumCircuit(q1, q2, q3, c)
qc.h(q1)
qc.cx(q1, q2)
qc.ccx(q1, q2, q3)
st = StateTomography(qc, physical_qubits=[85, 84, 83])
stdata = st.run(backend).block_for_results()
state_result = stdata.analysis_results(&quot;state&quot;)
array_to_latex(state_result.value)
fid_result = stdata.analysis_results(&quot;state_fidelity&quot;)
print(f&quot;state Fidelity = {fid_result.value}&quot;)
</code></pre>
",Low Fidelity In IBM Quantum Computers,<qiskit><ibm-q-experience><ibm-quantum-devices><qiskit-runtime>,0,3,,,"Low Fidelity In IBM Quantum Computers <p>I am just trying to calculate the highest fidelity of preparing GHZ states on IBM quantum computers and I run my circuit on qubits with the lowest readout error. However, I just obtain fidelity of the state about 0.5 to 0.6. like the following:</p>
<p>state Fidelity = 0.5924363421816463</p>
<p>is it OK? or I am doing something wrong. Because I suppose it must be higher than this.</p>
<p>Here is my code:</p>
<pre><code>q1 = QuantumRegister(1)
q2 = QuantumRegister(1)
q3 = QuantumRegister(1)
c = ClassicalRegister(3)
qc = QuantumCircuit(q1, q2, q3, c)
qc.h(q1)
qc.cx(q1, q2)
qc.ccx(q1, q2, q3)
st = StateTomography(qc, physical_qubits=[85, 84, 83])
stdata = st.run(backend).block_for_results()
state_result = stdata.analysis_results(&quot;state&quot;)
array_to_latex(state_result.value)
fid_result = stdata.analysis_results(&quot;state_fidelity&quot;)
print(f&quot;state Fidelity = {fid_result.value}&quot;)
</code></pre>
",qc,low fidelity ibm quantum computers p trying calculate highest fidelity preparing ghz states ibm quantum computers run circuit qubits lowest readout error however obtain fidelity state like following p state fidelity p ok something wrong suppose must higher p code pre code q1 quantumregister 1 q2 quantumregister 1 q3 quantumregister 1 c classicalregister 3 qc quantumcircuit q1 q2 q3 c q1 q1 q2 q1 q2 q3 st statetomography qc 85 84 83 stdata backend quot state quot quot quot print f quot state fidelity quot,"[(0, 0.17848317), (1, 0.029135553), (2, 0.03880416), (8, 0.0341112), (12, 0.011887171), (14, 0.4605806), (16, 0.06503208), (18, 0.08059653), (19, 0.100076094)]"
37372,,2024-03-20 09:05:43,1,67,"<p><a href=""https://Cirq%20compilation%20process"" rel=""nofollow noreferrer"">Cirq</a> compilation process.</p>
<p>I cannot find the documentation that describes the internal structure of <a href=""https://github.com/quantumlib/Cirq"" rel=""nofollow noreferrer"">the library Cirq by Google</a>.</p>
<p>There is much information related to high level functions, but none related to the compiler step and how the circuit is decomposed, and translated to an Intermediate Representation. If someone knows, where to find this information it would be very helpful?</p>
",How does the cirq compilation process work?,<cirq><compiling>,1,0,,,"How does the cirq compilation process work? <p><a href=""https://Cirq%20compilation%20process"" rel=""nofollow noreferrer"">Cirq</a> compilation process.</p>
<p>I cannot find the documentation that describes the internal structure of <a href=""https://github.com/quantumlib/Cirq"" rel=""nofollow noreferrer"">the library Cirq by Google</a>.</p>
<p>There is much information related to high level functions, but none related to the compiler step and how the circuit is decomposed, and translated to an Intermediate Representation. If someone knows, where to find this information it would be very helpful?</p>
",qc,cirq compilation process work p https 20compilation 20process nofollow noreferrer cirq compilation p find documentation describes internal structure https nofollow noreferrer library cirq google p much information related high level functions none related compiler step circuit decomposed translated intermediate representation someone knows find information would helpful,"[(4, 0.20751537), (8, 0.33798262), (13, 0.08687128), (14, 0.2853518), (16, 0.07888384)]"
37436,37437.0,2024-03-24 21:17:04,1,227,"<p>I am examining a simple circuit using both Qiskit and the AWS Braket SDK (Python).  The circuit is very simple.</p>
<pre><code>T  : |0|1|
          
q0 : -C-C-
      | | 
q1 : -Z-|-
        | 
q2 : ---Z-
</code></pre>
<p>I trying to find the equivalent unitary operator for this circuit.  I get different answers from Qiskit and AWS Braket SDK and I don't know why.</p>
<p>Here is my Qiskit code:</p>
<pre><code>from qiskit import *
qr = QuantumRegister(3, 'q')
cr = ClassicalRegister(0, 'c')
circuit = QuantumCircuit(qr, cr)
circuit.cz(qr[0], qr[1])
circuit.cz(qr[0], qr[2])

simulator = Aer.get_backend('unitary_simulator')
result = execute(circuit, backend = simulator).result() 
matprint(result.get_unitary().data)

def matprint(mat, fmt=&quot;g&quot;):
    col_maxes = [max([len((&quot;{:&quot;+fmt+&quot;}&quot;).format(x)) for x in col]) for col in mat.T]
    for x in mat:
        for i, y in enumerate(x):
            print((&quot;{:&quot;+str(col_maxes[i])+fmt+&quot;}&quot;).format(y), end=&quot;  &quot;)
        print(&quot;&quot;)
</code></pre>
<p>The Qiskit result is:</p>
<pre><code> 1+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
 0+0j   1+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
 0+0j   0+0j   1+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
-0+0j  -0+0j  -0+0j  -1+0j  -0+0j  -0+0j  -0+0j  -0+0j  
 0+0j   0+0j   0+0j   0+0j   1+0j   0+0j   0+0j   0+0j  
-0+0j  -0+0j  -0+0j  -0+0j  -0+0j  -1+0j  -0+0j  -0+0j  
 0+0j   0+0j   0+0j   0+0j   0+0j   0+0j   1+0j   0+0j  
 0-0j   0-0j   0-0j   0-0j   0-0j   0-0j   0-0j   1-0j  
</code></pre>
<p>This is what I expected from my hand-calculations.  However, when using AWS Braket SDK I get something different.  The Braket code:</p>
<pre><code>from braket.circuits import Circuit
db=Circuit().cz(0,1).cz(0,2)
print(db.to_unitary())
</code></pre>
<p>The result is:</p>
<pre><code>[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]
</code></pre>
<p>I believe the Qiskit answer is correct because it is consistent with &quot;I kron CZ&quot; for the first operation.  If I do &quot;CZ kron I&quot; for the first operation I get the Braket answer.</p>
<p>I am new to quantum computing and would find an explanation valuable.</p>
",Quantum Circuit evaluation Qiskit vs. AWS Braket SDK,<qiskit><quantum-gate><programming><amazon-braket>,1,0,,,"Quantum Circuit evaluation Qiskit vs. AWS Braket SDK <p>I am examining a simple circuit using both Qiskit and the AWS Braket SDK (Python).  The circuit is very simple.</p>
<pre><code>T  : |0|1|
          
q0 : -C-C-
      | | 
q1 : -Z-|-
        | 
q2 : ---Z-
</code></pre>
<p>I trying to find the equivalent unitary operator for this circuit.  I get different answers from Qiskit and AWS Braket SDK and I don't know why.</p>
<p>Here is my Qiskit code:</p>
<pre><code>from qiskit import *
qr = QuantumRegister(3, 'q')
cr = ClassicalRegister(0, 'c')
circuit = QuantumCircuit(qr, cr)
circuit.cz(qr[0], qr[1])
circuit.cz(qr[0], qr[2])

simulator = Aer.get_backend('unitary_simulator')
result = execute(circuit, backend = simulator).result() 
matprint(result.get_unitary().data)

def matprint(mat, fmt=&quot;g&quot;):
    col_maxes = [max([len((&quot;{:&quot;+fmt+&quot;}&quot;).format(x)) for x in col]) for col in mat.T]
    for x in mat:
        for i, y in enumerate(x):
            print((&quot;{:&quot;+str(col_maxes[i])+fmt+&quot;}&quot;).format(y), end=&quot;  &quot;)
        print(&quot;&quot;)
</code></pre>
<p>The Qiskit result is:</p>
<pre><code> 1+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
 0+0j   1+0j   0+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
 0+0j   0+0j   1+0j   0+0j   0+0j   0+0j   0+0j   0+0j  
-0+0j  -0+0j  -0+0j  -1+0j  -0+0j  -0+0j  -0+0j  -0+0j  
 0+0j   0+0j   0+0j   0+0j   1+0j   0+0j   0+0j   0+0j  
-0+0j  -0+0j  -0+0j  -0+0j  -0+0j  -1+0j  -0+0j  -0+0j  
 0+0j   0+0j   0+0j   0+0j   0+0j   0+0j   1+0j   0+0j  
 0-0j   0-0j   0-0j   0-0j   0-0j   0-0j   0-0j   1-0j  
</code></pre>
<p>This is what I expected from my hand-calculations.  However, when using AWS Braket SDK I get something different.  The Braket code:</p>
<pre><code>from braket.circuits import Circuit
db=Circuit().cz(0,1).cz(0,2)
print(db.to_unitary())
</code></pre>
<p>The result is:</p>
<pre><code>[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j -1.+0.j  0.+0.j]
 [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]
</code></pre>
<p>I believe the Qiskit answer is correct because it is consistent with &quot;I kron CZ&quot; for the first operation.  If I do &quot;CZ kron I&quot; for the first operation I get the Braket answer.</p>
<p>I am new to quantum computing and would find an explanation valuable.</p>
",qc,quantum circuit evaluation qiskit aws braket sdk p examining simple circuit using qiskit aws braket sdk python circuit pre code q0 q1 q2 p trying find equivalent unitary operator circuit get different answers qiskit aws braket sdk know p qiskit code pre code qiskit import qr quantumregister 3 q cr classicalregister 0 c circuit quantumcircuit qr cr qr 0 qr 1 qr 0 qr 2 simulator result execute circuit backend simulator matprint def matprint mat quot g quot max len quot quot quot quot x x col col x mat enumerate x print quot quot quot quot quot quot print quot quot p qiskit result pre code p expected however using aws braket sdk get something different braket code pre code import circuit print p result pre code p believe qiskit answer correct consistent quot kron cz quot first operation quot cz kron quot first operation get braket p new quantum computing would find explanation,"[(0, 0.322181), (2, 0.030592203), (6, 0.014676508), (10, 0.036892954), (13, 0.021832764), (14, 0.36698672), (15, 0.01584465), (16, 0.019672321), (19, 0.17060202)]"
37449,,2024-03-25 12:32:27,0,42,"<p>Suppose we have a state that is written as:
<span class=""math-container"">\begin{eqnarray}
|\Psi\rangle=\frac{1}{\mathcal{N}}\sum_{\mathcal{P}}e^{i\phi_p}\phi_{1p}(x_{1p})\phi_{2p}(x_{2p})...\phi_{N_p}(x_{N_p})|x_{1p}...x_{Np}\rangle,
\end{eqnarray}</span>
with <span class=""math-container"">$\mathcal{N}$</span> a normalization factor, and <span class=""math-container"">$\mathcal{P}$</span> sum over all permutations of indices <span class=""math-container"">$1,2,...,N$</span>, and <span class=""math-container"">$\phi_p$</span> an arbitrary phase depending on the permutation. Suppose we have full knowledge of the individual states <span class=""math-container"">$\phi(x_{jp})$</span> stored as 1D vectors. For fermions, such state reduces to the Slater determinant. What is the efficient way to compute probabilities or observables in that case, since the state has dimension <span class=""math-container"">$x^N$</span>? For instance, how to compute the probability <span class=""math-container"">$P(x_0)$</span> for a given <span class=""math-container"">$x_0$</span> taking into account all individual state amplitudes? In particular, this means that we compute a sum of amplitudes for which a state <span class=""math-container"">$x_0$</span> is present (i.e. non-zero) in any of the <span class=""math-container"">$N$</span> particle states, and then we compute the absolute value of such amplitude sum. Something like an amplitude <span class=""math-container"">$A(x_0)=\phi(x_0)\sum_{x_2,...,x_N}\phi(x_{2})...\phi(x_{N})$</span> + ... where <span class=""math-container"">$x_0$</span> will be present in all N particle spaces. This also includes doubly occupied cases, where for example two of the particles occupy <span class=""math-container"">$x_0$</span> but not the others.</p>
<p>Is there any good reference on how to do this efficiently?</p>
<p>EDIT: The values of each <span class=""math-container"">$x_j$</span> might correspond to a lattice, for simplicity taken from the set <span class=""math-container"">$x_j\in [0,1,...,M]$</span>. The special point <span class=""math-container"">$x_0$</span> just represent one point of the lattice, for instance it can be <span class=""math-container"">$x_0=0$</span>. Any particle therefore has a Hilbert space of dimension <span class=""math-container"">$M+1$</span>, with <span class=""math-container"">$\phi(x_j)$</span> the coefficient corresponding to state <span class=""math-container"">$|x_j\rangle$</span> for one of the particles. In this context, a state <span class=""math-container"">$|x_0\rangle$</span> present for one particle means that <span class=""math-container"">$\phi(x_0)\neq 0$</span>. Therefore, we look for the sum of probability amplitudes (i.e. sum of coefficients products) that contain at least one <span class=""math-container"">$x_0$</span> in all possible strings products of <span class=""math-container"">$\phi(x_1)...\phi(x_N)$</span>. Such amplitude is named <span class=""math-container"">$A(x_0)$</span> and the associated probability is <span class=""math-container"">$P(x_0)=A^*(x_0)A(x_0)$</span>.</p>
",Efficient computation of probabilities for an N-particle state,<quantum-state>,1,0,,,"Efficient computation of probabilities for an N-particle state <p>Suppose we have a state that is written as:
<span class=""math-container"">\begin{eqnarray}
|\Psi\rangle=\frac{1}{\mathcal{N}}\sum_{\mathcal{P}}e^{i\phi_p}\phi_{1p}(x_{1p})\phi_{2p}(x_{2p})...\phi_{N_p}(x_{N_p})|x_{1p}...x_{Np}\rangle,
\end{eqnarray}</span>
with <span class=""math-container"">$\mathcal{N}$</span> a normalization factor, and <span class=""math-container"">$\mathcal{P}$</span> sum over all permutations of indices <span class=""math-container"">$1,2,...,N$</span>, and <span class=""math-container"">$\phi_p$</span> an arbitrary phase depending on the permutation. Suppose we have full knowledge of the individual states <span class=""math-container"">$\phi(x_{jp})$</span> stored as 1D vectors. For fermions, such state reduces to the Slater determinant. What is the efficient way to compute probabilities or observables in that case, since the state has dimension <span class=""math-container"">$x^N$</span>? For instance, how to compute the probability <span class=""math-container"">$P(x_0)$</span> for a given <span class=""math-container"">$x_0$</span> taking into account all individual state amplitudes? In particular, this means that we compute a sum of amplitudes for which a state <span class=""math-container"">$x_0$</span> is present (i.e. non-zero) in any of the <span class=""math-container"">$N$</span> particle states, and then we compute the absolute value of such amplitude sum. Something like an amplitude <span class=""math-container"">$A(x_0)=\phi(x_0)\sum_{x_2,...,x_N}\phi(x_{2})...\phi(x_{N})$</span> + ... where <span class=""math-container"">$x_0$</span> will be present in all N particle spaces. This also includes doubly occupied cases, where for example two of the particles occupy <span class=""math-container"">$x_0$</span> but not the others.</p>
<p>Is there any good reference on how to do this efficiently?</p>
<p>EDIT: The values of each <span class=""math-container"">$x_j$</span> might correspond to a lattice, for simplicity taken from the set <span class=""math-container"">$x_j\in [0,1,...,M]$</span>. The special point <span class=""math-container"">$x_0$</span> just represent one point of the lattice, for instance it can be <span class=""math-container"">$x_0=0$</span>. Any particle therefore has a Hilbert space of dimension <span class=""math-container"">$M+1$</span>, with <span class=""math-container"">$\phi(x_j)$</span> the coefficient corresponding to state <span class=""math-container"">$|x_j\rangle$</span> for one of the particles. In this context, a state <span class=""math-container"">$|x_0\rangle$</span> present for one particle means that <span class=""math-container"">$\phi(x_0)\neq 0$</span>. Therefore, we look for the sum of probability amplitudes (i.e. sum of coefficients products) that contain at least one <span class=""math-container"">$x_0$</span> in all possible strings products of <span class=""math-container"">$\phi(x_1)...\phi(x_N)$</span>. Such amplitude is named <span class=""math-container"">$A(x_0)$</span> and the associated probability is <span class=""math-container"">$P(x_0)=A^*(x_0)A(x_0)$</span>.</p>
",qc,efficient computation probabilities state p suppose state written span eqnarray 1 n p 1p 1p 2p 2p 1p np eqnarray span n normalization factor span p sum permutations indices span n span arbitrary phase depending permutation suppose full knowledge individual states span jp stored 1d vectors fermions state reduces slater determinant efficient way compute probabilities observables case since state dimension span instance compute probability span p given span taking account individual state amplitudes particular means compute sum amplitudes state span present span n particle states compute absolute value amplitude sum something like amplitude span 2 n span present n particle spaces also includes doubly occupied cases example two particles occupy span p good reference efficiently p edit values span might correspond lattice simplicity taken set span special point span represent one point lattice instance span particle therefore hilbert space dimension span span coefficient corresponding state span one particles context state span present one particle means span 0 therefore look sum probability amplitudes sum coefficients products contain least one span possible strings products span amplitude named span associated probability span p,"[(1, 0.024700427), (3, 0.75350434), (9, 0.016177086), (13, 0.063276015), (16, 0.011269779), (18, 0.12348148)]"
37488,,2024-03-27 15:25:51,3,67,"<h1>Background</h1>
<p>Theorem 4.1 of Nielsen and Chuang (10th Anniversary Edition) states how a universal single-qubit unitary can be constructed from Y and Z rotations.</p>
<blockquote>
<p>Suppose <span class=""math-container"">$U$</span> is a unitary operation on a single qubit. Then there exist real numbers <span class=""math-container"">$\alpha, \beta, \gamma, \delta$</span> such that <span class=""math-container"">$$U = e^{i \alpha} R_z(\beta) R_y(\gamma) R_z(\delta) $$</span></p>
</blockquote>
<p>I am trying to prove this by deriving an equivalence with a previous result which states that a universal unitary can also be represented as
<span class=""math-container"">$$U = \exp(i\alpha) R_{\hat{n}}(\theta)$$</span> where <span class=""math-container"">$\hat{n} = \left(n_x, n_y, n_z\right)$</span> is a real unit vector and <span class=""math-container"">$R_{\hat{n}}(\theta) = \cos{\frac{\theta}{2}} I - i\sin{\frac{\theta}{2}}\left(n_x X + n_y Y + n_z Z\right)$</span></p>
<h1>My Approach</h1>
<p>I tried to expand the expression <span class=""math-container"">$R_z(\beta) R_y(\gamma) R_z(\delta)$</span>
Let
<span class=""math-container"">$$R_z(\beta) R_y(\gamma) R_z(\delta) = \left(\cos{\frac{\beta}{2}}I - i \sin{\frac{\beta}{2}}Z \right)\left(\cos{\frac{\gamma}{2}}I - i \sin{\frac{\gamma}{2}}Y \right)\left(\cos{\frac{\delta}{2}}I - i \sin{\frac{\delta}{2}}Z \right)$$</span>
On expanding and using trigonometric identities as well as identities for Pauli matrices:
<span class=""math-container"">$$R_z(\beta) R_y(\gamma) R_z(\delta) = \cos{\frac{\gamma}{2}}\cos{\frac{\beta+\delta}{2}}I - i \left[\sin{\frac{\gamma}{2}}\sin{\frac{\delta-\beta}{2}}X + \sin{\frac{\gamma}{2}}\cos{\frac{\delta-\beta}{2}}Y + \cos{\frac{\gamma}{2}}\sin{\frac{\delta+\beta}{2}}Z \right]$$</span>
I see that this is vaguely similar to the unitary one gets by rotating about an arbitrary unit vector but I cannot find a mapping between the parameters <span class=""math-container"">$\beta, \gamma, \delta$</span> and the parameters <span class=""math-container"">$\theta, \hat{n}$</span> which would allow me to prove that both formulations for a universal unitary are equivalent.</p>
<p>How do I proceed from here?</p>
",Trying to prove Theorem 4.1 from Nielsen and Chuang algebraically,<linear-algebra><pauli-gates><universal-gates>,0,1,,,"Trying to prove Theorem 4.1 from Nielsen and Chuang algebraically <h1>Background</h1>
<p>Theorem 4.1 of Nielsen and Chuang (10th Anniversary Edition) states how a universal single-qubit unitary can be constructed from Y and Z rotations.</p>
<blockquote>
<p>Suppose <span class=""math-container"">$U$</span> is a unitary operation on a single qubit. Then there exist real numbers <span class=""math-container"">$\alpha, \beta, \gamma, \delta$</span> such that <span class=""math-container"">$$U = e^{i \alpha} R_z(\beta) R_y(\gamma) R_z(\delta) $$</span></p>
</blockquote>
<p>I am trying to prove this by deriving an equivalence with a previous result which states that a universal unitary can also be represented as
<span class=""math-container"">$$U = \exp(i\alpha) R_{\hat{n}}(\theta)$$</span> where <span class=""math-container"">$\hat{n} = \left(n_x, n_y, n_z\right)$</span> is a real unit vector and <span class=""math-container"">$R_{\hat{n}}(\theta) = \cos{\frac{\theta}{2}} I - i\sin{\frac{\theta}{2}}\left(n_x X + n_y Y + n_z Z\right)$</span></p>
<h1>My Approach</h1>
<p>I tried to expand the expression <span class=""math-container"">$R_z(\beta) R_y(\gamma) R_z(\delta)$</span>
Let
<span class=""math-container"">$$R_z(\beta) R_y(\gamma) R_z(\delta) = \left(\cos{\frac{\beta}{2}}I - i \sin{\frac{\beta}{2}}Z \right)\left(\cos{\frac{\gamma}{2}}I - i \sin{\frac{\gamma}{2}}Y \right)\left(\cos{\frac{\delta}{2}}I - i \sin{\frac{\delta}{2}}Z \right)$$</span>
On expanding and using trigonometric identities as well as identities for Pauli matrices:
<span class=""math-container"">$$R_z(\beta) R_y(\gamma) R_z(\delta) = \cos{\frac{\gamma}{2}}\cos{\frac{\beta+\delta}{2}}I - i \left[\sin{\frac{\gamma}{2}}\sin{\frac{\delta-\beta}{2}}X + \sin{\frac{\gamma}{2}}\cos{\frac{\delta-\beta}{2}}Y + \cos{\frac{\gamma}{2}}\sin{\frac{\delta+\beta}{2}}Z \right]$$</span>
I see that this is vaguely similar to the unitary one gets by rotating about an arbitrary unit vector but I cannot find a mapping between the parameters <span class=""math-container"">$\beta, \gamma, \delta$</span> and the parameters <span class=""math-container"">$\theta, \hat{n}$</span> which would allow me to prove that both formulations for a universal unitary are equivalent.</p>
<p>How do I proceed from here?</p>
",qc,trying prove theorem nielsen chuang algebraically h1 background p theorem nielsen chuang 10th anniversary edition states universal unitary constructed z blockquote p suppose span u unitary operation single qubit exist real numbers span span u p trying prove deriving equivalence previous result states universal unitary also represented span u n span n real unit vector span n 2 2 x h1 approach p tried expand expression span let span 2 2 z 2 2 2 2 z expanding using trigonometric identities well identities pauli matrices span 2 2 2 2 x 2 2 2 2 z see vaguely similar unitary one gets rotating arbitrary unit vector find mapping parameters span parameters span n would allow prove formulations universal unitary p proceed,"[(2, 0.13810332), (3, 0.708157), (9, 0.118910685), (10, 0.018844185), (16, 0.0147362575)]"
37524,37585.0,2024-03-29 08:32:10,2,462,"<p>Right now I'm trying to figure out how to create custom fake backends using qiskit with data we are retrieving from our real backends in the laboratory.<br />
As I understand, the best way to create one is to use <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2"" rel=""nofollow noreferrer""><code>GenericBackendV2</code></a>.</p>
<p>Documentations says, that we can specify:</p>
<ul>
<li>Number of qubits</li>
<li>List of basis gate names</li>
<li>Coupling map for the backend</li>
<li>Instruction calibration settings</li>
</ul>
<p>But what about other characteristics? For instance, I want to set T1 / T2 times or each qubit's frequency and maybe even some measurement errors.</p>
<p>Documentations says:</p>
<blockquote>
<p>The remainder of the backend properties are generated by randomly
sampling from default ranges extracted from historical IBM backend
data.</p>
</blockquote>
<p>But can I somehow set it manually?</p>
",How to create custom fake backend?,<qiskit><programming>,2,0,,,"How to create custom fake backend? <p>Right now I'm trying to figure out how to create custom fake backends using qiskit with data we are retrieving from our real backends in the laboratory.<br />
As I understand, the best way to create one is to use <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2"" rel=""nofollow noreferrer""><code>GenericBackendV2</code></a>.</p>
<p>Documentations says, that we can specify:</p>
<ul>
<li>Number of qubits</li>
<li>List of basis gate names</li>
<li>Coupling map for the backend</li>
<li>Instruction calibration settings</li>
</ul>
<p>But what about other characteristics? For instance, I want to set T1 / T2 times or each qubit's frequency and maybe even some measurement errors.</p>
<p>Documentations says:</p>
<blockquote>
<p>The remainder of the backend properties are generated by randomly
sampling from default ranges extracted from historical IBM backend
data.</p>
</blockquote>
<p>But can I somehow set it manually?</p>
",qc,create custom fake backend p right trying figure create custom fake backends using qiskit data retrieving real backends br understand best way create one use https nofollow noreferrer code genericbackendv2 p documentations says specify ul li number qubits li list basis gate names li coupling map backend li instruction calibration settings p characteristics instance want set t1 t2 times qubit frequency maybe even measurement p documentations says blockquote p remainder backend properties generated randomly sampling default ranges extracted historical ibm backend p somehow set manually,"[(0, 0.02930228), (7, 0.08547155), (9, 0.23502731), (14, 0.62111604), (16, 0.027318774)]"
37541,37542.0,2024-03-30 09:57:27,1,58,"<p>The textbook says that since <span class=""math-container"">$U$</span> is a unitary matrix, its eigenvalue should be of the form <span class=""math-container"">$e^{2 \pi i \theta}$</span>. The thing I don't understand is why it's not <span class=""math-container"">$e^{i \theta}$</span> because it also lies on the unit circle and has a magnitude of 1. Are they the same? If yes, can you please show how?</p>
",Why can't the eigenvalues of a unitary matrix have the form $e^{i\theta}$?,<textbook-and-exercises><linear-algebra>,1,0,,,"Why can't the eigenvalues of a unitary matrix have the form $e^{i\theta}$? <p>The textbook says that since <span class=""math-container"">$U$</span> is a unitary matrix, its eigenvalue should be of the form <span class=""math-container"">$e^{2 \pi i \theta}$</span>. The thing I don't understand is why it's not <span class=""math-container"">$e^{i \theta}$</span> because it also lies on the unit circle and has a magnitude of 1. Are they the same? If yes, can you please show how?</p>
",qc,ca eigenvalues unitary matrix form p textbook says since span u unitary matrix eigenvalue form span 2 thing understand span also lies unit circle magnitude yes please show,"[(3, 0.8510125), (11, 0.10061812), (16, 0.042338464)]"
37557,,2024-04-01 00:46:00,0,172,"<p>I have the code below:</p>
<pre class=""lang-python prettyprint-override""><code>def load_IBMQ(channel,token):
    service = QiskitRuntimeService(channel=channel, token=token)
    #if len(IBMQ.stored_account()) == 0:
      #  IBMQ.save_account(token)
       # IBMQ.load_account()
    #elif IBMQ.active_account() == None:
     #   IBMQ.load_account()
    provider = service.backends(simulator=False, operational=True)#least_busy(operational=True, simulator=False)#IBMQ.get_provider(hub=hub, group=group, project=project)
    print(&quot;provider&quot;, provider)
    return provider
def get_device_info(channel,token,device_name,fields,datetime):
    dirname = './devices/%s'%datetime.date()
    filename = '%s/%s.pckl'%(dirname,device_name)
    _device_info = read_dict(filename=filename)
    if len(_device_info)==0:
        if not os.path.exists(dirname):
            os.makedirs(dirname)
        else:
            subprocess.run(['rm','-r',dirname])
            os.makedirs(dirname)
        provider = load_IBMQ(channel=channel,token=token)
        for x in provider:

            if 'qasm' not in str(x):
                device =x#get_backend(str(x))
                properties = device.properties(datetime=datetime)
                print(&quot;....properties....&quot;, properties)


                num_qubits = device.configuration().n_qubits#len(properties.qubits)
                print('Download device_info for %d-qubit %s'%(num_qubits,x))
                coupling_map = CouplingMap(device.configuration().coupling_map)
                noise_model = NoiseModel.from_backend(device)
                basis_gates = noise_model.basis_gates
                _device_info = {'properties':properties,#device.configuration(),
                'coupling_map':coupling_map,
                'noise_model':noise_model,
                'basis_gates':basis_gates}
                pickle.dump(_device_info, open('%s/%s.pckl'%(dirname,str(x)),'wb'))
            print('-'*50)
        _device_info = read_dict(filename=filename)
    device_info = {}
    for field in fields:


        if field=='device':
            provider = load_IBMQ(channel=channel,token=token)
            #print(device_name)

            device = device_name#provider.get_backend(device_name)
            device_info[field] = device
        else:
            device_info[field] = _device_info[field]
    print(&quot;get_device_info end&quot;)
    return device_info
</code></pre>
<p>I get error</p>
<pre><code>device_info[field] = _device_info[field]
                     ~~~~~~~~~~~~^^^^^^^
KeyError: 'properties'
</code></pre>
<p>How I get properties of real IBM quantum computer like <code>ibm_osaka</code> or others quantum computer in Qiskit SDK 1.0</p>
",How to get properties of real IBM Quantum Computer in Qiskit SDK 1.0?,<qiskit><qiskit-runtime>,1,0,,,"How to get properties of real IBM Quantum Computer in Qiskit SDK 1.0? <p>I have the code below:</p>
<pre class=""lang-python prettyprint-override""><code>def load_IBMQ(channel,token):
    service = QiskitRuntimeService(channel=channel, token=token)
    #if len(IBMQ.stored_account()) == 0:
      #  IBMQ.save_account(token)
       # IBMQ.load_account()
    #elif IBMQ.active_account() == None:
     #   IBMQ.load_account()
    provider = service.backends(simulator=False, operational=True)#least_busy(operational=True, simulator=False)#IBMQ.get_provider(hub=hub, group=group, project=project)
    print(&quot;provider&quot;, provider)
    return provider
def get_device_info(channel,token,device_name,fields,datetime):
    dirname = './devices/%s'%datetime.date()
    filename = '%s/%s.pckl'%(dirname,device_name)
    _device_info = read_dict(filename=filename)
    if len(_device_info)==0:
        if not os.path.exists(dirname):
            os.makedirs(dirname)
        else:
            subprocess.run(['rm','-r',dirname])
            os.makedirs(dirname)
        provider = load_IBMQ(channel=channel,token=token)
        for x in provider:

            if 'qasm' not in str(x):
                device =x#get_backend(str(x))
                properties = device.properties(datetime=datetime)
                print(&quot;....properties....&quot;, properties)


                num_qubits = device.configuration().n_qubits#len(properties.qubits)
                print('Download device_info for %d-qubit %s'%(num_qubits,x))
                coupling_map = CouplingMap(device.configuration().coupling_map)
                noise_model = NoiseModel.from_backend(device)
                basis_gates = noise_model.basis_gates
                _device_info = {'properties':properties,#device.configuration(),
                'coupling_map':coupling_map,
                'noise_model':noise_model,
                'basis_gates':basis_gates}
                pickle.dump(_device_info, open('%s/%s.pckl'%(dirname,str(x)),'wb'))
            print('-'*50)
        _device_info = read_dict(filename=filename)
    device_info = {}
    for field in fields:


        if field=='device':
            provider = load_IBMQ(channel=channel,token=token)
            #print(device_name)

            device = device_name#provider.get_backend(device_name)
            device_info[field] = device
        else:
            device_info[field] = _device_info[field]
    print(&quot;get_device_info end&quot;)
    return device_info
</code></pre>
<p>I get error</p>
<pre><code>device_info[field] = _device_info[field]
                     ~~~~~~~~~~~~^^^^^^^
KeyError: 'properties'
</code></pre>
<p>How I get properties of real IBM quantum computer like <code>ibm_osaka</code> or others quantum computer in Qiskit SDK 1.0</p>
",qc,get properties real ibm quantum computer qiskit sdk p code pre code def channel token service qiskitruntimeservice len 0 token elif none provider print quot provider quot provider return provider def channel token fields datetime dirname filename dirname len dirname dirname else dirname dirname provider x provider str x device str x properties print quot properties quot properties len print x couplingmap device properties open dirname str x print 50 field fields provider print device field device else field field print quot end quot return p get error pre code field field keyerror p get properties real ibm quantum computer like code others quantum computer qiskit sdk,"[(0, 0.33705205), (1, 0.1141585), (6, 0.083242156), (8, 0.051734053), (10, 0.0486551), (14, 0.13445461), (16, 0.029044744), (17, 0.027313849), (19, 0.1733179)]"
37604,,2024-04-03 20:54:32,3,82,"<p>Is there any theorem stating that lattice merge/split operations (or perhaps more generally, so-called <a href=""https://arxiv.org/abs/1810.10037"" rel=""nofollow noreferrer"">gauge-fixing</a>) cannot produce a non-Clifford gate that can complete the universal gateset for the surface code?</p>
",Can you produce Non-Clifford gates via Lattice Surgery?,<error-correction><surface-code><lattice-surgery>,1,0,,,"Can you produce Non-Clifford gates via Lattice Surgery? <p>Is there any theorem stating that lattice merge/split operations (or perhaps more generally, so-called <a href=""https://arxiv.org/abs/1810.10037"" rel=""nofollow noreferrer"">gauge-fixing</a>) cannot produce a non-Clifford gate that can complete the universal gateset for the surface code?</p>
",qc,produce gates via lattice surgery p theorem stating lattice operations perhaps generally https nofollow noreferrer produce gate complete universal gateset surface code,"[(5, 0.10262481), (9, 0.74037236), (16, 0.14934394)]"
37707,37708.0,2024-04-08 21:16:36,1,128,"<p>I'm attempting to understand how to perform universal quantum computation via lattice surgery. I'm struggling to find any resources for <span class=""math-container"">$S$</span> gates with lattice surgery. I would greatly appreciate an explanation/links to good resources.</p>
",How does one perform an $S$ gate on a surface code patch using lattice surgery?,<resource-request><lattice-surgery>,1,0,,,"How does one perform an $S$ gate on a surface code patch using lattice surgery? <p>I'm attempting to understand how to perform universal quantum computation via lattice surgery. I'm struggling to find any resources for <span class=""math-container"">$S$</span> gates with lattice surgery. I would greatly appreciate an explanation/links to good resources.</p>
",qc,one perform gate surface code patch using lattice surgery p attempting understand perform universal quantum computation via lattice surgery struggling find resources span gates lattice surgery would greatly appreciate good,"[(5, 0.11678298), (8, 0.32240573), (9, 0.22811517), (13, 0.062970646), (14, 0.059166163), (16, 0.20592125)]"
37766,37767.0,2024-04-12 17:13:05,4,124,"<p>Motivated by the latest lattice crypto paper (no idea if it's correct), I was wondering if there were any out there that thought perhaps NP <span class=""math-container"">$\cap$</span> co-NP was contained in BQP? Or alternatively, if there is a problem in NP <span class=""math-container"">$\cap$</span> co-NP that we especially strongly suspect is <em>not</em> in BQP?</p>
",What is an example of a problem that we strongly suspect lies in NP $\cap$ co-NP but not in BQP?,<complexity-theory>,1,5,,,"What is an example of a problem that we strongly suspect lies in NP $\cap$ co-NP but not in BQP? <p>Motivated by the latest lattice crypto paper (no idea if it's correct), I was wondering if there were any out there that thought perhaps NP <span class=""math-container"">$\cap$</span> co-NP was contained in BQP? Or alternatively, if there is a problem in NP <span class=""math-container"">$\cap$</span> co-NP that we especially strongly suspect is <em>not</em> in BQP?</p>
",qc,example problem strongly suspect lies np bqp p motivated latest lattice crypto paper idea correct wondering thought perhaps np span contained bqp alternatively problem np span especially strongly suspect em bqp,"[(1, 0.29786924), (9, 0.6322316), (16, 0.06444801)]"
37783,,2024-04-14 06:43:57,1,86,"<p>Could anyone please explain how should I carry out a state tomography on a real device in Qiskit (version 0.43.2)?
I have access to devices with 127 qubits, but I want to perform a simulation using only four qubits and then do a state tomography on them. When I use <code>StateTomography</code> specifying the circuit, the backend and the <code>measurement_indices</code>, it just tries to evaluate the density matrix of the whole device (returning an error, since it would be <span class=""math-container"">$2^{127}\times2^{127}$</span>). Is there any way to isolate just the four qubit I am working with?</p>
",State tomography in Qiskit on a subset of qubits of real QPU,<qiskit><quantum-state><measurement><density-matrix><state-tomography>,0,0,,,"State tomography in Qiskit on a subset of qubits of real QPU <p>Could anyone please explain how should I carry out a state tomography on a real device in Qiskit (version 0.43.2)?
I have access to devices with 127 qubits, but I want to perform a simulation using only four qubits and then do a state tomography on them. When I use <code>StateTomography</code> specifying the circuit, the backend and the <code>measurement_indices</code>, it just tries to evaluate the density matrix of the whole device (returning an error, since it would be <span class=""math-container"">$2^{127}\times2^{127}$</span>). Is there any way to isolate just the four qubit I am working with?</p>
",qc,state tomography qiskit subset qubits real qpu p could anyone please explain carry state tomography real device qiskit version access devices 127 qubits want perform simulation using four qubits state tomography use code statetomography specifying circuit backend code tries evaluate density matrix whole device returning error since would span 127 127 way isolate four qubit working,"[(9, 0.022490313), (11, 0.036306463), (13, 0.0732853), (14, 0.69090635), (16, 0.030327395), (18, 0.14419009)]"
37814,,2024-04-16 05:29:24,2,150,"<p>I'm facing a strange issue with the logical error rate after implementing Lattice Surgery in Stim. For <span class=""math-container"">$d=3$</span> (I have some custom error annotations in the circuit),</p>
<pre><code>Logical error rate of X-basis Lattice Surgery, XX-Observable: 0.06361
Logical error rate of X-basis Lattice Surgery, Z1-Observable: 0.00737
Logical error rate of X-basis Lattice Surgery, Z2-Observable: 0.00705
Logical error rate of X-basis Lattice Surgery, ZZ-Observable: 0.01417
</code></pre>
<p>There is a significant difference between these cases, and I can't understand why that would be the case. I followed all the directions in <a href=""https://quantumcomputing.stackexchange.com/questions/32382/how-to-implement-lattice-surgery-in-stim"">How to implement lattice surgery in stim?</a> for the right detector annotations and for both cases, <code>stim.Circuit.shortest_graphlike_error()</code> returns the same value (3). I've manually gone through the circuit and made sure all detectors have been included too.</p>
<p>What's a good way of debugging this?</p>
",High logical error rates when implementing Lattice Surgery with Stim,<stim><lattice-surgery>,1,1,,,"High logical error rates when implementing Lattice Surgery with Stim <p>I'm facing a strange issue with the logical error rate after implementing Lattice Surgery in Stim. For <span class=""math-container"">$d=3$</span> (I have some custom error annotations in the circuit),</p>
<pre><code>Logical error rate of X-basis Lattice Surgery, XX-Observable: 0.06361
Logical error rate of X-basis Lattice Surgery, Z1-Observable: 0.00737
Logical error rate of X-basis Lattice Surgery, Z2-Observable: 0.00705
Logical error rate of X-basis Lattice Surgery, ZZ-Observable: 0.01417
</code></pre>
<p>There is a significant difference between these cases, and I can't understand why that would be the case. I followed all the directions in <a href=""https://quantumcomputing.stackexchange.com/questions/32382/how-to-implement-lattice-surgery-in-stim"">How to implement lattice surgery in stim?</a> for the right detector annotations and for both cases, <code>stim.Circuit.shortest_graphlike_error()</code> returns the same value (3). I've manually gone through the circuit and made sure all detectors have been included too.</p>
<p>What's a good way of debugging this?</p>
",qc,high logical error rates implementing lattice surgery stim p facing strange issue logical error rate implementing lattice surgery stim span custom error annotations circuit pre code logical error rate lattice surgery logical error rate lattice surgery logical error rate lattice surgery logical error rate lattice surgery p significant difference cases ca understand would case followed directions https implement lattice surgery stim right detector annotations cases code returns value 3 manually gone circuit made sure detectors included p good way debugging,"[(4, 0.05808934), (5, 0.4578987), (7, 0.0581335), (14, 0.24603754), (16, 0.17796908)]"
37826,,2024-04-16 17:45:33,0,32,"<p>Suppose during a smooth lattice merge operation, I perform one round of error correction, treating the two code patches as one single lattice that stretches across the intermediate qubits. Then, one of the weight-3 Z stabilizers at the boundary of the join I can measure <span class=""math-container"">$d-1$</span> times more. Directly after this, I perform the additional <span class=""math-container"">$d - 1$</span> rounds of syndrome measurements needed except without this one stabilizer. How does this impact the fault tolerance of my <span class=""math-container"">$d$</span> rounds of error correction? Do I still get sufficient volume for MWPM? If not, how much worse is it?</p>
",Fault tolerance of turning off a stabilizer measurement for later rounds of error correction?,<error-correction><surface-code><lattice-surgery>,1,0,,,"Fault tolerance of turning off a stabilizer measurement for later rounds of error correction? <p>Suppose during a smooth lattice merge operation, I perform one round of error correction, treating the two code patches as one single lattice that stretches across the intermediate qubits. Then, one of the weight-3 Z stabilizers at the boundary of the join I can measure <span class=""math-container"">$d-1$</span> times more. Directly after this, I perform the additional <span class=""math-container"">$d - 1$</span> rounds of syndrome measurements needed except without this one stabilizer. How does this impact the fault tolerance of my <span class=""math-container"">$d$</span> rounds of error correction? Do I still get sufficient volume for MWPM? If not, how much worse is it?</p>
",qc,fault tolerance turning stabilizer measurement later rounds error correction p suppose smooth lattice merge operation perform one round error correction treating two code patches one single lattice stretches across intermediate qubits one z stabilizers boundary join measure span times directly perform additional span 1 rounds syndrome measurements needed except without one stabilizer impact fault tolerance span rounds error correction still get sufficient volume mwpm much worse,"[(3, 0.08501428), (5, 0.48472902), (13, 0.047236364), (14, 0.22201355), (16, 0.051408567), (18, 0.088273644), (19, 0.019329421)]"
37858,37881.0,2024-04-18 11:17:33,0,129,"<p>A year ago, I registered in the IBM Quantum Computing app, which provides access to quantum computers and to simulators. I got an API key, and was able to run some programs.</p>
<p>However, lately, I try to log in in my account and the system answers me with the same page, and I am not able to get another/the same API key. In fact, when I run the programs I run a year ago, using the API key that I then got, the program replies with:</p>
<pre><code>qiskit_ibm_runtime.api.exceptions.RequestsApiError: '403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Your IBM Quantum account has been disabled. Learn more: https://ibm.biz/BdfaME., Error code: 3485.'
</code></pre>
<p>I tried to contact IBM, but they have not been replying...</p>
<p>Any idea?</p>
<p>By the way: I use python 3.11 and qiskit 0.43.0.</p>
<p>The program:</p>
<pre><code># Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile
#from qiskit.tools.jupyter import *
from IPython.display import display
from qiskit.visualization import *

# Loading your IBM Quantum account(s)
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;) # the error occurs here!

...

<span class=""math-container"">```</span>
</code></pre>
",Quantum Computing - via Qiskit - error 403,<qiskit><programming><ibm-quantum-devices>,2,2,,,"Quantum Computing - via Qiskit - error 403 <p>A year ago, I registered in the IBM Quantum Computing app, which provides access to quantum computers and to simulators. I got an API key, and was able to run some programs.</p>
<p>However, lately, I try to log in in my account and the system answers me with the same page, and I am not able to get another/the same API key. In fact, when I run the programs I run a year ago, using the API key that I then got, the program replies with:</p>
<pre><code>qiskit_ibm_runtime.api.exceptions.RequestsApiError: '403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Your IBM Quantum account has been disabled. Learn more: https://ibm.biz/BdfaME., Error code: 3485.'
</code></pre>
<p>I tried to contact IBM, but they have not been replying...</p>
<p>Any idea?</p>
<p>By the way: I use python 3.11 and qiskit 0.43.0.</p>
<p>The program:</p>
<pre><code># Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile
#from qiskit.tools.jupyter import *
from IPython.display import display
from qiskit.visualization import *

# Loading your IBM Quantum account(s)
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;) # the error occurs here!

...

<span class=""math-container"">```</span>
</code></pre>
",qc,quantum computing via qiskit error 403 p year ago registered ibm quantum computing app provides access quantum computers simulators got api key able run p however lately try log account system answers page able get api key fact run programs run year ago using api key got program replies pre code client error forbidden url https ibm quantum account disabled learn https error code 3485 p tried contact ibm replying p idea p way use python qiskit p program pre code importing standard qiskit libraries qiskit import quantumcircuit transpile import import display import loading ibm quantum account service qiskitruntimeservice quot quot error occurs span,"[(0, 0.36854059), (3, 0.015553128), (4, 0.027199626), (8, 0.25933376), (12, 0.030223006), (14, 0.20389079), (16, 0.035059277), (19, 0.059000086)]"
37961,,2024-04-24 21:27:32,0,52,"<p>I have made use of the following formulas,
<span class=""math-container"">\begin{align}
\theta&amp;=2\cos^{-1}\bigg(\frac{e^{-i\alpha}Tr(X)}{2}\bigg)\\
n_i&amp;=\frac{e^{-i\alpha}Tr(X\sigma_x)}{2\sin\theta/2}\\
e^{i\alpha}&amp;=\sqrt{\det(X)}
\end{align}</span>
Please check <a href=""https://quantumcomputing.stackexchange.com/questions/16533/can-i-find-the-axis-of-rotation-for-any-single-qubit-gate?noredirect=1&amp;lq=1"">Can I find the axis of rotation for any single-qubit gate?</a> for the reference.
<span class=""math-container"">$$
X=\frac{1}{\sqrt{2}}\begin{bmatrix}-i&amp;-1\\1&amp;i\end{bmatrix}\\
e^{i\alpha}=\sqrt{\det(X)}=1\\
\theta=2\cos^{-1}(\frac{1.0}{2})=2\cos^{-1}(0)=2\frac{\pi}{2}=\pi\\
Tr(X\sigma_x)=0\implies n_1=0\\
X\sigma_y=X=\frac{1}{\sqrt{2}}\begin{bmatrix}-i&amp;-1\\1&amp;i\end{bmatrix}\begin{bmatrix}0&amp;-i\\i&amp;0\end{bmatrix}=\frac{1}{\sqrt{2}}\begin{bmatrix}-i&amp;-1\\-1&amp;-i\end{bmatrix}\\
\implies Tr(X\sigma_y)=\frac{1}{\sqrt{2}}.-2i=-\sqrt{2}i\implies n_2=\frac{i.1.-\sqrt{2}i}{2.1}=\frac{\sqrt{2}}{2}=\sqrt{2}\\
Tr(X\sigma_z)=0\implies n_3=0
$$</span></p>
<p>Why am I not getting a unit vector here ?</p>
",Axis and Angle of rotation of $\frac{1}{\sqrt{2}}\begin{bmatrix}-i&-1\\1&i\end{bmatrix}$,<quantum-gate><unitarity>,0,5,,,"Axis and Angle of rotation of $\frac{1}{\sqrt{2}}\begin{bmatrix}-i&-1\\1&i\end{bmatrix}$ <p>I have made use of the following formulas,
<span class=""math-container"">\begin{align}
\theta&amp;=2\cos^{-1}\bigg(\frac{e^{-i\alpha}Tr(X)}{2}\bigg)\\
n_i&amp;=\frac{e^{-i\alpha}Tr(X\sigma_x)}{2\sin\theta/2}\\
e^{i\alpha}&amp;=\sqrt{\det(X)}
\end{align}</span>
Please check <a href=""https://quantumcomputing.stackexchange.com/questions/16533/can-i-find-the-axis-of-rotation-for-any-single-qubit-gate?noredirect=1&amp;lq=1"">Can I find the axis of rotation for any single-qubit gate?</a> for the reference.
<span class=""math-container"">$$
X=\frac{1}{\sqrt{2}}\begin{bmatrix}-i&amp;-1\\1&amp;i\end{bmatrix}\\
e^{i\alpha}=\sqrt{\det(X)}=1\\
\theta=2\cos^{-1}(\frac{1.0}{2})=2\cos^{-1}(0)=2\frac{\pi}{2}=\pi\\
Tr(X\sigma_x)=0\implies n_1=0\\
X\sigma_y=X=\frac{1}{\sqrt{2}}\begin{bmatrix}-i&amp;-1\\1&amp;i\end{bmatrix}\begin{bmatrix}0&amp;-i\\i&amp;0\end{bmatrix}=\frac{1}{\sqrt{2}}\begin{bmatrix}-i&amp;-1\\-1&amp;-i\end{bmatrix}\\
\implies Tr(X\sigma_y)=\frac{1}{\sqrt{2}}.-2i=-\sqrt{2}i\implies n_2=\frac{i.1.-\sqrt{2}i}{2.1}=\frac{\sqrt{2}}{2}=\sqrt{2}\\
Tr(X\sigma_z)=0\implies n_3=0
$$</span></p>
<p>Why am I not getting a unit vector here ?</p>
",qc,axis angle rotation 1 2 bmatrix bmatrix p made use following formulas span align amp tr x 2 amp tr amp x align please check https amp find axis rotation gate reference span 1 2 bmatrix amp amp bmatrix x 2 0 2 tr 1 2 bmatrix amp amp bmatrix bmatrix 0 amp amp bmatrix 1 2 bmatrix amp amp bmatrix tr 1 2 2 2 2 2 2 tr p getting unit vector,"[(2, 0.31888968), (3, 0.14720836), (4, 0.045154978), (10, 0.04306173), (15, 0.42954138), (16, 0.014256395)]"
38000,,2024-04-27 00:48:24,2,154,"<p>The following quantum circuit consists of two CNOT gates in the middle of the circuit. The two-qubit input quantum register <span class=""math-container"">$|x\rangle$</span> is an arbitrary quantum state and can be set by the user. The other two-qubit input quantum register <span class=""math-container"">$|00\rangle$</span> is in the ground state and cannot be changed. The gate <span class=""math-container"">$F$</span> is an unknown quantum operation (this means it is an arbitrary, but fixed gate on two qubits, but you do not know what it does). The gate <span class=""math-container"">$F^{-1}$</span> computes the inverse operation of <span class=""math-container"">$F$</span>.
<a href=""https://i.sstatic.net/itUkhfDj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/itUkhfDj.png"" alt=""quantum circuit"" /></a></p>
<p>So how does this circuit work?
Label the qubits from top to bottom as q1, q2 for the input <span class=""math-container"">$|x\rangle$</span> and q3, q4 for the input <span class=""math-container"">$|00\rangle$</span>.</p>
<p>The <span class=""math-container"">$F(X)$</span> generated by q1, q2 acted by F, will it convert q3, q4 to <span class=""math-container"">$F(00)$</span> when the CNOT gate operation is performed? Will <span class=""math-container"">$F^{-1}$</span> also act on q1, q2 when it acts on q3, q4 because of the entanglement, so that the <span class=""math-container"">$F(X)$</span> will be converted to <span class=""math-container"">$X$</span>?</p>
<p>Personally, I guess that in the end the output result of A will be <span class=""math-container"">$F(X)$</span>, and the output result of B will be <span class=""math-container"">$00$</span>.  But I'm not sure that I'm right about this.</p>
",How to analyse a quantum circuit with an uncertain gate F?,<quantum-gate><entanglement><quantum-circuit>,1,4,,,"How to analyse a quantum circuit with an uncertain gate F? <p>The following quantum circuit consists of two CNOT gates in the middle of the circuit. The two-qubit input quantum register <span class=""math-container"">$|x\rangle$</span> is an arbitrary quantum state and can be set by the user. The other two-qubit input quantum register <span class=""math-container"">$|00\rangle$</span> is in the ground state and cannot be changed. The gate <span class=""math-container"">$F$</span> is an unknown quantum operation (this means it is an arbitrary, but fixed gate on two qubits, but you do not know what it does). The gate <span class=""math-container"">$F^{-1}$</span> computes the inverse operation of <span class=""math-container"">$F$</span>.
<a href=""https://i.sstatic.net/itUkhfDj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/itUkhfDj.png"" alt=""quantum circuit"" /></a></p>
<p>So how does this circuit work?
Label the qubits from top to bottom as q1, q2 for the input <span class=""math-container"">$|x\rangle$</span> and q3, q4 for the input <span class=""math-container"">$|00\rangle$</span>.</p>
<p>The <span class=""math-container"">$F(X)$</span> generated by q1, q2 acted by F, will it convert q3, q4 to <span class=""math-container"">$F(00)$</span> when the CNOT gate operation is performed? Will <span class=""math-container"">$F^{-1}$</span> also act on q1, q2 when it acts on q3, q4 because of the entanglement, so that the <span class=""math-container"">$F(X)$</span> will be converted to <span class=""math-container"">$X$</span>?</p>
<p>Personally, I guess that in the end the output result of A will be <span class=""math-container"">$F(X)$</span>, and the output result of B will be <span class=""math-container"">$00$</span>.  But I'm not sure that I'm right about this.</p>
",qc,analyse quantum circuit uncertain gate f p following quantum circuit consists two cnot gates middle circuit input quantum register span arbitrary quantum state set user input quantum register span ground state changed gate span f unknown quantum operation means arbitrary fixed gate two qubits know gate span computes inverse operation span f https nofollow noreferrer img https quantum circuit p circuit work label qubits top bottom q1 q2 input span q3 q4 input span p span f x generated q1 q2 acted f convert q3 q4 span f 00 cnot gate operation performed span also act q1 q2 acts q3 q4 entanglement span f x converted span x p personally guess end output result span f x output result b span 00 sure right,"[(1, 0.038762216), (3, 0.13382487), (4, 0.10454858), (8, 0.010792894), (10, 0.13625887), (14, 0.2605501), (16, 0.034350622), (18, 0.2799371)]"
38064,38067.0,2024-04-30 17:56:18,1,163,"<p>I am new to dynamical decoupling and is trying to study this from qiskit: <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling</a> . There, they are specifying the duration for each gate with an integer number. How can I relate this integer number to the real device gate duration (X, RZ, CX, etc. ) in the unit of nanosecond?</p>
",IBM quantum computer backend cycle time and real gate duration,<qiskit><quantum-gate><quantum-operation><ibm-quantum-devices>,1,0,,,"IBM quantum computer backend cycle time and real gate duration <p>I am new to dynamical decoupling and is trying to study this from qiskit: <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling</a> . There, they are specifying the duration for each gate with an integer number. How can I relate this integer number to the real device gate duration (X, RZ, CX, etc. ) in the unit of nanosecond?</p>
",qc,ibm quantum computer backend cycle time real gate duration p new dynamical decoupling trying study qiskit https nofollow noreferrer https specifying duration gate integer number relate integer number real device gate duration x rz cx etc unit nanosecond,"[(0, 0.123487525), (1, 0.119606346), (4, 0.09222776), (6, 0.05039356), (7, 0.07308241), (9, 0.21951796), (10, 0.027159853), (14, 0.23079626), (16, 0.060845796)]"
38220,38228.0,2024-05-09 10:11:38,0,64,"<p>I have the following question. If I perform projective measurements of a given (multi-qubit) Pauli string in my <code>TableauSimulator</code> I implicitly perform some Gaussian-elimination steps to get the measurement result (<span class=""math-container"">$\pm 1$</span>). If I'm not wrong, this should have some possible <span class=""math-container"">$O(n^3)$</span> complexity steps.</p>
<p>Nevertheless, I'm studying a problem where the outcome information is unnecessary. In this case, I expect that I can simply avoid these result-revealing steps and simply compute the new generators a la <a href=""https://arxiv.org/pdf/quant-ph/0406196"" rel=""nofollow noreferrer"">Aaronson and Gottesman</a>.
In this case, updating the destabilizer tableau would be unnecessary. Hence we can just focus on a <code>TableauHalf</code> object.</p>
<p>I was going through the C++ source but did not find an already implemented function on the <code>Tableau</code> or <code>TableauSimulator</code> headers. Hence, I implemented a version looping over the <code>TableauHalf</code> and updating it according to <a href=""https://arxiv.org/pdf/quant-ph/0406196"" rel=""nofollow noreferrer"">this paper</a>.</p>
<pre><code>uint64_t popcnt(uint64_t x) {
  uint64_t count = x;
  count = (count &amp; 0x5555555555555555) + ((count &gt;&gt; 1) &amp; 0x5555555555555555);
  count = (count &amp; 0x3333333333333333) + ((count &gt;&gt; 2) &amp; 0x3333333333333333);
  count = (count &amp; 0x0f0f0f0f0f0f0f0f) + ((count &gt;&gt; 4) &amp; 0x0f0f0f0f0f0f0f0f);
  count = (count &amp; 0x00ff00ff00ff00ff) + ((count &gt;&gt; 8) &amp; 0x00ff00ff00ff00ff);
  count = (count &amp; 0x0000ffff0000ffff) + ((count &gt;&gt; 16) &amp; 0x0000ffff0000ffff);
  count = (count &amp; 0x00000000ffffffff) + ((count &gt;&gt; 32) &amp; 0x00000000ffffffff);
  return count;
}

template &lt;size_t W&gt;
void measure_pauli(const size_t num_qubits, TableauHalf&lt;W&gt; &amp;T, const PauliStringRef&lt;W&gt; P) {
    size_t pivot=-1;
    std::vector&lt;size_t&gt; indices;
    size_t n = P.xs.num_u64_padded();
    for (size_t w = 0; w &lt; n; w++) {
        uint64_t v = P.xs.u64[w] | P.zs.u64[w];
        if (v&gt;0) {
            indices.push_back(w);
        }
    }
    for (size_t q1 = 0; q1 &lt; num_qubits; q1++) {
        PauliStringRef&lt;MAX_BITWORD_WIDTH&gt; z1 = T[q1];
        size_t test =0;
        for (size_t &amp; v : indices){
            test+= popcnt((z1.zs.u64[v]&amp;P.xs.u64[v])^(z1.xs.u64[v]&amp;P.zs.u64[v]));
        }
        if (test%2) {
            pivot=q1;
            break;
        }
    }
    if (pivot&gt;=0) {
        T[pivot]= P;
        for (size_t q2 = pivot + 1; q2 &lt; num_qubits; q2++) {
            PauliStringRef&lt;MAX_BITWORD_WIDTH&gt; z1 = T[q2];
            size_t test =0;
            for (size_t &amp; v : indices){
                test+= popcnt((z1.zs.u64[v]&amp;P.xs.u64[v])^(z1.xs.u64[v]&amp;P.zs.u64[v]));
            }
            if (test%2){
                for (size_t &amp; v : indices){
                    z1.xs.u64[v] ^= P.xs.u64[v];
                    z1.zs.u64[v] ^= P.zs.u64[v];
                }
            }
        }
    }
}
</code></pre>
<p>This gives a considerable speedup, but I wondered if more optimized operations exist.</p>
<p>EDIT: I slightly improved the code by updating where to check the operator commutes, and performing some update as u64.</p>
",stim: enhancing performance measuring Pauli strings without keeping the outcome,<measurement><stim>,1,0,,,"stim: enhancing performance measuring Pauli strings without keeping the outcome <p>I have the following question. If I perform projective measurements of a given (multi-qubit) Pauli string in my <code>TableauSimulator</code> I implicitly perform some Gaussian-elimination steps to get the measurement result (<span class=""math-container"">$\pm 1$</span>). If I'm not wrong, this should have some possible <span class=""math-container"">$O(n^3)$</span> complexity steps.</p>
<p>Nevertheless, I'm studying a problem where the outcome information is unnecessary. In this case, I expect that I can simply avoid these result-revealing steps and simply compute the new generators a la <a href=""https://arxiv.org/pdf/quant-ph/0406196"" rel=""nofollow noreferrer"">Aaronson and Gottesman</a>.
In this case, updating the destabilizer tableau would be unnecessary. Hence we can just focus on a <code>TableauHalf</code> object.</p>
<p>I was going through the C++ source but did not find an already implemented function on the <code>Tableau</code> or <code>TableauSimulator</code> headers. Hence, I implemented a version looping over the <code>TableauHalf</code> and updating it according to <a href=""https://arxiv.org/pdf/quant-ph/0406196"" rel=""nofollow noreferrer"">this paper</a>.</p>
<pre><code>uint64_t popcnt(uint64_t x) {
  uint64_t count = x;
  count = (count &amp; 0x5555555555555555) + ((count &gt;&gt; 1) &amp; 0x5555555555555555);
  count = (count &amp; 0x3333333333333333) + ((count &gt;&gt; 2) &amp; 0x3333333333333333);
  count = (count &amp; 0x0f0f0f0f0f0f0f0f) + ((count &gt;&gt; 4) &amp; 0x0f0f0f0f0f0f0f0f);
  count = (count &amp; 0x00ff00ff00ff00ff) + ((count &gt;&gt; 8) &amp; 0x00ff00ff00ff00ff);
  count = (count &amp; 0x0000ffff0000ffff) + ((count &gt;&gt; 16) &amp; 0x0000ffff0000ffff);
  count = (count &amp; 0x00000000ffffffff) + ((count &gt;&gt; 32) &amp; 0x00000000ffffffff);
  return count;
}

template &lt;size_t W&gt;
void measure_pauli(const size_t num_qubits, TableauHalf&lt;W&gt; &amp;T, const PauliStringRef&lt;W&gt; P) {
    size_t pivot=-1;
    std::vector&lt;size_t&gt; indices;
    size_t n = P.xs.num_u64_padded();
    for (size_t w = 0; w &lt; n; w++) {
        uint64_t v = P.xs.u64[w] | P.zs.u64[w];
        if (v&gt;0) {
            indices.push_back(w);
        }
    }
    for (size_t q1 = 0; q1 &lt; num_qubits; q1++) {
        PauliStringRef&lt;MAX_BITWORD_WIDTH&gt; z1 = T[q1];
        size_t test =0;
        for (size_t &amp; v : indices){
            test+= popcnt((z1.zs.u64[v]&amp;P.xs.u64[v])^(z1.xs.u64[v]&amp;P.zs.u64[v]));
        }
        if (test%2) {
            pivot=q1;
            break;
        }
    }
    if (pivot&gt;=0) {
        T[pivot]= P;
        for (size_t q2 = pivot + 1; q2 &lt; num_qubits; q2++) {
            PauliStringRef&lt;MAX_BITWORD_WIDTH&gt; z1 = T[q2];
            size_t test =0;
            for (size_t &amp; v : indices){
                test+= popcnt((z1.zs.u64[v]&amp;P.xs.u64[v])^(z1.xs.u64[v]&amp;P.zs.u64[v]));
            }
            if (test%2){
                for (size_t &amp; v : indices){
                    z1.xs.u64[v] ^= P.xs.u64[v];
                    z1.zs.u64[v] ^= P.zs.u64[v];
                }
            }
        }
    }
}
</code></pre>
<p>This gives a considerable speedup, but I wondered if more optimized operations exist.</p>
<p>EDIT: I slightly improved the code by updating where to check the operator commutes, and performing some update as u64.</p>
",qc,stim enhancing performance measuring pauli strings without keeping outcome p following question perform projective measurements given pauli string code tableausimulator implicitly perform steps get measurement result span 1 wrong possible span complexity p nevertheless studying problem outcome information unnecessary case expect simply avoid steps simply compute new generators la https nofollow noreferrer aaronson gottesman case updating destabilizer tableau would unnecessary hence focus code tableauhalf p going source find already implemented function code tableau code tableausimulator headers hence implemented version looping code tableauhalf updating according https nofollow noreferrer paper pre code popcnt x count x count count amp 0x5555555555555555 count gt gt 1 amp 0x5555555555555555 count count amp 0x3333333333333333 count gt gt 2 amp 0x3333333333333333 count count amp 0x0f0f0f0f0f0f0f0f count gt gt 4 amp 0x0f0f0f0f0f0f0f0f count count amp 0x00ff00ff00ff00ff count gt gt 8 amp 0x00ff00ff00ff00ff count count amp 0x0000ffff0000ffff count gt gt 16 amp 0x0000ffff0000ffff count count amp 0x00000000ffffffff count gt gt 32 amp 0x00000000ffffffff return count template lt w gt void const tableauhalf lt w gt amp const paulistringref lt w gt p std lt gt indices n w 0 w lt n v w w v gt 0 w q1 0 q1 lt paulistringref lt gt z1 q1 test amp v indices popcnt v amp v v amp v test 2 break pivot gt pivot p q2 pivot 1 q2 lt paulistringref lt gt z1 q2 test amp v indices popcnt v amp v v amp v test 2 amp v indices v v v v p gives considerable speedup wondered optimized operations p edit slightly improved code updating check operator commutes performing update,"[(0, 0.49693626), (3, 0.10584513), (4, 0.0316475), (5, 0.038372487), (7, 0.0356083), (9, 0.03595868), (14, 0.107149), (15, 0.12730281), (16, 0.012342635)]"
38232,38233.0,2024-05-09 21:22:45,1,97,"<p>If I consider the 3-dimensional structures from <a href=""https://arxiv.org/abs/1905.08916"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1905.08916</a>, these would form a nice 3-dimensional structure for surface code layouts, except I'm not sure what the equivalence rules are. For example, it seems like basic deformations aren't necessarily allowed, since we could deform a CNOT into something that is essentially a lattice surgery merge then split (which as far as I can tell, is not equivalent to a CNOT). Has there been a paper (or is it obvious?) about the equivalence rules for these 3-d diagrams?</p>
","Deformation rules for ZX ""pipe"" diagrams",<error-correction><zx-calculus>,1,0,,,"Deformation rules for ZX ""pipe"" diagrams <p>If I consider the 3-dimensional structures from <a href=""https://arxiv.org/abs/1905.08916"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1905.08916</a>, these would form a nice 3-dimensional structure for surface code layouts, except I'm not sure what the equivalence rules are. For example, it seems like basic deformations aren't necessarily allowed, since we could deform a CNOT into something that is essentially a lattice surgery merge then split (which as far as I can tell, is not equivalent to a CNOT). Has there been a paper (or is it obvious?) about the equivalence rules for these 3-d diagrams?</p>
",qc,deformation rules zx pipe diagrams p consider structures https nofollow noreferrer https would form nice structure surface code layouts except sure equivalence rules example seems like basic deformations necessarily allowed since could deform cnot something essentially lattice surgery merge split far tell equivalent cnot paper obvious equivalence rules diagrams,"[(5, 0.051474165), (9, 0.90293634), (16, 0.04212841)]"
38234,,2024-05-10 04:57:07,1,191,"<p><a href=""https://i.sstatic.net/IxF7ji9W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IxF7ji9W.png"" alt=""State injection protocol described in Fig. 8 of [Dominic Horsman
et al.]"" /></a></p>
<p>I am reading this paper on lattice surgery by <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011/pdf"" rel=""nofollow noreferrer"">Dominic Horsman
et al</a>, and am struggling to understand a simple method they put forward in their Figure 8(a)(b)(c) to inject an arbitrary state into a planar surface.</p>
<p>The protocol they put forward is very simple: initialize all physical qubits to <span class=""math-container"">$|0\rangle$</span> except for one distance-3 line of qubits. For that line of qubits, initialize each one of them to the arbitrary state to be injected <span class=""math-container"">$|\psi\rangle=\alpha|0\rangle + \beta|1\rangle$</span>. And then this surface is &quot;stabilized&quot; (I imagine this means 1 round of concurrent measurements of all X- and Z-type stabilizers), yielding a distance-3 logical qubit in that arbitrary logical state <span class=""math-container"">$|\psi\rangle_\text{L}=\alpha|000\rangle + \beta|111\rangle$</span>.</p>
<p>I know that in surface code we operate on quiescent states, like described in <a href=""https://arxiv.org/pdf/1208.0928"" rel=""nofollow noreferrer"">Fowler's review paper</a>. Am I correct that this simple state injection is viable, because <span class=""math-container"">$|0\rangle$</span> transversal initialization and <span class=""math-container"">$|1\rangle$</span> transversal initialization gives the two orthogonal logical state <span class=""math-container"">$|0\rangle_L$</span> and <span class=""math-container"">$|1\rangle_L$</span> after the code is stabilized, and so a superposition initialization of a line of qubit works as intended?</p>
<p>Could anyone help me understand why such a simple initialization of qubit does the job? Thanks.</p>
",State injection in a surface code,<error-correction><surface-code><logical-gates><lattice-surgery><state-injection-model>,1,0,,,"State injection in a surface code <p><a href=""https://i.sstatic.net/IxF7ji9W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IxF7ji9W.png"" alt=""State injection protocol described in Fig. 8 of [Dominic Horsman
et al.]"" /></a></p>
<p>I am reading this paper on lattice surgery by <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011/pdf"" rel=""nofollow noreferrer"">Dominic Horsman
et al</a>, and am struggling to understand a simple method they put forward in their Figure 8(a)(b)(c) to inject an arbitrary state into a planar surface.</p>
<p>The protocol they put forward is very simple: initialize all physical qubits to <span class=""math-container"">$|0\rangle$</span> except for one distance-3 line of qubits. For that line of qubits, initialize each one of them to the arbitrary state to be injected <span class=""math-container"">$|\psi\rangle=\alpha|0\rangle + \beta|1\rangle$</span>. And then this surface is &quot;stabilized&quot; (I imagine this means 1 round of concurrent measurements of all X- and Z-type stabilizers), yielding a distance-3 logical qubit in that arbitrary logical state <span class=""math-container"">$|\psi\rangle_\text{L}=\alpha|000\rangle + \beta|111\rangle$</span>.</p>
<p>I know that in surface code we operate on quiescent states, like described in <a href=""https://arxiv.org/pdf/1208.0928"" rel=""nofollow noreferrer"">Fowler's review paper</a>. Am I correct that this simple state injection is viable, because <span class=""math-container"">$|0\rangle$</span> transversal initialization and <span class=""math-container"">$|1\rangle$</span> transversal initialization gives the two orthogonal logical state <span class=""math-container"">$|0\rangle_L$</span> and <span class=""math-container"">$|1\rangle_L$</span> after the code is stabilized, and so a superposition initialization of a line of qubit works as intended?</p>
<p>Could anyone help me understand why such a simple initialization of qubit does the job? Thanks.</p>
",qc,state injection surface code p https nofollow noreferrer img https state injection protocol described fig 8 dominic horsman et al p reading paper lattice surgery https nofollow noreferrer dominic horsman et al struggling understand simple method put forward figure 8 b c inject arbitrary state planar p protocol put forward simple initialize physical qubits span except one line qubits line qubits initialize one arbitrary state injected span surface quot stabilized quot imagine means 1 round concurrent measurements stabilizers yielding logical qubit arbitrary logical state span l p know surface code operate quiescent states like described https nofollow noreferrer fowler review paper correct simple state injection viable span transversal initialization span transversal initialization gives two orthogonal logical state span span code stabilized superposition initialization line qubit works intended p could anyone help understand simple initialization qubit job,"[(0, 0.096535414), (3, 0.13634923), (4, 0.12055545), (5, 0.20586681), (6, 0.013098181), (9, 0.0634918), (13, 0.1052219), (14, 0.059377), (16, 0.015038091), (18, 0.16232418), (19, 0.021473752)]"
38266,38283.0,2024-05-13 10:39:51,2,158,"<p>I am reading about lattice surgery from <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011/pdf"" rel=""nofollow noreferrer"">this paper</a>. I am interested in the merge operation which takes 2 qubits to 1 qubit. I want to understand the logical-level Kraus operation that the merge does.</p>
<p>For instance, the action of the rough merge between two states <span class=""math-container"">$\vert\psi\rangle = \alpha\vert 0\rangle + \beta\vert 1 \rangle$</span> and <span class=""math-container"">$\vert\phi\rangle$</span> is given by</p>
<p><span class=""math-container"">$$|\psi\rangle \otimes |\phi\rangle\rightarrow \alpha|\phi\rangle+(-1)^M \beta X|\phi\rangle$$</span></p>
<p>where <span class=""math-container"">$M$</span> is the merge measurement result. However, this only tells me what happens to pure product states. What is this in terms of the Kraus operators of the channel that merges the two qubits?</p>
",Kraus decomposition of merging in lattice surgery,<error-correction><quantum-operation><stabilizer-code><stabilizer-state><lattice-surgery>,2,0,,,"Kraus decomposition of merging in lattice surgery <p>I am reading about lattice surgery from <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/14/12/123011/pdf"" rel=""nofollow noreferrer"">this paper</a>. I am interested in the merge operation which takes 2 qubits to 1 qubit. I want to understand the logical-level Kraus operation that the merge does.</p>
<p>For instance, the action of the rough merge between two states <span class=""math-container"">$\vert\psi\rangle = \alpha\vert 0\rangle + \beta\vert 1 \rangle$</span> and <span class=""math-container"">$\vert\phi\rangle$</span> is given by</p>
<p><span class=""math-container"">$$|\psi\rangle \otimes |\phi\rangle\rightarrow \alpha|\phi\rangle+(-1)^M \beta X|\phi\rangle$$</span></p>
<p>where <span class=""math-container"">$M$</span> is the merge measurement result. However, this only tells me what happens to pure product states. What is this in terms of the Kraus operators of the channel that merges the two qubits?</p>
",qc,kraus decomposition merging lattice surgery p reading lattice surgery https nofollow noreferrer paper interested merge operation takes 2 qubits 1 qubit want understand kraus operation merge p instance action rough merge two states span 1 span given p span p span merge measurement result however tells happens pure product states terms kraus operators channel merges two qubits,"[(3, 0.49245292), (4, 0.07070385), (13, 0.030534362), (16, 0.11875121), (18, 0.28493217)]"
38308,,2024-05-15 09:16:55,1,43,"<p>I'm generating a qiskit circuit and want to add an X gate to a qubit if the sum of some previous measurements modulo 2 is equal to 1. In cirq, I could just use a sympy expression that would look something like X(q(10)).with_classical_controls(Mod(q1 + q4 + q7, 2)), where q10 is the qubit I'm applying the X correction to, and q1, q4 and q7 are the measurement who's sum I'm using to control this correction. How can I do this in qiskit?</p>
",Custom classical control in qiskit,<qiskit><programming>,0,2,,,"Custom classical control in qiskit <p>I'm generating a qiskit circuit and want to add an X gate to a qubit if the sum of some previous measurements modulo 2 is equal to 1. In cirq, I could just use a sympy expression that would look something like X(q(10)).with_classical_controls(Mod(q1 + q4 + q7, 2)), where q10 is the qubit I'm applying the X correction to, and q1, q4 and q7 are the measurement who's sum I'm using to control this correction. How can I do this in qiskit?</p>
",qc,custom classical control qiskit p generating qiskit circuit want add x gate qubit sum previous measurements modulo 2 equal cirq could use sympy expression would look something like x q 10 mod q1 q4 q7 2 q10 qubit applying x correction q1 q4 q7 measurement sum using control correction qiskit,"[(2, 0.060554676), (5, 0.049664777), (10, 0.106761515), (14, 0.5495508), (16, 0.05214314), (18, 0.17853293)]"
38312,,2024-05-15 15:27:57,1,40,"<p>Suppose I have a 30 qbit system, due to computational complexity, I can't find the density matrix of the system. But is it possible to find the partial trace of the  a sub-system of 2 qubits out of 30 without explicitly finding the density matrix?</p>
",Finding partial trace in CIRQ,<cirq>,0,3,,,"Finding partial trace in CIRQ <p>Suppose I have a 30 qbit system, due to computational complexity, I can't find the density matrix of the system. But is it possible to find the partial trace of the  a sub-system of 2 qubits out of 30 without explicitly finding the density matrix?</p>
",qc,finding partial trace cirq p suppose 30 qbit system due computational complexity ca find density matrix system possible find partial trace 2 qubits 30 without explicitly finding density matrix,"[(3, 0.2845329), (7, 0.2139327), (11, 0.1964133), (13, 0.049212392), (16, 0.03451235), (17, 0.07807319), (18, 0.13886948)]"
38371,38377.0,2024-05-19 06:37:33,0,156,"<p>According to <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1111.4022</a>, to perform a logical CNOT using lattice surgery, three patches of surface codes are needed and nearest neighbour operations are performed. However, I recently come across a paper <a href=""https://arxiv.org/pdf/2302.01296"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2302.01296</a>. In Figure 1(b) it's claiming that using two patches and CNOT gates between boundary qubits we can perform a logical CNOT gate. What's the premise of this operation? Or perhaps I'm misunderstanding something?</p>
",Confusion about lattice-surgery operation,<error-correction><surface-code><logical-gates><lattice-surgery>,1,0,,,"Confusion about lattice-surgery operation <p>According to <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1111.4022</a>, to perform a logical CNOT using lattice surgery, three patches of surface codes are needed and nearest neighbour operations are performed. However, I recently come across a paper <a href=""https://arxiv.org/pdf/2302.01296"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2302.01296</a>. In Figure 1(b) it's claiming that using two patches and CNOT gates between boundary qubits we can perform a logical CNOT gate. What's the premise of this operation? Or perhaps I'm misunderstanding something?</p>
",qc,confusion operation p according https nofollow noreferrer https perform logical cnot using lattice surgery three patches surface codes needed nearest neighbour operations performed however recently come across paper https nofollow noreferrer https figure 1 b claiming using two patches cnot gates boundary qubits perform logical cnot gate premise operation perhaps misunderstanding something,"[(4, 0.36442113), (5, 0.2590623), (9, 0.22143652), (13, 0.08804051), (16, 0.06416479)]"
38386,,2024-05-20 07:25:11,1,15,"<p>On the web page of the Error Correction Zoo for the <a href=""https://errorcorrectionzoo.org/c/steane#citation-6"" rel=""nofollow noreferrer"">[[7,1,3]] Steane Code</a>, there are quite a few realizations on trapped-ion devices. In fact, there are a lot of implementations generally compared to other devices. For me, this seems like hardware research slightly tilts towards the Steane code.</p>
<p>Does the Steane Code have characteristics that make it especially useful for trapped-ion devices? And could a possible reason be the transversal implementation of the Clifford gates?</p>
",Does the Steane code have characteristics which make it especially useful for trapped-ion devices?,<error-correction><trapped-ion>,0,0,,,"Does the Steane code have characteristics which make it especially useful for trapped-ion devices? <p>On the web page of the Error Correction Zoo for the <a href=""https://errorcorrectionzoo.org/c/steane#citation-6"" rel=""nofollow noreferrer"">[[7,1,3]] Steane Code</a>, there are quite a few realizations on trapped-ion devices. In fact, there are a lot of implementations generally compared to other devices. For me, this seems like hardware research slightly tilts towards the Steane code.</p>
<p>Does the Steane Code have characteristics that make it especially useful for trapped-ion devices? And could a possible reason be the transversal implementation of the Clifford gates?</p>
",qc,steane code characteristics make especially useful devices p web page error correction zoo https nofollow noreferrer steane code quite realizations devices fact lot implementations generally compared devices seems like hardware research slightly tilts towards steane p steane code characteristics make especially useful devices could possible reason transversal implementation clifford gates,"[(5, 0.27715588), (7, 0.1501443), (8, 0.2237989), (9, 0.28243452), (16, 0.063415974)]"
38435,,2024-05-22 11:49:17,0,56,"<p>I am trying to parallelise the function: <code>matching.decode_to_edges_array()</code> to somewhat batch decode, but I am consistently running into the same problem:</p>
<p><code>TypeError: cannot pickle 'pymatching._cpp_pymatching.MatchingGraph' object</code> .</p>
<p>Any help will be much appreciated! I also want to ask if anyone knows why the batch decode equivalent is not available for this function, it would have been very useful for any sort of correlated decoder. What is the technical reason for not being able to batch decode to edges?</p>
<p>Thanks!</p>
",Parallelizing decode_to_edges_array (PyMatching),<error-correction><stim><pymatching>,1,0,,,"Parallelizing decode_to_edges_array (PyMatching) <p>I am trying to parallelise the function: <code>matching.decode_to_edges_array()</code> to somewhat batch decode, but I am consistently running into the same problem:</p>
<p><code>TypeError: cannot pickle 'pymatching._cpp_pymatching.MatchingGraph' object</code> .</p>
<p>Any help will be much appreciated! I also want to ask if anyone knows why the batch decode equivalent is not available for this function, it would have been very useful for any sort of correlated decoder. What is the technical reason for not being able to batch decode to edges?</p>
<p>Thanks!</p>
",qc,parallelizing pymatching p trying parallelise function code somewhat batch decode consistently running problem p code typeerror pickle object p help much appreciated also want ask anyone knows batch decode equivalent available function would useful sort correlated decoder technical reason able batch decode edges p thanks,"[(0, 0.093713254), (5, 0.17420794), (8, 0.31574872), (13, 0.32000336), (16, 0.065820955), (17, 0.027405519)]"
38439,38444.0,2024-05-22 17:31:44,0,65,"<p>Imagine you have merged two surface codes with lattice surgery by measuring all the stabilizers and treating both surface codes as one surface code, then are we doing error correction before or after applying CNOT gate or not? If yes, are we doing error correction on each surface code separately or together after the lattice surgery?</p>
",error correction after lattice surgery for merging,<error-correction><surface-code><lattice-surgery>,1,0,,,"error correction after lattice surgery for merging <p>Imagine you have merged two surface codes with lattice surgery by measuring all the stabilizers and treating both surface codes as one surface code, then are we doing error correction before or after applying CNOT gate or not? If yes, are we doing error correction on each surface code separately or together after the lattice surgery?</p>
",qc,error correction lattice surgery merging p imagine merged two surface codes lattice surgery measuring stabilizers treating surface codes one surface code error correction applying cnot gate yes error correction surface code separately together lattice surgery,"[(5, 0.6302254), (9, 0.078716375), (16, 0.2862278)]"
38446,,2024-05-22 23:24:47,2,123,"<p>Since both rely on Bell inequalities to maintain security, does the Ekert protocol rely on trustworthiness of the devices?</p>
",Do we consider the entangled-based protocol E91 to be a device-independent protocol?,<entanglement><qkd>,2,2,,,"Do we consider the entangled-based protocol E91 to be a device-independent protocol? <p>Since both rely on Bell inequalities to maintain security, does the Ekert protocol rely on trustworthiness of the devices?</p>
",qc,consider protocol e91 protocol p since rely bell inequalities maintain security ekert protocol rely trustworthiness devices,"[(7, 0.06640158), (11, 0.40570697), (16, 0.062454347), (18, 0.45554897)]"
38481,,2024-05-25 00:17:36,0,66,"<p>While doing quantum tomography in cirq, I ended up getting a density matrix which is not positive semi-definite. Why is this so? Here's the code I used:</p>
<pre><code>import cirq
from cirq.experiments import state_tomography
q0, q1, q2 = cirq.LineQubit.range(3)
circuit = cirq.Circuit(
    cirq.CNOT(q0,q1),         
    cirq.CNOT(q0, q2)    
)
simulator = cirq.Simulator()

results = state_tomography(
    sampler=simulator,
    qubits=[q0, q1],
    circuit=circuit,
    repetitions=5000
)
density_matrix = results.data
print(&quot;Reconstructed Density Matrix:&quot;)
print(density_matrix)
eigenvalues, _ = np.linalg.eigh(density_matrix)
print(eigenvalues)
</code></pre>
",Why does cirq produce a non-positive semidefinite density matrix doing quantum tomography?,<cirq>,0,4,,,"Why does cirq produce a non-positive semidefinite density matrix doing quantum tomography? <p>While doing quantum tomography in cirq, I ended up getting a density matrix which is not positive semi-definite. Why is this so? Here's the code I used:</p>
<pre><code>import cirq
from cirq.experiments import state_tomography
q0, q1, q2 = cirq.LineQubit.range(3)
circuit = cirq.Circuit(
    cirq.CNOT(q0,q1),         
    cirq.CNOT(q0, q2)    
)
simulator = cirq.Simulator()

results = state_tomography(
    sampler=simulator,
    qubits=[q0, q1],
    circuit=circuit,
    repetitions=5000
)
density_matrix = results.data
print(&quot;Reconstructed Density Matrix:&quot;)
print(density_matrix)
eigenvalues, _ = np.linalg.eigh(density_matrix)
print(eigenvalues)
</code></pre>
",qc,cirq produce semidefinite density matrix quantum tomography p quantum tomography cirq ended getting density matrix positive code used pre code import cirq import q0 q1 q2 3 circuit q0 q1 q0 q2 simulator results q0 q1 print quot reconstructed density matrix quot print eigenvalues print eigenvalues,"[(0, 0.20651743), (11, 0.23282589), (13, 0.070099995), (14, 0.22761174), (16, 0.21576896), (19, 0.044144243)]"
38555,,2024-05-30 12:40:50,1,72,"<p>I am trying to understand when a quantum channel preserves (part of) the information stored in an error correction code.</p>
<p>Take some <span class=""math-container"">$[[n, k, d]]$</span> quantum code with stabilizer set <span class=""math-container"">$\mathcal{S}$</span>. The codewords are the following set of states</p>
<p><span class=""math-container"">$$\{\vert\psi\rangle: \forall S\in \mathcal{S}, S\vert\psi\rangle = \vert\psi\rangle\}$$</span></p>
<p>Let us apply a quantum channel to the physical qubits such that we get <span class=""math-container"">$n'$</span> qubits in the output. Let us now consider some other <span class=""math-container"">$[[n', k', d']]$</span> quantum code with stabilizer set <span class=""math-container"">$\mathcal{S}'$</span>. If I claim that this channel preserves any logical information of the input code then, what conditions must it satisfy?</p>
<p>For a specific example, consider a merge operation in lattice surgery described <a href=""https://quantumcomputing.stackexchange.com/questions/38266/kraus-decomposition-of-merging-in-lattice-surgery"">here</a>. The effect of the physical operations is that they perform a logical <span class=""math-container"">$Z_1Z_2$</span> measurement and also transform the logical operators of the input code as follows</p>
<p><span class=""math-container"">$$X_1X_2 \rightarrow X, Z_1 \rightarrow Z, Z_2\rightarrow Z$$</span></p>
<p>From this, one infers that the logical CPTP map is the isometry <span class=""math-container"">$|0\rangle\langle 00|+|1\rangle\langle 11|$</span> if the <span class=""math-container"">$Z_1Z_2$</span> measurement is <span class=""math-container"">$+1$</span> and <span class=""math-container"">$|0\rangle\langle 01|+|1\rangle\langle 10|$</span> if the <span class=""math-container"">$Z_1Z_2$</span> measurement is <span class=""math-container"">$-1$</span> as shown in <a href=""https://quantumcomputing.stackexchange.com/questions/38266/kraus-decomposition-of-merging-in-lattice-surgery"">the answer</a>. The answer notes that coherences between <span class=""math-container"">$\vert 00\rangle$</span> and <span class=""math-container"">$\vert 11\rangle$</span> and coherences between <span class=""math-container"">$\vert 01\rangle$</span> and <span class=""math-container"">$\vert 10\rangle$</span> are preserved - so we have an isometry between those subspaces and the subspaces of the output code.</p>
<p>In this example, how does one know that the logical transformation is in fact an isometry on the eigenspaces of <span class=""math-container"">$Z_1Z_2$</span> and that coherences within those eigenspaces are preserved? More generally, how do we see what logical information is preserved during the action of a channel that takes us from one error-correcting code to another?</p>
",When does a channel between two error correcting codes preserve logical information?,<error-correction><information-theory>,1,0,,,"When does a channel between two error correcting codes preserve logical information? <p>I am trying to understand when a quantum channel preserves (part of) the information stored in an error correction code.</p>
<p>Take some <span class=""math-container"">$[[n, k, d]]$</span> quantum code with stabilizer set <span class=""math-container"">$\mathcal{S}$</span>. The codewords are the following set of states</p>
<p><span class=""math-container"">$$\{\vert\psi\rangle: \forall S\in \mathcal{S}, S\vert\psi\rangle = \vert\psi\rangle\}$$</span></p>
<p>Let us apply a quantum channel to the physical qubits such that we get <span class=""math-container"">$n'$</span> qubits in the output. Let us now consider some other <span class=""math-container"">$[[n', k', d']]$</span> quantum code with stabilizer set <span class=""math-container"">$\mathcal{S}'$</span>. If I claim that this channel preserves any logical information of the input code then, what conditions must it satisfy?</p>
<p>For a specific example, consider a merge operation in lattice surgery described <a href=""https://quantumcomputing.stackexchange.com/questions/38266/kraus-decomposition-of-merging-in-lattice-surgery"">here</a>. The effect of the physical operations is that they perform a logical <span class=""math-container"">$Z_1Z_2$</span> measurement and also transform the logical operators of the input code as follows</p>
<p><span class=""math-container"">$$X_1X_2 \rightarrow X, Z_1 \rightarrow Z, Z_2\rightarrow Z$$</span></p>
<p>From this, one infers that the logical CPTP map is the isometry <span class=""math-container"">$|0\rangle\langle 00|+|1\rangle\langle 11|$</span> if the <span class=""math-container"">$Z_1Z_2$</span> measurement is <span class=""math-container"">$+1$</span> and <span class=""math-container"">$|0\rangle\langle 01|+|1\rangle\langle 10|$</span> if the <span class=""math-container"">$Z_1Z_2$</span> measurement is <span class=""math-container"">$-1$</span> as shown in <a href=""https://quantumcomputing.stackexchange.com/questions/38266/kraus-decomposition-of-merging-in-lattice-surgery"">the answer</a>. The answer notes that coherences between <span class=""math-container"">$\vert 00\rangle$</span> and <span class=""math-container"">$\vert 11\rangle$</span> and coherences between <span class=""math-container"">$\vert 01\rangle$</span> and <span class=""math-container"">$\vert 10\rangle$</span> are preserved - so we have an isometry between those subspaces and the subspaces of the output code.</p>
<p>In this example, how does one know that the logical transformation is in fact an isometry on the eigenspaces of <span class=""math-container"">$Z_1Z_2$</span> and that coherences within those eigenspaces are preserved? More generally, how do we see what logical information is preserved during the action of a channel that takes us from one error-correcting code to another?</p>
",qc,channel two error correcting codes preserve logical information p trying understand quantum channel preserves part information stored error correction p take span n k quantum code stabilizer set span codewords following set states p span p let us apply quantum channel physical qubits get span n qubits output let us consider span n k quantum code stabilizer set span claim channel preserves logical information input code conditions must satisfy p specific example consider merge operation lattice surgery described https effect physical operations perform logical span measurement also transform logical operators input code follows p span x z z p one infers logical cptp map isometry span span measurement span span span measurement span shown https answer answer notes coherences span span coherences span span preserved isometry subspaces subspaces output p example one know logical transformation fact isometry eigenspaces span coherences within eigenspaces preserved generally see logical information preserved action channel takes us one code another,"[(3, 0.6443836), (5, 0.23201324), (14, 0.08027913), (16, 0.015587931), (18, 0.02676251)]"
38624,38625.0,2024-06-04 09:59:13,2,132,"<p>I have a unitary gate <span class=""math-container"">$U$</span>, which is applied on some <span class=""math-container"">$n$</span>-qubit quantum circuit (<span class=""math-container"">$n=7$</span> for my scenario). I wish to find the <span class=""math-container"">$n$</span>-qubit state, which is the eigenvector (and possibly eigenvalues) of this unitary in Qiskit's latest version. How do I do that?</p>
",Finding Eigenvectors of a Unitary in a Quantum circuit,<qiskit><quantum-state><programming>,1,0,,,"Finding Eigenvectors of a Unitary in a Quantum circuit <p>I have a unitary gate <span class=""math-container"">$U$</span>, which is applied on some <span class=""math-container"">$n$</span>-qubit quantum circuit (<span class=""math-container"">$n=7$</span> for my scenario). I wish to find the <span class=""math-container"">$n$</span>-qubit state, which is the eigenvector (and possibly eigenvalues) of this unitary in Qiskit's latest version. How do I do that?</p>
",qc,finding eigenvectors unitary quantum circuit p unitary gate span u applied span n quantum circuit span scenario wish find span n state eigenvector possibly eigenvalues unitary qiskit latest version,"[(3, 0.7329167), (14, 0.23483612), (16, 0.026423916)]"
38635,,2024-06-04 21:48:22,1,216,"<p>Proofs of correctness for fault-tolerance schemes rarely give tight constants for error correction performance. However, they do provide formal reasoning that a scheme is correct and all the pieces fit together in the appropriate way. The combination of a proof and simulations could be said to be the gold standard for a fault-tolerance scheme.</p>
<p>A threshold for memory was shown in the well known paper by <a href=""http://aip.scitation.org/doi/10.1063/1.1499754"" rel=""nofollow noreferrer"">Dennis-Kitaev-Landahl-Preskill</a>, but, as far as I can tell, there has not been a published threshold theorem for universal fault-tolerant <em>computation</em> using surface codes.</p>
<p>Fixing the scheme to be the usual lattice surgery + magic state distillation and considering circuit-level depolarizing noise, I am satisfied that a threshold for the lattice surgery steps nearly immediately follows from the usual LDPC threshold techniques by <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.87.020304"" rel=""nofollow noreferrer"">Kovalev-Pryadko</a> and <a href=""https://arxiv.org/abs/1310.2984"" rel=""nofollow noreferrer"">Gottesman</a>.</p>
<p>However, in order to perform magic state distillation, we need a way of performing state injection. That is, for an arbitrary state <span class=""math-container"">$|\psi\rangle$</span>, to prepare a logical state <span class=""math-container"">$\rho$</span> of a distance-<span class=""math-container"">$d$</span> surface code such that it is correctable to <span class=""math-container"">$|\bar{\psi} \rangle$</span> with probability at least <span class=""math-container"">$1-\epsilon$</span>** as <span class=""math-container"">$d \to \infty$</span>. There is a gadget that appears to have these properties numerically in <a href=""https://arxiv.org/abs/1410.7808"" rel=""nofollow noreferrer"">Li's paper</a>, but I believe it was not formally argued.</p>
<p>Is there a known formal proof in the literature of the existence of such a gadget?</p>
<p>** <span class=""math-container"">$\epsilon$</span> should be a small constant like <span class=""math-container"">$1/100$</span> such that we can use magic state distillation.</p>
",Is there a proof in the literature of magic state injection for surface codes?,<surface-code><fault-tolerance><magic-states>,1,4,,,"Is there a proof in the literature of magic state injection for surface codes? <p>Proofs of correctness for fault-tolerance schemes rarely give tight constants for error correction performance. However, they do provide formal reasoning that a scheme is correct and all the pieces fit together in the appropriate way. The combination of a proof and simulations could be said to be the gold standard for a fault-tolerance scheme.</p>
<p>A threshold for memory was shown in the well known paper by <a href=""http://aip.scitation.org/doi/10.1063/1.1499754"" rel=""nofollow noreferrer"">Dennis-Kitaev-Landahl-Preskill</a>, but, as far as I can tell, there has not been a published threshold theorem for universal fault-tolerant <em>computation</em> using surface codes.</p>
<p>Fixing the scheme to be the usual lattice surgery + magic state distillation and considering circuit-level depolarizing noise, I am satisfied that a threshold for the lattice surgery steps nearly immediately follows from the usual LDPC threshold techniques by <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.87.020304"" rel=""nofollow noreferrer"">Kovalev-Pryadko</a> and <a href=""https://arxiv.org/abs/1310.2984"" rel=""nofollow noreferrer"">Gottesman</a>.</p>
<p>However, in order to perform magic state distillation, we need a way of performing state injection. That is, for an arbitrary state <span class=""math-container"">$|\psi\rangle$</span>, to prepare a logical state <span class=""math-container"">$\rho$</span> of a distance-<span class=""math-container"">$d$</span> surface code such that it is correctable to <span class=""math-container"">$|\bar{\psi} \rangle$</span> with probability at least <span class=""math-container"">$1-\epsilon$</span>** as <span class=""math-container"">$d \to \infty$</span>. There is a gadget that appears to have these properties numerically in <a href=""https://arxiv.org/abs/1410.7808"" rel=""nofollow noreferrer"">Li's paper</a>, but I believe it was not formally argued.</p>
<p>Is there a known formal proof in the literature of the existence of such a gadget?</p>
<p>** <span class=""math-container"">$\epsilon$</span> should be a small constant like <span class=""math-container"">$1/100$</span> such that we can use magic state distillation.</p>
",qc,proof literature magic state injection surface codes p proofs correctness schemes rarely give tight constants error correction performance however provide formal reasoning scheme correct pieces fit together appropriate way combination proof simulations could said gold standard p threshold memory shown well known paper http nofollow noreferrer far tell published threshold theorem universal em computation using surface p fixing scheme usual lattice surgery magic state distillation considering depolarizing noise satisfied threshold lattice surgery steps nearly immediately follows usual ldpc threshold techniques https nofollow noreferrer https nofollow noreferrer gottesman p however order perform magic state distillation need way performing state injection arbitrary state span prepare logical state span span surface code correctable span probability least span span gadget appears properties numerically https nofollow noreferrer li paper believe formally p known formal proof literature existence gadget p span small constant like span use magic state,"[(3, 0.11528505), (5, 0.28293866), (9, 0.48897415), (16, 0.028703192), (18, 0.08303618)]"
38668,39696.0,2024-06-07 11:59:36,6,122,"<p>Is there a generally accepted definition of what a color code is?</p>
<p>I have found two definitions that I am not able to reconciliate with each other:</p>
<ol>
<li><p>The error correction zoo defines <a href=""https://errorcorrectionzoo.org/c/color"" rel=""noreferrer"">color codes</a> via <strong>homogeneous simplicial complexes</strong> as the triangulation of a single simplex and qubits are placed on <strong>simplices</strong>.</p>
</li>
<li><p>In <a href=""https://arxiv.org/abs/1311.0277"" rel=""noreferrer"">An Introduction to Topological Quantum Codes</a> in section 5, color codes are introduced as lattices that come with vertices and faces (at least, in the 2-D case) where qubits are on the <strong>vertices</strong> and the plaquettes denote X- and Z-stabilizers.</p>
</li>
</ol>
<p>The examples that I have come accross so far (Steane, honeycomb, 4-8-8 lattice) all seem to fit the second definition, but <strong>not the first</strong>.</p>
<p>Are the two definitions equivalent? If yes, why? If not, what is the &quot;correct&quot; / generally accepted definition?</p>
",What is the definition of color codes?,<error-correction><color-code>,1,2,,,"What is the definition of color codes? <p>Is there a generally accepted definition of what a color code is?</p>
<p>I have found two definitions that I am not able to reconciliate with each other:</p>
<ol>
<li><p>The error correction zoo defines <a href=""https://errorcorrectionzoo.org/c/color"" rel=""noreferrer"">color codes</a> via <strong>homogeneous simplicial complexes</strong> as the triangulation of a single simplex and qubits are placed on <strong>simplices</strong>.</p>
</li>
<li><p>In <a href=""https://arxiv.org/abs/1311.0277"" rel=""noreferrer"">An Introduction to Topological Quantum Codes</a> in section 5, color codes are introduced as lattices that come with vertices and faces (at least, in the 2-D case) where qubits are on the <strong>vertices</strong> and the plaquettes denote X- and Z-stabilizers.</p>
</li>
</ol>
<p>The examples that I have come accross so far (Steane, honeycomb, 4-8-8 lattice) all seem to fit the second definition, but <strong>not the first</strong>.</p>
<p>Are the two definitions equivalent? If yes, why? If not, what is the &quot;correct&quot; / generally accepted definition?</p>
",qc,definition color codes p generally accepted definition color code p found two definitions able reconciliate ol li p error correction zoo defines https noreferrer color codes via strong homogeneous simplicial complexes triangulation single simplex qubits placed strong simplices li p https noreferrer introduction topological quantum codes section 5 color codes introduced lattices come vertices faces least case qubits strong vertices plaquettes denote p examples come accross far steane honeycomb lattice seem fit second definition strong first p two definitions equivalent yes quot correct quot generally accepted definition,"[(3, 0.0299156), (5, 0.2676702), (6, 0.01108986), (7, 0.43365777), (9, 0.09906306), (13, 0.12189748), (16, 0.011643565), (19, 0.023682259)]"
38691,,2024-06-09 00:06:16,0,34,"<p>After applying the hadamard gate to a 0 state qutrit, I should be able to get it into the + state, but how do I then measure the circuit in the X basis as opposed to the computational basis?</p>
",How do I perform measurements in the X basis for qutrits in cirq?,<quantum-gate><quantum-state><measurement><cirq>,0,1,,,"How do I perform measurements in the X basis for qutrits in cirq? <p>After applying the hadamard gate to a 0 state qutrit, I should be able to get it into the + state, but how do I then measure the circuit in the X basis as opposed to the computational basis?</p>
",qc,perform measurements x basis qutrits cirq p applying hadamard gate 0 state qutrit able get state measure circuit x basis opposed computational basis,"[(2, 0.047850806), (9, 0.19072455), (10, 0.09284682), (16, 0.04355093), (18, 0.61856)]"
38773,38794.0,2024-06-14 20:40:12,1,35,"<p>Is there any sort of migration guide from the classic QDK to the modern QDK. When I am trying to use functions, I keep running into this</p>
<blockquote>
<p>This documentation refers to the Classic QDK, which has been replaced by the Modern QDK.
Please see <a href=""https://aka.ms/qdk.api"" rel=""nofollow noreferrer"">https://aka.ms/qdk.api</a> for the API documentation for the Modern QDK.</p>
</blockquote>
<p>However, the link just goes to the repository. It has been frustrating to try and figure out some of the new syntax changes e.g.</p>
<p><code>using (...)</code> to <code>use</code></p>
<p>and also how many of the functions simply do not exist or take in completely different arguments now.</p>
",Migration guide from Classic QDK to Modern QDK for Q#,<q#><azure-quantum>,1,0,,,"Migration guide from Classic QDK to Modern QDK for Q# <p>Is there any sort of migration guide from the classic QDK to the modern QDK. When I am trying to use functions, I keep running into this</p>
<blockquote>
<p>This documentation refers to the Classic QDK, which has been replaced by the Modern QDK.
Please see <a href=""https://aka.ms/qdk.api"" rel=""nofollow noreferrer"">https://aka.ms/qdk.api</a> for the API documentation for the Modern QDK.</p>
</blockquote>
<p>However, the link just goes to the repository. It has been frustrating to try and figure out some of the new syntax changes e.g.</p>
<p><code>using (...)</code> to <code>use</code></p>
<p>and also how many of the functions simply do not exist or take in completely different arguments now.</p>
",qc,migration guide classic qdk modern qdk q p sort migration guide classic qdk modern qdk trying use functions keep running blockquote p documentation refers classic qdk replaced modern qdk please see https nofollow noreferrer https api documentation modern p however link goes repository frustrating try figure new syntax changes p code using code use p also many functions simply exist take completely different arguments,"[(0, 0.12290287), (4, 0.11989716), (8, 0.08619181), (9, 0.3284387), (13, 0.13336037), (14, 0.19567288), (16, 0.011476653)]"
38958,,2024-06-29 14:13:17,2,46,"<p>I'm exploring quantum attacks (in the Q1 model) on symmetric structures, including hash functions, block ciphers, modes of operation and stream ciphers with time complexity beyond quadratic speedup. I've found a couple of resources:  <a href=""https://link.springer.com/article/10.1007/s11128-022-03499-5"" rel=""nofollow noreferrer"">Link1</a>, <a href=""https://www.rd.ntt/e/research/JN202305_21871.html"" rel=""nofollow noreferrer"">link2</a> and <a href=""https://link.springer.com/chapter/10.1007/978-3-031-07082-2_12"" rel=""nofollow noreferrer"">Link3</a>. I’d appreciate any additional recommendations you might have. Thank you!</p>
",Seeking Recommendations on Quantum Attacks,<quantum-algorithms><grovers-algorithm><resource-request><cryptography>,0,2,,,"Seeking Recommendations on Quantum Attacks <p>I'm exploring quantum attacks (in the Q1 model) on symmetric structures, including hash functions, block ciphers, modes of operation and stream ciphers with time complexity beyond quadratic speedup. I've found a couple of resources:  <a href=""https://link.springer.com/article/10.1007/s11128-022-03499-5"" rel=""nofollow noreferrer"">Link1</a>, <a href=""https://www.rd.ntt/e/research/JN202305_21871.html"" rel=""nofollow noreferrer"">link2</a> and <a href=""https://link.springer.com/chapter/10.1007/978-3-031-07082-2_12"" rel=""nofollow noreferrer"">Link3</a>. I’d appreciate any additional recommendations you might have. Thank you!</p>
",qc,seeking recommendations quantum attacks p exploring quantum attacks q1 model symmetric structures including hash functions block ciphers modes operation stream ciphers time complexity beyond quadratic speedup found couple resources https nofollow noreferrer link1 https nofollow noreferrer link2 https nofollow noreferrer link3 appreciate additional recommendations might thank,"[(1, 0.17725994), (4, 0.2108646), (8, 0.2897774), (9, 0.2792126), (16, 0.039408434)]"
38994,,2024-07-02 18:40:31,1,104,"<p>I want to understand why this gate is symmetric.</p>
<p>Consider a two qubits circuit (q1, q2) with a gate CZ controlled by the first q1, then if q1 is in the state <span class=""math-container"">$(a, b)^T$</span> and q2 is the state <span class=""math-container"">$(c, d)^T$</span>, the system is in state <span class=""math-container"">$(a, b)^T\otimes (c, d)^T= (ac, ad, bc, bd)^T= \psi$</span> using Kronecker product.</p>
<p>Given that <span class=""math-container"">$$CZ= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1 
\end{pmatrix} $$</span> we can find that the system after the gate is applied will be in the state <span class=""math-container"">$CZ.\psi= (ac, ad, bc, -bd)^T$</span></p>
<p>Now, let us consider q2 to be the controlling qubit and q1 to be the target; then <span class=""math-container"">$CZ$</span> should be applied to <span class=""math-container"">$\psi'= (c, d)^T\otimes (a, b)^T= (ca, cb, da, db)^T$</span> ( one way to think about it is to leave the gate fixed and swap q1 and q2 positions )</p>
<p>to result in <span class=""math-container"">$CZ.\psi'= (ac, bc, ad, -bd)^T$</span>, but this is not equal to <span class=""math-container"">$CZ.\psi$</span>. Notice how it is almost the same if we exchange the second and third coordinates.</p>
<p>What am I missing?</p>
<p>My problem is that the 'swap' gate changes the state of the whole system, or that we should abandon the Kronecker representation of the tensor product??</p>
",Why is the controlled-Z gate a symmetric gate?,<quantum-gate>,1,0,,,"Why is the controlled-Z gate a symmetric gate? <p>I want to understand why this gate is symmetric.</p>
<p>Consider a two qubits circuit (q1, q2) with a gate CZ controlled by the first q1, then if q1 is in the state <span class=""math-container"">$(a, b)^T$</span> and q2 is the state <span class=""math-container"">$(c, d)^T$</span>, the system is in state <span class=""math-container"">$(a, b)^T\otimes (c, d)^T= (ac, ad, bc, bd)^T= \psi$</span> using Kronecker product.</p>
<p>Given that <span class=""math-container"">$$CZ= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1 
\end{pmatrix} $$</span> we can find that the system after the gate is applied will be in the state <span class=""math-container"">$CZ.\psi= (ac, ad, bc, -bd)^T$</span></p>
<p>Now, let us consider q2 to be the controlling qubit and q1 to be the target; then <span class=""math-container"">$CZ$</span> should be applied to <span class=""math-container"">$\psi'= (c, d)^T\otimes (a, b)^T= (ca, cb, da, db)^T$</span> ( one way to think about it is to leave the gate fixed and swap q1 and q2 positions )</p>
<p>to result in <span class=""math-container"">$CZ.\psi'= (ac, bc, ad, -bd)^T$</span>, but this is not equal to <span class=""math-container"">$CZ.\psi$</span>. Notice how it is almost the same if we exchange the second and third coordinates.</p>
<p>What am I missing?</p>
<p>My problem is that the 'swap' gate changes the state of the whole system, or that we should abandon the Kronecker representation of the tensor product??</p>
",qc,gate symmetric gate p want understand gate p consider two qubits circuit q1 q2 gate cz controlled first q1 q1 state span b q2 state span c system state span b c ac ad bc bd using kronecker p given span pmatrix 1 amp 0 amp 0 amp 0 0 amp 1 amp 0 amp 0 0 amp 0 amp 1 amp 0 0 amp 0 amp 0 amp pmatrix find system gate applied state span ac ad bc p let us consider q2 controlling qubit q1 target span cz applied span c b ca cb da db one way think leave gate fixed swap q1 q2 positions p result span ac bc ad equal span notice almost exchange second third p missing p problem gate changes state whole system abandon kronecker representation tensor product,"[(2, 0.1016068), (3, 0.22207616), (9, 0.04509409), (15, 0.36538962), (16, 0.042224754), (18, 0.21421926)]"
39041,,2024-07-07 01:30:07,4,108,"<p>Let <span class=""math-container"">$\mathcal{H}$</span> be a <span class=""math-container"">$d$</span>-dimensional Hilbert space equipped with the Haar measure. Levy's lemma says that, for an <span class=""math-container"">$L$</span> -Lipschitz function <span class=""math-container"">$f$</span> on <span class=""math-container"">$\mathcal{H}$</span>, the probability that <span class=""math-container"">$f(x)$</span> for a randomly drawn unit vector <span class=""math-container"">$x$</span> deviates from its expected value <span class=""math-container"">$\mathbb{E}[f]$</span> by more than some <span class=""math-container"">$\delta &gt; 0$</span> is at most exponentially small in <span class=""math-container"">$d$</span>. Specifically,</p>
<p><span class=""math-container"">$$\Pr(|f(x) - \mathbb{E}[f]| \geq \delta) \leq 2 \exp\left( -\frac{C d \delta^2}{L^2} \right)$$</span></p>
<p>for some absolute constant <span class=""math-container"">$C &gt; 0$</span>.</p>
<p>Suppose that instead of the Haar measure, we take a <span class=""math-container"">$t$</span>-design over the unit vectors. Does Levy's lemma, or some modified form of it, hold for sufficiently small <span class=""math-container"">$t$</span>? By &quot;sufficiently small&quot; I am thinking of something like: let <span class=""math-container"">$f$</span> be a polynomial in <span class=""math-container"">$x$</span> with bounded degree <span class=""math-container"">$k$</span>, then <span class=""math-container"">$t = O(k)$</span> would be reasonable. A common class of functions are of the form <span class=""math-container"">$f(x) = \langle x | A | x \rangle$</span> for a fixed operator <span class=""math-container"">$A$</span>, which have <span class=""math-container"">$k = 2$</span>. On the other hand, if <span class=""math-container"">$t = \Omega(d)$</span> is necessary, then this would be too large to be useful (but good to know).</p>
",Does Levy's lemma hold for unitary/spherical designs?,<probability><t-designs>,0,0,,,"Does Levy's lemma hold for unitary/spherical designs? <p>Let <span class=""math-container"">$\mathcal{H}$</span> be a <span class=""math-container"">$d$</span>-dimensional Hilbert space equipped with the Haar measure. Levy's lemma says that, for an <span class=""math-container"">$L$</span> -Lipschitz function <span class=""math-container"">$f$</span> on <span class=""math-container"">$\mathcal{H}$</span>, the probability that <span class=""math-container"">$f(x)$</span> for a randomly drawn unit vector <span class=""math-container"">$x$</span> deviates from its expected value <span class=""math-container"">$\mathbb{E}[f]$</span> by more than some <span class=""math-container"">$\delta &gt; 0$</span> is at most exponentially small in <span class=""math-container"">$d$</span>. Specifically,</p>
<p><span class=""math-container"">$$\Pr(|f(x) - \mathbb{E}[f]| \geq \delta) \leq 2 \exp\left( -\frac{C d \delta^2}{L^2} \right)$$</span></p>
<p>for some absolute constant <span class=""math-container"">$C &gt; 0$</span>.</p>
<p>Suppose that instead of the Haar measure, we take a <span class=""math-container"">$t$</span>-design over the unit vectors. Does Levy's lemma, or some modified form of it, hold for sufficiently small <span class=""math-container"">$t$</span>? By &quot;sufficiently small&quot; I am thinking of something like: let <span class=""math-container"">$f$</span> be a polynomial in <span class=""math-container"">$x$</span> with bounded degree <span class=""math-container"">$k$</span>, then <span class=""math-container"">$t = O(k)$</span> would be reasonable. A common class of functions are of the form <span class=""math-container"">$f(x) = \langle x | A | x \rangle$</span> for a fixed operator <span class=""math-container"">$A$</span>, which have <span class=""math-container"">$k = 2$</span>. On the other hand, if <span class=""math-container"">$t = \Omega(d)$</span> is necessary, then this would be too large to be useful (but good to know).</p>
",qc,levy lemma hold designs p let span h span hilbert space equipped haar measure levy lemma says span l function span f span h probability span f x randomly drawn unit vector span x deviates expected value span e f span gt 0 exponentially small span specifically p span x e f 2 c p absolute constant span c gt 0 p suppose instead haar measure take span unit vectors levy lemma modified form hold sufficiently small span quot sufficiently small quot thinking something like let span f polynomial span x bounded degree span k span k would reasonable common class functions form span f x x x fixed operator span span k 2 hand span necessary would large useful good know,"[(2, 0.021474758), (3, 0.75956273), (10, 0.14979927), (15, 0.029871104), (16, 0.013012016), (19, 0.025131285)]"
39059,,2024-07-08 18:43:16,1,79,"<p>I was reading Litinski's A game of surface codes (<a href=""https://quantum-journal.org/papers/q-2019-03-05-128/pdf/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2019-03-05-128/pdf/</a>). In the introduction (page 2), the paper talks about operations like &quot;moving edges&quot; and &quot;moving corners&quot; leading to surface code patches where the X/Z boundaries are of different lengths and of irregular shapes (by irregular I mean that a surface code edge may partly be an &quot;X edge&quot; and partly a &quot;Z edge&quot;). What is the physical intuition behind these operations? As in, how are the stabilizers or data qubits getting modified to accomplish this? Also, why does &quot;expanding a surface code patch&quot; or &quot;moving a corner&quot; take d cycles?</p>
<p>Further, can we &quot;move a corner&quot; to the middle of an edge? Or does it have to move to another corner of the patch? An illustrative example would also help. Say, how can we create the wide qubit (Figure 2 of <a href=""https://quantum-journal.org/papers/q-2018-05-04-62/pdf/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2018-05-04-62/pdf/</a> - Litinski and Oppen's Lattice Surgery with a Twist) from one or more regular surface code qubits (For example, the one shown in Figure 1 of <a href=""https://quantum-journal.org/papers/q-2018-05-04-62/pdf/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2018-05-04-62/pdf/</a>)</p>
<p>Thanks!</p>
","What is the physical operation behind ""moving edges"" and ""moving corners"" in Litinski's game of surface codes paper?",<error-correction><surface-code>,1,0,,,"What is the physical operation behind ""moving edges"" and ""moving corners"" in Litinski's game of surface codes paper? <p>I was reading Litinski's A game of surface codes (<a href=""https://quantum-journal.org/papers/q-2019-03-05-128/pdf/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2019-03-05-128/pdf/</a>). In the introduction (page 2), the paper talks about operations like &quot;moving edges&quot; and &quot;moving corners&quot; leading to surface code patches where the X/Z boundaries are of different lengths and of irregular shapes (by irregular I mean that a surface code edge may partly be an &quot;X edge&quot; and partly a &quot;Z edge&quot;). What is the physical intuition behind these operations? As in, how are the stabilizers or data qubits getting modified to accomplish this? Also, why does &quot;expanding a surface code patch&quot; or &quot;moving a corner&quot; take d cycles?</p>
<p>Further, can we &quot;move a corner&quot; to the middle of an edge? Or does it have to move to another corner of the patch? An illustrative example would also help. Say, how can we create the wide qubit (Figure 2 of <a href=""https://quantum-journal.org/papers/q-2018-05-04-62/pdf/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2018-05-04-62/pdf/</a> - Litinski and Oppen's Lattice Surgery with a Twist) from one or more regular surface code qubits (For example, the one shown in Figure 1 of <a href=""https://quantum-journal.org/papers/q-2018-05-04-62/pdf/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2018-05-04-62/pdf/</a>)</p>
<p>Thanks!</p>
",qc,physical operation behind moving edges moving corners litinski game surface codes paper p reading litinski game surface codes https nofollow noreferrer https introduction page 2 paper talks operations like quot moving edges quot quot moving corners quot leading surface code patches boundaries different lengths irregular shapes irregular mean surface code edge may partly quot x edge quot partly quot z edge quot physical intuition behind operations stabilizers data qubits getting modified accomplish also quot expanding surface code patch quot quot moving corner quot take cycles p quot move corner quot middle edge move another corner patch illustrative example would also help say create wide qubit figure 2 https nofollow noreferrer https litinski oppen lattice surgery twist one regular surface code qubits example one shown figure 1 https nofollow noreferrer https p thanks,"[(4, 0.2400123), (5, 0.20314303), (9, 0.09031769), (13, 0.32842842), (16, 0.02408189), (19, 0.11294815)]"
39067,,2024-07-09 09:22:35,1,60,"<p>As of today, is there any QML algorithm that performs better than a classical one in practice? I have been looking for quantum neural networks, quantum kernels and quantum CNN, but none so far have come up with a better-performing model than it's classical counterpart.</p>
",Is there any QML algorithm that performs better than a classical one in practice?,<quantum-algorithms><quantum-advantage><quantum-enhanced-machine-learning><quantum-neural-network><quantum-kernel>,0,4,,,"Is there any QML algorithm that performs better than a classical one in practice? <p>As of today, is there any QML algorithm that performs better than a classical one in practice? I have been looking for quantum neural networks, quantum kernels and quantum CNN, but none so far have come up with a better-performing model than it's classical counterpart.</p>
",qc,qml algorithm performs better classical one practice p today qml algorithm performs better classical one practice looking quantum neural networks quantum kernels quantum cnn none far come model classical,"[(1, 0.14697886), (7, 0.07530605), (8, 0.73621905), (16, 0.035821028)]"
39126,,2024-07-12 17:18:46,3,53,"<p>In Nielsen Chuang section 2.2.6 as they are introducing POVMs they write “The acronym POVM stands for ‘Positive Operator-Valued Measure’, a technical term whose historical origins we won’t worry about.” I was curious and tried to google the origin of the term and got absolutely nothing. Understanding the origins of terms tends to help me keep them all straight. Does anyone know where the term came from?</p>
",What is the origin of the term POVM?,<measurement><nielsen-and-chuang><terminology-and-notation><povm><history>,0,2,,,"What is the origin of the term POVM? <p>In Nielsen Chuang section 2.2.6 as they are introducing POVMs they write “The acronym POVM stands for ‘Positive Operator-Valued Measure’, a technical term whose historical origins we won’t worry about.” I was curious and tried to google the origin of the term and got absolutely nothing. Understanding the origins of terms tends to help me keep them all straight. Does anyone know where the term came from?</p>
",qc,origin term povm p nielsen chuang section introducing povms write acronym povm stands positive measure technical term whose historical origins worry curious tried google origin term got absolutely nothing understanding origins terms tends help keep straight anyone know term came,"[(3, 0.46845677), (8, 0.067797735), (9, 0.21598387), (12, 0.07590404), (13, 0.14322329), (16, 0.025145078)]"
39196,,2024-07-18 17:10:55,0,102,"<p>The surface code is a CSS code, so assuming all-to-all connectivity (unrealistic on most physical platforms), the logical CNOT can be implemented transversally. In a biplanar architecture, the setup to implement transversal CNOT can be accomplished by placing one surface code patch over another. Aside, from this lattice surgery and puncturing &amp; braiding methods exist.</p>
<p>I want to ask in a similar vein, what are all the known ways to implement the logical controlled-phase (CZ) gate on the surface code?</p>
<p>(L.S. and braiding ought to work for implementing both logical CNOT and CZ gates, so it would be nice to know what are the leading methods preferred by the community!)</p>
",What are existing ways to do logical CZ gates on the surface code?,<surface-code><logical-gates>,1,0,,,"What are existing ways to do logical CZ gates on the surface code? <p>The surface code is a CSS code, so assuming all-to-all connectivity (unrealistic on most physical platforms), the logical CNOT can be implemented transversally. In a biplanar architecture, the setup to implement transversal CNOT can be accomplished by placing one surface code patch over another. Aside, from this lattice surgery and puncturing &amp; braiding methods exist.</p>
<p>I want to ask in a similar vein, what are all the known ways to implement the logical controlled-phase (CZ) gate on the surface code?</p>
<p>(L.S. and braiding ought to work for implementing both logical CNOT and CZ gates, so it would be nice to know what are the leading methods preferred by the community!)</p>
",qc,existing ways logical cz gates surface code p surface code css code assuming connectivity unrealistic physical platforms logical cnot implemented transversally biplanar architecture setup implement transversal cnot accomplished placing one surface code patch another aside lattice surgery puncturing amp braiding methods p want ask similar vein known ways implement logical cz gate surface code p braiding ought work implementing logical cnot cz gates would nice know leading methods preferred community,"[(5, 0.34059623), (7, 0.03126071), (9, 0.4251587), (11, 0.15601361), (15, 0.015856424), (16, 0.029114347)]"
39217,,2024-07-19 11:43:07,0,22,"<p>I am running a Quantum Process Tomography on a circuit with a custom pulse added to a calibation for a CNOT gate.</p>
<p>Upon running the circuit, running it on the backend takes forever and eventually ends up crashing the kernel.</p>
<p>I have changed the amount of shots from <code>shots=1024</code> to <code>shots=16</code> but the code continues to run and not work.</p>
<p>Here is what I am working with:</p>
<pre><code># circuit
qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.measure_all()

# pulse
with pulse.build(backend, name='cx') as cx0:
    pulse.play(Gaussian(duration=128, amp=0.1, sigma=16), pulse.drive_channel(0))

cx0.draw()    

# add calibration
qc.add_calibration('cx', [0], cx0) 

# generate pass manager 
backend = FakeHanoiV2()
passmanager = generate_preset_pass_manager(optimization_level=1, backend=backend)
qc = passmanager.run(qc)
 
# print instructions that only affect qubits 0 and 1
for instruction, qubits in FakeManilaV2().instructions:
    if qubits and set(qubits).issubset({0, 1}):
        print(instruction, qubits)
qc.draw('mpl', idle_wires=False)
</code></pre>
<p>Here is the QPT where I think the issue is:</p>
<pre><code># Set up the QPT experiment
qpt_qc = ProcessTomography(qc)

#Run
qstdata_qc = qpt_qc.run(backend=backend, seed_simulation=100, shots=16).block_for_results()

#Results 
for result in qstdata_qc.analysis_results():
    print(result)
</code></pre>
<p>Any help would be great, cheers</p>
",Process Tomography and transpiler not running and eventually crashing kernel,<programming><quantum-circuit><ibm-quantum-devices><quantum-process-tomography><openpulse>,0,0,,,"Process Tomography and transpiler not running and eventually crashing kernel <p>I am running a Quantum Process Tomography on a circuit with a custom pulse added to a calibation for a CNOT gate.</p>
<p>Upon running the circuit, running it on the backend takes forever and eventually ends up crashing the kernel.</p>
<p>I have changed the amount of shots from <code>shots=1024</code> to <code>shots=16</code> but the code continues to run and not work.</p>
<p>Here is what I am working with:</p>
<pre><code># circuit
qc = QuantumCircuit(2)
qc.cx(0, 1)
qc.measure_all()

# pulse
with pulse.build(backend, name='cx') as cx0:
    pulse.play(Gaussian(duration=128, amp=0.1, sigma=16), pulse.drive_channel(0))

cx0.draw()    

# add calibration
qc.add_calibration('cx', [0], cx0) 

# generate pass manager 
backend = FakeHanoiV2()
passmanager = generate_preset_pass_manager(optimization_level=1, backend=backend)
qc = passmanager.run(qc)
 
# print instructions that only affect qubits 0 and 1
for instruction, qubits in FakeManilaV2().instructions:
    if qubits and set(qubits).issubset({0, 1}):
        print(instruction, qubits)
qc.draw('mpl', idle_wires=False)
</code></pre>
<p>Here is the QPT where I think the issue is:</p>
<pre><code># Set up the QPT experiment
qpt_qc = ProcessTomography(qc)

#Run
qstdata_qc = qpt_qc.run(backend=backend, seed_simulation=100, shots=16).block_for_results()

#Results 
for result in qstdata_qc.analysis_results():
    print(result)
</code></pre>
<p>Any help would be great, cheers</p>
",qc,process tomography transpiler running eventually crashing kernel p running quantum process tomography circuit custom pulse added calibation cnot p upon running circuit running backend takes forever eventually ends crashing p changed amount shots code code code continues run p working pre code circuit qc quantumcircuit 2 0 1 pulse backend cx0 gaussian 0 add calibration 0 cx0 generate pass manager backend fakehanoiv2 passmanager qc qc print instructions affect qubits 0 1 instruction qubits fakemanilav2 qubits set qubits 0 1 print instruction qubits p qpt think issue pre code set qpt experiment processtomography qc run results result print result p help would great cheers,"[(0, 0.43195245), (2, 0.089617446), (13, 0.07509127), (14, 0.39167348), (16, 0.010180792)]"
39276,39278.0,2024-07-24 22:49:32,1,120,"<p>I'm looking for open-source code that implements lattice surgery merging and splitting between two rotated surface code logical qubits in STIM (for d=3 or above).</p>
<p>Whilst there are some excellent explanations on this site (thank you users Craig Gidney and &quot;control freak&quot;), I'm struggling to correctly implement lattice surgery in STIM. Mostly, this is because of the complexity and finickiness of implementing the merge and split operations and ensuring I introduce/remove detectors appropriately. It does not help that I am new to QEC either. What I'm looking for seems to be a fairly textbook situation - which is why I hope there's open source code out there (or perhaps a very detailed step-by-step explanation).</p>
<p>Ideally, I'd like to use code to modify the error rates of seam operations to understand how that affects (for example) logical qubit teleportation using lattice surgery.</p>
<p>Thank you.</p>
",Open-source code for Lattice Surgery in STIM,<stim><lattice-surgery>,1,0,,,"Open-source code for Lattice Surgery in STIM <p>I'm looking for open-source code that implements lattice surgery merging and splitting between two rotated surface code logical qubits in STIM (for d=3 or above).</p>
<p>Whilst there are some excellent explanations on this site (thank you users Craig Gidney and &quot;control freak&quot;), I'm struggling to correctly implement lattice surgery in STIM. Mostly, this is because of the complexity and finickiness of implementing the merge and split operations and ensuring I introduce/remove detectors appropriately. It does not help that I am new to QEC either. What I'm looking for seems to be a fairly textbook situation - which is why I hope there's open source code out there (or perhaps a very detailed step-by-step explanation).</p>
<p>Ideally, I'd like to use code to modify the error rates of seam operations to understand how that affects (for example) logical qubit teleportation using lattice surgery.</p>
<p>Thank you.</p>
",qc,code lattice surgery stim p looking code implements lattice surgery merging splitting two rotated surface code logical qubits stim p whilst excellent explanations site thank users craig gidney quot control freak quot struggling correctly implement lattice surgery stim mostly complexity finickiness implementing merge split operations ensuring detectors appropriately help new qec either looking seems fairly textbook situation hope open source code perhaps detailed explanation p ideally like use code modify error rates seam operations understand affects example logical qubit teleportation using lattice p thank,"[(5, 0.26782596), (7, 0.06149608), (8, 0.110103555), (9, 0.104875885), (13, 0.11324062), (14, 0.082948856), (16, 0.10773451), (17, 0.027872857), (18, 0.09240048), (19, 0.03026848)]"
39308,,2024-07-26 00:55:09,4,326,"<p>I understand that any single qubit unitary operation can be expressed as a rotation around a three dimensional unit vector. Is it possible to do the same for multi-qubit unitaries? Can I express an <span class=""math-container"">$n$</span>-qubit unitary operation as a rotation about some <span class=""math-container"">$m$</span>-dimensional vector, where (I assume) <span class=""math-container"">$m$</span> would depend on <span class=""math-container"">$n$</span>?</p>
",Is any multi-qubit unitary operation a rotation about a specific unit vector?,<quantum-gate><linear-algebra><state-space-geometry><unitary>,2,0,,,"Is any multi-qubit unitary operation a rotation about a specific unit vector? <p>I understand that any single qubit unitary operation can be expressed as a rotation around a three dimensional unit vector. Is it possible to do the same for multi-qubit unitaries? Can I express an <span class=""math-container"">$n$</span>-qubit unitary operation as a rotation about some <span class=""math-container"">$m$</span>-dimensional vector, where (I assume) <span class=""math-container"">$m$</span> would depend on <span class=""math-container"">$n$</span>?</p>
",qc,unitary operation rotation specific unit vector p understand single qubit unitary operation expressed rotation around three dimensional unit vector possible unitaries express span n unitary operation rotation span vector assume span would depend span n,"[(3, 0.6390692), (9, 0.24019434), (16, 0.11590625)]"
39337,39339.0,2024-07-27 15:30:50,0,68,"<p>I have some old version <code>qiskit==0.46</code> code which uses an API as below:</p>
<pre><code>from qiskit.opflow import MatrixOp
H_op = MatrixOp(Hamiltonian).to_pauli_op() 
</code></pre>
<p>After much study, I tried to replace it latest <code>qiskit==1.0</code> API, which has the below syntax:</p>
<pre><code>from qiskit.quantum_info import SparsePauliOp
 H_op = SparsePauliOp(Hamiltonian).to_operator()
</code></pre>
<p>But this is not correct. It gives me some error : <code>qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.'</code>
It would be great if I can be helped on this.</p>
<p><strong>Edit1</strong>
Question updated with the Hamiltonian.</p>
<pre><code>(Pdb) Hamiltonian
array([[ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
       [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
       [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
       [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
</code></pre>
",qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.',<qiskit><programming>,2,3,,,"qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.' <p>I have some old version <code>qiskit==0.46</code> code which uses an API as below:</p>
<pre><code>from qiskit.opflow import MatrixOp
H_op = MatrixOp(Hamiltonian).to_pauli_op() 
</code></pre>
<p>After much study, I tried to replace it latest <code>qiskit==1.0</code> API, which has the below syntax:</p>
<pre><code>from qiskit.quantum_info import SparsePauliOp
 H_op = SparsePauliOp(Hamiltonian).to_operator()
</code></pre>
<p>But this is not correct. It gives me some error : <code>qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.'</code>
It would be great if I can be helped on this.</p>
<p><strong>Edit1</strong>
Question updated with the Hamiltonian.</p>
<pre><code>(Pdb) Hamiltonian
array([[ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
       [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
       [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
       [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
</code></pre>
",qc,input data pauli p old version code code uses api pre code import matrixop matrixop hamiltonian p much study tried replace latest code api syntax pre code import sparsepauliop sparsepauliop hamiltonian p correct gives error code input data pauli would great helped p strong edit1 question updated pre code pdb hamiltonian array,"[(0, 0.49805862), (1, 0.10923549), (2, 0.018287396), (5, 0.2534775), (12, 0.058251847), (16, 0.059999246)]"
39344,39345.0,2024-07-27 21:41:32,2,460,"<p>I have a old version of <code>qiskit==0.46</code> code which uses the below syntax:</p>
<pre><code>quantum_instance = QuantumInstance(backend= backend,
                                                shots= self.shots_done,   
                                                seed_simulator= 28,   
                                                seed_transpiler= 28,
                                                basis_gates= None,
                                                optimization_level=self.optimization_level_used)
</code></pre>
<p>This API no longer works in the latest version of <code>qiskit==1.0</code>.
Please suggest me a API which exactly do this function in the latest <code>qiskit==1.0</code>?</p>
<p><strong>Edit1</strong>
Explaining the problem more clearly. Below is the complete code:</p>
<pre><code>from qiskit_aer import AerSimulator
import numpy as np
from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2
# from qiskit.utils import QuantumInstance # Need to replace it with something else
from qiskit_algorithms import VQE



 Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = SparsePauliOp.from_operator(Hamiltonian)
ansatz = EfficientSU2(num_qubits=num_qubits,
                                entanglement= 'linear',
                                reps= depth,
                                skip_final_rotation_layer= True)
    
backend = AerSimulator()

ansatz_opt = transpile(circuits=ansatz,
                         backend = backend,
                          optimization_level =self.optimization_level_used)
            
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                    shots= 1000,                                                   
                                   seed_simulator= 28,  
                                   seed_transpiler= 28,
                                   basis_gates= None,
                                   optimization_level=1)
    
           
           
initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
          optimizer= optimizer,
          quantum_instance=quantum_instance,
           initial_point=initial_point_values
          )
</code></pre>
<p>This code fails at <code>QuantumInstance</code> when I use the <code>qiskit==1.0</code>? Need some substitute for <code>QuantumInstance</code>?</p>
<p><strong>Edit2</strong>
This code works on <code>qiskit==0.46</code>. Just to be sure I am not missing anything,the other qiskit related packages in my conda env are :<br />
<code>qiskit-aer==0.13.3</code> , <code>qiskit-ibmq-provider==0.20.2</code>, <code>qiskit-terra==0.46.0</code></p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA

from qiskit.utils import QuantumInstance
from qiskit.algorithms import VQE
backend = Aer.get_backend('qasm_simulator')
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)

(VQE_backup) m2c693@alveo:~/RESEARCH_WORK$ python TESTING_VQE_CODE.py 
: DeprecationWarning: The ``qiskit.opflow`` module is deprecated as of qiskit-terra 0.24.0. It will be removed in Qiskit 1.0. For code migration guidelines, visit https://qisk.it/opflow_migration.
  from qiskit.opflow import MatrixOp
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:10: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed in Qiskit 1.0. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.
  from qiskit.algorithms.optimizers import COBYLA
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:14: DeprecationWarning: The 'qiskit.Aer' entry point is deprecated and will be removed in Qiskit 1.0. You should use 'qiskit_aer.Aer' directly instead.
  backend = Aer.get_backend('qasm_simulator')
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:21: DeprecationWarning: The class ``qiskit.opflow.primitive_ops.matrix_op.MatrixOp`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow_migration.
  H_op = MatrixOp(Hamiltonian).to_pauli_op()
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:30: DeprecationWarning: The class ``qiskit.utils.quantum_instance.QuantumInstance`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/qi_migration.
  quantum_instance = QuantumInstance(backend= backend,
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:39: DeprecationWarning: The class ``qiskit.algorithms.minimum_eigen_solvers.vqe.VQE`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class ``qiskit.algorithms.minimum_eigensolvers.VQE``. See https://qisk.it/algo_migration for a migration guide.
  vqe = VQE(ansatz=ansatz_opt,
{   'aux_operator_eigenvalues': None,
    'cost_function_evals': 204,
    'eigenstate': {   '00': 0.44743190822738604,
                      '01': 0.46351240544347894,
                      '10': 0.5321683239352001,
                      '11': 0.5493248697264671},
    'eigenvalue': (0.4073778676855462+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): 3.413149701335303,
                              ParameterVectorElement(θ[1]): 6.122673310049739,
                              ParameterVectorElement(θ[2]): 5.007510090575305,
                              ParameterVectorElement(θ[3]): 6.471417603085951,
                              ParameterVectorElement(θ[4]): 5.5825713635512635,
                              ParameterVectorElement(θ[5]): 3.612049649783617,
                              ParameterVectorElement(θ[6]): 1.1964266917131818,
                              ParameterVectorElement(θ[7]): 1.2636714562893496,
                              ParameterVectorElement(θ[8]): 2.7107242130163205,
                              ParameterVectorElement(θ[9]): 1.4162337151620497,
                              ParameterVectorElement(θ[10]): 3.4685412184905724,
                              ParameterVectorElement(θ[11]): 7.0531779235955145,
                              ParameterVectorElement(θ[12]): 4.759785290450675,
                              ParameterVectorElement(θ[13]): 7.005034463907616,
                              ParameterVectorElement(θ[14]): 3.0544374104242245,
                              ParameterVectorElement(θ[15]): 3.6712390616198993,
                              ParameterVectorElement(θ[16]): 0.8180247608411803,
                              ParameterVectorElement(θ[17]): 2.890632566254878,
                              ParameterVectorElement(θ[18]): 3.2114389132830734,
                              ParameterVectorElement(θ[19]): 1.1110070869050546},
    'optimal_point': array([3.4131497 , 6.12267331, 5.00751009, 6.4714176 , 5.58257136,
       3.61204965, 1.19642669, 1.26367146, 2.71072421, 1.41623372,
       3.46854122, 7.05317792, 4.75978529, 7.00503446, 3.05443741,
       3.67123906, 0.81802476, 2.89063257, 3.21143891, 1.11100709]),
    'optimal_value': 0.4073778676855462,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 4.511643648147583}
</code></pre>
",Substitute for QuantumInstance in latest qiskit==1.0,<qiskit><programming>,1,0,,,"Substitute for QuantumInstance in latest qiskit==1.0 <p>I have a old version of <code>qiskit==0.46</code> code which uses the below syntax:</p>
<pre><code>quantum_instance = QuantumInstance(backend= backend,
                                                shots= self.shots_done,   
                                                seed_simulator= 28,   
                                                seed_transpiler= 28,
                                                basis_gates= None,
                                                optimization_level=self.optimization_level_used)
</code></pre>
<p>This API no longer works in the latest version of <code>qiskit==1.0</code>.
Please suggest me a API which exactly do this function in the latest <code>qiskit==1.0</code>?</p>
<p><strong>Edit1</strong>
Explaining the problem more clearly. Below is the complete code:</p>
<pre><code>from qiskit_aer import AerSimulator
import numpy as np
from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2
# from qiskit.utils import QuantumInstance # Need to replace it with something else
from qiskit_algorithms import VQE



 Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = SparsePauliOp.from_operator(Hamiltonian)
ansatz = EfficientSU2(num_qubits=num_qubits,
                                entanglement= 'linear',
                                reps= depth,
                                skip_final_rotation_layer= True)
    
backend = AerSimulator()

ansatz_opt = transpile(circuits=ansatz,
                         backend = backend,
                          optimization_level =self.optimization_level_used)
            
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                    shots= 1000,                                                   
                                   seed_simulator= 28,  
                                   seed_transpiler= 28,
                                   basis_gates= None,
                                   optimization_level=1)
    
           
           
initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
          optimizer= optimizer,
          quantum_instance=quantum_instance,
           initial_point=initial_point_values
          )
</code></pre>
<p>This code fails at <code>QuantumInstance</code> when I use the <code>qiskit==1.0</code>? Need some substitute for <code>QuantumInstance</code>?</p>
<p><strong>Edit2</strong>
This code works on <code>qiskit==0.46</code>. Just to be sure I am not missing anything,the other qiskit related packages in my conda env are :<br />
<code>qiskit-aer==0.13.3</code> , <code>qiskit-ibmq-provider==0.20.2</code>, <code>qiskit-terra==0.46.0</code></p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA

from qiskit.utils import QuantumInstance
from qiskit.algorithms import VQE
backend = Aer.get_backend('qasm_simulator')
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)

(VQE_backup) m2c693@alveo:~/RESEARCH_WORK$ python TESTING_VQE_CODE.py 
: DeprecationWarning: The ``qiskit.opflow`` module is deprecated as of qiskit-terra 0.24.0. It will be removed in Qiskit 1.0. For code migration guidelines, visit https://qisk.it/opflow_migration.
  from qiskit.opflow import MatrixOp
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:10: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed in Qiskit 1.0. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.
  from qiskit.algorithms.optimizers import COBYLA
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:14: DeprecationWarning: The 'qiskit.Aer' entry point is deprecated and will be removed in Qiskit 1.0. You should use 'qiskit_aer.Aer' directly instead.
  backend = Aer.get_backend('qasm_simulator')
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:21: DeprecationWarning: The class ``qiskit.opflow.primitive_ops.matrix_op.MatrixOp`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow_migration.
  H_op = MatrixOp(Hamiltonian).to_pauli_op()
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:30: DeprecationWarning: The class ``qiskit.utils.quantum_instance.QuantumInstance`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/qi_migration.
  quantum_instance = QuantumInstance(backend= backend,
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:39: DeprecationWarning: The class ``qiskit.algorithms.minimum_eigen_solvers.vqe.VQE`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class ``qiskit.algorithms.minimum_eigensolvers.VQE``. See https://qisk.it/algo_migration for a migration guide.
  vqe = VQE(ansatz=ansatz_opt,
{   'aux_operator_eigenvalues': None,
    'cost_function_evals': 204,
    'eigenstate': {   '00': 0.44743190822738604,
                      '01': 0.46351240544347894,
                      '10': 0.5321683239352001,
                      '11': 0.5493248697264671},
    'eigenvalue': (0.4073778676855462+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): 3.413149701335303,
                              ParameterVectorElement(θ[1]): 6.122673310049739,
                              ParameterVectorElement(θ[2]): 5.007510090575305,
                              ParameterVectorElement(θ[3]): 6.471417603085951,
                              ParameterVectorElement(θ[4]): 5.5825713635512635,
                              ParameterVectorElement(θ[5]): 3.612049649783617,
                              ParameterVectorElement(θ[6]): 1.1964266917131818,
                              ParameterVectorElement(θ[7]): 1.2636714562893496,
                              ParameterVectorElement(θ[8]): 2.7107242130163205,
                              ParameterVectorElement(θ[9]): 1.4162337151620497,
                              ParameterVectorElement(θ[10]): 3.4685412184905724,
                              ParameterVectorElement(θ[11]): 7.0531779235955145,
                              ParameterVectorElement(θ[12]): 4.759785290450675,
                              ParameterVectorElement(θ[13]): 7.005034463907616,
                              ParameterVectorElement(θ[14]): 3.0544374104242245,
                              ParameterVectorElement(θ[15]): 3.6712390616198993,
                              ParameterVectorElement(θ[16]): 0.8180247608411803,
                              ParameterVectorElement(θ[17]): 2.890632566254878,
                              ParameterVectorElement(θ[18]): 3.2114389132830734,
                              ParameterVectorElement(θ[19]): 1.1110070869050546},
    'optimal_point': array([3.4131497 , 6.12267331, 5.00751009, 6.4714176 , 5.58257136,
       3.61204965, 1.19642669, 1.26367146, 2.71072421, 1.41623372,
       3.46854122, 7.05317792, 4.75978529, 7.00503446, 3.05443741,
       3.67123906, 0.81802476, 2.89063257, 3.21143891, 1.11100709]),
    'optimal_value': 0.4073778676855462,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 4.511643648147583}
</code></pre>
",qc,substitute quantuminstance latest p old version code code uses syntax pre code quantuminstance backend 28 28 none p api longer works latest version code please suggest api exactly function latest code p strong edit1 explaining problem clearly complete code pre code import aersimulator import numpy np import sparsepauliop import efficientsu2 import quantuminstance need replace something else import vqe hamiltonian hamiltonian ansatz efficientsu2 depth true backend aersimulator transpile backend backend optimizer cobyla 1500 quantuminstance backend 1000 28 28 none 2 vqe vqe optimizer p code fails code quantuminstance use code need substitute code quantuminstance p strong edit2 code works code sure missing anything qiskit related packages conda env br code code code pre code qiskit import transpile qiskit import aer import numpy np import matrixop import efficientsu2 import cobyla import quantuminstance import vqe backend hamiltonian matrixop hamiltonian ansatz efficientsu2 5 true transpile backend backend optimizer cobyla 1500 quantuminstance backend 1024 default 1024 changing number shots 32m 28 28 none 2 vqe vqe optimizer result print result m2c693 alveo python deprecationwarning module deprecated removed qiskit code migration guidelines visit https import matrixop deprecationwarning migrated independent package https import path deprecated removed qiskit please run pip install use import instead import cobyla deprecationwarning entry point deprecated removed qiskit use directly instead backend deprecationwarning class deprecated removed qiskit release code migration guidelines visit https matrixop hamiltonian deprecationwarning class deprecated removed qiskit release code migration guidelines visit https quantuminstance backend deprecationwarning class deprecated removed earlier 3 months release date instead use class see https migration guide vqe vqe none 204 none parametervectorelement θ 0 parametervectorelement θ 1 parametervectorelement θ 2 parametervectorelement θ 3 parametervectorelement θ 4 parametervectorelement θ 5 parametervectorelement θ 6 parametervectorelement θ 7 parametervectorelement θ 8 parametervectorelement θ 9 parametervectorelement θ 10 parametervectorelement θ 11 parametervectorelement θ 12 parametervectorelement θ 13 parametervectorelement θ 14 parametervectorelement θ 15 parametervectorelement θ 16 parametervectorelement θ 17 parametervectorelement θ 18 parametervectorelement θ 19 array none none,"[(0, 0.56065696), (4, 0.015355201), (6, 0.06708356), (8, 0.033823024), (12, 0.05121839), (14, 0.062352546), (16, 0.2020387)]"
39346,39403.0,2024-07-27 23:19:35,1,105,"<p>I am trying to understand the paper: <strong>Quantum circuits for isometries</strong> (<a href=""https://doi.org/10.1103/PhysRevA.93.032318"" rel=""nofollow noreferrer"">PRA 93, 032318</a>, <a href=""https://arxiv.org/abs/1501.06911"" rel=""nofollow noreferrer"">arXiv:1501.06911</a>).</p>
<p>This paper basically proposes an algorithm called as column column decomposition (CCD), which is basically used in qiskit API: <code>qc.unitary</code> (but I am not sure, if someone can confirm this that would be great). <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary</a></p>
<p>It would be great help if someone can explain a little about are Isometries and what exact is the name of the algorithm used in <code>qc.unitary</code>?</p>
<p><strong>Edit1</strong>
Perhaps, this question is too difficult. Just the name of algorithm used in <code>qc.unitary</code> would also be a great help.</p>
",What is the name of the algorithm used in the qc.unitary API?,<qiskit><quantum-algorithms>,2,4,,,"What is the name of the algorithm used in the qc.unitary API? <p>I am trying to understand the paper: <strong>Quantum circuits for isometries</strong> (<a href=""https://doi.org/10.1103/PhysRevA.93.032318"" rel=""nofollow noreferrer"">PRA 93, 032318</a>, <a href=""https://arxiv.org/abs/1501.06911"" rel=""nofollow noreferrer"">arXiv:1501.06911</a>).</p>
<p>This paper basically proposes an algorithm called as column column decomposition (CCD), which is basically used in qiskit API: <code>qc.unitary</code> (but I am not sure, if someone can confirm this that would be great). <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary</a></p>
<p>It would be great help if someone can explain a little about are Isometries and what exact is the name of the algorithm used in <code>qc.unitary</code>?</p>
<p><strong>Edit1</strong>
Perhaps, this question is too difficult. Just the name of algorithm used in <code>qc.unitary</code> would also be a great help.</p>
",qc,name algorithm used api p trying understand paper strong quantum circuits isometries https nofollow noreferrer pra 93 032318 https nofollow noreferrer p paper basically proposes algorithm called column column decomposition ccd basically used qiskit api code sure someone confirm would great https unitary nofollow noreferrer https unitary p would great help someone explain little isometries exact name algorithm used code p strong edit1 perhaps question difficult name algorithm used code would also great,"[(4, 0.24891298), (7, 0.46491235), (12, 0.026990704), (13, 0.11159469), (14, 0.11878355), (16, 0.02688772)]"
39389,39393.0,2024-07-31 02:56:04,2,61,"<p>I am using an API <code>result= vqe.compute_minimum_eigenvalue</code> using different version of qiskit. The <code>qiskit==0.46</code> gives <code>eigenstate</code> but the<code>qiskit==1.0</code> donot give <code>eigenstate</code>.
The complete code with <code>result</code> using <code>qiskit==0.46</code> is given in the <strong>Edit2</strong> of question : <a href=""https://quantumcomputing.stackexchange.com/questions/39344/substitute-for-quantuminstance-in-latest-qiskit-1-0"">Substitute for QuantumInstance in latest qiskit==1.0</a> and the modified code which can work on <code>qiskit==1.0</code> is given in solution of the question as shown below: <a href=""https://quantumcomputing.stackexchange.com/questions/39344/substitute-for-quantuminstance-in-latest-qiskit-1-0"">Substitute for QuantumInstance in latest qiskit==1.0</a></p>
<pre><code>{   'aux_operators_evaluated': None,
    'cost_function_evals': 226,
    'eigenvalue': 0.3137722886474602,
    'optimal_circuit': &lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7f9dbf535f90&gt;,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): 3.726825317040346,
                              ParameterVectorElement(θ[1]): 4.923652575593262,
                              ParameterVectorElement(θ[2]): 2.1799494002461577,
                              ParameterVectorElement(θ[3]): 4.342309624592069,
                              ParameterVectorElement(θ[4]): 3.9943861870781547,
                              ParameterVectorElement(θ[5]): 2.525898173896921,
                              ParameterVectorElement(θ[6]): 6.4689779624478385,
                              ParameterVectorElement(θ[7]): 6.861702135664873,
                              ParameterVectorElement(θ[8]): 3.3363062351723034,
                              ParameterVectorElement(θ[9]): 0.4303643667680397,
                              ParameterVectorElement(θ[10]): 4.26867749230714,
                              ParameterVectorElement(θ[11]): 0.09306511001614937,
                              ParameterVectorElement(θ[12]): 3.638200155835128,
                              ParameterVectorElement(θ[13]): 4.595353264668222,
                              ParameterVectorElement(θ[14]): 1.1300128175140915,
                              ParameterVectorElement(θ[15]): 6.254355360432362,
                              ParameterVectorElement(θ[16]): 5.451784319298557,
                              ParameterVectorElement(θ[17]): 2.5615938491419166,
                              ParameterVectorElement(θ[18]): 3.0653255873701926,
                              ParameterVectorElement(θ[19]): 5.062189928072163},
    'optimal_point': array([3.72682532, 4.92365258, 2.1799494 , 4.34230962, 3.99438619,
       2.52589817, 6.46897796, 6.86170214, 3.33630624, 0.43036437,
       4.26867749, 0.09306511, 3.63820016, 4.59535326, 1.13001282,
       6.25435536, 5.45178432, 2.56159385, 3.06532559, 5.06218993]),
    'optimal_value': 0.3137722886474602,
    'optimizer_evals': None,
    'optimizer_result': &lt;qiskit_algorithms.optimizers.optimizer.OptimizerResult object at 0x7f9dc752ee90&gt;,
    'optimizer_time': 2.2629570960998535}
</code></pre>
<p>I am really not sure how to get the <code>eigenstate</code> now ?</p>
",eigenstate is missing in the solution of vqe.compute_minimum_eigenvalue API in qiskit==1.0,<qiskit><programming>,1,0,,,"eigenstate is missing in the solution of vqe.compute_minimum_eigenvalue API in qiskit==1.0 <p>I am using an API <code>result= vqe.compute_minimum_eigenvalue</code> using different version of qiskit. The <code>qiskit==0.46</code> gives <code>eigenstate</code> but the<code>qiskit==1.0</code> donot give <code>eigenstate</code>.
The complete code with <code>result</code> using <code>qiskit==0.46</code> is given in the <strong>Edit2</strong> of question : <a href=""https://quantumcomputing.stackexchange.com/questions/39344/substitute-for-quantuminstance-in-latest-qiskit-1-0"">Substitute for QuantumInstance in latest qiskit==1.0</a> and the modified code which can work on <code>qiskit==1.0</code> is given in solution of the question as shown below: <a href=""https://quantumcomputing.stackexchange.com/questions/39344/substitute-for-quantuminstance-in-latest-qiskit-1-0"">Substitute for QuantumInstance in latest qiskit==1.0</a></p>
<pre><code>{   'aux_operators_evaluated': None,
    'cost_function_evals': 226,
    'eigenvalue': 0.3137722886474602,
    'optimal_circuit': &lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7f9dbf535f90&gt;,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): 3.726825317040346,
                              ParameterVectorElement(θ[1]): 4.923652575593262,
                              ParameterVectorElement(θ[2]): 2.1799494002461577,
                              ParameterVectorElement(θ[3]): 4.342309624592069,
                              ParameterVectorElement(θ[4]): 3.9943861870781547,
                              ParameterVectorElement(θ[5]): 2.525898173896921,
                              ParameterVectorElement(θ[6]): 6.4689779624478385,
                              ParameterVectorElement(θ[7]): 6.861702135664873,
                              ParameterVectorElement(θ[8]): 3.3363062351723034,
                              ParameterVectorElement(θ[9]): 0.4303643667680397,
                              ParameterVectorElement(θ[10]): 4.26867749230714,
                              ParameterVectorElement(θ[11]): 0.09306511001614937,
                              ParameterVectorElement(θ[12]): 3.638200155835128,
                              ParameterVectorElement(θ[13]): 4.595353264668222,
                              ParameterVectorElement(θ[14]): 1.1300128175140915,
                              ParameterVectorElement(θ[15]): 6.254355360432362,
                              ParameterVectorElement(θ[16]): 5.451784319298557,
                              ParameterVectorElement(θ[17]): 2.5615938491419166,
                              ParameterVectorElement(θ[18]): 3.0653255873701926,
                              ParameterVectorElement(θ[19]): 5.062189928072163},
    'optimal_point': array([3.72682532, 4.92365258, 2.1799494 , 4.34230962, 3.99438619,
       2.52589817, 6.46897796, 6.86170214, 3.33630624, 0.43036437,
       4.26867749, 0.09306511, 3.63820016, 4.59535326, 1.13001282,
       6.25435536, 5.45178432, 2.56159385, 3.06532559, 5.06218993]),
    'optimal_value': 0.3137722886474602,
    'optimizer_evals': None,
    'optimizer_result': &lt;qiskit_algorithms.optimizers.optimizer.OptimizerResult object at 0x7f9dc752ee90&gt;,
    'optimizer_time': 2.2629570960998535}
</code></pre>
<p>I am really not sure how to get the <code>eigenstate</code> now ?</p>
",qc,eigenstate missing solution api p using api code using different version qiskit code gives code eigenstate code donot give code eigenstate complete code code result using code given strong edit2 question https substitute quantuminstance latest modified code work code given solution question shown https substitute quantuminstance latest pre code none 226 lt object 0x7f9dbf535f90 gt parametervectorelement θ 0 parametervectorelement θ 1 parametervectorelement θ 2 parametervectorelement θ 3 parametervectorelement θ 4 parametervectorelement θ 5 parametervectorelement θ 6 parametervectorelement θ 7 parametervectorelement θ 8 parametervectorelement θ 9 parametervectorelement θ 10 parametervectorelement θ 11 parametervectorelement θ 12 parametervectorelement θ 13 parametervectorelement θ 14 parametervectorelement θ 15 parametervectorelement θ 16 parametervectorelement θ 17 parametervectorelement θ 18 parametervectorelement θ 19 array none lt object 0x7f9dc752ee90 gt p really sure get code eigenstate,"[(0, 0.2428088), (4, 0.025853015), (6, 0.15565285), (7, 0.050378222), (16, 0.52412766)]"
39446,39447.0,2024-08-05 05:59:27,3,170,"<p>A Hamiltonian <span class=""math-container"">$H$</span> is stoquastic in the standard basis if all the off-diagonal terms of the Hamiltonian are non-positive. If we choose <span class=""math-container"">$\beta$</span> small enough, all entries of <span class=""math-container"">$I-\beta H$</span> are non-negative. By the Perron-Frobenius Theorem, the eigenvector which corresponds to the largest eigenvalue (which is also the ground state of <span class=""math-container"">$H$</span>) can be chosen to have non-negative entries. Suppose the ground state is unique ,and denote it as <span class=""math-container"">$|\psi\rangle =\sum_x \sqrt{p(x)}|x\rangle$</span>. How to prove that the support of {<span class=""math-container"">$p(x)$</span>} is connected on the boolean hypercube?</p>
<p>Support is the 𝑥 that 𝑝(𝑥)&gt;0, connected means connected component in a graph （i.e there exist a path for every two points, in the boolean hypercube, there exist an edge between two points iff they differ in only one position).</p>
<p>The question is from Definition 28, Fact H.1. of <a href=""https://doi.org/10.48550/arXiv.2404.07281"" rel=""nofollow noreferrer"">this paper</a></p>
",The support of the ground state of stoquastic Hamiltonian is connected,<hamiltonian-simulation><hamiltonian><many-body-systems><stoquatic-matrices>,2,7,,,"The support of the ground state of stoquastic Hamiltonian is connected <p>A Hamiltonian <span class=""math-container"">$H$</span> is stoquastic in the standard basis if all the off-diagonal terms of the Hamiltonian are non-positive. If we choose <span class=""math-container"">$\beta$</span> small enough, all entries of <span class=""math-container"">$I-\beta H$</span> are non-negative. By the Perron-Frobenius Theorem, the eigenvector which corresponds to the largest eigenvalue (which is also the ground state of <span class=""math-container"">$H$</span>) can be chosen to have non-negative entries. Suppose the ground state is unique ,and denote it as <span class=""math-container"">$|\psi\rangle =\sum_x \sqrt{p(x)}|x\rangle$</span>. How to prove that the support of {<span class=""math-container"">$p(x)$</span>} is connected on the boolean hypercube?</p>
<p>Support is the 𝑥 that 𝑝(𝑥)&gt;0, connected means connected component in a graph （i.e there exist a path for every two points, in the boolean hypercube, there exist an edge between two points iff they differ in only one position).</p>
<p>The question is from Definition 28, Fact H.1. of <a href=""https://doi.org/10.48550/arXiv.2404.07281"" rel=""nofollow noreferrer"">this paper</a></p>
",qc,support ground state stoquastic hamiltonian connected p hamiltonian span h stoquastic standard basis terms hamiltonian choose span small enough entries span h theorem eigenvector corresponds largest eigenvalue also ground state span h chosen entries suppose ground state unique denote span p x prove support span p x connected boolean hypercube p support 𝑥 𝑝 𝑥 gt 0 connected means connected component graph exist path every two points boolean hypercube exist edge two points iff differ one position p question definition 28 fact https nofollow noreferrer paper,"[(0, 0.037560042), (1, 0.12755038), (3, 0.58204114), (9, 0.06558104), (10, 0.024348853), (13, 0.09588461), (15, 0.05386482), (16, 0.011772212)]"
39485,,2024-08-08 16:49:58,1,29,"<p>In this <a href=""https://arxiv.org/abs/2308.02913"" rel=""nofollow noreferrer"">review of GKP codes</a>, in Section <strong>IV B</strong>, they discuss GKP codes from a lattice perspective. For a GKP lattice state <span class=""math-container"">$\mathcal{L}$</span>, they say that the Pauli displacement vectors <span class=""math-container"">$\mathbf{p} \in \{\mathbf{x}, \mathbf{y}, \mathbf{z}\}$</span>, i.e., the displacement vectors that implement the logical Pauli operators (e.g., <span class=""math-container"">$X_L = D_{\mathbf{x}}$</span>), are the smallest vectors of the dual lattice <span class=""math-container"">$\mathcal{L}^*$</span>. The norms <span class=""math-container"">$\|\mathbf{x}\|$</span>, <span class=""math-container"">$\|\mathbf{y}\|$</span>, and <span class=""math-container"">$\|\mathbf{z}\|$</span> represent the Pauli distances of the GKP code. The generator of the dual lattice is <span class=""math-container"">$M^* = M A^{-T}$</span>, where <span class=""math-container"">$A$</span> is the Gram matrix <span class=""math-container"">$A = M^T \Omega M$</span>, <span class=""math-container"">$M$</span> is the generator of the GKP lattice state <span class=""math-container"">$\mathcal{L}$</span>, and <span class=""math-container"">$\Omega$</span> is a <span class=""math-container"">$2N \times 2N$</span> matrix representing the <span class=""math-container"">$N$</span>-mode symplectic form:
<span class=""math-container"">$$
\Omega = \bigoplus_{i=1}^N \Omega_1, \quad \Omega_1 = \begin{pmatrix}
0 &amp; 1 \\
-1 &amp; 0
\end{pmatrix}.
$$</span></p>
<p>They state:</p>
<blockquote>
<p>The Pauli displacements can, more or less, be associated with the columns (or rows) of <span class=""math-container"">$M^*$</span>.</p>
</blockquote>
<p>For example, for a two-mode (<span class=""math-container"">$N=2$</span>) Tesseract qubit (Example <strong>IV.7</strong> in the paper), the generator of the dual lattice is:
<span class=""math-container"">$$
M(\square^2)^* = \frac{\Omega \tilde{O}}{ \sqrt[4]{2}},
$$</span>
where <span class=""math-container"">$\tilde{O}$</span> is a <span class=""math-container"">$4\times4$</span> non-symplectic orthogonal transformation (see Eq. 75 in the paper). For which they say:</p>
<blockquote>
<p><span class=""math-container"">$M(\square^2)^*$</span> is enough to show that <span class=""math-container"">$\|\mathbf{x}_{\square^2}\| = \|\mathbf{z}_{\square^2}\| = \frac{1}{ \sqrt[4]{2}}$</span> and <span class=""math-container"">$\|\mathbf{y}_{\square^2}\| =  \sqrt[4]{2}$</span>.</p>
</blockquote>
<p>From this, it's unclear to me how the which columns of the <span class=""math-container"">$4\times4$</span> matrix <span class=""math-container"">$M(\square^2)^*$</span> correspond to which Pauli displacements.</p>
<p><strong>Question: How are the Pauli displacements determined from the dual lattice generator matrix
<span class=""math-container"">$M^*$</span>, for the Tesseract qubit example, and in general?</strong></p>
",Pauli displacements of a GKP lattice state,<error-correction>,0,0,,,"Pauli displacements of a GKP lattice state <p>In this <a href=""https://arxiv.org/abs/2308.02913"" rel=""nofollow noreferrer"">review of GKP codes</a>, in Section <strong>IV B</strong>, they discuss GKP codes from a lattice perspective. For a GKP lattice state <span class=""math-container"">$\mathcal{L}$</span>, they say that the Pauli displacement vectors <span class=""math-container"">$\mathbf{p} \in \{\mathbf{x}, \mathbf{y}, \mathbf{z}\}$</span>, i.e., the displacement vectors that implement the logical Pauli operators (e.g., <span class=""math-container"">$X_L = D_{\mathbf{x}}$</span>), are the smallest vectors of the dual lattice <span class=""math-container"">$\mathcal{L}^*$</span>. The norms <span class=""math-container"">$\|\mathbf{x}\|$</span>, <span class=""math-container"">$\|\mathbf{y}\|$</span>, and <span class=""math-container"">$\|\mathbf{z}\|$</span> represent the Pauli distances of the GKP code. The generator of the dual lattice is <span class=""math-container"">$M^* = M A^{-T}$</span>, where <span class=""math-container"">$A$</span> is the Gram matrix <span class=""math-container"">$A = M^T \Omega M$</span>, <span class=""math-container"">$M$</span> is the generator of the GKP lattice state <span class=""math-container"">$\mathcal{L}$</span>, and <span class=""math-container"">$\Omega$</span> is a <span class=""math-container"">$2N \times 2N$</span> matrix representing the <span class=""math-container"">$N$</span>-mode symplectic form:
<span class=""math-container"">$$
\Omega = \bigoplus_{i=1}^N \Omega_1, \quad \Omega_1 = \begin{pmatrix}
0 &amp; 1 \\
-1 &amp; 0
\end{pmatrix}.
$$</span></p>
<p>They state:</p>
<blockquote>
<p>The Pauli displacements can, more or less, be associated with the columns (or rows) of <span class=""math-container"">$M^*$</span>.</p>
</blockquote>
<p>For example, for a two-mode (<span class=""math-container"">$N=2$</span>) Tesseract qubit (Example <strong>IV.7</strong> in the paper), the generator of the dual lattice is:
<span class=""math-container"">$$
M(\square^2)^* = \frac{\Omega \tilde{O}}{ \sqrt[4]{2}},
$$</span>
where <span class=""math-container"">$\tilde{O}$</span> is a <span class=""math-container"">$4\times4$</span> non-symplectic orthogonal transformation (see Eq. 75 in the paper). For which they say:</p>
<blockquote>
<p><span class=""math-container"">$M(\square^2)^*$</span> is enough to show that <span class=""math-container"">$\|\mathbf{x}_{\square^2}\| = \|\mathbf{z}_{\square^2}\| = \frac{1}{ \sqrt[4]{2}}$</span> and <span class=""math-container"">$\|\mathbf{y}_{\square^2}\| =  \sqrt[4]{2}$</span>.</p>
</blockquote>
<p>From this, it's unclear to me how the which columns of the <span class=""math-container"">$4\times4$</span> matrix <span class=""math-container"">$M(\square^2)^*$</span> correspond to which Pauli displacements.</p>
<p><strong>Question: How are the Pauli displacements determined from the dual lattice generator matrix
<span class=""math-container"">$M^*$</span>, for the Tesseract qubit example, and in general?</strong></p>
",qc,pauli displacements gkp lattice state p https nofollow noreferrer review gkp codes section strong iv b discuss gkp codes lattice perspective gkp lattice state span l say pauli displacement vectors span p x z displacement vectors implement logical pauli operators span x smallest vectors dual lattice span l norms span x span span z represent pauli distances gkp code generator dual lattice span span gram matrix span span generator gkp lattice state span l span span 2n 2n matrix representing span n symplectic form span pmatrix 0 amp 1 amp 0 pmatrix p state blockquote p pauli displacements less associated columns rows span p example span tesseract qubit example strong paper generator dual lattice span 4 2 span span orthogonal transformation see eq 75 paper say blockquote p span enough show span x z 1 4 2 span 4 2 p unclear columns span matrix span correspond pauli p strong question pauli displacements determined dual lattice generator matrix span tesseract qubit example general,"[(2, 0.042659007), (3, 0.6934552), (5, 0.059795417), (7, 0.04180279), (10, 0.02800598), (11, 0.036963508), (15, 0.040698934), (16, 0.04958569)]"
39533,39543.0,2024-08-13 13:23:11,0,42,"<p>I've been going through a lot of literature on surface codes and lattice surgery, and I keep running into the issue of different papers, at least to me, changing their definition of rough and smooth (primal and dual), without explicity stating whether the surface bounday is given by X or Z stabilisers.</p>
<p>For example, in <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Surface code quantum computing by lattice surgery</a> and <a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">Surface codes: Towards practical large-scale quantum computation</a>, they both specify the rough(primal) boundary as <span class=""math-container"">$Z$</span> and the smooth(dual) boundary as <span class=""math-container"">$X$</span>. However, in <a href=""https://arxiv.org/abs/1808.02892"" rel=""nofollow noreferrer"">A Game of Surface Codes: Large-Scale Quantum Computing with Lattice Surgery</a>, in the section A Surface-code qubits and lattice-surgery operations, smooth(dual) boundaries are gives as <span class=""math-container"">$Z$</span> and rough(primal) as <span class=""math-container"">$X$</span>.</p>
<p><a href=""https://i.sstatic.net/JYysuv2C.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JYysuv2C.png"" alt=""diagram showing surface codes and the boundaries for them"" /></a></p>
<p>But then later on in this same section, they are swapped again, with the rough now being given as <span class=""math-container"">$Z$</span> and smooth as <span class=""math-container"">$X$</span>.</p>
<p>So which is it? It seems to me like this shouldn't be interchangeable, but maybe I am getting confused as the concepts of dual and primal also come up in syndrome graphs as well, along with correlation surfaces, and my definitions are getting mixed up.</p>
",Are rough and smooth boundaries (or primal and dual) always Z stabilisers and X stabilisers?,<error-correction><stabilizer-code><surface-code><lattice-surgery>,1,0,,,"Are rough and smooth boundaries (or primal and dual) always Z stabilisers and X stabilisers? <p>I've been going through a lot of literature on surface codes and lattice surgery, and I keep running into the issue of different papers, at least to me, changing their definition of rough and smooth (primal and dual), without explicity stating whether the surface bounday is given by X or Z stabilisers.</p>
<p>For example, in <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Surface code quantum computing by lattice surgery</a> and <a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">Surface codes: Towards practical large-scale quantum computation</a>, they both specify the rough(primal) boundary as <span class=""math-container"">$Z$</span> and the smooth(dual) boundary as <span class=""math-container"">$X$</span>. However, in <a href=""https://arxiv.org/abs/1808.02892"" rel=""nofollow noreferrer"">A Game of Surface Codes: Large-Scale Quantum Computing with Lattice Surgery</a>, in the section A Surface-code qubits and lattice-surgery operations, smooth(dual) boundaries are gives as <span class=""math-container"">$Z$</span> and rough(primal) as <span class=""math-container"">$X$</span>.</p>
<p><a href=""https://i.sstatic.net/JYysuv2C.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JYysuv2C.png"" alt=""diagram showing surface codes and the boundaries for them"" /></a></p>
<p>But then later on in this same section, they are swapped again, with the rough now being given as <span class=""math-container"">$Z$</span> and smooth as <span class=""math-container"">$X$</span>.</p>
<p>So which is it? It seems to me like this shouldn't be interchangeable, but maybe I am getting confused as the concepts of dual and primal also come up in syndrome graphs as well, along with correlation surfaces, and my definitions are getting mixed up.</p>
",qc,rough smooth boundaries primal dual always z stabilisers x stabilisers p going lot literature surface codes lattice surgery keep running issue different papers least changing definition rough smooth primal dual without explicity stating whether surface bounday given x z p example https nofollow noreferrer surface code quantum computing lattice surgery https nofollow noreferrer surface codes towards practical quantum computation specify rough primal boundary span z smooth dual boundary span x however https nofollow noreferrer game surface codes quantum computing lattice surgery section qubits operations smooth dual boundaries gives span z rough primal span x p https nofollow noreferrer img https diagram showing surface codes boundaries p later section swapped rough given span z smooth span x p seems like interchangeable maybe getting confused concepts dual primal also come syndrome graphs well along correlation surfaces definitions getting mixed,"[(3, 0.07160507), (4, 0.13147776), (5, 0.20086923), (7, 0.21520391), (10, 0.050299283), (13, 0.28480646), (16, 0.044776242)]"
39535,,2024-08-13 14:21:20,0,42,"<p>I have a quantity that I want to calculate by maximising over LOCC measurement protocols. How does one even approach this problem, both analytically or numerically? Has any work been done on the same? What are the kinds of approaches one needs to use when we encounter such problems? I could find papers finding upper bounds on mutual information when we only consider LOCC strategies, but none talk about how to approach them numerically if we wish to calculate them (here, mutual information) exactly.</p>
<p>Any ideas or references to papers would be very helpful.</p>
",Maximisations over LOCC measurement protocols,<measurement><optimization><locc-operation>,0,2,,,"Maximisations over LOCC measurement protocols <p>I have a quantity that I want to calculate by maximising over LOCC measurement protocols. How does one even approach this problem, both analytically or numerically? Has any work been done on the same? What are the kinds of approaches one needs to use when we encounter such problems? I could find papers finding upper bounds on mutual information when we only consider LOCC strategies, but none talk about how to approach them numerically if we wish to calculate them (here, mutual information) exactly.</p>
<p>Any ideas or references to papers would be very helpful.</p>
",qc,maximisations locc measurement protocols p quantity want calculate maximising locc measurement protocols one even approach problem analytically numerically work done kinds approaches one needs use encounter problems could find papers finding upper bounds mutual information consider locc strategies none talk approach numerically wish calculate mutual information p ideas references papers would,"[(3, 0.31127664), (7, 0.11635706), (8, 0.34234154), (13, 0.040140282), (16, 0.020132177), (18, 0.16696069)]"
39539,39548.0,2024-08-13 15:28:57,1,66,"<p>In the paper <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Surface code quantum computing by lattice surgery</a>, for rough merging, they state that measuring the <span class=""math-container"">$X$</span> stabilisers at the boundary is equivalent to <span class=""math-container"">$X_{L}X_{L}$</span>.</p>
<p>What I don't understand is what the new <span class=""math-container"">$X$</span> stabiliser measurements spanning the old boundary are meant to be. and how they're product gives these logical operators.</p>
<p>Do they mean that, using the 3 pink data qubits, they construct 3 new <span class=""math-container"">$X$</span> stabilizer measurements, and then the product of those 3 stabilizers would be equivalent to 2 logical <span class=""math-container"">$X$</span> operators running parallel to the old boundary? If this is the case, then why would the rounds of error correction we do on both the 3 qubits and 2 surfaces allow us to somehow arrive at this</p>
<p>If they are taking the existing <span class=""math-container"">$X$</span> stabilisers, then I don't see how the product of them even givens you the product of the 2 logical <span class=""math-container"">$X$</span> operators of each surface, given they act on different qubits, unless the idea is that the data qubits in the boundaries of the lattice disappear.</p>
<p><a href=""https://i.sstatic.net/AJ64CBz8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AJ64CBz8.png"" alt=""image showing lattice merging from paper"" /></a></p>
",Why does measuring the $X$ stabilisers at the boundary for rough merging give $X_{L}X_{L}$,<stabilizer-code><surface-code><lattice-surgery>,1,0,,,"Why does measuring the $X$ stabilisers at the boundary for rough merging give $X_{L}X_{L}$ <p>In the paper <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">Surface code quantum computing by lattice surgery</a>, for rough merging, they state that measuring the <span class=""math-container"">$X$</span> stabilisers at the boundary is equivalent to <span class=""math-container"">$X_{L}X_{L}$</span>.</p>
<p>What I don't understand is what the new <span class=""math-container"">$X$</span> stabiliser measurements spanning the old boundary are meant to be. and how they're product gives these logical operators.</p>
<p>Do they mean that, using the 3 pink data qubits, they construct 3 new <span class=""math-container"">$X$</span> stabilizer measurements, and then the product of those 3 stabilizers would be equivalent to 2 logical <span class=""math-container"">$X$</span> operators running parallel to the old boundary? If this is the case, then why would the rounds of error correction we do on both the 3 qubits and 2 surfaces allow us to somehow arrive at this</p>
<p>If they are taking the existing <span class=""math-container"">$X$</span> stabilisers, then I don't see how the product of them even givens you the product of the 2 logical <span class=""math-container"">$X$</span> operators of each surface, given they act on different qubits, unless the idea is that the data qubits in the boundaries of the lattice disappear.</p>
<p><a href=""https://i.sstatic.net/AJ64CBz8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AJ64CBz8.png"" alt=""image showing lattice merging from paper"" /></a></p>
",qc,measuring x stabilisers boundary rough merging give l l p paper https nofollow noreferrer surface code quantum computing lattice surgery rough merging state measuring span x stabilisers boundary equivalent span l l p understand new span x stabiliser measurements spanning old boundary meant product gives logical p mean using 3 pink data qubits construct 3 new span x stabilizer measurements product 3 stabilizers would equivalent 2 logical span x operators running parallel old boundary case would rounds error correction 3 qubits 2 surfaces allow us somehow arrive p taking existing span x stabilisers see product even givens product 2 logical span x operators surface given act different qubits unless idea data qubits boundaries lattice p https nofollow noreferrer img https image showing lattice merging paper,"[(2, 0.03206127), (3, 0.21488795), (4, 0.10991475), (5, 0.24526279), (10, 0.06398602), (13, 0.22386158), (14, 0.04928599), (16, 0.059780728)]"
39577,39578.0,2024-08-16 18:06:04,1,80,"<p>I believe that if using <code>sinter.collect</code> to simulate an error correction circuit in Stim, setting the number of tasks is not sufficient to fully take advantage of a large cluster (since Python's <code>multiprocessing</code> module spawns processes inside of a single node). Usually I would use MPI for this task, but attempting to do that gets me the error</p>
<p><code>RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase.</code></p>
<p>which (from some googling) seems to be because of an incompatability between <code>multiprocessing</code> and MPI.</p>
<p>Does anyone know the correct way to use MPI (or other ways to take advantage of the resources available) with Stim/sinter?</p>
<p>(Alternatively, if one knows how to use a decoder inheriting from <code>sinter.decoder</code> without using <code>sinter.collect</code>, that would be helpful too)</p>
",What is the right way to do Stim/sinter simulations using an HPC cluster?,<error-correction><stim><sinter>,1,0,,,"What is the right way to do Stim/sinter simulations using an HPC cluster? <p>I believe that if using <code>sinter.collect</code> to simulate an error correction circuit in Stim, setting the number of tasks is not sufficient to fully take advantage of a large cluster (since Python's <code>multiprocessing</code> module spawns processes inside of a single node). Usually I would use MPI for this task, but attempting to do that gets me the error</p>
<p><code>RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase.</code></p>
<p>which (from some googling) seems to be because of an incompatability between <code>multiprocessing</code> and MPI.</p>
<p>Does anyone know the correct way to use MPI (or other ways to take advantage of the resources available) with Stim/sinter?</p>
<p>(Alternatively, if one knows how to use a decoder inheriting from <code>sinter.decoder</code> without using <code>sinter.collect</code>, that would be helpful too)</p>
",qc,right way simulations using hpc cluster p believe using code simulate error correction circuit stim setting number tasks sufficient fully take advantage large cluster since python code multiprocessing module spawns processes inside single node usually would use mpi task attempting gets error p code runtimeerror attempt made start new process current process finished bootstrapping p googling seems incompatability code multiprocessing p anyone know correct way use mpi ways take advantage resources available p alternatively one knows use decoder inheriting code without using code would helpful,"[(5, 0.0883062), (8, 0.22547716), (13, 0.07435955), (14, 0.58492815), (16, 0.025080036)]"
39685,,2024-08-27 18:27:14,2,44,"<p><strong>The short story, including the question:</strong></p>
<p>Cluster states are used for measurement-based quantum computation in which a circuit is simulated by way of single-site measurements of the bulk of a quantum state. I have been told repeatedly that 2d cluster states cannot simulate universal fault-tolerant quantum computation (UFTQC). However, Raussendorf's <a href=""https://edoc.ub.uni-muenchen.de/1367/"" rel=""nofollow noreferrer"">thesis</a> explicitly argues that the 2d cluster state can perform UFTQC even in the presence of non-symmetric noise channels before every measurement (he does depolarizing channel specifically). Can <span class=""math-container"">$2$</span>d cluster states perform UFTQC or not?</p>
<hr />
<p><strong>Important clarification:</strong></p>
<p>I believe the paper <a href=""https://arxiv.org/abs/quant-ph/0610082"" rel=""nofollow noreferrer"">Fault-tolerant quantum computation with high threshold in two dimensions</a> does not answer my question. That paper is actually constructing a 3d cluster in time from 2d cluster state fragments.
I quote:</p>
<blockquote>
<p><em>Mapping to the 2D lattice.</em> The dimensionality of the spatial layout can be reduced by one if the cluster is created slice by slice. That
is, we convert the axis of &quot;simulated time&quot;—introduced as a means to
explain the connection with surface codes—into real time.</p>
</blockquote>
<p>Please note that Raussendorf's claim in his <a href=""https://edoc.ub.uni-muenchen.de/1367/"" rel=""nofollow noreferrer"">thesis</a> is different. His claim is for a <em>purely 2d</em> cluster state with depolarizing noise immediately before measurements.</p>
<p>To put this one more way, if I allow building the state in time (say to prevent idling), then I would be building a 2d cluster state from 1d fragments, not a 3d cluster state from 2d fragments.</p>
<hr />
<p><strong>The long story:</strong></p>
<p>Variants of the following claim are often stated:</p>
<blockquote>
<p>While a cluster state with two-dimensional (2D) connectivity is
required for universality, a three-dimensional (3D) cluster state is
necessary for additionally achieving fault tolerance.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>However, to advance toward fault-tolerant quantum computing,
three-dimensional (3D) cluster states are ultimately required [16,
17]. In particular, a 3D cluster state of the
Raussendorf-Harrington-Goyal (RHG) lattice— which is a foliation of
the surface code for topological quantum computing [18–21]—introduces
fault tolerance to the MBQC paradigm [16, 17].</p>
</blockquote>
<p>Both of these claims are stated directly in the paper <a href=""https://arxiv.org/abs/2309.05437"" rel=""nofollow noreferrer"">Generation of three-dimensional cluster entangled state</a>.</p>
<p>These sorts of claims are additionally implied in other parts of the literature.</p>
<p>In particular, in the SPT literature, the 3d RBH state is privileged because it is a so-called <span class=""math-container"">$\mathbb{Z}^{(1)}_2 \times \mathbb{Z}^{(1)}_2$</span>-protected SPT with &quot;one-form&quot; symmetries, and one-form symmetries (unlike zero-form symmetries) are viewed as resilient to weak amounts of explicit symmetry breaking through the formulation of emergent symmetries at low energy scales. As there are no such one-form SPTs in 2d (just <span class=""math-container"">$\mathbb{Z}^{(1)}_2 \times \mathbb{Z}^{(0)}_2$</span> or purely zero-form <span class=""math-container"">$\mathbb{Z}^{(0)}_2$</span>), the 2d SPT phases are expected to be destroyed on adding small amounts of explicit symmetry breaking. It is often viewed that the MBQC and SPT properties are tied together, and so explicit symmetry breaking will destroy computational properties in 2d. This is implied in e.g. <a href=""https://arxiv.org/abs/2311.12619"" rel=""nofollow noreferrer"">Two-dimensional symmetry-protected topological phases and transitions in open quantum systems</a></p>
<blockquote>
<p>Given that the 2D cluster state possesses universal computational
capabilities in the context of measurement-based quantum computation,
the topological phase transition found here can also be interpreted as
a transition in the computational power.</p>
</blockquote>
<p>They find an immediate transition out of the 2d <span class=""math-container"">$\mathbb{Z}^{(1)}_2 \times \mathbb{Z}^{(0)}_2$</span> phase of the cluster state on the Lieb lattice for noise that explicitly breaks the zero-form symmetry that is identified with a loss of computational power.</p>
<p>I have also heard that the 2d cluster state on a Lieb lattice has repetition codes on its boundaries, and so can again only handle appropriately-symmetric noise.</p>
<p>Putting aside the Lieb lattice, I have heard further claims that the cluster state on the square lattice, which is merely a subsystem symmetry SPT, also cannot perform fault tolerant universal computation because generic errors will destroy the subsystem symmetry. In fact, I have heard the square lattice cluster state presented as even less fault-tolerant than the Lieb lattice cluster state (although, given that one can construct the Lieb lattice cluster state from a square lattice cluster state, this does not seem like a reasonable statement).</p>
<p>To reiterate, I have both read and heard from multiple people that 2d cluster states generically cannot perform fault tolerant computation.</p>
<p><strong>However,</strong> Raussendorf's <a href=""https://edoc.ub.uni-muenchen.de/1367/"" rel=""nofollow noreferrer"">thesis</a> argues that the 2d cluster state can indeed perform UFTQC. The main discussion is in chapter 4 including and after page 123. The idea, if I understand it correctly, is that the 2d cluster state can simulate 1d circuits. One might worry that errors on the cluster state might become terrible errors on the simulated circuit, but this isn't the case. Errors like depolarizing noise on the 2d cluster state can be mapped to relatively benign Markovian noise on the simulated 1d circuit. Fault tolerant universal quantum computation can be performed with only local gates in 1d (a result I still find somewhat <a href=""https://quantumcomputing.stackexchange.com/questions/39628/can-fault-tolerant-computation-be-performed-in-1d-with-strictly-local-gates"">surprising</a>) by <a href=""https://arxiv.org/abs/quant-ph/9906129"" rel=""nofollow noreferrer"">Aharonov and Ben-Or</a> as well as <a href=""https://arxiv.org/abs/quant-ph/9903099"" rel=""nofollow noreferrer"">Gottesman</a>. To summarize, we can choose to simulate these 1d fault tolerant circuits with the 2d cluster state, and then errors on the cluster state will map to errors in the simulated circuit, but the fault tolerance and threshold theorem for the simulated circuit takes care of these errors, giving a threshold theorem for the cluster state.</p>
<p>I should emphasize that when I say fault tolerant, I mean definitions like in Nielsen and Chuang page 481 with threshold theorems, where there is a threshold under which the error of the output can be made arbitrarily small with at most polylog multiplicative increase in cost. This is a strong statement.</p>
<hr />
<p>Putting everything together, it naively seems that there is a direct contradiction in the literature about the computational properties of 2d cluster states. What's going on?</p>
","Under not-symmetric noise, can the 2d square lattice cluster state be used for universal fault-tolerant quantum computation?",<measurement><fault-tolerance><measurement-based-qc>,0,1,,,"Under not-symmetric noise, can the 2d square lattice cluster state be used for universal fault-tolerant quantum computation? <p><strong>The short story, including the question:</strong></p>
<p>Cluster states are used for measurement-based quantum computation in which a circuit is simulated by way of single-site measurements of the bulk of a quantum state. I have been told repeatedly that 2d cluster states cannot simulate universal fault-tolerant quantum computation (UFTQC). However, Raussendorf's <a href=""https://edoc.ub.uni-muenchen.de/1367/"" rel=""nofollow noreferrer"">thesis</a> explicitly argues that the 2d cluster state can perform UFTQC even in the presence of non-symmetric noise channels before every measurement (he does depolarizing channel specifically). Can <span class=""math-container"">$2$</span>d cluster states perform UFTQC or not?</p>
<hr />
<p><strong>Important clarification:</strong></p>
<p>I believe the paper <a href=""https://arxiv.org/abs/quant-ph/0610082"" rel=""nofollow noreferrer"">Fault-tolerant quantum computation with high threshold in two dimensions</a> does not answer my question. That paper is actually constructing a 3d cluster in time from 2d cluster state fragments.
I quote:</p>
<blockquote>
<p><em>Mapping to the 2D lattice.</em> The dimensionality of the spatial layout can be reduced by one if the cluster is created slice by slice. That
is, we convert the axis of &quot;simulated time&quot;—introduced as a means to
explain the connection with surface codes—into real time.</p>
</blockquote>
<p>Please note that Raussendorf's claim in his <a href=""https://edoc.ub.uni-muenchen.de/1367/"" rel=""nofollow noreferrer"">thesis</a> is different. His claim is for a <em>purely 2d</em> cluster state with depolarizing noise immediately before measurements.</p>
<p>To put this one more way, if I allow building the state in time (say to prevent idling), then I would be building a 2d cluster state from 1d fragments, not a 3d cluster state from 2d fragments.</p>
<hr />
<p><strong>The long story:</strong></p>
<p>Variants of the following claim are often stated:</p>
<blockquote>
<p>While a cluster state with two-dimensional (2D) connectivity is
required for universality, a three-dimensional (3D) cluster state is
necessary for additionally achieving fault tolerance.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>However, to advance toward fault-tolerant quantum computing,
three-dimensional (3D) cluster states are ultimately required [16,
17]. In particular, a 3D cluster state of the
Raussendorf-Harrington-Goyal (RHG) lattice— which is a foliation of
the surface code for topological quantum computing [18–21]—introduces
fault tolerance to the MBQC paradigm [16, 17].</p>
</blockquote>
<p>Both of these claims are stated directly in the paper <a href=""https://arxiv.org/abs/2309.05437"" rel=""nofollow noreferrer"">Generation of three-dimensional cluster entangled state</a>.</p>
<p>These sorts of claims are additionally implied in other parts of the literature.</p>
<p>In particular, in the SPT literature, the 3d RBH state is privileged because it is a so-called <span class=""math-container"">$\mathbb{Z}^{(1)}_2 \times \mathbb{Z}^{(1)}_2$</span>-protected SPT with &quot;one-form&quot; symmetries, and one-form symmetries (unlike zero-form symmetries) are viewed as resilient to weak amounts of explicit symmetry breaking through the formulation of emergent symmetries at low energy scales. As there are no such one-form SPTs in 2d (just <span class=""math-container"">$\mathbb{Z}^{(1)}_2 \times \mathbb{Z}^{(0)}_2$</span> or purely zero-form <span class=""math-container"">$\mathbb{Z}^{(0)}_2$</span>), the 2d SPT phases are expected to be destroyed on adding small amounts of explicit symmetry breaking. It is often viewed that the MBQC and SPT properties are tied together, and so explicit symmetry breaking will destroy computational properties in 2d. This is implied in e.g. <a href=""https://arxiv.org/abs/2311.12619"" rel=""nofollow noreferrer"">Two-dimensional symmetry-protected topological phases and transitions in open quantum systems</a></p>
<blockquote>
<p>Given that the 2D cluster state possesses universal computational
capabilities in the context of measurement-based quantum computation,
the topological phase transition found here can also be interpreted as
a transition in the computational power.</p>
</blockquote>
<p>They find an immediate transition out of the 2d <span class=""math-container"">$\mathbb{Z}^{(1)}_2 \times \mathbb{Z}^{(0)}_2$</span> phase of the cluster state on the Lieb lattice for noise that explicitly breaks the zero-form symmetry that is identified with a loss of computational power.</p>
<p>I have also heard that the 2d cluster state on a Lieb lattice has repetition codes on its boundaries, and so can again only handle appropriately-symmetric noise.</p>
<p>Putting aside the Lieb lattice, I have heard further claims that the cluster state on the square lattice, which is merely a subsystem symmetry SPT, also cannot perform fault tolerant universal computation because generic errors will destroy the subsystem symmetry. In fact, I have heard the square lattice cluster state presented as even less fault-tolerant than the Lieb lattice cluster state (although, given that one can construct the Lieb lattice cluster state from a square lattice cluster state, this does not seem like a reasonable statement).</p>
<p>To reiterate, I have both read and heard from multiple people that 2d cluster states generically cannot perform fault tolerant computation.</p>
<p><strong>However,</strong> Raussendorf's <a href=""https://edoc.ub.uni-muenchen.de/1367/"" rel=""nofollow noreferrer"">thesis</a> argues that the 2d cluster state can indeed perform UFTQC. The main discussion is in chapter 4 including and after page 123. The idea, if I understand it correctly, is that the 2d cluster state can simulate 1d circuits. One might worry that errors on the cluster state might become terrible errors on the simulated circuit, but this isn't the case. Errors like depolarizing noise on the 2d cluster state can be mapped to relatively benign Markovian noise on the simulated 1d circuit. Fault tolerant universal quantum computation can be performed with only local gates in 1d (a result I still find somewhat <a href=""https://quantumcomputing.stackexchange.com/questions/39628/can-fault-tolerant-computation-be-performed-in-1d-with-strictly-local-gates"">surprising</a>) by <a href=""https://arxiv.org/abs/quant-ph/9906129"" rel=""nofollow noreferrer"">Aharonov and Ben-Or</a> as well as <a href=""https://arxiv.org/abs/quant-ph/9903099"" rel=""nofollow noreferrer"">Gottesman</a>. To summarize, we can choose to simulate these 1d fault tolerant circuits with the 2d cluster state, and then errors on the cluster state will map to errors in the simulated circuit, but the fault tolerance and threshold theorem for the simulated circuit takes care of these errors, giving a threshold theorem for the cluster state.</p>
<p>I should emphasize that when I say fault tolerant, I mean definitions like in Nielsen and Chuang page 481 with threshold theorems, where there is a threshold under which the error of the output can be made arbitrarily small with at most polylog multiplicative increase in cost. This is a strong statement.</p>
<hr />
<p>Putting everything together, it naively seems that there is a direct contradiction in the literature about the computational properties of 2d cluster states. What's going on?</p>
",qc,noise 2d square lattice cluster state used universal quantum computation p strong short story including question p cluster states used quantum computation circuit simulated way measurements bulk quantum state told repeatedly 2d cluster states simulate universal quantum computation uftqc however raussendorf https nofollow noreferrer thesis explicitly argues 2d cluster state perform uftqc even presence noise channels every measurement depolarizing channel specifically span 2 cluster states perform uftqc hr p strong important clarification p believe paper https nofollow noreferrer quantum computation high threshold two dimensions answer question paper actually constructing 3d cluster time 2d cluster state fragments quote blockquote p em mapping 2d dimensionality spatial layout reduced one cluster created slice slice convert axis quot simulated time quot means explain connection surface real p please note raussendorf claim https nofollow noreferrer thesis different claim em purely 2d cluster state depolarizing noise immediately p put one way allow building state time say prevent idling would building 2d cluster state 1d fragments 3d cluster state 2d hr p strong long story p variants following claim often stated blockquote p cluster state 2d connectivity required universality 3d cluster state necessary additionally achieving fault p blockquote p however advance toward quantum computing 3d cluster states ultimately required 16 17 particular 3d cluster state rhg foliation surface code topological quantum computing fault tolerance mbqc paradigm 16 17 p claims stated directly paper https nofollow noreferrer generation cluster entangled state p sorts claims additionally implied parts p particular spt literature 3d rbh state privileged span z 1 z 1 spt quot quot symmetries symmetries unlike symmetries viewed resilient weak amounts explicit symmetry breaking formulation emergent symmetries low energy scales spts 2d span z 1 z 0 purely span z 0 2d spt phases expected destroyed adding small amounts explicit symmetry breaking often viewed mbqc spt properties tied together explicit symmetry breaking destroy computational properties 2d implied https nofollow noreferrer topological phases transitions open quantum systems blockquote p given 2d cluster state possesses universal computational capabilities context quantum computation topological phase transition found also interpreted transition computational p find immediate transition 2d span z 1 z 0 phase cluster state lieb lattice noise explicitly breaks symmetry identified loss computational p also heard 2d cluster state lieb lattice repetition codes boundaries handle p putting aside lieb lattice heard claims cluster state square lattice merely subsystem symmetry spt also perform fault tolerant universal computation generic errors destroy subsystem symmetry fact heard square lattice cluster state presented even less lieb lattice cluster state although given one construct lieb lattice cluster state square lattice cluster state seem like reasonable statement p reiterate read heard multiple people 2d cluster states generically perform fault tolerant p strong however raussendorf https nofollow noreferrer thesis argues 2d cluster state indeed perform uftqc main discussion chapter 4 including page idea understand correctly 2d cluster state simulate 1d circuits one might worry errors cluster state might become terrible errors simulated circuit case errors like depolarizing noise 2d cluster state mapped relatively benign markovian noise simulated 1d circuit fault tolerant universal quantum computation performed local gates 1d result still find somewhat https surprising https nofollow noreferrer aharonov well https nofollow noreferrer gottesman summarize choose simulate 1d fault tolerant circuits 2d cluster state errors cluster state map errors simulated circuit fault tolerance threshold theorem simulated circuit takes care errors giving threshold theorem cluster p emphasize say fault tolerant mean definitions like nielsen chuang page 481 threshold theorems threshold error output made arbitrarily small polylog multiplicative increase cost strong hr p putting everything together naively seems direct contradiction literature computational properties 2d cluster states going,"[(3, 0.17128508), (5, 0.10715195), (7, 0.010099939), (8, 0.16366087), (9, 0.16197649), (13, 0.21422827), (14, 0.117692366), (16, 0.016050078)]"
39733,,2024-09-04 14:44:15,2,32,"<p>My question focuses on bi-partite pure systems, but I am also interested in answers focusing on 2-qubit systems (this is actually the case I'm mostly interested in).</p>
<p>While being written in a different manner, many entangled state are actually equivalent.</p>
<p>For instance, one can show that:</p>
<p><span class=""math-container"">$$|00\rangle+|11\rangle=|++\rangle+|--\rangle$$</span></p>
<p>More generally, calling <span class=""math-container"">$\{|i\rangle\}$</span> an orthonormal basis, for any operator <span class=""math-container"">$M$</span>, we have the property that:
<span class=""math-container"">$$ \sum_{i} (\mathbb{I} \otimes M) |ii\rangle = \sum_i (M^T \otimes \mathbb{I}) |ii\rangle,$$</span></p>
<p>where the transposition of the operator is taken in the basis <span class=""math-container"">$\{|i\rangle\}$</span> (I recall that transposition is a basis-dependent property).</p>
<p><strong>Q1: Do all symmetries about bi-partite pure entangle state consequences of this properties (or there are symmetries that are not a consequence of the property I mention)?</strong></p>
<p><strong>Q2: Are there other interesting/important symetries that exists regarding bi-partite pure entangled states?</strong></p>
<p>(For Q2: if you have examples that are consequences of the symetry I mention but are not directly apparent, I could also be interested. I know that &quot;not directly apparent&quot; might be subjective :) )</p>
",Symmetries of maximally bi-partite pure entangled states,<entanglement><symmetry>,0,2,,,"Symmetries of maximally bi-partite pure entangled states <p>My question focuses on bi-partite pure systems, but I am also interested in answers focusing on 2-qubit systems (this is actually the case I'm mostly interested in).</p>
<p>While being written in a different manner, many entangled state are actually equivalent.</p>
<p>For instance, one can show that:</p>
<p><span class=""math-container"">$$|00\rangle+|11\rangle=|++\rangle+|--\rangle$$</span></p>
<p>More generally, calling <span class=""math-container"">$\{|i\rangle\}$</span> an orthonormal basis, for any operator <span class=""math-container"">$M$</span>, we have the property that:
<span class=""math-container"">$$ \sum_{i} (\mathbb{I} \otimes M) |ii\rangle = \sum_i (M^T \otimes \mathbb{I}) |ii\rangle,$$</span></p>
<p>where the transposition of the operator is taken in the basis <span class=""math-container"">$\{|i\rangle\}$</span> (I recall that transposition is a basis-dependent property).</p>
<p><strong>Q1: Do all symmetries about bi-partite pure entangle state consequences of this properties (or there are symmetries that are not a consequence of the property I mention)?</strong></p>
<p><strong>Q2: Are there other interesting/important symetries that exists regarding bi-partite pure entangled states?</strong></p>
<p>(For Q2: if you have examples that are consequences of the symetry I mention but are not directly apparent, I could also be interested. I know that &quot;not directly apparent&quot; might be subjective :) )</p>
",qc,symmetries maximally pure entangled states p question focuses pure systems also interested answers focusing systems actually case mostly interested p written different manner many entangled state actually p instance one show p span p generally calling span orthonormal basis operator span property span p transposition operator taken basis span recall transposition property p strong q1 symmetries pure entangle state consequences properties symmetries consequence property mention p strong q2 symetries exists regarding pure entangled states p q2 examples consequences symetry mention directly apparent could also interested know quot directly apparent quot might subjective,"[(3, 0.41134578), (8, 0.40118352), (14, 0.036558203), (16, 0.011464287), (18, 0.1124916), (19, 0.025401965)]"
39819,39990.0,2024-09-12 09:21:58,1,60,"<p>In <a href=""https://doi.org/10.22331/q-2019-03-05-128"" rel=""nofollow noreferrer"">A Game of Surface Codes</a> (<a href=""https://doi.org/10.48550/arXiv.1808.02892"" rel=""nofollow noreferrer"">arXiv</a>), I have been trying to understand the process that is described for forward propogating rotated clifford gates through other rotated clifford gates, and either I am making an error in these calculations, or missing something obvious. It's stated that</p>
<p><a href=""https://i.sstatic.net/Qsiajckn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qsiajckn.png"" alt=""commutation relations"" /></a></p>
<p>where <span class=""math-container"">$P_{\theta}=e^{-iP\theta}$</span></p>
<p>In the case of the commutating one, it is obvious. However, using an example, I cannot reproduce the bottom one.</p>
<p>If we take <span class=""math-container"">$$e^{-iZ\frac{\pi}{4}}=\begin{bmatrix}
e^{-i\frac{\pi}{4}} &amp; 0\\
0 &amp; e^{i\frac{\pi}{4}}
\end{bmatrix}, e^{-iX\theta}= \begin{bmatrix}
\cos(\theta) &amp; -i\sin(\theta)\\
-i\sin(\theta) &amp;\cos(\theta)
\end{bmatrix}$$</span>
then <span class=""math-container"">$$e^{-iX\theta}e^{-iZ\frac{\pi}{4}}= \begin{bmatrix}
e^{-i\frac{\pi}{4}}\cos(\theta) &amp; -ie^{i\frac{\pi}{4}}\sin(\theta)\\
-ie^{-i\frac{\pi}{4}}\sin(\theta) &amp;e^{i\frac{\pi}{4}}\cos(\theta)
\end{bmatrix}$$</span></p>
<p>where operation order is reverse of those in the pictures, as the circuit reads left to right, so multiplication order is the reverse</p>
<p>Now taking <span class=""math-container"">$iXZ=Y$</span>, <span class=""math-container"">$$e^{-iY\theta}=\begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta)\\
\sin(\theta) &amp;\cos(\theta)
\end{bmatrix}$$</span></p>
<p>Taking this and right multiplying, as the second line in the image shows, by <span class=""math-container"">$e^{-Zi\frac{\pi}{4}}$</span> gives <span class=""math-container"">$$e^{-iZ\frac{\pi}{4}}e^{iY\theta}=\begin{bmatrix}
e^{-i\frac{\pi}{4}}\cos(\theta) &amp; -e^{-i\frac{\pi}{4}}\sin(\theta)\\
e^{i\frac{\pi}{4}}\sin(\theta) &amp;e^{i\frac{\pi}{4}}\cos(\theta)
\end{bmatrix}$$</span></p>
<p>The off diagonal entries do not match, and I even did it in the revese order, ie not the order that the circuit diagrams would suggest. Am I missing something obvious here? When all is said an done, we need <span class=""math-container"">$i$</span> on the diagonal.</p>
<p>According to the paper, the end result should be</p>
<p><span class=""math-container"">$$e^{-iX\theta}e^{-iZ\frac{\pi}{4}}=e^{-iZ\frac{\pi}{4}}e^{-iXZ\theta}$$</span></p>
<p>It could be that swapping <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> for the product operation isn't correct, but even doing it the other way around doesn't work.</p>
",Forward propogation of rotated clifford gates in lattice surgery,<quantum-gate><quantum-circuit><pauli-gates>,1,0,,,"Forward propogation of rotated clifford gates in lattice surgery <p>In <a href=""https://doi.org/10.22331/q-2019-03-05-128"" rel=""nofollow noreferrer"">A Game of Surface Codes</a> (<a href=""https://doi.org/10.48550/arXiv.1808.02892"" rel=""nofollow noreferrer"">arXiv</a>), I have been trying to understand the process that is described for forward propogating rotated clifford gates through other rotated clifford gates, and either I am making an error in these calculations, or missing something obvious. It's stated that</p>
<p><a href=""https://i.sstatic.net/Qsiajckn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qsiajckn.png"" alt=""commutation relations"" /></a></p>
<p>where <span class=""math-container"">$P_{\theta}=e^{-iP\theta}$</span></p>
<p>In the case of the commutating one, it is obvious. However, using an example, I cannot reproduce the bottom one.</p>
<p>If we take <span class=""math-container"">$$e^{-iZ\frac{\pi}{4}}=\begin{bmatrix}
e^{-i\frac{\pi}{4}} &amp; 0\\
0 &amp; e^{i\frac{\pi}{4}}
\end{bmatrix}, e^{-iX\theta}= \begin{bmatrix}
\cos(\theta) &amp; -i\sin(\theta)\\
-i\sin(\theta) &amp;\cos(\theta)
\end{bmatrix}$$</span>
then <span class=""math-container"">$$e^{-iX\theta}e^{-iZ\frac{\pi}{4}}= \begin{bmatrix}
e^{-i\frac{\pi}{4}}\cos(\theta) &amp; -ie^{i\frac{\pi}{4}}\sin(\theta)\\
-ie^{-i\frac{\pi}{4}}\sin(\theta) &amp;e^{i\frac{\pi}{4}}\cos(\theta)
\end{bmatrix}$$</span></p>
<p>where operation order is reverse of those in the pictures, as the circuit reads left to right, so multiplication order is the reverse</p>
<p>Now taking <span class=""math-container"">$iXZ=Y$</span>, <span class=""math-container"">$$e^{-iY\theta}=\begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta)\\
\sin(\theta) &amp;\cos(\theta)
\end{bmatrix}$$</span></p>
<p>Taking this and right multiplying, as the second line in the image shows, by <span class=""math-container"">$e^{-Zi\frac{\pi}{4}}$</span> gives <span class=""math-container"">$$e^{-iZ\frac{\pi}{4}}e^{iY\theta}=\begin{bmatrix}
e^{-i\frac{\pi}{4}}\cos(\theta) &amp; -e^{-i\frac{\pi}{4}}\sin(\theta)\\
e^{i\frac{\pi}{4}}\sin(\theta) &amp;e^{i\frac{\pi}{4}}\cos(\theta)
\end{bmatrix}$$</span></p>
<p>The off diagonal entries do not match, and I even did it in the revese order, ie not the order that the circuit diagrams would suggest. Am I missing something obvious here? When all is said an done, we need <span class=""math-container"">$i$</span> on the diagonal.</p>
<p>According to the paper, the end result should be</p>
<p><span class=""math-container"">$$e^{-iX\theta}e^{-iZ\frac{\pi}{4}}=e^{-iZ\frac{\pi}{4}}e^{-iXZ\theta}$$</span></p>
<p>It could be that swapping <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> for the product operation isn't correct, but even doing it the other way around doesn't work.</p>
",qc,forward propogation rotated clifford gates lattice surgery p https nofollow noreferrer game surface codes https nofollow noreferrer arxiv trying understand process described forward propogating rotated clifford gates rotated clifford gates either making error calculations missing something obvious stated p https nofollow noreferrer img https commutation relations p span p case commutating one obvious however using example reproduce bottom p take span 4 bmatrix 4 amp 0 amp 4 bmatrix bmatrix amp amp bmatrix span 4 bmatrix 4 amp 4 4 amp 4 bmatrix p operation order reverse pictures circuit reads left right multiplication order reverse p taking span span bmatrix amp amp bmatrix p taking right multiplying second line image shows span 4 gives span 4 bmatrix 4 amp 4 4 amp 4 bmatrix p diagonal entries match even revese order ie order circuit diagrams would suggest missing something obvious said done need span p according paper end result p span 4 4 p could swapping span x span z product operation correct even way around,"[(3, 0.09056697), (4, 0.15834795), (5, 0.06872342), (6, 0.08690781), (9, 0.14309269), (13, 0.2006865), (15, 0.23338223), (16, 0.017556796)]"
39864,,2024-09-16 12:07:07,1,83,"<p>I'm looking at <a href=""https://arxiv.org/abs/1711.04921"" rel=""nofollow noreferrer"">Lattice Surgery on the Raussendorf Lattice</a>, and I am getting confused by one of their teleportation circuits.</p>
<p>In Figure 1, they show the following circuit to achieve MBQC:</p>
<p><a href=""https://i.sstatic.net/QwUlognZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QwUlognZ.png"" alt=""MBQC circuit"" /></a></p>
<p>It differs from ordinary MBQC circuits in that they measure in the <span class=""math-container"">$Z$</span> basis, as opposed to the X. But one can easily see that this is the same as measuring in the <span class=""math-container"">$X$</span> basis due to the <span class=""math-container"">$H$</span> gate they apply just before measurement, which can be commuted to the end of the circuit, and performs a measurement in the <span class=""math-container"">$X$</span> basis instead. If this is done, it is just the ordinary MBQC circuit.</p>
<p>However the operation they perform on the teleported qubit seems to be wrong. A straightforward calculation shows that:</p>
<p><span class=""math-container"">$$HZ_{\theta}C_{Z}|\psi\rangle\otimes|+\rangle=HZ_{\theta}(\alpha|0\rangle\otimes|+\rangle+\beta|1\rangle\otimes|-\rangle)=H(\alpha|0\rangle\otimes|+\rangle+\beta e^{i\theta}|1\rangle\otimes|-\rangle)\\ =\alpha|+\rangle\otimes|+\rangle+\beta e^{i\theta}|-\rangle\otimes|-\rangle$$</span></p>
<p>From here, measuring the first qubit in the <span class=""math-container"">$Z$</span> basis, and ignoring normalisation for the moment, will give
<span class=""math-container"">$$|0\rangle \otimes \alpha|+\rangle+\beta e^{i\theta}|-\rangle$$</span></p>
<p>or</p>
<p><span class=""math-container"">$$|1\rangle \otimes \alpha|+\rangle-\beta e^{i\theta}|-\rangle$$</span></p>
<p>In the first case, when the measurement outcome is +1, you can see this is <span class=""math-container"">$|0\rangle \otimes HZ_{\theta}(\alpha|0\rangle+\beta |1\rangle)$</span>, and the byproduct operator has no effect. However, in the case of -1, you don't get <span class=""math-container"">$ZHZ_{\theta}|\psi\rangle$</span>, as <span class=""math-container"">$$|1\rangle \otimes \alpha|+\rangle-\beta e^{i\theta}|-\rangle=|1\rangle \otimes XHZ_{\theta}(\alpha|0\rangle+\beta |1\rangle)$$</span></p>
<p>All the byproduct operator <span class=""math-container"">$Z^{m}$</span> would do, if included, is flip the bits.</p>
<p>So what am I missing here? Am I wrong or is this a mistake in the paper? I'll also point out that the equivalent action of measuring in the <span class=""math-container"">$X$</span> basis instead, which, up to a certain operation, would give the same, does give a <span class=""math-container"">$Z$</span> byproduct operator, but before the hadamard, which when rearranged achieves the same operation as the one I arrive at.</p>
<p>Shouldn't it be <span class=""math-container"">$$|1\rangle \otimes X^{m}HZ_{\theta}(\alpha|0\rangle+\beta |1\rangle)$$</span> or, in the original MBQC circuit, <span class=""math-container"">$$|1\rangle \otimes HZ^{m}Z_{\theta}(\alpha|0\rangle+\beta |1\rangle)$$</span></p>
",Quantum teleportation circuit with rotated measurement,<quantum-circuit><teleportation><measurement-based-qc>,1,0,,,"Quantum teleportation circuit with rotated measurement <p>I'm looking at <a href=""https://arxiv.org/abs/1711.04921"" rel=""nofollow noreferrer"">Lattice Surgery on the Raussendorf Lattice</a>, and I am getting confused by one of their teleportation circuits.</p>
<p>In Figure 1, they show the following circuit to achieve MBQC:</p>
<p><a href=""https://i.sstatic.net/QwUlognZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QwUlognZ.png"" alt=""MBQC circuit"" /></a></p>
<p>It differs from ordinary MBQC circuits in that they measure in the <span class=""math-container"">$Z$</span> basis, as opposed to the X. But one can easily see that this is the same as measuring in the <span class=""math-container"">$X$</span> basis due to the <span class=""math-container"">$H$</span> gate they apply just before measurement, which can be commuted to the end of the circuit, and performs a measurement in the <span class=""math-container"">$X$</span> basis instead. If this is done, it is just the ordinary MBQC circuit.</p>
<p>However the operation they perform on the teleported qubit seems to be wrong. A straightforward calculation shows that:</p>
<p><span class=""math-container"">$$HZ_{\theta}C_{Z}|\psi\rangle\otimes|+\rangle=HZ_{\theta}(\alpha|0\rangle\otimes|+\rangle+\beta|1\rangle\otimes|-\rangle)=H(\alpha|0\rangle\otimes|+\rangle+\beta e^{i\theta}|1\rangle\otimes|-\rangle)\\ =\alpha|+\rangle\otimes|+\rangle+\beta e^{i\theta}|-\rangle\otimes|-\rangle$$</span></p>
<p>From here, measuring the first qubit in the <span class=""math-container"">$Z$</span> basis, and ignoring normalisation for the moment, will give
<span class=""math-container"">$$|0\rangle \otimes \alpha|+\rangle+\beta e^{i\theta}|-\rangle$$</span></p>
<p>or</p>
<p><span class=""math-container"">$$|1\rangle \otimes \alpha|+\rangle-\beta e^{i\theta}|-\rangle$$</span></p>
<p>In the first case, when the measurement outcome is +1, you can see this is <span class=""math-container"">$|0\rangle \otimes HZ_{\theta}(\alpha|0\rangle+\beta |1\rangle)$</span>, and the byproduct operator has no effect. However, in the case of -1, you don't get <span class=""math-container"">$ZHZ_{\theta}|\psi\rangle$</span>, as <span class=""math-container"">$$|1\rangle \otimes \alpha|+\rangle-\beta e^{i\theta}|-\rangle=|1\rangle \otimes XHZ_{\theta}(\alpha|0\rangle+\beta |1\rangle)$$</span></p>
<p>All the byproduct operator <span class=""math-container"">$Z^{m}$</span> would do, if included, is flip the bits.</p>
<p>So what am I missing here? Am I wrong or is this a mistake in the paper? I'll also point out that the equivalent action of measuring in the <span class=""math-container"">$X$</span> basis instead, which, up to a certain operation, would give the same, does give a <span class=""math-container"">$Z$</span> byproduct operator, but before the hadamard, which when rearranged achieves the same operation as the one I arrive at.</p>
<p>Shouldn't it be <span class=""math-container"">$$|1\rangle \otimes X^{m}HZ_{\theta}(\alpha|0\rangle+\beta |1\rangle)$$</span> or, in the original MBQC circuit, <span class=""math-container"">$$|1\rangle \otimes HZ^{m}Z_{\theta}(\alpha|0\rangle+\beta |1\rangle)$$</span></p>
",qc,quantum teleportation circuit rotated measurement p looking https nofollow noreferrer lattice surgery raussendorf lattice getting confused one teleportation p figure 1 show following circuit achieve mbqc p https nofollow noreferrer img https mbqc circuit p differs ordinary mbqc circuits measure span z basis opposed one easily see measuring span x basis due span h gate apply measurement commuted end circuit performs measurement span x basis instead done ordinary mbqc p however operation perform teleported qubit seems wrong straightforward calculation shows p span z p measuring first qubit span z basis ignoring normalisation moment give span p p span p first case measurement outcome see span byproduct operator effect however case get span span p byproduct operator span would included flip p missing wrong mistake paper also point equivalent action measuring span x basis instead certain operation would give give span z byproduct operator hadamard rearranged achieves operation one arrive p span original mbqc circuit span,"[(3, 0.36572605), (4, 0.1381277), (9, 0.14688064), (10, 0.022693552), (14, 0.061295033), (16, 0.025075883), (18, 0.23935667)]"
39871,,2024-09-17 05:29:52,1,188,"<p>I was studying the VQLS from the tutorial :<a href=""https://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-paper-implementations/vqls.ipynb"" rel=""nofollow noreferrer"">https://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-paper-implementations/vqls.ipynb</a>
I am kind of stuck to understand how to convert a non-unitary matrix into quantum circuit as done in the tutorial because it is practically impossible for anyone to think like that as shown below:
<span class=""math-container"">$$
A=0.45Z_3+0.55{\mathbb I}
$$</span>
Also, how would the circuit look like? It would be really great if someone can help me understand this concept because it practically imposssible to implement this without any API or algorithm? Also, what would be complexity of the algorithm because what I think is that it very easy to solve this on classical computer than on quantum computer?</p>
",converting a non-unitary matrix into quantum circuit,<qiskit>,3,0,,,"converting a non-unitary matrix into quantum circuit <p>I was studying the VQLS from the tutorial :<a href=""https://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-paper-implementations/vqls.ipynb"" rel=""nofollow noreferrer"">https://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-paper-implementations/vqls.ipynb</a>
I am kind of stuck to understand how to convert a non-unitary matrix into quantum circuit as done in the tutorial because it is practically impossible for anyone to think like that as shown below:
<span class=""math-container"">$$
A=0.45Z_3+0.55{\mathbb I}
$$</span>
Also, how would the circuit look like? It would be really great if someone can help me understand this concept because it practically imposssible to implement this without any API or algorithm? Also, what would be complexity of the algorithm because what I think is that it very easy to solve this on classical computer than on quantum computer?</p>
",qc,converting matrix quantum circuit p studying vqls tutorial https nofollow noreferrer https kind stuck understand convert matrix quantum circuit done tutorial practically impossible anyone think like shown span also would circuit look like would really great someone help understand concept practically imposssible implement without api algorithm also would complexity algorithm think easy solve classical computer quantum computer,"[(1, 0.16337971), (3, 0.019755112), (4, 0.28764558), (7, 0.33992535), (11, 0.033086885), (13, 0.13552707), (16, 0.018404266)]"
39912,39914.0,2024-09-19 16:20:45,2,82,"<p>I'm performing some quantum experiments with Qiskit and I want to use a simulator that mimics a real quantum computer with recent calibration results, like so:</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_aer import AerSimulator
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;MY_TOKEN&quot;)
backend = service.backend(&quot;ibm_brisbane&quot;)
simulator = AerSimulator.from_backend(backend)
</code></pre>
<p>My problem is that I want my experiments to be reproducible in the future, and I believe that the above code snippet pulls the latest calibration results that are updated every 24 hours. Therefore, I wanted to somehow save the backend object to disk (which I would include in my publicly available replication package) and have my script load it instead of pulling it from the IBM Quantum service. Initially, I tried using the <code>pickle</code> module, but the backend object contains many attributes that don't seem relevant and some that should not be made publicly available (such as my token).</p>
<p>I am aware of <code>qiskit_ibm_runtime.fake_provider</code>, but the system snapshots here are too old.</p>
<p>To summarize my question: what is the best way to persist and reuse a Qiskit backend object?</p>
",What is the best way to save and load a Qiskit backend?,<qiskit><simulation>,1,0,,,"What is the best way to save and load a Qiskit backend? <p>I'm performing some quantum experiments with Qiskit and I want to use a simulator that mimics a real quantum computer with recent calibration results, like so:</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_aer import AerSimulator
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;MY_TOKEN&quot;)
backend = service.backend(&quot;ibm_brisbane&quot;)
simulator = AerSimulator.from_backend(backend)
</code></pre>
<p>My problem is that I want my experiments to be reproducible in the future, and I believe that the above code snippet pulls the latest calibration results that are updated every 24 hours. Therefore, I wanted to somehow save the backend object to disk (which I would include in my publicly available replication package) and have my script load it instead of pulling it from the IBM Quantum service. Initially, I tried using the <code>pickle</code> module, but the backend object contains many attributes that don't seem relevant and some that should not be made publicly available (such as my token).</p>
<p>I am aware of <code>qiskit_ibm_runtime.fake_provider</code>, but the system snapshots here are too old.</p>
<p>To summarize my question: what is the best way to persist and reuse a Qiskit backend object?</p>
",qc,best way save load qiskit backend p performing quantum experiments qiskit want use simulator mimics real quantum computer recent calibration results like pre code import qiskitruntimeservice import aersimulator service qiskitruntimeservice quot quot quot quot backend quot quot simulator backend p problem want experiments reproducible future believe code snippet pulls latest calibration results updated every 24 hours therefore wanted somehow save backend object disk would include publicly available replication package script load instead pulling ibm quantum service initially tried using code pickle module backend object contains many attributes seem relevant made publicly available token p aware code system snapshots p summarize question best way persist reuse qiskit backend object,"[(0, 0.24567689), (1, 0.038992424), (4, 0.03533215), (12, 0.04584499), (14, 0.54024416), (16, 0.024278607), (19, 0.06838931)]"
39928,39956.0,2024-09-21 14:59:53,1,65,"<p>According to help from Microsoft Learn, the binding of <code>Qubit[]</code> array to its equivalent ket vector representation is such that the qubit with index 0 becomes the rightmost qubit in the ket vector representation. So we expect that the output of the following Q# program be <span class=""math-container"">$|001\rangle$</span>, but this is not the case.</p>
<pre><code>namespace Quantum.Demo {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Measurement;

    @EntryPoint()
    operation CreateStateVector001() : Unit {
        use qba = Qubit[3];

        // initializing qubits
        Reset(qba[2]);
        Reset(qba[1]);
        X(qba[0]);  // The LSB becomes a 1

        // Display the state of the qubits
        DumpMachine();

        // Reset all qubits before releasing them
        ResetAll(qba);
    }
}
</code></pre>
<p>Please help me understand why.</p>
",Probable bug in DumpMachine() Quantum API function of Microsoft Quantum Platform,<programming><q#><state-preparation>,1,0,,,"Probable bug in DumpMachine() Quantum API function of Microsoft Quantum Platform <p>According to help from Microsoft Learn, the binding of <code>Qubit[]</code> array to its equivalent ket vector representation is such that the qubit with index 0 becomes the rightmost qubit in the ket vector representation. So we expect that the output of the following Q# program be <span class=""math-container"">$|001\rangle$</span>, but this is not the case.</p>
<pre><code>namespace Quantum.Demo {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Measurement;

    @EntryPoint()
    operation CreateStateVector001() : Unit {
        use qba = Qubit[3];

        // initializing qubits
        Reset(qba[2]);
        Reset(qba[1]);
        X(qba[0]);  // The LSB becomes a 1

        // Display the state of the qubits
        DumpMachine();

        // Reset all qubits before releasing them
        ResetAll(qba);
    }
}
</code></pre>
<p>Please help me understand why.</p>
",qc,probable bug dumpmachine quantum api function microsoft quantum platform p according help microsoft learn binding code qubit array equivalent ket vector representation qubit index 0 becomes rightmost qubit ket vector representation expect output following q program span pre code namespace open open open entrypoint operation createstatevector001 unit use qba qubit 3 initializing qubits reset qba 2 reset qba 1 x qba 0 lsb becomes 1 display state qubits dumpmachine reset qubits releasing resetall qba p please help understand,"[(2, 0.08792783), (10, 0.03961663), (11, 0.052491836), (13, 0.1645463), (14, 0.29278588), (16, 0.03663302), (17, 0.23655736), (18, 0.087905146)]"
39931,39947.0,2024-09-21 19:40:00,2,59,"<p>On pages 23-24 of YiLei Chen's paper &quot;Quantum Algorithms for Lattice Problems&quot;, he claims the following state's support contains at most <span class=""math-container"">$ 2r\log n $</span> entries:
<span class=""math-container"">$$
\left|\varphi_{1}\right\rangle=\sum_{k \in \mathbb{Z}, k \mathbf{x}-\mathbf{y} \in(r \log n) \mathcal{B}_{\infty}^{n}} \exp \left(-\pi\left(\frac{1}{r^{2}}+\frac{i}{s^{2}}\right)\|k \mathbf{x}-\mathbf{y}\|^{2}\right)|k \mathbf{x}-\mathbf{y}\rangle
$$</span></p>
<p>Wouldn't it actually contain <span class=""math-container"">$ (2r\log n)^{n} $</span> entries? This is quoting the paper:</p>
<p>We have <span class=""math-container"">$ \|\varphi_{1}\|_{2}^{2}\ \leq 2r\log n \in poly(n)$</span> since there are at most <span class=""math-container"">$ 2r\log n $</span> entries in the support.</p>
<p>What am I missing here?</p>
","Max amount of entries in n dimensional unit ball of infinity norm, question on YiLei Chen's eprint555 Lemma 3.10 proof",<quantum-algorithms>,1,0,,,"Max amount of entries in n dimensional unit ball of infinity norm, question on YiLei Chen's eprint555 Lemma 3.10 proof <p>On pages 23-24 of YiLei Chen's paper &quot;Quantum Algorithms for Lattice Problems&quot;, he claims the following state's support contains at most <span class=""math-container"">$ 2r\log n $</span> entries:
<span class=""math-container"">$$
\left|\varphi_{1}\right\rangle=\sum_{k \in \mathbb{Z}, k \mathbf{x}-\mathbf{y} \in(r \log n) \mathcal{B}_{\infty}^{n}} \exp \left(-\pi\left(\frac{1}{r^{2}}+\frac{i}{s^{2}}\right)\|k \mathbf{x}-\mathbf{y}\|^{2}\right)|k \mathbf{x}-\mathbf{y}\rangle
$$</span></p>
<p>Wouldn't it actually contain <span class=""math-container"">$ (2r\log n)^{n} $</span> entries? This is quoting the paper:</p>
<p>We have <span class=""math-container"">$ \|\varphi_{1}\|_{2}^{2}\ \leq 2r\log n \in poly(n)$</span> since there are at most <span class=""math-container"">$ 2r\log n $</span> entries in the support.</p>
<p>What am I missing here?</p>
",qc,max amount entries n dimensional unit ball infinity norm question yilei chen eprint555 lemma proof p pages yilei chen paper quot quantum algorithms lattice problems quot claims following state support contains span n entries span 1 k z k x r n b n 1 2 2 x 2 x p would actually contain span n n entries quoting paper p span 1 2 2 n poly n since span n entries p missing,"[(1, 0.046535477), (2, 0.08496813), (3, 0.6098566), (9, 0.03137812), (10, 0.17114513), (16, 0.026766332), (19, 0.027571924)]"
39969,,2024-09-25 10:54:01,2,69,"<p>Looking at the oringal paper on <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">lattice surgery on the surface code</a>, the expansion step of the state injection process is meant to take <span class=""math-container"">$$\alpha|0\rangle_{L}+\beta|1\rangle_{L}$$</span> to a larger surface code patch. However, both <a href=""https://quantumcomputing.stackexchange.com/questions/32946/surface-code-expansion-in-the-lattice-surgery-context"">this question</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/38234/state-injection-in-a-surface-code"">this one</a> seem to indicate that the expansion process doesn't work, or has issues.</p>
<p><a href=""https://i.sstatic.net/65NZAvUB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/65NZAvUB.png"" alt=""state injection expansion"" /></a></p>
<p>The main issues seem to be with the two bottom figures, and the fact that all the data qubits are initialised in <span class=""math-container"">$|0\rangle$</span>. Looking at figure d, the merge process involves both a smooth and rough merge. This means that on the right hand side, you are rough merging and measuring <span class=""math-container"">$X_{L}X_{L}$</span> on both surfaces, effectively putting them into an + or - eigenstate of <span class=""math-container"">$X_{L}X_{L}$</span>, depending on the outcomes. But for the bottom row, it's a smooth merge, and the qubits are initialised to the wrong states for that to occur. They'd need to be in <span class=""math-container"">$|+\rangle$</span>.</p>
<p>Additionally, as pointed out in <a href=""https://quantumcomputing.stackexchange.com/questions/32946/surface-code-expansion-in-the-lattice-surgery-context"">2</a>, the smooth merge would be measuring <span class=""math-container"">$Z_{L}Z_{L}$</span>, and the parity of the bottom row qubits, one <span class=""math-container"">$Z_{L}$</span>, and the original 3 qubit one plus an additional one from the right hand side of the lattice, giving the <span class=""math-container"">$Z_{L}$</span> for the pink surface, would have to match the parity of the 4 face stabilisers at the bottom. But this would only match for the surface being initialised in either the logical 0 or 1. ie if it was a superposition, wouldn't the expansion destroy the injected state? The green surface is already a +1 eigenstate of <span class=""math-container"">$Z_{L}$</span>, so shouldn't this remain the case after the measurements?</p>
",How does the expansion step for state injection in surface code lattice surgery work?,<surface-code><magic-states><lattice-surgery>,0,0,,,"How does the expansion step for state injection in surface code lattice surgery work? <p>Looking at the oringal paper on <a href=""https://arxiv.org/abs/1111.4022"" rel=""nofollow noreferrer"">lattice surgery on the surface code</a>, the expansion step of the state injection process is meant to take <span class=""math-container"">$$\alpha|0\rangle_{L}+\beta|1\rangle_{L}$$</span> to a larger surface code patch. However, both <a href=""https://quantumcomputing.stackexchange.com/questions/32946/surface-code-expansion-in-the-lattice-surgery-context"">this question</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/38234/state-injection-in-a-surface-code"">this one</a> seem to indicate that the expansion process doesn't work, or has issues.</p>
<p><a href=""https://i.sstatic.net/65NZAvUB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/65NZAvUB.png"" alt=""state injection expansion"" /></a></p>
<p>The main issues seem to be with the two bottom figures, and the fact that all the data qubits are initialised in <span class=""math-container"">$|0\rangle$</span>. Looking at figure d, the merge process involves both a smooth and rough merge. This means that on the right hand side, you are rough merging and measuring <span class=""math-container"">$X_{L}X_{L}$</span> on both surfaces, effectively putting them into an + or - eigenstate of <span class=""math-container"">$X_{L}X_{L}$</span>, depending on the outcomes. But for the bottom row, it's a smooth merge, and the qubits are initialised to the wrong states for that to occur. They'd need to be in <span class=""math-container"">$|+\rangle$</span>.</p>
<p>Additionally, as pointed out in <a href=""https://quantumcomputing.stackexchange.com/questions/32946/surface-code-expansion-in-the-lattice-surgery-context"">2</a>, the smooth merge would be measuring <span class=""math-container"">$Z_{L}Z_{L}$</span>, and the parity of the bottom row qubits, one <span class=""math-container"">$Z_{L}$</span>, and the original 3 qubit one plus an additional one from the right hand side of the lattice, giving the <span class=""math-container"">$Z_{L}$</span> for the pink surface, would have to match the parity of the 4 face stabilisers at the bottom. But this would only match for the surface being initialised in either the logical 0 or 1. ie if it was a superposition, wouldn't the expansion destroy the injected state? The green surface is already a +1 eigenstate of <span class=""math-container"">$Z_{L}$</span>, so shouldn't this remain the case after the measurements?</p>
",qc,expansion step state injection surface code lattice surgery work p looking oringal paper https nofollow noreferrer lattice surgery surface code expansion step state injection process meant take span l l larger surface code patch however https question https one seem indicate expansion process work p https nofollow noreferrer img https state injection expansion p main issues seem two bottom figures fact data qubits initialised span looking figure merge process involves smooth rough merge means right hand side rough merging measuring span l l surfaces effectively putting eigenstate span l l depending outcomes bottom row smooth merge qubits initialised wrong states occur need span p additionally pointed https 2 smooth merge would measuring span l l parity bottom row qubits one span l original 3 qubit one plus additional one right hand side lattice giving span l pink surface would match parity 4 face stabilisers bottom would match surface initialised either logical 0 ie superposition would expansion destroy injected state green surface already eigenstate span l remain case measurements,"[(3, 0.2053358), (4, 0.08291731), (5, 0.18309021), (13, 0.22585408), (16, 0.040418886), (18, 0.25243986)]"
40010,40012.0,2024-10-01 22:31:06,3,141,"<p>There are (at least) two conventions for single-qubit, arbitrary-angle Z rotations in quantum computing, which I will call Rz(theta) and Z^t.</p>
<p><span class=""math-container"">$$
R_Z(\theta) = \exp(-i \theta Z/2) = \mathrm{diag}(e^{-i \theta/2}, e^{i \theta/2}) \\
Z^t = \mathrm{diag}(1, (-1)^t) = \mathrm{diag}(1, e^{i \pi t}).
$$</span></p>
<p>In Cirq, these are <code>Rz</code> and <code>ZPowGate</code>. In OpenQASM3 these are <code>rz</code> and <code>p</code> &quot;phase&quot;. They are related by a global phase</p>
<p><span class=""math-container"">$$
R_Z(\theta) = e^{-i \theta/2} Z^{\theta / \pi}.
$$</span></p>
<p>Global phase doesn't matter until you start controlling operations, so Controlled(Z^t) is <em>not</em> the same as Controlled(Rz(t/pi)).</p>
<p>When doing lattice surgery on the surface code, arbitrary-angle rotations are very expensive; so I'd like to find compilations of C(Z^t) and C(Rz(t/pi)) that minimize the number of uncontrolled, arbitrary-angle rotations.</p>
<p>A circuit for C(Z^t) using one arbitrary-angle rotation is given in <a href=""https://arxiv.org/abs/1204.0567"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1204.0567</a>, figure 8. <strong>Is there an earlier reference that contains this circuit identity?</strong></p>
<p>You can do C(Rz(t/pi)) with two arbitrary-angle rotations, e.g. <a href=""https://docs.pennylane.ai/en/stable/code/api/pennylane.CRZ.html#pennylane.CRZ.compute_decomposition"" rel=""nofollow noreferrer"">https://docs.pennylane.ai/en/stable/code/api/pennylane.CRZ.html#pennylane.CRZ.compute_decomposition</a>. <strong>Is there a reference for this circuit identity I can cite?</strong></p>
<p><strong>Is there a way to do C(Rz) with only one arbitrary-angle rotation?</strong></p>
<p>or alternatively...</p>
<p><strong>Is it possible to prove that you need two arbitrary-angle rotations to implement C(Rz)?</strong></p>
",Is Controlled$(R_z(\theta))$ more expensive than Controlled$(Z^t)$ on the surface code?,<quantum-gate><circuit-construction><gate-synthesis><fault-tolerance><compiling>,1,1,,,"Is Controlled$(R_z(\theta))$ more expensive than Controlled$(Z^t)$ on the surface code? <p>There are (at least) two conventions for single-qubit, arbitrary-angle Z rotations in quantum computing, which I will call Rz(theta) and Z^t.</p>
<p><span class=""math-container"">$$
R_Z(\theta) = \exp(-i \theta Z/2) = \mathrm{diag}(e^{-i \theta/2}, e^{i \theta/2}) \\
Z^t = \mathrm{diag}(1, (-1)^t) = \mathrm{diag}(1, e^{i \pi t}).
$$</span></p>
<p>In Cirq, these are <code>Rz</code> and <code>ZPowGate</code>. In OpenQASM3 these are <code>rz</code> and <code>p</code> &quot;phase&quot;. They are related by a global phase</p>
<p><span class=""math-container"">$$
R_Z(\theta) = e^{-i \theta/2} Z^{\theta / \pi}.
$$</span></p>
<p>Global phase doesn't matter until you start controlling operations, so Controlled(Z^t) is <em>not</em> the same as Controlled(Rz(t/pi)).</p>
<p>When doing lattice surgery on the surface code, arbitrary-angle rotations are very expensive; so I'd like to find compilations of C(Z^t) and C(Rz(t/pi)) that minimize the number of uncontrolled, arbitrary-angle rotations.</p>
<p>A circuit for C(Z^t) using one arbitrary-angle rotation is given in <a href=""https://arxiv.org/abs/1204.0567"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1204.0567</a>, figure 8. <strong>Is there an earlier reference that contains this circuit identity?</strong></p>
<p>You can do C(Rz(t/pi)) with two arbitrary-angle rotations, e.g. <a href=""https://docs.pennylane.ai/en/stable/code/api/pennylane.CRZ.html#pennylane.CRZ.compute_decomposition"" rel=""nofollow noreferrer"">https://docs.pennylane.ai/en/stable/code/api/pennylane.CRZ.html#pennylane.CRZ.compute_decomposition</a>. <strong>Is there a reference for this circuit identity I can cite?</strong></p>
<p><strong>Is there a way to do C(Rz) with only one arbitrary-angle rotation?</strong></p>
<p>or alternatively...</p>
<p><strong>Is it possible to prove that you need two arbitrary-angle rotations to implement C(Rz)?</strong></p>
",qc,controlled expensive controlled surface code p least two conventions z rotations quantum computing call rz theta p span diag diag 1 diag 1 p cirq code rz code zpowgate openqasm3 code rz code p quot phase quot related global phase p span p global phase matter start controlling operations controlled em controlled rz p lattice surgery surface code rotations expensive like find compilations c c rz minimize number uncontrolled p circuit c using one rotation given https nofollow noreferrer https figure 8 strong earlier reference contains circuit identity p c rz two rotations https nofollow noreferrer https strong reference circuit identity cite p strong way c rz one rotation p alternatively p strong possible prove need two rotations implement c rz,"[(0, 0.047832604), (2, 0.01535788), (4, 0.13042052), (5, 0.07314364), (9, 0.61359555), (16, 0.032039262), (19, 0.07751876)]"
40011,40013.0,2024-10-02 08:25:10,1,92,"<p>I want to download the data tables from either the current QPUs or the previous ones (that have fewer qubits) from IBMQuantum. However, when I try to look at answers like <a href=""https://quantumcomputing.stackexchange.com/questions/11754/is-there-an-archive-of-ibmq-calibration-data"">Is there an archive of IBMQ calibration data?</a> or <a href=""https://quantumcomputing.stackexchange.com/questions/34703/how-to-get-pulse-level-historical-calibration-data-for-openpulse-devices"">How to get pulse-level historical calibration data for OpenPulse devices?</a> I always get errors.</p>
<p>I don't know much Python and having to learn a whole new framework (on top of the language) just to get the data is taking too much time. The only thing I need is the data. The ideal would be to select the time interval as well.</p>
<p>Can someone help me with this? By asking this I'm hoping to get an up-to-date answer to be displayed in this site, since there are probably other people struggling with this, so this will most likely help others as well.</p>
<hr />
<p>Edit: since my question was already answered, I'd figured that it would be nice for me to put here some important information. The parts of the code for getting the data and saving it are:</p>
<pre><code>def fetch_qubit_properties(service, backend_name, date):    
    # Fetch qubit properties for a specific backend and date

    backend = service.backend(backend_name)
    properties = backend.properties(datetime=date)

    # Check which backends are available for you
    # available_backends = service.backends()
    # print(f&quot;Available backends: {[backend.name for backend in available_backends]}&quot;)

    return properties


def extract_qubit_data(properties):
    # Extract qubit data from the properties and return it as a list of dictionaries.

    qubit_data = []

    # Define the expected keys
    # expected_keys = [
    #     &quot;Qubit&quot;, &quot;T1&quot;, &quot;T2&quot;, &quot;frequency&quot;, &quot;anharmonicity&quot;,
    #     &quot;readout_error&quot;, &quot;prob_meas0_prep1&quot;, &quot;prob_meas1_prep0&quot;, &quot;readout_length&quot;
    # ]

    expected_keys = [prop.name for prop in properties.qubits[0]]

    # Loop through each qubit's properties
    for idx in range(len(properties.qubits)):
        qubit_info = {key: None for key in expected_keys}  # Initialize all keys with None
        qubit_info[&quot;Qubit&quot;] = idx  # Set the qubit index

        # Get the properties for the current qubit
        qubit = properties.qubits[idx]
    
        if qubit:
            for prop in qubit:
                prop_name = prop.name  # Get property name
                prop_value = prop.value  # Get property value

                # Only update existing keys with actual values
                if prop_name in expected_keys:
                    qubit_info[prop_name] = prop_value

        # Check the collected info for the current qubit
        # print(f&quot;Collected data for Qubit {idx}: {qubit_info}&quot;)

        qubit_data.append(qubit_info)

    # Return the complete list of qubit data
    return qubit_data


def save_qubit_data_to_csv(qubit_data, date_str, directory):
    # Saves the qubit data to a CSV file for a given date.

    # Ensure the directory exists
    os.makedirs(directory, exist_ok=True)

    # Create the file path for the CSV file
    file_path = os.path.join(directory, f&quot;qubit_data_{date_str}.csv&quot;)

    # Create a DataFrame from the list of dictionaries
    df = pd.DataFrame(qubit_data)

    # Debugging output to check the DataFrame before saving
    # print(f&quot;DataFrame to save:\n{df}&quot;)

    # Save the DataFrame to a CSV file
    df.to_csv(file_path, index=False, encoding='utf-8')

    print(f&quot;Data successfully saved to {file_path}&quot;)
</code></pre>
",How to download historical calibration data from IBM quantum devices?,<qiskit><programming><ibm-quantum-devices><nisq>,1,0,,,"How to download historical calibration data from IBM quantum devices? <p>I want to download the data tables from either the current QPUs or the previous ones (that have fewer qubits) from IBMQuantum. However, when I try to look at answers like <a href=""https://quantumcomputing.stackexchange.com/questions/11754/is-there-an-archive-of-ibmq-calibration-data"">Is there an archive of IBMQ calibration data?</a> or <a href=""https://quantumcomputing.stackexchange.com/questions/34703/how-to-get-pulse-level-historical-calibration-data-for-openpulse-devices"">How to get pulse-level historical calibration data for OpenPulse devices?</a> I always get errors.</p>
<p>I don't know much Python and having to learn a whole new framework (on top of the language) just to get the data is taking too much time. The only thing I need is the data. The ideal would be to select the time interval as well.</p>
<p>Can someone help me with this? By asking this I'm hoping to get an up-to-date answer to be displayed in this site, since there are probably other people struggling with this, so this will most likely help others as well.</p>
<hr />
<p>Edit: since my question was already answered, I'd figured that it would be nice for me to put here some important information. The parts of the code for getting the data and saving it are:</p>
<pre><code>def fetch_qubit_properties(service, backend_name, date):    
    # Fetch qubit properties for a specific backend and date

    backend = service.backend(backend_name)
    properties = backend.properties(datetime=date)

    # Check which backends are available for you
    # available_backends = service.backends()
    # print(f&quot;Available backends: {[backend.name for backend in available_backends]}&quot;)

    return properties


def extract_qubit_data(properties):
    # Extract qubit data from the properties and return it as a list of dictionaries.

    qubit_data = []

    # Define the expected keys
    # expected_keys = [
    #     &quot;Qubit&quot;, &quot;T1&quot;, &quot;T2&quot;, &quot;frequency&quot;, &quot;anharmonicity&quot;,
    #     &quot;readout_error&quot;, &quot;prob_meas0_prep1&quot;, &quot;prob_meas1_prep0&quot;, &quot;readout_length&quot;
    # ]

    expected_keys = [prop.name for prop in properties.qubits[0]]

    # Loop through each qubit's properties
    for idx in range(len(properties.qubits)):
        qubit_info = {key: None for key in expected_keys}  # Initialize all keys with None
        qubit_info[&quot;Qubit&quot;] = idx  # Set the qubit index

        # Get the properties for the current qubit
        qubit = properties.qubits[idx]
    
        if qubit:
            for prop in qubit:
                prop_name = prop.name  # Get property name
                prop_value = prop.value  # Get property value

                # Only update existing keys with actual values
                if prop_name in expected_keys:
                    qubit_info[prop_name] = prop_value

        # Check the collected info for the current qubit
        # print(f&quot;Collected data for Qubit {idx}: {qubit_info}&quot;)

        qubit_data.append(qubit_info)

    # Return the complete list of qubit data
    return qubit_data


def save_qubit_data_to_csv(qubit_data, date_str, directory):
    # Saves the qubit data to a CSV file for a given date.

    # Ensure the directory exists
    os.makedirs(directory, exist_ok=True)

    # Create the file path for the CSV file
    file_path = os.path.join(directory, f&quot;qubit_data_{date_str}.csv&quot;)

    # Create a DataFrame from the list of dictionaries
    df = pd.DataFrame(qubit_data)

    # Debugging output to check the DataFrame before saving
    # print(f&quot;DataFrame to save:\n{df}&quot;)

    # Save the DataFrame to a CSV file
    df.to_csv(file_path, index=False, encoding='utf-8')

    print(f&quot;Data successfully saved to {file_path}&quot;)
</code></pre>
",qc,download historical calibration data ibm quantum devices p want download data tables either current qpus previous ones fewer qubits ibmquantum however try look answers like https archive ibmq calibration data https get historical calibration data openpulse devices always get p know much python learn whole new framework top language get data taking much time thing need data ideal would select time interval p someone help asking hoping get answer displayed site since probably people struggling likely help others hr p edit since question already answered figured would nice put important information parts code getting data saving pre code def service date fetch qubit properties specific backend date backend properties check backends available print f quot available backends backend quot return properties def properties extract qubit data properties return list dictionaries define expected keys quot qubit quot quot t1 quot quot t2 quot quot frequency quot quot anharmonicity quot quot quot quot quot quot quot quot quot prop 0 loop qubit properties idx range len key none key initialize keys none quot qubit quot idx set qubit index get properties current qubit qubit idx qubit prop qubit get property name get property value update existing keys actual values check collected info current qubit print f quot collected data qubit idx quot return complete list qubit data return def directory saves qubit data csv file given date ensure directory exists directory create file path csv file directory f quot quot create dataframe list dictionaries df debugging output check dataframe saving print f quot dataframe save df quot save dataframe csv file print f quot data successfully saved quot,"[(0, 0.15650636), (8, 0.34217584), (14, 0.18184632), (16, 0.044834312), (18, 0.050764084), (19, 0.2233406)]"
40016,40020.0,2024-10-02 18:38:47,0,73,"<p>In <a href=""https://arxiv.org/abs/1905.08916"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1905.08916</a>, the CCZ factory looks like this (minus the lower-distance T factories):</p>
<p><a href=""https://i.sstatic.net/Qs5MNDLn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qs5MNDLn.png"" alt=""block diagram of the CCZ factory with lattice surgery"" /></a></p>
<p>Why are the outputs so high? It seems like they could be &quot;used&quot;, i.e., directly sent to other parts of the circuit as soon as they exit the main body of the distillation. Even if they need stabilizer information from the measurements, the outputs still appear 2 rounds after the green measurement blocks, instead of 1 round.</p>
",Why are the outputs of a CCZ factory so high?,<error-correction><circuit-construction><surface-code>,1,0,,,"Why are the outputs of a CCZ factory so high? <p>In <a href=""https://arxiv.org/abs/1905.08916"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1905.08916</a>, the CCZ factory looks like this (minus the lower-distance T factories):</p>
<p><a href=""https://i.sstatic.net/Qs5MNDLn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qs5MNDLn.png"" alt=""block diagram of the CCZ factory with lattice surgery"" /></a></p>
<p>Why are the outputs so high? It seems like they could be &quot;used&quot;, i.e., directly sent to other parts of the circuit as soon as they exit the main body of the distillation. Even if they need stabilizer information from the measurements, the outputs still appear 2 rounds after the green measurement blocks, instead of 1 round.</p>
",qc,outputs ccz factory high p https nofollow noreferrer https ccz factory looks like minus factories p https nofollow noreferrer img https block diagram ccz factory lattice surgery p outputs high seems like could quot used quot directly sent parts circuit soon exit main body distillation even need stabilizer information measurements outputs still appear 2 rounds green measurement blocks instead 1,"[(2, 0.024092646), (4, 0.28141412), (5, 0.18377084), (7, 0.120997116), (14, 0.20789279), (16, 0.033454582), (18, 0.03647759), (19, 0.10990355)]"
40047,,2024-10-06 17:52:58,4,142,"<p>I'm following <a href=""https://pymatching.readthedocs.io/en/stable/toric-code-example.html"" rel=""nofollow noreferrer"">this</a> toric code tutorial, where they constructed the <span class=""math-container"">$X$</span>-logicals matrix using the <a href=""https://en.wikipedia.org/wiki/K%C3%BCnneth_theorem"" rel=""nofollow noreferrer"">Künneth theorem</a>.</p>
<p>I'm confused about why they specifically used <span class=""math-container"">$X$</span>-logicals when only <span class=""math-container"">$Z$</span> errors were allowed to occur.</p>
<p>I used the following code to create the <span class=""math-container"">$Z$</span>-logicals matrix manually.</p>
<pre class=""lang-python prettyprint-override""><code>def toric_code_z_logicals(L):
    n_qubits = 2 * L * L  # Total number of qubits in the toric code lattice
    matrix = dok_matrix((2, n_qubits), dtype=int)  # Two logical Z operators

    # Logical Z Operator 1: Mark every L-th qubit starting from the first qubit
    logical1_indices = [i * L for i in range(L)]

    # Logical Z Operator 2: Mark all qubits in the last row of the lattice
    logical2_start = n_qubits - L  # Starting index of the last row
    logical2_indices = [logical2_start + i for i in range(L)]

    # Fill in the matrix for the two logical Z operators
    for idx in logical1_indices:
        matrix[0, idx] = 1
    for idx in logical2_indices:
        matrix[1, idx] = 1

    return matrix.todense()
</code></pre>
<p>I tried using <span class=""math-container"">$Z$</span>-logicals instead but ended up with the following graph that looks like a bell curve when plotting the physical vs logical error graph using physical errors up to one.
<a href=""https://i.sstatic.net/F0rKINbV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F0rKINbV.png"" alt=""enter image description here"" /></a></p>
",Why are $X$-logicals used when only $Z$ errors are allowed in logical error calculation instead of $Z$-logicals?,<error-correction><pymatching><toric-code>,1,4,,,"Why are $X$-logicals used when only $Z$ errors are allowed in logical error calculation instead of $Z$-logicals? <p>I'm following <a href=""https://pymatching.readthedocs.io/en/stable/toric-code-example.html"" rel=""nofollow noreferrer"">this</a> toric code tutorial, where they constructed the <span class=""math-container"">$X$</span>-logicals matrix using the <a href=""https://en.wikipedia.org/wiki/K%C3%BCnneth_theorem"" rel=""nofollow noreferrer"">Künneth theorem</a>.</p>
<p>I'm confused about why they specifically used <span class=""math-container"">$X$</span>-logicals when only <span class=""math-container"">$Z$</span> errors were allowed to occur.</p>
<p>I used the following code to create the <span class=""math-container"">$Z$</span>-logicals matrix manually.</p>
<pre class=""lang-python prettyprint-override""><code>def toric_code_z_logicals(L):
    n_qubits = 2 * L * L  # Total number of qubits in the toric code lattice
    matrix = dok_matrix((2, n_qubits), dtype=int)  # Two logical Z operators

    # Logical Z Operator 1: Mark every L-th qubit starting from the first qubit
    logical1_indices = [i * L for i in range(L)]

    # Logical Z Operator 2: Mark all qubits in the last row of the lattice
    logical2_start = n_qubits - L  # Starting index of the last row
    logical2_indices = [logical2_start + i for i in range(L)]

    # Fill in the matrix for the two logical Z operators
    for idx in logical1_indices:
        matrix[0, idx] = 1
    for idx in logical2_indices:
        matrix[1, idx] = 1

    return matrix.todense()
</code></pre>
<p>I tried using <span class=""math-container"">$Z$</span>-logicals instead but ended up with the following graph that looks like a bell curve when plotting the physical vs logical error graph using physical errors up to one.
<a href=""https://i.sstatic.net/F0rKINbV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F0rKINbV.png"" alt=""enter image description here"" /></a></p>
",qc,x used z errors allowed logical error calculation instead z p following https nofollow noreferrer toric code tutorial constructed span x matrix using https c3 nofollow noreferrer künneth theorem p confused specifically used span x span z errors allowed p used following code create span z matrix pre code def l 2 l l total number qubits toric code lattice matrix 2 two logical z operators logical z operator 1 mark every qubit starting first qubit l range l logical z operator 2 mark qubits last row lattice l starting index last row range l fill matrix two logical z operators idx matrix 0 idx 1 idx matrix 1 idx 1 return p tried using span z instead ended following graph looks like bell curve plotting physical vs logical error graph using physical errors one https nofollow noreferrer img https enter image description,"[(0, 0.16624515), (2, 0.058128092), (3, 0.13861988), (4, 0.16977836), (5, 0.32071218), (10, 0.018655613), (11, 0.041778486), (16, 0.014177062), (17, 0.015580308), (18, 0.055624988)]"
40064,,2024-10-08 15:33:47,0,61,"<p>I'm trying to run multiple simulations of a stim circuit, in parallel. I am using Cupy to transfer the data to the GPU device but I get errors which because I think I can't run these simulations on the GPU. Is this true and is there a workaround? I'm currently using multiprocessing to run these simulations and it's working good, but I'm curious if it would better on the GPU.</p>
",Can I run stim on GPU?,<stim>,1,0,,,"Can I run stim on GPU? <p>I'm trying to run multiple simulations of a stim circuit, in parallel. I am using Cupy to transfer the data to the GPU device but I get errors which because I think I can't run these simulations on the GPU. Is this true and is there a workaround? I'm currently using multiprocessing to run these simulations and it's working good, but I'm curious if it would better on the GPU.</p>
",qc,run stim gpu p trying run multiple simulations stim circuit parallel using cupy transfer data gpu device get errors think ca run simulations gpu true workaround currently using multiprocessing run simulations working good curious would better,"[(14, 0.9189051), (16, 0.076118365)]"
40073,,2024-10-09 16:03:16,1,72,"<p>In this Qiskit community <a href=""https://github.com/qiskit-community/qiskit-community-tutorials/blob/master/Coding_With_Qiskit/ep5_Quantum_Teleportation.ipynb"" rel=""nofollow noreferrer"">tutorial on Quantum Teleportation (QT)</a>, the Step 5 in <code>In [3]</code> asks to measure Bob's final state.</p>
<pre><code>circuit.measure([2], [2])
</code></pre>
<p>But I have a basic question: Why do we need to measure the final state at all? Won't that collapse the quantum state? If the original state (initially in Alice's lab) is a superposition state, won't Bob lose the state after he measures it?</p>
<p>On the other hand, in the <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/circuits/01_circuit_basics.ipynb"" rel=""nofollow noreferrer"">Bell state generation tutorial</a>, no measurement is done explicitly (except through the simulator, see <code>In [11]</code> to <code>In [13]</code>). So why does the QT require the line <code>circuit.measure([2], [2])</code>?</p>
<p>Let me add a coding example below for more clarity and an awaited discussion.</p>
<pre><code>## ---  Module imports ----------------------

from qiskit import QuantumCircuit, transpile
from qiskit.quantum_info import Statevector

# Visualization
from qiskit.visualization import array_to_latex, plot_histogram

# Simulator
from qiskit_aer import AerSimulator 

# Others 
from IPython.display import Markdown
import numpy as np
%matplotlib inline


## ----- CODE FOR GENERATION OF BELL STATE |Phi+&gt; -------

# Create a quantum circuit for 2 qubits
qc = QuantumCircuit(2)

# Apply H-gate to the first qubit:
qc.h(0)

# Apply a CNOT:
qc.cx(0,1)

# Show circuit
display(qc.draw('mpl'))

simulator = AerSimulator() # need to import AerSimulator 

# Save the statevector into the quantum circuit
qc.save_statevector()


# Transpile the circuit for the simulator
qc = transpile(qc, simulator)

# Run on the simulator/backend
job = simulator.run(qc, shots=100).result() # some define variable `result` as well 

# Get final statevector from job
final_state_1 = job.get_statevector()
print('Final state =',final_state_1)
display( Markdown(r'Two qubit state ='), final_state_1.draw('latex') )
array_to_latex(final_state_1, prefix=&quot;(\\text{Two qubit state})^T = &quot;)

# Get counts and plot histogram 
plot_histogram(job.get_counts())
</code></pre>
<p>This gives us the plot shown below.</p>
<p><a href=""https://i.sstatic.net/2f0P7jwM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2f0P7jwM.png"" alt=""enter image description here"" /></a></p>
<p>Now the following is the code for Quantum Teleportation where I have intentionally commented out the line containing Bob's measurement [<code># qc.measure(2,2)</code>].</p>
<pre><code>## --- QUANTUM TELEPORTATION CODE ----------

# Create a quantum circuit for 3 qubits and their measurements

qc = QuantumCircuit(3, 3)


# Prepare mysterious state |Q&gt;  
choice = 0 # default choice |Q&gt; = |0&gt;
choice = 1  # |Q&gt; = |1&gt;
choice = 2 # |Q&gt; = (|0&gt; + |1&gt;)/sqrt(2)
choice = 3; a = 0.8; b = np.sqrt(1-a*a)
           # |Q&gt; = a|0&gt; + b|1&gt; [generic superposition]

choice = 1
if choice == 0:
  print('|Q &gt; = |0 &gt;')
elif choice == 1:
  qc.x(0) 
  print('|Q &gt; = |1 &gt;') 
elif choice == 2:
  qc.h(0) 
  print(f'|Q &gt; = .70710678|0 &gt; + .70710678|1 &gt;')
else:
  theta = 2*np.arccos(a); phi = 0
  qc.u(theta, phi, 0, 0) 
  print(f'|Q &gt; = {a}|0 &gt; + {b}|1 &gt;')
display(qc.draw('mpl'))


# Check initial state |\psi&gt;
psi = Statevector(qc)
print(psi)
display(Markdown(r'Initial three qubit state ='),psi.draw('latex'))
array_to_latex(psi, prefix=&quot;(\\text{Three qubit state})^T = &quot;)

###  Step 1: create an entangled Bell pair between Alice and Bob (q1 &amp; q2)
qc.h(1)
qc.cx(1,2)
qc.barrier() # put a barrier to demarcate


### Step 2: Alice applies a series of operations between the state to teleport (q0) 
###.       and her half of the Bell pair (q1)
qc.cx(0,1)
qc.barrier()
qc.h(0)
qc.barrier() # put a barrier to visualize 


### Step 3: Alice measures on q0 and q1, sends the results to Bob as classical bits
#qc.measure([0, 1], [0, 1]) # results stored in classical bits 0 and 1, respectively
qc.measure(0,0)
qc.measure(1,1)
qc.barrier()
qc.draw('mpl')

### Step 4: Based on Alice's results, Bob performs gates 
qc.cx(1,2)
qc.cz(0,2)
qc.draw('mpl')

### Step 5: Bob measures (does he need to?)
# qc.measure(2,2)

display(qc.draw(output='mpl'))


### Now check the state through quantum silmulator
simulator = AerSimulator() # need to import AerSimulator 

# Save the statevector into the quantum circuit
qc.save_statevector() # 


# Transpile the circuit for the simulator
qc = transpile(qc, simulator)

# Run job on the simulator/backend 
job = simulator.run(qc, shots=100).result() 

# Get final statevector from job
final_state_2 = job.get_statevector()
print('Final state =',final_state_2)
display( Markdown(r'Three qubit state ='), final_state_2.draw('latex') )
array_to_latex(final_state_2, prefix=&quot;(\\text{Three qubit state})^T = &quot;)



# Get counts and plot histogram
plot_histogram(job.get_counts())
</code></pre>
<p>I get the following output.</p>
<p><a href=""https://i.sstatic.net/eUnsg7vI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eUnsg7vI.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/HKQtTvOy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HKQtTvOy.png"" alt=""enter image description here"" /></a></p>
<p>As it can be seen, the final statevector after Bob's gate operations is correctly produced (<span class=""math-container"">$|Q\rangle = 1$</span>). However, that is not reflected in the histogram plot through the simulator and we get incorrect counts.</p>
<p>I also noticed that in the first code (Bell state generation), our quantum circuit does not contain any classical register while the second code (Quantum teleportation) has 3 classical registers. That's why we see &quot;quasi-probability&quot; in the first case and &quot;count&quot; in the second case. But does it make any big difference?</p>
",Why do we need Bob's measurement for Quantum Teleportation,<qiskit><quantum-state><measurement><teleportation>,1,0,,,"Why do we need Bob's measurement for Quantum Teleportation <p>In this Qiskit community <a href=""https://github.com/qiskit-community/qiskit-community-tutorials/blob/master/Coding_With_Qiskit/ep5_Quantum_Teleportation.ipynb"" rel=""nofollow noreferrer"">tutorial on Quantum Teleportation (QT)</a>, the Step 5 in <code>In [3]</code> asks to measure Bob's final state.</p>
<pre><code>circuit.measure([2], [2])
</code></pre>
<p>But I have a basic question: Why do we need to measure the final state at all? Won't that collapse the quantum state? If the original state (initially in Alice's lab) is a superposition state, won't Bob lose the state after he measures it?</p>
<p>On the other hand, in the <a href=""https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/circuits/01_circuit_basics.ipynb"" rel=""nofollow noreferrer"">Bell state generation tutorial</a>, no measurement is done explicitly (except through the simulator, see <code>In [11]</code> to <code>In [13]</code>). So why does the QT require the line <code>circuit.measure([2], [2])</code>?</p>
<p>Let me add a coding example below for more clarity and an awaited discussion.</p>
<pre><code>## ---  Module imports ----------------------

from qiskit import QuantumCircuit, transpile
from qiskit.quantum_info import Statevector

# Visualization
from qiskit.visualization import array_to_latex, plot_histogram

# Simulator
from qiskit_aer import AerSimulator 

# Others 
from IPython.display import Markdown
import numpy as np
%matplotlib inline


## ----- CODE FOR GENERATION OF BELL STATE |Phi+&gt; -------

# Create a quantum circuit for 2 qubits
qc = QuantumCircuit(2)

# Apply H-gate to the first qubit:
qc.h(0)

# Apply a CNOT:
qc.cx(0,1)

# Show circuit
display(qc.draw('mpl'))

simulator = AerSimulator() # need to import AerSimulator 

# Save the statevector into the quantum circuit
qc.save_statevector()


# Transpile the circuit for the simulator
qc = transpile(qc, simulator)

# Run on the simulator/backend
job = simulator.run(qc, shots=100).result() # some define variable `result` as well 

# Get final statevector from job
final_state_1 = job.get_statevector()
print('Final state =',final_state_1)
display( Markdown(r'Two qubit state ='), final_state_1.draw('latex') )
array_to_latex(final_state_1, prefix=&quot;(\\text{Two qubit state})^T = &quot;)

# Get counts and plot histogram 
plot_histogram(job.get_counts())
</code></pre>
<p>This gives us the plot shown below.</p>
<p><a href=""https://i.sstatic.net/2f0P7jwM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2f0P7jwM.png"" alt=""enter image description here"" /></a></p>
<p>Now the following is the code for Quantum Teleportation where I have intentionally commented out the line containing Bob's measurement [<code># qc.measure(2,2)</code>].</p>
<pre><code>## --- QUANTUM TELEPORTATION CODE ----------

# Create a quantum circuit for 3 qubits and their measurements

qc = QuantumCircuit(3, 3)


# Prepare mysterious state |Q&gt;  
choice = 0 # default choice |Q&gt; = |0&gt;
choice = 1  # |Q&gt; = |1&gt;
choice = 2 # |Q&gt; = (|0&gt; + |1&gt;)/sqrt(2)
choice = 3; a = 0.8; b = np.sqrt(1-a*a)
           # |Q&gt; = a|0&gt; + b|1&gt; [generic superposition]

choice = 1
if choice == 0:
  print('|Q &gt; = |0 &gt;')
elif choice == 1:
  qc.x(0) 
  print('|Q &gt; = |1 &gt;') 
elif choice == 2:
  qc.h(0) 
  print(f'|Q &gt; = .70710678|0 &gt; + .70710678|1 &gt;')
else:
  theta = 2*np.arccos(a); phi = 0
  qc.u(theta, phi, 0, 0) 
  print(f'|Q &gt; = {a}|0 &gt; + {b}|1 &gt;')
display(qc.draw('mpl'))


# Check initial state |\psi&gt;
psi = Statevector(qc)
print(psi)
display(Markdown(r'Initial three qubit state ='),psi.draw('latex'))
array_to_latex(psi, prefix=&quot;(\\text{Three qubit state})^T = &quot;)

###  Step 1: create an entangled Bell pair between Alice and Bob (q1 &amp; q2)
qc.h(1)
qc.cx(1,2)
qc.barrier() # put a barrier to demarcate


### Step 2: Alice applies a series of operations between the state to teleport (q0) 
###.       and her half of the Bell pair (q1)
qc.cx(0,1)
qc.barrier()
qc.h(0)
qc.barrier() # put a barrier to visualize 


### Step 3: Alice measures on q0 and q1, sends the results to Bob as classical bits
#qc.measure([0, 1], [0, 1]) # results stored in classical bits 0 and 1, respectively
qc.measure(0,0)
qc.measure(1,1)
qc.barrier()
qc.draw('mpl')

### Step 4: Based on Alice's results, Bob performs gates 
qc.cx(1,2)
qc.cz(0,2)
qc.draw('mpl')

### Step 5: Bob measures (does he need to?)
# qc.measure(2,2)

display(qc.draw(output='mpl'))


### Now check the state through quantum silmulator
simulator = AerSimulator() # need to import AerSimulator 

# Save the statevector into the quantum circuit
qc.save_statevector() # 


# Transpile the circuit for the simulator
qc = transpile(qc, simulator)

# Run job on the simulator/backend 
job = simulator.run(qc, shots=100).result() 

# Get final statevector from job
final_state_2 = job.get_statevector()
print('Final state =',final_state_2)
display( Markdown(r'Three qubit state ='), final_state_2.draw('latex') )
array_to_latex(final_state_2, prefix=&quot;(\\text{Three qubit state})^T = &quot;)



# Get counts and plot histogram
plot_histogram(job.get_counts())
</code></pre>
<p>I get the following output.</p>
<p><a href=""https://i.sstatic.net/eUnsg7vI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eUnsg7vI.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/HKQtTvOy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HKQtTvOy.png"" alt=""enter image description here"" /></a></p>
<p>As it can be seen, the final statevector after Bob's gate operations is correctly produced (<span class=""math-container"">$|Q\rangle = 1$</span>). However, that is not reflected in the histogram plot through the simulator and we get incorrect counts.</p>
<p>I also noticed that in the first code (Bell state generation), our quantum circuit does not contain any classical register while the second code (Quantum teleportation) has 3 classical registers. That's why we see &quot;quasi-probability&quot; in the first case and &quot;count&quot; in the second case. But does it make any big difference?</p>
",qc,need bob measurement quantum teleportation p qiskit community https nofollow noreferrer tutorial quantum teleportation qt step 5 code 3 asks measure bob final pre code 2 2 p basic question need measure final state wo collapse quantum state original state initially alice lab superposition state wo bob lose state measures p hand https nofollow noreferrer bell state generation tutorial measurement done explicitly except simulator see code 11 code 13 qt require line code 2 2 p let add coding example clarity awaited pre code module imports qiskit import quantumcircuit transpile import statevector visualization import simulator import aersimulator others import markdown import numpy np matplotlib inline code generation bell state gt create quantum circuit 2 qubits qc quantumcircuit 2 apply first qubit 0 apply cnot show circuit display simulator aersimulator need import aersimulator save statevector quantum circuit transpile circuit simulator qc transpile qc simulator run job qc define variable result well get final statevector job print state display markdown qubit state quot two qubit state quot get counts plot histogram p gives us plot shown p https nofollow noreferrer img https enter image description p following code quantum teleportation intentionally commented line containing bob measurement code pre code quantum teleportation code create quantum circuit 3 qubits measurements qc quantumcircuit 3 3 prepare mysterious state gt choice 0 default choice gt gt choice 1 gt gt choice 2 gt gt gt 2 choice 3 b gt gt gt generic superposition choice 1 choice 0 print gt gt elif choice 1 0 print gt gt elif choice 2 0 print gt gt gt else theta 2 phi 0 theta phi 0 0 print gt gt b gt display check initial state gt psi statevector qc print psi display markdown three qubit state psi quot three qubit state quot step 1 create entangled bell pair alice bob q1 amp q2 1 put barrier demarcate step 2 alice applies series operations state teleport q0 half bell pair q1 0 put barrier visualize step 3 alice measures q0 q1 sends results bob classical bits 0 1 0 1 results stored classical bits 0 1 respectively step 4 based alice results bob performs gates step 5 bob measures need display check state quantum silmulator simulator aersimulator need import aersimulator save statevector quantum circuit transpile circuit simulator qc transpile qc simulator run job job qc get final statevector job print state display markdown qubit state quot three qubit state quot get counts plot histogram p get following p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p seen final statevector bob gate operations correctly produced span 1 however reflected histogram plot simulator get incorrect p also noticed first code bell state generation quantum circuit contain classical register second code quantum teleportation 3 classical registers see quot quot first case quot count quot second case make big difference,"[(0, 0.35113412), (2, 0.070532344), (4, 0.1345941), (13, 0.011636264), (14, 0.07699699), (16, 0.011165494), (18, 0.31044275), (19, 0.02180955)]"
40118,,2024-10-15 12:05:52,1,29,"<p>I am testing a new algorithm for quantum error mitigation based on fuzzy clustering. As you can see in the piece of code below the calibration step is composed of multiple instances, that is I want to run each calibration circuit multiple times, let's say 10, for some post processing we are not interested in now. When running the code on local simulator it works fine but when I try to run it on IBM real backend the program is not retrieving any result, resulting in a timeout error, although on IBM quantum platform the job is successfully executed. Furthermore, when I manually retrieve results from IBM quantum platform, it looks like one single instance has been executed.</p>
<pre><code>qr = QuantumRegister(num_qubits) # Quantum register initialization
exp = CorrelatedReadoutError(qr, backend=backend)
meas_calibs, state_labels = exp.circuits()
if draw == True:
    for c in meas_calibs: # Return a list of measurement calibration circuits for the full Hilbert space
        print(c)

dict={}
for s in state_labels:
    dict[s]=list()
for n in range(num_runs):
    l_gen = tqdm(range(number_of_instances), desc=&quot;Number of instances&quot;) 
    for i in l_gen:
    
        transpiled_circuit = transpile(meas_calibs, backend, optimization_level=0)
        cal_results = backend.run(transpiled_circuit, shots=shots).result()
        
        for j in range(len(state_labels)):
            count=cal_results.get_counts(j)
            count_l=qu.convertInList(count, num_qubits)
            dict[state_labels[j]].append(count_l)
    for s in state_labels:
        matrix=np.array(dict[s]).T
        utils.save_obj(matrix, path+&quot;Alldata_&quot;+str(number_of_instances)+&quot;_&quot;+s+&quot;_&quot;+str(n))
print('Data created!')
</code></pre>
<p>Maybe it is necessary to create a batch or a session in order to execute a program with this type of structure, I could not figure out reading Qiskit documentation.</p>
",Executing multiple calibration circuits on IBM real backend,<qiskit-runtime><error-mitigation>,0,0,,,"Executing multiple calibration circuits on IBM real backend <p>I am testing a new algorithm for quantum error mitigation based on fuzzy clustering. As you can see in the piece of code below the calibration step is composed of multiple instances, that is I want to run each calibration circuit multiple times, let's say 10, for some post processing we are not interested in now. When running the code on local simulator it works fine but when I try to run it on IBM real backend the program is not retrieving any result, resulting in a timeout error, although on IBM quantum platform the job is successfully executed. Furthermore, when I manually retrieve results from IBM quantum platform, it looks like one single instance has been executed.</p>
<pre><code>qr = QuantumRegister(num_qubits) # Quantum register initialization
exp = CorrelatedReadoutError(qr, backend=backend)
meas_calibs, state_labels = exp.circuits()
if draw == True:
    for c in meas_calibs: # Return a list of measurement calibration circuits for the full Hilbert space
        print(c)

dict={}
for s in state_labels:
    dict[s]=list()
for n in range(num_runs):
    l_gen = tqdm(range(number_of_instances), desc=&quot;Number of instances&quot;) 
    for i in l_gen:
    
        transpiled_circuit = transpile(meas_calibs, backend, optimization_level=0)
        cal_results = backend.run(transpiled_circuit, shots=shots).result()
        
        for j in range(len(state_labels)):
            count=cal_results.get_counts(j)
            count_l=qu.convertInList(count, num_qubits)
            dict[state_labels[j]].append(count_l)
    for s in state_labels:
        matrix=np.array(dict[s]).T
        utils.save_obj(matrix, path+&quot;Alldata_&quot;+str(number_of_instances)+&quot;_&quot;+s+&quot;_&quot;+str(n))
print('Data created!')
</code></pre>
<p>Maybe it is necessary to create a batch or a session in order to execute a program with this type of structure, I could not figure out reading Qiskit documentation.</p>
",qc,executing multiple calibration circuits ibm real backend p testing new algorithm quantum error mitigation based fuzzy clustering see piece code calibration step composed multiple instances want run calibration circuit multiple times let say 10 post processing interested running code local simulator works fine try run ibm real backend program retrieving result resulting timeout error although ibm quantum platform job successfully executed furthermore manually retrieve results ibm quantum platform looks like one single instance pre code qr quantumregister quantum register initialization exp correlatedreadouterror qr draw true c return list measurement calibration circuits full hilbert space print c dict n range tqdm range quot number instances quot transpile backend j range len j count dict j dict matrix quot quot quot quot quot quot n print created p maybe necessary create batch session order execute program type structure could figure reading qiskit,"[(0, 0.270255), (3, 0.030333396), (7, 0.020810405), (8, 0.03964861), (14, 0.47890213), (16, 0.046297695), (19, 0.10745629)]"
40162,40163.0,2024-10-21 08:46:37,2,127,"<p>Given a stablizer expression (parity check matrix) of a quantum error correction code, how to obtain its system Hamitonian? I am not sure whether this is correct: for toric code, its Hamitonian is just to substract all the stabilizer. Assume the stabilizer for toric code is <span class=""math-container"">$A_s=\otimes_j \sigma^Z_j$</span> and <span class=""math-container"">$B_p=\otimes_j \sigma^X_j$</span> on the loop of lattice and dual lattice, the system Hamitonian is <span class=""math-container"">$H = -\sum_sA_s -\sum_p B_p$</span>. Refer to <a href=""https://arxiv.org/abs/quant-ph/9707021"" rel=""nofollow noreferrer"">1</a></p>
<p>If my understanding for toric code is correct, is the approach correct for all quantum error correction codes?</p>
",Stablizer expression(parity check matrix) to system Hamitonian for a quantum error correction code,<error-correction><stabilizer-code><surface-code>,1,0,,,"Stablizer expression(parity check matrix) to system Hamitonian for a quantum error correction code <p>Given a stablizer expression (parity check matrix) of a quantum error correction code, how to obtain its system Hamitonian? I am not sure whether this is correct: for toric code, its Hamitonian is just to substract all the stabilizer. Assume the stabilizer for toric code is <span class=""math-container"">$A_s=\otimes_j \sigma^Z_j$</span> and <span class=""math-container"">$B_p=\otimes_j \sigma^X_j$</span> on the loop of lattice and dual lattice, the system Hamitonian is <span class=""math-container"">$H = -\sum_sA_s -\sum_p B_p$</span>. Refer to <a href=""https://arxiv.org/abs/quant-ph/9707021"" rel=""nofollow noreferrer"">1</a></p>
<p>If my understanding for toric code is correct, is the approach correct for all quantum error correction codes?</p>
",qc,stablizer expression parity check matrix system hamitonian quantum error correction code p given stablizer expression parity check matrix quantum error correction code obtain system hamitonian sure whether correct toric code hamitonian substract stabilizer assume stabilizer toric code span span loop lattice dual lattice system hamitonian span h refer https nofollow noreferrer 1 p understanding toric code correct approach correct quantum error correction codes,"[(1, 0.09052083), (3, 0.1695419), (5, 0.41567904), (7, 0.21073964), (11, 0.027462063), (16, 0.032295205), (17, 0.05169844)]"
40207,40208.0,2024-10-24 19:23:00,2,133,"<p>I am trying to run my below code on FakeSherbrooke() system, but I am getting an error as shown below:
<code>The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits</code>.</p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.providers.aer import AerSimulator

from qiskit.utils import QuantumInstance
from qiskit.providers.fake_provider import FakeSherbrooke
from qiskit.algorithms import VQE
# backend = Aer.get_backend('qasm_simulator')
# backend = AerSimulator()
backend = FakeSherbrooke()
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Really not sure why I am getting this error and how to resolve it. This code is using <code>qiskit== 0.46</code>.
I also tested the <code>qiskit==1.0</code> version of the above code and I still get this error.</p>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_aer import AerSimulator

import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2

from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aer.primitives import Estimator as Estimator
from qiskit_ibm_runtime.fake_provider import  FakeSherbrooke

backend = AerSimulator()
# backend = FakeSherbrooke()

Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]

H_op = SparsePauliOp.from_operator(Hamiltonian)

ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)

pm = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    basis_gates=None,
    seed_transpiler=28
)
ansatz_opt = pm.run(ansatz)

optimizer = COBYLA(maxiter= 1500)

estimator = Estimator(
    run_options = {&quot;shots&quot;: 1024, &quot;seed&quot;: 28},
)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)

vqe = VQE(
    estimator=estimator,
    ansatz=ansatz_opt,
    optimizer=optimizer,
    initial_point=initial_point_values
)

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Any way to correct this error?</p>
",The number of qubits of the ansatz does not match the operator,<qiskit><programming><vqe>,1,0,,,"The number of qubits of the ansatz does not match the operator <p>I am trying to run my below code on FakeSherbrooke() system, but I am getting an error as shown below:
<code>The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits</code>.</p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.providers.aer import AerSimulator

from qiskit.utils import QuantumInstance
from qiskit.providers.fake_provider import FakeSherbrooke
from qiskit.algorithms import VQE
# backend = Aer.get_backend('qasm_simulator')
# backend = AerSimulator()
backend = FakeSherbrooke()
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Really not sure why I am getting this error and how to resolve it. This code is using <code>qiskit== 0.46</code>.
I also tested the <code>qiskit==1.0</code> version of the above code and I still get this error.</p>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_aer import AerSimulator

import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2

from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aer.primitives import Estimator as Estimator
from qiskit_ibm_runtime.fake_provider import  FakeSherbrooke

backend = AerSimulator()
# backend = FakeSherbrooke()

Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]

H_op = SparsePauliOp.from_operator(Hamiltonian)

ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)

pm = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    basis_gates=None,
    seed_transpiler=28
)
ansatz_opt = pm.run(ansatz)

optimizer = COBYLA(maxiter= 1500)

estimator = Estimator(
    run_options = {&quot;shots&quot;: 1024, &quot;seed&quot;: 28},
)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)

vqe = VQE(
    estimator=estimator,
    ansatz=ansatz_opt,
    optimizer=optimizer,
    initial_point=initial_point_values
)

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Any way to correct this error?</p>
",qc,number qubits ansatz match operator p trying run code fakesherbrooke system getting error shown code number qubits ansatz match operator ansatz allow setting number qubits using pre code qiskit import transpile qiskit import aer import numpy np import matrixop import efficientsu2 import cobyla import aersimulator import quantuminstance import fakesherbrooke import vqe backend backend aersimulator backend fakesherbrooke hamiltonian matrixop hamiltonian ansatz efficientsu2 5 true transpile backend backend optimizer cobyla 1500 quantuminstance backend 1024 default 1024 changing number shots 32m 28 28 none 2 vqe vqe optimizer result print result p really sure getting error resolve code using code also tested code version code still get pre code import import aersimulator import numpy np import sparsepauliop import efficientsu2 import vqe import cobyla import estimator estimator import fakesherbrooke backend aersimulator backend fakesherbrooke hamiltonian hamiltonian ansatz efficientsu2 5 true pm ansatz optimizer cobyla 1500 estimator estimator quot shots quot 1024 quot seed quot 28 2 vqe vqe result print result p way correct error,"[(0, 0.84651834), (1, 0.022624645), (12, 0.025401415), (16, 0.027052997), (17, 0.056164283), (19, 0.021358494)]"
40353,,2024-11-09 02:21:18,1,24,"<p>I’m implementing an arbitrary single-qubit gate in Q# , using pauli decompositon. The goal is to match the behavior of a specified unitary matrix acting on a single qubit. Here’s the code I’ve written so far:</p>
<pre><code>operation Task1 (q : Qubit, matrix : Complex[][]) : Unit is Adj + Ctl {
    let u00 = matrix[0][0];
    let u01 = matrix[0][1];
    let u10 = matrix[1][0];
    let u11 = matrix[1][1];
    let det_arg = ArgComplex(MinusC(TimesC(u00, u11), TimesC(u01, u10)));
    let phase = 0.5 * det_arg;
    let theta = 2.0 * ArcTan2(AbsComplex(u10), AbsComplex(u00));
    let ang1 = ArgComplex(u11);
    let ang2 = ArgComplex(u10);
    let phi = ang1 + ang2 - det_arg;
    let lam = ang1 - ang2;
    R1(phase, q);
    Rz(lam, q);
    Ry(theta, q);
    Rz(phi, q);
}
</code></pre>
<p>When running this operation through the testing harness, my output matches the expected values for u01 and u11, but u00 and u10 don't match. I'm not sure what’s causing this discrepancy and would appreciate guidance on where I might be going wrong.</p>
<p>Is there an issue in the way I’m calculating the parameters (phase, theta, phi, lam) for the rotation gates to reconstruct the unitary matrix?</p>
",Implementing an arbitrary complex valued single qubit unitary gate using a given matrix,<pauli-gates><q#>,0,0,,,"Implementing an arbitrary complex valued single qubit unitary gate using a given matrix <p>I’m implementing an arbitrary single-qubit gate in Q# , using pauli decompositon. The goal is to match the behavior of a specified unitary matrix acting on a single qubit. Here’s the code I’ve written so far:</p>
<pre><code>operation Task1 (q : Qubit, matrix : Complex[][]) : Unit is Adj + Ctl {
    let u00 = matrix[0][0];
    let u01 = matrix[0][1];
    let u10 = matrix[1][0];
    let u11 = matrix[1][1];
    let det_arg = ArgComplex(MinusC(TimesC(u00, u11), TimesC(u01, u10)));
    let phase = 0.5 * det_arg;
    let theta = 2.0 * ArcTan2(AbsComplex(u10), AbsComplex(u00));
    let ang1 = ArgComplex(u11);
    let ang2 = ArgComplex(u10);
    let phi = ang1 + ang2 - det_arg;
    let lam = ang1 - ang2;
    R1(phase, q);
    Rz(lam, q);
    Ry(theta, q);
    Rz(phi, q);
}
</code></pre>
<p>When running this operation through the testing harness, my output matches the expected values for u01 and u11, but u00 and u10 don't match. I'm not sure what’s causing this discrepancy and would appreciate guidance on where I might be going wrong.</p>
<p>Is there an issue in the way I’m calculating the parameters (phase, theta, phi, lam) for the rotation gates to reconstruct the unitary matrix?</p>
",qc,implementing arbitrary complex valued single qubit unitary gate using given matrix p implementing arbitrary gate q using pauli decompositon goal match behavior specified unitary matrix acting single qubit code written far pre code operation task1 q qubit matrix complex unit adj ctl let u00 matrix 0 0 let u01 matrix 0 1 let u10 matrix 1 0 let u11 matrix 1 1 let argcomplex minusc timesc u00 u11 timesc u01 u10 let phase let theta arctan2 abscomplex u10 abscomplex u00 let ang1 argcomplex u11 let ang2 argcomplex u10 let phi ang1 ang2 let lam ang1 ang2 r1 phase q rz lam q ry theta q rz phi q p running operation testing harness output matches expected values u01 u11 u00 u10 match sure causing discrepancy would appreciate guidance might going p issue way calculating parameters phase theta phi lam rotation gates reconstruct unitary matrix,"[(0, 0.094331756), (2, 0.07670842), (9, 0.14077799), (10, 0.04314448), (11, 0.06969202), (14, 0.21464045), (16, 0.3597626)]"
40435,,2024-11-17 12:07:57,1,13,"<p>I'm using mthree in Batch mode. A batch needs to be queued before it can be executed. The time when a batch was executed can be obtained from the IBM Quantum Platform site, so I would like to obtain calibration data by specifying that time later.</p>
<p>A similar question is discussed at <a href=""https://quantumcomputing.stackexchange.com/questions/40011/how-to-download-historical-calibration-data-from-ibm-quantum-devices"">How to download historical calibration data from IBM quantum devices?</a>. However, it seems that this method cannot obtain calibration data for mthree.</p>
<p>If you have a better method, please let me know. Thanks.</p>
",How to get historical calibration data for mthree (M3) from IBM Quantum devices?,<qiskit><programming><ibm-q-experience><ibm-quantum-devices><qiskit-runtime>,0,0,,,"How to get historical calibration data for mthree (M3) from IBM Quantum devices? <p>I'm using mthree in Batch mode. A batch needs to be queued before it can be executed. The time when a batch was executed can be obtained from the IBM Quantum Platform site, so I would like to obtain calibration data by specifying that time later.</p>
<p>A similar question is discussed at <a href=""https://quantumcomputing.stackexchange.com/questions/40011/how-to-download-historical-calibration-data-from-ibm-quantum-devices"">How to download historical calibration data from IBM quantum devices?</a>. However, it seems that this method cannot obtain calibration data for mthree.</p>
<p>If you have a better method, please let me know. Thanks.</p>
",qc,get historical calibration data mthree m3 ibm quantum devices p using mthree batch mode batch needs queued executed time batch executed obtained ibm quantum platform site would like obtain calibration data specifying time p similar question discussed https download historical calibration data ibm quantum devices however seems method obtain calibration data p better method please let know,"[(1, 0.096027195), (4, 0.023175683), (14, 0.45668045), (16, 0.42131895)]"
