Id,AcceptedAnswerId,CreationDate,Score,ViewCount,Body,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,text,From,processed_text,topics
114056,,2011-10-12 17:01:18,8,5270,"<p>I've been reading up a lot lately on various web application deployment processes using SVN or GIT, with a view to redesigning how we currently deploy where I work.</p>

<p>As is the way with many flavours of Agile, it's assumed that anything committed to master or trunk is production ready. Both GitHub and Etsy, <a href=""http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/"">http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/</a> say that they work on this basis (although Etsy actually have a staging environment).</p>

<p>This process assumes all unit test and CI tests have been run. You run the tests locally and on CI and then commit to trunk. SO, at this point your code is <strong>technically</strong> sound.</p>

<p>Your code may be technically correct, but user/functional testing may unearth more bugs, particularly when it comes to front end testing.</p>

<p>My question is this. Where do QA and Business owners test the feature changes you have implemented? On your local development machine before you commit to trunk, or on a QA/staging machine? </p>

<p>If you have a staging machine that runs off trunk, and you assume that all code committed to trunk is production ready ... eh .. then at what point is the code signed off and good to go into production from both a technical and business perspective? If you have only one staging machine, many developers and that is where the code is to be QA'd, then how can you deploy from trunk as many developer changes can be waiting for sign off.</p>

<p>I'd be interested to hear how others have approached this?</p>
",Agile development deployment process. Where do QA and Business Owners test?,<git><unit-testing><svn><testing><deployment>,3,0,,,"Agile development deployment process. Where do QA and Business Owners test? <p>I've been reading up a lot lately on various web application deployment processes using SVN or GIT, with a view to redesigning how we currently deploy where I work.</p>

<p>As is the way with many flavours of Agile, it's assumed that anything committed to master or trunk is production ready. Both GitHub and Etsy, <a href=""http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/"">http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/</a> say that they work on this basis (although Etsy actually have a staging environment).</p>

<p>This process assumes all unit test and CI tests have been run. You run the tests locally and on CI and then commit to trunk. SO, at this point your code is <strong>technically</strong> sound.</p>

<p>Your code may be technically correct, but user/functional testing may unearth more bugs, particularly when it comes to front end testing.</p>

<p>My question is this. Where do QA and Business owners test the feature changes you have implemented? On your local development machine before you commit to trunk, or on a QA/staging machine? </p>

<p>If you have a staging machine that runs off trunk, and you assume that all code committed to trunk is production ready ... eh .. then at what point is the code signed off and good to go into production from both a technical and business perspective? If you have only one staging machine, many developers and that is where the code is to be QA'd, then how can you deploy from trunk as many developer changes can be waiting for sign off.</p>

<p>I'd be interested to hear how others have approached this?</p>
",cr,agile development deployment process qa business owners test p reading lot lately various web application deployment processes using svn git view redesigning currently deploy p way many flavours agile assumed anything committed master trunk production ready github etsy http http say work basis although etsy actually staging environment p process assumes unit test ci tests run run tests locally ci commit trunk point code strong technically p code may technically correct testing may unearth bugs particularly comes front end p question qa business owners test feature changes implemented local development machine commit trunk machine p staging machine runs trunk assume code committed trunk production ready eh point code signed good go production technical business perspective one staging machine many developers code qa deploy trunk many developer changes waiting sign p interested hear others approached,"[(1, 0.046115488), (8, 0.5288846), (9, 0.07462183), (12, 0.010321636), (13, 0.11498209), (14, 0.22363316)]"
114056,,2011-10-12 17:01:18,8,5270,"<p>I've been reading up a lot lately on various web application deployment processes using SVN or GIT, with a view to redesigning how we currently deploy where I work.</p>

<p>As is the way with many flavours of Agile, it's assumed that anything committed to master or trunk is production ready. Both GitHub and Etsy, <a href=""http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/"">http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/</a> say that they work on this basis (although Etsy actually have a staging environment).</p>

<p>This process assumes all unit test and CI tests have been run. You run the tests locally and on CI and then commit to trunk. SO, at this point your code is <strong>technically</strong> sound.</p>

<p>Your code may be technically correct, but user/functional testing may unearth more bugs, particularly when it comes to front end testing.</p>

<p>My question is this. Where do QA and Business owners test the feature changes you have implemented? On your local development machine before you commit to trunk, or on a QA/staging machine? </p>

<p>If you have a staging machine that runs off trunk, and you assume that all code committed to trunk is production ready ... eh .. then at what point is the code signed off and good to go into production from both a technical and business perspective? If you have only one staging machine, many developers and that is where the code is to be QA'd, then how can you deploy from trunk as many developer changes can be waiting for sign off.</p>

<p>I'd be interested to hear how others have approached this?</p>
",Agile development deployment process. Where do QA and Business Owners test?,<git><unit-testing><svn><testing><deployment>,3,0,,,"Agile development deployment process. Where do QA and Business Owners test? <p>I've been reading up a lot lately on various web application deployment processes using SVN or GIT, with a view to redesigning how we currently deploy where I work.</p>

<p>As is the way with many flavours of Agile, it's assumed that anything committed to master or trunk is production ready. Both GitHub and Etsy, <a href=""http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/"">http://codeascraft.etsy.com/2010/05/20/quantum-of-deployment/</a> say that they work on this basis (although Etsy actually have a staging environment).</p>

<p>This process assumes all unit test and CI tests have been run. You run the tests locally and on CI and then commit to trunk. SO, at this point your code is <strong>technically</strong> sound.</p>

<p>Your code may be technically correct, but user/functional testing may unearth more bugs, particularly when it comes to front end testing.</p>

<p>My question is this. Where do QA and Business owners test the feature changes you have implemented? On your local development machine before you commit to trunk, or on a QA/staging machine? </p>

<p>If you have a staging machine that runs off trunk, and you assume that all code committed to trunk is production ready ... eh .. then at what point is the code signed off and good to go into production from both a technical and business perspective? If you have only one staging machine, many developers and that is where the code is to be QA'd, then how can you deploy from trunk as many developer changes can be waiting for sign off.</p>

<p>I'd be interested to hear how others have approached this?</p>
",se,agile development deployment process qa business owners test p reading lot lately various web application deployment processes using svn git view redesigning currently deploy p way many flavours agile assumed anything committed master trunk production ready github etsy http http say work basis although etsy actually staging environment p process assumes unit test ci tests run run tests locally ci commit trunk point code strong technically p code may technically correct testing may unearth bugs particularly comes front end p question qa business owners test feature changes implemented local development machine commit trunk machine p staging machine runs trunk assume code committed trunk production ready eh point code signed good go production technical business perspective one staging machine many developers code qa deploy trunk many developer changes waiting sign p interested hear others approached,"[(1, 0.046116423), (8, 0.5288828), (9, 0.07461079), (12, 0.010321639), (13, 0.11499529), (14, 0.22363183)]"
184936,,2013-01-26 14:52:17,1,3286,"<p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",Round Robin - how to determine the optimal quantum of time?,<unix><scheduling><process>,1,1,,,"Round Robin - how to determine the optimal quantum of time? <p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",se,round robin determine optimal quantum time p calculate proper quantum time http nofollow round robin process scheduling algorithm read http nofollow tanenbaum book quantum time cover like 80 running time p formula find optimal quantum time,"[(1, 0.34386572), (7, 0.18423218), (12, 0.031376757), (13, 0.22428213), (14, 0.088578686), (17, 0.1234467)]"
184936,,2013-01-26 14:52:17,1,3286,"<p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",Round Robin - how to determine the optimal quantum of time?,<unix><scheduling><process>,1,1,,,"Round Robin - how to determine the optimal quantum of time? <p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",cr,round robin determine optimal quantum time p calculate proper quantum time http nofollow round robin process scheduling algorithm read http nofollow tanenbaum book quantum time cover like 80 running time p formula find optimal quantum time,"[(1, 0.34389785), (7, 0.18422356), (12, 0.031377062), (13, 0.22424658), (14, 0.08858592), (17, 0.123451225)]"
17680,17853.0,2021-05-27 18:25:17,1,63,"<p>I am trying to create a portfolio optimization with the DWave Quantum Computer. I wrote some code trying to somehow reconstruct the following Ising model <a href=""https://www.osti.gov/servlets/purl/1423041"" rel=""nofollow noreferrer"">paper</a>:
<a href=""https://i.sstatic.net/LRYMK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LRYMK.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/Nni1A.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Nni1A.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/V0bKC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/V0bKC.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/xzYas.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xzYas.png"" alt=""enter image description here"" /></a></p>
<p><code>Ai</code> is the maximum amount of money that can be invested in the i-th asset.
<code>B</code> is the total budget.
<code>Ri</code> denote the random variable representing the return from asset i.</p>
<p>This is how I tried to code it:</p>
<pre><code>    import datetime
    import pandas as pd
    import fix_yahoo_finance as yf
    import pandas_datareader.data as web
    import numpy as np
    import neal
    import dimod
    from dwave.system import DWaveSampler
    import random
    import hybrid
    
    def cov(a,b):
        return a.cov(b)
    
    def hi(price, returns, cov):
        #mean price
        Ai = np.mean(price)
    
        #mean expected return
        E = np.mean(returns)
    
        # hi = -(1/2)((1/3)*cov(Ri,Rj) + (1/3)Ai^2 - (1/3)E(Ri) - 2B(1/3)*Ai)
        h = (-(1/2)*((1/3)*cov + (1/3)* (Ai ** 2) - (1/3)* E - 2*100*(1/3)*Ai))
        return h
    
    yf.pdr_override()
    
    start = datetime.datetime(2018,1,3)       
    end = datetime.datetime(2021,1,1)
    all_data = {ticker: web.get_data_yahoo(ticker,start,end)
              for ticker in ['AAPL','IBM','MSFT','GOOGL']}    #Note: GOOG has become GOOGL
    price = pd.DataFrame({ticker:data['Adj Close']
                        for ticker,data in all_data.items()})
    volume = pd.DataFrame({ticker:data['Volume']
                         for ticker,data in all_data.items()})
    returns = price.pct_change()      #calculate the percentage of the price
    
    returns = returns.dropna()
    
    print(returns.tail())
        
    a = cov(returns['AAPL'], returns['IBM'])
    b = cov(returns['IBM'], returns['MSFT'])
    c = cov(returns['MSFT'], returns['GOOGL'])
    d = cov(returns['GOOGL'], returns['AAPL'])
    
    apple = hi(price['AAPL'],returns['AAPL'], a)
    ibm = hi(price['IBM'],returns['IBM'], b)
    microsoft = hi(price['MSFT'],returns['MSFT'], c)
    google = hi(price['GOOGL'],returns['GOOGL'], d)
    
    
    sampler = neal.SimulatedAnnealingSampler()
    
    #qpu = DWaveSampler()
    
    h = {apple: 0.0, ibm: 0.0, microsoft: 0.0, google: 0.0}
    #energy changes when bias value changes
    J = {(apple, ibm): 0.0, (ibm, microsoft): 0.0, (google, apple): 0.0, (apple, microsoft): 0.0, (ibm, google): 0.0}
    sampleset = sampler.sample_ising(h, J, num_reads=10, annealing_time=2000)
    print(sampleset)
</code></pre>
<p>And this is the output sampleset:</p>
<p><a href=""https://i.sstatic.net/IDV4l.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IDV4l.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering what the numbers on top meant, so the <code>-224463.77916595488 1414.5773363996423</code> etc. and if this is correct</p>
",What do the numbers in the Ising sampleset mean?,<hamiltonian-simulation><d-wave><annealing>,1,0,,,"What do the numbers in the Ising sampleset mean? <p>I am trying to create a portfolio optimization with the DWave Quantum Computer. I wrote some code trying to somehow reconstruct the following Ising model <a href=""https://www.osti.gov/servlets/purl/1423041"" rel=""nofollow noreferrer"">paper</a>:
<a href=""https://i.sstatic.net/LRYMK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LRYMK.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/Nni1A.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Nni1A.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/V0bKC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/V0bKC.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/xzYas.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xzYas.png"" alt=""enter image description here"" /></a></p>
<p><code>Ai</code> is the maximum amount of money that can be invested in the i-th asset.
<code>B</code> is the total budget.
<code>Ri</code> denote the random variable representing the return from asset i.</p>
<p>This is how I tried to code it:</p>
<pre><code>    import datetime
    import pandas as pd
    import fix_yahoo_finance as yf
    import pandas_datareader.data as web
    import numpy as np
    import neal
    import dimod
    from dwave.system import DWaveSampler
    import random
    import hybrid
    
    def cov(a,b):
        return a.cov(b)
    
    def hi(price, returns, cov):
        #mean price
        Ai = np.mean(price)
    
        #mean expected return
        E = np.mean(returns)
    
        # hi = -(1/2)((1/3)*cov(Ri,Rj) + (1/3)Ai^2 - (1/3)E(Ri) - 2B(1/3)*Ai)
        h = (-(1/2)*((1/3)*cov + (1/3)* (Ai ** 2) - (1/3)* E - 2*100*(1/3)*Ai))
        return h
    
    yf.pdr_override()
    
    start = datetime.datetime(2018,1,3)       
    end = datetime.datetime(2021,1,1)
    all_data = {ticker: web.get_data_yahoo(ticker,start,end)
              for ticker in ['AAPL','IBM','MSFT','GOOGL']}    #Note: GOOG has become GOOGL
    price = pd.DataFrame({ticker:data['Adj Close']
                        for ticker,data in all_data.items()})
    volume = pd.DataFrame({ticker:data['Volume']
                         for ticker,data in all_data.items()})
    returns = price.pct_change()      #calculate the percentage of the price
    
    returns = returns.dropna()
    
    print(returns.tail())
        
    a = cov(returns['AAPL'], returns['IBM'])
    b = cov(returns['IBM'], returns['MSFT'])
    c = cov(returns['MSFT'], returns['GOOGL'])
    d = cov(returns['GOOGL'], returns['AAPL'])
    
    apple = hi(price['AAPL'],returns['AAPL'], a)
    ibm = hi(price['IBM'],returns['IBM'], b)
    microsoft = hi(price['MSFT'],returns['MSFT'], c)
    google = hi(price['GOOGL'],returns['GOOGL'], d)
    
    
    sampler = neal.SimulatedAnnealingSampler()
    
    #qpu = DWaveSampler()
    
    h = {apple: 0.0, ibm: 0.0, microsoft: 0.0, google: 0.0}
    #energy changes when bias value changes
    J = {(apple, ibm): 0.0, (ibm, microsoft): 0.0, (google, apple): 0.0, (apple, microsoft): 0.0, (ibm, google): 0.0}
    sampleset = sampler.sample_ising(h, J, num_reads=10, annealing_time=2000)
    print(sampleset)
</code></pre>
<p>And this is the output sampleset:</p>
<p><a href=""https://i.sstatic.net/IDV4l.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IDV4l.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering what the numbers on top meant, so the <code>-224463.77916595488 1414.5773363996423</code> etc. and if this is correct</p>
",qc,numbers ising sampleset mean p trying create portfolio optimization dwave quantum computer wrote code trying somehow reconstruct following ising model https nofollow noreferrer paper https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description p code ai maximum amount money invested asset code b total budget code ri denote random variable representing return asset p tried code pre code import datetime import pandas pd import yf import web import numpy np import neal import dimod import dwavesampler import random import hybrid def cov b return b def hi price returns cov mean price ai price mean expected return e returns hi cov ri rj e ri 2b ai h cov ai 2 e 2 100 ai return h start end ticker ticker start end ticker note goog become googl price ticker data close ticker data volume ticker data ticker data returns calculate percentage price returns print cov returns returns b cov returns returns c cov returns returns cov returns returns apple hi price returns ibm hi price returns b microsoft hi price returns c google hi price returns sampler qpu dwavesampler h apple ibm microsoft google energy changes bias value changes j apple ibm ibm microsoft google apple apple microsoft ibm google sampleset h j print sampleset p output sampleset p https nofollow noreferrer img https enter image description p wondering numbers top meant code etc correct,"[(0, 0.2533653), (1, 0.020991035), (3, 0.077732936), (4, 0.38276458), (8, 0.081743), (12, 0.03694445), (17, 0.13893211)]"
17782,17785.0,2021-06-02 07:18:42,2,134,"<p>We know that <span class=""math-container"">$\mathsf{SO}(3)$</span> matrix stands for the proper rotation in 3D space. But when I read this <a href=""https://doi.org/10.48550/arXiv.quant-ph/9911004"" rel=""nofollow noreferrer"">paper</a>, there is a <span class=""math-container"">$\mathsf{SO}(3)$</span> matrix stands for the general query matrix of Grover's algorithm in <span class=""math-container"">$\mathsf{SO}(3)$</span> form:
<span class=""math-container"">$$
\left(\begin{array}{ccc}
R_{11} &amp; R_{12} &amp; R_{13} \\
R_{21} &amp; R_{22} &amp; R_{23} \\
R_{31} &amp; R_{32} &amp; R_{33}
\end{array}\right),
$$</span>
where
<span class=""math-container"">\begin{align*}
R_{11}&amp;=\cos \phi\left(\cos ^{2} 2 \beta \cos \theta+\sin ^{2} 2 \beta\right)+\cos 2 \beta \sin \theta \sin \phi\\
R_{12}&amp;=\cos 2 \beta \cos \phi \sin \theta- 
\cos \theta \sin \phi\\R_{13}&amp;=-\cos \phi \sin 4 \beta \sin ^{2} \frac{\theta}{2}+\sin 2 \beta \sin \theta \sin \phi\\R_{21}&amp;=-\cos (2 \beta) \cos \phi \sin \theta+ 
\left(\cos ^{2} \frac{\theta}{2}-\cos 4 \beta \sin ^{2} \frac{\theta}{2}\right) \sin \phi\\R_{22}&amp;=\cos \theta \cos \phi+\cos 2 \beta \sin \theta \sin \phi\\ R_{23}&amp;=-\cos \phi \sin 2 \beta \sin \theta- 
\sin 4 \beta \sin ^{2} \frac{\theta}{2} \sin \phi\\R_{31}&amp;=-\sin 4 \beta \sin ^{2} \frac{\theta}{2}\\R_{32}&amp;=\sin 2 \beta \sin \theta\\R_{33}&amp;=\cos ^{2} 2 \beta+\cos \theta \sin ^{2} 2 \beta\,.
\end{align*}</span>
The paper says that the eigenvector of this matrix is <span class=""math-container"">$(\cot \frac{\phi}{2},1,-\cot 2 \beta \cot \frac{\phi}{2}+\cot \frac{\theta}{2} \csc 2 \beta)^{T}$</span>.</p>
<p>I know this question is very basic and I've tried to use Matlab to calculate it. But I just can't figure out how can the author got the eigenvector of such a simple form? Can it be manually calculated? Is there a better way to compute the eigenvector of this kind of parameterized matrix?</p>
",How to compute the eigenvector of this complex matrix in Grover's algorithm?,<quantum-algorithms><linear-algebra><grovers-algorithm>,1,3,,,"How to compute the eigenvector of this complex matrix in Grover's algorithm? <p>We know that <span class=""math-container"">$\mathsf{SO}(3)$</span> matrix stands for the proper rotation in 3D space. But when I read this <a href=""https://doi.org/10.48550/arXiv.quant-ph/9911004"" rel=""nofollow noreferrer"">paper</a>, there is a <span class=""math-container"">$\mathsf{SO}(3)$</span> matrix stands for the general query matrix of Grover's algorithm in <span class=""math-container"">$\mathsf{SO}(3)$</span> form:
<span class=""math-container"">$$
\left(\begin{array}{ccc}
R_{11} &amp; R_{12} &amp; R_{13} \\
R_{21} &amp; R_{22} &amp; R_{23} \\
R_{31} &amp; R_{32} &amp; R_{33}
\end{array}\right),
$$</span>
where
<span class=""math-container"">\begin{align*}
R_{11}&amp;=\cos \phi\left(\cos ^{2} 2 \beta \cos \theta+\sin ^{2} 2 \beta\right)+\cos 2 \beta \sin \theta \sin \phi\\
R_{12}&amp;=\cos 2 \beta \cos \phi \sin \theta- 
\cos \theta \sin \phi\\R_{13}&amp;=-\cos \phi \sin 4 \beta \sin ^{2} \frac{\theta}{2}+\sin 2 \beta \sin \theta \sin \phi\\R_{21}&amp;=-\cos (2 \beta) \cos \phi \sin \theta+ 
\left(\cos ^{2} \frac{\theta}{2}-\cos 4 \beta \sin ^{2} \frac{\theta}{2}\right) \sin \phi\\R_{22}&amp;=\cos \theta \cos \phi+\cos 2 \beta \sin \theta \sin \phi\\ R_{23}&amp;=-\cos \phi \sin 2 \beta \sin \theta- 
\sin 4 \beta \sin ^{2} \frac{\theta}{2} \sin \phi\\R_{31}&amp;=-\sin 4 \beta \sin ^{2} \frac{\theta}{2}\\R_{32}&amp;=\sin 2 \beta \sin \theta\\R_{33}&amp;=\cos ^{2} 2 \beta+\cos \theta \sin ^{2} 2 \beta\,.
\end{align*}</span>
The paper says that the eigenvector of this matrix is <span class=""math-container"">$(\cot \frac{\phi}{2},1,-\cot 2 \beta \cot \frac{\phi}{2}+\cot \frac{\theta}{2} \csc 2 \beta)^{T}$</span>.</p>
<p>I know this question is very basic and I've tried to use Matlab to calculate it. But I just can't figure out how can the author got the eigenvector of such a simple form? Can it be manually calculated? Is there a better way to compute the eigenvector of this kind of parameterized matrix?</p>
",qc,compute eigenvector complex matrix grover algorithm p know span 3 matrix stands proper rotation 3d space read https nofollow noreferrer paper span 3 matrix stands general query matrix grover algorithm span 3 form span array ccc 11 amp 12 amp 13 21 amp 22 amp 23 31 amp 32 amp 33 array span align 11 amp 2 2 2 2 2 12 amp 2 13 amp 4 2 2 2 21 amp 2 2 2 4 2 2 22 amp 2 23 amp 2 4 2 2 31 amp 4 2 2 32 amp 2 33 amp 2 2 2 2 align paper says eigenvector matrix span 2 2 2 2 2 p know question basic tried use matlab calculate ca figure author got eigenvector simple form manually calculated better way compute eigenvector kind parameterized matrix,"[(2, 0.26210788), (3, 0.10963424), (4, 0.036291696), (6, 0.14256246), (7, 0.12316541), (11, 0.018418811), (12, 0.015020658), (15, 0.29191738)]"
17802,,2021-06-03 09:31:06,4,98,"<p>I have the following minmax problem and I am wondering if the order of the minimum and maximum can be interchanged and if yes, why?</p>
<p>Let <span class=""math-container"">$\|\cdot\|_1$</span> be the trace norm defined as <span class=""math-container"">$\|\rho\|_1 = \text{Tr}(\sqrt{\rho^\dagger \rho})$</span>. This gives us a distance measure between quantum states i.e. <span class=""math-container"">$\|\rho - \sigma\|_1$</span>. Consider Hilbert spaces <span class=""math-container"">$A,B,E$</span> and <span class=""math-container"">$R$</span>.</p>
<p>The optimization problem I have is</p>
<p><span class=""math-container"">$$\max\limits_{\phi_{AR}} \min_{V_{E\rightarrow E}}\|(I_A\otimes V_{E\rightarrow E})(U_{A\rightarrow BE}\otimes I_R)\phi_{AR} - (U'_{A\rightarrow BE}\otimes I_R)\phi_{AR} \|_1$$</span></p>
<p>where <span class=""math-container"">$U_{A\rightarrow BE}, U'_{A\rightarrow BE}, V_{E\rightarrow E}$</span> are all isometries and <span class=""math-container"">$\phi_{AR}$</span> is a pure state. So my optimization is over the set of isometries and pure states neither of which is a convex set. However, note that the optimizations involved are on different Hilbert spaces.</p>
<p>Is it true or false that
<span class=""math-container"">\begin{align*}
\max_{\phi_{AR}} &amp;\min_{V_{E\rightarrow E}}\|(I_A\otimes V_{E\rightarrow E})(U_{A\rightarrow BE}\otimes I_R)\phi_{AR} - (U'_{A\rightarrow BE}\otimes I_R)\phi_{AR} \|_1 \\
&amp;= \min_{V_{E\rightarrow E}}\max_{\phi_{AR}} \|(I_A\otimes V_{E\rightarrow E})(U_{A\rightarrow BE}\otimes I_R)\phi_{AR} - (U'_{A\rightarrow BE}\otimes I_R)\phi_{AR} \|_1
\end{align*}</span>
and if true, what is the justification? I am aware that I can always upper bound the LHS with the RHS using the <a href=""https://en.wikipedia.org/wiki/Max%E2%80%93min_inequality"" rel=""nofollow noreferrer"">maxmin inequality</a>.</p>
",Minmax theorem for optimization over isometries and states,<quantum-state><information-theory><unitarity><optimization><trace-distance>,0,2,,,"Minmax theorem for optimization over isometries and states <p>I have the following minmax problem and I am wondering if the order of the minimum and maximum can be interchanged and if yes, why?</p>
<p>Let <span class=""math-container"">$\|\cdot\|_1$</span> be the trace norm defined as <span class=""math-container"">$\|\rho\|_1 = \text{Tr}(\sqrt{\rho^\dagger \rho})$</span>. This gives us a distance measure between quantum states i.e. <span class=""math-container"">$\|\rho - \sigma\|_1$</span>. Consider Hilbert spaces <span class=""math-container"">$A,B,E$</span> and <span class=""math-container"">$R$</span>.</p>
<p>The optimization problem I have is</p>
<p><span class=""math-container"">$$\max\limits_{\phi_{AR}} \min_{V_{E\rightarrow E}}\|(I_A\otimes V_{E\rightarrow E})(U_{A\rightarrow BE}\otimes I_R)\phi_{AR} - (U'_{A\rightarrow BE}\otimes I_R)\phi_{AR} \|_1$$</span></p>
<p>where <span class=""math-container"">$U_{A\rightarrow BE}, U'_{A\rightarrow BE}, V_{E\rightarrow E}$</span> are all isometries and <span class=""math-container"">$\phi_{AR}$</span> is a pure state. So my optimization is over the set of isometries and pure states neither of which is a convex set. However, note that the optimizations involved are on different Hilbert spaces.</p>
<p>Is it true or false that
<span class=""math-container"">\begin{align*}
\max_{\phi_{AR}} &amp;\min_{V_{E\rightarrow E}}\|(I_A\otimes V_{E\rightarrow E})(U_{A\rightarrow BE}\otimes I_R)\phi_{AR} - (U'_{A\rightarrow BE}\otimes I_R)\phi_{AR} \|_1 \\
&amp;= \min_{V_{E\rightarrow E}}\max_{\phi_{AR}} \|(I_A\otimes V_{E\rightarrow E})(U_{A\rightarrow BE}\otimes I_R)\phi_{AR} - (U'_{A\rightarrow BE}\otimes I_R)\phi_{AR} \|_1
\end{align*}</span>
and if true, what is the justification? I am aware that I can always upper bound the LHS with the RHS using the <a href=""https://en.wikipedia.org/wiki/Max%E2%80%93min_inequality"" rel=""nofollow noreferrer"">maxmin inequality</a>.</p>
",qc,minmax theorem optimization isometries states p following minmax problem wondering order minimum maximum interchanged yes p let span trace norm defined span tr gives us distance measure quantum states span consider hilbert spaces span b e span r p optimization problem p span ar e e ar u ar p span u e isometries span ar pure state optimization set isometries pure states neither convex set however note optimizations involved different hilbert p true false span align ar amp e e ar u ar amp e ar e ar u ar align true justification aware always upper bound lhs rhs using https e2 80 nofollow noreferrer maxmin inequality,"[(1, 0.055221494), (3, 0.65216583), (4, 0.020008247), (6, 0.010412773), (7, 0.015148831), (10, 0.01078841), (12, 0.019806344), (13, 0.012870595), (15, 0.20252073)]"
17870,,2021-06-08 19:41:01,1,205,"<p>Coding for Qiskit</p>
<p>I watched this video:
<a href=""https://www.youtube.com/watch?v=RrUTwq5jKM4"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=RrUTwq5jKM4</a></p>
<p>Using Mac OS Big Sur
Using Jupyter 2.0.8
Using Python 3.8</p>
<p>The below code did not work and therefore installed pylatexenc ('pip install pylatexenc') It installed successfully. I then restarted jupyter and It still prints the same error. When I try to reinstall pylatexenc  - it says it already there. I tried running while Jupyter is on and in a new terminal (Mac) window I tried to reinstall it- get the same message. Tried 'import pylatexenc *' at beginning of code - does not work - any advice</p>
<p>Code:</p>
<pre><code>from qiskit import *
from pylatexenc import *

qr = QuantumRegister(2)

cr = ClassicalRegister(2)

circuit = QuantumCircuit(qr, cr)

%matplotlib inline

circuit.draw()

circuit.h(qr[0])

circuit.draw(output='mpl')
</code></pre>
<p>Here is the error message:</p>
<pre><code>ImportError                               Traceback (most recent call last)
&lt;ipython-input-8-bd220039ee1c&gt; in &lt;module&gt;
----&gt; 1 circuit.draw(output='mpl')

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py in draw(self, output, scale, filename, style, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle)
   1496         from qiskit.visualization import circuit_drawer
   1497 
-&gt; 1498         return circuit_drawer(self, scale=scale,
   1499                               filename=filename, style=style,
   1500                               output=output,

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/visualization/circuit_visualization.py in circuit_drawer(circuit, scale, filename, style, output, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle)
    221                                       cregbundle=cregbundle)
    222     elif output == 'mpl':
--&gt; 223         image = _matplotlib_circuit_drawer(circuit, scale=scale,
    224                                            filename=filename, style=style,
    225                                            plot_barriers=plot_barriers,

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/visualization/circuit_visualization.py in _matplotlib_circuit_drawer(circuit, scale, filename, style, plot_barriers, reverse_bits, justify, idle_wires, with_layout, fold, ax, initial_state, cregbundle)
    515 
    516     global_phase = circuit.global_phase if hasattr(circuit, 'global_phase') else None
--&gt; 517     qcd = _matplotlib.MatplotlibDrawer(qubits, clbits, ops, scale=scale, style=style,
    518                                        plot_barriers=plot_barriers, layout=layout,
    519                                        fold=fold, ax=ax, initial_state=initial_state,

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/visualization/matplotlib.py in __init__(self, qubits, clbits, ops, scale, style, plot_barriers, layout, fold, ax, initial_state, cregbundle, global_phase, qregs, cregs)
    126         self.plt_mod = plt
    127         if not HAS_PYLATEX:
--&gt; 128             raise ImportError('The class MatplotlibDrawer needs pylatexenc. '
    129                               'to install, run &quot;pip install pylatexenc&quot;.')
    130         self._clbit = []
</code></pre>
",Qiskit - lesson 3 - with Abe,<programming><qiskit><ibm-quantum-devices>,1,2,,,"Qiskit - lesson 3 - with Abe <p>Coding for Qiskit</p>
<p>I watched this video:
<a href=""https://www.youtube.com/watch?v=RrUTwq5jKM4"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=RrUTwq5jKM4</a></p>
<p>Using Mac OS Big Sur
Using Jupyter 2.0.8
Using Python 3.8</p>
<p>The below code did not work and therefore installed pylatexenc ('pip install pylatexenc') It installed successfully. I then restarted jupyter and It still prints the same error. When I try to reinstall pylatexenc  - it says it already there. I tried running while Jupyter is on and in a new terminal (Mac) window I tried to reinstall it- get the same message. Tried 'import pylatexenc *' at beginning of code - does not work - any advice</p>
<p>Code:</p>
<pre><code>from qiskit import *
from pylatexenc import *

qr = QuantumRegister(2)

cr = ClassicalRegister(2)

circuit = QuantumCircuit(qr, cr)

%matplotlib inline

circuit.draw()

circuit.h(qr[0])

circuit.draw(output='mpl')
</code></pre>
<p>Here is the error message:</p>
<pre><code>ImportError                               Traceback (most recent call last)
&lt;ipython-input-8-bd220039ee1c&gt; in &lt;module&gt;
----&gt; 1 circuit.draw(output='mpl')

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py in draw(self, output, scale, filename, style, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle)
   1496         from qiskit.visualization import circuit_drawer
   1497 
-&gt; 1498         return circuit_drawer(self, scale=scale,
   1499                               filename=filename, style=style,
   1500                               output=output,

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/visualization/circuit_visualization.py in circuit_drawer(circuit, scale, filename, style, output, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle)
    221                                       cregbundle=cregbundle)
    222     elif output == 'mpl':
--&gt; 223         image = _matplotlib_circuit_drawer(circuit, scale=scale,
    224                                            filename=filename, style=style,
    225                                            plot_barriers=plot_barriers,

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/visualization/circuit_visualization.py in _matplotlib_circuit_drawer(circuit, scale, filename, style, plot_barriers, reverse_bits, justify, idle_wires, with_layout, fold, ax, initial_state, cregbundle)
    515 
    516     global_phase = circuit.global_phase if hasattr(circuit, 'global_phase') else None
--&gt; 517     qcd = _matplotlib.MatplotlibDrawer(qubits, clbits, ops, scale=scale, style=style,
    518                                        plot_barriers=plot_barriers, layout=layout,
    519                                        fold=fold, ax=ax, initial_state=initial_state,

~/opt/anaconda3/lib/python3.8/site-packages/qiskit/visualization/matplotlib.py in __init__(self, qubits, clbits, ops, scale, style, plot_barriers, layout, fold, ax, initial_state, cregbundle, global_phase, qregs, cregs)
    126         self.plt_mod = plt
    127         if not HAS_PYLATEX:
--&gt; 128             raise ImportError('The class MatplotlibDrawer needs pylatexenc. '
    129                               'to install, run &quot;pip install pylatexenc&quot;.')
    130         self._clbit = []
</code></pre>
",qc,qiskit lesson 3 abe p coding qiskit p watched video https nofollow noreferrer https p using mac os big sur using jupyter using python p code work therefore installed pylatexenc install pylatexenc installed successfully restarted jupyter still prints error try reinstall pylatexenc says already tried running jupyter new terminal mac window tried reinstall get message tried pylatexenc beginning code work advice p code pre code qiskit import pylatexenc import qr quantumregister 2 cr classicalregister 2 circuit quantumcircuit qr cr matplotlib inline qr 0 p error message pre code importerror traceback recent call last lt gt lt module gt gt 1 draw self output scale filename style interactive justify fold ax cregbundle 1496 import 1497 gt 1498 return self 1499 1500 circuit scale filename style output interactive justify fold ax cregbundle 221 222 elif output gt 223 image circuit 224 225 circuit scale filename style justify fold ax cregbundle 515 516 hasattr circuit else none gt 517 qcd qubits clbits ops 518 519 self qubits clbits ops scale style layout fold ax cregbundle qregs cregs 126 plt 127 gt 128 raise importerror class matplotlibdrawer needs pylatexenc 129 install run quot pip install pylatexenc quot 130,"[(0, 0.49716413), (4, 0.041151065), (8, 0.12738748), (12, 0.0502574), (14, 0.17366089), (15, 0.013596441), (19, 0.08350294)]"
17894,17896.0,2021-06-10 04:22:25,5,175,"<p>No matter from the true physical realization to date or from some papers, it seems that multipartite entanglement creation is difficult. However, the circuit showing below can easily create entanglement at least from the perspective of gates:
<a href=""https://i.sstatic.net/sghCQ.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/sghCQ.png"" alt=""enter image description here"" /></a></p>
<p>The H in the picture above means the Hardmard gate, and the other four blue items are the control-x gate. The circuit can change <span class=""math-container"">$\mid 0\rangle^{\otimes n}$</span> into <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""noreferrer"">GHZ state</a>.</p>
<p>So since the circuit realization of entanglement is clearly easy, why the entanglement creation in practice become a hard thing? Does it mean that the control-x gate or Hardmard gate is hard to realize, or there are some other reasons which make the realization of the circuit above very difficult?</p>
",Why is entanglement creation difficult?,<entanglement><experimental-realization>,1,0,,,"Why is entanglement creation difficult? <p>No matter from the true physical realization to date or from some papers, it seems that multipartite entanglement creation is difficult. However, the circuit showing below can easily create entanglement at least from the perspective of gates:
<a href=""https://i.sstatic.net/sghCQ.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/sghCQ.png"" alt=""enter image description here"" /></a></p>
<p>The H in the picture above means the Hardmard gate, and the other four blue items are the control-x gate. The circuit can change <span class=""math-container"">$\mid 0\rangle^{\otimes n}$</span> into <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""noreferrer"">GHZ state</a>.</p>
<p>So since the circuit realization of entanglement is clearly easy, why the entanglement creation in practice become a hard thing? Does it mean that the control-x gate or Hardmard gate is hard to realize, or there are some other reasons which make the realization of the circuit above very difficult?</p>
",qc,entanglement creation difficult p matter true physical realization date papers seems multipartite entanglement creation difficult however circuit showing easily create entanglement least perspective gates https noreferrer img https enter image description p h picture means hardmard gate four blue items gate circuit change span n https e2 80 93horne e2 80 noreferrer ghz state p since circuit realization entanglement clearly easy entanglement creation practice become hard thing mean gate hardmard gate hard realize reasons make realization circuit difficult,"[(4, 0.27163878), (5, 0.020028576), (8, 0.27940714), (9, 0.17015089), (12, 0.0554021), (18, 0.20150988)]"
17974,18016.0,2021-06-15 21:09:28,3,296,"<p>I am using the method from <a href=""https://quantumcomputing.stackexchange.com/questions/12080/evaluating-expectation-values-of-operators-in-qiskit"">this SE answer</a> to calculate the expectation value using qiskit aqua operator logic which works well for a single circuit. Here is a simplified code snippet to demonstrate how it works.</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer
import numpy as np
from qiskit.aqua import QuantumInstance
from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn, CircuitOp, CircuitStateFn

qctl = QuantumRegister(1)
psi  = QuantumCircuit(qctl)
psi  = CircuitStateFn(psi)

qctl = QuantumRegister(2)
op   = QuantumCircuit(qctl)
op.z(0)
op.ry(np.pi/4,0)
op   = CircuitOp(op)

backend = Aer.get_backend('qasm_simulator')
q_instance = QuantumInstance(backend, shots=1024)
measurable_expression = StateFn(op, is_measurement=True).compose(psi)
expectation = PauliExpectation().convert(measurable_expression)
sampler = CircuitSampler(q_instance).convert(expectation)
print('Expectation Value = ', sampler.eval())
</code></pre>
<p>However, I am applying it to a VQE application and for each iteration I have $x&gt;1$ circuits. There is no issue when I run on my local machine because there is no queue time, but on the IBMQ machines I would like to submit a batch of the aqua expectation value circuits for each iteration to reduce queue times. For a list of circuits I can submit a batch using the <code>IBMQJobManager()</code> function, however, the method I am using does not store circuits as a list. My question is, can I use the jobmanager with the aqua expectation value to submit a batch of jobs to IBMQ? If not, is there a different way to submit a batch of the aqua expectation value circuits?</p>
",How to find the expectation value of several circuits using Qiskit aqua operator logic?,<programming><qiskit><ibm-q-experience><vqe>,1,4,,,"How to find the expectation value of several circuits using Qiskit aqua operator logic? <p>I am using the method from <a href=""https://quantumcomputing.stackexchange.com/questions/12080/evaluating-expectation-values-of-operators-in-qiskit"">this SE answer</a> to calculate the expectation value using qiskit aqua operator logic which works well for a single circuit. Here is a simplified code snippet to demonstrate how it works.</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer
import numpy as np
from qiskit.aqua import QuantumInstance
from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn, CircuitOp, CircuitStateFn

qctl = QuantumRegister(1)
psi  = QuantumCircuit(qctl)
psi  = CircuitStateFn(psi)

qctl = QuantumRegister(2)
op   = QuantumCircuit(qctl)
op.z(0)
op.ry(np.pi/4,0)
op   = CircuitOp(op)

backend = Aer.get_backend('qasm_simulator')
q_instance = QuantumInstance(backend, shots=1024)
measurable_expression = StateFn(op, is_measurement=True).compose(psi)
expectation = PauliExpectation().convert(measurable_expression)
sampler = CircuitSampler(q_instance).convert(expectation)
print('Expectation Value = ', sampler.eval())
</code></pre>
<p>However, I am applying it to a VQE application and for each iteration I have $x&gt;1$ circuits. There is no issue when I run on my local machine because there is no queue time, but on the IBMQ machines I would like to submit a batch of the aqua expectation value circuits for each iteration to reduce queue times. For a list of circuits I can submit a batch using the <code>IBMQJobManager()</code> function, however, the method I am using does not store circuits as a list. My question is, can I use the jobmanager with the aqua expectation value to submit a batch of jobs to IBMQ? If not, is there a different way to submit a batch of the aqua expectation value circuits?</p>
",qc,find expectation value several circuits using qiskit aqua operator logic p using method https se answer calculate expectation value using qiskit aqua operator logic works well single circuit simplified code snippet demonstrate pre code import qiskit qiskit import quantumcircuit quantumregister classicalregister aer import numpy np import quantuminstance import pauliexpectation circuitsampler statefn circuitop circuitstatefn qctl quantumregister 1 psi quantumcircuit qctl psi circuitstatefn psi qctl quantumregister 2 op quantumcircuit qctl 0 op circuitop op backend quantuminstance backend statefn op psi expectation pauliexpectation sampler circuitsampler expectation print value p however applying vqe application iteration x gt 1 circuits issue run local machine queue time ibmq machines would like submit batch aqua expectation value circuits iteration reduce queue times list circuits submit batch using code ibmqjobmanager function however method using store circuits list question use jobmanager aqua expectation value submit batch jobs ibmq different way submit batch aqua expectation value circuits,"[(0, 0.637116), (12, 0.016396701), (14, 0.33539438)]"
18053,,2021-06-20 17:19:19,2,72,"<p>I am working on calculating the exact runtime of a quantum circuit on the <code>ibmq_16_melbourne</code> device. I am using the API <code>result.time_taken</code> to calculate the run time.</p>
<pre><code>result = execute(circuit, backend, shots=8000).result()
counts = result.get_counts(circuit)
print(counts)
print(&quot;Time taken: &quot;, result.time_taken)
</code></pre>
<p>I executed by python code on ibm quantum lab (which is a Jupyter notebook) and also using Pycharm on my laptop. I get huge variations in the results. So, I concluded that <code>result.time_taken</code> does not provide the run time correctly. I am going through the documentation, but still could not find the solution.</p>
<p>Please provide some solution to calculate exact runtime.</p>
",Issues in calculating exact runtime on ibmq_16_melbourne,<programming><qiskit>,0,7,,,"Issues in calculating exact runtime on ibmq_16_melbourne <p>I am working on calculating the exact runtime of a quantum circuit on the <code>ibmq_16_melbourne</code> device. I am using the API <code>result.time_taken</code> to calculate the run time.</p>
<pre><code>result = execute(circuit, backend, shots=8000).result()
counts = result.get_counts(circuit)
print(counts)
print(&quot;Time taken: &quot;, result.time_taken)
</code></pre>
<p>I executed by python code on ibm quantum lab (which is a Jupyter notebook) and also using Pycharm on my laptop. I get huge variations in the results. So, I concluded that <code>result.time_taken</code> does not provide the run time correctly. I am going through the documentation, but still could not find the solution.</p>
<p>Please provide some solution to calculate exact runtime.</p>
",qc,issues calculating exact runtime p working calculating exact runtime quantum circuit code device using api code calculate run pre code result execute circuit backend counts circuit print counts print quot time taken quot p executed python code ibm quantum lab jupyter notebook also using pycharm laptop get huge variations results concluded code provide run time correctly going documentation still could find p please provide solution calculate exact,"[(0, 0.08489759), (12, 0.015372524), (14, 0.85384566), (19, 0.04342941)]"
18104,,2021-06-23 07:49:50,1,100,"<p>Continuing from my last question that I posted about a paper on Graph States. I have another doubt regarding a possible typo error in the paper. Here it goes. The authors define a 'labeled state' as
<span class=""math-container"">$$|G_{\vec{l}}\rangle=\bigotimes_{i}X_i^{l_{i1}}Z_i^{l_{i2}}|G'\rangle$$</span>where G is a graph state.
Then they define an 'encoded graph state' as <span class=""math-container"">$$ |G_{\vec{l}_{*2}}\rangle=\bigotimes_{i}Z_i^{l_{i2}}|G'\rangle $$</span> and say that the encoded graph state is the labeled graph state with <span class=""math-container"">$l_{1i}=0, \forall i$</span>.</p>
<p>Here <span class=""math-container"">$\vec{l}_{i*}=(l_{i1},l_{i2})$</span> for the i-th vertex, <span class=""math-container"">$\vec{l}_{*j}=(l_{1j},l_{2j},....l_{nj})$</span> for the <span class=""math-container"">$j$</span> th bit over all the <span class=""math-container"">$n$</span> vertices, and <span class=""math-container"">$\vec{l}=(\vec{l}_{1*}, \vec{l}_{2*},........\vec{l}_{n*}$</span>, each <span class=""math-container"">$l_{ij}\in \{0,1\}$</span>.</p>
<p>My question is shouldn't the condition be <span class=""math-container"">$l_{i1}=0, \forall i$</span>, because only then the X gate is removed.  Can somebody check?</p>
<p>The link for the paper is <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309"" rel=""nofollow noreferrer"">https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309</a></p>
","Possible typo in the paper ""Graph states for quantum secret sharing""",<graph-states>,1,3,,,"Possible typo in the paper ""Graph states for quantum secret sharing"" <p>Continuing from my last question that I posted about a paper on Graph States. I have another doubt regarding a possible typo error in the paper. Here it goes. The authors define a 'labeled state' as
<span class=""math-container"">$$|G_{\vec{l}}\rangle=\bigotimes_{i}X_i^{l_{i1}}Z_i^{l_{i2}}|G'\rangle$$</span>where G is a graph state.
Then they define an 'encoded graph state' as <span class=""math-container"">$$ |G_{\vec{l}_{*2}}\rangle=\bigotimes_{i}Z_i^{l_{i2}}|G'\rangle $$</span> and say that the encoded graph state is the labeled graph state with <span class=""math-container"">$l_{1i}=0, \forall i$</span>.</p>
<p>Here <span class=""math-container"">$\vec{l}_{i*}=(l_{i1},l_{i2})$</span> for the i-th vertex, <span class=""math-container"">$\vec{l}_{*j}=(l_{1j},l_{2j},....l_{nj})$</span> for the <span class=""math-container"">$j$</span> th bit over all the <span class=""math-container"">$n$</span> vertices, and <span class=""math-container"">$\vec{l}=(\vec{l}_{1*}, \vec{l}_{2*},........\vec{l}_{n*}$</span>, each <span class=""math-container"">$l_{ij}\in \{0,1\}$</span>.</p>
<p>My question is shouldn't the condition be <span class=""math-container"">$l_{i1}=0, \forall i$</span>, because only then the X gate is removed.  Can somebody check?</p>
<p>The link for the paper is <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309"" rel=""nofollow noreferrer"">https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309</a></p>
",qc,possible typo paper graph states quantum secret sharing p continuing last question posted paper graph states another doubt regarding possible typo error paper goes authors define state span l i1 i2 g graph state define graph state span l 2 i2 say encoded graph state labeled graph state span 1i p span l i1 i2 vertex span l j 1j 2j nj span j th bit span n vertices span l l 1 l 2 l n span ij p question condition span i1 x gate removed somebody check p link paper https nofollow noreferrer https,"[(3, 0.6183166), (4, 0.053921867), (5, 0.021189066), (10, 0.010744569), (12, 0.034925193), (13, 0.25929627)]"
18141,,2021-06-25 15:16:36,1,110,"<p>The authors of the paper Graph States for Quantum Secret Sharing <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309"" rel=""nofollow noreferrer"">https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309</a> define a 'labeled state' as
<span class=""math-container"">$$|G_{\vec{l}}\rangle=\bigotimes_{i}X_i^{l_{i1}}Z_i^{l_{i2}}|G\rangle$$</span>where G is a graph state.
Then they define an 'encoded graph state' as <span class=""math-container"">$$ |G_{\vec{l}_{*2}}\rangle=\bigotimes_{i}Z_i^{l_{i2}}|G\rangle $$</span> and say that the encoded graph state is the labeled graph state with <span class=""math-container"">$l_{1i}=0, \forall i$</span>.</p>
<p>Here <span class=""math-container"">$\vec{l}_{i*}=(l_{i1},l_{i2})$</span> for the i-th vertex, <span class=""math-container"">$\vec{l}_{*j}=(l_{1j},l_{2j},....l_{nj})$</span> for the <span class=""math-container"">$j$</span> th bit over all the <span class=""math-container"">$n$</span> vertices, and <span class=""math-container"">$\vec{l}=(\vec{l}_{1*}, \vec{l}_{2*},........\vec{l}_{n*}$</span>, each <span class=""math-container"">$l_{ij}\in \{0,1\}$</span>.</p>
<p>With this framework they try to define a secret sharing protocol. However before the actual protocol, they give an example. I am understanding bits of the theory but not all of it, Here it is</p>
<ol>
<li>For a 4-party scheme, they prepare a graph state <span class=""math-container"">$$Z^{l_{12}}\otimes Z^{l_{22}}\otimes Z^{l_{32}}\otimes Z^{l_{42}} \left(|0+++\rangle+|1---\rangle\right)$$</span>, corresponding to this they have 4 stabilizers (generators) of the stabilizer group <span class=""math-container"">$K_1=XZZZ,K_2=ZXII,K_3=ZIXI,K_4=ZIIX$</span>, with eigenvalues <span class=""math-container"">$(l_{12},l_{22},l_{32},l_{42})$</span>.</li>
</ol>
<p>My first understanding about the eigenvalues is that <span class=""math-container"">$l_{i2}$</span> are eigenvalues because those are the indices (powers) where we have possible commuting issues between the <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> gate, so when they are zero the eigenvalues are <span class=""math-container"">$1$</span> and when they are <span class=""math-container"">$1$</span> they eigenvalues are <span class=""math-container"">$-1$</span>, and correspondingly the the graph states are orthogonal (since they correspond to different eigenvalues). Is my undertanding okay or atleast near okay? Shouldn't the eigenvalues be
<span class=""math-container"">$(-1)^{l_{i2}} \forall~i$</span>?</p>

",Quantum Graph state paper query (Phy Rev A),<graph-states>,0,5,,,"Quantum Graph state paper query (Phy Rev A) <p>The authors of the paper Graph States for Quantum Secret Sharing <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309"" rel=""nofollow noreferrer"">https://journals.aps.org/pra/abstract/10.1103/PhysRevA.78.042309</a> define a 'labeled state' as
<span class=""math-container"">$$|G_{\vec{l}}\rangle=\bigotimes_{i}X_i^{l_{i1}}Z_i^{l_{i2}}|G\rangle$$</span>where G is a graph state.
Then they define an 'encoded graph state' as <span class=""math-container"">$$ |G_{\vec{l}_{*2}}\rangle=\bigotimes_{i}Z_i^{l_{i2}}|G\rangle $$</span> and say that the encoded graph state is the labeled graph state with <span class=""math-container"">$l_{1i}=0, \forall i$</span>.</p>
<p>Here <span class=""math-container"">$\vec{l}_{i*}=(l_{i1},l_{i2})$</span> for the i-th vertex, <span class=""math-container"">$\vec{l}_{*j}=(l_{1j},l_{2j},....l_{nj})$</span> for the <span class=""math-container"">$j$</span> th bit over all the <span class=""math-container"">$n$</span> vertices, and <span class=""math-container"">$\vec{l}=(\vec{l}_{1*}, \vec{l}_{2*},........\vec{l}_{n*}$</span>, each <span class=""math-container"">$l_{ij}\in \{0,1\}$</span>.</p>
<p>With this framework they try to define a secret sharing protocol. However before the actual protocol, they give an example. I am understanding bits of the theory but not all of it, Here it is</p>
<ol>
<li>For a 4-party scheme, they prepare a graph state <span class=""math-container"">$$Z^{l_{12}}\otimes Z^{l_{22}}\otimes Z^{l_{32}}\otimes Z^{l_{42}} \left(|0+++\rangle+|1---\rangle\right)$$</span>, corresponding to this they have 4 stabilizers (generators) of the stabilizer group <span class=""math-container"">$K_1=XZZZ,K_2=ZXII,K_3=ZIXI,K_4=ZIIX$</span>, with eigenvalues <span class=""math-container"">$(l_{12},l_{22},l_{32},l_{42})$</span>.</li>
</ol>
<p>My first understanding about the eigenvalues is that <span class=""math-container"">$l_{i2}$</span> are eigenvalues because those are the indices (powers) where we have possible commuting issues between the <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> gate, so when they are zero the eigenvalues are <span class=""math-container"">$1$</span> and when they are <span class=""math-container"">$1$</span> they eigenvalues are <span class=""math-container"">$-1$</span>, and correspondingly the the graph states are orthogonal (since they correspond to different eigenvalues). Is my undertanding okay or atleast near okay? Shouldn't the eigenvalues be
<span class=""math-container"">$(-1)^{l_{i2}} \forall~i$</span>?</p>

",qc,quantum graph state paper query phy rev p authors paper graph states quantum secret sharing https nofollow noreferrer https define state span l i1 i2 g graph state define graph state span l 2 i2 say encoded graph state labeled graph state span 1i p span l i1 i2 vertex span l j 1j 2j nj span j th bit span n vertices span l l 1 l 2 l n span ij p framework try define secret sharing protocol however actual protocol give example understanding bits theory ol li scheme prepare graph state span 12 22 32 42 corresponding 4 stabilizers generators stabilizer group span eigenvalues span 12 22 32 42 p first understanding eigenvalues span i2 eigenvalues indices powers possible commuting issues span x span z gate zero eigenvalues span 1 span 1 eigenvalues span correspondingly graph states orthogonal since correspond different eigenvalues undertanding okay atleast near okay eigenvalues span i2,"[(3, 0.52357715), (5, 0.037364554), (6, 0.025895303), (9, 0.047989793), (11, 0.027972942), (12, 0.037462037), (13, 0.20842303), (18, 0.084229134)]"
18168,,2021-06-28 17:06:29,2,215,"<p>I'm trying to calculate the expectation value of some operator for a state that comes out of a quantum circuit using Qiskit. I was initially using <code>StatevectorSimulator</code>, but I also wanted to experiment with <code>QasmSimulator</code>. I Followed <a href=""https://quantumcomputing.stackexchange.com/questions/12080/evaluating-expectation-values-of-operators-in-qiskit"">this</a> answer in trying to calculate expectation values using <code>QasmSimulator</code>. However I noticed that <code>Qasmsimulator</code> is almost <span class=""math-container"">$40$</span> times slower than <code>StatevectorSimulator</code> for doing the same task. Here is a minimal code for comparison:</p>
<pre><code>import time 
from numpy import conjugate, pi
from qiskit import QuantumCircuit, transpile
from qiskit.providers.aer import QasmSimulator, StatevectorSimulator
from qiskit.utils import QuantumInstance
from qiskit.opflow import CircuitStateFn, PauliExpectation, CircuitSampler, StateFn
from qiskit.opflow import PauliOp, PauliSumOp
from qiskit.quantum_info import Pauli

# The details of the PauliOp and the quantum circuit I guess are irrelevant. 
# What follows is just an example of some operator (qubit_op) to calculate
# the expectation value for and a quantum circuit for enerating the statevector.

qubit_op = PauliOp(Pauli('IIZZIZZZ')) + PauliOp(Pauli('IIXXXZZX')) 
start = time.time()
qc = QuantumCircuit(8)
for i in range(4):
    for j in range(7): 
        qc.cx(j, j+1)
    qc.rz(pi/2, 7)
    for j in range(7)[::-1]: 
        qc.cx(j, j+1)
    qc.h([*range(8)])

qc = transpile(qc)  
print(f'time took to build the circuit: {time.time() - start}s')

start = time.time()
simulator = StatevectorSimulator()
result = simulator.run(qc).result()
psi = result.get_statevector()
qubit_mat = qubit_op.to_matrix()
qubit_op_ev = conjugate(psi.T) @ qubit_mat @ psi
t1 = time.time() - start
print(f'time to calculate expectation value using StatevectorSimulator: {round(t1, 4)}s')

start = time.time()
simulator = QasmSimulator()
QI = QuantumInstance(simulator, shots=1000)
psi = CircuitStateFn(qc)
ms = StateFn(qubit_op, is_measurement=True) @ psi
pe = PauliExpectation().convert(ms)
samp = CircuitSampler(QI).convert(pe).eval().real
t2 = time.time() - start
print(f'time to calculate expectation value using Qasmsimulator: {round(t2, 4)}s')

print(f'QasmSimulator is {t2/t1} times slower than StatevectorSimulator')
</code></pre>
<p>Running this code gives the following output:</p>
<pre><code>time took to build the circuit: 0.9908s
time to calculate expectation value using StatevectorSimulator: 0.0074s
time to calculate expectation value using Qasmsimulator: 0.2886s
QasmSimulator is 38.8306 times slower than StatevectorSimulator
</code></pre>
<p>It's somewhat surprising to me that <code>QasmSimulator</code> is that much slower (I would have thought it would be faster). So I guess I have two questions:</p>
<ol>
<li>Is this the expected behavior for <code>Qasmsimulator</code> to be slower?</li>
<li>If not, what is it I'm doing wrong?</li>
</ol>
","Is it true that QasmSimulator is much slower than StatevectorSimulator, or am I doing something wrong?",<programming><qiskit><qasm>,1,0,,,"Is it true that QasmSimulator is much slower than StatevectorSimulator, or am I doing something wrong? <p>I'm trying to calculate the expectation value of some operator for a state that comes out of a quantum circuit using Qiskit. I was initially using <code>StatevectorSimulator</code>, but I also wanted to experiment with <code>QasmSimulator</code>. I Followed <a href=""https://quantumcomputing.stackexchange.com/questions/12080/evaluating-expectation-values-of-operators-in-qiskit"">this</a> answer in trying to calculate expectation values using <code>QasmSimulator</code>. However I noticed that <code>Qasmsimulator</code> is almost <span class=""math-container"">$40$</span> times slower than <code>StatevectorSimulator</code> for doing the same task. Here is a minimal code for comparison:</p>
<pre><code>import time 
from numpy import conjugate, pi
from qiskit import QuantumCircuit, transpile
from qiskit.providers.aer import QasmSimulator, StatevectorSimulator
from qiskit.utils import QuantumInstance
from qiskit.opflow import CircuitStateFn, PauliExpectation, CircuitSampler, StateFn
from qiskit.opflow import PauliOp, PauliSumOp
from qiskit.quantum_info import Pauli

# The details of the PauliOp and the quantum circuit I guess are irrelevant. 
# What follows is just an example of some operator (qubit_op) to calculate
# the expectation value for and a quantum circuit for enerating the statevector.

qubit_op = PauliOp(Pauli('IIZZIZZZ')) + PauliOp(Pauli('IIXXXZZX')) 
start = time.time()
qc = QuantumCircuit(8)
for i in range(4):
    for j in range(7): 
        qc.cx(j, j+1)
    qc.rz(pi/2, 7)
    for j in range(7)[::-1]: 
        qc.cx(j, j+1)
    qc.h([*range(8)])

qc = transpile(qc)  
print(f'time took to build the circuit: {time.time() - start}s')

start = time.time()
simulator = StatevectorSimulator()
result = simulator.run(qc).result()
psi = result.get_statevector()
qubit_mat = qubit_op.to_matrix()
qubit_op_ev = conjugate(psi.T) @ qubit_mat @ psi
t1 = time.time() - start
print(f'time to calculate expectation value using StatevectorSimulator: {round(t1, 4)}s')

start = time.time()
simulator = QasmSimulator()
QI = QuantumInstance(simulator, shots=1000)
psi = CircuitStateFn(qc)
ms = StateFn(qubit_op, is_measurement=True) @ psi
pe = PauliExpectation().convert(ms)
samp = CircuitSampler(QI).convert(pe).eval().real
t2 = time.time() - start
print(f'time to calculate expectation value using Qasmsimulator: {round(t2, 4)}s')

print(f'QasmSimulator is {t2/t1} times slower than StatevectorSimulator')
</code></pre>
<p>Running this code gives the following output:</p>
<pre><code>time took to build the circuit: 0.9908s
time to calculate expectation value using StatevectorSimulator: 0.0074s
time to calculate expectation value using Qasmsimulator: 0.2886s
QasmSimulator is 38.8306 times slower than StatevectorSimulator
</code></pre>
<p>It's somewhat surprising to me that <code>QasmSimulator</code> is that much slower (I would have thought it would be faster). So I guess I have two questions:</p>
<ol>
<li>Is this the expected behavior for <code>Qasmsimulator</code> to be slower?</li>
<li>If not, what is it I'm doing wrong?</li>
</ol>
",qc,true qasmsimulator much slower statevectorsimulator something wrong p trying calculate expectation value operator state comes quantum circuit using qiskit initially using code statevectorsimulator also wanted experiment code qasmsimulator followed https answer trying calculate expectation values using code qasmsimulator however noticed code qasmsimulator almost span 40 times slower code statevectorsimulator task minimal code comparison pre code import time numpy import conjugate pi qiskit import quantumcircuit transpile import qasmsimulator statevectorsimulator import quantuminstance import circuitstatefn pauliexpectation circuitsampler statefn import pauliop paulisumop import pauli details pauliop quantum circuit guess irrelevant follows example operator calculate expectation value quantum circuit enerating statevector pauliop pauli pauliop pauli start qc quantumcircuit 8 range 4 j range 7 j 7 j range 7 j range 8 qc transpile qc print took build circuit start start simulator statevectorsimulator result qc psi conjugate psi t1 start print calculate expectation value using statevectorsimulator round t1 4 start simulator qasmsimulator qi quantuminstance simulator psi circuitstatefn qc ms statefn psi pe pauliexpectation ms samp circuitsampler qi pe t2 start print calculate expectation value using qasmsimulator round t2 4 print times slower statevectorsimulator p running code gives following output pre code time took build circuit time calculate expectation value using statevectorsimulator time calculate expectation value using qasmsimulator qasmsimulator times slower statevectorsimulator p somewhat surprising code qasmsimulator much slower would thought would faster guess two questions ol li expected behavior code qasmsimulator slower li wrong,"[(0, 0.6017825), (6, 0.032490242), (7, 0.024035634), (8, 0.08420686), (12, 0.018807022), (14, 0.23013055)]"
18280,,2021-07-05 01:15:52,0,90,"<p>Is there a corresponding function that has the same function as function <a href=""https://projectq.readthedocs.io/en/latest/_doc_gen/projectq.backends.html#projectq.backends.Simulator.get_expectation_value"" rel=""nofollow noreferrer"">get_expectation_value()</a> in Project Q?</p>
<blockquote>
<p>Get the expectation value of qubit_operator w.r.t. the current wave function representeenter preformatted text hered by the supplied quantum register.</p>
<p>Args:</p>
<ul>
<li>qubit_operator: Operator to measure.</li>
<li>qureg: Quantum bits to measure.</li>
</ul>
<p>Returns: Expectation value</p>
</blockquote>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer
import numpy as np
from qiskit.aqua import QuantumInstance
from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn, CircuitOp, CircuitStateFn

qctl = QuantumRegister(10)
psi = QuantumCircuit(qctl)
psi.h(0)
psi = CircuitStateFn(psi)

qctl = QuantumRegister(10)
op = QuantumCircuit(qctl)
op.z(0)
op.ry(np.pi/4,0)
op = CircuitOp(op)

backend = Aer.get_backend('qasm_simulator')
q_instance = QuantumInstance(backend, shots=1024)
measurable_expression = StateFn(op, is_measurement=True).compose(psi)
expectation = PauliExpectation().convert(measurable_expression)
sampler = CircuitSampler(q_instance).convert(expectation)
print('Expectation Value = ', sampler.eval())
</code></pre>
",Qiskit equivalent of get_expectation_value() in ProjectQ,<programming><qiskit><measurement>,0,4,,,"Qiskit equivalent of get_expectation_value() in ProjectQ <p>Is there a corresponding function that has the same function as function <a href=""https://projectq.readthedocs.io/en/latest/_doc_gen/projectq.backends.html#projectq.backends.Simulator.get_expectation_value"" rel=""nofollow noreferrer"">get_expectation_value()</a> in Project Q?</p>
<blockquote>
<p>Get the expectation value of qubit_operator w.r.t. the current wave function representeenter preformatted text hered by the supplied quantum register.</p>
<p>Args:</p>
<ul>
<li>qubit_operator: Operator to measure.</li>
<li>qureg: Quantum bits to measure.</li>
</ul>
<p>Returns: Expectation value</p>
</blockquote>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer
import numpy as np
from qiskit.aqua import QuantumInstance
from qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn, CircuitOp, CircuitStateFn

qctl = QuantumRegister(10)
psi = QuantumCircuit(qctl)
psi.h(0)
psi = CircuitStateFn(psi)

qctl = QuantumRegister(10)
op = QuantumCircuit(qctl)
op.z(0)
op.ry(np.pi/4,0)
op = CircuitOp(op)

backend = Aer.get_backend('qasm_simulator')
q_instance = QuantumInstance(backend, shots=1024)
measurable_expression = StateFn(op, is_measurement=True).compose(psi)
expectation = PauliExpectation().convert(measurable_expression)
sampler = CircuitSampler(q_instance).convert(expectation)
print('Expectation Value = ', sampler.eval())
</code></pre>
",qc,qiskit equivalent projectq p corresponding function function function https nofollow noreferrer project q blockquote p get expectation value current wave function representeenter preformatted text hered supplied quantum p args ul li operator li qureg quantum bits p returns expectation value pre code qiskit import quantumcircuit quantumregister classicalregister aer import numpy np import quantuminstance import pauliexpectation circuitsampler statefn circuitop circuitstatefn qctl quantumregister 10 psi quantumcircuit qctl 0 psi circuitstatefn psi qctl quantumregister 10 op quantumcircuit qctl 0 op circuitop op backend quantuminstance backend statefn op psi expectation pauliexpectation sampler circuitsampler expectation print value,"[(0, 0.77570885), (4, 0.04323668), (7, 0.055797383), (8, 0.082364425), (12, 0.040949143)]"
18493,18496.0,2021-07-19 08:52:13,1,343,"<p>I encountered a problem when learning from the <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html#varforms"" rel=""nofollow noreferrer"">qiskit tutorial</a> about solving electronic structure problem with VQE. Under the &quot;Running VQE on a Statevector Simulator&quot; part, the code provided for leveraging active space of LiH to reduce the qubit requirement seems quite confusing. The <code>freeze_list</code> in the code is interpreted as the core space in my opinion. However, what confuse me is that why to choose the [-3, -2] orbitals as virtual space to be removed (<code>remove_list</code>). Or the problem can be stated as why to choose [-3, -2] as the virtual space of the LiH molecule? The corresponding code of the tutorial is provide as below:</p>
<pre><code>def get_qubit_op(dist):
    driver = PySCFDriver(atom=&quot;Li .0 .0 .0; H .0 .0 &quot; + str(dist), unit=UnitsType.ANGSTROM, 
                         charge=0, spin=0, basis='sto3g')
    molecule = driver.run()
    freeze_list = [0]
    remove_list = [-3, -2]
    repulsion_energy = molecule.nuclear_repulsion_energy
    num_particles = molecule.num_alpha + molecule.num_beta
    num_spin_orbitals = molecule.num_orbitals * 2
    remove_list = [x % molecule.num_orbitals for x in remove_list]
    freeze_list = [x % molecule.num_orbitals for x in freeze_list]
    remove_list = [x - len(freeze_list) for x in remove_list]
    remove_list += [x + molecule.num_orbitals - len(freeze_list)  for x in remove_list]
    freeze_list += [x + molecule.num_orbitals for x in freeze_list]
    ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)
    ferOp, energy_shift = ferOp.fermion_mode_freezing(freeze_list)
    num_spin_orbitals -= len(freeze_list)
    num_particles -= len(freeze_list)
    ferOp = ferOp.fermion_mode_elimination(remove_list)
    num_spin_orbitals -= len(remove_list)
    qubitOp = ferOp.mapping(map_type='parity', threshold=0.00000001)
    qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
    shift = energy_shift + repulsion_energy
    return qubitOp, num_particles, num_spin_orbitals, shift
</code></pre>
",Active space chosen for VQE in qiskit,<qiskit><vqe>,1,0,,,"Active space chosen for VQE in qiskit <p>I encountered a problem when learning from the <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html#varforms"" rel=""nofollow noreferrer"">qiskit tutorial</a> about solving electronic structure problem with VQE. Under the &quot;Running VQE on a Statevector Simulator&quot; part, the code provided for leveraging active space of LiH to reduce the qubit requirement seems quite confusing. The <code>freeze_list</code> in the code is interpreted as the core space in my opinion. However, what confuse me is that why to choose the [-3, -2] orbitals as virtual space to be removed (<code>remove_list</code>). Or the problem can be stated as why to choose [-3, -2] as the virtual space of the LiH molecule? The corresponding code of the tutorial is provide as below:</p>
<pre><code>def get_qubit_op(dist):
    driver = PySCFDriver(atom=&quot;Li .0 .0 .0; H .0 .0 &quot; + str(dist), unit=UnitsType.ANGSTROM, 
                         charge=0, spin=0, basis='sto3g')
    molecule = driver.run()
    freeze_list = [0]
    remove_list = [-3, -2]
    repulsion_energy = molecule.nuclear_repulsion_energy
    num_particles = molecule.num_alpha + molecule.num_beta
    num_spin_orbitals = molecule.num_orbitals * 2
    remove_list = [x % molecule.num_orbitals for x in remove_list]
    freeze_list = [x % molecule.num_orbitals for x in freeze_list]
    remove_list = [x - len(freeze_list) for x in remove_list]
    remove_list += [x + molecule.num_orbitals - len(freeze_list)  for x in remove_list]
    freeze_list += [x + molecule.num_orbitals for x in freeze_list]
    ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)
    ferOp, energy_shift = ferOp.fermion_mode_freezing(freeze_list)
    num_spin_orbitals -= len(freeze_list)
    num_particles -= len(freeze_list)
    ferOp = ferOp.fermion_mode_elimination(remove_list)
    num_spin_orbitals -= len(remove_list)
    qubitOp = ferOp.mapping(map_type='parity', threshold=0.00000001)
    qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
    shift = energy_shift + repulsion_energy
    return qubitOp, num_particles, num_spin_orbitals, shift
</code></pre>
",qc,active space chosen vqe qiskit p encountered problem learning https varforms nofollow noreferrer qiskit tutorial solving electronic structure problem vqe quot running vqe statevector simulator quot part code provided leveraging active space lih reduce qubit requirement seems quite confusing code code interpreted core space opinion however confuse choose orbitals virtual space removed code problem stated choose virtual space lih molecule corresponding code tutorial provide pre code def dist driver pyscfdriver quot li h quot str dist molecule 0 2 x x x x x len x x len x x x ferop fermionicoperator ferop len len ferop len qubitop qubitop qubitop shift return qubitop shift,"[(0, 0.2996226), (3, 0.04462585), (4, 0.061425835), (7, 0.02853797), (8, 0.22263952), (10, 0.11948645), (12, 0.043047417), (17, 0.12628585), (19, 0.05322823)]"
18544,18545.0,2021-07-22 00:21:36,1,844,"<blockquote>
<p><span class=""math-container"">$$
\left| \psi_2 \right\rangle = \frac{1}{\sqrt{8}} \left( \left| 000 \right\rangle + \left| 001 \right\rangle + \left| 010 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 101 \right\rangle - \left| 110 \right\rangle + \left| 111 \right\rangle \right)$$</span></p>
<p>3.​ Perform the reflection around the average amplitude:</p>
<ol>
<li>Apply Hadamard gates to the qubits</li>
</ol>
<p><span class=""math-container"">$$\left| \psi_{3a} \right\rangle = \frac{1}{2} \left( \left| 000 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 111 \right\rangle \right)$$</span></p>
</blockquote>
<p>Can someone show me step-by-step how to apply Hadamard to <span class=""math-container"">$\psi_2\rangle$</span> to obtain <span class=""math-container"">$| \psi_{3a}\rangle$</span>?</p>
",Apply Hadamard gate to three-qubit state,<textbook-and-exercises><linear-algebra>,1,1,,,"Apply Hadamard gate to three-qubit state <blockquote>
<p><span class=""math-container"">$$
\left| \psi_2 \right\rangle = \frac{1}{\sqrt{8}} \left( \left| 000 \right\rangle + \left| 001 \right\rangle + \left| 010 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 101 \right\rangle - \left| 110 \right\rangle + \left| 111 \right\rangle \right)$$</span></p>
<p>3.​ Perform the reflection around the average amplitude:</p>
<ol>
<li>Apply Hadamard gates to the qubits</li>
</ol>
<p><span class=""math-container"">$$\left| \psi_{3a} \right\rangle = \frac{1}{2} \left( \left| 000 \right\rangle + \left| 011 \right\rangle + \left| 100 \right\rangle - \left| 111 \right\rangle \right)$$</span></p>
</blockquote>
<p>Can someone show me step-by-step how to apply Hadamard to <span class=""math-container"">$\psi_2\rangle$</span> to obtain <span class=""math-container"">$| \psi_{3a}\rangle$</span>?</p>
",qc,apply hadamard gate state blockquote p span 1 8 000 001 010 011 100 101 110 111 p perform reflection around average amplitude ol li apply hadamard gates qubits p span 3a 1 2 000 011 100 111 p someone show apply hadamard span obtain span 3a,"[(3, 0.18027109), (6, 0.11265445), (12, 0.043217637), (18, 0.6604655)]"
20692,,2021-08-02 17:10:08,2,186,"<p>I am trying to apply a non-unitary projector (see image) to my two-qubit quantum circuit using mid-circuit measurements.</p>
<p>$$
\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \
0 &amp; 1 &amp; 0 &amp; 0 \
0 &amp; 0 &amp; 1 &amp; 0 \
0 &amp; 0 &amp; 0 &amp; 0 \</p>
<p>\end{pmatrix}
$$</p>
<p>Since I am a bit stumped on whether I can apply this projector to qubits in the middle of the circuit, I am using conditional resets in the following way:</p>
<pre><code>    for i in range(1, t):
        #print ('Measuring ' + str(i) + ' times')
        #do not apply unitary if the outcome is |00&gt; (1000) or |11&gt; (0001)
        qRandWalk.measure(qlist,creg)
        qRandWalk.x(qlist[1]).c_if(creg,5) #resets 1001 (|01&gt;) to (1010) |00&gt;
        qRandWalk.x(qlist[1]).c_if(creg,10) #resets 0110 (|10&gt;) to (0101) |11&gt;
        qRandWalk.append(unitary_operator, qlist).c_if(creg,6) # 6 in binary is 0110, |10&gt;
        qRandWalk.append(unitary_operator, qlist).c_if(creg,9) #9 in binary is 1001, |01&gt;
    
</code></pre>
<p>I want to project the measured state onto a subspace, then append the unitary operator to the circuit depending on the measurement outcome. I am not sure whether that is what my current code is doing. Are there any other approaches I can take at the moment, running on QASM simulator?</p>
",Applying projectors with mid-circuit measurements,<programming><qiskit><measurement><projection-operator>,0,1,,,"Applying projectors with mid-circuit measurements <p>I am trying to apply a non-unitary projector (see image) to my two-qubit quantum circuit using mid-circuit measurements.</p>
<p>$$
\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \
0 &amp; 1 &amp; 0 &amp; 0 \
0 &amp; 0 &amp; 1 &amp; 0 \
0 &amp; 0 &amp; 0 &amp; 0 \</p>
<p>\end{pmatrix}
$$</p>
<p>Since I am a bit stumped on whether I can apply this projector to qubits in the middle of the circuit, I am using conditional resets in the following way:</p>
<pre><code>    for i in range(1, t):
        #print ('Measuring ' + str(i) + ' times')
        #do not apply unitary if the outcome is |00&gt; (1000) or |11&gt; (0001)
        qRandWalk.measure(qlist,creg)
        qRandWalk.x(qlist[1]).c_if(creg,5) #resets 1001 (|01&gt;) to (1010) |00&gt;
        qRandWalk.x(qlist[1]).c_if(creg,10) #resets 0110 (|10&gt;) to (0101) |11&gt;
        qRandWalk.append(unitary_operator, qlist).c_if(creg,6) # 6 in binary is 0110, |10&gt;
        qRandWalk.append(unitary_operator, qlist).c_if(creg,9) #9 in binary is 1001, |01&gt;
    
</code></pre>
<p>I want to project the measured state onto a subspace, then append the unitary operator to the circuit depending on the measurement outcome. I am not sure whether that is what my current code is doing. Are there any other approaches I can take at the moment, running on QASM simulator?</p>
",qc,applying projectors measurements p trying apply projector see image quantum circuit using p pmatrix 0 amp 0 amp 0 amp 0 0 amp 1 amp 0 amp 0 0 amp 0 amp 1 amp 0 0 amp 0 amp 0 amp 0 p pmatrix p since bit stumped whether apply projector qubits middle circuit using conditional resets following way pre code range 1 print str times apply unitary outcome gt 1000 gt 0001 qlist creg qlist 1 resets 1001 gt 1010 gt qlist 1 resets 0110 gt 0101 gt qlist 6 binary 0110 gt qlist 9 binary 1001 gt p want project measured state onto subspace append unitary operator circuit depending measurement outcome sure whether current code approaches take moment running qasm simulator,"[(0, 0.15479551), (2, 0.17922823), (3, 0.108762756), (4, 0.011546033), (6, 0.018069044), (12, 0.017976677), (14, 0.19127159), (15, 0.17086431), (18, 0.1465303)]"
20722,22106.0,2021-08-04 09:54:17,1,201,"<p>In pyGSTi in order to construct Randomized Benchmarking circuits, we first need to define a <code>pspec</code> object that contains information about the number of qubits, basis gates and gate availability.*</p>
<p>In the tutorial notebooks (<a href=""https://github.com/pyGSTio/pyGSTi/blob/master/jupyter_notebooks/Tutorials/algorithms/RB-DirectRB.ipynb"" rel=""nofollow noreferrer"">https://github.com/pyGSTio/pyGSTi/blob/master/jupyter_notebooks/Tutorials/algorithms/RB-DirectRB.ipynb</a>), they use a predefined gate dictionary for this, where each gate is called by a certain key (string) and it's value corresponds to the numpy array for the matrix representation of the gate. This does not seem to allow parametrized gates but if we want to characterize for example an ibmq device, then we would need a dictionary for continuously parametrized gates.</p>
<p>I would be really happy, if someone knows how to define a <code>pspec</code> object so that it corresponds to the device, I want run the experiments later on.</p>
<p>*(Interestingly the qubit topology doesn't play a role here, but the sampling algorithms for direct and mirror randomized benchmarking need to work with the topology of the device in order to achieve the desired sampling process of single- and two-qubit gate layers...)</p>
",Defining native gate dictionary in pyGSTi,<programming><quantum-gate><randomised-benchmarking>,1,0,,,"Defining native gate dictionary in pyGSTi <p>In pyGSTi in order to construct Randomized Benchmarking circuits, we first need to define a <code>pspec</code> object that contains information about the number of qubits, basis gates and gate availability.*</p>
<p>In the tutorial notebooks (<a href=""https://github.com/pyGSTio/pyGSTi/blob/master/jupyter_notebooks/Tutorials/algorithms/RB-DirectRB.ipynb"" rel=""nofollow noreferrer"">https://github.com/pyGSTio/pyGSTi/blob/master/jupyter_notebooks/Tutorials/algorithms/RB-DirectRB.ipynb</a>), they use a predefined gate dictionary for this, where each gate is called by a certain key (string) and it's value corresponds to the numpy array for the matrix representation of the gate. This does not seem to allow parametrized gates but if we want to characterize for example an ibmq device, then we would need a dictionary for continuously parametrized gates.</p>
<p>I would be really happy, if someone knows how to define a <code>pspec</code> object so that it corresponds to the device, I want run the experiments later on.</p>
<p>*(Interestingly the qubit topology doesn't play a role here, but the sampling algorithms for direct and mirror randomized benchmarking need to work with the topology of the device in order to achieve the desired sampling process of single- and two-qubit gate layers...)</p>
",qc,defining native gate dictionary pygsti p pygsti order construct randomized benchmarking circuits first need define code pspec object contains information number qubits basis gates gate availability p tutorial notebooks https nofollow noreferrer https use predefined gate dictionary gate called certain key string value corresponds numpy array matrix representation gate seem allow parametrized gates want characterize example ibmq device would need dictionary continuously parametrized p would really happy someone knows define code pspec object corresponds device want run experiments later p interestingly qubit topology play role sampling algorithms direct mirror randomized benchmarking need work topology device order achieve desired sampling process gate layers,"[(4, 0.02691947), (8, 0.03775184), (9, 0.100995794), (11, 0.0921724), (12, 0.010917204), (13, 0.04478468), (14, 0.68512034)]"
20749,20754.0,2021-08-06 04:12:30,2,193,"<p>I encountered the issue that when defining my customized excitation list in the UCC  algorithm, there was only one parameter. How to fix this so that the algorithm assign one parameter for each excitation defined? The code is as follow:</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.drivers import PySCFDriver, UnitsType, QMolecule, FermionicDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock, UCCSD, UCC
from qiskit_nature.transformers import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms.optimizers import L_BFGS_B, SPSA, AQGD, CG, ADAM, P_BFGS, SLSQP, NELDER_MEAD
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.circuit.library import TwoLocal, EfficientSU2
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
matplotlib.use('Agg')


driver = PySCFDriver(atom='H -1.9767, .0, 1.53054; \
                        O  .0, .0, .0; \
                        H 1.9767, .0, 1.53054;',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

at = ActiveSpaceTransformer(8, 5)
ft = FreezeCoreTransformer()

problem = ElectronicStructureProblem(driver, q_molecule_transformers=[ft, at])

# generate the second-quantized operators
second_q_ops = problem.second_q_ops()
main_op = second_q_ops[0]

num_particles = (problem.molecule_data_transformed.num_alpha,
                 problem.molecule_data_transformed.num_beta)

num_spin_orbitals = 2 * problem.molecule_data.num_molecular_orbitals
mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=True)
qubit_op = converter.convert(main_op, num_particles=num_particles)
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
# print(main_op)

def custom_excitation_list(num_spin_orbitals, num_particles):
   my_excitation_list = [((0, 2, 4, 6), (0 ,2, 4, 7), (0,2,5,6))]

   return my_excitation_list

circ = UCC(qubit_converter=converter, num_particles=num_particles, num_spin_orbitals=num_spin_orbitals, excitations=custom_excitation_list,  reps=1, initial_state=init_state)

print(circ.parameters)
<span class=""math-container"">```</span>
</code></pre>
",Define customized excitation for the unitary coupled-cluster (UCC) algorithm in qiskit,<programming><qiskit>,1,0,,,"Define customized excitation for the unitary coupled-cluster (UCC) algorithm in qiskit <p>I encountered the issue that when defining my customized excitation list in the UCC  algorithm, there was only one parameter. How to fix this so that the algorithm assign one parameter for each excitation defined? The code is as follow:</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.drivers import PySCFDriver, UnitsType, QMolecule, FermionicDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock, UCCSD, UCC
from qiskit_nature.transformers import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms.optimizers import L_BFGS_B, SPSA, AQGD, CG, ADAM, P_BFGS, SLSQP, NELDER_MEAD
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.circuit.library import TwoLocal, EfficientSU2
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
matplotlib.use('Agg')


driver = PySCFDriver(atom='H -1.9767, .0, 1.53054; \
                        O  .0, .0, .0; \
                        H 1.9767, .0, 1.53054;',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

at = ActiveSpaceTransformer(8, 5)
ft = FreezeCoreTransformer()

problem = ElectronicStructureProblem(driver, q_molecule_transformers=[ft, at])

# generate the second-quantized operators
second_q_ops = problem.second_q_ops()
main_op = second_q_ops[0]

num_particles = (problem.molecule_data_transformed.num_alpha,
                 problem.molecule_data_transformed.num_beta)

num_spin_orbitals = 2 * problem.molecule_data.num_molecular_orbitals
mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=True)
qubit_op = converter.convert(main_op, num_particles=num_particles)
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
# print(main_op)

def custom_excitation_list(num_spin_orbitals, num_particles):
   my_excitation_list = [((0, 2, 4, 6), (0 ,2, 4, 7), (0,2,5,6))]

   return my_excitation_list

circ = UCC(qubit_converter=converter, num_particles=num_particles, num_spin_orbitals=num_spin_orbitals, excitations=custom_excitation_list,  reps=1, initial_state=init_state)

print(circ.parameters)
<span class=""math-container"">```</span>
</code></pre>
",qc,define customized excitation unitary ucc algorithm qiskit p encountered issue defining customized excitation list ucc algorithm one parameter fix algorithm assign one parameter excitation defined code follow pre code qiskit import import numpy np operator imports import z x circuit imports import pyscfdriver unitstype qmolecule fermionicdriver import electronicstructureproblem import hartreefock uccsd ucc import freezecoretransformer activespacetransformer import groundstateeigensolver import eigenstateresult qiskit import aer import paritymapper jordanwignermapper import qubitconverter import spsa aqgd cg adam slsqp import vqe numpyminimumeigensolver import twolocal efficientsu2 import plt import matplotlib import driver pyscfdriver h h activespacetransformer 8 5 ft freezecoretransformer problem electronicstructureproblem driver ft generate operators 0 2 mapper jordanwignermapper converter qubitconverter hartreefock converter print def 0 2 4 6 0 4 7 return circ ucc print span,"[(0, 0.5968216), (2, 0.035492174), (3, 0.01869915), (6, 0.06287249), (8, 0.089778304), (10, 0.018089714), (12, 0.019856391), (14, 0.093794815), (17, 0.06351819)]"
20782,20847.0,2021-08-08 14:56:39,5,886,"<p>During the same minute as asking this question, I also asked <a href=""https://mattermodeling.stackexchange.com/q/6538/5"">this</a> at Matter Modeling SE.</p>
<p>In Qiskit, each qubit corrrespond to one spin orbital. For example, the <span class=""math-container"">$\text{N}_2$</span> molecule have 10 molecular orbitals, which correspond to 20 spin orbitals for <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> spins in <code>sto-3g</code> basis set. In my opinion, this is the case because the for each atom contained in the molecule, we need to account for the orbitals included, which are <code>1s</code>, <code>2s</code>, <code>2p</code> for the nitrogen atom. However, in this case, how could one deal with the molecular orbitals when one is in the situation as choosing the active space for the molecule?</p>
<p>Take the H2O molecule as an excample, according to the MO diagram <a href=""https://commons.wikimedia.org/wiki/File:H2O-MO-Diagram.svg"" rel=""nofollow noreferrer"">here</a>,  I would like to choose the 3a1 &amp; 1b1 orbital to be not in the active space. In this case, is the qiskit pakage (more specifically the PySCF driver) arrange the orbitals according to the MO orbitals so that I can just specify a list like [0,1,4,5] to be the active MO space assume that the organization is from down to up in this case?</p>
",Molecular orbitals in Qiskit,<qiskit><chemistry>,1,1,,,"Molecular orbitals in Qiskit <p>During the same minute as asking this question, I also asked <a href=""https://mattermodeling.stackexchange.com/q/6538/5"">this</a> at Matter Modeling SE.</p>
<p>In Qiskit, each qubit corrrespond to one spin orbital. For example, the <span class=""math-container"">$\text{N}_2$</span> molecule have 10 molecular orbitals, which correspond to 20 spin orbitals for <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> spins in <code>sto-3g</code> basis set. In my opinion, this is the case because the for each atom contained in the molecule, we need to account for the orbitals included, which are <code>1s</code>, <code>2s</code>, <code>2p</code> for the nitrogen atom. However, in this case, how could one deal with the molecular orbitals when one is in the situation as choosing the active space for the molecule?</p>
<p>Take the H2O molecule as an excample, according to the MO diagram <a href=""https://commons.wikimedia.org/wiki/File:H2O-MO-Diagram.svg"" rel=""nofollow noreferrer"">here</a>,  I would like to choose the 3a1 &amp; 1b1 orbital to be not in the active space. In this case, is the qiskit pakage (more specifically the PySCF driver) arrange the orbitals according to the MO orbitals so that I can just specify a list like [0,1,4,5] to be the active MO space assume that the organization is from down to up in this case?</p>
",qc,molecular orbitals qiskit p minute asking question also asked https matter modeling p qiskit qubit corrrespond one spin orbital example span n molecule 10 molecular orbitals correspond 20 spin orbitals span span spins code basis set opinion case atom contained molecule need account orbitals included code 1s code 2s code 2p nitrogen atom however case could one deal molecular orbitals one situation choosing active space molecule p take h2o molecule excample according mo diagram https nofollow noreferrer would like choose 3a1 amp 1b1 orbital active space case qiskit pakage specifically pyscf driver arrange orbitals according mo orbitals specify list like active mo space assume organization case,"[(3, 0.16744918), (4, 0.20008607), (7, 0.030957077), (8, 0.34356356), (12, 0.010207802), (14, 0.13577732), (15, 0.013627889), (17, 0.09706891)]"
20791,20793.0,2021-08-09 08:03:16,2,424,"<p>In 2019, Google claimed that they have achieved quantum supremacy/advantage with their 53 qubit quantum processor Sycamore. The paper is <a href=""https://doi.org/10.1038%2Fs41586-019-1666-5"" rel=""nofollow noreferrer"">here</a>. But I have not even been able to find what their algorithm is called. I know that is just a sampling problem. How would I go to create a similar sampling for a smaller circuit (say 5 qubits) using Qiskit?</p>
<p>I have checked this good 3-part series of questions <a href=""https://quantumcomputing.stackexchange.com/questions/8337/understanding-googles-quantum-supremacy-using-a-programmable-superconducting-p"">Understanding Google&#39;s “Quantum supremacy using a programmable superconducting processor” (Part 1): choice of gate set</a>. Yet I am still unable to understand from where to start. Does Qiskit have predetermined functions for this purpose? Especially on how would I go to confirm it out later? My key issue here is that I do not know the name of the algorithm so I only have Google experiment related sources.</p>
<p>I am not concerned with the issue that they may have achieved quantum supremacy or not.</p>
",Can Google Sycamore's benchmark for quantum supremacy be simulated on Qiskit?,<qiskit><google-sycamore>,1,0,,,"Can Google Sycamore's benchmark for quantum supremacy be simulated on Qiskit? <p>In 2019, Google claimed that they have achieved quantum supremacy/advantage with their 53 qubit quantum processor Sycamore. The paper is <a href=""https://doi.org/10.1038%2Fs41586-019-1666-5"" rel=""nofollow noreferrer"">here</a>. But I have not even been able to find what their algorithm is called. I know that is just a sampling problem. How would I go to create a similar sampling for a smaller circuit (say 5 qubits) using Qiskit?</p>
<p>I have checked this good 3-part series of questions <a href=""https://quantumcomputing.stackexchange.com/questions/8337/understanding-googles-quantum-supremacy-using-a-programmable-superconducting-p"">Understanding Google&#39;s “Quantum supremacy using a programmable superconducting processor” (Part 1): choice of gate set</a>. Yet I am still unable to understand from where to start. Does Qiskit have predetermined functions for this purpose? Especially on how would I go to confirm it out later? My key issue here is that I do not know the name of the algorithm so I only have Google experiment related sources.</p>
<p>I am not concerned with the issue that they may have achieved quantum supremacy or not.</p>
",qc,google sycamore benchmark quantum supremacy simulated qiskit p 2019 google claimed achieved quantum 53 qubit quantum processor sycamore paper https nofollow noreferrer even able find algorithm called know sampling problem would go create similar sampling smaller circuit say 5 qubits using qiskit p checked good series questions https understanding google 39 quantum supremacy using programmable superconducting processor part 1 choice gate set yet still unable understand start qiskit predetermined functions purpose especially would go confirm later key issue know name algorithm google experiment related p concerned issue may achieved quantum supremacy,"[(4, 0.10605123), (8, 0.49082202), (9, 0.22203861), (12, 0.011151759), (14, 0.16827244)]"
20798,20799.0,2021-08-09 16:17:15,1,91,"<p>I'm running a quantum simulation and want to obtain some information from a single shot of an experiment. Here's part of the code I'm working on:</p>
<pre><code>for i in range(Nshot):
    Expeb = []
    for measure_circuit in [circ_1, circ_2, circ_3, circ_4]:
        measure_circuit = transpile(measure_circuit,backend=backend,optimization_level=2,initial_layout = [1])
        counts = execute(measure_circuit, backend = backend, shots=1).result().get_counts()
        for output in ['0','1']:
            if output not in counts:
                counts[output] = 0
        expe = (counts['0'] - counts['1']) 
        Expeb.append(expe)
    Est = sum(x*y for x,y in zip(Expeb,[a,b,c,d]))
</code></pre>
<p>The code works on simulators, but it might take a very long time if <code>Nshot</code> gets large (Like 5000, I think that's because I generated a lot of circuits) and I submit the jobs to a quantum device. I wonder is there a way I can extract information (like making calculations for) a single shot but in a more efficient way? Thanks for the help!</p>
",Can I extract information from a single shot efficiently?,<programming><ibm-q-experience><simulation>,1,4,,,"Can I extract information from a single shot efficiently? <p>I'm running a quantum simulation and want to obtain some information from a single shot of an experiment. Here's part of the code I'm working on:</p>
<pre><code>for i in range(Nshot):
    Expeb = []
    for measure_circuit in [circ_1, circ_2, circ_3, circ_4]:
        measure_circuit = transpile(measure_circuit,backend=backend,optimization_level=2,initial_layout = [1])
        counts = execute(measure_circuit, backend = backend, shots=1).result().get_counts()
        for output in ['0','1']:
            if output not in counts:
                counts[output] = 0
        expe = (counts['0'] - counts['1']) 
        Expeb.append(expe)
    Est = sum(x*y for x,y in zip(Expeb,[a,b,c,d]))
</code></pre>
<p>The code works on simulators, but it might take a very long time if <code>Nshot</code> gets large (Like 5000, I think that's because I generated a lot of circuits) and I submit the jobs to a quantum device. I wonder is there a way I can extract information (like making calculations for) a single shot but in a more efficient way? Thanks for the help!</p>
",qc,extract information single shot efficiently p running quantum simulation want obtain information single shot experiment part code working pre code range nshot expeb transpile 1 counts execute backend backend output 0 1 output counts counts output 0 expe counts 0 counts 1 expe est sum x x zip expeb b c p code works simulators might take long time code nshot gets large like 5000 think generated lot circuits submit jobs quantum device wonder way extract information like making calculations single shot efficient way thanks help,"[(0, 0.10971854), (2, 0.08816288), (10, 0.027335351), (12, 0.012204127), (14, 0.76070756)]"
20827,,2021-08-12 15:50:30,1,145,"<p>After running this code:
<a href=""https://i.sstatic.net/vWKBi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/vWKBi.png"" alt=""enter image description here"" /></a></p>
<p>I have an error:</p>
<pre><code>KeyError Traceback (most recent call last) ~\anaconda3\lib\site-packages\pandas\core\indexes\base.py in get_loc(self, key, method, tolerance) 3079 try: -&gt; 3080 return self._engine.get_loc(casted_key) 3081 except KeyError as err:

pandas_libs\index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas_libs\index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas_libs\hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas_libs\hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: (0, 0)

The above exception was the direct cause of the following exception:

KeyError Traceback (most recent call last) in 3 penalty = num_assets # set parameter to scale the budget penalty term 4 ----&gt; 5 qubitOp, offset = portfolio.get_operator(mu, sigma, q, budget, penalty) 6 print (qubitOp, offset)

~\anaconda3\lib\site-packages\qiskit\finance\applications\ising\portfolio.py in get_operator(mu, sigma, q, budget, penalty) 80 zp[j_] = True 81 pauli_list.append([2 * sigma_z[i_, j_], Pauli((zp, xp))]) ---&gt; 82 offset += sigma_z[i_, i_] 83 84 return WeightedPauliOperator(paulis=pauli_list), offset

~\anaconda3\lib\site-packages\pandas\core\frame.py in getitem(self, key) 3022 if self.columns.nlevels &gt; 1: 3023 return self._getitem_multilevel(key) -&gt; 3024 indexer = self.columns.get_loc(key) 3025 if is_integer(indexer): 3026 indexer = [indexer]

~\anaconda3\lib\site-packages\pandas\core\indexes\base.py in get_loc(self, key, method, tolerance) 3080 return self._engine.get_loc(casted_key) 3081 except KeyError as err: -&gt; 3082 raise KeyError(key) from err 3083 3084 if tolerance is not None:

KeyError: (0, 0)
</code></pre>
<p>Anyone know how to fix it?</p>
",Qiskit Portfolio Optimization,<qiskit><optimization><quantum-computing-for-finance>,0,3,,,"Qiskit Portfolio Optimization <p>After running this code:
<a href=""https://i.sstatic.net/vWKBi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/vWKBi.png"" alt=""enter image description here"" /></a></p>
<p>I have an error:</p>
<pre><code>KeyError Traceback (most recent call last) ~\anaconda3\lib\site-packages\pandas\core\indexes\base.py in get_loc(self, key, method, tolerance) 3079 try: -&gt; 3080 return self._engine.get_loc(casted_key) 3081 except KeyError as err:

pandas_libs\index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas_libs\index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas_libs\hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas_libs\hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: (0, 0)

The above exception was the direct cause of the following exception:

KeyError Traceback (most recent call last) in 3 penalty = num_assets # set parameter to scale the budget penalty term 4 ----&gt; 5 qubitOp, offset = portfolio.get_operator(mu, sigma, q, budget, penalty) 6 print (qubitOp, offset)

~\anaconda3\lib\site-packages\qiskit\finance\applications\ising\portfolio.py in get_operator(mu, sigma, q, budget, penalty) 80 zp[j_] = True 81 pauli_list.append([2 * sigma_z[i_, j_], Pauli((zp, xp))]) ---&gt; 82 offset += sigma_z[i_, i_] 83 84 return WeightedPauliOperator(paulis=pauli_list), offset

~\anaconda3\lib\site-packages\pandas\core\frame.py in getitem(self, key) 3022 if self.columns.nlevels &gt; 1: 3023 return self._getitem_multilevel(key) -&gt; 3024 indexer = self.columns.get_loc(key) 3025 if is_integer(indexer): 3026 indexer = [indexer]

~\anaconda3\lib\site-packages\pandas\core\indexes\base.py in get_loc(self, key, method, tolerance) 3080 return self._engine.get_loc(casted_key) 3081 except KeyError as err: -&gt; 3082 raise KeyError(key) from err 3083 3084 if tolerance is not None:

KeyError: (0, 0)
</code></pre>
<p>Anyone know how to fix it?</p>
",qc,qiskit portfolio optimization p running code https nofollow noreferrer img https enter image description p error pre code keyerror traceback recent call last self key method tolerance 3079 try gt 3080 return 3081 except keyerror err keyerror 0 0 exception direct cause following exception keyerror traceback recent call last 3 penalty set parameter scale budget penalty term 4 gt 5 qubitop offset mu sigma q budget penalty 6 print qubitop offset mu sigma q budget penalty 80 zp true 81 2 pauli zp xp gt 82 offset 83 84 return weightedpaulioperator offset getitem self key 3022 gt 1 3023 return key gt 3024 indexer key 3025 indexer 3026 indexer indexer self key method tolerance 3080 return 3081 except keyerror err gt 3082 raise keyerror key err 3083 3084 tolerance none keyerror 0 0 p anyone know fix,"[(0, 0.65314806), (4, 0.091447964), (6, 0.13755746), (10, 0.040974196), (11, 0.041814983), (12, 0.027122248)]"
20845,20848.0,2021-08-15 19:04:58,9,577,"<h1>Question</h1>
<p>Consider two single qubit states <span class=""math-container"">$\left\{|\alpha_0\rangle,|\alpha_1\rangle\right\}$</span> which are not orthogonal or parallel, i.e. <span class=""math-container"">$\left|\langle\alpha_0|\alpha_1\rangle\right|\ne0,1$</span>. Additionally, consider the unitary operation: <span class=""math-container"">$U|\alpha_i\rangle|0\rangle=|c_{ii}\rangle\forall i\in\left\{0,1\right\}$</span>; where we want <span class=""math-container"">$|c_{ii}\rangle$</span> to approximate <span class=""math-container"">$|\alpha_i\rangle|\alpha_i\rangle$</span>, i.e. approximate cloning - note that <span class=""math-container"">$|c_{ii}\rangle\ne|\alpha_i\rangle|\alpha_i\rangle\forall i$</span> due to the no-cloning theorem. We can define the fidelity <span class=""math-container"">$F_i\equiv\left|\langle\alpha_i|\langle\alpha_i|c_{ii}\rangle\right|^2$</span> as a measure of the quality of the approximation such that the best approximation is given by maximising <span class=""math-container"">$F_i$</span> with respect to <span class=""math-container"">$|c_{ii}\rangle$</span> subject to the following constraints:</p>
<ol>
<li><span class=""math-container"">$|c_{ii}\rangle\in\operatorname{span}\left\{|\alpha_j\rangle|\alpha_j\rangle\right\}$</span></li>
<li><span class=""math-container"">$|\alpha_i\rangle|0\rangle\to|c_{ii}\rangle\forall i$</span> is unitary <span class=""math-container"">$\iff\langle\alpha_i|\alpha_j\rangle=\langle c_{ii}|c_{jj}\rangle\forall i,j$</span></li>
<li><span class=""math-container"">$F=F_0=F_1$</span></li>
</ol>
<p>Contraint 1 allows us to express:</p>
<p><span class=""math-container"">$$|c_{ii}\rangle\equiv\sum_ja_{ji}|\alpha_j\rangle|\alpha_j\rangle$$</span></p>
<p>Now if we let <span class=""math-container"">$A_{ij}=\langle\alpha_i|\alpha_j\rangle$</span> then constraint 2 can be expressed as:</p>
<p><span class=""math-container"">$$\boldsymbol A=\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a$$</span></p>
<p>where <span class=""math-container"">$\boldsymbol A^{\circ 2}$</span> is the Hadamard power i.e. <span class=""math-container"">$\left[\boldsymbol A^{\circ 2}\right]_{ij}\equiv A_{ij}^2$</span>. In this notation we can also express <span class=""math-container"">$F_i=\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2$</span>.</p>
<p>We have already applied constraint 1 in the notation used leaving both constraints 2 and 3 to be applied.</p>
<p>As far as I see the problem of finding the values of <span class=""math-container"">$|c_{ii}\rangle$</span> that maximise <span class=""math-container"">$F$</span> from here can then be solved in one of three ways - each of which I have tried with no luck. I would be very grateful if someone was able to outline a solution for complex <span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span>. However, if no elegant solution for <span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span> then a solution for <span class=""math-container"">$\boldsymbol a\in\mathbb R^{2\times2}$</span> where <span class=""math-container"">$|\alpha_i\rangle$</span> can be expressed in terms of <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> with only real coefficients would suffice to be accepted as the correct answer. I know there should be an elegant solution for <span class=""math-container"">$\boldsymbol a\in\mathbb R^{2\times2}$</span> as this was what was asked on a problem sheet I have been using for some self-learning, but I am interested in the more general solution <span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span> if possible.</p>
<p>Finally, while I am an avid StackExchange user, this is my first post on Quantum Computing StackExchange and so I apologise if I have broken any site-specific rules and please do let me know. Additionally, if the moderators feel this is more appropriate for either Physics or Maths SE do migrate.</p>
<hr />
<h1>Attempts</h1>
<p>Below I will outline three of my attempted methods in case these are of any help.</p>
<p><span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span> has 8 degrees of freedom, but as <span class=""math-container"">$F_i$</span> is independent of an overall phase factor the degrees of freedom reduce to 7 and we can express:</p>
<p><span class=""math-container"">$$\boldsymbol a\equiv a\begin{bmatrix}1&amp;be^{i\beta}\\ce^{i\gamma}&amp;de^{i\delta}\end{bmatrix}$$</span></p>
<p>Using the method of Lagrange multipliers with a matrix constraint we must maximise:</p>
<p><span class=""math-container"">$$L_i\equiv\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2+\operatorname{Tr}\left(\boldsymbol \mu\left[\boldsymbol A-\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\right]\right)+\lambda\left(\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2-\left|\left[\boldsymbol A\boldsymbol a\right]_{\overline{ii}}\right|^2\right)\quad\forall i$$</span></p>
<p>where <span class=""math-container"">$\boldsymbol\mu\in\mathbb C^{2\times2}$</span> and <span class=""math-container"">$\lambda\in\mathbb C$</span> are the lagrange multipliers; and <span class=""math-container"">$\overline i\equiv\begin{cases}0,&amp;i=1\\1,&amp;i=0\end{cases}$</span>. Thus,</p>
<p><span class=""math-container"">$$\text{d}L_i=\left(1+\lambda\right)\left(\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{A\text{d}a}\vec\pi_i+\vec\pi_i^\dagger\text{d}\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{Aa}\vec\pi_i\right)-\operatorname{Tr}\left(\boldsymbol{\mu a}^\dagger\boldsymbol A^{\circ2}\text{d}\boldsymbol a\right)-\operatorname{Tr}\left(\text{d}\boldsymbol a^\dagger\boldsymbol A^{\circ2}\boldsymbol{a\mu}\right)-\lambda\left(\vec\pi_\overline{i}^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_\overline{i}\vec\pi_\overline{i}^\dagger\boldsymbol{A\text{d}a}\vec\pi_\overline{i}+\vec\pi_\overline{i}^\dagger\text{d}\boldsymbol a^\dagger\boldsymbol A\vec\pi_\overline{i}\vec\pi_\overline{i}^\dagger\boldsymbol{Aa}\vec\pi_\overline{i}\right)$$</span></p>
<p>As <span class=""math-container"">$\left\{\text{d}\boldsymbol a\vec\pi_i,\vec\pi_i^\dagger\text{d}\boldsymbol a^\dagger\middle|\forall i\right\}$</span> are independent variables and <span class=""math-container"">$\operatorname{Tr}\left(\boldsymbol M\right)\equiv\sum_i\vec\pi_i^\dagger\boldsymbol M\vec\pi_i$</span> then for <span class=""math-container"">$\text{d}L_i=0$</span> the simultaneous equations are:</p>
<p><span class=""math-container"">$$\begin{cases}\left(\delta_{ij}\left(1+2\lambda\right)-\lambda\right)\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol A-\pi_i^\dagger\boldsymbol{\mu a}^\dagger\boldsymbol A^{\circ2}=0&amp;\forall i,j\\\left(\delta_{ij}\left(1+2\lambda\right)-\lambda\right)\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{Aa}\vec\pi_i-\boldsymbol A^{\circ2}\boldsymbol{a\mu}\vec\pi_i=0&amp;\forall i,j\\\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{A\text{d}a}\vec\pi_i=F&amp;\forall i\\\boldsymbol A=\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\end{cases}$$</span></p>
<p>This gives <span class=""math-container"">$\lambda=-\frac{1}{2}$</span> and so:</p>
<p><span class=""math-container"">$$\begin{cases}\frac{1}{2}\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol A-\pi_i^\dagger\boldsymbol{\mu a}^\dagger\boldsymbol A^{\circ2}=0&amp;\forall i\\\frac{1}{2}\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{Aa}\vec\pi_i-\boldsymbol A^{\circ2}\boldsymbol{a\mu}\vec\pi_i=0&amp;\forall i\\\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{A\text{d}a}\vec\pi_i=F&amp;\forall i\\\boldsymbol A=\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\end{cases}$$</span></p>
<p>Then we can easily see that <span class=""math-container"">$F=\vec\pi_i^\dagger\boldsymbol{A\mu}\vec\pi_i=\vec\pi_i^\dagger\boldsymbol{\mu A}\vec\pi_i$</span> for all <span class=""math-container"">$i$</span>. However, I do not know how I would proceed further than this.</p>
<p>Another approach would be to use constraint 3 to reduce the degrees of freedom to 6 by showing:</p>
<p><span class=""math-container"">$$de^{i\delta}=-\alpha^*be^{i\beta}+\left|1+\alpha ce^{i\gamma}\right|e^{i\epsilon}$$</span></p>
<p>where <span class=""math-container"">$\alpha\equiv\langle\alpha_0|\alpha_1\rangle$</span>. Now our remaining degrees of freedom are <span class=""math-container"">$\left\{a,b,c,\beta,\gamma,\epsilon\right\}$</span> and we need only maximise:</p>
<p><span class=""math-container"">$$L_i'\equiv\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2+\operatorname{Tr}\left(\boldsymbol \mu\left[\boldsymbol A-\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\right]\right)\quad\forall i$$</span></p>
<p>I won't write out the resulting simultaneous equations again as this time they are more involved as the reduction in degrees of freedom means <span class=""math-container"">$\left\{\text{d}\boldsymbol a\vec\pi_i,\vec\pi_i^\dagger\text{d}\boldsymbol a^\dagger\middle|\forall i\right\}$</span> are not all independent degrees of freedom.</p>
<p>Or finally, we could apply both constraints 2 and 3 before maximising; however, I have not managed to navigate my way through the swamp of simultaneous equations for this but in this case, we now only need to maximise <span class=""math-container"">$F$</span> with respect to the remaining degrees of freedom.</p>
<p>Now I have in all three cases managed to find the conditions under which these are maximised; however, I then have been struggling to solve the resulting simultaneous equations.</p>
",Approximate Cloning,<fidelity><no-cloning-theorem><cloning>,1,0,,,"Approximate Cloning <h1>Question</h1>
<p>Consider two single qubit states <span class=""math-container"">$\left\{|\alpha_0\rangle,|\alpha_1\rangle\right\}$</span> which are not orthogonal or parallel, i.e. <span class=""math-container"">$\left|\langle\alpha_0|\alpha_1\rangle\right|\ne0,1$</span>. Additionally, consider the unitary operation: <span class=""math-container"">$U|\alpha_i\rangle|0\rangle=|c_{ii}\rangle\forall i\in\left\{0,1\right\}$</span>; where we want <span class=""math-container"">$|c_{ii}\rangle$</span> to approximate <span class=""math-container"">$|\alpha_i\rangle|\alpha_i\rangle$</span>, i.e. approximate cloning - note that <span class=""math-container"">$|c_{ii}\rangle\ne|\alpha_i\rangle|\alpha_i\rangle\forall i$</span> due to the no-cloning theorem. We can define the fidelity <span class=""math-container"">$F_i\equiv\left|\langle\alpha_i|\langle\alpha_i|c_{ii}\rangle\right|^2$</span> as a measure of the quality of the approximation such that the best approximation is given by maximising <span class=""math-container"">$F_i$</span> with respect to <span class=""math-container"">$|c_{ii}\rangle$</span> subject to the following constraints:</p>
<ol>
<li><span class=""math-container"">$|c_{ii}\rangle\in\operatorname{span}\left\{|\alpha_j\rangle|\alpha_j\rangle\right\}$</span></li>
<li><span class=""math-container"">$|\alpha_i\rangle|0\rangle\to|c_{ii}\rangle\forall i$</span> is unitary <span class=""math-container"">$\iff\langle\alpha_i|\alpha_j\rangle=\langle c_{ii}|c_{jj}\rangle\forall i,j$</span></li>
<li><span class=""math-container"">$F=F_0=F_1$</span></li>
</ol>
<p>Contraint 1 allows us to express:</p>
<p><span class=""math-container"">$$|c_{ii}\rangle\equiv\sum_ja_{ji}|\alpha_j\rangle|\alpha_j\rangle$$</span></p>
<p>Now if we let <span class=""math-container"">$A_{ij}=\langle\alpha_i|\alpha_j\rangle$</span> then constraint 2 can be expressed as:</p>
<p><span class=""math-container"">$$\boldsymbol A=\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a$$</span></p>
<p>where <span class=""math-container"">$\boldsymbol A^{\circ 2}$</span> is the Hadamard power i.e. <span class=""math-container"">$\left[\boldsymbol A^{\circ 2}\right]_{ij}\equiv A_{ij}^2$</span>. In this notation we can also express <span class=""math-container"">$F_i=\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2$</span>.</p>
<p>We have already applied constraint 1 in the notation used leaving both constraints 2 and 3 to be applied.</p>
<p>As far as I see the problem of finding the values of <span class=""math-container"">$|c_{ii}\rangle$</span> that maximise <span class=""math-container"">$F$</span> from here can then be solved in one of three ways - each of which I have tried with no luck. I would be very grateful if someone was able to outline a solution for complex <span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span>. However, if no elegant solution for <span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span> then a solution for <span class=""math-container"">$\boldsymbol a\in\mathbb R^{2\times2}$</span> where <span class=""math-container"">$|\alpha_i\rangle$</span> can be expressed in terms of <span class=""math-container"">$|0\rangle$</span> and <span class=""math-container"">$|1\rangle$</span> with only real coefficients would suffice to be accepted as the correct answer. I know there should be an elegant solution for <span class=""math-container"">$\boldsymbol a\in\mathbb R^{2\times2}$</span> as this was what was asked on a problem sheet I have been using for some self-learning, but I am interested in the more general solution <span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span> if possible.</p>
<p>Finally, while I am an avid StackExchange user, this is my first post on Quantum Computing StackExchange and so I apologise if I have broken any site-specific rules and please do let me know. Additionally, if the moderators feel this is more appropriate for either Physics or Maths SE do migrate.</p>
<hr />
<h1>Attempts</h1>
<p>Below I will outline three of my attempted methods in case these are of any help.</p>
<p><span class=""math-container"">$\boldsymbol a\in\mathbb C^{2\times2}$</span> has 8 degrees of freedom, but as <span class=""math-container"">$F_i$</span> is independent of an overall phase factor the degrees of freedom reduce to 7 and we can express:</p>
<p><span class=""math-container"">$$\boldsymbol a\equiv a\begin{bmatrix}1&amp;be^{i\beta}\\ce^{i\gamma}&amp;de^{i\delta}\end{bmatrix}$$</span></p>
<p>Using the method of Lagrange multipliers with a matrix constraint we must maximise:</p>
<p><span class=""math-container"">$$L_i\equiv\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2+\operatorname{Tr}\left(\boldsymbol \mu\left[\boldsymbol A-\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\right]\right)+\lambda\left(\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2-\left|\left[\boldsymbol A\boldsymbol a\right]_{\overline{ii}}\right|^2\right)\quad\forall i$$</span></p>
<p>where <span class=""math-container"">$\boldsymbol\mu\in\mathbb C^{2\times2}$</span> and <span class=""math-container"">$\lambda\in\mathbb C$</span> are the lagrange multipliers; and <span class=""math-container"">$\overline i\equiv\begin{cases}0,&amp;i=1\\1,&amp;i=0\end{cases}$</span>. Thus,</p>
<p><span class=""math-container"">$$\text{d}L_i=\left(1+\lambda\right)\left(\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{A\text{d}a}\vec\pi_i+\vec\pi_i^\dagger\text{d}\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{Aa}\vec\pi_i\right)-\operatorname{Tr}\left(\boldsymbol{\mu a}^\dagger\boldsymbol A^{\circ2}\text{d}\boldsymbol a\right)-\operatorname{Tr}\left(\text{d}\boldsymbol a^\dagger\boldsymbol A^{\circ2}\boldsymbol{a\mu}\right)-\lambda\left(\vec\pi_\overline{i}^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_\overline{i}\vec\pi_\overline{i}^\dagger\boldsymbol{A\text{d}a}\vec\pi_\overline{i}+\vec\pi_\overline{i}^\dagger\text{d}\boldsymbol a^\dagger\boldsymbol A\vec\pi_\overline{i}\vec\pi_\overline{i}^\dagger\boldsymbol{Aa}\vec\pi_\overline{i}\right)$$</span></p>
<p>As <span class=""math-container"">$\left\{\text{d}\boldsymbol a\vec\pi_i,\vec\pi_i^\dagger\text{d}\boldsymbol a^\dagger\middle|\forall i\right\}$</span> are independent variables and <span class=""math-container"">$\operatorname{Tr}\left(\boldsymbol M\right)\equiv\sum_i\vec\pi_i^\dagger\boldsymbol M\vec\pi_i$</span> then for <span class=""math-container"">$\text{d}L_i=0$</span> the simultaneous equations are:</p>
<p><span class=""math-container"">$$\begin{cases}\left(\delta_{ij}\left(1+2\lambda\right)-\lambda\right)\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol A-\pi_i^\dagger\boldsymbol{\mu a}^\dagger\boldsymbol A^{\circ2}=0&amp;\forall i,j\\\left(\delta_{ij}\left(1+2\lambda\right)-\lambda\right)\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{Aa}\vec\pi_i-\boldsymbol A^{\circ2}\boldsymbol{a\mu}\vec\pi_i=0&amp;\forall i,j\\\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{A\text{d}a}\vec\pi_i=F&amp;\forall i\\\boldsymbol A=\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\end{cases}$$</span></p>
<p>This gives <span class=""math-container"">$\lambda=-\frac{1}{2}$</span> and so:</p>
<p><span class=""math-container"">$$\begin{cases}\frac{1}{2}\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol A-\pi_i^\dagger\boldsymbol{\mu a}^\dagger\boldsymbol A^{\circ2}=0&amp;\forall i\\\frac{1}{2}\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{Aa}\vec\pi_i-\boldsymbol A^{\circ2}\boldsymbol{a\mu}\vec\pi_i=0&amp;\forall i\\\vec\pi_i^\dagger\boldsymbol a^\dagger\boldsymbol A\vec\pi_i\vec\pi_i^\dagger\boldsymbol{A\text{d}a}\vec\pi_i=F&amp;\forall i\\\boldsymbol A=\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\end{cases}$$</span></p>
<p>Then we can easily see that <span class=""math-container"">$F=\vec\pi_i^\dagger\boldsymbol{A\mu}\vec\pi_i=\vec\pi_i^\dagger\boldsymbol{\mu A}\vec\pi_i$</span> for all <span class=""math-container"">$i$</span>. However, I do not know how I would proceed further than this.</p>
<p>Another approach would be to use constraint 3 to reduce the degrees of freedom to 6 by showing:</p>
<p><span class=""math-container"">$$de^{i\delta}=-\alpha^*be^{i\beta}+\left|1+\alpha ce^{i\gamma}\right|e^{i\epsilon}$$</span></p>
<p>where <span class=""math-container"">$\alpha\equiv\langle\alpha_0|\alpha_1\rangle$</span>. Now our remaining degrees of freedom are <span class=""math-container"">$\left\{a,b,c,\beta,\gamma,\epsilon\right\}$</span> and we need only maximise:</p>
<p><span class=""math-container"">$$L_i'\equiv\left|\left[\boldsymbol A\boldsymbol a\right]_{ii}\right|^2+\operatorname{Tr}\left(\boldsymbol \mu\left[\boldsymbol A-\boldsymbol a^\dagger\boldsymbol A^{\circ 2}\boldsymbol a\right]\right)\quad\forall i$$</span></p>
<p>I won't write out the resulting simultaneous equations again as this time they are more involved as the reduction in degrees of freedom means <span class=""math-container"">$\left\{\text{d}\boldsymbol a\vec\pi_i,\vec\pi_i^\dagger\text{d}\boldsymbol a^\dagger\middle|\forall i\right\}$</span> are not all independent degrees of freedom.</p>
<p>Or finally, we could apply both constraints 2 and 3 before maximising; however, I have not managed to navigate my way through the swamp of simultaneous equations for this but in this case, we now only need to maximise <span class=""math-container"">$F$</span> with respect to the remaining degrees of freedom.</p>
<p>Now I have in all three cases managed to find the conditions under which these are maximised; however, I then have been struggling to solve the resulting simultaneous equations.</p>
",qc,approximate cloning h1 question p consider two single qubit states span orthogonal parallel span additionally consider unitary operation span ii want span ii approximate span approximate cloning note span ii due theorem define fidelity span ii measure quality approximation best approximation given maximising span respect span ii subject following constraints ol li span ii span li span ii unitary span ii jj j li span p contraint 1 allows us express p span ii ji p let span ij constraint 2 expressed p span 2 p span 2 hadamard power span 2 ij ij notation also express span ii p already applied constraint 1 notation used leaving constraints 2 3 p far see problem finding values span ii maximise span f solved one three ways tried luck would grateful someone able outline solution complex span however elegant solution span solution span span expressed terms span span real coefficients would suffice accepted correct answer know elegant solution span asked problem sheet using interested general solution span p finally avid stackexchange user first post quantum computing stackexchange apologise broken rules please let know additionally moderators feel appropriate either physics maths se hr h1 attempts p outline three attempted methods case p span 8 degrees freedom span independent overall phase factor degrees freedom reduce 7 express p span bmatrix 1 amp amp bmatrix p using method lagrange multipliers matrix constraint must maximise p span ii tr 2 ii ii p span span c lagrange multipliers span cases 0 amp amp cases thus p span aa tr tr aa p span independent variables span tr span simultaneous equations p span cases ij amp ij aa amp amp 2 cases p gives span 1 2 p span cases 1 2 amp 1 2 aa amp amp 2 cases p easily see span span however know would proceed p another approach would use constraint 3 reduce degrees freedom 6 showing p span p span remaining degrees freedom span b c need maximise p span ii tr 2 p wo write resulting simultaneous equations time involved reduction degrees freedom means span independent degrees p finally could apply constraints 2 3 maximising however managed navigate way swamp simultaneous equations case need maximise span f respect remaining degrees p three cases managed find conditions maximised however struggling solve resulting simultaneous,"[(1, 0.031635948), (2, 0.052357845), (3, 0.62979454), (6, 0.010543468), (7, 0.0848759), (9, 0.072759815), (11, 0.012733789), (12, 0.012171527), (13, 0.021927807), (15, 0.051348526)]"
21001,21010.0,2021-08-28 19:51:23,2,153,"<p>In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, <code>%simulate</code>, and writes out the inputs as key-value pairs, <code>key=value</code>.</p>
<p>For example, if I had some operation, operation <code>HelloHardy (number : Int) : Unit {...}</code>, then I would run the following <code>%simulate HelloHardy number=1729</code>.</p>
<p>I am currently working with the operation, <code>EvaluatePolynomial</code>, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated.</p>
<pre><code>%simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false.

Received invalid parameters. Please fix and try again:

 coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.

 evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.
</code></pre>
",Passing arrays to operations/functions in Q# Jupyter Notebooks,<programming><q#>,1,0,,,"Passing arrays to operations/functions in Q# Jupyter Notebooks <p>In order to pass inputs to Q# operations/functions with Jupyter Notebooks, one uses the magic command, <code>%simulate</code>, and writes out the inputs as key-value pairs, <code>key=value</code>.</p>
<p>For example, if I had some operation, operation <code>HelloHardy (number : Int) : Unit {...}</code>, then I would run the following <code>%simulate HelloHardy number=1729</code>.</p>
<p>I am currently working with the operation, <code>EvaluatePolynomial</code>, which is part of the numerics library and takes in integers, arrays of doubles, and booleans. Below is what I am running and the error message that is generated.</p>
<pre><code>%simulate EvaluatePolynomial coefficients=[1.0,1.0] evaluationPoints=[0.0,1.0] numBits=3 pointPos=3 odd=true even=false.

Received invalid parameters. Please fix and try again:

 coefficients: Error converting value &quot;[1.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.

 evaluationPoints: Error converting value &quot;[0.0,1.0]&quot; to type 'System.Collections.Generic.List`1[System.Double]'. Path '', line 1, position 11.
</code></pre>
",qc,passing arrays q jupyter notebooks p order pass inputs q jupyter notebooks one uses magic command code simulate writes inputs pairs code p example operation operation code hellohardy number int unit would run following code simulate hellohardy p currently working operation code evaluatepolynomial part numerics library takes integers arrays doubles booleans running error message pre code simulate evaluatepolynomial received invalid parameters please fix try coefficients error converting value quot quot type 1 path line 1 position evaluationpoints error converting value quot quot type 1 path line 1 position 11,"[(0, 0.35877362), (2, 0.027157994), (3, 0.04288801), (5, 0.035086203), (6, 0.017649058), (12, 0.024476023), (14, 0.39224973), (16, 0.034302045), (19, 0.06609276)]"
21071,,2021-09-04 05:10:52,0,103,"<p>[I am just transferring this from Stack Overflow.  It might need editing.]</p>
<p>————</p>
<p>[The reader can skip to “It all sounds fine…”, before the spreadsheet representation.]</p>
<p>I am trying to figure out quantum computing from YouTube videos, and pdf’s from universities, and odd bits here and there.</p>
<p>I have been confident that the two values in any q-bit must add to 1 — that is, their squares must.</p>
<p>Pertinent (or related) to Grover’s Algorithm, I have been trying to figure out the procedure for multiplying [i.e. increasing] the amplitude of the one q-bit, relative to the others.  (I mostly follow the trigonometry; it is the matrix side I am having trouble with… mostly because I am having trouble getting a handle on the syntax of the algebra.)</p>
<p>(I have been working from the following page.)<br />
<a href=""https://drive.google.com/file/d/14G_0TwdxBFpI_Ylj5lb_imVtcnunrQcB/view"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/14G_0TwdxBFpI_Ylj5lb_imVtcnunrQcB/view</a></p>
<p>I think I understand the “reflection around |0〉” part — just flip the sign on the p[robability]|1〉 part.</p>
<p>(Incidentally, I take it that the pertinent q-bits still add to 1, through ignoring their signs?)</p>
<p>That leaves the “reflection around |ψ〉” part.  I have just found an account that is meaningful to me (rightly or wrongly!), on this page (straddling pp5 and 6).<br />
<a href=""https://theory.epfl.ch/courses/topicstcs/Lecture112016.pdf"" rel=""nofollow noreferrer"">https://theory.epfl.ch/courses/topicstcs/Lecture112016.pdf</a></p>
<p>If I understand correctly, it says that one  • applies a Hadamard Gate,  • reflects around |0〉 (as above), and  • applies a Hadamard Gate (again).  (I have not mentally conceptualised this yet.)</p>
<p>It all sounds fine.  The issue is that, when I try applying a Hadamard Gate to a biased superposition — {3/4,1/4} as opposed to {1/2,1/2} — the resulting probabilities (i.e. their squares) do not add to 1.</p>
<hr />
<p>EDIT_01</p>
<ol>
<li>My spreadsheet is as follows.</li>
</ol>
<p>Columns A, B… D… F.<br />
A ----------- B ----------…  D -----------…  F<br />
<code>= sqrt(0.5)</code>,  =<code> sqrt(0.5)</code>…  =<code> sqrt(3/4)</code>…  =<code>(A1*D1)+(B1*D2)</code><br />
<code>= sqrt(0.5)</code>,  =<code>-sqrt(0.5)</code>…  =<code> sqrt(1/4)</code>…  =<code>(A2*D1)+(B2*D2)</code></p>
<p>. Clmn(F)                                        =<code>SUM(F1,F2)</code></p>
<p>Respectively, for • all SQRT (as above), • SQRT(X/4), • SQRT(0.5) and • no SQRT…<br />
I get 1.225…, 0.866…, 1.06… and 0.75.  (Of course, only one of those is “correct” — the first one, I believe — the point here is that this is not my/the error.)</p>
<hr />
<p>Is my spreadsheet wrong, or is my rendition of matrix multiplication wrong, or is it in fact true that applying a Hadamard Gate to anything other than 0, 1, or 50/50 results in mayhem… or is it okay for a q-bit to have a total probability &lt; 1… please?</p>
",Applying Hadamard gate to $\sqrt{3/4}|0\rangle + \sqrt{1/4}|1\rangle$,<grovers-algorithm><hadamard><superposition><probability>,1,2,,,"Applying Hadamard gate to $\sqrt{3/4}|0\rangle + \sqrt{1/4}|1\rangle$ <p>[I am just transferring this from Stack Overflow.  It might need editing.]</p>
<p>————</p>
<p>[The reader can skip to “It all sounds fine…”, before the spreadsheet representation.]</p>
<p>I am trying to figure out quantum computing from YouTube videos, and pdf’s from universities, and odd bits here and there.</p>
<p>I have been confident that the two values in any q-bit must add to 1 — that is, their squares must.</p>
<p>Pertinent (or related) to Grover’s Algorithm, I have been trying to figure out the procedure for multiplying [i.e. increasing] the amplitude of the one q-bit, relative to the others.  (I mostly follow the trigonometry; it is the matrix side I am having trouble with… mostly because I am having trouble getting a handle on the syntax of the algebra.)</p>
<p>(I have been working from the following page.)<br />
<a href=""https://drive.google.com/file/d/14G_0TwdxBFpI_Ylj5lb_imVtcnunrQcB/view"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/14G_0TwdxBFpI_Ylj5lb_imVtcnunrQcB/view</a></p>
<p>I think I understand the “reflection around |0〉” part — just flip the sign on the p[robability]|1〉 part.</p>
<p>(Incidentally, I take it that the pertinent q-bits still add to 1, through ignoring their signs?)</p>
<p>That leaves the “reflection around |ψ〉” part.  I have just found an account that is meaningful to me (rightly or wrongly!), on this page (straddling pp5 and 6).<br />
<a href=""https://theory.epfl.ch/courses/topicstcs/Lecture112016.pdf"" rel=""nofollow noreferrer"">https://theory.epfl.ch/courses/topicstcs/Lecture112016.pdf</a></p>
<p>If I understand correctly, it says that one  • applies a Hadamard Gate,  • reflects around |0〉 (as above), and  • applies a Hadamard Gate (again).  (I have not mentally conceptualised this yet.)</p>
<p>It all sounds fine.  The issue is that, when I try applying a Hadamard Gate to a biased superposition — {3/4,1/4} as opposed to {1/2,1/2} — the resulting probabilities (i.e. their squares) do not add to 1.</p>
<hr />
<p>EDIT_01</p>
<ol>
<li>My spreadsheet is as follows.</li>
</ol>
<p>Columns A, B… D… F.<br />
A ----------- B ----------…  D -----------…  F<br />
<code>= sqrt(0.5)</code>,  =<code> sqrt(0.5)</code>…  =<code> sqrt(3/4)</code>…  =<code>(A1*D1)+(B1*D2)</code><br />
<code>= sqrt(0.5)</code>,  =<code>-sqrt(0.5)</code>…  =<code> sqrt(1/4)</code>…  =<code>(A2*D1)+(B2*D2)</code></p>
<p>. Clmn(F)                                        =<code>SUM(F1,F2)</code></p>
<p>Respectively, for • all SQRT (as above), • SQRT(X/4), • SQRT(0.5) and • no SQRT…<br />
I get 1.225…, 0.866…, 1.06… and 0.75.  (Of course, only one of those is “correct” — the first one, I believe — the point here is that this is not my/the error.)</p>
<hr />
<p>Is my spreadsheet wrong, or is my rendition of matrix multiplication wrong, or is it in fact true that applying a Hadamard Gate to anything other than 0, 1, or 50/50 results in mayhem… or is it okay for a q-bit to have a total probability &lt; 1… please?</p>
",qc,applying hadamard gate p transferring stack overflow might need editing p p reader skip sounds spreadsheet representation p trying figure quantum computing youtube videos pdf universities odd bits p confident two values must add 1 squares p pertinent related grover algorithm trying figure procedure multiplying increasing amplitude one relative others mostly follow trigonometry matrix side trouble mostly trouble getting handle syntax algebra p working following page br https nofollow noreferrer https p think understand reflection around part flip sign p robability p incidentally take pertinent still add 1 ignoring signs p leaves reflection around part found account meaningful rightly wrongly page straddling pp5 6 br https nofollow noreferrer https p understand correctly says one applies hadamard gate reflects around applies hadamard gate mentally conceptualised yet p sounds fine issue try applying hadamard gate biased superposition opposed resulting probabilities squares add hr p ol li spreadsheet p columns br b f br code sqrt code sqrt code sqrt code a1 d1 b1 d2 br code sqrt code code sqrt code a2 d1 b2 d2 p clmn f code sum f1 f2 p respectively sqrt sqrt sqrt br get course one correct first one believe point error hr p spreadsheet wrong rendition matrix multiplication wrong fact true applying hadamard gate anything 0 1 results okay total probability lt please,"[(0, 0.12515807), (3, 0.06226024), (4, 0.059736796), (6, 0.025516763), (7, 0.073376365), (8, 0.061038833), (9, 0.10481119), (10, 0.010546226), (11, 0.017512023), (12, 0.015639873), (13, 0.22839078), (14, 0.08511791), (18, 0.13054457)]"
21174,39831.0,2021-09-12 22:15:14,3,321,"<p>I am considering the density matrix which represents an arbitrary state for a pair of qubits.  When written out in terms of the Pauli operators, this is as follows (certain terms vanish for another reason so there are fewer than <span class=""math-container"">$16$</span> terms):</p>
<p><span class=""math-container"">$$\rho = \frac{1}{4} \bigg(  I \otimes I + t_{01}I \otimes \sigma_x + t_{10} \sigma_x \otimes I + t_{02} I \otimes \sigma_y + t_{20} \sigma_y \otimes I + t_{11} \sigma_x \otimes \sigma_x + t_{22}\sigma_y \otimes \sigma_y + t_{33} \sigma_z \otimes \sigma_z + t_{12} \sigma_x \otimes \sigma_y + t_{21}\sigma_y \otimes \sigma_x \bigg),$$</span></p>
<p>where the coefficients take values between <span class=""math-container"">$-1$</span> and <span class=""math-container"">$1$</span>.</p>
<p>It is possible to have eigenstates for a density matrix but this is quite a long and complicated expression, so I am just curious to how would one would write down the possible eigenvectors for this matrix? Do the eigenvectors here relate to the usual eigenvectors for the Pauli matrices themselves?</p>
",Is there a way to write down the eigenstates of this two-qubit density matrix?,<linear-algebra><density-matrix>,1,5,,,"Is there a way to write down the eigenstates of this two-qubit density matrix? <p>I am considering the density matrix which represents an arbitrary state for a pair of qubits.  When written out in terms of the Pauli operators, this is as follows (certain terms vanish for another reason so there are fewer than <span class=""math-container"">$16$</span> terms):</p>
<p><span class=""math-container"">$$\rho = \frac{1}{4} \bigg(  I \otimes I + t_{01}I \otimes \sigma_x + t_{10} \sigma_x \otimes I + t_{02} I \otimes \sigma_y + t_{20} \sigma_y \otimes I + t_{11} \sigma_x \otimes \sigma_x + t_{22}\sigma_y \otimes \sigma_y + t_{33} \sigma_z \otimes \sigma_z + t_{12} \sigma_x \otimes \sigma_y + t_{21}\sigma_y \otimes \sigma_x \bigg),$$</span></p>
<p>where the coefficients take values between <span class=""math-container"">$-1$</span> and <span class=""math-container"">$1$</span>.</p>
<p>It is possible to have eigenstates for a density matrix but this is quite a long and complicated expression, so I am just curious to how would one would write down the possible eigenvectors for this matrix? Do the eigenvectors here relate to the usual eigenvectors for the Pauli matrices themselves?</p>
",qc,way write eigenstates density matrix p considering density matrix represents arbitrary state pair qubits written terms pauli operators follows certain terms vanish another reason fewer span 16 terms p span 1 4 01 10 02 20 11 22 33 12 21 p coefficients take values span span 1 p possible eigenstates density matrix quite long complicated expression curious would one would write possible eigenvectors matrix eigenvectors relate usual eigenvectors pauli matrices,"[(3, 0.6027494), (6, 0.12952468), (9, 0.13667145), (10, 0.015576941), (11, 0.09921096), (12, 0.014298897)]"
21210,21217.0,2021-09-15 13:03:49,0,153,"<p>first of all, I would probably report this as a bug if I was confident enough in my QC abilities. As it stands, I've just started out, so I'm phrasing it as a question.</p>
<p>From what I can tell, adding two PauliOps in this specific case does not result in the expected operator matrix:</p>
<pre><code>import qiskit as qk
from qiskit.opflow.primitive_ops import PauliOp

(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix()
</code></pre>
<p>results in</p>
<pre><code>array([[0.+0.j, 1.-1.j],
       [1.+1.j, 0.+0.j]])
</code></pre>
<p>whereas the result that I would expect is the one i get when I run the following code:</p>
<pre><code>PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)).to_matrix() + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;)).to_matrix()
</code></pre>
<p>Result:</p>
<pre><code>array([[0.+0.j, 2.+0.j],
       [0.+0.j, 0.+0.j]])
</code></pre>
<p>What further confuses me is that the deprecated version of PauliOp actually results in the expected operator. Running this code:</p>
<pre><code>import qiskit as qk
from qiskit.aqua.operators.primitive_ops import PauliOp

(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix()
</code></pre>
<p>gives a deprecation warning and the [[0,2],[0,0]]-array that I want.</p>
<p>Has the behaviour of the addition changed or is this a bug? In any case, how can I construct the operator that I want (in a non-deprecated way)?</p>
<p>I'm running qiskit version 0.29.0</p>
<p>Thanks in advance!</p>
",Expected outcome of adding two PauliOp,<qiskit><programming>,1,0,,,"Expected outcome of adding two PauliOp <p>first of all, I would probably report this as a bug if I was confident enough in my QC abilities. As it stands, I've just started out, so I'm phrasing it as a question.</p>
<p>From what I can tell, adding two PauliOps in this specific case does not result in the expected operator matrix:</p>
<pre><code>import qiskit as qk
from qiskit.opflow.primitive_ops import PauliOp

(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix()
</code></pre>
<p>results in</p>
<pre><code>array([[0.+0.j, 1.-1.j],
       [1.+1.j, 0.+0.j]])
</code></pre>
<p>whereas the result that I would expect is the one i get when I run the following code:</p>
<pre><code>PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)).to_matrix() + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;)).to_matrix()
</code></pre>
<p>Result:</p>
<pre><code>array([[0.+0.j, 2.+0.j],
       [0.+0.j, 0.+0.j]])
</code></pre>
<p>What further confuses me is that the deprecated version of PauliOp actually results in the expected operator. Running this code:</p>
<pre><code>import qiskit as qk
from qiskit.aqua.operators.primitive_ops import PauliOp

(PauliOp(qk.quantum_info.Pauli(&quot;X&quot;)) + PauliOp(qk.quantum_info.Pauli(&quot;iY&quot;))).to_matrix()
</code></pre>
<p>gives a deprecation warning and the [[0,2],[0,0]]-array that I want.</p>
<p>Has the behaviour of the addition changed or is this a bug? In any case, how can I construct the operator that I want (in a non-deprecated way)?</p>
<p>I'm running qiskit version 0.29.0</p>
<p>Thanks in advance!</p>
",qc,expected outcome adding two pauliop p first would probably report bug confident enough qc abilities stands started phrasing p tell adding two pauliops specific case result expected operator matrix pre code import qiskit qk import pauliop pauliop quot x quot pauliop quot iy quot p results pre code array p whereas result would expect one get run following code pre code pauliop quot x quot pauliop quot iy quot p result pre code array p confuses deprecated version pauliop actually results expected operator running code pre code import qiskit qk import pauliop pauliop quot x quot pauliop quot iy quot p gives deprecation warning p behaviour addition changed bug case construct operator want way p running qiskit version p thanks advance,"[(0, 0.24217221), (3, 0.10110434), (10, 0.029765038), (12, 0.0857206), (14, 0.43214238), (19, 0.10791002)]"
21215,21216.0,2021-09-15 18:54:10,1,302,"<p>I hear that phase information of qubits is important and you can clearly see the phase of a qubit when represented on the Bloch sphere.</p>
<p>But, I am not sure what to think of the phase of individual qubits in the context of an entangled state of multiple qubits.</p>
<p>For example, when talking about <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""nofollow noreferrer"">the GHZ state</a>,one could have a relative phase relation between  <span class=""math-container"">$|000\rangle$</span>   and <span class=""math-container"">$|111\rangle  $</span> in the form of <span class=""math-container"">$\frac{1}{\sqrt{2}}|000\rangle+e^{i\phi}|111\rangle $</span></p>
<p>But, that's just one phase as opposed to multiple phases which come from the phases of individual qubits.</p>
<p>Is there a simple way to make sense of the fact that there is only one relative phase despite the fact that there are 3 individual qubits?</p>
",How to make sense of phases of individual qubits in the context of multiple entangled qubits?,<quantum-state><entanglement>,1,1,,,"How to make sense of phases of individual qubits in the context of multiple entangled qubits? <p>I hear that phase information of qubits is important and you can clearly see the phase of a qubit when represented on the Bloch sphere.</p>
<p>But, I am not sure what to think of the phase of individual qubits in the context of an entangled state of multiple qubits.</p>
<p>For example, when talking about <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""nofollow noreferrer"">the GHZ state</a>,one could have a relative phase relation between  <span class=""math-container"">$|000\rangle$</span>   and <span class=""math-container"">$|111\rangle  $</span> in the form of <span class=""math-container"">$\frac{1}{\sqrt{2}}|000\rangle+e^{i\phi}|111\rangle $</span></p>
<p>But, that's just one phase as opposed to multiple phases which come from the phases of individual qubits.</p>
<p>Is there a simple way to make sense of the fact that there is only one relative phase despite the fact that there are 3 individual qubits?</p>
",qc,make sense phases individual qubits context multiple entangled qubits p hear phase information qubits important clearly see phase qubit represented bloch p sure think phase individual qubits context entangled state multiple p example talking https e2 80 93horne e2 80 nofollow noreferrer ghz state one could relative phase relation span span form span 1 2 p one phase opposed multiple phases come phases individual p simple way make sense fact one relative phase despite fact 3 individual qubits,"[(2, 0.026712127), (8, 0.0859383), (9, 0.4357126), (12, 0.054093797), (18, 0.39559957)]"
21356,,2021-09-28 05:06:55,1,97,"<p>I am reading a paper about QCNN and BP problem. And in the paper there is a part illustrating the relation between the trainability and variance of the cost. The cost function is written as,</p>
<p><span class=""math-container"">$C(\theta)=Tr[V(\theta)\sigma V^\dagger (\theta)\tilde O]$</span></p>
<p><span class=""math-container"">$\theta$</span> is the vector of the trainable parameters, <span class=""math-container"">$V(\theta)$</span> is the unitary that contains the gates in the convolutional and pooling layers plus the fully connected layer, <span class=""math-container"">$\tilde O$</span> is defined on the input Hilbert space such that its expectation value represents the measured value.</p>
<p>And we want to evaluate the partial derivative of <span class=""math-container"">$C(\theta)$</span> with respect to <span class=""math-container"">$\theta_\mu$</span>, and the explicit form is</p>
<p><span class=""math-container"">$\partial_\mu C = Tr[W_A V_L \sigma V_L^{\dagger} W_A^{\dagger} [H_\mu, W_B^\dagger V_R^\dagger\tilde O V_R W_B]]\space (*)$</span></p>
<p>where <span class=""math-container"">$V=V_RWV_L$</span>, where <span class=""math-container"">$V_R$</span> and <span class=""math-container"">$V_L$</span> contain all gates in the QCNN except for W. And <span class=""math-container"">$W=W_BW_A, W_A=\prod_{\eta \leq \mu}e^{-i\theta_\eta H_\eta},W_A=\prod_{\eta &gt; \mu}e^{-i\theta_\eta H_\eta}$</span>.</p>
<p>I am quite confused about (*), since based on the direct derivation of <span class=""math-container"">$C(\theta)$</span>, I get,</p>
<p><span class=""math-container"">$\partial_\mu C = Tr[V_R W_B (\partial_\mu W_A) V_L \sigma V_L^\dagger W_A^\dagger W_B^\dagger V_R^\dagger \tilde O] + Tr[V_R W_B W_A V_L \sigma V_L^\dagger (\partial_\mu W_A^\dagger ) W_B^\dagger V_R^\dagger \tilde O]$</span></p>
<p>Why the relative positions of each operators are different from what I got above, and what is the specific definition of <span class=""math-container"">$H_\mu$</span> (to be more specific, how does <span class=""math-container"">$H_\mu$</span> relates to <span class=""math-container"">$\partial_\mu$</span>) ?</p>
<p>For your reference, the the arxiv link of the original paper is <a href=""https://arxiv.org/abs/2011.02966"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2011.02966</a>.</p>
<p>Any help would be appreciated!!</p>
",Why the partial derivative of cost function is written in this form?,<quantum-operation><vqe>,0,0,,,"Why the partial derivative of cost function is written in this form? <p>I am reading a paper about QCNN and BP problem. And in the paper there is a part illustrating the relation between the trainability and variance of the cost. The cost function is written as,</p>
<p><span class=""math-container"">$C(\theta)=Tr[V(\theta)\sigma V^\dagger (\theta)\tilde O]$</span></p>
<p><span class=""math-container"">$\theta$</span> is the vector of the trainable parameters, <span class=""math-container"">$V(\theta)$</span> is the unitary that contains the gates in the convolutional and pooling layers plus the fully connected layer, <span class=""math-container"">$\tilde O$</span> is defined on the input Hilbert space such that its expectation value represents the measured value.</p>
<p>And we want to evaluate the partial derivative of <span class=""math-container"">$C(\theta)$</span> with respect to <span class=""math-container"">$\theta_\mu$</span>, and the explicit form is</p>
<p><span class=""math-container"">$\partial_\mu C = Tr[W_A V_L \sigma V_L^{\dagger} W_A^{\dagger} [H_\mu, W_B^\dagger V_R^\dagger\tilde O V_R W_B]]\space (*)$</span></p>
<p>where <span class=""math-container"">$V=V_RWV_L$</span>, where <span class=""math-container"">$V_R$</span> and <span class=""math-container"">$V_L$</span> contain all gates in the QCNN except for W. And <span class=""math-container"">$W=W_BW_A, W_A=\prod_{\eta \leq \mu}e^{-i\theta_\eta H_\eta},W_A=\prod_{\eta &gt; \mu}e^{-i\theta_\eta H_\eta}$</span>.</p>
<p>I am quite confused about (*), since based on the direct derivation of <span class=""math-container"">$C(\theta)$</span>, I get,</p>
<p><span class=""math-container"">$\partial_\mu C = Tr[V_R W_B (\partial_\mu W_A) V_L \sigma V_L^\dagger W_A^\dagger W_B^\dagger V_R^\dagger \tilde O] + Tr[V_R W_B W_A V_L \sigma V_L^\dagger (\partial_\mu W_A^\dagger ) W_B^\dagger V_R^\dagger \tilde O]$</span></p>
<p>Why the relative positions of each operators are different from what I got above, and what is the specific definition of <span class=""math-container"">$H_\mu$</span> (to be more specific, how does <span class=""math-container"">$H_\mu$</span> relates to <span class=""math-container"">$\partial_\mu$</span>) ?</p>
<p>For your reference, the the arxiv link of the original paper is <a href=""https://arxiv.org/abs/2011.02966"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2011.02966</a>.</p>
<p>Any help would be appreciated!!</p>
",qc,partial derivative cost function written form p reading paper qcnn bp problem paper part illustrating relation trainability variance cost cost function written p span c v p span vector trainable parameters span v unitary contains gates convolutional pooling layers plus fully connected layer span defined input hilbert space expectation value represents measured p want evaluate partial derivative span c respect span explicit form p span c tr p span span span contain gates qcnn except span gt p quite confused since based direct derivation span c get p span c tr tr p relative positions operators different got specific definition span specific span relates span p reference arxiv link original paper https nofollow noreferrer https p help would appreciated,"[(3, 0.6844186), (4, 0.09350604), (9, 0.041765798), (12, 0.035621837), (14, 0.09335616), (19, 0.050126113)]"
21377,,2021-10-01 06:29:13,2,176,"<p>I've lately started working on a DI-QKD project. I've started looking into <a href=""https://arxiv.org/abs/1210.1810"" rel=""nofollow noreferrer"">Vazirani and Vidick's PRL paper</a> on Device-Independent QKD security proof. It's proving to be quite time-consuming for me to go through all of the proofs.<br />
I'm curious if there are any other well-known security proofs for DI-QKD that go in a different way from Vazirani and Vidick's. So that I can get a general estimate of how many more proofs I'll need to read in order to cover all of DI-security QKD's proofs. In order for me to be able to allocate my time properly.<br />
Or is this the main paper, and only minor changes have been made to it since then?</p>
<p>If you have any familiarity with DI-QKD, it would be helpful if you could give me some insight or point me to some of the important security proofs available. Alternatively, find an article or review paper that addresses these DI-QKD-related subjects.<br />
It would also be beneficial for future students who would like to understand DI-QKD.</p>
",Major Security proofs available for Device-Independent QKD,<resource-request><cryptography><qkd>,1,2,,,"Major Security proofs available for Device-Independent QKD <p>I've lately started working on a DI-QKD project. I've started looking into <a href=""https://arxiv.org/abs/1210.1810"" rel=""nofollow noreferrer"">Vazirani and Vidick's PRL paper</a> on Device-Independent QKD security proof. It's proving to be quite time-consuming for me to go through all of the proofs.<br />
I'm curious if there are any other well-known security proofs for DI-QKD that go in a different way from Vazirani and Vidick's. So that I can get a general estimate of how many more proofs I'll need to read in order to cover all of DI-security QKD's proofs. In order for me to be able to allocate my time properly.<br />
Or is this the main paper, and only minor changes have been made to it since then?</p>
<p>If you have any familiarity with DI-QKD, it would be helpful if you could give me some insight or point me to some of the important security proofs available. Alternatively, find an article or review paper that addresses these DI-QKD-related subjects.<br />
It would also be beneficial for future students who would like to understand DI-QKD.</p>
",qc,major security proofs available qkd p lately started working project started looking https nofollow noreferrer vazirani vidick prl paper qkd security proof proving quite go br curious security proofs go different way vazirani vidick get general estimate many proofs need read order cover qkd proofs order able allocate time br main paper minor changes made since p familiarity would helpful could give insight point important security proofs available alternatively find article review paper addresses br would also beneficial future students would like understand,"[(1, 0.015969044), (3, 0.037157558), (8, 0.46637112), (9, 0.13809513), (12, 0.012333682), (13, 0.32836446)]"
21429,21430.0,2021-10-06 13:24:43,5,363,"<p>Consider the following general formulation of the standard quantum state tomography problem: given an unknown state <span class=""math-container"">$\rho$</span>, a set of (known) observables <span class=""math-container"">$\{\mathcal O_k\}_k$</span> (generally the elements of some POVM), and a corresponding vector of measured probabilities (or more realistically, frequencies) <span class=""math-container"">$\mathbf Y$</span>, we want to retrieve a description of <span class=""math-container"">$\rho$</span>, that is, the coefficients of the decomposition of <span class=""math-container"">$\rho$</span> with respect to some &quot;canonical&quot; operatorial basis <span class=""math-container"">$\{\sigma_k\}$</span> (the typical example being the basis built with Pauli matrices).</p>
<p>This amounts to solving the linear problem
<span class=""math-container"">$\mathbf Y = \mathbf X\boldsymbol \theta$</span> for <span class=""math-container"">$\boldsymbol\theta$</span>.
Here, <span class=""math-container"">$\mathbf Y$</span> vector of measured frequencies, <span class=""math-container"">$\mathbf X$</span> the matrix whose elements are the coefficients of the decomposition of the observables <span class=""math-container"">$\mathcal O_k$</span> in terms of <span class=""math-container"">$\sigma_j$</span>, and <span class=""math-container"">$\boldsymbol\theta$</span> the vector of coefficients obtained decomposing <span class=""math-container"">$\rho$</span> with respect to <span class=""math-container"">$\{\sigma_j\}$</span> (this notation is from (<em><a href=""https://doi.org/10.1088/1367-2630/aa8fe6"" rel=""nofollow noreferrer"">Granade et al. 2017</a></em>)).</p>
<p>The naive solution to this linear problem is <span class=""math-container"">$\boldsymbol\theta=\mathbf X^+\mathbf Y$</span>, with <span class=""math-container"">$\mathbf X^+$</span> the <a href=""https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse"" rel=""nofollow noreferrer"">pseudoinverse</a> of <span class=""math-container"">$\mathbf X$</span>.
However, this method is known to be problematic. For one thing, it is not guaranteed to produce a positive semidefinite estimate for the state. As mentioned by (<a href=""https://doi.org/10.1088/1367-2630/aa8fe6"" rel=""nofollow noreferrer""><em>Granade et al. 2017</em></a>), possible workarounds include performing <em>constrained</em> least squares, or using a &quot;two-step approach that outputs the closest physical state to a given matrix&quot;.</p>
<p>I'm aware of the plethora of alternative approaches to state tomography. However, I'm specifically looking for references discussing the issues with this &quot;naive&quot; linear reconstruction method, and in particular the related problems of numerical (in)stability and lack of positive semidefiniteness of the estimate.
The only thing I found was the brief mention in the paper above, the discussion in (<em><a href=""https://doi.org/10.1038/srep03496"" rel=""nofollow noreferrer"">Qi et al. 2013</a></em>), and some discussion of the numerical stability problems in Appendix A of (<em><a href=""https://doi.org/10.1103/PhysRevA.56.1788"" rel=""nofollow noreferrer"">Opatrný et al. 1997</a></em>).</p>
",What are the problems of linear inversion quantum state tomography?,<resource-request><state-tomography>,1,1,,,"What are the problems of linear inversion quantum state tomography? <p>Consider the following general formulation of the standard quantum state tomography problem: given an unknown state <span class=""math-container"">$\rho$</span>, a set of (known) observables <span class=""math-container"">$\{\mathcal O_k\}_k$</span> (generally the elements of some POVM), and a corresponding vector of measured probabilities (or more realistically, frequencies) <span class=""math-container"">$\mathbf Y$</span>, we want to retrieve a description of <span class=""math-container"">$\rho$</span>, that is, the coefficients of the decomposition of <span class=""math-container"">$\rho$</span> with respect to some &quot;canonical&quot; operatorial basis <span class=""math-container"">$\{\sigma_k\}$</span> (the typical example being the basis built with Pauli matrices).</p>
<p>This amounts to solving the linear problem
<span class=""math-container"">$\mathbf Y = \mathbf X\boldsymbol \theta$</span> for <span class=""math-container"">$\boldsymbol\theta$</span>.
Here, <span class=""math-container"">$\mathbf Y$</span> vector of measured frequencies, <span class=""math-container"">$\mathbf X$</span> the matrix whose elements are the coefficients of the decomposition of the observables <span class=""math-container"">$\mathcal O_k$</span> in terms of <span class=""math-container"">$\sigma_j$</span>, and <span class=""math-container"">$\boldsymbol\theta$</span> the vector of coefficients obtained decomposing <span class=""math-container"">$\rho$</span> with respect to <span class=""math-container"">$\{\sigma_j\}$</span> (this notation is from (<em><a href=""https://doi.org/10.1088/1367-2630/aa8fe6"" rel=""nofollow noreferrer"">Granade et al. 2017</a></em>)).</p>
<p>The naive solution to this linear problem is <span class=""math-container"">$\boldsymbol\theta=\mathbf X^+\mathbf Y$</span>, with <span class=""math-container"">$\mathbf X^+$</span> the <a href=""https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse"" rel=""nofollow noreferrer"">pseudoinverse</a> of <span class=""math-container"">$\mathbf X$</span>.
However, this method is known to be problematic. For one thing, it is not guaranteed to produce a positive semidefinite estimate for the state. As mentioned by (<a href=""https://doi.org/10.1088/1367-2630/aa8fe6"" rel=""nofollow noreferrer""><em>Granade et al. 2017</em></a>), possible workarounds include performing <em>constrained</em> least squares, or using a &quot;two-step approach that outputs the closest physical state to a given matrix&quot;.</p>
<p>I'm aware of the plethora of alternative approaches to state tomography. However, I'm specifically looking for references discussing the issues with this &quot;naive&quot; linear reconstruction method, and in particular the related problems of numerical (in)stability and lack of positive semidefiniteness of the estimate.
The only thing I found was the brief mention in the paper above, the discussion in (<em><a href=""https://doi.org/10.1038/srep03496"" rel=""nofollow noreferrer"">Qi et al. 2013</a></em>), and some discussion of the numerical stability problems in Appendix A of (<em><a href=""https://doi.org/10.1103/PhysRevA.56.1788"" rel=""nofollow noreferrer"">Opatrný et al. 1997</a></em>).</p>
",qc,problems linear inversion quantum state tomography p consider following general formulation standard quantum state tomography problem given unknown state span set known observables span generally elements povm corresponding vector measured probabilities realistically frequencies span want retrieve description span coefficients decomposition span respect quot canonical quot operatorial basis span typical example basis built pauli matrices p amounts solving linear problem span span span vector measured frequencies span x matrix whose elements coefficients decomposition observables span terms span span vector coefficients obtained decomposing span respect span notation em https nofollow noreferrer granade et al 2017 p naive solution linear problem span span https e2 80 nofollow noreferrer pseudoinverse span x however method known problematic one thing guaranteed produce positive semidefinite estimate state mentioned https nofollow noreferrer em granade et al 2017 possible workarounds include performing em constrained least squares using quot approach outputs closest physical state given matrix quot p aware plethora alternative approaches state tomography however specifically looking references discussing issues quot naive quot linear reconstruction method particular related problems numerical stability lack positive semidefiniteness estimate thing found brief mention paper discussion em https nofollow noreferrer qi et al 2013 discussion numerical stability problems appendix em https nofollow noreferrer opatrný et al 1997,"[(1, 0.048162702), (3, 0.35357642), (4, 0.046989758), (7, 0.09291585), (8, 0.049290147), (9, 0.19546828), (10, 0.010778513), (11, 0.037201535), (12, 0.010705259), (13, 0.084231764), (14, 0.023912774), (19, 0.04635251)]"
21510,21511.0,2021-10-11 18:25:25,1,275,"<p>I am trying to run a simple &quot;Hello World&quot; project in Q#, following <a href=""https://www.c-sharpcorner.com/article/getting-started-with-q-programming/"" rel=""nofollow noreferrer"">this tutorial</a>. I have completed the following steps (Step #s from tutorial link):</p>
<ul>
<li>Step 1: Installed the latest version of Visual Studio 2019 (16.11.4 Preview 1.0)</li>
<li>Step 2: Installed Microsoft Quantum Development Kit</li>
<li>Step 3: Created a Q# Project using the Q# Application Template</li>
</ul>
<p>The resulting <code>Program.qs</code> file appears in vs:</p>
<pre><code>namespace Quantum.QSharpHelloWorld {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    
    @EntryPoint()
    operation HelloQ () : Unit {
        Message(&quot;Hello quantum world!&quot;);
    }
}
</code></pre>
<p>The two namespaces I am trying to <code>open</code> show the red squiggly line, with the errors</p>
<blockquote>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Canon&quot; exists.</p>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Intrinsic&quot; exists.</p>
</blockquote>
<p>Additionally and likely the same root cause, the <code>@EntryPoint</code> annotation and <code>Message()</code> call fail:</p>
<blockquote>
<p>QS6005: No type with the name &quot;EntryPoint&quot; exists in any of the open namespaces.</p>
<p>QS5022: No identifier with the name &quot;Message&quot; exists.</p>
</blockquote>
<p>In the solution explorer for my projet <code>QSharpHelloWorld</code>, the Dependencies, Packages, and each of five packages (Microsoft.Quantum.CSharpGeneration, .EntryPointDriver, .QSharp.Core, .Runtime.Core, and .Standard) all have the yellow triangle warning indicating a problem.</p>
<p>The error is similar to the one in <a href=""https://quantumcomputing.stackexchange.com/questions/12520/q-error-no-namespace-with-the-name-microsoft-quantum-machinelearning-exists"">this question</a>, except I'm not using Python so the accepted answer is irrelevant.  I attempted to use the command suggested in <a href=""https://quantumcomputing.stackexchange.com/a/12573/13421"">another answer</a>:</p>
<pre><code>dotnet add QSharpHelloWorld.csproj package Microsoft.Quantum.CSharpGeneration
</code></pre>
<p>However, this failed with the following error, suggesting this is the wrong solution:</p>
<pre><code>error: Error while performing Update for package 'Microsoft.Quantum.CSharpGeneration'. Cannot edit items in imported files -
error:   Item 'PackageReference' for 'Microsoft.Quantum.CSharpGeneration' in Imported file 'C:\[...]\.nuget\packages\microsoft.quantum.sdk\0.19.2109165653\Sdk\Sdk.props'.
</code></pre>
<p>I can't find any other obvious/easy menu options or fixes for this.  Other questions I've found here on SE all seem to be related to Python integration, not using Visual Studio.  I have the feeling I'm missing something trivial and obvious. Can anyone suggest additional steps I can take?</p>
","Q#/VS: No namespace with the name ""Microsoft.Quantum.Canon"" exists",<programming><q#>,1,1,,,"Q#/VS: No namespace with the name ""Microsoft.Quantum.Canon"" exists <p>I am trying to run a simple &quot;Hello World&quot; project in Q#, following <a href=""https://www.c-sharpcorner.com/article/getting-started-with-q-programming/"" rel=""nofollow noreferrer"">this tutorial</a>. I have completed the following steps (Step #s from tutorial link):</p>
<ul>
<li>Step 1: Installed the latest version of Visual Studio 2019 (16.11.4 Preview 1.0)</li>
<li>Step 2: Installed Microsoft Quantum Development Kit</li>
<li>Step 3: Created a Q# Project using the Q# Application Template</li>
</ul>
<p>The resulting <code>Program.qs</code> file appears in vs:</p>
<pre><code>namespace Quantum.QSharpHelloWorld {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    
    @EntryPoint()
    operation HelloQ () : Unit {
        Message(&quot;Hello quantum world!&quot;);
    }
}
</code></pre>
<p>The two namespaces I am trying to <code>open</code> show the red squiggly line, with the errors</p>
<blockquote>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Canon&quot; exists.</p>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Intrinsic&quot; exists.</p>
</blockquote>
<p>Additionally and likely the same root cause, the <code>@EntryPoint</code> annotation and <code>Message()</code> call fail:</p>
<blockquote>
<p>QS6005: No type with the name &quot;EntryPoint&quot; exists in any of the open namespaces.</p>
<p>QS5022: No identifier with the name &quot;Message&quot; exists.</p>
</blockquote>
<p>In the solution explorer for my projet <code>QSharpHelloWorld</code>, the Dependencies, Packages, and each of five packages (Microsoft.Quantum.CSharpGeneration, .EntryPointDriver, .QSharp.Core, .Runtime.Core, and .Standard) all have the yellow triangle warning indicating a problem.</p>
<p>The error is similar to the one in <a href=""https://quantumcomputing.stackexchange.com/questions/12520/q-error-no-namespace-with-the-name-microsoft-quantum-machinelearning-exists"">this question</a>, except I'm not using Python so the accepted answer is irrelevant.  I attempted to use the command suggested in <a href=""https://quantumcomputing.stackexchange.com/a/12573/13421"">another answer</a>:</p>
<pre><code>dotnet add QSharpHelloWorld.csproj package Microsoft.Quantum.CSharpGeneration
</code></pre>
<p>However, this failed with the following error, suggesting this is the wrong solution:</p>
<pre><code>error: Error while performing Update for package 'Microsoft.Quantum.CSharpGeneration'. Cannot edit items in imported files -
error:   Item 'PackageReference' for 'Microsoft.Quantum.CSharpGeneration' in Imported file 'C:\[...]\.nuget\packages\microsoft.quantum.sdk\0.19.2109165653\Sdk\Sdk.props'.
</code></pre>
<p>I can't find any other obvious/easy menu options or fixes for this.  Other questions I've found here on SE all seem to be related to Python integration, not using Visual Studio.  I have the feeling I'm missing something trivial and obvious. Can anyone suggest additional steps I can take?</p>
",qc,q namespace name exists p trying run simple quot hello world quot project q following https nofollow noreferrer tutorial completed following steps step tutorial link ul li step 1 installed latest version visual studio 2019 preview li step 2 installed microsoft quantum development kit li step 3 created q project using q application template p resulting code file appears vs pre code namespace open open entrypoint operation helloq unit message quot hello quantum world quot p two namespaces trying code open show red squiggly line errors blockquote p qs6104 namespace name quot quot p qs6104 namespace name quot quot p additionally likely root cause code entrypoint annotation code message call fail blockquote p qs6005 type name quot entrypoint quot exists open p qs5022 identifier name quot message quot p solution explorer projet code qsharphelloworld dependencies packages five packages yellow triangle warning indicating p error similar one https question except using python accepted answer irrelevant attempted use command suggested https another answer pre code dotnet add package p however failed following error suggesting wrong solution pre code error error performing update package edit items imported files error item imported file c p ca find menu options fixes questions found se seem related python integration using visual studio feeling missing something trivial obvious anyone suggest additional steps take,"[(0, 0.06695284), (3, 0.020705469), (4, 0.05422052), (5, 0.029492702), (7, 0.05720205), (8, 0.067060895), (9, 0.016463803), (10, 0.021450121), (12, 0.03833159), (13, 0.22956379), (14, 0.23150653), (17, 0.013334691), (19, 0.15337464)]"
21521,,2021-10-13 14:44:19,1,58,"<p>Are there some lists of the method to realize quantum metrology, or rather, utilizing quantum resources to enhance the precision of parameter estimation. The experimental method I've know is listed as follows:</p>
<ul>
<li><a href=""https://arxiv.org/abs/1609.01609"" rel=""nofollow noreferrer"">Trapped Ions</a></li>
<li><a href=""https://arxiv.org/abs/1609.01609"" rel=""nofollow noreferrer"">Bose-Einstein Condenstates</a></li>
<li><a href=""https://arxiv.org/abs/1609.01609"" rel=""nofollow noreferrer"">Cold Thermal Atoms</a></li>
<li><a href=""https://academic.oup.com/nsr/article/5/3/346/4430770"" rel=""nofollow noreferrer"">NV Center in Diamond</a></li>
<li>Some interferometry(e.g. Ramsey interferometer, <a href=""https://en.wikipedia.org/wiki/Mach%E2%80%93Zehnder_interferometer"" rel=""nofollow noreferrer"">MZ interferometer</a>)</li>
</ul>
",How is quantum metrology realized in experiment?,<resource-request><quantum-metrology>,0,3,,,"How is quantum metrology realized in experiment? <p>Are there some lists of the method to realize quantum metrology, or rather, utilizing quantum resources to enhance the precision of parameter estimation. The experimental method I've know is listed as follows:</p>
<ul>
<li><a href=""https://arxiv.org/abs/1609.01609"" rel=""nofollow noreferrer"">Trapped Ions</a></li>
<li><a href=""https://arxiv.org/abs/1609.01609"" rel=""nofollow noreferrer"">Bose-Einstein Condenstates</a></li>
<li><a href=""https://arxiv.org/abs/1609.01609"" rel=""nofollow noreferrer"">Cold Thermal Atoms</a></li>
<li><a href=""https://academic.oup.com/nsr/article/5/3/346/4430770"" rel=""nofollow noreferrer"">NV Center in Diamond</a></li>
<li>Some interferometry(e.g. Ramsey interferometer, <a href=""https://en.wikipedia.org/wiki/Mach%E2%80%93Zehnder_interferometer"" rel=""nofollow noreferrer"">MZ interferometer</a>)</li>
</ul>
",qc,quantum metrology realized experiment p lists method realize quantum metrology rather utilizing quantum resources enhance precision parameter estimation experimental method know listed follows ul li https nofollow noreferrer trapped ions li https nofollow noreferrer condenstates li https nofollow noreferrer cold thermal atoms li https nofollow noreferrer nv center diamond li interferometry ramsey interferometer https e2 80 nofollow noreferrer mz interferometer,"[(4, 0.33067575), (5, 0.01826508), (7, 0.30600473), (9, 0.17705728), (11, 0.07042698), (12, 0.05362129), (18, 0.041672453)]"
21541,21544.0,2021-10-14 13:15:24,4,670,"<p>I need some help on <code>stim</code>, where I'm trying to compute expectation values of Pauli strings. Hopefully I did not overlook on the documentation an implementation of this method.</p>
<h1><strong>Problem Statement</strong></h1>
<p>Given a generic Pauli string <span class=""math-container"">$O$</span> acting on <span class=""math-container"">$N$</span> qubits and a stabilizer state <span class=""math-container"">$\rho$</span> on <span class=""math-container"">$N$</span> qubits, compute within <code>stim</code> the expectation value
<span class=""math-container"">\begin{equation}
\langle O\rangle \equiv \mathrm{Tr}(O \rho).
\end{equation}</span>
Since <span class=""math-container"">$O$</span> is a Pauli string, <span class=""math-container"">$\langle O\rangle \in \{0,+1,-1\}$</span>.</p>
<h1><strong>Tentative Solution</strong></h1>
<p>To be concrete, within this question I fix <span class=""math-container"">$N=4$</span>, and I want to compute <span class=""math-container"">$\mathrm{Tr}(X_1 Z_3 \rho)$</span>. Furthermore, I specify I work on the <code>c++</code> library, within which my state is contained in an instance of <code>TableauSimulator</code>:</p>
<pre><code>...
using namespace stim;
using namespace std;

mt19937_64 rng(1); // Random generator with SEED=1
MeasureRecord record; // Measurement records
TableauSimulator Psi(ref(rng),4,0,record); 
// 0 is the unbiased-condition of the output sign for non-deterministic measurements

...
</code></pre>
<p>Now, I know I can apply a measurement gate <code>MPP X1Z3</code>. If this measurement is deterministic (equivalently, if <span class=""math-container"">$X1Z3$</span> commute with <span class=""math-container"">$\rho$</span>), the measurement readout gives <span class=""math-container"">$\langle O\rangle$</span>, which is either <span class=""math-container"">$+1$</span> or <span class=""math-container"">$-1$</span>.
If, instead, the measurement is non-deterministic (equivalently, if <span class=""math-container"">$X1Z3$</span> anticommute with <span class=""math-container"">$\rho$</span>), <span class=""math-container"">$\langle O\rangle=0$</span>.
Given the above, I tried the following. I initialize two new <code>TableauSimulator</code></p>
<pre><code>TableauSimulator PsiPlus = Psi;
TableauSimulator PsiMinus = Psi;
</code></pre>
<p>and applied to them <code>PsiPlus</code> the gate <code>MPP X1Z3</code>, whereas in <code>PsiMinus</code> the gate <code>MPP !X1Z3</code>. Then, since in general
<span class=""math-container"">\begin{equation}
\langle O\rangle = \mathrm{Tr}(O\rho) = \mathrm{Tr}\left(\frac{1+O}{2}\rho\right) -\mathrm{Tr}\left(\frac{1-O}{2}\rho\right) = p(+1) - p(-1),
\end{equation}</span>
I expect the difference:</p>
<pre><code>int aveO = PsiPlus.measurement_record.storage[last_entry]-PsiMinus.measurement_record.storage[last_entry];
</code></pre>
<p>where last_entry is the index of the last measurement (respectively of <code>MPP X1Z3</code> for <code>PsiPlus</code> and <code>MPP !X1Z3</code> for <code>PsiMinus</code>) should be the required value <span class=""math-container"">$\langle O\rangle$</span>.</p>
<p><strong>Problems</strong> There are problems with the above approach/ideas/implementation. It works if the measurement is deterministic, but it in general it doesn't for non-deterministic measurements (which is the main issue to solve). I think the reason is, since both states refer to the same random generator, the randomness in PsiPlus and PsiMinus are inequivalent, leading to different results (e.g. different internally drawn random numbers).
Furthermore, the operations required can be probably reduced.
Lastly, I conclude with a remark.
For single site measurements, the above issue do not figure in the present release of <code>stim</code>, as there is a method <code>TableauSimulator.is_deterministic_x</code> (and similarly for y,z) which should exactly check if the outcome of <code>MX</code> (<code>MY</code>,<code>MZ</code>) is deterministic or not. If a similar method would be present for generic <code>MPP</code>, probably a solution would still be easily implementable. In <em>pseudo-code</em>:</p>
<pre><code>int aveO;
if (Psi.is_deterministic_mpp(`X1Z3`,{1,3}) {
    TableauSimulator PsiM = Psi;
    PsiM.apply_mpp(`X1Z3`,{1,3});
    aveO = PsiM.measurement_record.storage[last_item];
}
</code></pre>
<p>Still, I'm not an expect in HPC, but probably there are smarter way to implement the computation of expectation values.</p>
",Computing expectation value of a Pauli string on stabilizer states,<programming><stabilizer-state><stim>,1,0,,,"Computing expectation value of a Pauli string on stabilizer states <p>I need some help on <code>stim</code>, where I'm trying to compute expectation values of Pauli strings. Hopefully I did not overlook on the documentation an implementation of this method.</p>
<h1><strong>Problem Statement</strong></h1>
<p>Given a generic Pauli string <span class=""math-container"">$O$</span> acting on <span class=""math-container"">$N$</span> qubits and a stabilizer state <span class=""math-container"">$\rho$</span> on <span class=""math-container"">$N$</span> qubits, compute within <code>stim</code> the expectation value
<span class=""math-container"">\begin{equation}
\langle O\rangle \equiv \mathrm{Tr}(O \rho).
\end{equation}</span>
Since <span class=""math-container"">$O$</span> is a Pauli string, <span class=""math-container"">$\langle O\rangle \in \{0,+1,-1\}$</span>.</p>
<h1><strong>Tentative Solution</strong></h1>
<p>To be concrete, within this question I fix <span class=""math-container"">$N=4$</span>, and I want to compute <span class=""math-container"">$\mathrm{Tr}(X_1 Z_3 \rho)$</span>. Furthermore, I specify I work on the <code>c++</code> library, within which my state is contained in an instance of <code>TableauSimulator</code>:</p>
<pre><code>...
using namespace stim;
using namespace std;

mt19937_64 rng(1); // Random generator with SEED=1
MeasureRecord record; // Measurement records
TableauSimulator Psi(ref(rng),4,0,record); 
// 0 is the unbiased-condition of the output sign for non-deterministic measurements

...
</code></pre>
<p>Now, I know I can apply a measurement gate <code>MPP X1Z3</code>. If this measurement is deterministic (equivalently, if <span class=""math-container"">$X1Z3$</span> commute with <span class=""math-container"">$\rho$</span>), the measurement readout gives <span class=""math-container"">$\langle O\rangle$</span>, which is either <span class=""math-container"">$+1$</span> or <span class=""math-container"">$-1$</span>.
If, instead, the measurement is non-deterministic (equivalently, if <span class=""math-container"">$X1Z3$</span> anticommute with <span class=""math-container"">$\rho$</span>), <span class=""math-container"">$\langle O\rangle=0$</span>.
Given the above, I tried the following. I initialize two new <code>TableauSimulator</code></p>
<pre><code>TableauSimulator PsiPlus = Psi;
TableauSimulator PsiMinus = Psi;
</code></pre>
<p>and applied to them <code>PsiPlus</code> the gate <code>MPP X1Z3</code>, whereas in <code>PsiMinus</code> the gate <code>MPP !X1Z3</code>. Then, since in general
<span class=""math-container"">\begin{equation}
\langle O\rangle = \mathrm{Tr}(O\rho) = \mathrm{Tr}\left(\frac{1+O}{2}\rho\right) -\mathrm{Tr}\left(\frac{1-O}{2}\rho\right) = p(+1) - p(-1),
\end{equation}</span>
I expect the difference:</p>
<pre><code>int aveO = PsiPlus.measurement_record.storage[last_entry]-PsiMinus.measurement_record.storage[last_entry];
</code></pre>
<p>where last_entry is the index of the last measurement (respectively of <code>MPP X1Z3</code> for <code>PsiPlus</code> and <code>MPP !X1Z3</code> for <code>PsiMinus</code>) should be the required value <span class=""math-container"">$\langle O\rangle$</span>.</p>
<p><strong>Problems</strong> There are problems with the above approach/ideas/implementation. It works if the measurement is deterministic, but it in general it doesn't for non-deterministic measurements (which is the main issue to solve). I think the reason is, since both states refer to the same random generator, the randomness in PsiPlus and PsiMinus are inequivalent, leading to different results (e.g. different internally drawn random numbers).
Furthermore, the operations required can be probably reduced.
Lastly, I conclude with a remark.
For single site measurements, the above issue do not figure in the present release of <code>stim</code>, as there is a method <code>TableauSimulator.is_deterministic_x</code> (and similarly for y,z) which should exactly check if the outcome of <code>MX</code> (<code>MY</code>,<code>MZ</code>) is deterministic or not. If a similar method would be present for generic <code>MPP</code>, probably a solution would still be easily implementable. In <em>pseudo-code</em>:</p>
<pre><code>int aveO;
if (Psi.is_deterministic_mpp(`X1Z3`,{1,3}) {
    TableauSimulator PsiM = Psi;
    PsiM.apply_mpp(`X1Z3`,{1,3});
    aveO = PsiM.measurement_record.storage[last_item];
}
</code></pre>
<p>Still, I'm not an expect in HPC, but probably there are smarter way to implement the computation of expectation values.</p>
",qc,computing expectation value pauli string stabilizer states p need help code stim trying compute expectation values pauli strings hopefully overlook documentation implementation h1 strong problem statement p given generic pauli string span acting span n qubits stabilizer state span span n qubits compute within code stim expectation value span equation tr equation since span pauli string span 0 h1 strong tentative solution p concrete within question fix span want compute span tr furthermore specify work code library within state contained instance code tableausimulator pre code using namespace stim using namespace std rng 1 random generator measurerecord record measurement records tableausimulator psi ref rng record 0 output sign measurements p know apply measurement gate code mpp x1z3 measurement deterministic equivalently span x1z3 commute span measurement readout gives span either span span instead measurement equivalently span x1z3 anticommute span span given tried following initialize two new code tableausimulator pre code tableausimulator psiplus psi tableausimulator psiminus psi p applied code psiplus gate code mpp x1z3 whereas code psiminus gate code mpp x1z3 since general span equation tr tr 2 tr 2 p p equation expect difference pre code int aveo p index last measurement respectively code mpp x1z3 code psiplus code mpp x1z3 code psiminus required value span p strong problems problems works measurement deterministic general measurements main issue solve think reason since states refer random generator randomness psiplus psiminus inequivalent leading different results different internally drawn random numbers furthermore operations required probably reduced lastly conclude remark single site measurements issue figure present release code stim method code similarly z exactly check outcome code mx code code mz deterministic similar method would present generic code mpp probably solution would still easily implementable em pre code int aveo x1z3 tableausimulator psim psi x1z3 aveo p still expect hpc probably smarter way implement computation expectation,"[(0, 0.1149766), (1, 0.018390141), (3, 0.3482645), (5, 0.09037255), (12, 0.031117627), (13, 0.040570002), (14, 0.3465612)]"
21677,,2021-10-26 07:26:36,1,511,"<p>We all know that quantum computing is rapidly developing and somehow being used in the AI field. However, it seems like there's no specific comparison between quantum machine learning (could be deep learning) and classical machine learning.</p>
<p>D-wave has a quantum computer (annealer) and own library as well as pennylane (Xanadu) and IBM, even Google. My question is &quot;are these devices really run hybrid or quantum machine learning?&quot;.</p>
",Is quantum machine learning faster than classical machine learning (at the moment)?,<machine-learning><quantum-enhanced-machine-learning><artificial-intelligence>,1,1,,,"Is quantum machine learning faster than classical machine learning (at the moment)? <p>We all know that quantum computing is rapidly developing and somehow being used in the AI field. However, it seems like there's no specific comparison between quantum machine learning (could be deep learning) and classical machine learning.</p>
<p>D-wave has a quantum computer (annealer) and own library as well as pennylane (Xanadu) and IBM, even Google. My question is &quot;are these devices really run hybrid or quantum machine learning?&quot;.</p>
",qc,quantum machine learning faster classical machine learning moment p know quantum computing rapidly developing somehow used ai field however seems like specific comparison quantum machine learning could deep learning classical machine p quantum computer annealer library well pennylane xanadu ibm even google question quot devices really run hybrid quantum machine learning quot,"[(4, 0.02278464), (8, 0.81807554), (9, 0.021192253), (12, 0.0194062), (13, 0.05224135), (15, 0.020215148), (19, 0.04358761)]"
21747,,2021-11-01 03:58:54,1,157,"<p>The definition of a 2-RDM is <span class=""math-container"">$D_{ijkl}=\langle\psi|a_i^{\dagger}a_j^{\dagger}a_k a_l|\psi\rangle,i,,j,k,l\in[0,N-1]$</span>, where <span class=""math-container"">$N$</span> is the number of qubits/ orbitals in the quantum system.I am trying to use the following code to get the 2-RDM for a given state and the eigenvalue for the 2-RDM,</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.circuit.library import HartreeFock
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
from qiskit_nature.operators.second_quantization import FermionicOp
from qiskit.opflow import Z, X, I, StateFn, CircuitStateFn, SummedOp
from qiskit.opflow.converters import CircuitSampler
from qiskit.utils import QuantumInstance
from qiskit.opflow import expectations
import itertools
matplotlib.use('Agg')


mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=False)
num_particles = (2, 2)
num_spin_orbitals = 6
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)

init_state1 = QuantumCircuit(num_spin_orbitals)

init_state1.h(0)
init_state1.h(1)
print(init_state1)


def get_rdm(init_state):
    two_rdm = np.zeros((num_spin_orbitals,) * 4)
    for i, j, k, l in itertools.product(range(num_spin_orbitals), repeat=4):
        # if i != j and k != l:
        s = &quot;+_{i} +_{j} -_{k} -_{l}&quot;.format(i=str(i),j=str(j),k=str(k),l=str(l))
        fermi_term = FermionicOp(s, register_length=num_spin_orbitals)
        qubit_term = converter.convert(fermi_term, num_particles=num_particles)

        # Evaluate the Hamiltonian term w.r.t. the given state
        # temp = (~init_state @ qubit_term @ init_state).eval()
        temp = ~StateFn(qubit_term) @ CircuitStateFn(primitive=init_state, coeff=1.)
        temp = int(temp.eval())

        two_rdm[i,j,k,l] = temp

    return two_rdm

# rdm1 = rdm(init_state)
# print('--------------')
two_rdm = get_rdm(init_state1)


# Transpose of the 2-RDM
two_rdm = np.transpose(two_rdm, (0, 1, 3, 2))
two_rdm = two_rdm.reshape((num_spin_orbitals ** 2, num_spin_orbitals ** 2))
# SVD of the 2-RDM
a, b = np.linalg.eig(two_rdm)
print(a)

u, s, vh = np.linalg.svd(two_rdm, full_matrices=True)
print(s)
print(s.sum())
</code></pre>
<p>For the Hartree Fock state, the eigenvalues of the corresponding 2-RDM output six non-zero elements, which all are <span class=""math-container"">$2$</span>. In my opinion, the eigenvalues of the 2-RDM stand for the meaning that probability of two electron residing in the corresponding two orbitals. Therefore, the eigenvalue should be from zero to one.</p>
",Problems when computing the two-electron reduced density matrix (2-RDM) by qiskit,<qiskit><programming>,0,0,,,"Problems when computing the two-electron reduced density matrix (2-RDM) by qiskit <p>The definition of a 2-RDM is <span class=""math-container"">$D_{ijkl}=\langle\psi|a_i^{\dagger}a_j^{\dagger}a_k a_l|\psi\rangle,i,,j,k,l\in[0,N-1]$</span>, where <span class=""math-container"">$N$</span> is the number of qubits/ orbitals in the quantum system.I am trying to use the following code to get the 2-RDM for a given state and the eigenvalue for the 2-RDM,</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.circuit.library import HartreeFock
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
from qiskit_nature.operators.second_quantization import FermionicOp
from qiskit.opflow import Z, X, I, StateFn, CircuitStateFn, SummedOp
from qiskit.opflow.converters import CircuitSampler
from qiskit.utils import QuantumInstance
from qiskit.opflow import expectations
import itertools
matplotlib.use('Agg')


mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=False)
num_particles = (2, 2)
num_spin_orbitals = 6
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)

init_state1 = QuantumCircuit(num_spin_orbitals)

init_state1.h(0)
init_state1.h(1)
print(init_state1)


def get_rdm(init_state):
    two_rdm = np.zeros((num_spin_orbitals,) * 4)
    for i, j, k, l in itertools.product(range(num_spin_orbitals), repeat=4):
        # if i != j and k != l:
        s = &quot;+_{i} +_{j} -_{k} -_{l}&quot;.format(i=str(i),j=str(j),k=str(k),l=str(l))
        fermi_term = FermionicOp(s, register_length=num_spin_orbitals)
        qubit_term = converter.convert(fermi_term, num_particles=num_particles)

        # Evaluate the Hamiltonian term w.r.t. the given state
        # temp = (~init_state @ qubit_term @ init_state).eval()
        temp = ~StateFn(qubit_term) @ CircuitStateFn(primitive=init_state, coeff=1.)
        temp = int(temp.eval())

        two_rdm[i,j,k,l] = temp

    return two_rdm

# rdm1 = rdm(init_state)
# print('--------------')
two_rdm = get_rdm(init_state1)


# Transpose of the 2-RDM
two_rdm = np.transpose(two_rdm, (0, 1, 3, 2))
two_rdm = two_rdm.reshape((num_spin_orbitals ** 2, num_spin_orbitals ** 2))
# SVD of the 2-RDM
a, b = np.linalg.eig(two_rdm)
print(a)

u, s, vh = np.linalg.svd(two_rdm, full_matrices=True)
print(s)
print(s.sum())
</code></pre>
<p>For the Hartree Fock state, the eigenvalues of the corresponding 2-RDM output six non-zero elements, which all are <span class=""math-container"">$2$</span>. In my opinion, the eigenvalues of the 2-RDM stand for the meaning that probability of two electron residing in the corresponding two orbitals. Therefore, the eigenvalue should be from zero to one.</p>
",qc,problems computing reduced density matrix qiskit p definition span ijkl k 0 span n number orbitals quantum trying use following code get given state eigenvalue pre code qiskit import import numpy np operator imports import z x circuit imports import hartreefock qiskit import aer import jordanwignermapper import qubitconverter import vqe numpyminimumeigensolver import plt import matplotlib import import fermionicop import z x statefn circuitstatefn summedop import circuitsampler import quantuminstance import expectations import itertools mapper jordanwignermapper converter qubitconverter 2 2 6 hartreefock converter quantumcircuit 0 1 print def 4 j k l range j k l quot j k l quot j k l fermionicop evaluate hamiltonian term given state temp temp circuitstatefn temp int j k l temp return rdm1 rdm print transpose 0 1 3 2 2 2 svd b print u vh print print p hartree fock state eigenvalues corresponding output six elements span 2 opinion eigenvalues stand meaning probability two electron residing corresponding two orbitals therefore eigenvalue zero,"[(0, 0.49389377), (2, 0.09403901), (3, 0.2505395), (4, 0.017697616), (7, 0.014223563), (8, 0.03261313), (10, 0.026392624), (11, 0.015075608), (12, 0.013911065), (19, 0.040929414)]"
21852,,2021-11-09 04:44:40,1,297,"<p>I use the following code to calculate the ground state for the LiH molecule in an active space. I come across two problems. The first is I found that the Hartree Fock state gave energy that is far from the ground state energy. But the <code>qc</code> state is the true Hartree Fock state. The second problem is using the <code>ground_state</code>, it just outputs <code>0</code>. Can anybody help me with that?</p>
<pre><code>from qiskit import *
import numpy as np

#Circuit imports
from qiskit_nature.drivers import UnitsType
from qiskit_nature.drivers.second_quantization import PySCFDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.opflow.state_fns import StateFn, CircuitStateFn
import matplotlib
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity, Statevector
matplotlib.use('Agg')
np.set_printoptions(threshold=np.inf)

driver = PySCFDriver(atom='H .0, .0, .0; Li .0, .0, 0.5',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

# set parameters
molecule = &quot;LiH&quot;
set_as = True # set the active space or not
as_particle = 2 # number of particles in the active space
as_mol_orbital = 3 # number of molecular orbitals in the active space
at = ActiveSpaceTransformer(as_particle, as_mol_orbital, active_orbitals=[1,2,5])
ft = FreezeCoreTransformer()
as_problem = ElectronicStructureProblem(driver, transformers=[at])

# generate the second-quantized operators for active space
as_second_q_ops = as_problem.second_q_ops()
as_main_op = as_second_q_ops[0]

as_particle_number = as_problem.grouped_property_transformed.get_property(&quot;ParticleNumber&quot;)
as_num_particles = (as_particle_number.num_alpha, as_particle_number.num_beta)
as_num_spin_orbitals = as_particle_number.num_spin_orbitals

as_qubit_op = converter.convert(main_op, num_particles=num_particles)
as_init_state = HartreeFock(as_num_spin_orbitals, as_num_particles, converter)
qc = QuantumCircuit(as_num_spin_orbitals)
qc.x(1)
qc.x(3)

# calculate the energy
numpy_solver = NumPyMinimumEigensolver()
calc = GroundStateEigensolver(converter, numpy_solver)
calc.returns_groundstate()
as_res_ref = calc.solve(as_problem)
ground_state = as_res_ref.eigenstates[0]
print('G.S. energy is', as_res_ref.eigenenergies.min())
gse = (~ground_state @ as_qubit_op @ ground_state).eval()
print('Second G.S. energy is',gse)

e = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=as_init_state, coeff=1.)
e = e.eval()
print('HF state energy is',e)
e2 = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=qc, coeff=1.)
e2 = e2.eval()
print('qc state energy is',e2)
<span class=""math-container"">```</span>
</code></pre>
",Ground state compute issue by qiskit,<qiskit><programming><vqe>,0,4,,,"Ground state compute issue by qiskit <p>I use the following code to calculate the ground state for the LiH molecule in an active space. I come across two problems. The first is I found that the Hartree Fock state gave energy that is far from the ground state energy. But the <code>qc</code> state is the true Hartree Fock state. The second problem is using the <code>ground_state</code>, it just outputs <code>0</code>. Can anybody help me with that?</p>
<pre><code>from qiskit import *
import numpy as np

#Circuit imports
from qiskit_nature.drivers import UnitsType
from qiskit_nature.drivers.second_quantization import PySCFDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.opflow.state_fns import StateFn, CircuitStateFn
import matplotlib
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity, Statevector
matplotlib.use('Agg')
np.set_printoptions(threshold=np.inf)

driver = PySCFDriver(atom='H .0, .0, .0; Li .0, .0, 0.5',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

# set parameters
molecule = &quot;LiH&quot;
set_as = True # set the active space or not
as_particle = 2 # number of particles in the active space
as_mol_orbital = 3 # number of molecular orbitals in the active space
at = ActiveSpaceTransformer(as_particle, as_mol_orbital, active_orbitals=[1,2,5])
ft = FreezeCoreTransformer()
as_problem = ElectronicStructureProblem(driver, transformers=[at])

# generate the second-quantized operators for active space
as_second_q_ops = as_problem.second_q_ops()
as_main_op = as_second_q_ops[0]

as_particle_number = as_problem.grouped_property_transformed.get_property(&quot;ParticleNumber&quot;)
as_num_particles = (as_particle_number.num_alpha, as_particle_number.num_beta)
as_num_spin_orbitals = as_particle_number.num_spin_orbitals

as_qubit_op = converter.convert(main_op, num_particles=num_particles)
as_init_state = HartreeFock(as_num_spin_orbitals, as_num_particles, converter)
qc = QuantumCircuit(as_num_spin_orbitals)
qc.x(1)
qc.x(3)

# calculate the energy
numpy_solver = NumPyMinimumEigensolver()
calc = GroundStateEigensolver(converter, numpy_solver)
calc.returns_groundstate()
as_res_ref = calc.solve(as_problem)
ground_state = as_res_ref.eigenstates[0]
print('G.S. energy is', as_res_ref.eigenenergies.min())
gse = (~ground_state @ as_qubit_op @ ground_state).eval()
print('Second G.S. energy is',gse)

e = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=as_init_state, coeff=1.)
e = e.eval()
print('HF state energy is',e)
e2 = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=qc, coeff=1.)
e2 = e2.eval()
print('qc state energy is',e2)
<span class=""math-container"">```</span>
</code></pre>
",qc,ground state compute issue qiskit p use following code calculate ground state lih molecule active space come across two problems first found hartree fock state gave energy far ground state energy code qc state true hartree fock state second problem using code outputs code 0 anybody help pre code qiskit import import numpy np circuit imports import unitstype import pyscfdriver import electronicstructureproblem import hartreefock import freezecoretransformer activespacetransformer import groundstateeigensolver import eigenstateresult qiskit import aer import paritymapper jordanwignermapper import qubitconverter import vqe numpyminimumeigensolver import statefn circuitstatefn import matplotlib import import statevector driver pyscfdriver h li set parameters molecule quot lih quot true set active space 2 number particles active space 3 number molecular orbitals active space activespacetransformer ft freezecoretransformer electronicstructureproblem driver generate operators active space 0 quot particlenumber quot hartreefock converter qc quantumcircuit 1 3 calculate energy numpyminimumeigensolver calc groundstateeigensolver converter 0 print energy gse print energy gse e circuitstatefn e print state energy e e2 circuitstatefn e2 print state energy e2 span,"[(0, 0.46991947), (2, 0.031786963), (8, 0.119148016), (12, 0.035118025), (17, 0.21228895), (18, 0.097197026), (19, 0.025000855)]"
21879,21880.0,2021-11-11 05:37:11,4,273,"<p>Consider generalizations of the <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""nofollow noreferrer"">GHZ</a> state and the <a href=""https://en.wikipedia.org/wiki/W_state"" rel=""nofollow noreferrer"">W</a> state to <span class=""math-container"">$n$</span> qubits.</p>
<p>What is the Schmidt number of these two states for any bipartition <span class=""math-container"">$ c n $</span> and <span class=""math-container"">$(1 - c) ~n $</span>, for <span class=""math-container"">$c &lt; 1$</span>?</p>
<p>Does it depend on the bipartition chosen?</p>
",What is the Schmidt number of generalized GHZ and W states?,<quantum-state><entanglement>,1,0,,,"What is the Schmidt number of generalized GHZ and W states? <p>Consider generalizations of the <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""nofollow noreferrer"">GHZ</a> state and the <a href=""https://en.wikipedia.org/wiki/W_state"" rel=""nofollow noreferrer"">W</a> state to <span class=""math-container"">$n$</span> qubits.</p>
<p>What is the Schmidt number of these two states for any bipartition <span class=""math-container"">$ c n $</span> and <span class=""math-container"">$(1 - c) ~n $</span>, for <span class=""math-container"">$c &lt; 1$</span>?</p>
<p>Does it depend on the bipartition chosen?</p>
",qc,schmidt number generalized ghz w states p consider generalizations https e2 80 93horne e2 80 nofollow noreferrer ghz state https nofollow noreferrer w state span n p schmidt number two states bipartition span c n span 1 c span c lt 1 p depend bipartition chosen,"[(3, 0.5979473), (4, 0.15625526), (5, 0.05112575), (12, 0.09616696), (18, 0.09518464)]"
21991,22011.0,2021-11-19 13:17:42,0,251,"<p>It is stated in the Phase Estimation algorithm in <a href=""http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf"" rel=""nofollow noreferrer"">Page 222, Quantum Computation and Quantum Information by Nielsen and Chuang</a> that</p>
<p><a href=""https://i.sstatic.net/KQzaA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KQzaA.png"" alt=""ph1"" /></a></p>
<p><a href=""https://i.sstatic.net/If77p.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/If77p.png"" alt=""ph2"" /></a></p>
<p><a href=""https://i.sstatic.net/nIVho.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nIVho.png"" alt=""ph3"" /></a></p>
<hr />
<p>It seems to say that taking the inverse Quantum Fourier transform of the state gives
<span class=""math-container"">$$
|\phi_1\cdots\phi_t\rangle
$$</span></p>
<p>That means the state <span class=""math-container"">$\frac{1}{2^{t/2}}(|0\rangle+e^{2\pi i0.\phi_t}|1\rangle)(|0\rangle+e^{2\pi i0.\phi_{t-1}\phi_t}|1\rangle)\cdots (|0\rangle+e^{2\pi i0.\phi_{1}\cdots\phi_t}|1\rangle)$</span> is the Quantum Fourier transform of the state <span class=""math-container"">$|\phi_1\cdots\phi_t\rangle$</span>.</p>
<p>But in the section of the derivation of the QFT it is given</p>
<hr />
<p><a href=""https://i.sstatic.net/5U3SE.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5U3SE.png"" alt=""ph4"" /></a></p>
<hr />
<p>As per Eq. 5.5 to 5.10 <span class=""math-container"">$$\frac{(|0\rangle+e^{2\pi i0.\phi_t}|1\rangle)(|0\rangle+e^{2\pi i0.\phi_{t-1}\phi_t}|1\rangle)\cdots (|0\rangle+e^{2\pi i0.\phi_{1}\cdots\phi_t}|1\rangle)}{2^{t/2}}=\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}e^{2\pi i\phi k/\color{red}{2^t}}|k\rangle$$</span> But equations 5.20-5.21-5.22 seem to consider it is equal to <span class=""math-container"">$\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}e^{2\pi i\phi k}|k\rangle$</span>. How do I make sense of this ?</p>
",Equating the state of the Phase Estimation algorithm to $\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1} e^{2\pi i\phi k}|k\rangle$,<textbook-and-exercises><nielsen-and-chuang><quantum-fourier-transform><quantum-phase-estimation>,1,1,,,"Equating the state of the Phase Estimation algorithm to $\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1} e^{2\pi i\phi k}|k\rangle$ <p>It is stated in the Phase Estimation algorithm in <a href=""http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf"" rel=""nofollow noreferrer"">Page 222, Quantum Computation and Quantum Information by Nielsen and Chuang</a> that</p>
<p><a href=""https://i.sstatic.net/KQzaA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KQzaA.png"" alt=""ph1"" /></a></p>
<p><a href=""https://i.sstatic.net/If77p.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/If77p.png"" alt=""ph2"" /></a></p>
<p><a href=""https://i.sstatic.net/nIVho.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nIVho.png"" alt=""ph3"" /></a></p>
<hr />
<p>It seems to say that taking the inverse Quantum Fourier transform of the state gives
<span class=""math-container"">$$
|\phi_1\cdots\phi_t\rangle
$$</span></p>
<p>That means the state <span class=""math-container"">$\frac{1}{2^{t/2}}(|0\rangle+e^{2\pi i0.\phi_t}|1\rangle)(|0\rangle+e^{2\pi i0.\phi_{t-1}\phi_t}|1\rangle)\cdots (|0\rangle+e^{2\pi i0.\phi_{1}\cdots\phi_t}|1\rangle)$</span> is the Quantum Fourier transform of the state <span class=""math-container"">$|\phi_1\cdots\phi_t\rangle$</span>.</p>
<p>But in the section of the derivation of the QFT it is given</p>
<hr />
<p><a href=""https://i.sstatic.net/5U3SE.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5U3SE.png"" alt=""ph4"" /></a></p>
<hr />
<p>As per Eq. 5.5 to 5.10 <span class=""math-container"">$$\frac{(|0\rangle+e^{2\pi i0.\phi_t}|1\rangle)(|0\rangle+e^{2\pi i0.\phi_{t-1}\phi_t}|1\rangle)\cdots (|0\rangle+e^{2\pi i0.\phi_{1}\cdots\phi_t}|1\rangle)}{2^{t/2}}=\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}e^{2\pi i\phi k/\color{red}{2^t}}|k\rangle$$</span> But equations 5.20-5.21-5.22 seem to consider it is equal to <span class=""math-container"">$\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}e^{2\pi i\phi k}|k\rangle$</span>. How do I make sense of this ?</p>
",qc,equating state phase estimation algorithm 1 k p stated phase estimation algorithm http nofollow noreferrer page 222 quantum computation quantum information nielsen chuang p https nofollow noreferrer img https ph1 p https nofollow noreferrer img https ph2 p https nofollow noreferrer img https ph3 hr p seems say taking inverse quantum fourier transform state gives span p means state span 1 1 quantum fourier transform state span p section derivation qft given hr p https nofollow noreferrer img https ph4 hr p per eq span 1 1 red equations seem consider equal span 1 k make sense,"[(2, 0.042500705), (3, 0.40641123), (4, 0.36262116), (7, 0.17563555), (12, 0.0112042185)]"
22113,,2021-11-29 00:01:02,3,458,"<p>Suppose I have a list of numbers from 0 to 32, that is <span class=""math-container"">$ [0,1,2....31, 32].$</span> I want to find a number <span class=""math-container"">$n$</span> in this list such that it satisfies a property, say <span class=""math-container"">$n$</span> is prime. How would I translate this to an Oracle that can be used with Grovers's Algorithm in Qiskit?</p>
<p>I am following <a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#Unstructured-Search"" rel=""nofollow noreferrer"">this</a> guide but, it seems like the general pattern to the solution is already known in this Sudoku example, that is the pattern of the bits of a potential solution is known and it can be checked.</p>
<p>What if there isn't a general pattern? How would you implement an oracle to look through the list, check each item and return the one that matches some criteria?</p>
<p>I'm following the same code in the link referenced above but, changing the <code>sudoku_oracle</code> to my own custom function.</p>
<p>Any help is appreciated, thanks.</p>
",Qiskit Implementation of Grover's Algorithm to search a list,<qiskit><grovers-algorithm>,1,0,,,"Qiskit Implementation of Grover's Algorithm to search a list <p>Suppose I have a list of numbers from 0 to 32, that is <span class=""math-container"">$ [0,1,2....31, 32].$</span> I want to find a number <span class=""math-container"">$n$</span> in this list such that it satisfies a property, say <span class=""math-container"">$n$</span> is prime. How would I translate this to an Oracle that can be used with Grovers's Algorithm in Qiskit?</p>
<p>I am following <a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#Unstructured-Search"" rel=""nofollow noreferrer"">this</a> guide but, it seems like the general pattern to the solution is already known in this Sudoku example, that is the pattern of the bits of a potential solution is known and it can be checked.</p>
<p>What if there isn't a general pattern? How would you implement an oracle to look through the list, check each item and return the one that matches some criteria?</p>
<p>I'm following the same code in the link referenced above but, changing the <code>sudoku_oracle</code> to my own custom function.</p>
<p>Any help is appreciated, thanks.</p>
",qc,qiskit implementation grover algorithm search list p suppose list numbers 0 32 span 31 32 want find number span n list satisfies property say span n prime would translate oracle used grovers algorithm qiskit p following https nofollow noreferrer guide seems like general pattern solution already known sudoku example pattern bits potential solution known p general pattern would implement oracle look list check item return one matches criteria p following code link referenced changing code custom p help appreciated,"[(0, 0.025829861), (2, 0.028271351), (3, 0.156394), (4, 0.07468396), (7, 0.3788811), (12, 0.012793474), (14, 0.3215029)]"
22156,,2021-12-01 23:55:12,1,255,"<p><span class=""math-container"">$\newcommand{\ket}[1]{|#1 \rangle}$</span>
<span class=""math-container"">$\newcommand{\bra}[1]{\langle #1 |}$</span></p>
<p>PS: I suppose this question could also ask &quot;How to implement <span class=""math-container"">$2 \ket{s}\bra{s} - I$</span> for <em>any</em> (identifiable) <span class=""math-container"">$\ket{s} \in \mathcal{H}_A \subset \mathcal{H}$</span>&quot; (in Quirks)?</p>
<p>I am struggling to implement a nested Grover search on gate level, e.g. in quirk (<a href=""https://algassert.com/quirk"" rel=""nofollow noreferrer"">https://algassert.com/quirk</a>).
(Essentially, I was following this paper: <a href=""https://arxiv.org/pdf/quant-ph/9806078.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/quant-ph/9806078.pdf</a>)</p>
<h3>Setup</h3>
<p>Consider the Hilbert space <span class=""math-container"">$\mathcal{H} = \mathcal{H}_A \otimes \mathcal{H}_B$</span>,
with <span class=""math-container"">$\mathcal{H} = \mathbb{C}^{2^n}$</span>,
such that there are <span class=""math-container"">$2^n$</span> elements in <span class=""math-container"">$\mathcal{H}$</span> (respectively <span class=""math-container"">$n_A, n_B$</span> for <span class=""math-container"">$\mathcal{H}_A, \mathcal{H}_B$</span>).
(Also, sorry for slight abuse of set-formalisms here)</p>
<p>We are given a function
<span class=""math-container"">$f_A(x) = \begin{cases}
1 \Leftrightarrow x \in \mathcal{H}_A,\\
0 \text{ otherwise}
\end{cases} \qquad$</span>
and <span class=""math-container"">$f_a(x) = \begin{cases}
1 \Leftrightarrow x \in M,\\
0 \text{ otherwise}
\end{cases}$</span></p>
<h3>Grover Search</h3>
<p>... on any element in <span class=""math-container"">$H_A$</span> performs the following steps:</p>
<ol start=""0"">
<li>Create uniform superposition: <span class=""math-container"">$\ket{\psi_0} =  H^{\otimes n'}$</span></li>
<li>Repeat about <span class=""math-container"">$\frac{4}{\pi} \sqrt{N/n_A}$</span> times:
<ul>
<li>Define Circuit <span class=""math-container"">$G_A$</span>:
<ul>
<li>Apply oracle: <span class=""math-container"">$\ket{\psi_{A,1}} =  U_{f_A} \ket{\psi_0}$</span></li>
<li>Apply Diffusion on <span class=""math-container"">$\mathcal{H}$</span>: <span class=""math-container"">$\ket{\psi_{A, 2}} = 2 \ket{\psi_{A,1}} \bra{\psi_{a,1}} - I$</span></li>
</ul>
</li>
</ul>
</li>
<li>The resulting state is close to <span class=""math-container"">$\ket{x} \in \mathcal{H}_A$</span>.</li>
</ol>
<p>where
<span class=""math-container"">$2 \ket{\psi_{A,1}} \bra{\psi_{A,1}} - I$</span> is implemented via: <span class=""math-container"">$H^{\otimes n} (I - 2\ket{0}\bra{0}) H^{\otimes n}$</span></p>
<h3>Nested Grover Search</h3>
<p>... to find a elements <span class=""math-container"">$a \in M \subset\mathcal{H_A}$</span>.
... first creates a superposition over <span class=""math-container"">$\mathcal{H}_A$</span> via a search using the function <span class=""math-container"">$f_A$</span>, then searches that subspace via function <span class=""math-container"">$f_a$</span>:</p>
<ol>
<li>Create uniform superposition: <span class=""math-container"">$\ket{\psi_0} =  H^{\otimes n}$</span></li>
<li>Repeat about <span class=""math-container"">$\sqrt{n_a/ |M|}$</span> times:
<ul>
<li>Define Function G_{Aa}
<ul>
<li>Apply <span class=""math-container"">$G_A$</span> about <span class=""math-container"">$\frac{4}{\pi} \sqrt{N/n_A}$</span> times
// Now <span class=""math-container"">$\ket{\psi_{A, 2}}$</span> is (close to) a superposition of <span class=""math-container"">$\ket{x} \in \mathcal{H}_A$</span></li>
<li>
<ol start=""2"">
<li>Apply oracle: <span class=""math-container"">$\ket{\psi_{a,1}} =  U_{f_a} \psi_{A,2}$</span></li>
</ol>
</li>
<li>Apply Diffusion on <span class=""math-container"">$\mathcal{H_A}$</span>: <span class=""math-container"">$\ket{\psi_{a,2}} = 2 \ket{\psi_{A,2}} \bra{\psi_{A,2}} - I$</span></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>where<br />
<span class=""math-container"">$2 \ket{\psi_{A,2}} \bra{\psi_{A,2}} - I$</span> is implemented via: <span class=""math-container"">$G_A (I - 2\ket{0}\bra{0}) G_A^{\dagger}$</span></p>
<h3>Simple Instantiation</h3>
<p>For simplicity, consider <span class=""math-container"">$n=4$</span> such that the database are the numbers from <span class=""math-container"">$0,1,... 15$</span>. Our target values are <span class=""math-container"">$M = \{2\}$</span> ('10'), hence a single element.</p>
<ul>
<li><p>We first identify the number in <span class=""math-container"">$a \in \mathcal{H}_A$</span> with <span class=""math-container"">$f_A(x) = 1 \leftrightarrow x \leq 3$</span>. For this particular example <span class=""math-container"">$G_A$</span> has to be applied once to get <span class=""math-container"">$\psi_{A,2} = \sqrt{1/4} \sum_{x=0}^{3} \ket{x}$</span>.</p>
</li>
<li><p>Then we identify <span class=""math-container"">$a$</span> with <span class=""math-container"">$f_a(x) = 1 \leftrightarrow x \leq 2$</span>.
In theory, a single call to the oracle should be sufficient here too.</p>
</li>
</ul>
<p>Since <span class=""math-container"">$\sqrt{\frac{n_a}{|M|}} = 1$</span> I suppose we would need to iterations of the complete circuit. In my implementation (<a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22%7Elcdf%22,1,1,%22%7Egb97%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A6%22%5D,%5B%22%7Ebbrs%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA%3CB%22,%7B%22id%22:%22setB%22,%22arg%22:4%7D%5D,%5B%5D,%5B%22%7Ell24%22%5D,%5B%22Chance4%22%5D,%5B%22%E2%80%A6%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA=B%22,%22setB%22%5D,%5B%5D,%5B%22%E2%80%A6%22%5D,%5B%22%7Ebbrs%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA%3CB%22,%7B%22id%22:%22setB%22,%22arg%22:4%7D%5D,%5B%22%7Ell24%22%5D,%5B%22%7E9djj%22%5D,%5B%22%7Ell24%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA%3CB%22,%7B%22id%22:%22setB%22,%22arg%22:4%7D%5D,%5B%22%7Ebbrs%22%5D,%5B%22Chance4%22%5D%5D,%22gates%22:%5B%7B%22id%22:%22%7Ennks%22,%22name%22:%22X%20x4%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7Ebbrs%22,%22name%22:%22H%20x4%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D%5D%7D%7D,%7B%22id%22:%22%7E8pf0%22,%22name%22:%22I%20-%202%20%7C1%3E%3C1%7C%22,%22circuit%22:%7B%22cols%22:%5B%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22Z%22%5D%5D%7D%7D,%7B%22id%22:%22%7Elcdf%22,%22name%22:%22(lsb)%22,%22circuit%22:%7B%22cols%22:%5B%5B%22%E2%80%A6%22%5D%5D%7D%7D,%7B%22id%22:%22%7Egb97%22,%22name%22:%22(msb)%22,%22circuit%22:%7B%22cols%22:%5B%5B%22%E2%80%A6%22%5D%5D%7D%7D,%7B%22id%22:%22%7Ell24%22,%22name%22:%222%20%7CD%3E%3CD%7C%20-%20I%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22Z%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22H%22,%22H%22,%22H%22,%22H%22%5D%5D%7D%7D,%7B%22id%22:%22%7E9djj%22,%22name%22:%22I%20-%202%20%7C0%3E%3C0%7C%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22Z%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22%5D%5D%7D%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk Nested Grover</a>); after one step of each '10' clearly has a larger amplitude than the other states, but not close to 100%.</p>
<ol>
<li>What is wrong about my intuition on a <strong>nested</strong> Grover search?</li>
<li>And/ or how do I implement this in Quirk?</li>
<li>If this is not a good example, do you know a <strong>simple</strong> example that can be implemented? (I would prefer an implementation in Quirk, Q# would be okay'ish too ;))</li>
</ol>
",How to implement *nested* Grover search (in Quirk)?,<quantum-gate><grovers-algorithm><quirk>,1,0,,,"How to implement *nested* Grover search (in Quirk)? <p><span class=""math-container"">$\newcommand{\ket}[1]{|#1 \rangle}$</span>
<span class=""math-container"">$\newcommand{\bra}[1]{\langle #1 |}$</span></p>
<p>PS: I suppose this question could also ask &quot;How to implement <span class=""math-container"">$2 \ket{s}\bra{s} - I$</span> for <em>any</em> (identifiable) <span class=""math-container"">$\ket{s} \in \mathcal{H}_A \subset \mathcal{H}$</span>&quot; (in Quirks)?</p>
<p>I am struggling to implement a nested Grover search on gate level, e.g. in quirk (<a href=""https://algassert.com/quirk"" rel=""nofollow noreferrer"">https://algassert.com/quirk</a>).
(Essentially, I was following this paper: <a href=""https://arxiv.org/pdf/quant-ph/9806078.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/quant-ph/9806078.pdf</a>)</p>
<h3>Setup</h3>
<p>Consider the Hilbert space <span class=""math-container"">$\mathcal{H} = \mathcal{H}_A \otimes \mathcal{H}_B$</span>,
with <span class=""math-container"">$\mathcal{H} = \mathbb{C}^{2^n}$</span>,
such that there are <span class=""math-container"">$2^n$</span> elements in <span class=""math-container"">$\mathcal{H}$</span> (respectively <span class=""math-container"">$n_A, n_B$</span> for <span class=""math-container"">$\mathcal{H}_A, \mathcal{H}_B$</span>).
(Also, sorry for slight abuse of set-formalisms here)</p>
<p>We are given a function
<span class=""math-container"">$f_A(x) = \begin{cases}
1 \Leftrightarrow x \in \mathcal{H}_A,\\
0 \text{ otherwise}
\end{cases} \qquad$</span>
and <span class=""math-container"">$f_a(x) = \begin{cases}
1 \Leftrightarrow x \in M,\\
0 \text{ otherwise}
\end{cases}$</span></p>
<h3>Grover Search</h3>
<p>... on any element in <span class=""math-container"">$H_A$</span> performs the following steps:</p>
<ol start=""0"">
<li>Create uniform superposition: <span class=""math-container"">$\ket{\psi_0} =  H^{\otimes n'}$</span></li>
<li>Repeat about <span class=""math-container"">$\frac{4}{\pi} \sqrt{N/n_A}$</span> times:
<ul>
<li>Define Circuit <span class=""math-container"">$G_A$</span>:
<ul>
<li>Apply oracle: <span class=""math-container"">$\ket{\psi_{A,1}} =  U_{f_A} \ket{\psi_0}$</span></li>
<li>Apply Diffusion on <span class=""math-container"">$\mathcal{H}$</span>: <span class=""math-container"">$\ket{\psi_{A, 2}} = 2 \ket{\psi_{A,1}} \bra{\psi_{a,1}} - I$</span></li>
</ul>
</li>
</ul>
</li>
<li>The resulting state is close to <span class=""math-container"">$\ket{x} \in \mathcal{H}_A$</span>.</li>
</ol>
<p>where
<span class=""math-container"">$2 \ket{\psi_{A,1}} \bra{\psi_{A,1}} - I$</span> is implemented via: <span class=""math-container"">$H^{\otimes n} (I - 2\ket{0}\bra{0}) H^{\otimes n}$</span></p>
<h3>Nested Grover Search</h3>
<p>... to find a elements <span class=""math-container"">$a \in M \subset\mathcal{H_A}$</span>.
... first creates a superposition over <span class=""math-container"">$\mathcal{H}_A$</span> via a search using the function <span class=""math-container"">$f_A$</span>, then searches that subspace via function <span class=""math-container"">$f_a$</span>:</p>
<ol>
<li>Create uniform superposition: <span class=""math-container"">$\ket{\psi_0} =  H^{\otimes n}$</span></li>
<li>Repeat about <span class=""math-container"">$\sqrt{n_a/ |M|}$</span> times:
<ul>
<li>Define Function G_{Aa}
<ul>
<li>Apply <span class=""math-container"">$G_A$</span> about <span class=""math-container"">$\frac{4}{\pi} \sqrt{N/n_A}$</span> times
// Now <span class=""math-container"">$\ket{\psi_{A, 2}}$</span> is (close to) a superposition of <span class=""math-container"">$\ket{x} \in \mathcal{H}_A$</span></li>
<li>
<ol start=""2"">
<li>Apply oracle: <span class=""math-container"">$\ket{\psi_{a,1}} =  U_{f_a} \psi_{A,2}$</span></li>
</ol>
</li>
<li>Apply Diffusion on <span class=""math-container"">$\mathcal{H_A}$</span>: <span class=""math-container"">$\ket{\psi_{a,2}} = 2 \ket{\psi_{A,2}} \bra{\psi_{A,2}} - I$</span></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>where<br />
<span class=""math-container"">$2 \ket{\psi_{A,2}} \bra{\psi_{A,2}} - I$</span> is implemented via: <span class=""math-container"">$G_A (I - 2\ket{0}\bra{0}) G_A^{\dagger}$</span></p>
<h3>Simple Instantiation</h3>
<p>For simplicity, consider <span class=""math-container"">$n=4$</span> such that the database are the numbers from <span class=""math-container"">$0,1,... 15$</span>. Our target values are <span class=""math-container"">$M = \{2\}$</span> ('10'), hence a single element.</p>
<ul>
<li><p>We first identify the number in <span class=""math-container"">$a \in \mathcal{H}_A$</span> with <span class=""math-container"">$f_A(x) = 1 \leftrightarrow x \leq 3$</span>. For this particular example <span class=""math-container"">$G_A$</span> has to be applied once to get <span class=""math-container"">$\psi_{A,2} = \sqrt{1/4} \sum_{x=0}^{3} \ket{x}$</span>.</p>
</li>
<li><p>Then we identify <span class=""math-container"">$a$</span> with <span class=""math-container"">$f_a(x) = 1 \leftrightarrow x \leq 2$</span>.
In theory, a single call to the oracle should be sufficient here too.</p>
</li>
</ul>
<p>Since <span class=""math-container"">$\sqrt{\frac{n_a}{|M|}} = 1$</span> I suppose we would need to iterations of the complete circuit. In my implementation (<a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22%7Elcdf%22,1,1,%22%7Egb97%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A6%22%5D,%5B%22%7Ebbrs%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA%3CB%22,%7B%22id%22:%22setB%22,%22arg%22:4%7D%5D,%5B%5D,%5B%22%7Ell24%22%5D,%5B%22Chance4%22%5D,%5B%22%E2%80%A6%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA=B%22,%22setB%22%5D,%5B%5D,%5B%22%E2%80%A6%22%5D,%5B%22%7Ebbrs%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA%3CB%22,%7B%22id%22:%22setB%22,%22arg%22:4%7D%5D,%5B%22%7Ell24%22%5D,%5B%22%7E9djj%22%5D,%5B%22%7Ell24%22%5D,%5B%22inputA4%22,1,1,1,%22%5EA%3CB%22,%7B%22id%22:%22setB%22,%22arg%22:4%7D%5D,%5B%22%7Ebbrs%22%5D,%5B%22Chance4%22%5D%5D,%22gates%22:%5B%7B%22id%22:%22%7Ennks%22,%22name%22:%22X%20x4%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7Ebbrs%22,%22name%22:%22H%20x4%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D%5D%7D%7D,%7B%22id%22:%22%7E8pf0%22,%22name%22:%22I%20-%202%20%7C1%3E%3C1%7C%22,%22circuit%22:%7B%22cols%22:%5B%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22Z%22%5D%5D%7D%7D,%7B%22id%22:%22%7Elcdf%22,%22name%22:%22(lsb)%22,%22circuit%22:%7B%22cols%22:%5B%5B%22%E2%80%A6%22%5D%5D%7D%7D,%7B%22id%22:%22%7Egb97%22,%22name%22:%22(msb)%22,%22circuit%22:%7B%22cols%22:%5B%5B%22%E2%80%A6%22%5D%5D%7D%7D,%7B%22id%22:%22%7Ell24%22,%22name%22:%222%20%7CD%3E%3CD%7C%20-%20I%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22Z%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22H%22,%22H%22,%22H%22,%22H%22%5D%5D%7D%7D,%7B%22id%22:%22%7E9djj%22,%22name%22:%22I%20-%202%20%7C0%3E%3C0%7C%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22Z%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22%5D%5D%7D%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk Nested Grover</a>); after one step of each '10' clearly has a larger amplitude than the other states, but not close to 100%.</p>
<ol>
<li>What is wrong about my intuition on a <strong>nested</strong> Grover search?</li>
<li>And/ or how do I implement this in Quirk?</li>
<li>If this is not a good example, do you know a <strong>simple</strong> example that can be implemented? (I would prefer an implementation in Quirk, Q# would be okay'ish too ;))</li>
</ol>
",qc,implement nested grover search quirk p span 1 1 span 1 1 p ps suppose question could also ask quot implement span 2 em identifiable span h h quot quirks p struggling implement nested grover search gate level quirk https nofollow noreferrer https essentially following paper https nofollow noreferrer https h3 setup p consider hilbert space span h h h span h c span elements span h respectively span span h h also sorry slight abuse p given function span x cases 1 x h 0 otherwise cases span x cases 1 x 0 otherwise cases h3 grover search p element span performs following steps ol 0 li create uniform superposition span n li repeat span 4 times ul li define circuit span ul li apply oracle span li apply diffusion span h span 2 2 li resulting state close span x h p span 2 implemented via span n 0 0 n h3 nested grover search p find elements span first creates superposition span h via search using function span searches subspace via function span ol li create uniform superposition span n li repeat span times ul li define function aa ul li apply span span 4 times span 2 close superposition span x h li ol 2 li apply oracle span li apply diffusion span span 2 p br span 2 implemented via span 0 0 h3 simple instantiation p simplicity consider span database numbers span 15 target values span hence single ul li p first identify number span h span x 1 x 3 particular example span applied get span 3 x li p identify span span x 1 x 2 theory single call oracle sufficient p since span 1 suppose would need iterations complete circuit implementation https 7b 22cols 22 5b 5b 22 7elcdf 22 7egb97 22 22x 22 5d 22h 22 5d 5b 22 e2 80 a6 22 5d 5b 22 7ebbrs 22 5d 5b 22inputa4 22 5ea 3cb 22 7b 22id 22 22setb 22 22arg 7d 5d 5b 5d 5b 22 7ell24 22 5d 5b 22chance4 22 5d 5b 22 e2 80 a6 22 5d 5b 22inputa4 22 22 22setb 22 5d 5b 5d 5b 22 e2 80 a6 22 5d 5b 22 7ebbrs 22 5d 5b 22inputa4 22 5ea 3cb 22 7b 22id 22 22setb 22 22arg 7d 5d 5b 22 7ell24 22 5d 5b 22 7e9djj 22 5d 5b 22 7ell24 22 5d 5b 22inputa4 22 5ea 3cb 22 7b 22id 22 22setb 22 22arg 7d 5d 5b 22 7ebbrs 22 5d 5b 22chance4 22 5d 5d 22gates 22 5b 7b 22id 22 22 7ennks 22 22name 22 22x 20x4 22 22circuit 22 7b 22cols 22 5b 5b 22x 22 22x 22 22x 22 22x 22 5d 5d 7d 7d 7b 22id 22 22 7ebbrs 22 22name 22 22h 20x4 22 22circuit 22 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 5d 5d 7d 7d 7b 22id 22 22 7e8pf0 22 22name 22 22i 202 20 7c1 3e 3c1 7c 22 22circuit 22 7b 22cols 22 5b 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22z 22 5d 5d 7d 7d 7b 22id 22 22 7elcdf 22 22name 22 22 lsb 22 22circuit 22 7b 22cols 22 5b 5b 22 e2 80 a6 22 5d 5d 7d 7d 7b 22id 22 22 7egb97 22 22name 22 22 msb 22 22circuit 22 7b 22cols 22 5b 5b 22 e2 80 a6 22 5d 5d 7d 7d 7b 22id 22 22 7ell24 22 22name 22 222 20 7cd 3e 3cd 7c 20i 22 22circuit 22 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 5d 5b 22x 22 22x 22 22x 22 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22z 22 5d 5b 22x 22 22x 22 22x 22 22x 22 5d 5b 22h 22 22h 22 22h 22 22h 22 5d 5d 7d 7d 7b 22id 22 22 7e9djj 22 22name 22 22i 202 20 7c0 3e 3c0 7c 22 22circuit 22 7b 22cols 22 5b 5b 22x 22 22x 22 22x 22 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22z 22 5d 5b 22x 22 22x 22 22x 22 22x 22 5d 5d 7d 7d 5d 7d nofollow noreferrer quirk nested grover one step clearly larger amplitude states close 100 ol li wrong intuition strong nested grover search li implement quirk li good example know strong simple example implemented would prefer implementation quirk q would,"[(2, 0.037714332), (3, 0.16479288), (7, 0.10253026), (10, 0.033043377), (12, 0.58042973), (18, 0.06913991)]"
22169,,2021-12-03 06:37:33,2,59,"<p>I'm running a QPE algorithm on the amazon-braket but it can only apply on a 2<em>2 or 4</em>4 matrix, when I want to expand it into a 5*5 or more, it will come an error. As I know, there is no theoretical limitation on the size of matrix QPE can solve.</p>
<p>Here is the main part of the code:</p>
<pre><code>def get_qpe_phases(measurement_counts, precision_qubits, items_to_keep=1):
    bitstrings_precision_register = [
        substring(key, precision_qubits) for key in measurement_counts.keys()
    ]
    bitstrings_precision_register_set = set(bitstrings_precision_register)
    bitstrings_precision_register_list = list(bitstrings_precision_register_set)
    precision_results_dic = {key: 0 for key in bitstrings_precision_register_list}

    for key in measurement_counts.keys():
        counts = measurement_counts[key]
        count_key = substring(key, precision_qubits)
        precision_results_dic[count_key] += counts

    c = Counter(precision_results_dic)
    topmost = c.most_common(items_to_keep)
    phases_decimal = [binaryToDecimal(item[0]) for item in topmost]

    return phases_decimal, precision_results_dic


def run_qpe(
    unitary,
    precision_qubits,
    query_qubits,
    query_circuit,
    items_to_keep=1,
    shots=1000
):
    circ = query_circuit
    circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False)

    # Add desired results_types
    
    number_precision_qubits = len(precision_qubits)
    
    num_qubits = len(precision_qubits)
    circ.probability(np.array(precision_qubits))
    device = LocalSimulator()
    task=device.run(circ,shots=shots)
    result=task.result()
    metadata = result.task_metadata

    probs_values = result.values[0]
    measurements = result.measurements
    measured_qubits = result.measured_qubits
    measurement_counts = result.measurement_counts
    measurement_probabilities = result.measurement_probabilities
    format_bitstring = &quot;{0:0&quot; + str(num_qubits) + &quot;b}&quot;
    bitstring_keys = [format_bitstring.format(ii) for ii in range(2 ** num_qubits)]


    phases_decimal, precision_results_dic = get_qpe_phases(
        measurement_counts, precision_qubits, items_to_keep
    )
    
    print('\nPhases:',phases_decimal)
    
    eigenvalues = [np.exp(2 * np.pi * 1j * phase) for phase in phases_decimal]

    # aggregate results
    out = {
        &quot;circuit&quot;: circ,
        &quot;task_metadata&quot;: metadata,
        &quot;measurements&quot;: measurements,
        &quot;measured_qubits&quot;: measured_qubits,
        &quot;measurement_counts&quot;: measurement_counts,
        &quot;measurement_probabilities&quot;: measurement_probabilities,
        &quot;probs_values&quot;: probs_values,
        &quot;bitstring_keys&quot;: bitstring_keys,
        &quot;precision_results_dic&quot;: precision_results_dic,
        &quot;phases_decimal&quot;: phases_decimal,
        &quot;eigenvalues&quot;: eigenvalues,
    }

    return out
</code></pre>
<p>And when it comes to a 6*6 matrix,</p>
<pre><code>from scipy.stats import unitary_group
import numpy as np
np.random.seed(seed=3000)

unitary1 = unitary_group.rvs(6)
result = estimate_phase(4,unitary1,5,printcir=False)
</code></pre>
<p>the error report is like:</p>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-21-4eae0beac402&gt; in &lt;module&gt;
      4 
      5 unitary = unitary_group.rvs(6)
----&gt; 6 result = estimate_phase(4,unitary,5,printcir=False)

&lt;ipython-input-9-30dffae9e6c6&gt; in estimate_phase(n, unitary, runit, shots, printcir)
     15     query = Circuit().h(query_qubits)
     16 
---&gt; 17     result = run_qpe(unitary, precision_qubits, query_qubits, query, items_to_keep=elen, shots = shots)
     18     qeigvals= postprocess_qpe_results(result,printcir)
     19 

&lt;ipython-input-6-1875e0e5a610&gt; in run_qpe(unitary, precision_qubits, query_qubits, query_circuit, items_to_keep, shots)
     92 ):
     93     circ = query_circuit
---&gt; 94     circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False)
     95 
     96     # Add desired results_types

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs)
     75 
     76         def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn:
---&gt; 77             return self.add(func, *args, **kwargs)
     78 
     79         function_name = func.__name__

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs)
    495                 self.add_circuit(item, *args, **kwargs)
    496             elif callable(item):
--&gt; 497                 self.add(item(*args, **kwargs))
    498             else:
    499                 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;)

&lt;ipython-input-6-1875e0e5a610&gt; in qpe(precision_qubits, query_qubits, unitary, control_unitary)
     39         else:
     40             for _ in range(2 ** power):
---&gt; 41                 qpe_circ.controlled_unitary(qubit, query_qubits, unitary)
     42     qpe_circ.inverse_qft(precision_qubits)
     43 

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs)
     75 
     76         def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn:
---&gt; 77             return self.add(func, *args, **kwargs)
     78 
     79         function_name = func.__name__

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs)
    495                 self.add_circuit(item, *args, **kwargs)
    496             elif callable(item):
--&gt; 497                 self.add(item(*args, **kwargs))
    498             else:
    499                 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;)

&lt;ipython-input-6-1875e0e5a610&gt; in controlled_unitary(control, target_qubits, unitary)
     21     targets = [control] + target_qubits
     22 
---&gt; 23     circ.unitary(matrix=controlled_matrix, targets=targets)
     24 
     25     return circ

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs)
     75 
     76         def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn:
---&gt; 77             return self.add(func, *args, **kwargs)
     78 
     79         function_name = func.__name__

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs)
    495                 self.add_circuit(item, *args, **kwargs)
    496             elif callable(item):
--&gt; 497                 self.add(item(*args, **kwargs))
    498             else:
    499                 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;)

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/gates.py in unitary(targets, matrix, display_name)
   1339         &quot;&quot;&quot;
   1340         if 2 ** len(targets) != matrix.shape[0]:
-&gt; 1341             raise ValueError(&quot;Dimensions of the supplied unitary are incompatible with the targets&quot;)
   1342 
   1343         return Instruction(Gate.Unitary(matrix, display_name), target=targets)

ValueError: Dimensions of the supplied unitary are incompatible with the targets
</code></pre>
<p>So I'm wondering if it's the packages' problem or the program problem or any other had met the similar problem as I?</p>
<p>Thanks in advance!</p>
",Applying QPE on a large matrix on amazon-braket,<programming><hamiltonian-simulation><quantum-phase-estimation><amazon-braket>,1,0,,,"Applying QPE on a large matrix on amazon-braket <p>I'm running a QPE algorithm on the amazon-braket but it can only apply on a 2<em>2 or 4</em>4 matrix, when I want to expand it into a 5*5 or more, it will come an error. As I know, there is no theoretical limitation on the size of matrix QPE can solve.</p>
<p>Here is the main part of the code:</p>
<pre><code>def get_qpe_phases(measurement_counts, precision_qubits, items_to_keep=1):
    bitstrings_precision_register = [
        substring(key, precision_qubits) for key in measurement_counts.keys()
    ]
    bitstrings_precision_register_set = set(bitstrings_precision_register)
    bitstrings_precision_register_list = list(bitstrings_precision_register_set)
    precision_results_dic = {key: 0 for key in bitstrings_precision_register_list}

    for key in measurement_counts.keys():
        counts = measurement_counts[key]
        count_key = substring(key, precision_qubits)
        precision_results_dic[count_key] += counts

    c = Counter(precision_results_dic)
    topmost = c.most_common(items_to_keep)
    phases_decimal = [binaryToDecimal(item[0]) for item in topmost]

    return phases_decimal, precision_results_dic


def run_qpe(
    unitary,
    precision_qubits,
    query_qubits,
    query_circuit,
    items_to_keep=1,
    shots=1000
):
    circ = query_circuit
    circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False)

    # Add desired results_types
    
    number_precision_qubits = len(precision_qubits)
    
    num_qubits = len(precision_qubits)
    circ.probability(np.array(precision_qubits))
    device = LocalSimulator()
    task=device.run(circ,shots=shots)
    result=task.result()
    metadata = result.task_metadata

    probs_values = result.values[0]
    measurements = result.measurements
    measured_qubits = result.measured_qubits
    measurement_counts = result.measurement_counts
    measurement_probabilities = result.measurement_probabilities
    format_bitstring = &quot;{0:0&quot; + str(num_qubits) + &quot;b}&quot;
    bitstring_keys = [format_bitstring.format(ii) for ii in range(2 ** num_qubits)]


    phases_decimal, precision_results_dic = get_qpe_phases(
        measurement_counts, precision_qubits, items_to_keep
    )
    
    print('\nPhases:',phases_decimal)
    
    eigenvalues = [np.exp(2 * np.pi * 1j * phase) for phase in phases_decimal]

    # aggregate results
    out = {
        &quot;circuit&quot;: circ,
        &quot;task_metadata&quot;: metadata,
        &quot;measurements&quot;: measurements,
        &quot;measured_qubits&quot;: measured_qubits,
        &quot;measurement_counts&quot;: measurement_counts,
        &quot;measurement_probabilities&quot;: measurement_probabilities,
        &quot;probs_values&quot;: probs_values,
        &quot;bitstring_keys&quot;: bitstring_keys,
        &quot;precision_results_dic&quot;: precision_results_dic,
        &quot;phases_decimal&quot;: phases_decimal,
        &quot;eigenvalues&quot;: eigenvalues,
    }

    return out
</code></pre>
<p>And when it comes to a 6*6 matrix,</p>
<pre><code>from scipy.stats import unitary_group
import numpy as np
np.random.seed(seed=3000)

unitary1 = unitary_group.rvs(6)
result = estimate_phase(4,unitary1,5,printcir=False)
</code></pre>
<p>the error report is like:</p>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-21-4eae0beac402&gt; in &lt;module&gt;
      4 
      5 unitary = unitary_group.rvs(6)
----&gt; 6 result = estimate_phase(4,unitary,5,printcir=False)

&lt;ipython-input-9-30dffae9e6c6&gt; in estimate_phase(n, unitary, runit, shots, printcir)
     15     query = Circuit().h(query_qubits)
     16 
---&gt; 17     result = run_qpe(unitary, precision_qubits, query_qubits, query, items_to_keep=elen, shots = shots)
     18     qeigvals= postprocess_qpe_results(result,printcir)
     19 

&lt;ipython-input-6-1875e0e5a610&gt; in run_qpe(unitary, precision_qubits, query_qubits, query_circuit, items_to_keep, shots)
     92 ):
     93     circ = query_circuit
---&gt; 94     circ.qpe(precision_qubits, query_qubits, unitary, control_unitary=False)
     95 
     96     # Add desired results_types

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs)
     75 
     76         def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn:
---&gt; 77             return self.add(func, *args, **kwargs)
     78 
     79         function_name = func.__name__

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs)
    495                 self.add_circuit(item, *args, **kwargs)
    496             elif callable(item):
--&gt; 497                 self.add(item(*args, **kwargs))
    498             else:
    499                 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;)

&lt;ipython-input-6-1875e0e5a610&gt; in qpe(precision_qubits, query_qubits, unitary, control_unitary)
     39         else:
     40             for _ in range(2 ** power):
---&gt; 41                 qpe_circ.controlled_unitary(qubit, query_qubits, unitary)
     42     qpe_circ.inverse_qft(precision_qubits)
     43 

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs)
     75 
     76         def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn:
---&gt; 77             return self.add(func, *args, **kwargs)
     78 
     79         function_name = func.__name__

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs)
    495                 self.add_circuit(item, *args, **kwargs)
    496             elif callable(item):
--&gt; 497                 self.add(item(*args, **kwargs))
    498             else:
    499                 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;)

&lt;ipython-input-6-1875e0e5a610&gt; in controlled_unitary(control, target_qubits, unitary)
     21     targets = [control] + target_qubits
     22 
---&gt; 23     circ.unitary(matrix=controlled_matrix, targets=targets)
     24 
     25     return circ

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in method_from_subroutine(self, *args, **kwargs)
     75 
     76         def method_from_subroutine(self, *args, **kwargs) -&gt; SubroutineReturn:
---&gt; 77             return self.add(func, *args, **kwargs)
     78 
     79         function_name = func.__name__

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/circuit.py in add(self, addable, *args, **kwargs)
    495                 self.add_circuit(item, *args, **kwargs)
    496             elif callable(item):
--&gt; 497                 self.add(item(*args, **kwargs))
    498             else:
    499                 raise TypeError(f&quot;Cannot add a '{type(item)}' to a Circuit&quot;)

~/anaconda3/envs/Braket/lib/python3.7/site-packages/braket/circuits/gates.py in unitary(targets, matrix, display_name)
   1339         &quot;&quot;&quot;
   1340         if 2 ** len(targets) != matrix.shape[0]:
-&gt; 1341             raise ValueError(&quot;Dimensions of the supplied unitary are incompatible with the targets&quot;)
   1342 
   1343         return Instruction(Gate.Unitary(matrix, display_name), target=targets)

ValueError: Dimensions of the supplied unitary are incompatible with the targets
</code></pre>
<p>So I'm wondering if it's the packages' problem or the program problem or any other had met the similar problem as I?</p>
<p>Thanks in advance!</p>
",qc,applying qpe large matrix p running qpe algorithm apply 2 em 2 4 4 matrix want expand 5 5 come error know theoretical limitation size matrix qpe p main part code pre code def substring key key set list key 0 key key counts key substring key counts c counter topmost binarytodecimal item 0 item topmost return def unitary circ unitary add desired len len device localsimulator circ metadata 0 measurements quot quot str quot b quot ii ii range 2 print eigenvalues 2 1j phase phase aggregate results quot circuit quot circ quot quot metadata quot measurements quot measurements quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot eigenvalues quot eigenvalues return p comes 6 6 matrix pre code import import numpy np unitary1 6 result 4 p error report like pre code valueerror traceback recent call last lt gt lt module gt 4 5 unitary 6 gt 6 result 4 lt gt n unitary runit shots printcir 15 query circuit 16 gt 17 result unitary query shots shots 18 result printcir 19 lt gt unitary shots 92 93 circ gt 94 unitary 95 96 add desired self args kwargs 75 76 def self args kwargs gt subroutinereturn gt 77 return func args kwargs 78 79 add self addable args kwargs 495 item args kwargs 496 elif callable item gt 497 item args kwargs 498 else 499 raise typeerror f quot add type item circuit quot lt gt qpe unitary 39 else 40 range 2 power gt 41 qubit unitary 42 43 self args kwargs 75 76 def self args kwargs gt subroutinereturn gt 77 return func args kwargs 78 79 add self addable args kwargs 495 item args kwargs 496 elif callable item gt 497 item args kwargs 498 else 499 raise typeerror f quot add type item circuit quot lt gt control unitary 21 targets control 22 gt 23 24 25 return circ self args kwargs 75 76 def self args kwargs gt subroutinereturn gt 77 return func args kwargs 78 79 add self addable args kwargs 495 item args kwargs 496 elif callable item gt 497 item args kwargs 498 else 499 raise typeerror f quot add type item circuit quot unitary targets matrix 1339 quot quot quot 1340 2 len targets 0 gt 1341 raise valueerror quot dimensions supplied unitary incompatible targets quot 1342 1343 return instruction matrix valueerror dimensions supplied unitary incompatible targets p wondering packages problem program problem met similar problem p thanks advance,"[(0, 0.45200017), (2, 0.05346177), (6, 0.0668228), (7, 0.061795704), (9, 0.012907746), (11, 0.022458453), (12, 0.027229693), (19, 0.29522425)]"
22274,,2021-12-14 06:23:25,4,130,"<p>Here is the link to the Dirac's three polarizer experiment.
<a href=""https://www.informationphilosopher.com/solutions/experiments/dirac_3-polarizers/"" rel=""nofollow noreferrer"">https://www.informationphilosopher.com/solutions/experiments/dirac_3-polarizers/</a></p>
<p>When a 90<span class=""math-container"">$^o$</span> and 0<span class=""math-container"">$^o$</span> polarizers are placed in front of each other, no light comes out of the other end.
When a 45<span class=""math-container"">$^o$</span> polarizing filter is placed between 90<span class=""math-container"">$^o$</span> and 0<span class=""math-container"">$^o$</span> filters, we surprisingly see light coming out from the setup.</p>
<p>A quantum explanation of polarization of light was given by Dirac.</p>
<p>However, I found a few sources where this is explained classically. The crux of their argument is that there are long molecules in the polarizer film. They not only attenuate the light but also rotate it. This combined effect can be used to explain the phenomenon classically.</p>
<p><a href=""http://alienryderflex.com/polarizer/"" rel=""nofollow noreferrer"">http://alienryderflex.com/polarizer/</a>
<a href=""https://qr.ae/pGqOMb"" rel=""nofollow noreferrer"">https://qr.ae/pGqOMb</a></p>
<p>Is this a good experiment to teach about Quantum Superposition. Is there is any flaw in the second argument?</p>
","If 3 polarizer experiment to teach quantum superposition can be explained classically, should it not be used to explain Quantum Mechanics?",<superposition>,1,0,,,"If 3 polarizer experiment to teach quantum superposition can be explained classically, should it not be used to explain Quantum Mechanics? <p>Here is the link to the Dirac's three polarizer experiment.
<a href=""https://www.informationphilosopher.com/solutions/experiments/dirac_3-polarizers/"" rel=""nofollow noreferrer"">https://www.informationphilosopher.com/solutions/experiments/dirac_3-polarizers/</a></p>
<p>When a 90<span class=""math-container"">$^o$</span> and 0<span class=""math-container"">$^o$</span> polarizers are placed in front of each other, no light comes out of the other end.
When a 45<span class=""math-container"">$^o$</span> polarizing filter is placed between 90<span class=""math-container"">$^o$</span> and 0<span class=""math-container"">$^o$</span> filters, we surprisingly see light coming out from the setup.</p>
<p>A quantum explanation of polarization of light was given by Dirac.</p>
<p>However, I found a few sources where this is explained classically. The crux of their argument is that there are long molecules in the polarizer film. They not only attenuate the light but also rotate it. This combined effect can be used to explain the phenomenon classically.</p>
<p><a href=""http://alienryderflex.com/polarizer/"" rel=""nofollow noreferrer"">http://alienryderflex.com/polarizer/</a>
<a href=""https://qr.ae/pGqOMb"" rel=""nofollow noreferrer"">https://qr.ae/pGqOMb</a></p>
<p>Is this a good experiment to teach about Quantum Superposition. Is there is any flaw in the second argument?</p>
",qc,3 polarizer experiment teach quantum superposition explained classically used explain quantum mechanics p link dirac three polarizer experiment https nofollow noreferrer https p 90 span 0 span polarizers placed front light comes end 45 span polarizing filter placed 90 span 0 span filters surprisingly see light coming p quantum explanation polarization light given p however found sources explained classically crux argument long molecules polarizer film attenuate light also rotate combined effect used explain phenomenon p http nofollow noreferrer http https nofollow noreferrer https p good experiment teach quantum superposition flaw second argument,"[(2, 0.024202313), (3, 0.09465554), (4, 0.16861893), (6, 0.029227976), (8, 0.28508472), (9, 0.30487272), (12, 0.013027958), (13, 0.03611483), (18, 0.042945843)]"
22285,,2021-12-15 00:00:17,3,35,"<p>Assume a large combinatorial optimization problem should be solved (e.g. via Grover) and further assume there is a (near error free) universal quantum computer with a sufficient number of qubits (and sufficiently good quantum volume/clops/gate fidelity): is the wall clock time of the circuit execution neglectable (in comparison to a classical exhaustive search or branch&amp;bound)?</p>
<p>For instance, is it ok to assume that the execution of such a circuit for a TSP with thousands of cities only takes milliseconds or seconds? And even if thousands of shots are required, this would be faster by magnitudes than classical approaches.</p>
<p>So is it correct that once a (near perfect) quantum computer is available classical approaches can be easily beaten?</p>
",Is the execution of a circuit neglectable for large optimization problems?,<grovers-algorithm><optimization>,0,0,,,"Is the execution of a circuit neglectable for large optimization problems? <p>Assume a large combinatorial optimization problem should be solved (e.g. via Grover) and further assume there is a (near error free) universal quantum computer with a sufficient number of qubits (and sufficiently good quantum volume/clops/gate fidelity): is the wall clock time of the circuit execution neglectable (in comparison to a classical exhaustive search or branch&amp;bound)?</p>
<p>For instance, is it ok to assume that the execution of such a circuit for a TSP with thousands of cities only takes milliseconds or seconds? And even if thousands of shots are required, this would be faster by magnitudes than classical approaches.</p>
<p>So is it correct that once a (near perfect) quantum computer is available classical approaches can be easily beaten?</p>
",qc,execution circuit neglectable large optimization problems p assume large combinatorial optimization problem solved via grover assume near error free universal quantum computer sufficient number qubits sufficiently good quantum fidelity wall clock time circuit execution neglectable comparison classical exhaustive search branch amp bound p instance ok assume execution circuit tsp thousands cities takes milliseconds seconds even thousands shots required would faster magnitudes classical p correct near perfect quantum computer available classical approaches easily beaten,"[(1, 0.29159066), (3, 0.030395627), (4, 0.017090736), (7, 0.100203946), (8, 0.23989227), (11, 0.016432181), (12, 0.013896061), (14, 0.2729251), (15, 0.01592905)]"
23457,,2021-12-28 22:00:47,3,152,"<p>In the original paper (Quanum Mechanical Interaction-Free Measurements - Elitzur, Vaidman, p.991), they make an algebraic substitution for the 'appearance' or 'scattering' of the bomb (green arrow):</p>
<p><a href=""https://i.sstatic.net/6Vg0k.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6Vg0k.png"" alt=""enter image description here"" /></a></p>
<p>Can anyone shed any light on what this substitution is?  The &quot;up&quot; path (where the bomb lays) is <span class=""math-container"">$|2\rangle$</span>.  I do not see how (algebraically) the 'scattered' state is being introduced.</p>
<p>Thanks!</p>
<p><a href=""https://link.springer.com/article/10.1007/BF00736012"" rel=""nofollow noreferrer"">Abstract of paper</a></p>
<p><a href=""https://www.tau.ac.il/%7Evaidman/lvhp/m28.pdf"" rel=""nofollow noreferrer"">PDF of paper</a></p>
<p><a href=""https://en.wikipedia.org/wiki/Elitzur%E2%80%93Vaidman_bomb_tester#References"" rel=""nofollow noreferrer"">Wikipedia page</a></p>
",Elitzur-Vaidman bomb,<measurement>,1,0,,,"Elitzur-Vaidman bomb <p>In the original paper (Quanum Mechanical Interaction-Free Measurements - Elitzur, Vaidman, p.991), they make an algebraic substitution for the 'appearance' or 'scattering' of the bomb (green arrow):</p>
<p><a href=""https://i.sstatic.net/6Vg0k.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6Vg0k.png"" alt=""enter image description here"" /></a></p>
<p>Can anyone shed any light on what this substitution is?  The &quot;up&quot; path (where the bomb lays) is <span class=""math-container"">$|2\rangle$</span>.  I do not see how (algebraically) the 'scattered' state is being introduced.</p>
<p>Thanks!</p>
<p><a href=""https://link.springer.com/article/10.1007/BF00736012"" rel=""nofollow noreferrer"">Abstract of paper</a></p>
<p><a href=""https://www.tau.ac.il/%7Evaidman/lvhp/m28.pdf"" rel=""nofollow noreferrer"">PDF of paper</a></p>
<p><a href=""https://en.wikipedia.org/wiki/Elitzur%E2%80%93Vaidman_bomb_tester#References"" rel=""nofollow noreferrer"">Wikipedia page</a></p>
",qc,bomb p original paper quanum mechanical measurements elitzur vaidman make algebraic substitution bomb green arrow p https nofollow noreferrer img https enter image description p anyone shed light substitution quot quot path bomb lays span see algebraically state p thanks p https nofollow noreferrer abstract paper p https nofollow noreferrer pdf paper p https e2 80 references nofollow noreferrer wikipedia page,"[(3, 0.07619352), (4, 0.49007836), (7, 0.08281684), (9, 0.11231969), (12, 0.03788628), (13, 0.15854149), (19, 0.039760794)]"
23509,23532.0,2021-12-31 14:43:56,4,159,"<p>I am a bit puzzled on the following circuit. According to <a href=""https://quantumcomputing.stackexchange.com/questions/5567/circuit-construction-for-hamiltonian-simulation"">this Quantum Computing SE thread</a> it holds that
<span class=""math-container"">$$
e^{i(Z\otimes Z)t} = {\rm CNOT} (I\otimes e^{iZt}){\rm CNOT} \qquad (1)
$$</span></p>
<p>As a result we have the following circuit  (<strong>C1</strong>):<a href=""https://i.sstatic.net/BSi3N.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BSi3N.png"" alt=""enter image description here"" /></a></p>
<p>Furthermore, for <span class=""math-container"">$e^{iZ\otimes Z\otimes Z t}$</span> we obtain the following circuit (<strong>C2</strong>):</p>
<p><a href=""https://i.sstatic.net/7zBXb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7zBXb.png"" alt=""enter image description here"" /></a></p>
<p>I was reading arxiv:<a href=""https://arxiv.org/abs/2003.13599"" rel=""nofollow noreferrer"">2003.13599</a> and in Figure 3 we see three unitaries corresponding to <span class=""math-container"">$I\otimes Z \otimes I$</span>, <span class=""math-container"">$I \otimes Z \otimes Z$</span> and <span class=""math-container"">$Z \otimes Z \otimes I$</span> seen below (<strong>C3</strong>):
<a href=""https://i.sstatic.net/LdfhS.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LdfhS.png"" alt=""enter image description here"" /></a></p>
<p>Which is very confusing. Specifically, let's focus for example on the middle part of Diagram (a) corresponding to <span class=""math-container"">$I\otimes Z \otimes Z$</span>. The <span class=""math-container"">$I$</span> term (in the first qubit) can be ignored. Then, if we ignore the first wire we essentially should have the term <span class=""math-container"">$Z\otimes Z$</span> from Eq. (1) but nevertheless we see two pairs of CNOT gates just like in (<strong>C2</strong>) that corresponds to <span class=""math-container"">$e^{iZ\otimes Z \otimes Z t}$</span>.</p>
<p><strong>Why is this the case?</strong> I suspect this is somehow related to the extra wire we ( <strong>C2</strong> has three wires but for some reason <strong>C3</strong> has four).</p>
",Confusion with the number of CNOTs in a circuit,<quantum-gate><circuit-construction><quantum-circuit><gate-synthesis>,1,2,,,"Confusion with the number of CNOTs in a circuit <p>I am a bit puzzled on the following circuit. According to <a href=""https://quantumcomputing.stackexchange.com/questions/5567/circuit-construction-for-hamiltonian-simulation"">this Quantum Computing SE thread</a> it holds that
<span class=""math-container"">$$
e^{i(Z\otimes Z)t} = {\rm CNOT} (I\otimes e^{iZt}){\rm CNOT} \qquad (1)
$$</span></p>
<p>As a result we have the following circuit  (<strong>C1</strong>):<a href=""https://i.sstatic.net/BSi3N.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BSi3N.png"" alt=""enter image description here"" /></a></p>
<p>Furthermore, for <span class=""math-container"">$e^{iZ\otimes Z\otimes Z t}$</span> we obtain the following circuit (<strong>C2</strong>):</p>
<p><a href=""https://i.sstatic.net/7zBXb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7zBXb.png"" alt=""enter image description here"" /></a></p>
<p>I was reading arxiv:<a href=""https://arxiv.org/abs/2003.13599"" rel=""nofollow noreferrer"">2003.13599</a> and in Figure 3 we see three unitaries corresponding to <span class=""math-container"">$I\otimes Z \otimes I$</span>, <span class=""math-container"">$I \otimes Z \otimes Z$</span> and <span class=""math-container"">$Z \otimes Z \otimes I$</span> seen below (<strong>C3</strong>):
<a href=""https://i.sstatic.net/LdfhS.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LdfhS.png"" alt=""enter image description here"" /></a></p>
<p>Which is very confusing. Specifically, let's focus for example on the middle part of Diagram (a) corresponding to <span class=""math-container"">$I\otimes Z \otimes Z$</span>. The <span class=""math-container"">$I$</span> term (in the first qubit) can be ignored. Then, if we ignore the first wire we essentially should have the term <span class=""math-container"">$Z\otimes Z$</span> from Eq. (1) but nevertheless we see two pairs of CNOT gates just like in (<strong>C2</strong>) that corresponds to <span class=""math-container"">$e^{iZ\otimes Z \otimes Z t}$</span>.</p>
<p><strong>Why is this the case?</strong> I suspect this is somehow related to the extra wire we ( <strong>C2</strong> has three wires but for some reason <strong>C3</strong> has four).</p>
",qc,confusion number cnots circuit p bit puzzled following circuit according https quantum computing se thread holds span z cnot izt cnot 1 p result following circuit strong c1 https nofollow noreferrer img https enter image description p furthermore span z obtain following circuit strong c2 p https nofollow noreferrer img https enter image description p reading arxiv https nofollow noreferrer figure 3 see three unitaries corresponding span z span z z span z z seen strong c3 https nofollow noreferrer img https enter image description p confusing specifically let focus example middle part diagram corresponding span z z span term first qubit ignored ignore first wire essentially term span z eq 1 nevertheless see two pairs cnot gates like strong c2 corresponds span z z p strong case suspect somehow related extra wire strong c2 three wires reason strong c3 four,"[(0, 0.031027384), (3, 0.24132714), (4, 0.37340534), (5, 0.106375396), (9, 0.14388286), (12, 0.022208951), (13, 0.08084526)]"
23606,,2022-01-09 04:42:24,1,30,"<p>I am working on a project related to Boosting of Quantum Classifiers of PAC format. And I am a little confused about how do we go about implementing a PAC classifier. The basic idea is that we have to use multiple copies(say Q) of the state
<span class=""math-container"">$$
\sum_{x \in \{ 0,1 \}^n } \sqrt{D(x_i)} |x_i, y_i = c(x_i)&gt;
$$</span></p>
<p>where in order to train our classifier. On further exploring the <a href=""https://homepages.cwi.nl/%7Erdewolf/publ/qc/sigact_arxiv.pdf"" rel=""nofollow noreferrer"">paper</a> pointed out that we need to measure out the above state and then use the samples in order to train the classifier.</p>
<p>So assuming that I have access to such a state, would measuring out the state and then using Q states out of all the obtained states in order to train a classifier such as QNN or QSVM, accomplish the said task.</p>
<p>Furthermore lets say I have the <span class=""math-container"">$ D(x_i)$</span> and <span class=""math-container"">$(x_i, y_i)$</span> is there even any need to create the said state, or just directly using these to train our model enough ??</p>
",Implementation of Quantum PAC learning classifier,<quantum-enhanced-machine-learning>,0,0,,,"Implementation of Quantum PAC learning classifier <p>I am working on a project related to Boosting of Quantum Classifiers of PAC format. And I am a little confused about how do we go about implementing a PAC classifier. The basic idea is that we have to use multiple copies(say Q) of the state
<span class=""math-container"">$$
\sum_{x \in \{ 0,1 \}^n } \sqrt{D(x_i)} |x_i, y_i = c(x_i)&gt;
$$</span></p>
<p>where in order to train our classifier. On further exploring the <a href=""https://homepages.cwi.nl/%7Erdewolf/publ/qc/sigact_arxiv.pdf"" rel=""nofollow noreferrer"">paper</a> pointed out that we need to measure out the above state and then use the samples in order to train the classifier.</p>
<p>So assuming that I have access to such a state, would measuring out the state and then using Q states out of all the obtained states in order to train a classifier such as QNN or QSVM, accomplish the said task.</p>
<p>Furthermore lets say I have the <span class=""math-container"">$ D(x_i)$</span> and <span class=""math-container"">$(x_i, y_i)$</span> is there even any need to create the said state, or just directly using these to train our model enough ??</p>
",qc,implementation quantum pac learning classifier p working project related boosting quantum classifiers pac format little confused go implementing pac classifier basic idea use multiple copies say q state span x c gt p order train classifier exploring https nofollow noreferrer paper pointed need measure state use samples order train p assuming access state would measuring state using q states obtained states order train classifier qnn qsvm accomplish said p furthermore lets say span span even need create said state directly using train model enough,"[(3, 0.09597825), (4, 0.073289365), (8, 0.4112256), (10, 0.06816194), (12, 0.036504187), (13, 0.039063256), (14, 0.0821232), (18, 0.19220984)]"
23936,,2022-02-03 18:14:44,6,126,"<p>The &quot;<a href=""https://en.wikipedia.org/wiki/No_free_lunch_theorem"" rel=""noreferrer"">No Free Lunch Theorem</a>&quot; says: that when averaged across all possible problems, any two strategies have equivalent performance. However it uses Bayesian reasoning to arrive at this conclusion.</p>
<p>However, Bayesian reasoning employs <a href=""https://physics.stackexchange.com/a/510364/150174"">conditional probability</a> which does not hold in it's standard form in QM. Then the question becomes if I have 2 search algorithms in QM do they have
equivalent performance across all possible problems? Or in other words is No Free Lunch Theorem generalizable to Quantum Computation?</p>
",Is No Free Lunch Theorem generalizable to Quantum Computation?,<optimization>,0,0,,,"Is No Free Lunch Theorem generalizable to Quantum Computation? <p>The &quot;<a href=""https://en.wikipedia.org/wiki/No_free_lunch_theorem"" rel=""noreferrer"">No Free Lunch Theorem</a>&quot; says: that when averaged across all possible problems, any two strategies have equivalent performance. However it uses Bayesian reasoning to arrive at this conclusion.</p>
<p>However, Bayesian reasoning employs <a href=""https://physics.stackexchange.com/a/510364/150174"">conditional probability</a> which does not hold in it's standard form in QM. Then the question becomes if I have 2 search algorithms in QM do they have
equivalent performance across all possible problems? Or in other words is No Free Lunch Theorem generalizable to Quantum Computation?</p>
",qc,free lunch theorem generalizable quantum computation p quot https noreferrer free lunch theorem quot says averaged across possible problems two strategies equivalent performance however uses bayesian reasoning arrive p however bayesian reasoning employs https conditional probability hold standard form qm question becomes 2 search algorithms qm equivalent performance across possible problems words free lunch theorem generalizable quantum computation,"[(1, 0.164684), (3, 0.18265603), (5, 0.04917905), (9, 0.443821), (12, 0.055586655), (18, 0.066172466), (19, 0.035541274)]"
23992,23993.0,2022-02-08 19:11:48,2,324,"<p>How should I use the 'MPP' gate with append_operation in stim? For example it's clear from the documentation that circuit.append_operation('MX', [1,2]) will append two X-base measurements on qubits 1 and 2. However, I couldn't figure out how to do an X1*X2 measurement with 'MPP'. Could you please give me an example?</p>
",How do I add an MPP operation to a stim circuit using append_operation?,<stim>,1,1,,,"How do I add an MPP operation to a stim circuit using append_operation? <p>How should I use the 'MPP' gate with append_operation in stim? For example it's clear from the documentation that circuit.append_operation('MX', [1,2]) will append two X-base measurements on qubits 1 and 2. However, I couldn't figure out how to do an X1*X2 measurement with 'MPP'. Could you please give me an example?</p>
",qc,add mpp operation stim circuit using p use gate stim example clear documentation append two measurements qubits 1 however could figure x1 x2 measurement could please give example,"[(2, 0.033286966), (12, 0.036033597), (14, 0.8462481), (17, 0.07875687)]"
24044,,2022-02-11 13:36:40,1,171,"<p>I have a quantum circuit in which I apply snapshots like this during setup:</p>
<pre><code>    for qubit_index in range(0, num_qubits):
        
        if qubit_index &lt; num_qubits-1:
            next_qubit_index = qubit_index + 1
            snapshot_name_string = &quot;snapshot_&quot; + str(qubit_index) + &quot;_&quot; + str(next_qubit_index)
            print(&quot;--- Setting &quot; + snapshot_name_string)
            quantum_circuit.snapshot(snapshot_name_string, qubits = [qubit_index,next_qubit_index])
    
</code></pre>
<p>This so I can compute the amplitudes of sub-systems. For example, if I have 10 qubits, but want to get probabilities of only the 3rd and fourth qubit being in their states (00, 01, 10, 11), I use:</p>
<pre><code>result = execute(quantum_circuit, backend, shots=1).result()
snapshots = result.data()['snapshots']['statevector'][snapshot_name_string][0].tolist()
</code></pre>
<p>I need the probabilities to correctly sample projective measurements before applying Clifford gates to (qubit_index,next_qubit_index) during the evolution. However, later on in the evolution when I try to analyze the density matrix:</p>
<pre><code>rho = qi.DensityMatrix.from_instruction(quantum_circuit)
# just note I then go on to compute the partial trace
reduced_rho = qi.partial_trace(rho, subsystem_range)
</code></pre>
<p>I now get an error <strong>QiskitError: 'Cannot apply Instruction: snapshot'</strong> from qi.DensityMatrix.from_instruction(). The density matrix from_instruction was working fine before I implemented the snapshots (when I was randomly selected a projective measurement based on uniform distribution rather than based on amplitudes).</p>
<p>Does anyone know how I can reconcile the DensityMatrix with the snapshots? I don't see a DensityMatrix parameter that just says 'use the whole system instead of a snapshot.' Also if their is an easy/better way to get amplitudes of sub-system states without snapshots that would be perfectly acceptable answer as well!</p>
<p>&lt;thank|you!&gt;</p>
",Qiskit DensityMatrix.from_instruction when snapshots are present,<qiskit><density-matrix>,1,0,,,"Qiskit DensityMatrix.from_instruction when snapshots are present <p>I have a quantum circuit in which I apply snapshots like this during setup:</p>
<pre><code>    for qubit_index in range(0, num_qubits):
        
        if qubit_index &lt; num_qubits-1:
            next_qubit_index = qubit_index + 1
            snapshot_name_string = &quot;snapshot_&quot; + str(qubit_index) + &quot;_&quot; + str(next_qubit_index)
            print(&quot;--- Setting &quot; + snapshot_name_string)
            quantum_circuit.snapshot(snapshot_name_string, qubits = [qubit_index,next_qubit_index])
    
</code></pre>
<p>This so I can compute the amplitudes of sub-systems. For example, if I have 10 qubits, but want to get probabilities of only the 3rd and fourth qubit being in their states (00, 01, 10, 11), I use:</p>
<pre><code>result = execute(quantum_circuit, backend, shots=1).result()
snapshots = result.data()['snapshots']['statevector'][snapshot_name_string][0].tolist()
</code></pre>
<p>I need the probabilities to correctly sample projective measurements before applying Clifford gates to (qubit_index,next_qubit_index) during the evolution. However, later on in the evolution when I try to analyze the density matrix:</p>
<pre><code>rho = qi.DensityMatrix.from_instruction(quantum_circuit)
# just note I then go on to compute the partial trace
reduced_rho = qi.partial_trace(rho, subsystem_range)
</code></pre>
<p>I now get an error <strong>QiskitError: 'Cannot apply Instruction: snapshot'</strong> from qi.DensityMatrix.from_instruction(). The density matrix from_instruction was working fine before I implemented the snapshots (when I was randomly selected a projective measurement based on uniform distribution rather than based on amplitudes).</p>
<p>Does anyone know how I can reconcile the DensityMatrix with the snapshots? I don't see a DensityMatrix parameter that just says 'use the whole system instead of a snapshot.' Also if their is an easy/better way to get amplitudes of sub-system states without snapshots that would be perfectly acceptable answer as well!</p>
<p>&lt;thank|you!&gt;</p>
",qc,qiskit snapshots present p quantum circuit apply snapshots like setup pre code range 0 lt 1 quot quot str quot quot str print quot setting quot qubits p compute amplitudes example 10 qubits want get probabilities 3rd fourth qubit states 00 01 10 11 use pre code result execute backend snapshots 0 p need probabilities correctly sample projective measurements applying clifford gates evolution however later evolution try analyze density matrix pre code rho note go compute partial trace rho p get error strong qiskiterror apply instruction snapshot density matrix working fine implemented snapshots randomly selected projective measurement based uniform distribution rather based amplitudes p anyone know reconcile densitymatrix snapshots see densitymatrix parameter says whole system instead snapshot also way get amplitudes states without snapshots would perfectly acceptable answer well p lt gt,"[(0, 0.12484077), (2, 0.014808105), (3, 0.032204457), (6, 0.025033819), (11, 0.08920474), (12, 0.045881096), (14, 0.4048401), (18, 0.19430472), (19, 0.05878461)]"
24113,,2022-02-16 00:18:31,0,85,"<p>Referring to the Q# tutorial on Grover algorithm in <a href=""https://docs.microsoft.com/en-us/azure/quantum/tutorial-qdk-grovers-search?tabs=tabid-visualstudio"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/azure/quantum/tutorial-qdk-grovers-search?tabs=tabid-visualstudio</a>, I replicated the code exactly in Visual Studio Code and used a Python host program to run it.</p>
<p>I tried to run it with N_Experiments(=100 for example) times but it always hanged or stopped after a few times. For instance, it will hang at Experiment 37 out of 100 or 45 out of 100, etc. I don't know what is wrong with it. Is the problem caused by my system itself or is it due to the underlying code? I wonder if anyone out there has faced similar problem. Please help.</p>
<p>Thanks</p>
",Q# Grover Tutorial Problem,<programming><grovers-algorithm><q#>,0,2,,,"Q# Grover Tutorial Problem <p>Referring to the Q# tutorial on Grover algorithm in <a href=""https://docs.microsoft.com/en-us/azure/quantum/tutorial-qdk-grovers-search?tabs=tabid-visualstudio"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/azure/quantum/tutorial-qdk-grovers-search?tabs=tabid-visualstudio</a>, I replicated the code exactly in Visual Studio Code and used a Python host program to run it.</p>
<p>I tried to run it with N_Experiments(=100 for example) times but it always hanged or stopped after a few times. For instance, it will hang at Experiment 37 out of 100 or 45 out of 100, etc. I don't know what is wrong with it. Is the problem caused by my system itself or is it due to the underlying code? I wonder if anyone out there has faced similar problem. Please help.</p>
<p>Thanks</p>
",qc,q grover tutorial problem p referring q tutorial grover algorithm https nofollow noreferrer https replicated code exactly visual studio code used python host program run p tried run example times always hanged stopped times instance hang experiment 37 100 45 100 etc know wrong problem caused system due underlying code wonder anyone faced similar problem please p thanks,"[(1, 0.045581102), (4, 0.1483553), (6, 0.026681935), (7, 0.10979234), (8, 0.038626004), (10, 0.044169974), (11, 0.018117733), (12, 0.03630868), (14, 0.51118666), (15, 0.019397954)]"
24204,24210.0,2022-02-21 12:52:36,2,185,"<p>Suppose I have the simple circuit</p>
<pre><code>bell = Circuit().h(0).cnot(control=0, target=1)
</code></pre>
<p>and I am running it in a notebook inside AWS. How can I download the results to my local pc when</p>
<ol>
<li><p>I use the <code>LocalSimulator()</code>.</p>
</li>
<li><p>An IonQ or a Rigetti device?</p>
</li>
</ol>
",Download results in amazon braket,<amazon-braket>,1,0,,,"Download results in amazon braket <p>Suppose I have the simple circuit</p>
<pre><code>bell = Circuit().h(0).cnot(control=0, target=1)
</code></pre>
<p>and I am running it in a notebook inside AWS. How can I download the results to my local pc when</p>
<ol>
<li><p>I use the <code>LocalSimulator()</code>.</p>
</li>
<li><p>An IonQ or a Rigetti device?</p>
</li>
</ol>
",qc,download results amazon braket p suppose simple circuit pre code bell circuit 0 p running notebook inside aws download results local pc ol li p use code localsimulator li p ionq rigetti device,"[(0, 0.05635685), (2, 0.030344848), (7, 0.09150111), (12, 0.030092947), (14, 0.6319804), (16, 0.0808052), (18, 0.044824783), (19, 0.03047121)]"
24206,24207.0,2022-02-21 13:55:22,0,225,"<p>I tried to create a PoC that QFT and classical (np.fft) are the same; however, the result confuses me. I use the same input for both QFT and np.fft. I used simulator circuit and directly measured the vector so there shouldn't be any noise.
Here is my code.</p>
<pre><code>import qiskit
from qiskit.providers.aer.extensions.snapshot_statevector import *
import numpy as np
import matplotlib.pyplot as plt
import math

sample_norm = [0.5, 0, 0.5, 0, 0.5, 0, 0.5, 0]
n = len(sample_norm)
q = int(math.log(n,2))

# Start the QFT circuit
circuit = qiskit.QuantumCircuit(q)
circuit.initialize(sample_norm, range(q))
circuit.snapshot_statevector('init') # This vector is correct
circuit += qiskit.circuit.library.QFT(num_qubits=q, do_swaps=False, approximation_degree=0)
circuit.snapshot_statevector('qft')
circuit.measure_all()

aer_sim = qiskit.Aer.get_backend('qasm_simulator')
qobj = qiskit.assemble(circuit)
result = aer_sim.run(qobj, shots=1).result()
init_vec = result.data()[&quot;snapshots&quot;][&quot;statevector&quot;][&quot;init&quot;][0]
qft_vec = result.data()[&quot;snapshots&quot;][&quot;statevector&quot;][&quot;qft&quot;][0]

PSD_q = np.real(qft_vec * np.conj(qft_vec))

# Classical np.fft
f = sample_norm
fhat = np.fft.fft(f,n)
PSD = np.real(fhat * np.conj(fhat) / n)

plt.plot(PSD_q, color='r', linewidth=2, label='QTF')
plt.plot(PSD, color='c', linestyle='dashed', linewidth=2, label='npFFT')
plt.xlim(0, n)
plt.legend()
plt.show()
</code></pre>
<p>The result:</p>
<p><img src=""https://i.sstatic.net/ooOKZ.png"" alt=""Text"" /></p>
<p>I understand that there may be different in scaling but the result doesn't look like an effect from scaling. I have also tried with do_swaps=True/False but it doesn't help either. The vectors I got from the snapshot also don't look similar. (And not just the conjugate part)</p>
<pre><code>eps = 0.000000001
qft_vec.real[np.abs(qft_vec.real) &lt; eps] = 0
qft_vec.imag[np.abs(qft_vec.imag) &lt; eps] = 0
fhat.real[np.abs(fhat.real) &lt; eps] = 0
fhat.imag[np.abs(fhat.imag) &lt; eps] = 0

qft_vec
array([0.70710678+0.j       , 0.1767767 +0.4267767j,
       0.        +0.j       , 0.1767767 +0.0732233j,
       0.        +0.j       , 0.1767767 -0.0732233j,
       0.        +0.j       , 0.1767767 -0.4267767j])

fhat
array([2.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 2.+0.j, 0.+0.j, 0.+0.j, 0.+0.j])
</code></pre>
<p>I'm actually a beginner in both QFT and FFT but I have read many sources, the result from both QFT and FFT should be similar? Even the matrix is only different in the complex conjugate part. <a href=""https://quantumcomputing.stackexchange.com/questions/17259/qiskit-qft-matrix-does-not-match-with-dft-matrix"">Qiskit QFT matrix does not match with DFT matrix</a></p>
<p>Any help is appreciated.</p>
",Different QFT and classical FFT result,<qiskit><quantum-fourier-transform>,1,0,,,"Different QFT and classical FFT result <p>I tried to create a PoC that QFT and classical (np.fft) are the same; however, the result confuses me. I use the same input for both QFT and np.fft. I used simulator circuit and directly measured the vector so there shouldn't be any noise.
Here is my code.</p>
<pre><code>import qiskit
from qiskit.providers.aer.extensions.snapshot_statevector import *
import numpy as np
import matplotlib.pyplot as plt
import math

sample_norm = [0.5, 0, 0.5, 0, 0.5, 0, 0.5, 0]
n = len(sample_norm)
q = int(math.log(n,2))

# Start the QFT circuit
circuit = qiskit.QuantumCircuit(q)
circuit.initialize(sample_norm, range(q))
circuit.snapshot_statevector('init') # This vector is correct
circuit += qiskit.circuit.library.QFT(num_qubits=q, do_swaps=False, approximation_degree=0)
circuit.snapshot_statevector('qft')
circuit.measure_all()

aer_sim = qiskit.Aer.get_backend('qasm_simulator')
qobj = qiskit.assemble(circuit)
result = aer_sim.run(qobj, shots=1).result()
init_vec = result.data()[&quot;snapshots&quot;][&quot;statevector&quot;][&quot;init&quot;][0]
qft_vec = result.data()[&quot;snapshots&quot;][&quot;statevector&quot;][&quot;qft&quot;][0]

PSD_q = np.real(qft_vec * np.conj(qft_vec))

# Classical np.fft
f = sample_norm
fhat = np.fft.fft(f,n)
PSD = np.real(fhat * np.conj(fhat) / n)

plt.plot(PSD_q, color='r', linewidth=2, label='QTF')
plt.plot(PSD, color='c', linestyle='dashed', linewidth=2, label='npFFT')
plt.xlim(0, n)
plt.legend()
plt.show()
</code></pre>
<p>The result:</p>
<p><img src=""https://i.sstatic.net/ooOKZ.png"" alt=""Text"" /></p>
<p>I understand that there may be different in scaling but the result doesn't look like an effect from scaling. I have also tried with do_swaps=True/False but it doesn't help either. The vectors I got from the snapshot also don't look similar. (And not just the conjugate part)</p>
<pre><code>eps = 0.000000001
qft_vec.real[np.abs(qft_vec.real) &lt; eps] = 0
qft_vec.imag[np.abs(qft_vec.imag) &lt; eps] = 0
fhat.real[np.abs(fhat.real) &lt; eps] = 0
fhat.imag[np.abs(fhat.imag) &lt; eps] = 0

qft_vec
array([0.70710678+0.j       , 0.1767767 +0.4267767j,
       0.        +0.j       , 0.1767767 +0.0732233j,
       0.        +0.j       , 0.1767767 -0.0732233j,
       0.        +0.j       , 0.1767767 -0.4267767j])

fhat
array([2.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 2.+0.j, 0.+0.j, 0.+0.j, 0.+0.j])
</code></pre>
<p>I'm actually a beginner in both QFT and FFT but I have read many sources, the result from both QFT and FFT should be similar? Even the matrix is only different in the complex conjugate part. <a href=""https://quantumcomputing.stackexchange.com/questions/17259/qiskit-qft-matrix-does-not-match-with-dft-matrix"">Qiskit QFT matrix does not match with DFT matrix</a></p>
<p>Any help is appreciated.</p>
",qc,different qft classical fft result p tried create poc qft classical however result confuses use input qft used simulator circuit directly measured vector noise pre code import qiskit import import numpy np import plt import math 0 0 0 0 n len q int start qft circuit circuit q range q vector correct circuit qobj circuit result qobj quot snapshots quot quot statevector quot quot init quot 0 quot snapshots quot quot statevector quot quot qft quot 0 classical f fhat f n psd fhat fhat n r psd c 0 n p result p img https text p understand may different scaling result look like effect scaling also tried help either vectors got snapshot also look similar conjugate part pre code eps lt eps 0 lt eps 0 lt eps 0 lt eps 0 array 0 0 0 fhat array p actually beginner qft fft read many sources result qft fft similar even matrix different complex conjugate part https qiskit qft matrix match dft matrix p help,"[(0, 0.2695405), (2, 0.09685813), (4, 0.10198669), (7, 0.0761246), (8, 0.10925274), (10, 0.028778655), (11, 0.023843832), (12, 0.012465593), (13, 0.06883718), (14, 0.110425845), (19, 0.10133434)]"
24219,24221.0,2022-02-21 22:17:20,1,207,"<p>In most diagrams of oracles for basic algorithms such as Deutsch-Jozsa (e.g., <a href=""https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html</a>) the inputs are bitstrings <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span>, and outputs are bitstrings <span class=""math-container"">$x$</span> and <span class=""math-container"">$y \oplus f(x)$</span>.</p>
<p>When used in a quantum circuit, the oracle is given quantum states, <span class=""math-container"">$|x\rangle$</span> and <span class=""math-container"">$|y \rangle$</span>, where <span class=""math-container"">$|x\rangle$</span> is often in superposition, and <span class=""math-container"">$|y\rangle$</span> is an eigenvector of the oracle. The output of the oracle can be seen as the result of phase kickback (<a href=""https://people.vcu.edu/%7Esgharibian/courses/CMSC491/notes/Lecture%206%20-%20Deutsch%27s%20algorithm.pdf"" rel=""nofollow noreferrer"">https://people.vcu.edu/~sgharibian/courses/CMSC491/notes/Lecture%206%20-%20Deutsch's%20algorithm.pdf</a>):</p>
<p><span class=""math-container"">$$
U_f|x\rangle|-\rangle = (-1)^{f(x)}|x\rangle|-\rangle
$$</span></p>
<p>I have a question:</p>
<p>The oracle's inputs and outputs are shown as bitstrings, not states. Where, and how, are the circuit's input states <span class=""math-container"">$|x\rangle$</span> and <span class=""math-container"">$|y\rangle$</span> turned into bitstrings <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span> before the oracle, and then back into states after? Or should the diagram be showing a quantum version of the oracle, and the input/output labels should be states?</p>

",How do bitstring oracles work in quantum circuits?,<deutsch-jozsa-algorithm><oracles>,1,0,,,"How do bitstring oracles work in quantum circuits? <p>In most diagrams of oracles for basic algorithms such as Deutsch-Jozsa (e.g., <a href=""https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html</a>) the inputs are bitstrings <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span>, and outputs are bitstrings <span class=""math-container"">$x$</span> and <span class=""math-container"">$y \oplus f(x)$</span>.</p>
<p>When used in a quantum circuit, the oracle is given quantum states, <span class=""math-container"">$|x\rangle$</span> and <span class=""math-container"">$|y \rangle$</span>, where <span class=""math-container"">$|x\rangle$</span> is often in superposition, and <span class=""math-container"">$|y\rangle$</span> is an eigenvector of the oracle. The output of the oracle can be seen as the result of phase kickback (<a href=""https://people.vcu.edu/%7Esgharibian/courses/CMSC491/notes/Lecture%206%20-%20Deutsch%27s%20algorithm.pdf"" rel=""nofollow noreferrer"">https://people.vcu.edu/~sgharibian/courses/CMSC491/notes/Lecture%206%20-%20Deutsch's%20algorithm.pdf</a>):</p>
<p><span class=""math-container"">$$
U_f|x\rangle|-\rangle = (-1)^{f(x)}|x\rangle|-\rangle
$$</span></p>
<p>I have a question:</p>
<p>The oracle's inputs and outputs are shown as bitstrings, not states. Where, and how, are the circuit's input states <span class=""math-container"">$|x\rangle$</span> and <span class=""math-container"">$|y\rangle$</span> turned into bitstrings <span class=""math-container"">$x$</span> and <span class=""math-container"">$y$</span> before the oracle, and then back into states after? Or should the diagram be showing a quantum version of the oracle, and the input/output labels should be states?</p>

",qc,bitstring oracles work quantum circuits p diagrams oracles basic algorithms https nofollow noreferrer https inputs bitstrings span x span outputs bitstrings span x span f x p used quantum circuit oracle given quantum states span span span often superposition span eigenvector oracle output oracle seen result phase kickback https 206 20deutsch 27s nofollow noreferrer https 206 20deutsch p span f x p question p oracle inputs outputs shown bitstrings states circuit input states span span turned bitstrings span x span oracle back states diagram showing quantum version oracle labels states,"[(3, 0.24038923), (4, 0.1986833), (8, 0.051443063), (9, 0.06729946), (10, 0.22965625), (12, 0.023552237), (14, 0.031133017), (18, 0.14642313), (19, 0.010157809)]"
24226,24254.0,2022-02-22 19:21:37,0,886,"<p>I'm relatively new to the topic of QCNNs and I wanted to understand how the number of qubits is selected in the encoded quantum layer. Like is it based on the image we want to encode? What is the maximum image size that we can encode today in a quantum layer?</p>
",How do I calculate the amount of qubits required for Image Classification with a Quantum Convolutional Neural Network?,<quantum-neural-network>,2,0,,,"How do I calculate the amount of qubits required for Image Classification with a Quantum Convolutional Neural Network? <p>I'm relatively new to the topic of QCNNs and I wanted to understand how the number of qubits is selected in the encoded quantum layer. Like is it based on the image we want to encode? What is the maximum image size that we can encode today in a quantum layer?</p>
",qc,calculate amount qubits required image classification quantum convolutional neural network p relatively new topic qcnns wanted understand number qubits selected encoded quantum layer like based image want encode maximum image size encode today quantum layer,"[(4, 0.1205963), (7, 0.11480439), (8, 0.73008287), (12, 0.029835604)]"
24270,24271.0,2022-02-26 19:52:45,4,165,"<h1>TL/DR</h1>
<p>What is a good circuit for:
<span class=""math-container"">$$\frac{1}{2}\begin{pmatrix} 
-i &amp; i  &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; -i &amp; i \\ 
i  &amp; -i &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; i  &amp; -i\end{pmatrix},$$</span></p>
<p>as this may be a useful matrix for taking square roots of other unitaries?</p>
<p><strong>EDIT - there are some significant errors in my question, and I retract the setup.  For example the initial circuit below is improper in at least three ways, as I didn't phase the ancillae,  I got the IQFT wrong, and I didn't uncompute properly.</strong></p>
<p><strong>But I don't want to delete the question as @CraigGidney's answer is still valid to the original question, and his pointers to his posts are instructive, and deserves the check!</strong></p>
<hr />
<h1>Separate Square Roots</h1>
<p>In more detail, given two unitary operators <span class=""math-container"">$A,B$</span> acting on an <span class=""math-container"">$n$</span>-qubit state <span class=""math-container"">$|\psi\rangle$</span>, where <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> are inverses of each other, <em>e.g.</em>, <span class=""math-container"">$AB=BA=I$</span>, and both <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> are of order <span class=""math-container"">$4$</span>, <em>e.g.</em>, <span class=""math-container"">$A^4=B^4=I$</span>, we wish to find a good circuit for <span class=""math-container"">$\sqrt A\sqrt B$</span>, as this might be part of a product formula for Hamiltonian simulation.</p>
<p>Initially we can construct the square roots for each of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> separately, noting that because the eigenvalues of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> are the fourth roots of unity, <em>e.g.</em>, <span class=""math-container"">$\pm i, \pm 1$</span>, we can use two ancillae for phase estimation with <span class=""math-container"">$S$</span> gates that rotate the ancillae and take the roots:</p>
<p><a href=""https://i.sstatic.net/cEA5h.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cEA5h.png"" alt=""Separate Roots"" /></a></p>
<p>The last Hadamard gates are included to emphasize that the ancillae all revert back to <span class=""math-container"">$|0\rangle$</span>.</p>
<hr />
<h1>Parallel Circuit</h1>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/24242/if-two-unitary-operators-commute-do-their-roots-also-commute"">Because</a> <span class=""math-container"">$[\sqrt A, \sqrt B]=0$</span>, <em>i.e.</em> the above circuits commute, we can execute them in parallel with four ancillae (two at the top and two at the bottom):</p>
<p><a href=""https://i.sstatic.net/FS184.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/FS184.png"" alt=""Parallel Roots"" /></a></p>
<p>With the above parallel circuit, we have six controlled applications each of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>, sixteen Hadamard gates, and eight <span class=""math-container"">$S$</span>/<span class=""math-container"">$CS$</span> gates.</p>
<hr />
<h1>Initial Serial Circuit</h1>
<p>But in the first circuits the ancillae revert back to <span class=""math-container"">$|0\rangle$</span>, and we can also execute them in series:</p>
<p><a href=""https://i.sstatic.net/cIoI4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cIoI4.png"" alt=""Long Serial Roots"" /></a></p>
<p>This only uses two ancillae, with the same number of gates as, but double the depth of, the parallel circuit.</p>
<hr />
<h1>Simplified Serial Circuit</h1>
<p>However, recall that <span class=""math-container"">$H^2=I$</span>, and we also were given that <span class=""math-container"">$AB=A^2 B^2=I$</span>.  Thus much of the above cancels out, leaving:</p>
<p><a href=""https://i.sstatic.net/7QeOt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7QeOt.png"" alt=""Simplified Roots"" /></a></p>
<p>This simplified serial circuit uses two ancillae and six <span class=""math-container"">$S$</span> and one <span class=""math-container"">$CZ$</span> gate, but with ten <span class=""math-container"">$H$</span> gates and significantly only three controlled applications each of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>.</p>
<hr />
<h1>Question</h1>
<p>Quirk <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22Z%5E%C2%BD%22%5D,%5B1,%22H%22%5D,%5B%22Z%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22Z%5E%C2%BD%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B%22H%22%5D%5D,%22init%22:%5B1%5D%7D"" rel=""nofollow noreferrer"">tells</a> us that the remaining highlighted circuit in the middle of the last figure is equal to the matrix mentioned in the intro:</p>
<p><span class=""math-container"">$$\frac{1}{2}\begin{pmatrix} 
-i &amp; i  &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; -i &amp; i \\ 
i  &amp; -i &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; i  &amp; -i\end{pmatrix}.$$</span></p>
<blockquote>
<p><em><strong>I suspect the highlighted circuit could be simplified further still</strong></em>.  Can the above circuit/matrix be simplified any more, using, say, Clifford+<span class=""math-container"">$T$</span> gates?</p>
</blockquote>
<p>Indeed, the <span class=""math-container"">$S$</span> gates, the <span class=""math-container"">$CZ$</span> gate, etc. are all Clifford gates anyways (although cube roots/fourth roots/etc. would use non-Clifford gates).</p>
","If $A^4=B^4=AB=I$, what is a good circuit for $\sqrt A\sqrt B$?",<circuit-construction><gate-synthesis>,1,1,,,"If $A^4=B^4=AB=I$, what is a good circuit for $\sqrt A\sqrt B$? <h1>TL/DR</h1>
<p>What is a good circuit for:
<span class=""math-container"">$$\frac{1}{2}\begin{pmatrix} 
-i &amp; i  &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; -i &amp; i \\ 
i  &amp; -i &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; i  &amp; -i\end{pmatrix},$$</span></p>
<p>as this may be a useful matrix for taking square roots of other unitaries?</p>
<p><strong>EDIT - there are some significant errors in my question, and I retract the setup.  For example the initial circuit below is improper in at least three ways, as I didn't phase the ancillae,  I got the IQFT wrong, and I didn't uncompute properly.</strong></p>
<p><strong>But I don't want to delete the question as @CraigGidney's answer is still valid to the original question, and his pointers to his posts are instructive, and deserves the check!</strong></p>
<hr />
<h1>Separate Square Roots</h1>
<p>In more detail, given two unitary operators <span class=""math-container"">$A,B$</span> acting on an <span class=""math-container"">$n$</span>-qubit state <span class=""math-container"">$|\psi\rangle$</span>, where <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> are inverses of each other, <em>e.g.</em>, <span class=""math-container"">$AB=BA=I$</span>, and both <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> are of order <span class=""math-container"">$4$</span>, <em>e.g.</em>, <span class=""math-container"">$A^4=B^4=I$</span>, we wish to find a good circuit for <span class=""math-container"">$\sqrt A\sqrt B$</span>, as this might be part of a product formula for Hamiltonian simulation.</p>
<p>Initially we can construct the square roots for each of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> separately, noting that because the eigenvalues of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> are the fourth roots of unity, <em>e.g.</em>, <span class=""math-container"">$\pm i, \pm 1$</span>, we can use two ancillae for phase estimation with <span class=""math-container"">$S$</span> gates that rotate the ancillae and take the roots:</p>
<p><a href=""https://i.sstatic.net/cEA5h.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cEA5h.png"" alt=""Separate Roots"" /></a></p>
<p>The last Hadamard gates are included to emphasize that the ancillae all revert back to <span class=""math-container"">$|0\rangle$</span>.</p>
<hr />
<h1>Parallel Circuit</h1>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/24242/if-two-unitary-operators-commute-do-their-roots-also-commute"">Because</a> <span class=""math-container"">$[\sqrt A, \sqrt B]=0$</span>, <em>i.e.</em> the above circuits commute, we can execute them in parallel with four ancillae (two at the top and two at the bottom):</p>
<p><a href=""https://i.sstatic.net/FS184.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/FS184.png"" alt=""Parallel Roots"" /></a></p>
<p>With the above parallel circuit, we have six controlled applications each of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>, sixteen Hadamard gates, and eight <span class=""math-container"">$S$</span>/<span class=""math-container"">$CS$</span> gates.</p>
<hr />
<h1>Initial Serial Circuit</h1>
<p>But in the first circuits the ancillae revert back to <span class=""math-container"">$|0\rangle$</span>, and we can also execute them in series:</p>
<p><a href=""https://i.sstatic.net/cIoI4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cIoI4.png"" alt=""Long Serial Roots"" /></a></p>
<p>This only uses two ancillae, with the same number of gates as, but double the depth of, the parallel circuit.</p>
<hr />
<h1>Simplified Serial Circuit</h1>
<p>However, recall that <span class=""math-container"">$H^2=I$</span>, and we also were given that <span class=""math-container"">$AB=A^2 B^2=I$</span>.  Thus much of the above cancels out, leaving:</p>
<p><a href=""https://i.sstatic.net/7QeOt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7QeOt.png"" alt=""Simplified Roots"" /></a></p>
<p>This simplified serial circuit uses two ancillae and six <span class=""math-container"">$S$</span> and one <span class=""math-container"">$CZ$</span> gate, but with ten <span class=""math-container"">$H$</span> gates and significantly only three controlled applications each of <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>.</p>
<hr />
<h1>Question</h1>
<p>Quirk <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22Z%5E%C2%BD%22%5D,%5B1,%22H%22%5D,%5B%22Z%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22Z%5E%C2%BD%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B%22H%22%5D%5D,%22init%22:%5B1%5D%7D"" rel=""nofollow noreferrer"">tells</a> us that the remaining highlighted circuit in the middle of the last figure is equal to the matrix mentioned in the intro:</p>
<p><span class=""math-container"">$$\frac{1}{2}\begin{pmatrix} 
-i &amp; i  &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; -i &amp; i \\ 
i  &amp; -i &amp; 1  &amp; 1 \\ 
1  &amp; 1  &amp; i  &amp; -i\end{pmatrix}.$$</span></p>
<blockquote>
<p><em><strong>I suspect the highlighted circuit could be simplified further still</strong></em>.  Can the above circuit/matrix be simplified any more, using, say, Clifford+<span class=""math-container"">$T$</span> gates?</p>
</blockquote>
<p>Indeed, the <span class=""math-container"">$S$</span> gates, the <span class=""math-container"">$CZ$</span> gate, etc. are all Clifford gates anyways (although cube roots/fourth roots/etc. would use non-Clifford gates).</p>
",qc,good circuit b h1 p good circuit span 1 2 pmatrix amp amp 1 amp 1 1 amp 1 amp amp amp amp 1 amp 1 1 amp 1 amp amp pmatrix p may useful matrix taking square roots unitaries p strong edit significant errors question retract setup example initial circuit improper least three ways phase ancillae got iqft wrong uncompute p strong want delete question craiggidney answer still valid original question pointers posts instructive deserves check hr h1 separate square roots p detail given two unitary operators span b acting span n state span span span b inverses em span span span b order span 4 em span wish find good circuit span b might part product formula hamiltonian p initially construct square roots span span b separately noting eigenvalues span span b fourth roots unity em span 1 use two ancillae phase estimation span gates rotate ancillae take roots p https nofollow noreferrer img https separate roots p last hadamard gates included emphasize ancillae revert back span hr h1 parallel circuit p https span b em circuits commute execute parallel four ancillae two top two bottom p https nofollow noreferrer img https parallel roots p parallel circuit six controlled applications span span b sixteen hadamard gates eight span span cs hr h1 initial serial circuit p first circuits ancillae revert back span also execute series p https nofollow noreferrer img https long serial roots p uses two ancillae number gates double depth parallel hr h1 simplified serial circuit p however recall span also given span thus much cancels leaving p https nofollow noreferrer img https simplified roots p simplified serial circuit uses two ancillae six span one span cz gate ten span h gates significantly three controlled applications span span b hr h1 question p quirk https 7b 22cols 22 5b 5b 22h 22 5d 5b 22z 5e c2 bd 22 22 e2 80 a2 22 5d 5b1 22h 22 5d 5b 22z 5e c2 bd 22 22z 5e c2 bd 22 5d 5b1 22h 22 5d 5b 22z 22 22 e2 80 a2 22 5d 5b1 22h 22 5d 5b 22z 5e c2 bd 22 22z 5e c2 bd 22 5d 5b1 22h 22 5d 5b 22z 5e c2 bd 22 22 e2 80 a2 22 5d 5b 22h 22 5d 5d 22init 22 5b1 5d 7d nofollow noreferrer tells us remaining highlighted circuit middle last figure equal matrix mentioned intro p span 1 2 pmatrix amp amp 1 amp 1 1 amp 1 amp amp amp amp 1 amp 1 1 amp 1 amp amp pmatrix blockquote p em strong suspect highlighted circuit could simplified still simplified using say span gates p indeed span gates span cz gate etc clifford gates anyways although cube would use gates,"[(2, 0.03623822), (3, 0.27567294), (4, 0.077755645), (7, 0.013800122), (9, 0.17603579), (12, 0.23178072), (13, 0.018228298), (14, 0.04214998), (15, 0.116602965), (18, 0.011514858)]"
24284,,2022-02-28 11:51:42,8,1100,"<p>Why is the <a href=""https://www.quantiki.org/wiki/linear-entropy#:%7E:text=The%20linear%20entropy%20is%20a,1%E2%88%92Tr(%CF%812)"" rel=""noreferrer"">linear entropy</a>, defined by <span class=""math-container"">$S_L = 1 - \textrm{Tr} \rho^2$</span>, called linear?</p>
","What is ""linear"" in linear entropy?",<entropy>,1,0,,,"What is ""linear"" in linear entropy? <p>Why is the <a href=""https://www.quantiki.org/wiki/linear-entropy#:%7E:text=The%20linear%20entropy%20is%20a,1%E2%88%92Tr(%CF%812)"" rel=""noreferrer"">linear entropy</a>, defined by <span class=""math-container"">$S_L = 1 - \textrm{Tr} \rho^2$</span>, called linear?</p>
",qc,linear linear entropy p https 7e 20linear 20entropy 20is e2 88 92tr cf 812 noreferrer linear entropy defined span 1 tr called linear,"[(3, 0.6946674), (4, 0.09288982), (12, 0.10780547), (13, 0.09629364)]"
24338,24341.0,2022-03-03 02:57:19,0,337,"<p>I save my (lenghty) Hamiltonian in a file as a string.</p>
<p>My naive attempt:</p>
<pre><code>hamiltonian_string = read_hamiltonian_from_file()  # some function
hamiltonian = PauliOp(hamiltonian_string) 
TypeError: PauliOp can only be instantiated with Paulis, not &lt;class 'str'&gt;
</code></pre>
<p>But copy-pasting from the file into Jupyter notebook works (of course):</p>
<pre><code>hamiltonian =  1*(X^X^X) - 2*(X^Z^X) + 3*(X^I^X)
print(type(hamiltonian))
&lt;class 'qiskit.opflow.primitive_ops.pauli_sum_op.PauliSumOp'&gt;
</code></pre>
<p>Is there a way to initiate a PauliOp from a string?</p>
",Qiskit: PauliOp from string,<qiskit>,1,0,,,"Qiskit: PauliOp from string <p>I save my (lenghty) Hamiltonian in a file as a string.</p>
<p>My naive attempt:</p>
<pre><code>hamiltonian_string = read_hamiltonian_from_file()  # some function
hamiltonian = PauliOp(hamiltonian_string) 
TypeError: PauliOp can only be instantiated with Paulis, not &lt;class 'str'&gt;
</code></pre>
<p>But copy-pasting from the file into Jupyter notebook works (of course):</p>
<pre><code>hamiltonian =  1*(X^X^X) - 2*(X^Z^X) + 3*(X^I^X)
print(type(hamiltonian))
&lt;class 'qiskit.opflow.primitive_ops.pauli_sum_op.PauliSumOp'&gt;
</code></pre>
<p>Is there a way to initiate a PauliOp from a string?</p>
",qc,qiskit pauliop string p save lenghty hamiltonian file p naive attempt pre code function hamiltonian pauliop typeerror pauliop instantiated paulis lt class gt p file jupyter notebook works course pre code hamiltonian 1 2 3 print type hamiltonian lt class gt p way initiate pauliop string,"[(0, 0.6119553), (1, 0.09691594), (3, 0.04565367), (12, 0.091893315), (14, 0.12283895), (15, 0.027564622)]"
24343,,2022-03-03 09:51:05,4,929,"<p>I have been trying to understand Variational Quantum Eigensolver (VQE), particularly from the non-linear binary programming perspective. But after reading a few resources I'm still confused about where exactly the algorithm promise a speed-up over classical one. The key steps where quantum properties provide advantages seem to be:</p>
<ol>
<li>Ansatz preparation <span class=""math-container"">$|\psi(\theta)\rangle = U(\theta)|\psi_0\rangle$</span>, where classically this would involve applying matrices of size <span class=""math-container"">$2^N$</span>.</li>
<li>Computing the expectation <span class=""math-container"">$\langle \psi(\theta)|H|\psi(\theta)\rangle$</span>.</li>
</ol>
<p>Is this essentially correct?</p>
<p>I think I can accept step 1. but for step 2. how does quantum computer computes <span class=""math-container"">$\langle \psi(\theta)|H|\psi(\theta)\rangle$</span> quickly in practice?</p>
<p>I read from several places, e.g. <a href=""https://quantumcomputing.stackexchange.com/questions/18387/why-exactly-are-variational-algorithms-considered-promising"">Why exactly are variational algorithms considered promising?</a> that this is done by making repeated measurements to find the approximated distribution of bitstrings in <span class=""math-container"">$|\psi(\theta)\rangle$</span>, then compute the expectation value of <span class=""math-container"">$H$</span> classically. The important point seems to be that if <span class=""math-container"">$H$</span> is bounded by some <span class=""math-container"">$C$</span>, then the number of samples required to estimate <span class=""math-container"">$\langle \psi(\theta)|H|\psi(\theta)\rangle$</span> to <span class=""math-container"">$\epsilon &gt; 0$</span> precision seems to be <span class=""math-container"">$O(C^2/\epsilon^2)$</span>, which grows polynomially with problem size if <span class=""math-container"">$C$</span> does (see e.g. 4.3.3 remark in <a href=""https://qiskit.org/textbook/ch-applications/qaoa.html#:%7E:text=QAOA%20(Quantum%20Approximate%20Optimization%20Algorithm,(%20%CE%B2%20%2C%20%CE%B3%20)%20%E2%9F%A9%20)"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/qaoa.html#:~:text=QAOA%20(Quantum%20Approximate%20Optimization%20Algorithm,(%20%CE%B2%20%2C%20%CE%B3%20)%20%E2%9F%A9%20)</a>. On the other hand, even to simulate the sampling process classically we need to store distribution <span class=""math-container"">$|\psi(\theta)\rangle$</span> which requires <span class=""math-container"">$2^N$</span> space and also another <span class=""math-container"">$2^N$</span> loop to simulate sampling process (dividing <span class=""math-container"">$[0,1]$</span> into <span class=""math-container"">$2^N$</span> subintervals and do a uniform distribution or something?).</p>
<p>But if we are only going to measure <span class=""math-container"">$|\psi(\theta)\rangle$</span> w.r.t. <span class=""math-container"">$Z$</span>-basis then compute the expectation value of <span class=""math-container"">$H$</span> classically, then why many resources such as <a href=""https://arxiv.org/pdf/2111.05176.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2111.05176.pdf</a> seems to suggest the importance of having <span class=""math-container"">$H$</span> in a form that is `directly measurable on quantum computer' (see page 7)? This apparently restricts <span class=""math-container"">$H$</span> to the form <span class=""math-container"">$H = \sum w_a P_a$</span> where <span class=""math-container"">$P_a \in \{I, X, Y, Z\}^{\otimes N}$</span>, instead of <span class=""math-container"">$H$</span> being any bounded functions <span class=""math-container"">$\{0,1\}^N\rightarrow \mathbb{R}$</span> which should be allowed if we are just going to compute the expectation value classically.</p>
",What exactly makes VQE faster than classical optimization?,<measurement><vqe><quantum-advantage>,1,0,,,"What exactly makes VQE faster than classical optimization? <p>I have been trying to understand Variational Quantum Eigensolver (VQE), particularly from the non-linear binary programming perspective. But after reading a few resources I'm still confused about where exactly the algorithm promise a speed-up over classical one. The key steps where quantum properties provide advantages seem to be:</p>
<ol>
<li>Ansatz preparation <span class=""math-container"">$|\psi(\theta)\rangle = U(\theta)|\psi_0\rangle$</span>, where classically this would involve applying matrices of size <span class=""math-container"">$2^N$</span>.</li>
<li>Computing the expectation <span class=""math-container"">$\langle \psi(\theta)|H|\psi(\theta)\rangle$</span>.</li>
</ol>
<p>Is this essentially correct?</p>
<p>I think I can accept step 1. but for step 2. how does quantum computer computes <span class=""math-container"">$\langle \psi(\theta)|H|\psi(\theta)\rangle$</span> quickly in practice?</p>
<p>I read from several places, e.g. <a href=""https://quantumcomputing.stackexchange.com/questions/18387/why-exactly-are-variational-algorithms-considered-promising"">Why exactly are variational algorithms considered promising?</a> that this is done by making repeated measurements to find the approximated distribution of bitstrings in <span class=""math-container"">$|\psi(\theta)\rangle$</span>, then compute the expectation value of <span class=""math-container"">$H$</span> classically. The important point seems to be that if <span class=""math-container"">$H$</span> is bounded by some <span class=""math-container"">$C$</span>, then the number of samples required to estimate <span class=""math-container"">$\langle \psi(\theta)|H|\psi(\theta)\rangle$</span> to <span class=""math-container"">$\epsilon &gt; 0$</span> precision seems to be <span class=""math-container"">$O(C^2/\epsilon^2)$</span>, which grows polynomially with problem size if <span class=""math-container"">$C$</span> does (see e.g. 4.3.3 remark in <a href=""https://qiskit.org/textbook/ch-applications/qaoa.html#:%7E:text=QAOA%20(Quantum%20Approximate%20Optimization%20Algorithm,(%20%CE%B2%20%2C%20%CE%B3%20)%20%E2%9F%A9%20)"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/qaoa.html#:~:text=QAOA%20(Quantum%20Approximate%20Optimization%20Algorithm,(%20%CE%B2%20%2C%20%CE%B3%20)%20%E2%9F%A9%20)</a>. On the other hand, even to simulate the sampling process classically we need to store distribution <span class=""math-container"">$|\psi(\theta)\rangle$</span> which requires <span class=""math-container"">$2^N$</span> space and also another <span class=""math-container"">$2^N$</span> loop to simulate sampling process (dividing <span class=""math-container"">$[0,1]$</span> into <span class=""math-container"">$2^N$</span> subintervals and do a uniform distribution or something?).</p>
<p>But if we are only going to measure <span class=""math-container"">$|\psi(\theta)\rangle$</span> w.r.t. <span class=""math-container"">$Z$</span>-basis then compute the expectation value of <span class=""math-container"">$H$</span> classically, then why many resources such as <a href=""https://arxiv.org/pdf/2111.05176.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2111.05176.pdf</a> seems to suggest the importance of having <span class=""math-container"">$H$</span> in a form that is `directly measurable on quantum computer' (see page 7)? This apparently restricts <span class=""math-container"">$H$</span> to the form <span class=""math-container"">$H = \sum w_a P_a$</span> where <span class=""math-container"">$P_a \in \{I, X, Y, Z\}^{\otimes N}$</span>, instead of <span class=""math-container"">$H$</span> being any bounded functions <span class=""math-container"">$\{0,1\}^N\rightarrow \mathbb{R}$</span> which should be allowed if we are just going to compute the expectation value classically.</p>
",qc,exactly makes vqe faster classical optimization p trying understand variational quantum eigensolver vqe particularly binary programming perspective reading resources still confused exactly algorithm promise classical one key steps quantum properties provide advantages seem ol li ansatz preparation span u classically would involve applying matrices size span li computing expectation span p essentially correct p think accept step step quantum computer computes span quickly practice p read several places https exactly variational algorithms considered promising done making repeated measurements find approximated distribution bitstrings span compute expectation value span h classically important point seems span h bounded span c number samples required estimate span span gt 0 precision seems span grows polynomially problem size span c see remark https 7e 20 quantum 20approximate 20optimization 20algorithm 20 ce b2 20 2c 20 ce b3 20 20 e2 9f a9 20 nofollow noreferrer https 20 quantum 20approximate 20optimization 20algorithm 20 ce b2 20 2c 20 ce b3 20 20 e2 9f a9 20 hand even simulate sampling process classically need store distribution span requires span space also another span loop simulate sampling process dividing span span subintervals uniform distribution something p going measure span span z compute expectation value span h classically many resources https nofollow noreferrer https seems suggest importance span h form directly measurable quantum computer see page 7 apparently restricts span h form span h span x n instead span h bounded functions span r allowed going compute expectation value,"[(1, 0.09708019), (3, 0.33304992), (6, 0.073336124), (7, 0.16333878), (8, 0.19030854), (9, 0.0223018), (12, 0.018673), (13, 0.096737854)]"
24369,24372.0,2022-03-04 14:28:54,4,261,"<p>For learning purposes I would like to hand-craft my own circuit for the fourth-root of <span class=""math-container"">$X$</span>, using <span class=""math-container"">$S$</span>, <span class=""math-container"">$T$</span>, and <span class=""math-container"">$\sqrt X$</span> gates.</p>
<p>Note that <span class=""math-container"">$\sqrt[4]X$</span> is of order eight while <span class=""math-container"">$\sqrt X$</span> is of order four, and we can use two ancillas to temporarily store the respective eigenspace.  The recipe that I have been following is to:</p>
<ol>
<li>Hit both ancilla with a Hadamard <span class=""math-container"">$H$</span>,</li>
<li>Have the lower-order ancilla perform a controlled <span class=""math-container"">$\sqrt X$</span> on the target with the higher-order ancilla perform a controlled <span class=""math-container"">$X$</span> on the target,</li>
<li>Perform a QFT on the ancillas,</li>
<li>Phase the ancillas,</li>
<li>Perform an IQFT on the ancillas,</li>
<li>Have the higher-order ancilla perform another controlled <span class=""math-container"">$X$</span> while the lower-order ancilla performs a controlled <span class=""math-container"">$X^{-1/2}$</span>, and</li>
<li>Hit both ancillas with an <span class=""math-container"">$H$</span> to revert:</li>
</ol>
<p><a href=""https://i.sstatic.net/GF32K.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GF32K.png"" alt=""First attempt at fourth root"" /></a></p>
<p>I try the above circuit in <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22%5D,%5B1,%22%E2%80%A2%22,%22X%5E%C2%BD%22%5D,%5B%22%E2%80%A2%22,1,%22X%22%5D,%5B%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22Z%5E%C2%BC%22,1,%22X%5E%C2%BC%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E-%C2%BD%22,%22%E2%80%A2%22%5D,%5B%22H%22%5D,%5B%22%E2%80%A2%22,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%5E-%C2%BD%22%5D,%5B%22H%22,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a>; although the ancillas properly revert <span class=""math-container"">$|0\rangle$</span>, it gives me a different answer on the target than Quirk's native <span class=""math-container"">$\sqrt[4] X$</span>.  On the Bloch sphere my recipe says the target's <span class=""math-container"">$\theta$</span> is <span class=""math-container"">$135^\circ$</span> while the native <span class=""math-container"">$\sqrt[4] X$</span> should be at <span class=""math-container"">$45^\circ$</span>.</p>
<blockquote>
<p>Did I get my endian-convention wrong on the QFT (red)? Or did I do the uncomputing wrong?  Did I not phase properly (purple)?</p>
</blockquote>
<p>Here's a Quirk snapshot to compare.  The hand-crafted circuit is on the first three qubits with the ancilla the first two qubits and the target the third qubit, while the native <span class=""math-container"">$\sqrt[4] X$</span> for comparison is the fourth qubit. The Bloch spheres/amplitudes are different between the third qubit (my circuit) and Quirk's native circuit:</p>
<p><a href=""https://i.sstatic.net/emOJl.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/emOJl.png"" alt=""Quirk Snapshot"" /></a></p>
",What is wrong with my circuit for the fourth-root of $X$?,<circuit-construction><quirk>,2,0,,,"What is wrong with my circuit for the fourth-root of $X$? <p>For learning purposes I would like to hand-craft my own circuit for the fourth-root of <span class=""math-container"">$X$</span>, using <span class=""math-container"">$S$</span>, <span class=""math-container"">$T$</span>, and <span class=""math-container"">$\sqrt X$</span> gates.</p>
<p>Note that <span class=""math-container"">$\sqrt[4]X$</span> is of order eight while <span class=""math-container"">$\sqrt X$</span> is of order four, and we can use two ancillas to temporarily store the respective eigenspace.  The recipe that I have been following is to:</p>
<ol>
<li>Hit both ancilla with a Hadamard <span class=""math-container"">$H$</span>,</li>
<li>Have the lower-order ancilla perform a controlled <span class=""math-container"">$\sqrt X$</span> on the target with the higher-order ancilla perform a controlled <span class=""math-container"">$X$</span> on the target,</li>
<li>Perform a QFT on the ancillas,</li>
<li>Phase the ancillas,</li>
<li>Perform an IQFT on the ancillas,</li>
<li>Have the higher-order ancilla perform another controlled <span class=""math-container"">$X$</span> while the lower-order ancilla performs a controlled <span class=""math-container"">$X^{-1/2}$</span>, and</li>
<li>Hit both ancillas with an <span class=""math-container"">$H$</span> to revert:</li>
</ol>
<p><a href=""https://i.sstatic.net/GF32K.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GF32K.png"" alt=""First attempt at fourth root"" /></a></p>
<p>I try the above circuit in <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22%5D,%5B1,%22%E2%80%A2%22,%22X%5E%C2%BD%22%5D,%5B%22%E2%80%A2%22,1,%22X%22%5D,%5B%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22Z%5E%C2%BC%22,1,%22X%5E%C2%BC%22%5D,%5B1,%22H%22%5D,%5B%22Z%5E-%C2%BD%22,%22%E2%80%A2%22%5D,%5B%22H%22%5D,%5B%22%E2%80%A2%22,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%5E-%C2%BD%22%5D,%5B%22H%22,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a>; although the ancillas properly revert <span class=""math-container"">$|0\rangle$</span>, it gives me a different answer on the target than Quirk's native <span class=""math-container"">$\sqrt[4] X$</span>.  On the Bloch sphere my recipe says the target's <span class=""math-container"">$\theta$</span> is <span class=""math-container"">$135^\circ$</span> while the native <span class=""math-container"">$\sqrt[4] X$</span> should be at <span class=""math-container"">$45^\circ$</span>.</p>
<blockquote>
<p>Did I get my endian-convention wrong on the QFT (red)? Or did I do the uncomputing wrong?  Did I not phase properly (purple)?</p>
</blockquote>
<p>Here's a Quirk snapshot to compare.  The hand-crafted circuit is on the first three qubits with the ancilla the first two qubits and the target the third qubit, while the native <span class=""math-container"">$\sqrt[4] X$</span> for comparison is the fourth qubit. The Bloch spheres/amplitudes are different between the third qubit (my circuit) and Quirk's native circuit:</p>
<p><a href=""https://i.sstatic.net/emOJl.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/emOJl.png"" alt=""Quirk Snapshot"" /></a></p>
",qc,wrong circuit x p learning purposes would like circuit span x using span span span x p note span 4 x order eight span x order four use two ancillas temporarily store respective eigenspace recipe following ol li hit ancilla hadamard span h li ancilla perform controlled span x target ancilla perform controlled span x target li perform qft ancillas li phase ancillas li perform iqft ancillas li ancilla perform another controlled span x ancilla performs controlled span li hit ancillas span h revert p https nofollow noreferrer img https first attempt fourth root p try circuit https 7b 22cols 22 5b 5b 22h 22 22h 22 5d 5b1 22 e2 80 a2 22 22x 5e c2 bd 22 5d 5b 22 e2 80 a2 22x 22 5d 5b 22h 22 5d 5b 22z 5e c2 bd 22 22 e2 80 a2 22 5d 5b1 22h 22 5d 5b 22z 5e c2 bd 22 22z 5e c2 bc 22x 5e c2 bc 22 5d 5b1 22h 22 5d 5b 22z c2 bd 22 22 e2 80 a2 22 5d 5b 22h 22 5d 5b 22 e2 80 a2 22x 22 5d 5b1 22 e2 80 a2 22 22x c2 bd 22 5d 5b 22h 22 22h 22 5d 5d 7d nofollow noreferrer quirk although ancillas properly revert span gives different answer target quirk native span 4 x bloch sphere recipe says target span span native span 4 x span blockquote p get wrong qft red uncomputing wrong phase properly purple p quirk snapshot compare circuit first three qubits ancilla first two qubits target third qubit native span 4 x comparison fourth qubit bloch different third qubit circuit quirk native circuit p https nofollow noreferrer img https quirk snapshot,"[(3, 0.09760014), (4, 0.09775787), (6, 0.01585683), (7, 0.034802184), (10, 0.047754105), (12, 0.4293759), (13, 0.02075278), (14, 0.042146973), (18, 0.20417668)]"
24374,,2022-03-04 19:53:20,5,168,"<p>Let <span class=""math-container"">$f$</span> : {<span class=""math-container"">$0, 1, . . . , M − 1$</span>} <span class=""math-container"">$→$</span> {<span class=""math-container"">$0, 1, . . . , M − 1$</span>} be a function of the form <span class=""math-container"">$f(x) = ax ⊕ b$</span>, for
<span class=""math-container"">$a$</span> <span class=""math-container"">$∈$</span> {<span class=""math-container"">$0, 1, . . . , M − 1$</span>} and <span class=""math-container"">$b$</span> <span class=""math-container"">$∈$</span> {<span class=""math-container"">$0, 1, . . . , M − 1$</span>}, where <span class=""math-container"">$⊕$</span> is the sum modulo M. Assuming
a reduced oracle for <span class=""math-container"">$f$</span>, I'm trying to find a quantum algorithm that finds out the number <span class=""math-container"">$a$</span> with the
minimum number of queries.</p>
<p>I'm not sure how to do this - I thought that perhaps the function's periodic so we could maybe use Shor's algorithm for period finding - but I don't know how to extend it to a reduced oracle.</p>
",Quantum Algorithm for Linear interpolation,<quantum-algorithms><linear-algebra>,2,2,,,"Quantum Algorithm for Linear interpolation <p>Let <span class=""math-container"">$f$</span> : {<span class=""math-container"">$0, 1, . . . , M − 1$</span>} <span class=""math-container"">$→$</span> {<span class=""math-container"">$0, 1, . . . , M − 1$</span>} be a function of the form <span class=""math-container"">$f(x) = ax ⊕ b$</span>, for
<span class=""math-container"">$a$</span> <span class=""math-container"">$∈$</span> {<span class=""math-container"">$0, 1, . . . , M − 1$</span>} and <span class=""math-container"">$b$</span> <span class=""math-container"">$∈$</span> {<span class=""math-container"">$0, 1, . . . , M − 1$</span>}, where <span class=""math-container"">$⊕$</span> is the sum modulo M. Assuming
a reduced oracle for <span class=""math-container"">$f$</span>, I'm trying to find a quantum algorithm that finds out the number <span class=""math-container"">$a$</span> with the
minimum number of queries.</p>
<p>I'm not sure how to do this - I thought that perhaps the function's periodic so we could maybe use Shor's algorithm for period finding - but I don't know how to extend it to a reduced oracle.</p>
",qc,quantum algorithm linear interpolation p let span f span 0 1 1 span span 0 1 1 function form span f x ax b span span span 0 1 1 span b span span 0 1 1 span sum modulo assuming reduced oracle span f trying find quantum algorithm finds number span minimum number p sure thought perhaps function periodic could maybe use shor algorithm period finding know extend reduced,"[(2, 0.17114094), (3, 0.5161341), (7, 0.16797934), (10, 0.12914917), (12, 0.0134563465)]"
24470,,2022-03-10 13:50:41,6,503,"<p>Lately I have seen the claim that <span class=""math-container"">$\mathsf{QMA}\subseteq \mathsf{PSPACE}$</span>, and I wonder how can it be proved.
Thanks</p>
",How can I show that $\mathsf{QMA}\subseteq \mathsf{PSPACE}$,<complexity-theory><qma>,2,0,,,"How can I show that $\mathsf{QMA}\subseteq \mathsf{PSPACE}$ <p>Lately I have seen the claim that <span class=""math-container"">$\mathsf{QMA}\subseteq \mathsf{PSPACE}$</span>, and I wonder how can it be proved.
Thanks</p>
",qc,show qma pspace p lately seen claim span qma pspace wonder proved thanks,"[(3, 0.13229598), (9, 0.77779746), (12, 0.07701538)]"
25595,25607.0,2022-03-21 06:31:41,2,346,"<p>While implementing QSVM algorithm and I am facing some problems.
I followed this tutorial: <a href=""https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html</a>
While training using the breast cancer dataset, I got a 80% testing success ratio. Can I enhance this ratio by fine tuning the training parameters? and if yes what parameters to edit?
The training takes forever with the full dataset. Is there a way to speed it up while implementing full datasets.</p>
",Tuning hyperparameters of QSVM,<qiskit><programming><quantum-state><machine-learning><quantum-enhanced-machine-learning>,1,0,,,"Tuning hyperparameters of QSVM <p>While implementing QSVM algorithm and I am facing some problems.
I followed this tutorial: <a href=""https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stable/0.24/tutorials/machine_learning/01_qsvm_classification.html</a>
While training using the breast cancer dataset, I got a 80% testing success ratio. Can I enhance this ratio by fine tuning the training parameters? and if yes what parameters to edit?
The training takes forever with the full dataset. Is there a way to speed it up while implementing full datasets.</p>
",qc,tuning hyperparameters qsvm p implementing qsvm algorithm facing problems followed tutorial https nofollow noreferrer https training using breast cancer dataset got 80 testing success ratio enhance ratio fine tuning training parameters yes parameters edit training takes forever full dataset way speed implementing full,"[(4, 0.14018469), (8, 0.43620166), (9, 0.09163042), (10, 0.0823224), (12, 0.024254464), (14, 0.22207958)]"
25770,25771.0,2022-04-02 18:12:52,2,130,"<p>I am attempting to write a <a href=""https://github.com/liorella-qm/CliffordTableau"" rel=""nofollow noreferrer"">module</a> for composition of Clifford Tableaus using only elementary arithmetic and logical operations. Everything seems to be working fine, except that as far as I understand, the matrices whose columns are the image of each Pauli X/Z operator should be symplectic, namely, pass the test:</p>
<p><span class=""math-container"">$$
g^T\Lambda g = \Lambda
$$</span>
where
<span class=""math-container"">$$
\Lambda = \begin{pmatrix}0 &amp; I_n \\ I_n &amp; 0\end{pmatrix},
$$</span>
and the field is <span class=""math-container"">$\mathbb{F}_2$</span>, namely, I perform all additions and multiplications mod 2.</p>
<p>While single qubit Cliffords do pass this test, e.g, S gate has the tableau:</p>
<pre><code>   |x0 z0
--+------
x0|1  0
z0|1  1
s |0  0
</code></pre>
<p>where <code>s</code> is a sign bit,
which is symplectic. However, when I define the S gate on qubit 1 for a 2 qubit circuit in the following way:</p>
<pre><code>   |x0 z0 x1 z1
--+------------
x0|1  0  0  0
z0|1  1  0  0
x1|0  0  1  0
z1|0  0  0  1
s |0  0  0  0
</code></pre>
<p>it is not symplectic using the test defined above! In all other respects, this gate behaves as expected (e.g when composing it with other gates, the composition gives the expected Clifford, as can be seen in the test file <a href=""https://github.com/liorella-qm/CliffordTableau/blob/master/test_simple_tableau.py"" rel=""nofollow noreferrer"">here</a>.)</p>
<p>So what am I missing here? Which one of my definitions is incorrect?</p>
",why does this definition of multi qubit Clifford Tableaus not pass symplectic test?,<simulation><clifford-group>,2,0,,,"why does this definition of multi qubit Clifford Tableaus not pass symplectic test? <p>I am attempting to write a <a href=""https://github.com/liorella-qm/CliffordTableau"" rel=""nofollow noreferrer"">module</a> for composition of Clifford Tableaus using only elementary arithmetic and logical operations. Everything seems to be working fine, except that as far as I understand, the matrices whose columns are the image of each Pauli X/Z operator should be symplectic, namely, pass the test:</p>
<p><span class=""math-container"">$$
g^T\Lambda g = \Lambda
$$</span>
where
<span class=""math-container"">$$
\Lambda = \begin{pmatrix}0 &amp; I_n \\ I_n &amp; 0\end{pmatrix},
$$</span>
and the field is <span class=""math-container"">$\mathbb{F}_2$</span>, namely, I perform all additions and multiplications mod 2.</p>
<p>While single qubit Cliffords do pass this test, e.g, S gate has the tableau:</p>
<pre><code>   |x0 z0
--+------
x0|1  0
z0|1  1
s |0  0
</code></pre>
<p>where <code>s</code> is a sign bit,
which is symplectic. However, when I define the S gate on qubit 1 for a 2 qubit circuit in the following way:</p>
<pre><code>   |x0 z0 x1 z1
--+------------
x0|1  0  0  0
z0|1  1  0  0
x1|0  0  1  0
z1|0  0  0  1
s |0  0  0  0
</code></pre>
<p>it is not symplectic using the test defined above! In all other respects, this gate behaves as expected (e.g when composing it with other gates, the composition gives the expected Clifford, as can be seen in the test file <a href=""https://github.com/liorella-qm/CliffordTableau/blob/master/test_simple_tableau.py"" rel=""nofollow noreferrer"">here</a>.)</p>
<p>So what am I missing here? Which one of my definitions is incorrect?</p>
",qc,definition multi qubit clifford tableaus pass symplectic test p attempting write https nofollow noreferrer module composition clifford tableaus using elementary arithmetic logical operations everything seems working fine except far understand matrices whose columns image pauli operator symplectic namely pass test p span g span pmatrix 0 amp amp pmatrix field span f namely perform additions multiplications mod p single qubit cliffords pass test gate tableau pre code z0 0 1 0 p code sign bit symplectic however define gate qubit 1 2 qubit circuit following way pre code z0 x1 z1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 p symplectic using test defined respects gate behaves expected composing gates composition gives expected clifford seen test file https nofollow noreferrer p missing one definitions incorrect,"[(2, 0.1905677), (3, 0.16073805), (4, 0.06205423), (5, 0.012827978), (7, 0.04222986), (9, 0.1277805), (12, 0.01588954), (14, 0.2892038), (15, 0.048199385), (17, 0.017285379), (18, 0.024193339)]"
25994,,2022-04-16 20:04:05,8,282,"<p>It is well-known that there are <a href=""https://doi.org/10.48550/arXiv.quant-ph/0005115"" rel=""nofollow noreferrer"">two ways to entangle three qubits</a> and <a href=""https://doi.org/10.48550/arXiv.quant-ph/0109033"" rel=""nofollow noreferrer"">nine ways to entangle four qubits</a>.</p>
<p>In page 22 of <a href=""https://doi.org/10.48550/arXiv.2101.02431"" rel=""nofollow noreferrer"">this paper</a> I found that there are infinitely many ways to entangle five qubits, but I am not sure how to see or prove this or if this is correct.</p>
",Five qubits can be entangled in how many ways?,<entanglement>,0,3,,,"Five qubits can be entangled in how many ways? <p>It is well-known that there are <a href=""https://doi.org/10.48550/arXiv.quant-ph/0005115"" rel=""nofollow noreferrer"">two ways to entangle three qubits</a> and <a href=""https://doi.org/10.48550/arXiv.quant-ph/0109033"" rel=""nofollow noreferrer"">nine ways to entangle four qubits</a>.</p>
<p>In page 22 of <a href=""https://doi.org/10.48550/arXiv.2101.02431"" rel=""nofollow noreferrer"">this paper</a> I found that there are infinitely many ways to entangle five qubits, but I am not sure how to see or prove this or if this is correct.</p>
",qc,five qubits entangled many ways p https nofollow noreferrer two ways entangle three qubits https nofollow noreferrer nine ways entangle four qubits p page 22 https nofollow noreferrer paper found infinitely many ways entangle five qubits sure see prove,"[(4, 0.26944783), (9, 0.37513247), (12, 0.026981601), (13, 0.07497229), (18, 0.24953753)]"
25998,,2022-04-17 05:15:17,1,202,"<p>I am trying to calculate the state of this Quirk circuit by hand:</p>
<p><a href=""https://i.sstatic.net/QYNIn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QYNIn.png"" alt=""enter image description here"" /></a></p>
<p>where U is a custom gate with 2x2 matrix:</p>
<p><a href=""https://i.sstatic.net/qwMZV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qwMZV.png"" alt=""enter image description here"" /></a></p>
<p>From what I've read, I should be able to calculate the resultant amplitudes as:</p>
<p><strong>(U⊗I⊗I).(anti_controlled_H⊗I).(anti_Toffoli)</strong></p>
<p>which is</p>
<p><a href=""https://i.sstatic.net/fHYlD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fHYlD.png"" alt=""calculation"" /></a></p>
<p>But the resulting amplitudes in Wolfram Alpha do not match the Quirk output, leading me to believe I've made fundamental mistake. What am I missing?</p>
",Manually calculating quantum circuit with custom gate,<quantum-gate><quantum-circuit><matrix-representation><quirk>,1,0,,,"Manually calculating quantum circuit with custom gate <p>I am trying to calculate the state of this Quirk circuit by hand:</p>
<p><a href=""https://i.sstatic.net/QYNIn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QYNIn.png"" alt=""enter image description here"" /></a></p>
<p>where U is a custom gate with 2x2 matrix:</p>
<p><a href=""https://i.sstatic.net/qwMZV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qwMZV.png"" alt=""enter image description here"" /></a></p>
<p>From what I've read, I should be able to calculate the resultant amplitudes as:</p>
<p><strong>(U⊗I⊗I).(anti_controlled_H⊗I).(anti_Toffoli)</strong></p>
<p>which is</p>
<p><a href=""https://i.sstatic.net/fHYlD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fHYlD.png"" alt=""calculation"" /></a></p>
<p>But the resulting amplitudes in Wolfram Alpha do not match the Quirk output, leading me to believe I've made fundamental mistake. What am I missing?</p>
",qc,manually calculating quantum circuit custom gate p trying calculate state quirk circuit hand p https nofollow noreferrer img https enter image description p u custom gate 2x2 matrix p https nofollow noreferrer img https enter image description p read able calculate resultant amplitudes p strong p p https nofollow noreferrer img https calculation p resulting amplitudes wolfram alpha match quirk output leading believe made fundamental mistake missing,"[(0, 0.022890003), (4, 0.7227873), (7, 0.025283106), (11, 0.012005662), (12, 0.019842967), (13, 0.09785731), (14, 0.097397566)]"
26048,26074.0,2022-04-19 20:12:41,1,167,"<p>I was expecting Qiskit to do a upside down version of my unitary as it does for other unitary matrices of CNOT and Toffoli gates given in textbooks : if you convert a toffoli matrix from quantum computing textbooks(target 3rd and ctrl 1st,2nd) you will get an inverted version of it (target as q0 and ctrl as q1,q2).<br />
So I hardcoded a unitary matrix and converted to gate then appended to qc. But the operator returns exactly the same matrix, so I wonder if my unitary is actually upside down but operator just shows flipped output ?</p>
<p>Hard coded matrix :
<a href=""https://i.sstatic.net/HBJts.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HBJts.png"" alt=""Hard coded matrix"" /></a>
Operator output :
<a href=""https://i.sstatic.net/Rh0hV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Rh0hV.png"" alt=""Operator Output"" /></a></p>
<p>Code :</p>
<pre><code>u = QuantumCircuit(qr)
u.unitary(UA, range(qr), label='U')
unitary = u.to_gate()
unitary.name = 'U'
</code></pre>
<p>mpl display :</p>
<pre><code>qc = QuantumCircuit(qr)
qc.append(unitary, range(0, qr))
qc.draw(&quot;mpl&quot;, style='bw')
</code></pre>
<p><a href=""https://i.sstatic.net/ZbSZIt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZbSZIt.png"" alt=""mpl display"" /></a></p>
",Why Qiskit doesn't invert hard coded unitary matrix?,<qiskit><programming><matrix-representation>,1,1,,,"Why Qiskit doesn't invert hard coded unitary matrix? <p>I was expecting Qiskit to do a upside down version of my unitary as it does for other unitary matrices of CNOT and Toffoli gates given in textbooks : if you convert a toffoli matrix from quantum computing textbooks(target 3rd and ctrl 1st,2nd) you will get an inverted version of it (target as q0 and ctrl as q1,q2).<br />
So I hardcoded a unitary matrix and converted to gate then appended to qc. But the operator returns exactly the same matrix, so I wonder if my unitary is actually upside down but operator just shows flipped output ?</p>
<p>Hard coded matrix :
<a href=""https://i.sstatic.net/HBJts.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HBJts.png"" alt=""Hard coded matrix"" /></a>
Operator output :
<a href=""https://i.sstatic.net/Rh0hV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Rh0hV.png"" alt=""Operator Output"" /></a></p>
<p>Code :</p>
<pre><code>u = QuantumCircuit(qr)
u.unitary(UA, range(qr), label='U')
unitary = u.to_gate()
unitary.name = 'U'
</code></pre>
<p>mpl display :</p>
<pre><code>qc = QuantumCircuit(qr)
qc.append(unitary, range(0, qr))
qc.draw(&quot;mpl&quot;, style='bw')
</code></pre>
<p><a href=""https://i.sstatic.net/ZbSZIt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ZbSZIt.png"" alt=""mpl display"" /></a></p>
",qc,qiskit invert hard coded unitary matrix p expecting qiskit upside version unitary unitary matrices cnot toffoli gates given textbooks convert toffoli matrix quantum computing textbooks target 3rd ctrl get inverted version target q0 ctrl q1 q2 br hardcoded unitary matrix converted gate appended qc operator returns exactly matrix wonder unitary actually upside operator shows flipped output p hard coded matrix https nofollow noreferrer img https hard coded matrix operator output https nofollow noreferrer img https operator output p code pre code u quantumcircuit qr ua range qr u unitary u p mpl display pre code qc quantumcircuit qr unitary range 0 qr quot mpl quot p https nofollow noreferrer img https mpl display,"[(0, 0.36492658), (3, 0.08737744), (4, 0.2766377), (9, 0.11973387), (11, 0.066784464), (12, 0.02779298), (13, 0.024602398), (16, 0.018536946), (19, 0.012599088)]"
26072,26073.0,2022-04-20 18:44:18,2,83,"<p>I'm trying to prove that my quantum circuit is behaving the way I want it to, which means I want to calculate its state vector. Until entanglement, I can show it works using the bloch-sphere - after entanglement that option is gone, so I have to go back to good 'ol maths.</p>
<p>This is my circuit (Simplified and made smaller to easen up initial calculations):
<a href=""https://i.sstatic.net/yjtfg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yjtfg.png"" alt=""Simple 3 qubit circuit with an RY layer, as well as selected CRZ entanglement"" /></a></p>
<p>So these are the steps I have so far:</p>
<p>Initial state
<span class=""math-container"">$$
q_0 =\ q_1 =\ q_2 =\ |0\rangle\\
$$</span></p>
<p>State after RY-Gate
<span class=""math-container"">$$
q_0 =\ q_1 =\ q_2 =\ RY(c_i)|0\rangle =\ \begin{pmatrix}
        \cos{\frac{c_i}{2}} &amp; -\sin{\frac{c_i}{2}} \\
        \sin{\frac{c_i}{2}} &amp; \cos{\frac{c_i}{2}}
    \end{pmatrix}|0\rangle =\ \begin{pmatrix}
        \cos{\frac{c_i}{2}}\\
        \sin{\frac{c_i}{2}}\\
    \end{pmatrix}\\
$$</span></p>
<p>Now before applying the CRZ-Gates we create the tensor product of all qubits</p>
<p><span class=""math-container"">$$
q_2 \otimes q_1 \otimes q_0 =\ \begin{pmatrix}
     \cos{\frac{c0}{2}}\cos{\frac{c1}{2}}\cos{\frac{c2}{2}}\\
     \cos{\frac{c1}{2}}\cos{\frac{c2}{2}}\sin{\frac{c0}{2}}\\
     \cos{\frac{c0}{2}}\cos{\frac{c2}{2}}\sin{\frac{c1}{2}}\\
     \cos{\frac{c2}{2}}\sin{\frac{c0}{2}}\sin{\frac{c1}{2}}\\
     \cos{\frac{c0}{2}}\cos{\frac{c1}{2}}\sin{\frac{c2}{2}}\\
     \cos{\frac{c1}{2}}\sin{\frac{c0}{2}}\sin{\frac{c2}{2}}\\
     \cos{\frac{c0}{2}}\sin{\frac{c1}{2}}\sin{\frac{c2}{2}}\\
     \sin{\frac{c0}{2}}\sin{\frac{c1}{2}}\sin{\frac{c2}{2}}\\
     \end{pmatrix}
$$</span></p>
<p>The CRZ Gate for <code>s02</code> has to match the size of the tensor product, but only apply to the qubit 0 and 2. Standard CRZ gate
<span class=""math-container"">$$
\begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; e^{-i\frac{\lambda}{2}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; e^{i\frac{\lambda}{2}}
    \end{pmatrix}
$$</span></p>
<p>Now we make it 8x8 in size.
<span class=""math-container"">$$
CRZ^{8\times 8}_{q_0,q_2} =\ \begin{pmatrix}
     1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; e^{-i\frac{\lambda}{2}} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e^{i\frac{\lambda}{2}}\\
     \end{pmatrix}
$$</span></p>
<p>Now, the <span class=""math-container"">$CRZ^{8\times 8}_{q_0,q_2}$</span> gate is something I think is correct? I get the tensor product of all qubits, and then I change the <span class=""math-container"">$CRZ$</span> gate so that it can be used to calculate, but does not touch the state of <span class=""math-container"">$q_1$</span>. To be completely honest, I don't know if this works, or is the right approach. Until now, I only calculated entanglement in circular fashion of neighbouring qubits, which is straightforward, but I somehow can't even find much literature on this, which might also be because I'm using the wrong formalism.</p>
",Calculating entanglement with CRZ Gates on non-neighbor qubits,<quantum-state><entanglement><quantum-circuit><linear-algebra>,1,0,,,"Calculating entanglement with CRZ Gates on non-neighbor qubits <p>I'm trying to prove that my quantum circuit is behaving the way I want it to, which means I want to calculate its state vector. Until entanglement, I can show it works using the bloch-sphere - after entanglement that option is gone, so I have to go back to good 'ol maths.</p>
<p>This is my circuit (Simplified and made smaller to easen up initial calculations):
<a href=""https://i.sstatic.net/yjtfg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yjtfg.png"" alt=""Simple 3 qubit circuit with an RY layer, as well as selected CRZ entanglement"" /></a></p>
<p>So these are the steps I have so far:</p>
<p>Initial state
<span class=""math-container"">$$
q_0 =\ q_1 =\ q_2 =\ |0\rangle\\
$$</span></p>
<p>State after RY-Gate
<span class=""math-container"">$$
q_0 =\ q_1 =\ q_2 =\ RY(c_i)|0\rangle =\ \begin{pmatrix}
        \cos{\frac{c_i}{2}} &amp; -\sin{\frac{c_i}{2}} \\
        \sin{\frac{c_i}{2}} &amp; \cos{\frac{c_i}{2}}
    \end{pmatrix}|0\rangle =\ \begin{pmatrix}
        \cos{\frac{c_i}{2}}\\
        \sin{\frac{c_i}{2}}\\
    \end{pmatrix}\\
$$</span></p>
<p>Now before applying the CRZ-Gates we create the tensor product of all qubits</p>
<p><span class=""math-container"">$$
q_2 \otimes q_1 \otimes q_0 =\ \begin{pmatrix}
     \cos{\frac{c0}{2}}\cos{\frac{c1}{2}}\cos{\frac{c2}{2}}\\
     \cos{\frac{c1}{2}}\cos{\frac{c2}{2}}\sin{\frac{c0}{2}}\\
     \cos{\frac{c0}{2}}\cos{\frac{c2}{2}}\sin{\frac{c1}{2}}\\
     \cos{\frac{c2}{2}}\sin{\frac{c0}{2}}\sin{\frac{c1}{2}}\\
     \cos{\frac{c0}{2}}\cos{\frac{c1}{2}}\sin{\frac{c2}{2}}\\
     \cos{\frac{c1}{2}}\sin{\frac{c0}{2}}\sin{\frac{c2}{2}}\\
     \cos{\frac{c0}{2}}\sin{\frac{c1}{2}}\sin{\frac{c2}{2}}\\
     \sin{\frac{c0}{2}}\sin{\frac{c1}{2}}\sin{\frac{c2}{2}}\\
     \end{pmatrix}
$$</span></p>
<p>The CRZ Gate for <code>s02</code> has to match the size of the tensor product, but only apply to the qubit 0 and 2. Standard CRZ gate
<span class=""math-container"">$$
\begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; e^{-i\frac{\lambda}{2}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; e^{i\frac{\lambda}{2}}
    \end{pmatrix}
$$</span></p>
<p>Now we make it 8x8 in size.
<span class=""math-container"">$$
CRZ^{8\times 8}_{q_0,q_2} =\ \begin{pmatrix}
     1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; e^{-i\frac{\lambda}{2}} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
     0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e^{i\frac{\lambda}{2}}\\
     \end{pmatrix}
$$</span></p>
<p>Now, the <span class=""math-container"">$CRZ^{8\times 8}_{q_0,q_2}$</span> gate is something I think is correct? I get the tensor product of all qubits, and then I change the <span class=""math-container"">$CRZ$</span> gate so that it can be used to calculate, but does not touch the state of <span class=""math-container"">$q_1$</span>. To be completely honest, I don't know if this works, or is the right approach. Until now, I only calculated entanglement in circular fashion of neighbouring qubits, which is straightforward, but I somehow can't even find much literature on this, which might also be because I'm using the wrong formalism.</p>
",qc,calculating entanglement crz gates qubits p trying prove quantum circuit behaving way want means want calculate state vector entanglement show works using entanglement option gone go back good p circuit simplified made smaller easen initial calculations https nofollow noreferrer img https simple 3 qubit circuit ry layer well selected crz entanglement p steps far p initial state span p state span ry pmatrix 2 amp 2 2 amp 2 pmatrix pmatrix 2 2 pmatrix p applying create tensor product qubits p span pmatrix c0 2 c1 2 c2 2 c1 2 c2 2 c0 2 c0 2 c2 2 c1 2 c2 2 c0 2 c1 2 c0 2 c1 2 c2 2 c1 2 c0 2 c2 2 c0 2 c1 2 c2 2 c0 2 c1 2 c2 2 pmatrix p crz gate code s02 match size tensor product apply qubit 0 standard crz gate span pmatrix 1 amp 0 amp 0 amp 0 0 amp 2 amp 0 amp 0 0 amp 0 amp 1 amp 0 0 amp 0 amp 0 amp 2 pmatrix p make 8x8 size span 8 pmatrix 1 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 2 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 0 amp 2 pmatrix p span 8 gate something think correct get tensor product qubits change span crz gate used calculate touch state span completely honest know works right approach calculated entanglement circular fashion neighbouring qubits straightforward somehow ca even find much literature might also using wrong,"[(2, 0.31980416), (4, 0.02781238), (7, 0.030518694), (9, 0.010516782), (12, 0.025045978), (14, 0.12946485), (15, 0.3937975), (18, 0.06268457)]"
26239,26246.0,2022-05-02 07:46:12,1,386,"<p>I am using source code of split_dataset_to_data_and_labels as I am unable to install qiskit-aqua because of error. But in that source code, &quot;keys&quot; is not being identified. I am using qiskit's tutorials as I am learning, and code I wrote from it, is-:</p>
<pre><code>feature_dim = 2
training_dataset_size = 20
testing_dataset_size = 10
shot = 10000
sample_Total, training_input, test_input, class_labels = ad_hoc_data(training_size=training_dataset_size,
                                                                    test_size=testing_dataset_size,
                                                                    gap=0.3,
                                                                    n=feature_dim,
                                                                    plot_data=True)
datapoints, class_to_label = split_dataset_to_data_and_labels(test_input)
print(class_to_label)
</code></pre>
<p>It is giving this error-:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Input In [6], in &lt;cell line: 10&gt;()
      4 shot = 10000
      5 sample_Total, training_input, test_input, class_labels = ad_hoc_data(training_size=training_dataset_size,
      6                                                                     test_size=testing_dataset_size,
      7                                                                     gap=0.3,
      8                                                                     n=feature_dim,
      9                                                                     plot_data=True)
---&gt; 10 datapoints, class_to_label = split_dataset_to_data_and_labels(test_input)
     11 print(class_to_label)

Input In [4], in split_dataset_to_data_and_labels(dataset, class_names)
     22 labels = []
     23 if class_names is None:
---&gt; 24     sorted_classes_name = sorted(list(dataset.keys()))
     25     class_to_label = {k: idx for idx, k in enumerate(sorted_classes_name)}
     26 else:

AttributeError: 'numpy.ndarray' object has no attribute 'keys'
</code></pre>
<p>The link to source code, I am using is <a href=""https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py</a> .
I found at <a href=""https://stackoverflow.com/questions/66591189/can-you-help-me-in-this-error-attributeerror-numpy-ndarray-object-has-no-att"">https://stackoverflow.com/questions/66591189/can-you-help-me-in-this-error-attributeerror-numpy-ndarray-object-has-no-att</a> that flags can be used but it also gives error.</p>
",split_dataset_to_data_and_labels in qiskit not working correctly,<qiskit><programming>,1,0,,,"split_dataset_to_data_and_labels in qiskit not working correctly <p>I am using source code of split_dataset_to_data_and_labels as I am unable to install qiskit-aqua because of error. But in that source code, &quot;keys&quot; is not being identified. I am using qiskit's tutorials as I am learning, and code I wrote from it, is-:</p>
<pre><code>feature_dim = 2
training_dataset_size = 20
testing_dataset_size = 10
shot = 10000
sample_Total, training_input, test_input, class_labels = ad_hoc_data(training_size=training_dataset_size,
                                                                    test_size=testing_dataset_size,
                                                                    gap=0.3,
                                                                    n=feature_dim,
                                                                    plot_data=True)
datapoints, class_to_label = split_dataset_to_data_and_labels(test_input)
print(class_to_label)
</code></pre>
<p>It is giving this error-:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Input In [6], in &lt;cell line: 10&gt;()
      4 shot = 10000
      5 sample_Total, training_input, test_input, class_labels = ad_hoc_data(training_size=training_dataset_size,
      6                                                                     test_size=testing_dataset_size,
      7                                                                     gap=0.3,
      8                                                                     n=feature_dim,
      9                                                                     plot_data=True)
---&gt; 10 datapoints, class_to_label = split_dataset_to_data_and_labels(test_input)
     11 print(class_to_label)

Input In [4], in split_dataset_to_data_and_labels(dataset, class_names)
     22 labels = []
     23 if class_names is None:
---&gt; 24     sorted_classes_name = sorted(list(dataset.keys()))
     25     class_to_label = {k: idx for idx, k in enumerate(sorted_classes_name)}
     26 else:

AttributeError: 'numpy.ndarray' object has no attribute 'keys'
</code></pre>
<p>The link to source code, I am using is <a href=""https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-aqua/blob/main/qiskit/aqua/utils/dataset_helper.py</a> .
I found at <a href=""https://stackoverflow.com/questions/66591189/can-you-help-me-in-this-error-attributeerror-numpy-ndarray-object-has-no-att"">https://stackoverflow.com/questions/66591189/can-you-help-me-in-this-error-attributeerror-numpy-ndarray-object-has-no-att</a> that flags can be used but it also gives error.</p>
",qc,qiskit working correctly p using source code unable install error source code quot keys quot identified using qiskit tutorials learning code wrote pre code 2 20 10 shot 10000 datapoints print p giving pre code attributeerror traceback recent call last input 6 lt cell line 10 gt 4 shot 10000 5 6 7 8 9 gt 10 datapoints 11 print input 4 dataset 22 labels 23 none gt 24 sorted list 25 k idx idx k enumerate 26 else attributeerror object attribute p link source code using https nofollow noreferrer https found https https flags used also gives,"[(0, 0.5953393), (4, 0.110188015), (6, 0.19454047), (8, 0.05025938), (12, 0.010805103), (19, 0.037396476)]"
26241,26344.0,2022-05-02 10:15:17,2,630,"<p>I want to calculate the mean expectation value of an PauliSumOp within qiskit after I executed a QAOA Circuit. My approach is the following:</p>
<pre><code># Run and get counts
job=qiskit.execute(circuit,backend=simulator,shots=shots,optimization_level=0)
result = job.result().get_counts()
# Compute average expectation value of the observable H Ising
max_count=0
value=0
for string,count in result.items():
    value+=count*sum([(~StateFn(string)@ op @ StateFn(string)).eval() for op in hamiltonian])
    max_count+=count
expectation=value/max_count
</code></pre>
<p>Is this correct? I am especially concerned if <code>StateFn(Bitstring)</code> is a valid usage of qiskit in terms of <code>StateFn(&quot;0101&quot;)</code>=<span class=""math-container"">$|0101\rangle$</span></p>
",Qiskit compute mean expectation value,<qiskit><programming><qaoa>,2,2,,,"Qiskit compute mean expectation value <p>I want to calculate the mean expectation value of an PauliSumOp within qiskit after I executed a QAOA Circuit. My approach is the following:</p>
<pre><code># Run and get counts
job=qiskit.execute(circuit,backend=simulator,shots=shots,optimization_level=0)
result = job.result().get_counts()
# Compute average expectation value of the observable H Ising
max_count=0
value=0
for string,count in result.items():
    value+=count*sum([(~StateFn(string)@ op @ StateFn(string)).eval() for op in hamiltonian])
    max_count+=count
expectation=value/max_count
</code></pre>
<p>Is this correct? I am especially concerned if <code>StateFn(Bitstring)</code> is a valid usage of qiskit in terms of <code>StateFn(&quot;0101&quot;)</code>=<span class=""math-container"">$|0101\rangle$</span></p>
",qc,qiskit compute mean expectation value p want calculate mean expectation value paulisumop within qiskit executed qaoa circuit approach following pre code run get counts circuit result compute average expectation value observable h ising string count sum string op statefn string op hamiltonian p correct especially concerned code statefn bitstring valid usage qiskit terms code statefn quot 0101 quot span,"[(0, 0.3967227), (1, 0.12077967), (3, 0.045421094), (12, 0.018399235), (14, 0.36393863), (19, 0.052200884)]"
26392,,2022-05-14 11:37:17,1,133,"<p>While sometimes the jobs run without any problem, and in other cases there are errors that can tell how to troubleshoot, in this case it seems there is no explanation from IBM.</p>
<p>Has anyone had similar problems? What is the solution?</p>
<p>The circuit is correct. It is not clear why the transpiling was &quot;cancelled&quot;. This is not a one-time rare incidence. It is running fine on other devices.</p>
<p><a href=""https://i.sstatic.net/HnR1v.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HnR1v.png"" alt=""enter image description here"" /></a></p>
",IBM Q jobs being cancelled without error or explanation?,<ibm-q-experience>,1,3,,,"IBM Q jobs being cancelled without error or explanation? <p>While sometimes the jobs run without any problem, and in other cases there are errors that can tell how to troubleshoot, in this case it seems there is no explanation from IBM.</p>
<p>Has anyone had similar problems? What is the solution?</p>
<p>The circuit is correct. It is not clear why the transpiling was &quot;cancelled&quot;. This is not a one-time rare incidence. It is running fine on other devices.</p>
<p><a href=""https://i.sstatic.net/HnR1v.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HnR1v.png"" alt=""enter image description here"" /></a></p>
",qc,ibm q jobs cancelled without error explanation p sometimes jobs run without problem cases errors tell troubleshoot case seems explanation p anyone similar problems solution p circuit correct clear transpiling quot cancelled quot rare incidence running fine p https nofollow noreferrer img https enter image description,"[(1, 0.04245966), (4, 0.3545372), (7, 0.09213084), (10, 0.024888908), (12, 0.021316627), (14, 0.3281256), (19, 0.1335932)]"
26589,,2022-05-27 03:32:19,1,200,"<p>In my incredibly elementary understanding of superconducting qubits, a qubit is an LC circuit where the inductor has been replaced with a Josephson junction. In this system, microwave pulse operations to implement transformations on the qubit is achieved by a microwave drive line which coupled to the qubit with a capacitor.</p>
<p>In Qiskit Pulse, we usually play our pulses on the DriveChannel, which I assume is directly related to the time varying voltage at the end of the microwave drive line (though I’m a little unsure of where the AWGs come in?). In this big picture, I’m not so sure where the ControlChannel comes into play. All the Qiskit docs say is that it is “associated with multi-qubit gates,” but I am still unsure of how the ControlChannel is physically implemented or when to use it instead of the regular DriveChannel.</p>
",What’s the difference between the DriveChannel and the Control Channel?,<qiskit><programming><openpulse><hardware>,1,0,,,"What’s the difference between the DriveChannel and the Control Channel? <p>In my incredibly elementary understanding of superconducting qubits, a qubit is an LC circuit where the inductor has been replaced with a Josephson junction. In this system, microwave pulse operations to implement transformations on the qubit is achieved by a microwave drive line which coupled to the qubit with a capacitor.</p>
<p>In Qiskit Pulse, we usually play our pulses on the DriveChannel, which I assume is directly related to the time varying voltage at the end of the microwave drive line (though I’m a little unsure of where the AWGs come in?). In this big picture, I’m not so sure where the ControlChannel comes into play. All the Qiskit docs say is that it is “associated with multi-qubit gates,” but I am still unsure of how the ControlChannel is physically implemented or when to use it instead of the regular DriveChannel.</p>
",qc,difference drivechannel control channel p incredibly elementary understanding superconducting qubits qubit lc circuit inductor replaced josephson junction system microwave pulse operations implement transformations qubit achieved microwave drive line coupled qubit p qiskit pulse usually play pulses drivechannel assume directly related time varying voltage end microwave drive line though little unsure awgs come big picture sure controlchannel comes play qiskit docs say associated gates still unsure controlchannel physically implemented use instead regular,"[(8, 0.15857492), (9, 0.37202078), (12, 0.030594436), (13, 0.06350109), (14, 0.37313816)]"
26690,,2022-06-02 08:10:38,4,348,"<p>I am trying to run a Qiskit QAOA algorithm on AWS Rigetti Aspen M 1 Backend using qiskit braket provider. However qiskit is not able to properly transpile the circuit</p>
<pre><code>optimizer = COBYLA(maxiter=50)
provider = AWSBraketProvider()
backend = QuantumInstance(
    provider.get_backend(&quot;Aspen-M-1&quot;),
    shots=1024,
    seed_transpiler=algorithm_globals.random_seed,
    seed_simulator=algorithm_globals.random_seed,
)
qaoa = QAOA(
    reps=p,
    expectation=cvar_exp,
    optimizer=optimizer,
    quantum_instance=backend,
    callback=store_intermediate_result,
)
ckt=qaoa.construct_circuit([1.0,1.5],qubit_op)
ckt[0].draw()
transpiled_circuit = transpile(
    ckt[0], 
    backend=provider.get_backend(&quot;Aspen-M-1&quot;), 
    #seed_transpiler=42
)
transpiled_circuit.draw(idle_wires=False, fold=-1)
</code></pre>
<p>leads to the following error:</p>
<pre><code>This backend's operations: h,id,p,rx,ry,rz,s,sdg,t,tdg,x,y,z only apply to a subset of qubits. Using this property to get 'basis_gates' for the transpiler may potentially create invalid output
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-117-94170a3bccca&gt; in &lt;module&gt;
     40 transpiled_circuit = transpile(
     41     ckt[0],
---&gt; 42     backend=provider.get_backend(&quot;Aspen-M-1&quot;),
     43     #seed_transpiler=42
     44 )

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/compiler/transpiler.py in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target)
    302 
    303     # Transpile circuits in parallel
--&gt; 304     circuits = parallel_map(_transpile_circuit, list(zip(circuits, transpile_args)))
    305 
    306     end_time = time()

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/tools/parallel.py in parallel_map(task, values, task_args, task_kwargs, num_processes)
    127         return []
    128     if len(values) == 1:
--&gt; 129         return [task(values[0], *task_args, **task_kwargs)]
    130 
    131     Publisher().publish(&quot;terra.parallel.start&quot;, len(values))

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/compiler/transpiler.py in _transpile_circuit(circuit_config_tuple)
    388 
    389     result = pass_manager.run(
--&gt; 390         circuit, callback=transpile_config[&quot;callback&quot;], output_name=transpile_config[&quot;output_name&quot;]
    391     )
    392 

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/passmanager.py in run(self, circuits, output_name, callback)
    220             return circuits
    221         if isinstance(circuits, QuantumCircuit):
--&gt; 222             return self._run_single_circuit(circuits, output_name, callback)
    223         if len(circuits) == 1:
    224             return self._run_single_circuit(circuits[0], output_name, callback)

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/passmanager.py in _run_single_circuit(self, circuit, output_name, callback)
    275         &quot;&quot;&quot;
    276         running_passmanager = self._create_running_passmanager()
--&gt; 277         result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    278         self.property_set = running_passmanager.property_set
    279         return result

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/runningpassmanager.py in run(***failed resolving arguments***)
    122         for passset in self.working_list:
    123             for pass_ in passset:
--&gt; 124                 dag = self._do_pass(pass_, dag, passset.options)
    125 
    126         circuit = dag_to_circuit(dag)

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/runningpassmanager.py in _do_pass(self, pass_, dag, options)
    155             # Run the pass itself, if not already run
    156             if pass_ not in self.valid_passes:
--&gt; 157                 dag = self._run_this_pass(pass_, dag)
    158 
    159                 # update the valid_passes property

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/runningpassmanager.py in _run_this_pass(self, pass_, dag)
    209             # Measure time if we have a callback or logging set
    210             start_time = time()
--&gt; 211             pass_.run(FencedDAGCircuit(dag))
    212             end_time = time()
    213             run_time = end_time - start_time

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py in run(self, dag)
     44         &quot;&quot;&quot;
     45         self.property_set[&quot;is_direction_mapped&quot;] = True
---&gt; 46         edges = self.coupling_map.get_edges()
     47         trivial_layout = Layout.generate_trivial_layout(*dag.qregs.values())
     48         if self.target is None:

AttributeError: 'NoneType' object has no attribute 'get_edges'
</code></pre>
<p>Similar error occurs when I try to directly get results by</p>
<pre><code>result = qaoa.compute_minimum_eigenvalue(qubit_op)

</code></pre>
<p>The code works fine with other hardware, it seems only Rigetti has this problem.</p>
",Qiskit unable to transpile the circuit for Rigetti Aspen M 1 on AWS,<qaoa><transpile><amazon-braket><rigetti>,1,0,,,"Qiskit unable to transpile the circuit for Rigetti Aspen M 1 on AWS <p>I am trying to run a Qiskit QAOA algorithm on AWS Rigetti Aspen M 1 Backend using qiskit braket provider. However qiskit is not able to properly transpile the circuit</p>
<pre><code>optimizer = COBYLA(maxiter=50)
provider = AWSBraketProvider()
backend = QuantumInstance(
    provider.get_backend(&quot;Aspen-M-1&quot;),
    shots=1024,
    seed_transpiler=algorithm_globals.random_seed,
    seed_simulator=algorithm_globals.random_seed,
)
qaoa = QAOA(
    reps=p,
    expectation=cvar_exp,
    optimizer=optimizer,
    quantum_instance=backend,
    callback=store_intermediate_result,
)
ckt=qaoa.construct_circuit([1.0,1.5],qubit_op)
ckt[0].draw()
transpiled_circuit = transpile(
    ckt[0], 
    backend=provider.get_backend(&quot;Aspen-M-1&quot;), 
    #seed_transpiler=42
)
transpiled_circuit.draw(idle_wires=False, fold=-1)
</code></pre>
<p>leads to the following error:</p>
<pre><code>This backend's operations: h,id,p,rx,ry,rz,s,sdg,t,tdg,x,y,z only apply to a subset of qubits. Using this property to get 'basis_gates' for the transpiler may potentially create invalid output
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-117-94170a3bccca&gt; in &lt;module&gt;
     40 transpiled_circuit = transpile(
     41     ckt[0],
---&gt; 42     backend=provider.get_backend(&quot;Aspen-M-1&quot;),
     43     #seed_transpiler=42
     44 )

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/compiler/transpiler.py in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target)
    302 
    303     # Transpile circuits in parallel
--&gt; 304     circuits = parallel_map(_transpile_circuit, list(zip(circuits, transpile_args)))
    305 
    306     end_time = time()

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/tools/parallel.py in parallel_map(task, values, task_args, task_kwargs, num_processes)
    127         return []
    128     if len(values) == 1:
--&gt; 129         return [task(values[0], *task_args, **task_kwargs)]
    130 
    131     Publisher().publish(&quot;terra.parallel.start&quot;, len(values))

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/compiler/transpiler.py in _transpile_circuit(circuit_config_tuple)
    388 
    389     result = pass_manager.run(
--&gt; 390         circuit, callback=transpile_config[&quot;callback&quot;], output_name=transpile_config[&quot;output_name&quot;]
    391     )
    392 

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/passmanager.py in run(self, circuits, output_name, callback)
    220             return circuits
    221         if isinstance(circuits, QuantumCircuit):
--&gt; 222             return self._run_single_circuit(circuits, output_name, callback)
    223         if len(circuits) == 1:
    224             return self._run_single_circuit(circuits[0], output_name, callback)

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/passmanager.py in _run_single_circuit(self, circuit, output_name, callback)
    275         &quot;&quot;&quot;
    276         running_passmanager = self._create_running_passmanager()
--&gt; 277         result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    278         self.property_set = running_passmanager.property_set
    279         return result

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/runningpassmanager.py in run(***failed resolving arguments***)
    122         for passset in self.working_list:
    123             for pass_ in passset:
--&gt; 124                 dag = self._do_pass(pass_, dag, passset.options)
    125 
    126         circuit = dag_to_circuit(dag)

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/runningpassmanager.py in _do_pass(self, pass_, dag, options)
    155             # Run the pass itself, if not already run
    156             if pass_ not in self.valid_passes:
--&gt; 157                 dag = self._run_this_pass(pass_, dag)
    158 
    159                 # update the valid_passes property

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/runningpassmanager.py in _run_this_pass(self, pass_, dag)
    209             # Measure time if we have a callback or logging set
    210             start_time = time()
--&gt; 211             pass_.run(FencedDAGCircuit(dag))
    212             end_time = time()
    213             run_time = end_time - start_time

~/anaconda3/envs/Braket/lib/python3.7/site-packages/qiskit/transpiler/passes/utils/check_gate_direction.py in run(self, dag)
     44         &quot;&quot;&quot;
     45         self.property_set[&quot;is_direction_mapped&quot;] = True
---&gt; 46         edges = self.coupling_map.get_edges()
     47         trivial_layout = Layout.generate_trivial_layout(*dag.qregs.values())
     48         if self.target is None:

AttributeError: 'NoneType' object has no attribute 'get_edges'
</code></pre>
<p>Similar error occurs when I try to directly get results by</p>
<pre><code>result = qaoa.compute_minimum_eigenvalue(qubit_op)

</code></pre>
<p>The code works fine with other hardware, it seems only Rigetti has this problem.</p>
",qc,qiskit unable transpile circuit rigetti aspen 1 aws p trying run qiskit qaoa algorithm aws rigetti aspen 1 backend using qiskit braket provider however qiskit able properly transpile circuit pre code optimizer cobyla provider awsbraketprovider backend quantuminstance quot quot qaoa qaoa ckt 0 transpile ckt 0 quot quot p leads following error pre code backend operations h id p rx ry rz sdg tdg x z apply subset qubits using property get transpiler may potentially create invalid output attributeerror traceback recent call last lt gt lt module gt 40 transpile 41 ckt 0 gt 42 quot quot 43 44 transpile circuits backend dt callback target 302 303 transpile circuits parallel gt 304 circuits list zip circuits 305 306 time task values 127 return 128 len values 1 gt 129 return task values 0 130 131 publisher quot quot len values 388 389 result gt 390 circuit quot callback quot quot quot 391 392 run self circuits callback 220 return circuits 221 isinstance circuits quantumcircuit gt 222 return circuits callback 223 len circuits 1 224 return circuits 0 callback self circuit callback 275 quot quot quot 276 gt 277 result circuit 278 279 return result run failed resolving arguments 122 passset 123 passset gt 124 dag dag 125 126 circuit dag self dag options 155 run pass already run 156 gt 157 dag dag 158 159 update property self dag 209 measure time callback logging set 210 time gt 211 fenceddagcircuit dag 212 time 213 run self dag 44 quot quot quot 45 quot quot true gt 46 edges 47 48 none attributeerror object attribute p similar error occurs try directly get results pre code result p code works fine hardware seems rigetti,"[(0, 0.47122246), (2, 0.039109048), (9, 0.010112343), (12, 0.024661865), (14, 0.1854394), (15, 0.03392573), (19, 0.23502886)]"
26693,26737.0,2022-06-02 13:55:23,2,305,"<p>I tried to change a little the code <a href=""https://qiskit.org/textbook/ch-quantum-hardware/measuring-quantum-volume.html"" rel=""nofollow noreferrer"">here</a> for running the quantum volume circuits in real devices. My code is</p>
<pre><code>backend = provider.get_backend('ibmq_bogota')

shots = 1000
for trial in range(ntrials):
    clear_output(wait=True)
    t_qcs = transpile(qv_circs[trial], backend=backend, initial_layout=qubit_lists[0])
    qobj = [assemble(t_qcs)]

    job_manager = IBMQJobManager()
    job_set_foo = job_manager.run(qobj, backend=backend, shots=shots, name='QV trial %d'%(trial))
print(job_set_foo.report(detailed=True))
print(f'Completed trial {trial+1}/{ntrials}')
</code></pre>
<p>But I get</p>
<pre><code>status: job submit failed: 'bad input to assemble() function; must be either circuits or schedules'
</code></pre>
<p>I don't understand how this can fail,since <code>qv_circs</code> must contain the necessary attributes. Note that I wrote <code>qobj = [assemble(t_qcs)]</code> instead of <code>qobj = assemble(t_qcs)</code>. If I do the latter I obtain</p>
<pre><code>'QasmQobj' object is not iterable
</code></pre>
<hr />
<p>EDIT:</p>
<p>Some information about the objects:</p>
<pre><code>print(t_qcs)
[&lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7fa2398698a0&gt;]
print(type(t_qcs))
&lt;class 'list'&gt;
</code></pre>
",QV circuits fail to execute in real devices,<qiskit><ibm-q-experience><quantum-volume>,2,2,,,"QV circuits fail to execute in real devices <p>I tried to change a little the code <a href=""https://qiskit.org/textbook/ch-quantum-hardware/measuring-quantum-volume.html"" rel=""nofollow noreferrer"">here</a> for running the quantum volume circuits in real devices. My code is</p>
<pre><code>backend = provider.get_backend('ibmq_bogota')

shots = 1000
for trial in range(ntrials):
    clear_output(wait=True)
    t_qcs = transpile(qv_circs[trial], backend=backend, initial_layout=qubit_lists[0])
    qobj = [assemble(t_qcs)]

    job_manager = IBMQJobManager()
    job_set_foo = job_manager.run(qobj, backend=backend, shots=shots, name='QV trial %d'%(trial))
print(job_set_foo.report(detailed=True))
print(f'Completed trial {trial+1}/{ntrials}')
</code></pre>
<p>But I get</p>
<pre><code>status: job submit failed: 'bad input to assemble() function; must be either circuits or schedules'
</code></pre>
<p>I don't understand how this can fail,since <code>qv_circs</code> must contain the necessary attributes. Note that I wrote <code>qobj = [assemble(t_qcs)]</code> instead of <code>qobj = assemble(t_qcs)</code>. If I do the latter I obtain</p>
<pre><code>'QasmQobj' object is not iterable
</code></pre>
<hr />
<p>EDIT:</p>
<p>Some information about the objects:</p>
<pre><code>print(t_qcs)
[&lt;qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7fa2398698a0&gt;]
print(type(t_qcs))
&lt;class 'list'&gt;
</code></pre>
",qc,qv circuits fail execute real devices p tried change little code https nofollow noreferrer running quantum volume circuits real devices code pre code backend shots 1000 trial range ntrials transpile trial 0 qobj assemble ibmqjobmanager qobj trial trial print print trial ntrials p get pre code status job submit failed input assemble function must either circuits schedules p understand fail since code must contain necessary attributes note wrote code qobj assemble instead code qobj assemble latter obtain pre code object iterable hr p edit p information objects pre code print lt object 0x7fa2398698a0 gt print type lt class gt,"[(0, 0.5077638), (4, 0.037229758), (8, 0.14172982), (12, 0.0110356845), (14, 0.3006475)]"
26744,,2022-06-06 04:54:39,1,75,"<p>I am trying to perform a lattice surgery. Initial state is <span class=""math-container"">$|0\rangle+|1\rangle$</span> and when I perform a smooth merge and split, I think I get <span class=""math-container"">$|00\rangle+|11\rangle$</span> but it doesn't work. Is there something wrong with the code?</p>
<hr />
<pre><code>
include &quot;qelib1.inc&quot;;
qreg q1[5];
qreg q2[5];
qreg q3[1];
qreg anc[6];
creg c1[5];
creg c2[5];
creg c3[1];


// initial state |+&gt;

h q1[0];
cx q1[0],q1[3];

reset anc;

h anc[0];
cx anc[0],q1[0];
cx anc[0],q1[1];
cx anc[0],q1[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q1[2];
cx anc[0],q1[3];
cx anc[0],q1[4];
h anc[0];


// int bit |+&gt;

h q2[0];
cx q2[0],q2[3];

reset anc;

h anc[0];
cx anc[0],q2[0];
cx anc[0],q2[1];
cx anc[0],q2[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q2[2];
cx anc[0],q2[3];
cx anc[0],q2[4];
h anc[0];

// smooth merge
h q3[0]; 


// Z Stabilizer

reset anc;

h anc[0]; 
cz anc[0],q1[0];
cz anc[0],q2[3];
cz anc[0],q3[0];
h anc[0]; 

reset anc;

h anc[0]; 
cz anc[0],q1[1];
cz anc[0],q2[4];
cz anc[0],q3[0];
h anc[0]; 

measure q3[0] -&gt; c3[0];

measure q1[0] -&gt; c1[0];
measure q1[1] -&gt; c1[1];
measure q1[2] -&gt; c1[2];
measure q1[3] -&gt; c1[3];
measure q1[4] -&gt; c1[4];
measure q2[0] -&gt; c2[0];
measure q2[1] -&gt; c2[1];
measure q2[2] -&gt; c2[2];
measure q2[3] -&gt; c2[3];
measure q2[4] -&gt; c2[4];

</code></pre>
","How to perform lattice surgery with initial state $|0\rangle+|1\rangle$, with qasm?",<programming><error-correction><qasm>,0,0,,,"How to perform lattice surgery with initial state $|0\rangle+|1\rangle$, with qasm? <p>I am trying to perform a lattice surgery. Initial state is <span class=""math-container"">$|0\rangle+|1\rangle$</span> and when I perform a smooth merge and split, I think I get <span class=""math-container"">$|00\rangle+|11\rangle$</span> but it doesn't work. Is there something wrong with the code?</p>
<hr />
<pre><code>
include &quot;qelib1.inc&quot;;
qreg q1[5];
qreg q2[5];
qreg q3[1];
qreg anc[6];
creg c1[5];
creg c2[5];
creg c3[1];


// initial state |+&gt;

h q1[0];
cx q1[0],q1[3];

reset anc;

h anc[0];
cx anc[0],q1[0];
cx anc[0],q1[1];
cx anc[0],q1[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q1[2];
cx anc[0],q1[3];
cx anc[0],q1[4];
h anc[0];


// int bit |+&gt;

h q2[0];
cx q2[0],q2[3];

reset anc;

h anc[0];
cx anc[0],q2[0];
cx anc[0],q2[1];
cx anc[0],q2[2];
h anc[0];

reset anc;

h anc[0];
cx anc[0],q2[2];
cx anc[0],q2[3];
cx anc[0],q2[4];
h anc[0];

// smooth merge
h q3[0]; 


// Z Stabilizer

reset anc;

h anc[0]; 
cz anc[0],q1[0];
cz anc[0],q2[3];
cz anc[0],q3[0];
h anc[0]; 

reset anc;

h anc[0]; 
cz anc[0],q1[1];
cz anc[0],q2[4];
cz anc[0],q3[0];
h anc[0]; 

measure q3[0] -&gt; c3[0];

measure q1[0] -&gt; c1[0];
measure q1[1] -&gt; c1[1];
measure q1[2] -&gt; c1[2];
measure q1[3] -&gt; c1[3];
measure q1[4] -&gt; c1[4];
measure q2[0] -&gt; c2[0];
measure q2[1] -&gt; c2[1];
measure q2[2] -&gt; c2[2];
measure q2[3] -&gt; c2[3];
measure q2[4] -&gt; c2[4];

</code></pre>
",qc,perform lattice surgery initial state qasm p trying perform lattice surgery initial state span perform smooth merge split think get span work something wrong code hr pre code include quot quot qreg q1 5 qreg q2 5 qreg q3 1 qreg anc 6 creg c1 5 creg c2 5 creg c3 1 initial state gt h q1 0 cx q1 0 q1 3 reset anc h anc 0 cx anc 0 q1 0 cx anc 0 q1 1 cx anc 0 q1 2 h anc 0 reset anc h anc 0 cx anc 0 q1 2 cx anc 0 q1 3 cx anc 0 q1 4 h anc 0 int bit gt h q2 0 cx q2 0 q2 3 reset anc h anc 0 cx anc 0 q2 0 cx anc 0 q2 1 cx anc 0 q2 2 h anc 0 reset anc h anc 0 cx anc 0 q2 2 cx anc 0 q2 3 cx anc 0 q2 4 h anc 0 smooth merge h q3 0 z stabilizer reset anc h anc 0 cz anc 0 q1 0 cz anc 0 q2 3 cz anc 0 q3 0 h anc 0 reset anc h anc 0 cz anc 0 q1 1 cz anc 0 q2 4 cz anc 0 q3 0 h anc 0 measure q3 0 gt c3 0 measure q1 0 gt c1 0 measure q1 1 gt c1 1 measure q1 2 gt c1 2 measure q1 3 gt c1 3 measure q1 4 gt c1 4 measure q2 0 gt c2 0 measure q2 1 gt c2 1 measure q2 2 gt c2 2 measure q2 3 gt c2 3 measure q2 4 gt c2 4,"[(0, 0.08280064), (2, 0.26657593), (5, 0.013555518), (6, 0.19229609), (12, 0.022576414), (14, 0.28718215), (16, 0.073870994), (18, 0.055188883)]"
26764,26777.0,2022-06-07 14:41:11,5,172,"<p>I'm reading through this <a href=""https://arxiv.org/pdf/1910.09333.pdf"" rel=""nofollow noreferrer"">paper</a> and on page 14 they define quantum reed muller (QRM) codes using the classical versions. I've seen punctured RM codes used to define quantum CSS codes with good properties; but the paper's definition is with
unpunctured codes. I checked the the <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> stabilizers define a QECC; but the definition of the <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> logicals doesn't seem right. For one, they don't have the same dimensions. They're also orthogonal...which also doesn't make sense. Is the paper wrong or did I miss something?
(the motivation is that these codes allow some transversal non-clifford gates)</p>
<p>I converted the accepted answer to <a href=""https://www.gap-system.org/"" rel=""nofollow noreferrer"">GAP</a>. Here's my version :</p>
<pre><code>    Qrm:=function(m,r)local s,mat,layers,Sx,Sz,Lx,Lz,mx,mz,kx,kz,check,verify,code;
     mat:=Iterated(List([1..m],x-&gt;[[1,1],[0,1]]),KroneckerProduct); # 2^m x 2^m matrix = m-th tensor power of [[1,1],[0,1]]
     layers:=List([0..m],x-&gt;Filtered(mat,y-&gt;Sum(y)=2^(m-x)));       # layer[r]=subset of rows with weight = 2^(m-r)
     s:=m-r-2;
     Sx:=Concatenation(layers{[1..r+1]});  mx:=Length(Sx);            # X satbilisers
     Sz:=Concatenation(layers{[1..s+1]});  mz:=Length(Sz);            # Z satbilisers
     Lx:=layers[r+2];                      kx:=Length(Lx);            # X logicals
     Lz:=layers[s+2];                      kz:=Length(Lz);            # Z logicals
    
     Print(&quot;n =&quot;,2^m,&quot; |Sx|=&quot;,mx,&quot; |Sz|=&quot;,mz,&quot; |Lx|=&quot;,kx,&quot; |Lz|=&quot;,kz,&quot;\n&quot;);
    
     check:=&quot;kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);&quot;;verify:=kx=kz and kx=Binomial(m,r+1) and 2^m-(mx+mz)=kx;Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Sx*Sz=0; &quot;;verify:=\mod(Sx*TransposedMat(Sz),2)=NullMat(mx,mz);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Lx*Sz=0; &quot;;verify:=\mod(Lx*TransposedMat(Sz),2)=NullMat(kx,mz);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Lz*Sx=0; &quot;;verify:=\mod(Lz*TransposedMat(Sx),2)=NullMat(kz,mx);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Lx*Lz=I; &quot;;verify:=\mod(Lx*TransposedMat(Reversed(Lz)),2)=IdentityMat(kz);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
    
     code:=rec();
     code.Sx:=Sx;code.Sz:=Sz;code.Lx:=Lx;code.Lz:=Lz;
     return code;
    end;
</code></pre>
<p>I checked with a few other parameters :</p>
<pre><code>gap&gt; code:=Qrm(6,1);;
n =64 |Sx|=7 |Sz|=42 |Lx|=15 |Lz|=15
true kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);
true Sx*Sz=0; 
true Lx*Sz=0; 
true Lz*Sx=0; 
true Lx*Lz=I; 
gap&gt; code:=Qrm(6,2);;
n =64 |Sx|=22 |Sz|=22 |Lx|=20 |Lz|=20
true kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);
true Sx*Sz=0; 
true Lx*Sz=0; 
true Lz*Sx=0; 
true Lx*Lz=I; 
gap&gt; code:=Qrm(6,0);;
n =64 |Sx|=1 |Sz|=57 |Lx|=6 |Lz|=6
true kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);
true Sx*Sz=0; 
true Lx*Sz=0; 
true Lz*Sx=0; 
true Lx*Lz=I;
</code></pre>
",Discrepancy in definition of quantum reed muller codes,<error-correction><stabilizer-code>,1,0,,,"Discrepancy in definition of quantum reed muller codes <p>I'm reading through this <a href=""https://arxiv.org/pdf/1910.09333.pdf"" rel=""nofollow noreferrer"">paper</a> and on page 14 they define quantum reed muller (QRM) codes using the classical versions. I've seen punctured RM codes used to define quantum CSS codes with good properties; but the paper's definition is with
unpunctured codes. I checked the the <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> stabilizers define a QECC; but the definition of the <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> logicals doesn't seem right. For one, they don't have the same dimensions. They're also orthogonal...which also doesn't make sense. Is the paper wrong or did I miss something?
(the motivation is that these codes allow some transversal non-clifford gates)</p>
<p>I converted the accepted answer to <a href=""https://www.gap-system.org/"" rel=""nofollow noreferrer"">GAP</a>. Here's my version :</p>
<pre><code>    Qrm:=function(m,r)local s,mat,layers,Sx,Sz,Lx,Lz,mx,mz,kx,kz,check,verify,code;
     mat:=Iterated(List([1..m],x-&gt;[[1,1],[0,1]]),KroneckerProduct); # 2^m x 2^m matrix = m-th tensor power of [[1,1],[0,1]]
     layers:=List([0..m],x-&gt;Filtered(mat,y-&gt;Sum(y)=2^(m-x)));       # layer[r]=subset of rows with weight = 2^(m-r)
     s:=m-r-2;
     Sx:=Concatenation(layers{[1..r+1]});  mx:=Length(Sx);            # X satbilisers
     Sz:=Concatenation(layers{[1..s+1]});  mz:=Length(Sz);            # Z satbilisers
     Lx:=layers[r+2];                      kx:=Length(Lx);            # X logicals
     Lz:=layers[s+2];                      kz:=Length(Lz);            # Z logicals
    
     Print(&quot;n =&quot;,2^m,&quot; |Sx|=&quot;,mx,&quot; |Sz|=&quot;,mz,&quot; |Lx|=&quot;,kx,&quot; |Lz|=&quot;,kz,&quot;\n&quot;);
    
     check:=&quot;kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);&quot;;verify:=kx=kz and kx=Binomial(m,r+1) and 2^m-(mx+mz)=kx;Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Sx*Sz=0; &quot;;verify:=\mod(Sx*TransposedMat(Sz),2)=NullMat(mx,mz);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Lx*Sz=0; &quot;;verify:=\mod(Lx*TransposedMat(Sz),2)=NullMat(kx,mz);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Lz*Sx=0; &quot;;verify:=\mod(Lz*TransposedMat(Sx),2)=NullMat(kz,mx);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
     check:=&quot;Lx*Lz=I; &quot;;verify:=\mod(Lx*TransposedMat(Reversed(Lz)),2)=IdentityMat(kz);Print(verify,&quot; &quot;,check,&quot;\n&quot;);
    
     code:=rec();
     code.Sx:=Sx;code.Sz:=Sz;code.Lx:=Lx;code.Lz:=Lz;
     return code;
    end;
</code></pre>
<p>I checked with a few other parameters :</p>
<pre><code>gap&gt; code:=Qrm(6,1);;
n =64 |Sx|=7 |Sz|=42 |Lx|=15 |Lz|=15
true kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);
true Sx*Sz=0; 
true Lx*Sz=0; 
true Lz*Sx=0; 
true Lx*Lz=I; 
gap&gt; code:=Qrm(6,2);;
n =64 |Sx|=22 |Sz|=22 |Lx|=20 |Lz|=20
true kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);
true Sx*Sz=0; 
true Lx*Sz=0; 
true Lz*Sx=0; 
true Lx*Lz=I; 
gap&gt; code:=Qrm(6,0);;
n =64 |Sx|=1 |Sz|=57 |Lx|=6 |Lz|=6
true kx=kz=k; k=Binomial(m,r+1); k=n-(mx+mz);
true Sx*Sz=0; 
true Lx*Sz=0; 
true Lz*Sx=0; 
true Lx*Lz=I;
</code></pre>
",qc,discrepancy definition quantum reed muller codes p reading https nofollow noreferrer paper page 14 define quantum reed muller qrm codes using classical versions seen punctured rm codes used define quantum css codes good properties paper definition unpunctured codes checked span x span z stabilizers define qecc definition span x span z logicals seem right one dimensions also orthogonal also make sense paper wrong miss something motivation codes allow transversal gates p converted accepted answer https nofollow noreferrer gap version pre code qrm r local mat layers sx sz lx lz mx mz kx kz check verify code mat list 1 gt kroneckerproduct x matrix tensor power layers 0 gt filtered mat gt sum layer r rows weight sx layers 1 mx sx x satbilisers sz layers 1 mz sz z satbilisers lx kx lx x logicals lz kz lz z logicals print quot n quot quot quot mx quot quot mz quot quot kx quot quot kz quot quot check quot quot verify print verify quot quot check quot quot check quot sx quot verify sx transposedmat sz mx mz print verify quot quot check quot quot check quot lx quot verify lx transposedmat sz kx mz print verify quot quot check quot quot check quot lz quot verify lz transposedmat sx kz mx print verify quot quot check quot quot check quot lx quot verify lx transposedmat reversed lz kz print verify quot quot check quot quot code return code end p checked parameters pre code gap gt code n true true sx true lx true lz true lx gap gt code n true true sx true lx true lz true lx gap gt code n true true sx true lx true lz true lx,"[(0, 0.22304283), (3, 0.15697613), (5, 0.13140671), (7, 0.050338626), (9, 0.0778997), (10, 0.021385098), (11, 0.022484256), (12, 0.041055597), (19, 0.2605525)]"
26783,26791.0,2022-06-08 13:09:21,1,59,"<p>I was going through <a href=""https://quantumai.google/cirq/tutorials/shor#quantum_order_finder"" rel=""nofollow noreferrer"">Cirq tutorial on Shor's algorithm</a> and was able to implement it successfully using cirq. But it takes forever to run for any <code>n &gt; 21</code>; so I tried to use the qsim simulator instead of using cirq.</p>
<p><strong>What I tried to do -</strong></p>
<p>I replaced <code>measurement = cirq.sample(circuit)</code> with <code>measurement = simulator.simulate(circuit)</code>.</p>
<pre><code>def quantum_order_finder(x: int, n: int) -&gt; Optional[int]:
    if x &lt; 2 or n &lt;= x or math.gcd(x, n) &gt; 1:
        raise ValueError(f'Invalid x={x} for modulus n={n}.')

    circuit = make_order_finding_circuit(x, n)
    
    simulator = qsimcirq.QSimSimulator()
    measurement = simulator.simulate(circuit)
    
    return process_measurement(measurement, x, n)
</code></pre>
<p><strong>The error I got -</strong></p>
<pre><code>&lt;ipython-input-21-b2e4008cd3ca&gt; in quantum_order_finder(x, n)
     22
---&gt; 23     measurement = simulator.simulate(circuit)
     24

/usr/local/lib/python3.7/dist-packages/cirq/sim/simulator.py in simulate(self, program, param_resolver, qubit_order, initial_state)
    517         &quot;&quot;&quot;
    518         return self.simulate_sweep(
--&gt; 519             program, study.ParamResolver(param_resolver), qubit_order, initial_state
    520         )[0]
    521 

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in simulate_sweep(self, program, params, qubit_order, initial_state)
    561                 solved_circuit,
    562                 translator_fn_name,
--&gt; 563                 cirq_order,
    564             )
    565             options[&quot;s&quot;] = self.get_seed()

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in _translate_circuit(self, circuit, translator_fn_name, qubit_order)
    858         if translated_circuit is None:
    859             translator_fn = getattr(circuit, translator_fn_name)
--&gt; 860             translated_circuit, moment_indices = translator_fn(qubit_order)
    861             self._translated_circuits.append(
    862                 (circuit, translated_circuit, moment_indices)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in translate_cirq_to_qsim(self, qubit_order)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in &lt;listcomp&gt;(.0)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/cirq/protocols/decompose_protocol.py in decompose(val, intercepting_decomposer, fallback_decomposer, keep, on_stuck_raise, preserve_structure)
    245                 error = on_stuck_raise(item)
    246                 if error is not None:
--&gt; 247                     raise error
    248 
    249         output.append(item)

ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed: &lt;__main__.ModularExp object at 0x7efe3c3e76d0&gt;
</code></pre>
<p>Is there a difference between <code>simulate(circuit)</code> and <code>sample(circuit)</code> ? And if so, then how do i make the algorithm run with <code>qismcirq</code> instead of <code>cirq</code> ?</p>
",ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed,<simulation><shors-algorithm><cirq>,1,0,,,"ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed <p>I was going through <a href=""https://quantumai.google/cirq/tutorials/shor#quantum_order_finder"" rel=""nofollow noreferrer"">Cirq tutorial on Shor's algorithm</a> and was able to implement it successfully using cirq. But it takes forever to run for any <code>n &gt; 21</code>; so I tried to use the qsim simulator instead of using cirq.</p>
<p><strong>What I tried to do -</strong></p>
<p>I replaced <code>measurement = cirq.sample(circuit)</code> with <code>measurement = simulator.simulate(circuit)</code>.</p>
<pre><code>def quantum_order_finder(x: int, n: int) -&gt; Optional[int]:
    if x &lt; 2 or n &lt;= x or math.gcd(x, n) &gt; 1:
        raise ValueError(f'Invalid x={x} for modulus n={n}.')

    circuit = make_order_finding_circuit(x, n)
    
    simulator = qsimcirq.QSimSimulator()
    measurement = simulator.simulate(circuit)
    
    return process_measurement(measurement, x, n)
</code></pre>
<p><strong>The error I got -</strong></p>
<pre><code>&lt;ipython-input-21-b2e4008cd3ca&gt; in quantum_order_finder(x, n)
     22
---&gt; 23     measurement = simulator.simulate(circuit)
     24

/usr/local/lib/python3.7/dist-packages/cirq/sim/simulator.py in simulate(self, program, param_resolver, qubit_order, initial_state)
    517         &quot;&quot;&quot;
    518         return self.simulate_sweep(
--&gt; 519             program, study.ParamResolver(param_resolver), qubit_order, initial_state
    520         )[0]
    521 

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in simulate_sweep(self, program, params, qubit_order, initial_state)
    561                 solved_circuit,
    562                 translator_fn_name,
--&gt; 563                 cirq_order,
    564             )
    565             options[&quot;s&quot;] = self.get_seed()

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_simulator.py in _translate_circuit(self, circuit, translator_fn_name, qubit_order)
    858         if translated_circuit is None:
    859             translator_fn = getattr(circuit, translator_fn_name)
--&gt; 860             translated_circuit, moment_indices = translator_fn(qubit_order)
    861             self._translated_circuits.append(
    862                 (circuit, translated_circuit, moment_indices)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in translate_cirq_to_qsim(self, qubit_order)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/qsimcirq/qsim_circuit.py in &lt;listcomp&gt;(.0)
    316             ops_by_gate = [
    317                 cirq.decompose(op, fallback_decomposer=to_matrix, keep=has_qsim_kind)
--&gt; 318                 for op in moment
    319             ]
    320             moment_length = max((len(gate_ops) for gate_ops in ops_by_gate), default=0)

/usr/local/lib/python3.7/dist-packages/cirq/protocols/decompose_protocol.py in decompose(val, intercepting_decomposer, fallback_decomposer, keep, on_stuck_raise, preserve_structure)
    245                 error = on_stuck_raise(item)
    246                 if error is not None:
--&gt; 247                     raise error
    248 
    249         output.append(item)

ValueError: Operation doesn't satisfy the given `keep` but can't be decomposed: &lt;__main__.ModularExp object at 0x7efe3c3e76d0&gt;
</code></pre>
<p>Is there a difference between <code>simulate(circuit)</code> and <code>sample(circuit)</code> ? And if so, then how do i make the algorithm run with <code>qismcirq</code> instead of <code>cirq</code> ?</p>
",qc,valueerror operation satisfy given keep ca decomposed p going https nofollow noreferrer cirq tutorial shor algorithm able implement successfully using cirq takes forever run code n gt 21 tried use qsim simulator instead using p strong tried p replaced code measurement circuit code measurement circuit pre code def x int n int gt optional int x lt 2 n lt x x n gt 1 raise valueerror x modulus n circuit x n simulator measurement circuit return measurement x n p strong error got pre code lt gt x n 22 gt 23 measurement circuit 24 simulate self program 517 quot quot quot 518 return gt 519 program 520 0 521 self program params 561 562 gt 563 564 565 options quot quot self circuit 858 none 859 getattr circuit gt 860 861 862 circuit self 316 317 op gt 318 op moment 319 320 max len lt listcomp gt 316 317 op gt 318 op moment 319 320 max len decompose val keep 245 error item 246 error none gt 247 raise error 248 249 item valueerror operation satisfy given keep ca decomposed lt object 0x7efe3c3e76d0 gt p difference code simulate circuit code sample circuit make algorithm run code qismcirq instead code cirq,"[(0, 0.46185014), (4, 0.02606865), (6, 0.049196254), (7, 0.017159976), (10, 0.08473356), (12, 0.01679722), (14, 0.2670712), (16, 0.011461457), (19, 0.06505713)]"
26789,26823.0,2022-06-08 17:46:54,7,300,"<p>Computer scientists and others who are interested in learning more about quantum computation might be exposed, or re-exposed, to various concepts and classes of matrices from linear algebra.  For example because of familiarity with <a href=""https://en.wikipedia.org/wiki/Truth_table"" rel=""nofollow noreferrer"">truth-tables</a>, (classical) reversible operators are often introduced in conjunction with <a href=""https://en.wikipedia.org/wiki/Unitary_matrix"" rel=""nofollow noreferrer"">unitary matrices</a>.</p>
<p>Within quantum mechanics, there are a number of classes of matrices that are commonly used:</p>
<ol>
<li>As mentioned, unitary matrices are matrices <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U^\dagger U = UU^\dagger = I$</span>.  These unitary matrices form the basis for discussion within the <a href=""https://en.wikipedia.org/wiki/Quantum_logic_gate#:%7E:text=In%20quantum%20computing%20and%20specifically,are%20for%20conventional%20digital%20circuits."" rel=""nofollow noreferrer"">gate model</a> of computation.</li>
<li>Furthermore <a href=""https://en.wikipedia.org/wiki/Hermitian_matrix"" rel=""nofollow noreferrer"">hermitian matrices</a> are matrices <span class=""math-container"">$A$</span> such that <span class=""math-container"">$A = A^\dagger$</span>.  These matrices form the basis for, among other things, <a href=""https://en.wikipedia.org/wiki/Adiabatic_quantum_computation"" rel=""nofollow noreferrer"">adiabatic computation</a>.</li>
<li>Additionally there are matrices, such as the creation <span class=""math-container"">$a^\dagger$</span>, annihilation <span class=""math-container"">$a$</span>, and number <span class=""math-container"">$N=a^\dagger a$</span> matrices, commonly referred to as <a href=""https://en.wikipedia.org/wiki/Ladder_operator"" rel=""nofollow noreferrer"">ladder operators</a>.</li>
</ol>
<p>The familiar Pauli matrices <span class=""math-container"">$X$</span>, <span class=""math-container"">$Y$</span>, and <span class=""math-container"">$Z$</span> are both hermitian and unitary, while the creation and annihilation matrices are neither.
Nonetheless reviewing Feynman's 1985 paper <a href=""https://link.springer.com/article/10.1007/BF01886518"" rel=""nofollow noreferrer"">&quot;Quantum Mechanical Computers&quot;</a>, it appears that Feynman envisioned programming a quantum computer with an algebra or a calculus of sorts with sums and products of these ladder operators; indeed, he considered three qubits <span class=""math-container"">$a,b,c$</span> with <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> controlling the negation of <span class=""math-container"">$c$</span>, and wrote a Toffoli gate explicitly as:</p>
<p><span class=""math-container"">$$\mathsf{CCNOT}=1+a^\dagger ab^\dagger b(c+c^\dagger-1).$$</span></p>
<p>But other than Feynman's paper, I'm not aware of any extensive use of these ladder operators in any other model of quantum computation.</p>
<blockquote>
<p>Is there any such model of quantum computation that focuses on ladder operators in lieu of unitary or hermitian operators?  Did Feynman's &quot;calculus&quot; in his 1985 paper ever gain traction anywhere?</p>
</blockquote>
<p>This is also partly motivated because I've read that Sophus Lie sort of envisioned infinitesimal generators of what we now call a Lie algebra as actual elements of the Lie group; it took others like Killing and Cartan to revise and formalize this intuition, and to put the <a href=""https://en.wikipedia.org/wiki/Lie_group%E2%80%93Lie_algebra_correspondence"" rel=""nofollow noreferrer"">Lie group - Lie algebra</a> correspondence on more solid footing in the sense that the Lie algebra &quot;linearizes&quot; or is &quot;tangent to&quot; the Lie group.</p>
<p>I think perhaps there may be a similar analogy between the works of Feynman and, for example, Lloyd and Kitaev and Aharanov and others who came after, in the sense that these ladder operators somehow &quot;linearize&quot; or are &quot;tangent to&quot; the Hamiltonian, which enables Hamiltonian simulation.  I'm trying to understand more of Feynman's intuition regarding these operators, but I might be making this analogy in hindsight.</p>
",Are ladder operators ever extensively used in any model of quantum computation?,<computational-models><history>,1,0,,,"Are ladder operators ever extensively used in any model of quantum computation? <p>Computer scientists and others who are interested in learning more about quantum computation might be exposed, or re-exposed, to various concepts and classes of matrices from linear algebra.  For example because of familiarity with <a href=""https://en.wikipedia.org/wiki/Truth_table"" rel=""nofollow noreferrer"">truth-tables</a>, (classical) reversible operators are often introduced in conjunction with <a href=""https://en.wikipedia.org/wiki/Unitary_matrix"" rel=""nofollow noreferrer"">unitary matrices</a>.</p>
<p>Within quantum mechanics, there are a number of classes of matrices that are commonly used:</p>
<ol>
<li>As mentioned, unitary matrices are matrices <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U^\dagger U = UU^\dagger = I$</span>.  These unitary matrices form the basis for discussion within the <a href=""https://en.wikipedia.org/wiki/Quantum_logic_gate#:%7E:text=In%20quantum%20computing%20and%20specifically,are%20for%20conventional%20digital%20circuits."" rel=""nofollow noreferrer"">gate model</a> of computation.</li>
<li>Furthermore <a href=""https://en.wikipedia.org/wiki/Hermitian_matrix"" rel=""nofollow noreferrer"">hermitian matrices</a> are matrices <span class=""math-container"">$A$</span> such that <span class=""math-container"">$A = A^\dagger$</span>.  These matrices form the basis for, among other things, <a href=""https://en.wikipedia.org/wiki/Adiabatic_quantum_computation"" rel=""nofollow noreferrer"">adiabatic computation</a>.</li>
<li>Additionally there are matrices, such as the creation <span class=""math-container"">$a^\dagger$</span>, annihilation <span class=""math-container"">$a$</span>, and number <span class=""math-container"">$N=a^\dagger a$</span> matrices, commonly referred to as <a href=""https://en.wikipedia.org/wiki/Ladder_operator"" rel=""nofollow noreferrer"">ladder operators</a>.</li>
</ol>
<p>The familiar Pauli matrices <span class=""math-container"">$X$</span>, <span class=""math-container"">$Y$</span>, and <span class=""math-container"">$Z$</span> are both hermitian and unitary, while the creation and annihilation matrices are neither.
Nonetheless reviewing Feynman's 1985 paper <a href=""https://link.springer.com/article/10.1007/BF01886518"" rel=""nofollow noreferrer"">&quot;Quantum Mechanical Computers&quot;</a>, it appears that Feynman envisioned programming a quantum computer with an algebra or a calculus of sorts with sums and products of these ladder operators; indeed, he considered three qubits <span class=""math-container"">$a,b,c$</span> with <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> controlling the negation of <span class=""math-container"">$c$</span>, and wrote a Toffoli gate explicitly as:</p>
<p><span class=""math-container"">$$\mathsf{CCNOT}=1+a^\dagger ab^\dagger b(c+c^\dagger-1).$$</span></p>
<p>But other than Feynman's paper, I'm not aware of any extensive use of these ladder operators in any other model of quantum computation.</p>
<blockquote>
<p>Is there any such model of quantum computation that focuses on ladder operators in lieu of unitary or hermitian operators?  Did Feynman's &quot;calculus&quot; in his 1985 paper ever gain traction anywhere?</p>
</blockquote>
<p>This is also partly motivated because I've read that Sophus Lie sort of envisioned infinitesimal generators of what we now call a Lie algebra as actual elements of the Lie group; it took others like Killing and Cartan to revise and formalize this intuition, and to put the <a href=""https://en.wikipedia.org/wiki/Lie_group%E2%80%93Lie_algebra_correspondence"" rel=""nofollow noreferrer"">Lie group - Lie algebra</a> correspondence on more solid footing in the sense that the Lie algebra &quot;linearizes&quot; or is &quot;tangent to&quot; the Lie group.</p>
<p>I think perhaps there may be a similar analogy between the works of Feynman and, for example, Lloyd and Kitaev and Aharanov and others who came after, in the sense that these ladder operators somehow &quot;linearize&quot; or are &quot;tangent to&quot; the Hamiltonian, which enables Hamiltonian simulation.  I'm trying to understand more of Feynman's intuition regarding these operators, but I might be making this analogy in hindsight.</p>
",qc,ladder operators ever extensively used model quantum computation p computer scientists others interested learning quantum computation might exposed various concepts classes matrices linear algebra example familiarity https nofollow noreferrer classical reversible operators often introduced conjunction https nofollow noreferrer unitary matrices p within quantum mechanics number classes matrices commonly used ol li mentioned unitary matrices matrices span u span u unitary matrices form basis discussion within https 7e 20quantum 20computing 20and 20specifically 20for 20conventional 20digital 20circuits nofollow noreferrer gate model li furthermore https nofollow noreferrer hermitian matrices matrices span span matrices form basis among things https nofollow noreferrer adiabatic computation li additionally matrices creation span annihilation span number span matrices commonly referred https nofollow noreferrer ladder operators p familiar pauli matrices span x span span z hermitian unitary creation annihilation matrices neither nonetheless reviewing feynman 1985 paper https nofollow noreferrer quot quantum mechanical computers quot appears feynman envisioned programming quantum computer algebra calculus sorts sums products ladder operators indeed considered three qubits span b c span span b controlling negation span c wrote toffoli gate explicitly p span ccnot b p feynman paper aware extensive use ladder operators model quantum blockquote p model quantum computation focuses ladder operators lieu unitary hermitian operators feynman quot calculus quot 1985 paper ever gain traction anywhere p also partly motivated read sophus lie sort envisioned infinitesimal generators call lie algebra actual elements lie group took others like killing cartan revise formalize intuition put https e2 80 nofollow noreferrer lie group lie algebra correspondence solid footing sense lie algebra quot linearizes quot quot tangent quot lie p think perhaps may similar analogy works feynman example lloyd kitaev aharanov others came sense ladder operators somehow quot linearize quot quot tangent quot hamiltonian enables hamiltonian simulation trying understand feynman intuition regarding operators might making analogy,"[(1, 0.043334994), (3, 0.2826348), (4, 0.054875202), (7, 0.010982704), (8, 0.20032924), (9, 0.2839065), (10, 0.015644701), (12, 0.010773289), (13, 0.01129018), (18, 0.033676285), (19, 0.052228987)]"
26844,,2022-06-12 02:37:34,2,390,"<p>It seems like all the worry about quantum computers breaking encryption is based on speculation that someday quantum computers will break modern encryption. I think we can all agree it will happen at some point, but I have yet to find any credible information that gives an accurate timeline for this. &quot;Experts&quot; say 30 years, but where do they come up with these time estimates? Do we even know how many qubits we would need to break RSA or similar algorithms? I haven't been able to find any credible information to answer these questions.</p>
<p>Let's say we will have a quantum computer in 30 years that can break RSA, what type of data is even worth grabbing now that will be relevant in 30 years? Are there any instances of a &quot;harvest now, decrypt later&quot; attack yet?</p>
<p>Thank you for your input.</p>
","Are there any examples of ""harvest now, decrypt later"" that we know of?",<cryptography>,0,4,,,"Are there any examples of ""harvest now, decrypt later"" that we know of? <p>It seems like all the worry about quantum computers breaking encryption is based on speculation that someday quantum computers will break modern encryption. I think we can all agree it will happen at some point, but I have yet to find any credible information that gives an accurate timeline for this. &quot;Experts&quot; say 30 years, but where do they come up with these time estimates? Do we even know how many qubits we would need to break RSA or similar algorithms? I haven't been able to find any credible information to answer these questions.</p>
<p>Let's say we will have a quantum computer in 30 years that can break RSA, what type of data is even worth grabbing now that will be relevant in 30 years? Are there any instances of a &quot;harvest now, decrypt later&quot; attack yet?</p>
<p>Thank you for your input.</p>
",qc,examples harvest decrypt later know p seems like worry quantum computers breaking encryption based speculation someday quantum computers break modern encryption think agree happen point yet find credible information gives accurate timeline quot experts quot say 30 years come time estimates even know many qubits would need break rsa similar algorithms able find credible information answer p let say quantum computer 30 years break rsa type data even worth grabbing relevant 30 years instances quot harvest decrypt later quot attack yet p thank,"[(1, 0.067743815), (7, 0.072714515), (8, 0.6399864), (9, 0.08210779), (11, 0.013692009), (12, 0.013060838), (13, 0.048671953), (19, 0.060423166)]"
26993,26996.0,2022-06-22 01:31:11,1,745,"<p>I have read Fujitsu's white paper for a brief introduction to their device:
<a href=""http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf"" rel=""nofollow noreferrer"">http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf</a>
As far as I know, Fujitsu's hardware is not quantum-mechanical. They call it a digital annealer inspired by quantum phenomenon. I'm curious about what it actually is, and what kind of algorithm it runs. Is it a classical computer or some specialized annealing device? If the former, what kind of annealing algorithm does it use? As for the latter, I'm not sure whether that kind of device actually exists. (Quantum annealers like the ones D-wave has belongs to this category, but Fujitsu doesn't have those.)</p>
",How does Fujitsu's digital annealer work?,<classical-computing><annealing><quantum-inspired>,1,0,,,"How does Fujitsu's digital annealer work? <p>I have read Fujitsu's white paper for a brief introduction to their device:
<a href=""http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf"" rel=""nofollow noreferrer"">http://marketing.us.fujitsu.com/rs/407-MTR-501/images/quantum-inspired-computing.pdf</a>
As far as I know, Fujitsu's hardware is not quantum-mechanical. They call it a digital annealer inspired by quantum phenomenon. I'm curious about what it actually is, and what kind of algorithm it runs. Is it a classical computer or some specialized annealing device? If the former, what kind of annealing algorithm does it use? As for the latter, I'm not sure whether that kind of device actually exists. (Quantum annealers like the ones D-wave has belongs to this category, but Fujitsu doesn't have those.)</p>
",qc,fujitsu digital annealer work p read fujitsu white paper brief introduction device http nofollow noreferrer http far know fujitsu hardware call digital annealer inspired quantum phenomenon curious actually kind algorithm runs classical computer specialized annealing device former kind annealing algorithm use latter sure whether kind device actually exists quantum annealers like ones belongs category fujitsu,"[(1, 0.1824403), (4, 0.08113847), (8, 0.47408453), (9, 0.17240815), (12, 0.018083671), (15, 0.037731256), (16, 0.03175488)]"
27101,,2022-06-27 10:08:17,0,411,"<p>This is a question I have based on <a href=""https://quantumcomputing.stackexchange.com/questions/27063/gradient-descent-for-a-quantum-classical-hybrid-neural-network"">this</a> previous question on calculating quantum gradients in quantum-classical hybrid circuits. I would like to understand the output of the <code>CircuitQNN</code> class in <code>qiskit_machine_learning.neural_networks</code>.</p>
<p>Based on <a href=""https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.neural_networks.CircuitQNN.html"" rel=""nofollow noreferrer"">this</a> documentation and <a href=""https://qiskit.org/documentation/machine-learning/tutorials/01_neural_networks.html#4.1-Output:-sparse-integer-probabilities"" rel=""nofollow noreferrer"">this</a> tutorial on using <code>CircuitQNN</code> within <code>TorchConnector</code>, what do <code>sparse-integer probabilities</code> and <code>dense-integer probabilities</code> correspond to? To gain some insight, I reproduced results from the tutorial and performed measurement on a copy of the same quantum circuit. The tests were performed with <code>algorithm_globals.random_seed = 42</code></p>
<p>Experiment 01:</p>
<pre><code>algorithm_globals.random_seed = 42
num_qubits = 3
qc = RealAmplitudes(num_qubits, entanglement=&quot;linear&quot;, reps=1)

qnn4 = CircuitQNN(qc, [], qc.parameters, sparse=True, quantum_instance=qi_qasm)

# define (random) input and weights
input4 = algorithm_globals.random.random(qnn4.num_inputs)
weights4 = algorithm_globals.random.random(qnn4.num_weights)

# QNN forward pass
qnn4.forward(input4, weights4).todense()
print(qnn4.forward(input4, weights4).todense())
-------
#The result being:
&gt;&gt; array([[0.24609375, 0.05566406, 0., 0., 0.41308594,
        0.09765625, 0.00976562, 0.17773438]]) 
</code></pre>
<p>Experiment 02:</p>
<pre><code>algorithm_globals.random_seed = 42
circ = qc.copy() ; circ.measure_all()
circ.assign_parameters(dict(zip(circ.parameters,
                                algorithm_globals.random.random(len(circ.parameters)))), inplace=True)
results = qi_qasm.run(qiskit.transpile(circ, qi_qasm), shots=1000).result()
plot_histogram(results.get_counts())
</code></pre>
<p><a href=""https://i.sstatic.net/aJ7a1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/aJ7a1.png"" alt=""Output of Experiment 02"" /></a></p>
<p>We notice that the two probability values are similar but not the same. To quantify the difference I calculated the <a href=""https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence"" rel=""nofollow noreferrer"">KL divergence</a> of these two distributions wrt the uniformly random distribution over (<span class=""math-container"">$2^3$</span>=8) basis. The KL_div values are: 0.6349 and 0.6362 respectively. So I am assuming that <code>CircuitQNN</code> generates the output distribution by performing some shot-measurements? In any case, I do not understand the output of <code>qnn4.backward()</code>. How am I supposed to interpret the gradients from this output?</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt;qnn4.backward(input4, weights4)
(None, &lt;COO: shape=(1, 8, 6), dtype=float64, nnz=46, fill_value=0.0&gt;)
</code></pre>
<p>Further, I'll be grateful if someone can explain what is being done in Sec4.2 on dense parity probabilites in the <a href=""https://qiskit.org/documentation/machine-learning/tutorials/01_neural_networks.html#4.2-Output:-dense-parity-probabilities"" rel=""nofollow noreferrer"">same</a> tutorial.</p>
",How does CircuitQNN in qiskit machine learning calculate output probabiltiies?,<qiskit><quantum-circuit>,1,0,,,"How does CircuitQNN in qiskit machine learning calculate output probabiltiies? <p>This is a question I have based on <a href=""https://quantumcomputing.stackexchange.com/questions/27063/gradient-descent-for-a-quantum-classical-hybrid-neural-network"">this</a> previous question on calculating quantum gradients in quantum-classical hybrid circuits. I would like to understand the output of the <code>CircuitQNN</code> class in <code>qiskit_machine_learning.neural_networks</code>.</p>
<p>Based on <a href=""https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.neural_networks.CircuitQNN.html"" rel=""nofollow noreferrer"">this</a> documentation and <a href=""https://qiskit.org/documentation/machine-learning/tutorials/01_neural_networks.html#4.1-Output:-sparse-integer-probabilities"" rel=""nofollow noreferrer"">this</a> tutorial on using <code>CircuitQNN</code> within <code>TorchConnector</code>, what do <code>sparse-integer probabilities</code> and <code>dense-integer probabilities</code> correspond to? To gain some insight, I reproduced results from the tutorial and performed measurement on a copy of the same quantum circuit. The tests were performed with <code>algorithm_globals.random_seed = 42</code></p>
<p>Experiment 01:</p>
<pre><code>algorithm_globals.random_seed = 42
num_qubits = 3
qc = RealAmplitudes(num_qubits, entanglement=&quot;linear&quot;, reps=1)

qnn4 = CircuitQNN(qc, [], qc.parameters, sparse=True, quantum_instance=qi_qasm)

# define (random) input and weights
input4 = algorithm_globals.random.random(qnn4.num_inputs)
weights4 = algorithm_globals.random.random(qnn4.num_weights)

# QNN forward pass
qnn4.forward(input4, weights4).todense()
print(qnn4.forward(input4, weights4).todense())
-------
#The result being:
&gt;&gt; array([[0.24609375, 0.05566406, 0., 0., 0.41308594,
        0.09765625, 0.00976562, 0.17773438]]) 
</code></pre>
<p>Experiment 02:</p>
<pre><code>algorithm_globals.random_seed = 42
circ = qc.copy() ; circ.measure_all()
circ.assign_parameters(dict(zip(circ.parameters,
                                algorithm_globals.random.random(len(circ.parameters)))), inplace=True)
results = qi_qasm.run(qiskit.transpile(circ, qi_qasm), shots=1000).result()
plot_histogram(results.get_counts())
</code></pre>
<p><a href=""https://i.sstatic.net/aJ7a1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/aJ7a1.png"" alt=""Output of Experiment 02"" /></a></p>
<p>We notice that the two probability values are similar but not the same. To quantify the difference I calculated the <a href=""https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence"" rel=""nofollow noreferrer"">KL divergence</a> of these two distributions wrt the uniformly random distribution over (<span class=""math-container"">$2^3$</span>=8) basis. The KL_div values are: 0.6349 and 0.6362 respectively. So I am assuming that <code>CircuitQNN</code> generates the output distribution by performing some shot-measurements? In any case, I do not understand the output of <code>qnn4.backward()</code>. How am I supposed to interpret the gradients from this output?</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt;qnn4.backward(input4, weights4)
(None, &lt;COO: shape=(1, 8, 6), dtype=float64, nnz=46, fill_value=0.0&gt;)
</code></pre>
<p>Further, I'll be grateful if someone can explain what is being done in Sec4.2 on dense parity probabilites in the <a href=""https://qiskit.org/documentation/machine-learning/tutorials/01_neural_networks.html#4.2-Output:-dense-parity-probabilities"" rel=""nofollow noreferrer"">same</a> tutorial.</p>
",qc,circuitqnn qiskit machine learning calculate output probabiltiies p question based https previous question calculating quantum gradients hybrid circuits would like understand output code circuitqnn class code p based https nofollow noreferrer documentation https nofollow noreferrer tutorial using code circuitqnn within code torchconnector code probabilities code probabilities correspond gain insight reproduced results tutorial performed measurement copy quantum circuit tests performed code 42 p experiment 01 pre code 42 3 qc realamplitudes quot linear quot qnn4 circuitqnn qc define random input weights input4 weights4 qnn forward pass input4 weights4 print input4 weights4 result gt gt array p experiment 02 pre code 42 circ dict zip len results circ p https nofollow noreferrer img https output experiment 02 p notice two probability values similar quantify difference calculated https e2 80 nofollow noreferrer kl divergence two distributions wrt uniformly random distribution span basis values respectively assuming code circuitqnn generates output distribution performing case understand output code supposed interpret gradients output p example pre code gt gt gt input4 weights4 none lt coo 1 8 6 gt p grateful someone explain done dense parity probabilites https nofollow noreferrer,"[(0, 0.21647799), (3, 0.090077974), (4, 0.19660197), (5, 0.014741201), (6, 0.034207337), (8, 0.083927445), (12, 0.014570272), (13, 0.015657412), (14, 0.3147271), (19, 0.018412273)]"
27115,27238.0,2022-06-28 10:46:19,0,166,"<p>I have installed boto3, aws cli, and python-braket-sdk. I have run <code>aws configure</code>, and config with my IAM user. My IAM user isn't root user, but it has <code>AdministratorAccess</code>, <code>AmazonBraketFullAccess</code>, <code>AmazonBraketJobsExecutionPolicy</code> policies.</p>
<p>But if I tried to get some quantum device by this command:<code>aws braket get-device --device-arn arn:aws:braket:::device/qpu/ionq/ionQdevice</code>, it always return this error:</p>
<p><code>An error occurred (AccessDeniedException) when calling the GetDevice operation: User: arn:aws:iam::178363055402:user/hblab-rnd is not authorized to perform: braket:GetDevice on resource: arn:aws:braket::178363055402:device/qpu/ionq/ionQdevice with an explicit deny</code></p>
<p>If I run same below python from this link: <a href=""https://github.com/aws/amazon-braket-sdk-python#usage"" rel=""nofollow noreferrer"">https://github.com/aws/amazon-braket-sdk-python#usage</a>, it also return similar error:</p>
<pre><code>import boto3
from braket.aws import AwsDevice
from braket.circuits import Circuit
device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)
bell = Circuit().h(0).cnot(0, 1)
task = device.run(bell, shots=100)
print(task.result().measurement_counts)
</code></pre>
<p>Error output:</p>
<pre><code>AccessDeniedException: An error occurred (AccessDeniedException) when calling the GetDevice 
operation: User: arn:aws:iam::178363055402:user/hblab-rnd is not authorized to perform: 
braket:GetDevice on resource: arn:aws:braket::178363055402:device/quantum-simulator/amazon/sv1 
with an explicit deny
</code></pre>
<p>I have already added permissions for Braket, but I can not figure the reason for this bug. Please help</p>
<p><strong>System information</strong></p>
<ul>
<li><strong>aws cli</strong>: aws-cli/2.7.11 Python/3.9.11 Windows/10 exe/AMD64 prompt/off</li>
<li><strong>Amazon Braket Python SDK version</strong>: 1.25.2</li>
<li><strong>Amazon Braket schemas</strong>: 1.10.0</li>
<li><strong>Amazon Braket default simulator</strong>: 1.6.2</li>
<li><strong>Python version</strong>: 3.8.13</li>
</ul>
",AWS braket python sdk: user is not authorized to perform on quantum device,<amazon-braket>,2,0,,,"AWS braket python sdk: user is not authorized to perform on quantum device <p>I have installed boto3, aws cli, and python-braket-sdk. I have run <code>aws configure</code>, and config with my IAM user. My IAM user isn't root user, but it has <code>AdministratorAccess</code>, <code>AmazonBraketFullAccess</code>, <code>AmazonBraketJobsExecutionPolicy</code> policies.</p>
<p>But if I tried to get some quantum device by this command:<code>aws braket get-device --device-arn arn:aws:braket:::device/qpu/ionq/ionQdevice</code>, it always return this error:</p>
<p><code>An error occurred (AccessDeniedException) when calling the GetDevice operation: User: arn:aws:iam::178363055402:user/hblab-rnd is not authorized to perform: braket:GetDevice on resource: arn:aws:braket::178363055402:device/qpu/ionq/ionQdevice with an explicit deny</code></p>
<p>If I run same below python from this link: <a href=""https://github.com/aws/amazon-braket-sdk-python#usage"" rel=""nofollow noreferrer"">https://github.com/aws/amazon-braket-sdk-python#usage</a>, it also return similar error:</p>
<pre><code>import boto3
from braket.aws import AwsDevice
from braket.circuits import Circuit
device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)
bell = Circuit().h(0).cnot(0, 1)
task = device.run(bell, shots=100)
print(task.result().measurement_counts)
</code></pre>
<p>Error output:</p>
<pre><code>AccessDeniedException: An error occurred (AccessDeniedException) when calling the GetDevice 
operation: User: arn:aws:iam::178363055402:user/hblab-rnd is not authorized to perform: 
braket:GetDevice on resource: arn:aws:braket::178363055402:device/quantum-simulator/amazon/sv1 
with an explicit deny
</code></pre>
<p>I have already added permissions for Braket, but I can not figure the reason for this bug. Please help</p>
<p><strong>System information</strong></p>
<ul>
<li><strong>aws cli</strong>: aws-cli/2.7.11 Python/3.9.11 Windows/10 exe/AMD64 prompt/off</li>
<li><strong>Amazon Braket Python SDK version</strong>: 1.25.2</li>
<li><strong>Amazon Braket schemas</strong>: 1.10.0</li>
<li><strong>Amazon Braket default simulator</strong>: 1.6.2</li>
<li><strong>Python version</strong>: 3.8.13</li>
</ul>
",qc,aws braket python sdk user authorized perform quantum device p installed boto3 aws cli run code aws configure config iam user iam user root user code administratoraccess code amazonbraketfullaccess code amazonbraketjobsexecutionpolicy p tried get quantum device command code aws braket arn aws braket always return error p code error occurred accessdeniedexception calling getdevice operation user arn aws iam authorized perform braket getdevice resource arn aws braket explicit deny p run python link https usage nofollow noreferrer https usage also return similar error pre code import boto3 import awsdevice import circuit device awsdevice quot arn aws braket quot bell circuit 0 0 1 task bell print p error output pre code accessdeniedexception error occurred accessdeniedexception calling getdevice operation user arn aws iam authorized perform braket getdevice resource arn aws braket explicit deny p already added permissions braket figure reason bug please help p strong system information ul li strong aws cli li strong amazon braket python sdk version li strong amazon braket schemas li strong amazon braket default simulator li strong python version,"[(0, 0.06708238), (2, 0.018051574), (4, 0.038435016), (7, 0.07253069), (12, 0.042313237), (14, 0.6875341), (18, 0.03884227), (19, 0.027561264)]"
27122,27123.0,2022-06-29 02:35:29,0,173,"<p><a href=""https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits"" rel=""nofollow noreferrer"">https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits</a></p>
<pre><code>  &gt; TranspilerError                           Traceback (most recent call
    &gt; last) File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\circuit_gradient.py:92,
    &gt; in CircuitGradient._transpile_to_supported_operations(circuit,
    &gt; supported_gates)
    &gt;      91 try:
    &gt; ---&gt; 92     circuit = transpile(
    &gt;      93         circuit, basis_gates=list(supported_gates), optimization_level=0
    &gt;      94     )
    &gt;      95 except Exception as exc:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\compiler\transpiler.py:304, in
    &gt; transpile(circuits, backend, basis_gates, inst_map, coupling_map,
    &gt; backend_properties, initial_layout, layout_method, routing_method,
    &gt; translation_method, scheduling_method, instruction_durations, dt,
    &gt; approximation_degree, timing_constraints, seed_transpiler,
    &gt; optimization_level, callback, output_name, unitary_synthesis_method,
    &gt; unitary_synthesis_plugin_config, target)
    &gt;     303 # Transpile circuits in parallel
    &gt; --&gt; 304 circuits = parallel_map(_transpile_circuit, list(zip(circuits, transpile_args)))
    &gt;     306 end_time = time()
    &gt; 
    &gt; File d:\miniconda3\lib\site-packages\qiskit\tools\parallel.py:129, in
    &gt; parallel_map(task, values, task_args, task_kwargs, num_processes)
    &gt;     128 if len(values) == 1:
    &gt; --&gt; 129     return [task(values[0], *task_args, **task_kwargs)]
    &gt;     131 Publisher().publish(&quot;terra.parallel.start&quot;, len(values))
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\compiler\transpiler.py:389, in
    &gt; _transpile_circuit(circuit_config_tuple)
    &gt;     387     raise TranspilerError(&quot;optimization_level can range from 0 to 3.&quot;)
    &gt; --&gt; 389 result = pass_manager.run(
    &gt;     390     circuit, callback=transpile_config[&quot;callback&quot;], output_name=transpile_config[&quot;output_name&quot;]
    &gt;     391 )
    &gt;     393 if transpile_config[&quot;faulty_qubits_map&quot;]:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\passmanager.py:222,
    &gt; in PassManager.run(self, circuits, output_name, callback)
    &gt;     221 if isinstance(circuits, QuantumCircuit):
    &gt; --&gt; 222     return self._run_single_circuit(circuits, output_name, callback)
    &gt;     223 if len(circuits) == 1:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\passmanager.py:277,
    &gt; in PassManager._run_single_circuit(self, circuit, output_name,
    &gt; callback)
    &gt;     276 running_passmanager = self._create_running_passmanager()
    &gt; --&gt; 277 result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    &gt;     278 self.property_set = running_passmanager.property_set
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\runningpassmanager.py:124,
    &gt; in RunningPassManager.run(***failed resolving arguments***)
    &gt;     123     for pass_ in passset:
    &gt; --&gt; 124         dag = self._do_pass(pass_, dag, passset.options)
    &gt;     126 circuit = dag_to_circuit(dag)
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\runningpassmanager.py:157,
    &gt; in RunningPassManager._do_pass(self, pass_, dag, options)
    &gt;     156 if pass_ not in self.valid_passes:
    &gt; --&gt; 157     dag = self._run_this_pass(pass_, dag)
    &gt;     159     # update the valid_passes property
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\runningpassmanager.py:186,
    &gt; in RunningPassManager._run_this_pass(self, pass_, dag)
    &gt;     185 start_time = time()
    &gt; --&gt; 186 new_dag = pass_.run(dag)
    &gt;     187 end_time = time()
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\passes\basis\basis_translator.py:206,
    &gt; in BasisTranslator.run(self, dag)
    &gt;     205 if basis_transforms is None:
    &gt; --&gt; 206     raise TranspilerError(
    &gt;     207         &quot;Unable to map source basis {} to target basis {} &quot;
    &gt;     208         &quot;over library {}.&quot;.format(source_basis, target_basis, self._equiv_lib)
    &gt;     209     )
    &gt;     211 # Compose found path into a set of instruction substitution rules.
    &gt; 
    &gt; TranspilerError: &quot;Unable to map source basis {('h', 1),
    &gt; ('save_density_matrix', 3), ('swap', 2), ('ry', 1), ('ccx', 3),
    &gt; ('barrier', 18), ('cx', 2)} to target basis {'rz', 'ry', 'y',
    &gt; 'barrier', 'u', 'snapshot', 'h', 'z', 'measure', 'x', 'cx', 'delay',
    &gt; 'cz', 'reset', 'p', 'rx', 'cy'} over library
    &gt; &lt;qiskit.circuit.equivalence.EquivalenceLibrary object at
    &gt; 0x000001D80DDAD310&gt;.&quot;
    &gt; 
    &gt; The above exception was the direct cause of the following exception:
    &gt; 
    &gt; QiskitError                               Traceback (most recent call
    &gt; last) Input In [13], in &lt;cell line: 41&gt;()
    &gt;      38 print(finite_difference)
    &gt;      40 shifter = Gradient()  # parameter-shift rule is the default
    &gt; ---&gt; 41 grad = shifter.convert(expectation, params=QC.parameters[index])
    &gt;      42 sampler.convert(grad, value_dict).eval().real
    &gt;      44 tmp = init_states(num_words, qbits_for_single_word) 
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\gradient.py:78,
    &gt; in Gradient.convert(self, operator, params)
    &gt;      76 expec_op = PauliExpectation(group_paulis=False).convert(operator).reduce()
    &gt;      77 cleaned_op = self._factor_coeffs_out_of_composed_op(expec_op)
    &gt; ---&gt; 78 return self.get_gradient(cleaned_op, param)
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\gradient.py:182,
    &gt; in Gradient.get_gradient(self, operator, params)
    &gt;     176     if not isinstance(operator[-1], CircuitStateFn):
    &gt;     177         raise TypeError(
    &gt;     178             &quot;The gradient framework is compatible with states that are given as &quot;
    &gt;     179             &quot;CircuitStateFn&quot;
    &gt;     180         )
    &gt; --&gt; 182     return self.grad_method.convert(operator, param)
    &gt;     184 elif isinstance(operator, CircuitStateFn):
    &gt;     185     # Gradient of an a state's sampling probabilities
    &gt;     186     if not is_coeff_c(operator._coeff, 1.0):
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\param_shift.py:116,
    &gt; in ParamShift.convert(self, operator, params)
    &gt;      96 &quot;&quot;&quot;
    &gt;      97 Args:
    &gt;      98     operator: The operator corresponding to our quantum state we are taking the    (...)
    &gt;     113 
    &gt;     114 &quot;&quot;&quot;
    &gt;     115 if isinstance(params, (ParameterExpression, ParameterVector)):
    &gt; --&gt; 116     return self._parameter_shift(operator, params)
    &gt;     117 elif isinstance(params, tuple):
    &gt;     118     return self._parameter_shift(self._parameter_shift(operator, params[0]),
    &gt; params[1])
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\param_shift.py:202,
    &gt; in ParamShift._parameter_shift(self, operator, params)
    &gt;     197 circ = circs[0]
    &gt;     199 if self.analytic:
    &gt;     200     # Unroll the circuit into a gate set for which the gradient may be computed
    &gt;     201     # using pi/2 shifts.
    &gt; --&gt; 202     circ = ParamShift._transpile_to_supported_operations(circ, self.SUPPORTED_GATES)
    &gt;     203     operator = ParamShift._replace_operator_circuit(operator, circ)
    &gt;     205 if param not in circ._parameter_table:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\circuit_gradient.py:96,
    &gt; in CircuitGradient._transpile_to_supported_operations(circuit,
    &gt; supported_gates)
    &gt;      92         circuit = transpile(
    &gt;      93             circuit, basis_gates=list(supported_gates), optimization_level=0
    &gt;      94         )
    &gt;      95     except Exception as exc:
    &gt; ---&gt; 96         raise QiskitError(
    &gt;      97             f&quot;Could not transpile the circuit provided {circuit} into supported gates &quot;
    &gt;      98             f&quot;{supported_gates}.&quot;
    &gt;      99         ) from exc
    &gt;     100 return circuit
    &gt; 
    &gt; QiskitError: &quot;Could not transpile the circuit provided (....QC) into supported gates {'rz', 'ry', 'y', 'u', 'h', 'z', 'x', 'cx', 'cz', 'p', 'rx', 'cy'}.&quot;
</code></pre>
<p>When experimenting with the Lab-4 case of the qiskit2021 summer machine learning school, the quantum circuit in the notebook of Lab-4 was replaced (the circuit is not convenient to provide), the structure is much more complicated than the provided case, and the following problems occur when compiling</p>
<blockquote>
<p>Unable to map source basis {('h', 1),
('save_density_matrix', 3), ('swap', 2), ('ry', 1), ('ccx', 3),
('barrier', 18), ('cx', 2)} to target basis {'rz', 'ry', 'y',
'barrier', 'u', 'snapshot', 'h', 'z', 'measure', 'x', 'cx', 'delay',
'cz', 'reset', 'p', 'rx', 'cy'} over library</p>
</blockquote>
",Compilation error occurred in qiskit natural gradient case,<qiskit>,1,0,,,"Compilation error occurred in qiskit natural gradient case <p><a href=""https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits"" rel=""nofollow noreferrer"">https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits</a></p>
<pre><code>  &gt; TranspilerError                           Traceback (most recent call
    &gt; last) File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\circuit_gradient.py:92,
    &gt; in CircuitGradient._transpile_to_supported_operations(circuit,
    &gt; supported_gates)
    &gt;      91 try:
    &gt; ---&gt; 92     circuit = transpile(
    &gt;      93         circuit, basis_gates=list(supported_gates), optimization_level=0
    &gt;      94     )
    &gt;      95 except Exception as exc:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\compiler\transpiler.py:304, in
    &gt; transpile(circuits, backend, basis_gates, inst_map, coupling_map,
    &gt; backend_properties, initial_layout, layout_method, routing_method,
    &gt; translation_method, scheduling_method, instruction_durations, dt,
    &gt; approximation_degree, timing_constraints, seed_transpiler,
    &gt; optimization_level, callback, output_name, unitary_synthesis_method,
    &gt; unitary_synthesis_plugin_config, target)
    &gt;     303 # Transpile circuits in parallel
    &gt; --&gt; 304 circuits = parallel_map(_transpile_circuit, list(zip(circuits, transpile_args)))
    &gt;     306 end_time = time()
    &gt; 
    &gt; File d:\miniconda3\lib\site-packages\qiskit\tools\parallel.py:129, in
    &gt; parallel_map(task, values, task_args, task_kwargs, num_processes)
    &gt;     128 if len(values) == 1:
    &gt; --&gt; 129     return [task(values[0], *task_args, **task_kwargs)]
    &gt;     131 Publisher().publish(&quot;terra.parallel.start&quot;, len(values))
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\compiler\transpiler.py:389, in
    &gt; _transpile_circuit(circuit_config_tuple)
    &gt;     387     raise TranspilerError(&quot;optimization_level can range from 0 to 3.&quot;)
    &gt; --&gt; 389 result = pass_manager.run(
    &gt;     390     circuit, callback=transpile_config[&quot;callback&quot;], output_name=transpile_config[&quot;output_name&quot;]
    &gt;     391 )
    &gt;     393 if transpile_config[&quot;faulty_qubits_map&quot;]:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\passmanager.py:222,
    &gt; in PassManager.run(self, circuits, output_name, callback)
    &gt;     221 if isinstance(circuits, QuantumCircuit):
    &gt; --&gt; 222     return self._run_single_circuit(circuits, output_name, callback)
    &gt;     223 if len(circuits) == 1:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\passmanager.py:277,
    &gt; in PassManager._run_single_circuit(self, circuit, output_name,
    &gt; callback)
    &gt;     276 running_passmanager = self._create_running_passmanager()
    &gt; --&gt; 277 result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    &gt;     278 self.property_set = running_passmanager.property_set
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\runningpassmanager.py:124,
    &gt; in RunningPassManager.run(***failed resolving arguments***)
    &gt;     123     for pass_ in passset:
    &gt; --&gt; 124         dag = self._do_pass(pass_, dag, passset.options)
    &gt;     126 circuit = dag_to_circuit(dag)
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\runningpassmanager.py:157,
    &gt; in RunningPassManager._do_pass(self, pass_, dag, options)
    &gt;     156 if pass_ not in self.valid_passes:
    &gt; --&gt; 157     dag = self._run_this_pass(pass_, dag)
    &gt;     159     # update the valid_passes property
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\runningpassmanager.py:186,
    &gt; in RunningPassManager._run_this_pass(self, pass_, dag)
    &gt;     185 start_time = time()
    &gt; --&gt; 186 new_dag = pass_.run(dag)
    &gt;     187 end_time = time()
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\transpiler\passes\basis\basis_translator.py:206,
    &gt; in BasisTranslator.run(self, dag)
    &gt;     205 if basis_transforms is None:
    &gt; --&gt; 206     raise TranspilerError(
    &gt;     207         &quot;Unable to map source basis {} to target basis {} &quot;
    &gt;     208         &quot;over library {}.&quot;.format(source_basis, target_basis, self._equiv_lib)
    &gt;     209     )
    &gt;     211 # Compose found path into a set of instruction substitution rules.
    &gt; 
    &gt; TranspilerError: &quot;Unable to map source basis {('h', 1),
    &gt; ('save_density_matrix', 3), ('swap', 2), ('ry', 1), ('ccx', 3),
    &gt; ('barrier', 18), ('cx', 2)} to target basis {'rz', 'ry', 'y',
    &gt; 'barrier', 'u', 'snapshot', 'h', 'z', 'measure', 'x', 'cx', 'delay',
    &gt; 'cz', 'reset', 'p', 'rx', 'cy'} over library
    &gt; &lt;qiskit.circuit.equivalence.EquivalenceLibrary object at
    &gt; 0x000001D80DDAD310&gt;.&quot;
    &gt; 
    &gt; The above exception was the direct cause of the following exception:
    &gt; 
    &gt; QiskitError                               Traceback (most recent call
    &gt; last) Input In [13], in &lt;cell line: 41&gt;()
    &gt;      38 print(finite_difference)
    &gt;      40 shifter = Gradient()  # parameter-shift rule is the default
    &gt; ---&gt; 41 grad = shifter.convert(expectation, params=QC.parameters[index])
    &gt;      42 sampler.convert(grad, value_dict).eval().real
    &gt;      44 tmp = init_states(num_words, qbits_for_single_word) 
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\gradient.py:78,
    &gt; in Gradient.convert(self, operator, params)
    &gt;      76 expec_op = PauliExpectation(group_paulis=False).convert(operator).reduce()
    &gt;      77 cleaned_op = self._factor_coeffs_out_of_composed_op(expec_op)
    &gt; ---&gt; 78 return self.get_gradient(cleaned_op, param)
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\gradient.py:182,
    &gt; in Gradient.get_gradient(self, operator, params)
    &gt;     176     if not isinstance(operator[-1], CircuitStateFn):
    &gt;     177         raise TypeError(
    &gt;     178             &quot;The gradient framework is compatible with states that are given as &quot;
    &gt;     179             &quot;CircuitStateFn&quot;
    &gt;     180         )
    &gt; --&gt; 182     return self.grad_method.convert(operator, param)
    &gt;     184 elif isinstance(operator, CircuitStateFn):
    &gt;     185     # Gradient of an a state's sampling probabilities
    &gt;     186     if not is_coeff_c(operator._coeff, 1.0):
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\param_shift.py:116,
    &gt; in ParamShift.convert(self, operator, params)
    &gt;      96 &quot;&quot;&quot;
    &gt;      97 Args:
    &gt;      98     operator: The operator corresponding to our quantum state we are taking the    (...)
    &gt;     113 
    &gt;     114 &quot;&quot;&quot;
    &gt;     115 if isinstance(params, (ParameterExpression, ParameterVector)):
    &gt; --&gt; 116     return self._parameter_shift(operator, params)
    &gt;     117 elif isinstance(params, tuple):
    &gt;     118     return self._parameter_shift(self._parameter_shift(operator, params[0]),
    &gt; params[1])
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\param_shift.py:202,
    &gt; in ParamShift._parameter_shift(self, operator, params)
    &gt;     197 circ = circs[0]
    &gt;     199 if self.analytic:
    &gt;     200     # Unroll the circuit into a gate set for which the gradient may be computed
    &gt;     201     # using pi/2 shifts.
    &gt; --&gt; 202     circ = ParamShift._transpile_to_supported_operations(circ, self.SUPPORTED_GATES)
    &gt;     203     operator = ParamShift._replace_operator_circuit(operator, circ)
    &gt;     205 if param not in circ._parameter_table:
    &gt; 
    &gt; File
    &gt; d:\miniconda3\lib\site-packages\qiskit\opflow\gradients\circuit_gradients\circuit_gradient.py:96,
    &gt; in CircuitGradient._transpile_to_supported_operations(circuit,
    &gt; supported_gates)
    &gt;      92         circuit = transpile(
    &gt;      93             circuit, basis_gates=list(supported_gates), optimization_level=0
    &gt;      94         )
    &gt;      95     except Exception as exc:
    &gt; ---&gt; 96         raise QiskitError(
    &gt;      97             f&quot;Could not transpile the circuit provided {circuit} into supported gates &quot;
    &gt;      98             f&quot;{supported_gates}.&quot;
    &gt;      99         ) from exc
    &gt;     100 return circuit
    &gt; 
    &gt; QiskitError: &quot;Could not transpile the circuit provided (....QC) into supported gates {'rz', 'ry', 'y', 'u', 'h', 'z', 'x', 'cx', 'cz', 'p', 'rx', 'cy'}.&quot;
</code></pre>
<p>When experimenting with the Lab-4 case of the qiskit2021 summer machine learning school, the quantum circuit in the notebook of Lab-4 was replaced (the circuit is not convenient to provide), the structure is much more complicated than the provided case, and the following problems occur when compiling</p>
<blockquote>
<p>Unable to map source basis {('h', 1),
('save_density_matrix', 3), ('swap', 2), ('ry', 1), ('ccx', 3),
('barrier', 18), ('cx', 2)} to target basis {'rz', 'ry', 'y',
'barrier', 'u', 'snapshot', 'h', 'z', 'measure', 'x', 'cx', 'delay',
'cz', 'reset', 'p', 'rx', 'cy'} over library</p>
</blockquote>
",qc,compilation error occurred qiskit natural gradient case p https nofollow noreferrer https pre code gt transpilererror traceback recent call gt last file gt gt circuit gt gt 91 try gt gt 92 circuit transpile gt 93 circuit gt 94 gt 95 except exception exc gt gt file gt gt transpile circuits backend gt gt dt gt gt callback gt target gt 303 transpile circuits parallel gt gt 304 circuits list zip circuits gt 306 time gt gt file gt task values gt 128 len values 1 gt gt 129 return task values 0 gt 131 publisher quot quot len values gt gt file gt gt gt 387 raise transpilererror quot range 0 quot gt gt 389 result gt 390 circuit quot callback quot quot quot gt 391 gt 393 quot quot gt gt file gt gt self circuits callback gt 221 isinstance circuits quantumcircuit gt gt 222 return circuits callback gt 223 len circuits 1 gt gt file gt gt self circuit gt callback gt 276 gt gt 277 result circuit gt 278 gt gt file gt gt failed resolving arguments gt 123 passset gt gt 124 dag dag gt 126 circuit dag gt gt file gt gt self dag options gt 156 gt gt 157 dag dag gt 159 update property gt gt file gt gt self dag gt 185 time gt gt 186 dag gt 187 time gt gt file gt gt self dag gt 205 none gt gt 206 raise transpilererror gt 207 quot unable map source basis target basis quot gt 208 quot library quot gt 209 gt 211 compose found path set instruction substitution rules gt gt transpilererror quot unable map source basis h 1 gt 3 2 1 3 gt 18 2 target basis gt u h z x gt p library gt lt object gt 0x000001d80ddad310 gt quot gt gt exception direct cause following exception gt gt qiskiterror traceback recent call gt last input 13 lt cell line 41 gt gt 38 print gt 40 shifter gradient rule default gt gt 41 grad expectation index gt 42 grad gt 44 tmp gt gt file gt gt self operator params gt 76 pauliexpectation operator gt 77 gt gt 78 return param gt gt file gt gt self operator params gt 176 isinstance operator circuitstatefn gt 177 raise typeerror gt 178 quot gradient framework compatible states given quot gt 179 quot circuitstatefn quot gt 180 gt gt 182 return operator param gt 184 elif isinstance operator circuitstatefn gt 185 gradient state sampling probabilities gt 186 gt gt file gt gt self operator params gt 96 quot quot quot gt 97 args gt 98 operator operator corresponding quantum state taking gt 113 gt 114 quot quot quot gt 115 isinstance params parameterexpression parametervector gt gt 116 return operator params gt 117 elif isinstance params tuple gt 118 return operator params 0 gt params 1 gt gt file gt gt self operator params gt 197 circ circs 0 gt 199 gt 200 unroll circuit gate set gradient may computed gt 201 using shifts gt gt 202 circ circ gt 203 operator operator circ gt 205 param gt gt file gt gt circuit gt gt 92 circuit transpile gt 93 circuit gt 94 gt 95 except exception exc gt gt 96 raise qiskiterror gt 97 f quot could transpile circuit provided circuit supported gates quot gt 98 f quot quot gt 99 exc gt 100 return circuit gt gt qiskiterror quot could transpile circuit provided qc supported gates u h z x p quot p experimenting case qiskit2021 summer machine learning school quantum circuit notebook replaced circuit convenient provide structure much complicated provided case following problems occur compiling blockquote p unable map source basis h 1 3 2 1 3 18 2 target basis u h z x p library,"[(0, 0.74274313), (6, 0.012447564), (8, 0.012284909), (9, 0.023049729), (12, 0.04113193), (14, 0.03880298), (19, 0.11727754)]"
27147,27150.0,2022-06-30 01:28:56,0,617,"<p>My proj is from
<a href=""https://pennylane.ai/qml/demos/tutorial_rotoselect.html"" rel=""nofollow noreferrer"">https://pennylane.ai/qml/demos/tutorial_rotoselect.html</a></p>
<p>In verifying the application of this theory in more complex circuits, the following problems occurred.</p>
<p>How to fix this, I tried the suggestions in github still no solution ? How to fix this, I tried the suggestions in github still no solution,</p>
<p><a href=""https://github.com/PennyLaneAI/pennylane/issues/1459"" rel=""nofollow noreferrer"">https://github.com/PennyLaneAI/pennylane/issues/1459</a></p>
<p><a href=""https://i.sstatic.net/INnIe.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/INnIe.png"" alt=""enter image description here"" /></a></p>
<pre><code>&gt; WireError                                 Traceback (most recent call
&gt; last) File d:\miniconda3\lib\site-packages\pennylane\_device.py:369,
&gt; in Device.map_wires(self, wires)
&gt;     368 try:
&gt; --&gt; 369     mapped_wires = wires.map(self.wire_map)
&gt;     370 except WireError as e:
&gt; 
&gt; File d:\miniconda3\lib\site-packages\pennylane\wires.py:273, in
&gt; Wires.map(self, wire_map)
&gt;     272     if w not in wire_map:
&gt; --&gt; 273         raise WireError(f&quot;No mapping for wire label {w} specified in wire map {wire_map}.&quot;)
&gt;     275 new_wires = [wire_map[w] for w in self]
&gt; 
&gt; WireError: No mapping for wire label 0 specified in wire map
&gt; OrderedDict([(tensor(18, requires_grad=True), 0)]).
&gt; 
&gt; The above exception was the direct cause of the following exception:
&gt; 
&gt; WireError                                 Traceback (most recent call
&gt; last) Input In [11], in &lt;cell line: 137&gt;()
&gt;     136 costs_rotosolve = []
&gt;     137 for i in range(n_steps):
&gt; --&gt; 139     costs_rotosolve.append(cost(params_rsol, wires))
&gt;     140     params_rsol = rotosolve_cycle(cost, params_rsol)
&gt;     142 params_gd = init_params.copy()
&gt; 
&gt; Input In [11], in cost(params, wires)
&gt;      89 def cost(params, wires):
&gt; ---&gt; 90     Z = circuit(params, wires)
&gt;      91     return Z
&gt; 
&gt; File d:\miniconda3\lib\site-packages\pennylane\qnode.py:576, in
&gt; QNode.__call__(self, *args, **kwargs)
&gt;     569 using_custom_cache = (
&gt;     570     hasattr(cache, &quot;__getitem__&quot;)
&gt;     571     and hasattr(cache, &quot;__setitem__&quot;)
&gt;     572     and hasattr(cache, &quot;__delitem__&quot;)
&gt;     573 )
&gt;     574 self._tape_cached = using_custom_cache and self.tape.hash in cache
&gt; --&gt; 576 res = qml.execute(
&gt;     577     [self.tape],
&gt;     578     device=self.device,
&gt;     579     gradient_fn=self.gradient_fn,
&gt;     580     interface=self.interface,
&gt;     581     gradient_kwargs=self.gradient_kwargs,
&gt;     582     override_shots=override_shots,
&gt;     583     **self.execute_kwargs,
&gt;     584 )
&gt;     586 if autograd.isinstance(res, (tuple, list)) and len(res) == 1:
&gt;     587     # If a device batch transform was applied, we need to 'unpack'
&gt;     588     # the returned tuple/list to a float.    (...)
&gt;     595     # TODO: find a more explicit way of determining that a batch transform
&gt;     596     # was applied.
&gt;     598     res = res[0]
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\execution.py:409,
&gt; in execute(tapes, device, gradient_fn, interface, mode,
&gt; gradient_kwargs, cache, cachesize, max_diff, override_shots,
&gt; expand_fn, max_expansion, device_batch_transform)
&gt;     402     interface_name = [k for k, v in INTERFACE_NAMES.items() if interface in v][0]
&gt;     404     raise qml.QuantumFunctionError(
&gt;     405         f&quot;{interface_name} not found. Please install the latest &quot;
&gt;     406         f&quot;version of {interface_name} to enable the '{interface}' interface.&quot;
&gt;     407     ) from e
&gt; --&gt; 409 res = _execute(
&gt;     410     tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n=1, max_diff=max_diff, mode=_mode
&gt;     411 )
&gt;     413 return batch_fn(res)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\autograd.py:64,
&gt; in execute(tapes, device, execute_fn, gradient_fn, gradient_kwargs,
&gt; _n, max_diff, mode)
&gt;      58     tape.trainable_params = qml.math.get_trainable_indices(params)
&gt;      60 parameters = autograd.builtins.tuple(
&gt;      61     [autograd.builtins.list(t.get_parameters()) for t in tapes]
&gt;      62 )
&gt; ---&gt; 64 return _execute(
&gt;      65     parameters,
&gt;      66     tapes=tapes,
&gt;      67     device=device,
&gt;      68     execute_fn=execute_fn,
&gt;      69     gradient_fn=gradient_fn,
&gt;      70     gradient_kwargs=gradient_kwargs,
&gt;      71     _n=_n,
&gt;      72     max_diff=max_diff,
&gt;      73 )[0]
&gt; 
&gt; File d:\miniconda3\lib\site-packages\autograd\tracer.py:48, in
&gt; primitive.&lt;locals&gt;.f_wrapped(*args, **kwargs)
&gt;      46     return new_box(ans, trace, node)
&gt;      47 else:
&gt; ---&gt; 48     return f_raw(*args, **kwargs)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\autograd.py:108,
&gt; in _execute(parameters, tapes, device, execute_fn, gradient_fn,
&gt; gradient_kwargs, _n, max_diff)
&gt;      87 &quot;&quot;&quot;Autodifferentiable wrapper around ``Device.batch_execute``.
&gt;      88 
&gt;      89 The signature of this function is designed to work around Autograd restrictions.    (...)
&gt;     105 understand the consequences!
&gt;     106 &quot;&quot;&quot;
&gt;     107 with qml.tape.Unwrap(*tapes):
&gt; --&gt; 108     res, jacs = execute_fn(tapes, **gradient_kwargs)
&gt;     110 for i, r in enumerate(res):
&gt;     112     if isinstance(res[i], np.ndarray):
&gt;     113         # For backwards compatibility, we flatten ragged tape outputs
&gt;     114         # when there is no sampling
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\execution.py:165,
&gt; in cache_execute.&lt;locals&gt;.wrapper(tapes, **kwargs)
&gt;     161         return (res, []) if return_tuple else res
&gt;     163 else:
&gt;     164     # execute all unique tapes that do not exist in the cache
&gt; --&gt; 165     res = fn(execution_tapes.values(), **kwargs)
&gt;     167 final_res = []
&gt;     169 for i, tape in enumerate(tapes):
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\execution.py:90,
&gt; in cache_execute.&lt;locals&gt;.fn(tapes, **kwargs)
&gt;      88 def fn(tapes, **kwargs):  # pylint: disable=function-redefined
&gt;      89     tapes = [expand_fn(tape) for tape in tapes]
&gt; ---&gt; 90     return original_fn(tapes, **kwargs)
&gt; 
&gt; File d:\miniconda3\lib\contextlib.py:79, in
&gt; ContextDecorator.__call__.&lt;locals&gt;.inner(*args, **kwds)
&gt;      76 @wraps(func)
&gt;      77 def inner(*args, **kwds):
&gt;      78     with self._recreate_cm():
&gt; ---&gt; 79         return func(*args, **kwds)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:428,
&gt; in QiskitDevice.batch_execute(self, circuits)
&gt;     425 def batch_execute(self, circuits):
&gt;     426     # pylint: disable=missing-function-docstring
&gt; --&gt; 428     compiled_circuits = self.compile_circuits(circuits)
&gt;     430     # Send the batch of circuit objects using backend.run
&gt;     431     self._current_job = self.backend.run(compiled_circuits, shots=self.shots, **self.run_args)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:417,
&gt; in QiskitDevice.compile_circuits(self, circuits)
&gt;     413 for circuit in circuits:
&gt;     414     # We need to reset the device here, else it will
&gt;     415     # not start the next computation in the zero state
&gt;     416     self.reset()
&gt; --&gt; 417     self.create_circuit_object(circuit.operations, rotations=circuit.diagonalizing_gates)
&gt;     419     compiled_circ = self.compile()
&gt;     420     compiled_circ.name = f&quot;circ{len(compiled_circuits)}&quot;
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:230,
&gt; in QiskitDevice.create_circuit_object(self, operations, **kwargs)
&gt;     218 &quot;&quot;&quot;Builds the circuit objects based on the operations and measurements
&gt;     219 specified to apply.
&gt;     220     (...)
&gt;     226         pre-measurement into the eigenbasis of the observables.
&gt;     227 &quot;&quot;&quot;
&gt;     228 rotations = kwargs.get(&quot;rotations&quot;, [])
&gt; --&gt; 230 applied_operations = self.apply_operations(operations)
&gt;     232 # Rotating the state for measurement in the computational basis
&gt;     233 rotation_circuits = self.apply_operations(rotations)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:269,
&gt; in QiskitDevice.apply_operations(self, operations)
&gt;     265 circuits = []
&gt;     267 for operation in operations:
&gt;     268     # Apply the circuit operations
&gt; --&gt; 269     device_wires = self.map_wires(operation.wires)
&gt;     270     par = operation.parameters
&gt;     272     for idx, p in enumerate(par):
&gt; 
&gt; File d:\miniconda3\lib\site-packages\pennylane\_device.py:371, in
&gt; Device.map_wires(self, wires)
&gt;     369     mapped_wires = wires.map(self.wire_map)
&gt;     370 except WireError as e:
&gt; --&gt; 371     raise WireError(
&gt;     372         f&quot;Did not find some of the wires {wires} on device with wires {self.wires}.&quot;
&gt;     373     ) from e
&gt;     375 return mapped_wires
&gt; 
&gt; WireError: Did not find some of the wires &lt;Wires = [0]&gt; on device with
&gt; wires &lt;Wires = [tensor(18, requires_grad=True)]&gt;.
</code></pre>
","Pennylane:WireError: Did not find some of the wires <Wires = [0]> on device with wires <Wires = [tensor(18, requires_grad=True)]>",<qiskit>,1,8,,,"Pennylane:WireError: Did not find some of the wires <Wires = [0]> on device with wires <Wires = [tensor(18, requires_grad=True)]> <p>My proj is from
<a href=""https://pennylane.ai/qml/demos/tutorial_rotoselect.html"" rel=""nofollow noreferrer"">https://pennylane.ai/qml/demos/tutorial_rotoselect.html</a></p>
<p>In verifying the application of this theory in more complex circuits, the following problems occurred.</p>
<p>How to fix this, I tried the suggestions in github still no solution ? How to fix this, I tried the suggestions in github still no solution,</p>
<p><a href=""https://github.com/PennyLaneAI/pennylane/issues/1459"" rel=""nofollow noreferrer"">https://github.com/PennyLaneAI/pennylane/issues/1459</a></p>
<p><a href=""https://i.sstatic.net/INnIe.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/INnIe.png"" alt=""enter image description here"" /></a></p>
<pre><code>&gt; WireError                                 Traceback (most recent call
&gt; last) File d:\miniconda3\lib\site-packages\pennylane\_device.py:369,
&gt; in Device.map_wires(self, wires)
&gt;     368 try:
&gt; --&gt; 369     mapped_wires = wires.map(self.wire_map)
&gt;     370 except WireError as e:
&gt; 
&gt; File d:\miniconda3\lib\site-packages\pennylane\wires.py:273, in
&gt; Wires.map(self, wire_map)
&gt;     272     if w not in wire_map:
&gt; --&gt; 273         raise WireError(f&quot;No mapping for wire label {w} specified in wire map {wire_map}.&quot;)
&gt;     275 new_wires = [wire_map[w] for w in self]
&gt; 
&gt; WireError: No mapping for wire label 0 specified in wire map
&gt; OrderedDict([(tensor(18, requires_grad=True), 0)]).
&gt; 
&gt; The above exception was the direct cause of the following exception:
&gt; 
&gt; WireError                                 Traceback (most recent call
&gt; last) Input In [11], in &lt;cell line: 137&gt;()
&gt;     136 costs_rotosolve = []
&gt;     137 for i in range(n_steps):
&gt; --&gt; 139     costs_rotosolve.append(cost(params_rsol, wires))
&gt;     140     params_rsol = rotosolve_cycle(cost, params_rsol)
&gt;     142 params_gd = init_params.copy()
&gt; 
&gt; Input In [11], in cost(params, wires)
&gt;      89 def cost(params, wires):
&gt; ---&gt; 90     Z = circuit(params, wires)
&gt;      91     return Z
&gt; 
&gt; File d:\miniconda3\lib\site-packages\pennylane\qnode.py:576, in
&gt; QNode.__call__(self, *args, **kwargs)
&gt;     569 using_custom_cache = (
&gt;     570     hasattr(cache, &quot;__getitem__&quot;)
&gt;     571     and hasattr(cache, &quot;__setitem__&quot;)
&gt;     572     and hasattr(cache, &quot;__delitem__&quot;)
&gt;     573 )
&gt;     574 self._tape_cached = using_custom_cache and self.tape.hash in cache
&gt; --&gt; 576 res = qml.execute(
&gt;     577     [self.tape],
&gt;     578     device=self.device,
&gt;     579     gradient_fn=self.gradient_fn,
&gt;     580     interface=self.interface,
&gt;     581     gradient_kwargs=self.gradient_kwargs,
&gt;     582     override_shots=override_shots,
&gt;     583     **self.execute_kwargs,
&gt;     584 )
&gt;     586 if autograd.isinstance(res, (tuple, list)) and len(res) == 1:
&gt;     587     # If a device batch transform was applied, we need to 'unpack'
&gt;     588     # the returned tuple/list to a float.    (...)
&gt;     595     # TODO: find a more explicit way of determining that a batch transform
&gt;     596     # was applied.
&gt;     598     res = res[0]
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\execution.py:409,
&gt; in execute(tapes, device, gradient_fn, interface, mode,
&gt; gradient_kwargs, cache, cachesize, max_diff, override_shots,
&gt; expand_fn, max_expansion, device_batch_transform)
&gt;     402     interface_name = [k for k, v in INTERFACE_NAMES.items() if interface in v][0]
&gt;     404     raise qml.QuantumFunctionError(
&gt;     405         f&quot;{interface_name} not found. Please install the latest &quot;
&gt;     406         f&quot;version of {interface_name} to enable the '{interface}' interface.&quot;
&gt;     407     ) from e
&gt; --&gt; 409 res = _execute(
&gt;     410     tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n=1, max_diff=max_diff, mode=_mode
&gt;     411 )
&gt;     413 return batch_fn(res)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\autograd.py:64,
&gt; in execute(tapes, device, execute_fn, gradient_fn, gradient_kwargs,
&gt; _n, max_diff, mode)
&gt;      58     tape.trainable_params = qml.math.get_trainable_indices(params)
&gt;      60 parameters = autograd.builtins.tuple(
&gt;      61     [autograd.builtins.list(t.get_parameters()) for t in tapes]
&gt;      62 )
&gt; ---&gt; 64 return _execute(
&gt;      65     parameters,
&gt;      66     tapes=tapes,
&gt;      67     device=device,
&gt;      68     execute_fn=execute_fn,
&gt;      69     gradient_fn=gradient_fn,
&gt;      70     gradient_kwargs=gradient_kwargs,
&gt;      71     _n=_n,
&gt;      72     max_diff=max_diff,
&gt;      73 )[0]
&gt; 
&gt; File d:\miniconda3\lib\site-packages\autograd\tracer.py:48, in
&gt; primitive.&lt;locals&gt;.f_wrapped(*args, **kwargs)
&gt;      46     return new_box(ans, trace, node)
&gt;      47 else:
&gt; ---&gt; 48     return f_raw(*args, **kwargs)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\autograd.py:108,
&gt; in _execute(parameters, tapes, device, execute_fn, gradient_fn,
&gt; gradient_kwargs, _n, max_diff)
&gt;      87 &quot;&quot;&quot;Autodifferentiable wrapper around ``Device.batch_execute``.
&gt;      88 
&gt;      89 The signature of this function is designed to work around Autograd restrictions.    (...)
&gt;     105 understand the consequences!
&gt;     106 &quot;&quot;&quot;
&gt;     107 with qml.tape.Unwrap(*tapes):
&gt; --&gt; 108     res, jacs = execute_fn(tapes, **gradient_kwargs)
&gt;     110 for i, r in enumerate(res):
&gt;     112     if isinstance(res[i], np.ndarray):
&gt;     113         # For backwards compatibility, we flatten ragged tape outputs
&gt;     114         # when there is no sampling
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\execution.py:165,
&gt; in cache_execute.&lt;locals&gt;.wrapper(tapes, **kwargs)
&gt;     161         return (res, []) if return_tuple else res
&gt;     163 else:
&gt;     164     # execute all unique tapes that do not exist in the cache
&gt; --&gt; 165     res = fn(execution_tapes.values(), **kwargs)
&gt;     167 final_res = []
&gt;     169 for i, tape in enumerate(tapes):
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane\interfaces\execution.py:90,
&gt; in cache_execute.&lt;locals&gt;.fn(tapes, **kwargs)
&gt;      88 def fn(tapes, **kwargs):  # pylint: disable=function-redefined
&gt;      89     tapes = [expand_fn(tape) for tape in tapes]
&gt; ---&gt; 90     return original_fn(tapes, **kwargs)
&gt; 
&gt; File d:\miniconda3\lib\contextlib.py:79, in
&gt; ContextDecorator.__call__.&lt;locals&gt;.inner(*args, **kwds)
&gt;      76 @wraps(func)
&gt;      77 def inner(*args, **kwds):
&gt;      78     with self._recreate_cm():
&gt; ---&gt; 79         return func(*args, **kwds)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:428,
&gt; in QiskitDevice.batch_execute(self, circuits)
&gt;     425 def batch_execute(self, circuits):
&gt;     426     # pylint: disable=missing-function-docstring
&gt; --&gt; 428     compiled_circuits = self.compile_circuits(circuits)
&gt;     430     # Send the batch of circuit objects using backend.run
&gt;     431     self._current_job = self.backend.run(compiled_circuits, shots=self.shots, **self.run_args)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:417,
&gt; in QiskitDevice.compile_circuits(self, circuits)
&gt;     413 for circuit in circuits:
&gt;     414     # We need to reset the device here, else it will
&gt;     415     # not start the next computation in the zero state
&gt;     416     self.reset()
&gt; --&gt; 417     self.create_circuit_object(circuit.operations, rotations=circuit.diagonalizing_gates)
&gt;     419     compiled_circ = self.compile()
&gt;     420     compiled_circ.name = f&quot;circ{len(compiled_circuits)}&quot;
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:230,
&gt; in QiskitDevice.create_circuit_object(self, operations, **kwargs)
&gt;     218 &quot;&quot;&quot;Builds the circuit objects based on the operations and measurements
&gt;     219 specified to apply.
&gt;     220     (...)
&gt;     226         pre-measurement into the eigenbasis of the observables.
&gt;     227 &quot;&quot;&quot;
&gt;     228 rotations = kwargs.get(&quot;rotations&quot;, [])
&gt; --&gt; 230 applied_operations = self.apply_operations(operations)
&gt;     232 # Rotating the state for measurement in the computational basis
&gt;     233 rotation_circuits = self.apply_operations(rotations)
&gt; 
&gt; File
&gt; d:\miniconda3\lib\site-packages\pennylane_qiskit\qiskit_device.py:269,
&gt; in QiskitDevice.apply_operations(self, operations)
&gt;     265 circuits = []
&gt;     267 for operation in operations:
&gt;     268     # Apply the circuit operations
&gt; --&gt; 269     device_wires = self.map_wires(operation.wires)
&gt;     270     par = operation.parameters
&gt;     272     for idx, p in enumerate(par):
&gt; 
&gt; File d:\miniconda3\lib\site-packages\pennylane\_device.py:371, in
&gt; Device.map_wires(self, wires)
&gt;     369     mapped_wires = wires.map(self.wire_map)
&gt;     370 except WireError as e:
&gt; --&gt; 371     raise WireError(
&gt;     372         f&quot;Did not find some of the wires {wires} on device with wires {self.wires}.&quot;
&gt;     373     ) from e
&gt;     375 return mapped_wires
&gt; 
&gt; WireError: Did not find some of the wires &lt;Wires = [0]&gt; on device with
&gt; wires &lt;Wires = [tensor(18, requires_grad=True)]&gt;.
</code></pre>
",qc,pennylane wireerror find wires wires 0 device wires wires tensor 18 p proj https nofollow noreferrer https p verifying application theory complex circuits following problems p fix tried suggestions github still solution fix tried suggestions github still solution p https nofollow noreferrer https p https nofollow noreferrer img https enter image description pre code gt wireerror traceback recent call gt last file gt self wires gt 368 try gt gt 369 gt 370 except wireerror e gt gt file gt self gt 272 w gt gt 273 raise wireerror f quot mapping wire label w specified wire map quot gt 275 w w self gt gt wireerror mapping wire label 0 specified wire map gt ordereddict tensor 18 0 gt gt exception direct cause following exception gt gt wireerror traceback recent call gt last input 11 lt cell line 137 gt gt 136 gt 137 range gt gt 139 cost wires gt 140 cost gt 142 gt gt input 11 cost params wires gt 89 def cost params wires gt gt 90 z circuit params wires gt 91 return z gt gt file gt self args kwargs gt 569 gt 570 hasattr cache quot quot gt 571 hasattr cache quot quot gt 572 hasattr cache quot quot gt 573 gt 574 cache gt gt 576 res gt 577 gt 578 gt 579 gt 580 gt 581 gt 582 gt 583 gt 584 gt 586 res tuple list len res 1 gt 587 device batch transform applied need gt 588 returned float gt 595 todo find explicit way determining batch transform gt 596 applied gt 598 res res 0 gt gt file gt gt execute tapes device interface mode gt cache cachesize gt gt 402 k k v interface v 0 gt 404 raise gt 405 f quot found please install latest quot gt 406 f quot version enable interface quot gt 407 e gt gt 409 res gt 410 tapes device gt 411 gt 413 return res gt gt file gt gt execute tapes device gt mode gt 58 params gt 60 parameters gt 61 tapes gt 62 gt gt 64 return gt 65 parameters gt 66 gt 67 gt 68 gt 69 gt 70 gt 71 gt 72 gt 73 0 gt gt file gt lt locals gt args kwargs gt 46 return ans trace node gt 47 else gt gt 48 return args kwargs gt gt file gt gt parameters tapes device gt gt 87 quot quot quot autodifferentiable wrapper around gt 88 gt 89 signature function designed work around autograd restrictions gt 105 understand consequences gt 106 quot quot quot gt 107 tapes gt gt 108 res jacs tapes gt 110 r enumerate res gt 112 isinstance res gt 113 backwards compatibility flatten ragged tape outputs gt 114 sampling gt gt file gt gt lt locals gt tapes kwargs gt 161 return res else res gt 163 else gt 164 execute unique tapes exist cache gt gt 165 res fn kwargs gt 167 gt 169 tape enumerate tapes gt gt file gt gt lt locals gt tapes kwargs gt 88 def fn tapes kwargs pylint gt 89 tapes tape tape tapes gt gt 90 return tapes kwargs gt gt file gt lt locals gt args kwds gt 76 wraps func gt 77 def inner args kwds gt 78 gt gt 79 return func args kwds gt gt file gt gt self circuits gt 425 def self circuits gt 426 pylint gt gt 428 circuits gt 430 send batch circuit objects using gt 431 gt gt file gt gt self circuits gt 413 circuit circuits gt 414 need reset device else gt 415 start next computation zero state gt 416 gt gt 417 gt 419 gt 420 f quot circ len quot gt gt file gt gt self operations kwargs gt 218 quot quot quot builds circuit objects based operations measurements gt 219 specified apply gt 220 gt 226 eigenbasis observables gt 227 quot quot quot gt 228 rotations quot rotations quot gt gt 230 operations gt 232 rotating state measurement computational basis gt 233 rotations gt gt file gt gt self operations gt 265 circuits gt 267 operation operations gt 268 apply circuit operations gt gt 269 gt 270 par gt 272 idx p enumerate par gt gt file gt self wires gt 369 gt 370 except wireerror e gt gt 371 raise wireerror gt 372 f quot find wires wires device wires quot gt 373 e gt 375 return gt gt wireerror find wires lt wires 0 gt device gt wires lt wires tensor 18 gt,"[(0, 0.78341043), (4, 0.023724694), (5, 0.011147363), (6, 0.026227215), (8, 0.018448193), (9, 0.014819398), (12, 0.019017048), (19, 0.084733546)]"
27148,,2022-06-30 02:29:18,4,210,"<p>I am new to quantum computation, I have seen examples of super-dense coding; however, I am struggling in my attempts to scale the 2-qubit system to a 4-qubit, here is a visual of the 2-qubit super-dense coding protocol I have implemented. My question is could anyone please provide an explanation on scaling in general. <a href=""https://i.sstatic.net/6zgvP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6zgvP.png"" alt=""2-qubit super-dense coding protocol"" /></a></p>
",Help Implementing a 4-qubit super dense coding algorithm,<quantum-circuit>,0,2,,,"Help Implementing a 4-qubit super dense coding algorithm <p>I am new to quantum computation, I have seen examples of super-dense coding; however, I am struggling in my attempts to scale the 2-qubit system to a 4-qubit, here is a visual of the 2-qubit super-dense coding protocol I have implemented. My question is could anyone please provide an explanation on scaling in general. <a href=""https://i.sstatic.net/6zgvP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6zgvP.png"" alt=""2-qubit super-dense coding protocol"" /></a></p>
",qc,help implementing super dense coding algorithm p new quantum computation seen examples coding however struggling attempts scale system visual coding protocol implemented question could anyone please provide explanation scaling general https nofollow noreferrer img https coding protocol,"[(4, 0.17717053), (8, 0.7907895), (12, 0.027468832)]"
27192,,2022-07-04 14:45:50,1,4458,"<p>when I try to use a quantum instance I get the error below.
I'm using qiskit 0.37.0 and qiskit-aqua 0.9.5.
Any hint suggested?
Thanks in advance</p>
<pre><code>ImportError                               Traceback (most recent call last)
/var/folders/gl/v7sz8_9j0nqcpxrr79rjtq7w0000gn/T/ipykernel_64860/3839405800.py in &lt;module&gt;
      7 print(provider.backends())
      8 
----&gt; 9 from qiskit.aqua import QuantumInstance
     10 
     11 backend = provider.get_backend('ibmq_manila')

/Applications/miniconda3/envs/eelbrain/lib/python3.9/site-packages/qiskit/aqua/__init__.py in &lt;module&gt;
     74 from .missing_optional_library_error import MissingOptionalLibraryError
     75 from .aqua_globals import aqua_globals
---&gt; 76 from .quantum_instance import QuantumInstance
     77 from .algorithms import QuantumAlgorithm
     78 from ._logging import (QiskitLogDomains,

/Applications/miniconda3/envs/eelbrain/lib/python3.9/site-packages/qiskit/aqua/quantum_instance.py in &lt;module&gt;
     19 import numpy as np
     20 
---&gt; 21 from qiskit.providers import Backend, BaseBackend
     22 from qiskit.transpiler import CouplingMap, PassManager
     23 from qiskit.transpiler.layout import Layout

ImportError: cannot import name 'BaseBackend' from 'qiskit.providers' (/Applications/miniconda3/envs/eelbrain/lib/python3.9/site-packages/qiskit/providers/__init__.py)<span class=""math-container"">```</span>
</code></pre>
",Error: cannot import name 'BaseBackend' from 'qiskit.providers',<qiskit>,1,3,,,"Error: cannot import name 'BaseBackend' from 'qiskit.providers' <p>when I try to use a quantum instance I get the error below.
I'm using qiskit 0.37.0 and qiskit-aqua 0.9.5.
Any hint suggested?
Thanks in advance</p>
<pre><code>ImportError                               Traceback (most recent call last)
/var/folders/gl/v7sz8_9j0nqcpxrr79rjtq7w0000gn/T/ipykernel_64860/3839405800.py in &lt;module&gt;
      7 print(provider.backends())
      8 
----&gt; 9 from qiskit.aqua import QuantumInstance
     10 
     11 backend = provider.get_backend('ibmq_manila')

/Applications/miniconda3/envs/eelbrain/lib/python3.9/site-packages/qiskit/aqua/__init__.py in &lt;module&gt;
     74 from .missing_optional_library_error import MissingOptionalLibraryError
     75 from .aqua_globals import aqua_globals
---&gt; 76 from .quantum_instance import QuantumInstance
     77 from .algorithms import QuantumAlgorithm
     78 from ._logging import (QiskitLogDomains,

/Applications/miniconda3/envs/eelbrain/lib/python3.9/site-packages/qiskit/aqua/quantum_instance.py in &lt;module&gt;
     19 import numpy as np
     20 
---&gt; 21 from qiskit.providers import Backend, BaseBackend
     22 from qiskit.transpiler import CouplingMap, PassManager
     23 from qiskit.transpiler.layout import Layout

ImportError: cannot import name 'BaseBackend' from 'qiskit.providers' (/Applications/miniconda3/envs/eelbrain/lib/python3.9/site-packages/qiskit/providers/__init__.py)<span class=""math-container"">```</span>
</code></pre>
",qc,error import name p try use quantum instance get error using qiskit hint suggested thanks advance pre code importerror traceback recent call last lt module gt 7 print 8 gt 9 import quantuminstance 10 11 backend lt module gt 74 import missingoptionallibraryerror 75 import gt 76 import quantuminstance 77 import quantumalgorithm 78 import qiskitlogdomains lt module gt 19 import numpy np 20 gt 21 import backend basebackend 22 import couplingmap passmanager 23 import layout importerror import name span,"[(0, 0.8116865), (3, 0.036521), (6, 0.12237304), (12, 0.027261335)]"
27195,,2022-07-04 16:33:55,2,145,"<p>As the question says, I'm looking to run some pulse schedules on quantum computers. Right now, I'm really only able to find ibmq_armonk (from IBM) to be an openpulse computer that I am able to use. I've found some papers that mentioned running pulse schedules on ibmq_toronto and ibmq_montreal, but IBMQ doesn't seem to identify them to support OpenPulse when applying the filters (though, this may just be because I'm on an unpaid account). Does anyone have any recommendations? I'm looking for both paid and unpaid services.</p>
",Where are the multi-qubit openpulse computers?,<ibm-q-experience><openpulse>,2,0,,,"Where are the multi-qubit openpulse computers? <p>As the question says, I'm looking to run some pulse schedules on quantum computers. Right now, I'm really only able to find ibmq_armonk (from IBM) to be an openpulse computer that I am able to use. I've found some papers that mentioned running pulse schedules on ibmq_toronto and ibmq_montreal, but IBMQ doesn't seem to identify them to support OpenPulse when applying the filters (though, this may just be because I'm on an unpaid account). Does anyone have any recommendations? I'm looking for both paid and unpaid services.</p>
",qc,openpulse computers p question says looking run pulse schedules quantum computers right really able find ibm openpulse computer able use found papers mentioned running pulse schedules ibmq seem identify support openpulse applying filters though may unpaid account anyone recommendations looking paid unpaid,"[(0, 0.15555817), (8, 0.7338804), (12, 0.025512043), (13, 0.08096538)]"
27250,,2022-07-08 04:40:23,4,295,"<p>I am interested in using QASM 3.0 after reading it's documentation and seeing it's examples <a href=""https://github.com/openqasm/openqasm"" rel=""nofollow noreferrer"">1</a>. However, I see that in IBM Quantum Experience QASM 3.0 is not supported yet. Is there any way I can run QASM 3.0 code locally or by a customized Qiskit install? Also is QASM 3.0 still in active development and is there a timeline? Long story short I feel like there is documentation I am just missing/not finding.</p>
",Does Qiskit allow for QASM 3.0 code to be utilized?,<qiskit><qasm>,1,0,,,"Does Qiskit allow for QASM 3.0 code to be utilized? <p>I am interested in using QASM 3.0 after reading it's documentation and seeing it's examples <a href=""https://github.com/openqasm/openqasm"" rel=""nofollow noreferrer"">1</a>. However, I see that in IBM Quantum Experience QASM 3.0 is not supported yet. Is there any way I can run QASM 3.0 code locally or by a customized Qiskit install? Also is QASM 3.0 still in active development and is there a timeline? Long story short I feel like there is documentation I am just missing/not finding.</p>
",qc,qiskit allow qasm code utilized p interested using qasm reading documentation seeing examples https nofollow noreferrer 1 however see ibm quantum experience qasm supported yet way run qasm code locally customized qiskit install also qasm still active development timeline long story short feel like documentation,"[(0, 0.050645184), (4, 0.110815756), (8, 0.2428709), (12, 0.022292769), (13, 0.03755228), (14, 0.5327223)]"
27305,27323.0,2022-07-12 07:54:01,0,271,"<p>I am trying to design a custom VQE algorithm using qiskit. The main customization of the algorithm is in the minimization of expectation value of the Hamiltonian. To accomplish this, I have used the following code. I have chosen the LiH molecule in sto3g basis.</p>
<p>First, I perform SCF calculation using pyscf just to get the number of orbitals, orbital occupation etc.</p>
<p>Code:</p>
<pre><code>from pyscf import gto, scf, fci
import numpy as np

mol = gto.Mole()
mol.build(atom='Li 0 0 0; H 0 0 1', basis='sto3g', symmetry=1)

mf = scf.RHF(mol)
mf.kernel()
print ('Occupation in MOs: ', mf.mo_occ)
</code></pre>
<p>Output:</p>
<pre><code>converged SCF energy = -7.76736213574856
Occupation in MOs:  [2. 2. 0. 0. 0. 0.]
</code></pre>
<p>Next, I generate the HF reference state and the UCCSD operator.</p>
<pre><code>from qiskit_nature.circuit.library.initial_states.hartree_fock import *
from qiskit_nature.circuit.library.ansatzes import UCC

#Writing the HF state in qubit occupation form 
#The following code gives a circuit to prepare the HF state from the state with all qubits =0
HF = HartreeFock(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True))
#print (HF)

UCC_operator = UCC(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, excitations='sd', qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True), initial_state = HF)
</code></pre>
<p>Then I write down the molecule whose energy needs to be calculated and obtain its Hamiltonian.</p>
<pre><code>from qiskit_nature.drivers import UnitsType, Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem

molecule = Molecule(
    # coordinates are given in Angstrom
    geometry=[
        [&quot;Li&quot;, [0.0, 0.0, 0.0]],
        [&quot;H&quot;, [0.0, 0.0, 1.0]]
    ],
    multiplicity=1,  # = 2*spin + 1
    charge=0,)

driver = ElectronicStructureMoleculeDriver(molecule, basis=&quot;sto3g&quot;, 
                    driver_type=ElectronicStructureDriverType.PYSCF)

problem = ElectronicStructureProblem(driver)
second_q_op = problem.second_q_ops()
qubit_converter = QubitConverter(mapper = JordanWignerMapper(), two_qubit_reduction = True)
Hamiltonian = qubit_converter.convert(second_q_op[0], num_particles=problem.num_particles)
</code></pre>
<p>Now since I am customizing in the minimization part of the VQE algorithm, I will just prepare the VQE instance and then use the <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.VQE.get_energy_evaluation.html#qiskit.algorithms.VQE.get_energy_evaluation"" rel=""nofollow noreferrer""><code>get_energy_evaluation</code></a> method that qiskit provides to use UCCSD-VQE circuit as a parametrized circuit to be evaluated at the desired parameter values.</p>
<pre><code>from qiskit import Aer
from qiskit.algorithms.optimizers import SLSQP
from qiskit.algorithms import VQE

backend = Aer.get_backend('aer_simulator_statevector')
optimizer = SLSQP(maxiter=100)

algorithm = VQE(UCC_operator, optimizer=optimizer, quantum_instance=backend)

energy_eval_func = algorithm.get_energy_evaluation(Hamiltonian, False)
</code></pre>
<p>Now that I have obtained the function to evaluate expectation value of the Hamiltonian of the molecule wrt to a desired UCC state (i.e. T1 and T2 amplitudes), I choose 2 kinds of parameters for the UCC operator and observe the results.</p>
<ol>
<li>All the parameters are equal to 0. This is equivalent to the <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.HFInitialPoint.html#qiskit_nature.algorithms.initial_points.HFInitialPoint"" rel=""nofollow noreferrer""><code>HFInitialpoint</code></a>. I use this as follows.</li>
</ol>
<pre><code>t = UCC_operator.parameters
num_params = len(t)
energy_eval_func(np.zeros(len(t))
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.354893768508214
</code></pre>
<ol start=""2"">
<li>I choose the parameter elements to be MP2 amplitudes. This can be achieved by using <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.MP2InitialPoint.html#qiskit_nature.algorithms.initial_points.MP2InitialPoint"" rel=""nofollow noreferrer""><code>MP2InitialPoint</code></a> as follows.</li>
</ol>
<pre><code>from qiskit_nature.algorithms.initial_points import *

mp2_initial_point = MP2InitialPoint()
mp2_initial_point.compute(UCC_operator, driver_results)
initial_point = mp2_initial_point.to_numpy_array()

energy_eval_func(initial_point)
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.324343952128133
</code></pre>
<p>This is what I do not understand.
<strong>Given that the theoretical energy is -9.371991912791, why is the energy lower for HF initial point than the MP2 initial point?</strong> I was of the opinion that it should have been the other way around. I do not see where have I gone wrong. It would be really helpful if you could clarify this doubt. Thank you.</p>
",Why is HF Initial point seems to be better than MP2 initial point in qiskit?,<qiskit><vqe>,1,0,,,"Why is HF Initial point seems to be better than MP2 initial point in qiskit? <p>I am trying to design a custom VQE algorithm using qiskit. The main customization of the algorithm is in the minimization of expectation value of the Hamiltonian. To accomplish this, I have used the following code. I have chosen the LiH molecule in sto3g basis.</p>
<p>First, I perform SCF calculation using pyscf just to get the number of orbitals, orbital occupation etc.</p>
<p>Code:</p>
<pre><code>from pyscf import gto, scf, fci
import numpy as np

mol = gto.Mole()
mol.build(atom='Li 0 0 0; H 0 0 1', basis='sto3g', symmetry=1)

mf = scf.RHF(mol)
mf.kernel()
print ('Occupation in MOs: ', mf.mo_occ)
</code></pre>
<p>Output:</p>
<pre><code>converged SCF energy = -7.76736213574856
Occupation in MOs:  [2. 2. 0. 0. 0. 0.]
</code></pre>
<p>Next, I generate the HF reference state and the UCCSD operator.</p>
<pre><code>from qiskit_nature.circuit.library.initial_states.hartree_fock import *
from qiskit_nature.circuit.library.ansatzes import UCC

#Writing the HF state in qubit occupation form 
#The following code gives a circuit to prepare the HF state from the state with all qubits =0
HF = HartreeFock(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True))
#print (HF)

UCC_operator = UCC(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, excitations='sd', qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True), initial_state = HF)
</code></pre>
<p>Then I write down the molecule whose energy needs to be calculated and obtain its Hamiltonian.</p>
<pre><code>from qiskit_nature.drivers import UnitsType, Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem

molecule = Molecule(
    # coordinates are given in Angstrom
    geometry=[
        [&quot;Li&quot;, [0.0, 0.0, 0.0]],
        [&quot;H&quot;, [0.0, 0.0, 1.0]]
    ],
    multiplicity=1,  # = 2*spin + 1
    charge=0,)

driver = ElectronicStructureMoleculeDriver(molecule, basis=&quot;sto3g&quot;, 
                    driver_type=ElectronicStructureDriverType.PYSCF)

problem = ElectronicStructureProblem(driver)
second_q_op = problem.second_q_ops()
qubit_converter = QubitConverter(mapper = JordanWignerMapper(), two_qubit_reduction = True)
Hamiltonian = qubit_converter.convert(second_q_op[0], num_particles=problem.num_particles)
</code></pre>
<p>Now since I am customizing in the minimization part of the VQE algorithm, I will just prepare the VQE instance and then use the <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.VQE.get_energy_evaluation.html#qiskit.algorithms.VQE.get_energy_evaluation"" rel=""nofollow noreferrer""><code>get_energy_evaluation</code></a> method that qiskit provides to use UCCSD-VQE circuit as a parametrized circuit to be evaluated at the desired parameter values.</p>
<pre><code>from qiskit import Aer
from qiskit.algorithms.optimizers import SLSQP
from qiskit.algorithms import VQE

backend = Aer.get_backend('aer_simulator_statevector')
optimizer = SLSQP(maxiter=100)

algorithm = VQE(UCC_operator, optimizer=optimizer, quantum_instance=backend)

energy_eval_func = algorithm.get_energy_evaluation(Hamiltonian, False)
</code></pre>
<p>Now that I have obtained the function to evaluate expectation value of the Hamiltonian of the molecule wrt to a desired UCC state (i.e. T1 and T2 amplitudes), I choose 2 kinds of parameters for the UCC operator and observe the results.</p>
<ol>
<li>All the parameters are equal to 0. This is equivalent to the <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.HFInitialPoint.html#qiskit_nature.algorithms.initial_points.HFInitialPoint"" rel=""nofollow noreferrer""><code>HFInitialpoint</code></a>. I use this as follows.</li>
</ol>
<pre><code>t = UCC_operator.parameters
num_params = len(t)
energy_eval_func(np.zeros(len(t))
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.354893768508214
</code></pre>
<ol start=""2"">
<li>I choose the parameter elements to be MP2 amplitudes. This can be achieved by using <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.MP2InitialPoint.html#qiskit_nature.algorithms.initial_points.MP2InitialPoint"" rel=""nofollow noreferrer""><code>MP2InitialPoint</code></a> as follows.</li>
</ol>
<pre><code>from qiskit_nature.algorithms.initial_points import *

mp2_initial_point = MP2InitialPoint()
mp2_initial_point.compute(UCC_operator, driver_results)
initial_point = mp2_initial_point.to_numpy_array()

energy_eval_func(initial_point)
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.324343952128133
</code></pre>
<p>This is what I do not understand.
<strong>Given that the theoretical energy is -9.371991912791, why is the energy lower for HF initial point than the MP2 initial point?</strong> I was of the opinion that it should have been the other way around. I do not see where have I gone wrong. It would be really helpful if you could clarify this doubt. Thank you.</p>
",qc,hf initial point seems better mp2 initial point qiskit p trying design custom vqe algorithm using qiskit main customization algorithm minimization expectation value hamiltonian accomplish used following code chosen lih molecule sto3g p first perform scf calculation using pyscf get number orbitals orbital occupation p code pre code pyscf import gto scf fci import numpy np mol 0 0 0 h 0 0 1 mf mol print mos p output pre code converged scf energy occupation mos 2 2 0 0 0 0 p next generate hf reference state uccsd pre code import import ucc writing hf state qubit occupation form following code gives circuit prepare hf state state qubits hf hartreefock 2 print hf ucc 2 hf p write molecule whose energy needs calculated obtain pre code import unitstype molecule import electronicstructuredrivertype electronicstructuremoleculedriver import electronicstructureproblem molecule molecule coordinates given angstrom quot li quot quot h quot 2 spin 1 driver electronicstructuremoleculedriver molecule quot sto3g quot problem electronicstructureproblem driver qubitconverter mapper jordanwignermapper true hamiltonian 0 p since customizing minimization part vqe algorithm prepare vqe instance use https nofollow noreferrer code method qiskit provides use circuit parametrized circuit evaluated desired parameter pre code qiskit import aer import slsqp import vqe backend optimizer slsqp algorithm vqe hamiltonian false p obtained function evaluate expectation value hamiltonian molecule wrt desired ucc state t1 t2 amplitudes choose 2 kinds parameters ucc operator observe ol li parameters equal equivalent https nofollow noreferrer code hfinitialpoint use pre code len len print p output pre code ol 2 li choose parameter elements mp2 amplitudes achieved using https nofollow noreferrer code mp2initialpoint pre code import mp2initialpoint print p output pre code p understand strong given theoretical energy energy lower hf initial point mp2 initial point opinion way around see gone wrong would really helpful could clarify doubt thank,"[(0, 0.32541832), (1, 0.02346823), (2, 0.06900455), (4, 0.08702842), (5, 0.020108752), (7, 0.045891266), (8, 0.1607497), (12, 0.011086986), (14, 0.08364056), (17, 0.07854532), (18, 0.06670976), (19, 0.028049467)]"
27392,27393.0,2022-07-19 18:13:54,0,78,"<p>The usual convention is that <span class=""math-container"">$Y=\imath XZ$</span> let's call that the &quot;complex&quot; <span class=""math-container"">$Y$</span> convention; for a number of reasons I prefer to work with <span class=""math-container"">$Y=XZ$</span>, the &quot;real&quot; <span class=""math-container"">$Y$</span> convention. Stim works with the complex <span class=""math-container"">$Y$</span> convention; how would I do a <span class=""math-container"">$CY$</span> and <span class=""math-container"">$MPP$</span> in the real convention? I can find workarounds by multiplying by <span class=""math-container"">$\imath$</span> but I didn't see in the documentation how that's done.</p>
",Stim : How to use gates multiplied by a constant or how to convert between Y and XZ,<stim>,1,0,,,"Stim : How to use gates multiplied by a constant or how to convert between Y and XZ <p>The usual convention is that <span class=""math-container"">$Y=\imath XZ$</span> let's call that the &quot;complex&quot; <span class=""math-container"">$Y$</span> convention; for a number of reasons I prefer to work with <span class=""math-container"">$Y=XZ$</span>, the &quot;real&quot; <span class=""math-container"">$Y$</span> convention. Stim works with the complex <span class=""math-container"">$Y$</span> convention; how would I do a <span class=""math-container"">$CY$</span> and <span class=""math-container"">$MPP$</span> in the real convention? I can find workarounds by multiplying by <span class=""math-container"">$\imath$</span> but I didn't see in the documentation how that's done.</p>
",qc,stim use gates multiplied constant convert xz p usual convention span xz let call quot complex quot span convention number reasons prefer work span quot real quot span convention stim works complex span convention would span cy span mpp real convention find workarounds multiplying span see documentation,"[(3, 0.5277036), (12, 0.021607256), (13, 0.050314203), (14, 0.29430875), (19, 0.10288592)]"
27396,27397.0,2022-07-19 22:00:46,3,327,"<p>I'd like to understand how the signs in the tableau are calculated and if there's a way to force them to be +. Here's an example that shows what I see : (this is an encoder for <span class=""math-container"">$[[8,3,3]]$</span> code)</p>
<pre><code>import stim

def circuit_to_tableau(circuit: stim.Circuit) -&gt; stim.Tableau:
 s=stim.TableauSimulator()
 s.do_circuit(circuit)
 return s.current_inverse_tableau() ** -1

circuit=stim.Circuit('''
 CX 5 4
 CX 6 5
 CX 7 6
 H 0
 CX 0 4
 CX 0 5
 CX 0 6
 CZ 0 6
 H 1
 CZ 1 0
 CX 1 4
 CX 1 5
 CZ 1 5
 CX 1 7
 H 2
 CZ 2 0
 CX 2 4
 CZ 2 5
 CX 2 6
 CX 2 7
 CZ 2 7
 H 3
 CZ 3 0
 CZ 3 1
 CX 3 5
 CX 3 6
 CZ 3 6
 CX 3 7
 CZ 3 7
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
sampler=circuit.compile_sampler()
print(sampler.sample(shots=8))
tableau=circuit_to_tableau(circuit)
print(repr(tableau))
</code></pre>
<p>running it gives this result :</p>
<pre><code>[[False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+ZZZZ_XX_&quot;),
        stim.PauliString(&quot;+Z_Z___XX&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;-ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+___Z_ZZZ&quot;),
        stim.PauliString(&quot;+ZZ____ZZ&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
<p>Why did the fourth z stabilizer pick up a minus sign? these are all stabilizers, destabilizers, and logical for the code and everything works the same with + for all of them.</p>
<p>(PS. Let me know if there's a better place to post Stim specific questions...I have several about syntax ... and I don't want to clutter things here)</p>
<p>Here's another approach to get the encoding circuit using the routines described in a previous post <a href=""https://quantumcomputing.stackexchange.com/questions/27326/how-to-go-from-matrix-to-tableau-to-circuit-in-qiskit-or-stim"">how to go from matrix to tableau to circuit in qiskit or stim</a></p>
<pre><code> matrix=[
 [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
 [0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0],
 [0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0],
 [1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0],
 [0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0],
 [0,0,1,0,1,0,1,1,1,0,1,0,0,1,0,1],
 [0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0],
 [0,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0],
 [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1]]
 tableau = bit_matrix_to_tableau(matrix)
 print(repr(tableau))
 circuit1 = tableau_to_circuit_simple(tableau)
 circuit2=stim.Circuit('''
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
 circuit=circuit1+circuit2
 sampler=circuit.compile_sampler()
 print(sampler.sample(shots=8))
 tableau=circuit_to_tableau(circuit)
 print(repr(tableau))
</code></pre>
<p>This gives a + for all stabilizers when the tableau is generated from a matrix and even when you go matrix -&gt; tableau -&gt; circuit -&gt; tableau</p>
<pre><code>stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
[[False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
",Stim: How are the signs in tableau calculated and how to force them to +,<stim>,2,5,,,"Stim: How are the signs in tableau calculated and how to force them to + <p>I'd like to understand how the signs in the tableau are calculated and if there's a way to force them to be +. Here's an example that shows what I see : (this is an encoder for <span class=""math-container"">$[[8,3,3]]$</span> code)</p>
<pre><code>import stim

def circuit_to_tableau(circuit: stim.Circuit) -&gt; stim.Tableau:
 s=stim.TableauSimulator()
 s.do_circuit(circuit)
 return s.current_inverse_tableau() ** -1

circuit=stim.Circuit('''
 CX 5 4
 CX 6 5
 CX 7 6
 H 0
 CX 0 4
 CX 0 5
 CX 0 6
 CZ 0 6
 H 1
 CZ 1 0
 CX 1 4
 CX 1 5
 CZ 1 5
 CX 1 7
 H 2
 CZ 2 0
 CX 2 4
 CZ 2 5
 CX 2 6
 CX 2 7
 CZ 2 7
 H 3
 CZ 3 0
 CZ 3 1
 CX 3 5
 CX 3 6
 CZ 3 6
 CX 3 7
 CZ 3 7
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
sampler=circuit.compile_sampler()
print(sampler.sample(shots=8))
tableau=circuit_to_tableau(circuit)
print(repr(tableau))
</code></pre>
<p>running it gives this result :</p>
<pre><code>[[False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+ZZZZ_XX_&quot;),
        stim.PauliString(&quot;+Z_Z___XX&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;-ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+___Z_ZZZ&quot;),
        stim.PauliString(&quot;+ZZ____ZZ&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
<p>Why did the fourth z stabilizer pick up a minus sign? these are all stabilizers, destabilizers, and logical for the code and everything works the same with + for all of them.</p>
<p>(PS. Let me know if there's a better place to post Stim specific questions...I have several about syntax ... and I don't want to clutter things here)</p>
<p>Here's another approach to get the encoding circuit using the routines described in a previous post <a href=""https://quantumcomputing.stackexchange.com/questions/27326/how-to-go-from-matrix-to-tableau-to-circuit-in-qiskit-or-stim"">how to go from matrix to tableau to circuit in qiskit or stim</a></p>
<pre><code> matrix=[
 [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
 [0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0],
 [0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0],
 [1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0],
 [0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0],
 [0,0,1,0,1,0,1,1,1,0,1,0,0,1,0,1],
 [0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0],
 [0,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0],
 [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1]]
 tableau = bit_matrix_to_tableau(matrix)
 print(repr(tableau))
 circuit1 = tableau_to_circuit_simple(tableau)
 circuit2=stim.Circuit('''
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
 circuit=circuit1+circuit2
 sampler=circuit.compile_sampler()
 print(sampler.sample(shots=8))
 tableau=circuit_to_tableau(circuit)
 print(repr(tableau))
</code></pre>
<p>This gives a + for all stabilizers when the tableau is generated from a matrix and even when you go matrix -&gt; tableau -&gt; circuit -&gt; tableau</p>
<pre><code>stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
[[False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
",qc,stim signs tableau calculated force p like understand signs tableau calculated way force example shows see encoder span code pre code import stim def circuit gt circuit return cx 5 4 cx 6 5 cx 7 6 h 0 cx 0 4 cx 0 5 cx 0 6 cz 0 6 h 1 cz 1 0 cx 1 4 cx 1 5 cz 1 5 cx 1 7 h 2 cz 2 0 cx 2 4 cz 2 5 cx 2 6 cx 2 7 cz 2 7 h 3 cz 3 0 cz 3 1 cx 3 5 cx 3 6 cz 3 6 cx 3 7 cz 3 7 mpp y0 z2 z3 x4 x5 y6 mpp z0 y1 z3 x4 y5 x7 mpp z0 y2 x4 z5 x6 y7 mpp z0 z1 x3 x5 y6 y7 mpp z0 z1 z2 z3 z4 z5 z6 z7 print circuit print repr tableau p running gives result pre code false false false true false false false false true false false false false true false false false false true false false false false true false false false false true false false false false true false false false false true false quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot p fourth z stabilizer pick minus sign stabilizers destabilizers logical code everything works p ps let know better place post stim specific questions several syntax want clutter things p another approach get encoding circuit using routines described previous post https go matrix tableau circuit qiskit stim pre code tableau matrix print repr tableau circuit1 tableau mpp y0 z2 z3 x4 x5 y6 mpp z0 y1 z3 x4 y5 x7 mpp z0 y2 x4 z5 x6 y7 mpp z0 z1 x3 x5 y6 y7 mpp z0 z1 z2 z3 z4 z5 z6 z7 print circuit print repr tableau p gives stabilizers tableau generated matrix even go matrix gt tableau gt circuit gt tableau pre code quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot,"[(0, 0.033190742), (5, 0.023786493), (6, 0.4186969), (8, 0.014226059), (12, 0.07717625), (13, 0.014181036), (14, 0.090660155), (17, 0.027241118), (19, 0.2858093)]"
27474,,2022-07-25 17:54:41,1,135,"<p>I am using Qiskit's operator flow framework to calculate expectation values of observables. An example composed operator I want to evaluate typically looks like</p>
<p><a href=""https://i.sstatic.net/wolq3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wolq3.png"" alt=""Typical composed op needed to evaluate."" /></a></p>
<p>I want to run this circuit on hardware, but first I am testing using classical backends. Using the code from the opflow tutorial, I use the CircuitSampler class and the included converter as follows:</p>
<pre><code>sampler = of.CircuitSampler(backend=qiskit.Aer.get_backend('aer_simulator_statevector'))
sampled_exp_op = sampler.convert(expectation_op_bound)
sampled_expect_val = sampled_exp_op.eval()
</code></pre>
<p>If I use the 'aer_simulator_statevector' backend I get the correct result. If I use 'aer_simulator' instead, I get the wrong result.</p>
<p>Could someone explain why I am getting two different results?</p>
",different results between aer_simulator and aer_simulator_statevector using Qiskit opflow circuit sampler,<qiskit>,1,0,,,"different results between aer_simulator and aer_simulator_statevector using Qiskit opflow circuit sampler <p>I am using Qiskit's operator flow framework to calculate expectation values of observables. An example composed operator I want to evaluate typically looks like</p>
<p><a href=""https://i.sstatic.net/wolq3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wolq3.png"" alt=""Typical composed op needed to evaluate."" /></a></p>
<p>I want to run this circuit on hardware, but first I am testing using classical backends. Using the code from the opflow tutorial, I use the CircuitSampler class and the included converter as follows:</p>
<pre><code>sampler = of.CircuitSampler(backend=qiskit.Aer.get_backend('aer_simulator_statevector'))
sampled_exp_op = sampler.convert(expectation_op_bound)
sampled_expect_val = sampled_exp_op.eval()
</code></pre>
<p>If I use the 'aer_simulator_statevector' backend I get the correct result. If I use 'aer_simulator' instead, I get the wrong result.</p>
<p>Could someone explain why I am getting two different results?</p>
",qc,different results using qiskit opflow circuit sampler p using qiskit operator flow framework calculate expectation values observables example composed operator want evaluate typically looks like p https nofollow noreferrer img https typical composed op needed evaluate p want run circuit hardware first testing using classical backends using code opflow tutorial use circuitsampler class included converter follows pre code sampler p use backend get correct result use instead get wrong p could someone explain getting two different results,"[(0, 0.09444753), (4, 0.15907297), (8, 0.09828143), (12, 0.013344), (14, 0.6328841)]"
27483,,2022-07-26 10:14:34,4,527,"<p>The following error occurs when executing the code to measure the dephasing time(T2). I would appreciate it if someone could give me a solution to this problem. Among the two functions below, widthoutDelay() performs normally, and the function withDelay() fails with the attached error.</p>
<p>Additionally, where can I find an example code to measure the time-dependent dephasing of the qubit? Some of the sample codes are from a few years ago, so there are a lot of contents that have been depreciated.</p>
<pre>
--------------------------- Execution Code in jupyter ---------------------------

from qiskit import QuantumRegister, ClassicalRegister
from qiskit import QuantumCircuit, execute,IBMQ
from qiskit.tools.monitor import job_monitor
from qiskit import transpile
import numpy

pi = numpy.pi

IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
backend = provider.get_backend('ibm_nairobi')

q = QuantumRegister(1,'q')
c = ClassicalRegister(1,'c')

def withoutDelay():
    circuit = QuantumCircuit(q,c)

    circuit.h(q[0])
    circuit.h(q[0])
    circuit.measure(q[0],c[0]) #Measuring the qubit

    nShots = 8192

    job = execute(circuit, backend, shots=nShots)
    job_monitor(job)

    counts = job.result().get_counts()

    print(""No delay: "",counts)

def withDelay():  
    circuit = QuantumCircuit(q,c)
    circuit.h(q[0])
    circuit.delay(283, unit=""us"") # Delay of 200.79 microseconds   
    circuit.h(q[0])

    circuit.measure(q[0],c[0]) #Measuring the qubit

    transpiled_circ = transpile(circuit, backend, scheduling_method='alap')  

    nShots = 8192
    
    job = execute(transpiled_circ, backend, shots=nShots)
    job_monitor(job)

    counts = job.result().get_counts()

    print(""With delay: "",counts)

withoutDelay()
withDelay()

</pre>
<pre>
--------------------------- Error Message ---------------------------

Job Status: job has successfully run
No delay:  {'0': 8111, '1': 81}

---------------------------------------------------------------------------
TranspilerError                           Traceback (most recent call last)
Input In [19], in ()
     49     print(""With delay: "",counts)
     51 withoutDelay()
---> 52 withDelay()

Input In [19], in withDelay()
     40 transpiled_circ = transpile(circuit, backend, scheduling_method='alap')  
     42 nShots = 8192
---> 44 job = execute(transpiled_circ, backend, shots=nShots)
     45 job_monitor(job)
     47 counts = job.result().get_counts()

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/execute_function.py:299, in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config)
    296     experiments = pass_manager.run(experiments)
    297 else:
    298     # transpiling the circuits using given transpile options
--> 299     experiments = transpile(
    300         experiments,
    301         basis_gates=basis_gates,
    302         coupling_map=coupling_map,
    303         backend_properties=backend_properties,
    304         initial_layout=initial_layout,
    305         seed_transpiler=seed_transpiler,
    306         optimization_level=optimization_level,
    307         backend=backend,
    308     )
    310 if schedule_circuit:
    311     experiments = schedule(
    312         circuits=experiments,
    313         backend=backend,
   (...)
    316         method=scheduling_method,
    317     )

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:341, in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target)
    338     for circuit, unique_args in zip(circuits, unique_transpile_args):
    339         transpile_config, pass_manager = _combine_args(shared_args, unique_args)
    340         output_circuits.append(
--> 341             _serial_transpile_circuit(
    342                 circuit,
    343                 pass_manager,
    344                 transpile_config[""callback""],
    345                 transpile_config[""output_name""],
    346                 transpile_config[""backend_num_qubits""],
    347                 transpile_config[""faulty_qubits_map""],
    348                 transpile_config[""pass_manager_config""].backend_properties,
    349             )
    350         )
    351     circuits = output_circuits
    352 end_time = time()

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:434, in _serial_transpile_circuit(circuit, pass_manager, callback, output_name, num_qubits, faulty_qubits_map, backend_prop)
    425 def _serial_transpile_circuit(
    426     circuit,
    427     pass_manager,
   (...)
    432     backend_prop=None,
    433 ):
--> 434     result = pass_manager.run(circuit, callback=callback, output_name=output_name)
    435     if faulty_qubits_map:
    436         return _remap_circuit_faulty_backend(
    437             result,
    438             num_qubits,
    439             backend_prop,
    440             faulty_qubits_map,
    441         )

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:507, in StagedPassManager.run(self, circuits, output_name, callback)
    500 def run(
    501     self,
    502     circuits: Union[QuantumCircuit, List[QuantumCircuit]],
    503     output_name: str = None,
    504     callback: Callable = None,
    505 ) -> Union[QuantumCircuit, List[QuantumCircuit]]:
    506     self._update_passmanager()
--> 507     return super().run(circuits, output_name, callback)

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:224, in PassManager.run(self, circuits, output_name, callback)
    222     return circuits
    223 if isinstance(circuits, QuantumCircuit):
--> 224     return self._run_single_circuit(circuits, output_name, callback)
    225 if len(circuits) == 1:
    226     return self._run_single_circuit(circuits[0], output_name, callback)

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:279, in PassManager._run_single_circuit(self, circuit, output_name, callback)
    267 """"""Run all the passes on a ``circuit``.
    268 
    269 Args:
   (...)
    276     The transformed circuit.
    277 """"""
    278 running_passmanager = self._create_running_passmanager()
--> 279 result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    280 self.property_set = running_passmanager.property_set
    281 return result

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:124, in RunningPassManager.run(***failed resolving arguments***)
    122 for passset in self.working_list:
    123     for pass_ in passset:
--> 124         dag = self._do_pass(pass_, dag, passset.options)
    126 circuit = dag_to_circuit(dag)
    127 if output_name:

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:167, in RunningPassManager._do_pass(self, pass_, dag, options)
    165 # Run the pass itself, if not already run
    166 if pass_ not in self.valid_passes:
--> 167     dag = self._run_this_pass(pass_, dag)
    169     # update the valid_passes property
    170     self._update_valid_passes(pass_)

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:221, in RunningPassManager._run_this_pass(self, pass_, dag)
    218 elif pass_.is_analysis_pass:
    219     # Measure time if we have a callback or logging set
    220     start_time = time()
--> 221     pass_.run(FencedDAGCircuit(dag))
    222     end_time = time()
    223     run_time = end_time - start_time

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py:206, in ConstrainedReschedule.run(self, dag)
    170 """"""Run rescheduler.
    171 
    172 This pass should perform rescheduling to satisfy:
   (...)
    202     TranspilerError: If circuit is not scheduled.
    203 """"""
    205 if ""node_start_time"" not in self.property_set:
--> 206     raise TranspilerError(
    207         f""The input circuit {dag.name} is not scheduled. Call one of scheduling passes ""
    208         f""before running the {self.__class__.__name__} pass.""
    209     )
    211 node_start_time = self.property_set[""node_start_time""]
    213 for node in dag.topological_op_nodes():

TranspilerError: 'The input circuit None is not scheduled. Call one of scheduling passes before running the ConstrainedReschedule pass.'
</pre>
",TranspilerError: 'The input circuit None is not scheduled',<qiskit><programming>,1,0,,,"TranspilerError: 'The input circuit None is not scheduled' <p>The following error occurs when executing the code to measure the dephasing time(T2). I would appreciate it if someone could give me a solution to this problem. Among the two functions below, widthoutDelay() performs normally, and the function withDelay() fails with the attached error.</p>
<p>Additionally, where can I find an example code to measure the time-dependent dephasing of the qubit? Some of the sample codes are from a few years ago, so there are a lot of contents that have been depreciated.</p>
<pre>
--------------------------- Execution Code in jupyter ---------------------------

from qiskit import QuantumRegister, ClassicalRegister
from qiskit import QuantumCircuit, execute,IBMQ
from qiskit.tools.monitor import job_monitor
from qiskit import transpile
import numpy

pi = numpy.pi

IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
backend = provider.get_backend('ibm_nairobi')

q = QuantumRegister(1,'q')
c = ClassicalRegister(1,'c')

def withoutDelay():
    circuit = QuantumCircuit(q,c)

    circuit.h(q[0])
    circuit.h(q[0])
    circuit.measure(q[0],c[0]) #Measuring the qubit

    nShots = 8192

    job = execute(circuit, backend, shots=nShots)
    job_monitor(job)

    counts = job.result().get_counts()

    print(""No delay: "",counts)

def withDelay():  
    circuit = QuantumCircuit(q,c)
    circuit.h(q[0])
    circuit.delay(283, unit=""us"") # Delay of 200.79 microseconds   
    circuit.h(q[0])

    circuit.measure(q[0],c[0]) #Measuring the qubit

    transpiled_circ = transpile(circuit, backend, scheduling_method='alap')  

    nShots = 8192
    
    job = execute(transpiled_circ, backend, shots=nShots)
    job_monitor(job)

    counts = job.result().get_counts()

    print(""With delay: "",counts)

withoutDelay()
withDelay()

</pre>
<pre>
--------------------------- Error Message ---------------------------

Job Status: job has successfully run
No delay:  {'0': 8111, '1': 81}

---------------------------------------------------------------------------
TranspilerError                           Traceback (most recent call last)
Input In [19], in ()
     49     print(""With delay: "",counts)
     51 withoutDelay()
---> 52 withDelay()

Input In [19], in withDelay()
     40 transpiled_circ = transpile(circuit, backend, scheduling_method='alap')  
     42 nShots = 8192
---> 44 job = execute(transpiled_circ, backend, shots=nShots)
     45 job_monitor(job)
     47 counts = job.result().get_counts()

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/execute_function.py:299, in execute(experiments, backend, basis_gates, coupling_map, backend_properties, initial_layout, seed_transpiler, optimization_level, pass_manager, qobj_id, qobj_header, shots, memory, max_credits, seed_simulator, default_qubit_los, default_meas_los, qubit_lo_range, meas_lo_range, schedule_los, meas_level, meas_return, memory_slots, memory_slot_size, rep_time, rep_delay, parameter_binds, schedule_circuit, inst_map, meas_map, scheduling_method, init_qubits, **run_config)
    296     experiments = pass_manager.run(experiments)
    297 else:
    298     # transpiling the circuits using given transpile options
--> 299     experiments = transpile(
    300         experiments,
    301         basis_gates=basis_gates,
    302         coupling_map=coupling_map,
    303         backend_properties=backend_properties,
    304         initial_layout=initial_layout,
    305         seed_transpiler=seed_transpiler,
    306         optimization_level=optimization_level,
    307         backend=backend,
    308     )
    310 if schedule_circuit:
    311     experiments = schedule(
    312         circuits=experiments,
    313         backend=backend,
   (...)
    316         method=scheduling_method,
    317     )

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:341, in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target)
    338     for circuit, unique_args in zip(circuits, unique_transpile_args):
    339         transpile_config, pass_manager = _combine_args(shared_args, unique_args)
    340         output_circuits.append(
--> 341             _serial_transpile_circuit(
    342                 circuit,
    343                 pass_manager,
    344                 transpile_config[""callback""],
    345                 transpile_config[""output_name""],
    346                 transpile_config[""backend_num_qubits""],
    347                 transpile_config[""faulty_qubits_map""],
    348                 transpile_config[""pass_manager_config""].backend_properties,
    349             )
    350         )
    351     circuits = output_circuits
    352 end_time = time()

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:434, in _serial_transpile_circuit(circuit, pass_manager, callback, output_name, num_qubits, faulty_qubits_map, backend_prop)
    425 def _serial_transpile_circuit(
    426     circuit,
    427     pass_manager,
   (...)
    432     backend_prop=None,
    433 ):
--> 434     result = pass_manager.run(circuit, callback=callback, output_name=output_name)
    435     if faulty_qubits_map:
    436         return _remap_circuit_faulty_backend(
    437             result,
    438             num_qubits,
    439             backend_prop,
    440             faulty_qubits_map,
    441         )

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:507, in StagedPassManager.run(self, circuits, output_name, callback)
    500 def run(
    501     self,
    502     circuits: Union[QuantumCircuit, List[QuantumCircuit]],
    503     output_name: str = None,
    504     callback: Callable = None,
    505 ) -> Union[QuantumCircuit, List[QuantumCircuit]]:
    506     self._update_passmanager()
--> 507     return super().run(circuits, output_name, callback)

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:224, in PassManager.run(self, circuits, output_name, callback)
    222     return circuits
    223 if isinstance(circuits, QuantumCircuit):
--> 224     return self._run_single_circuit(circuits, output_name, callback)
    225 if len(circuits) == 1:
    226     return self._run_single_circuit(circuits[0], output_name, callback)

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:279, in PassManager._run_single_circuit(self, circuit, output_name, callback)
    267 """"""Run all the passes on a ``circuit``.
    268 
    269 Args:
   (...)
    276     The transformed circuit.
    277 """"""
    278 running_passmanager = self._create_running_passmanager()
--> 279 result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    280 self.property_set = running_passmanager.property_set
    281 return result

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:124, in RunningPassManager.run(***failed resolving arguments***)
    122 for passset in self.working_list:
    123     for pass_ in passset:
--> 124         dag = self._do_pass(pass_, dag, passset.options)
    126 circuit = dag_to_circuit(dag)
    127 if output_name:

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:167, in RunningPassManager._do_pass(self, pass_, dag, options)
    165 # Run the pass itself, if not already run
    166 if pass_ not in self.valid_passes:
--> 167     dag = self._run_this_pass(pass_, dag)
    169     # update the valid_passes property
    170     self._update_valid_passes(pass_)

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:221, in RunningPassManager._run_this_pass(self, pass_, dag)
    218 elif pass_.is_analysis_pass:
    219     # Measure time if we have a callback or logging set
    220     start_time = time()
--> 221     pass_.run(FencedDAGCircuit(dag))
    222     end_time = time()
    223     run_time = end_time - start_time

File ~/anaconda3/envs/qiskit/lib/python3.10/site-packages/qiskit/transpiler/passes/scheduling/alignments/reschedule.py:206, in ConstrainedReschedule.run(self, dag)
    170 """"""Run rescheduler.
    171 
    172 This pass should perform rescheduling to satisfy:
   (...)
    202     TranspilerError: If circuit is not scheduled.
    203 """"""
    205 if ""node_start_time"" not in self.property_set:
--> 206     raise TranspilerError(
    207         f""The input circuit {dag.name} is not scheduled. Call one of scheduling passes ""
    208         f""before running the {self.__class__.__name__} pass.""
    209     )
    211 node_start_time = self.property_set[""node_start_time""]
    213 for node in dag.topological_op_nodes():

TranspilerError: 'The input circuit None is not scheduled. Call one of scheduling passes before running the ConstrainedReschedule pass.'
</pre>
",qc,transpilererror input circuit none scheduled p following error occurs executing code measure dephasing time t2 would appreciate someone could give solution problem among two functions widthoutdelay performs normally function withdelay fails attached p additionally find example code measure dephasing qubit sample codes years ago lot contents pre execution code jupyter qiskit import quantumregister classicalregister qiskit import quantumcircuit execute ibmq import qiskit import transpile import numpy pi provider backend q quantumregister 1 q c classicalregister 1 c def withoutdelay circuit quantumcircuit q c q 0 q 0 q 0 c 0 measuring qubit nshots 8192 job execute circuit backend job counts print delay counts def withdelay circuit quantumcircuit q c q 0 283 us delay microseconds q 0 q 0 c 0 measuring qubit transpile circuit backend nshots 8192 job execute backend job counts print delay counts withoutdelay withdelay pre error message job status job successfully run delay 0 8111 1 81 transpilererror traceback recent call last input 19 49 print delay counts 51 withoutdelay 52 withdelay input 19 withdelay 40 transpile circuit backend 42 nshots 8192 44 job execute backend 45 job 47 counts file execute experiments backend shots memory 296 experiments experiments 297 else 298 transpiling circuits using given transpile options 299 experiments transpile 300 experiments 301 302 303 304 305 306 307 308 310 311 experiments schedule 312 313 316 317 file transpile circuits backend dt callback target 338 circuit zip circuits 339 340 341 342 circuit 343 344 callback 345 346 347 348 349 350 351 circuits 352 time file circuit callback 425 def 426 circuit 427 432 433 434 result circuit 435 436 return 437 result 438 439 440 441 file self circuits callback 500 def run 501 self 502 circuits union quantumcircuit list quantumcircuit 503 str none 504 callback callable none 505 union quantumcircuit list quantumcircuit 506 507 return super circuits callback file self circuits callback 222 return circuits 223 isinstance circuits quantumcircuit 224 return circuits callback 225 len circuits 1 226 return circuits 0 callback file self circuit callback 267 run passes circuit 268 269 args 276 transformed circuit 277 278 279 result circuit 280 281 return result file failed resolving arguments 122 passset 123 passset 124 dag dag 126 circuit dag 127 file self dag options 165 run pass already run 166 167 dag dag 169 update property 170 file self dag 218 elif 219 measure time callback logging set 220 time 221 fenceddagcircuit dag 222 time 223 file self dag 170 run rescheduler 171 172 pass perform rescheduling satisfy 202 transpilererror circuit scheduled 203 205 206 raise transpilererror 207 f input circuit scheduled call one scheduling passes 208 f running pass 209 211 213 node transpilererror input circuit none scheduled call one scheduling passes running constrainedreschedule pass,"[(0, 0.4475899), (2, 0.022116559), (5, 0.021303305), (6, 0.026874607), (12, 0.026579654), (14, 0.24883138), (15, 0.014026037), (19, 0.17081136)]"
27489,27493.0,2022-07-27 03:16:41,1,229,"<p>So far, the control bits of most control gates have an AND relationship. How to construct a quantum gate whose control bits are XOR with the fewest auxiliary qubits? And then generalize it, is it possible to realize multi-control quantum gates of arbitrary control logic with different relationships?</p>
",How to construct a multi-control quantum gate whose control bit relation is XOR?,<qiskit>,1,0,,,"How to construct a multi-control quantum gate whose control bit relation is XOR? <p>So far, the control bits of most control gates have an AND relationship. How to construct a quantum gate whose control bits are XOR with the fewest auxiliary qubits? And then generalize it, is it possible to realize multi-control quantum gates of arbitrary control logic with different relationships?</p>
",qc,construct quantum gate whose control bit relation xor p far control bits control gates relationship construct quantum gate whose control bits xor fewest auxiliary qubits generalize possible realize quantum gates arbitrary control logic different relationships,"[(9, 0.50278705), (12, 0.027089305), (18, 0.46528372)]"
27529,,2022-07-29 01:49:28,1,153,"<p>I am relative beginner to building qc circuits and programming. Please share with me how you would begin to approach this problem. What steps would you take to draw this circuit? Thank you for your help.</p>
<p>What I have worked on thus far:</p>
<ol>
<li><p>I have studied the basic idea of a demultiplexer. However, I do not know what the selector switch(s) would be in this case so I will assume the NOT, CNOT, Toffoli and Fredkin gates will play this role?</p>
</li>
<li><p>Using the HINT, I was able to construct a table:</p>
</li>
</ol>
<p>a, b, c, d <strong>to</strong> a(bar)b(bar), ab(bar), a(bar)b, ab   [n]</p>
<p>0  0  0  0                1      0        0        0    n= 2b + a = 0</p>
<p>1  0  0  0                0      1        0        0    n= 2b + a = 1</p>
<p>0  1  0  0                0      0        1        0    n= 2b + a = 2</p>
<p>1  1  0  0                0      0        0        1    n= 2b + a = 3</p>
<ol start=""3"">
<li>My first question re: &quot;where only the  nth  output is  1  (the others are all  0 ), and  n=2b+a .&quot;</li>
</ol>
<p>If a and b inputs are arbitrary, how do I ensure the appropriate nth output? If for n=1, a=1 and b=0 (vs. a=0,b=0), what can I do to ensure that for n=1 the output is 1 0 0 0.</p>
<ol start=""4"">
<li>Second question, should I be using a circuit composer at this stage? If so, how do I begin to think about arbitrary nature of inputs a and b with respect to the boolean logic gates?</li>
</ol>
<p>Any guidance and hints are appreciated.</p>
<p><a href=""https://i.sstatic.net/BRiga.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BRiga.png"" alt=""Reversible 2-bit demultiplexer"" /></a></p>
","How does one begin to map a circuit to this problem? (Reversible 2-bit demultiplexer using NOT, CNOT, Toffoli & Fredkin)",<textbook-and-exercises>,2,1,,,"How does one begin to map a circuit to this problem? (Reversible 2-bit demultiplexer using NOT, CNOT, Toffoli & Fredkin) <p>I am relative beginner to building qc circuits and programming. Please share with me how you would begin to approach this problem. What steps would you take to draw this circuit? Thank you for your help.</p>
<p>What I have worked on thus far:</p>
<ol>
<li><p>I have studied the basic idea of a demultiplexer. However, I do not know what the selector switch(s) would be in this case so I will assume the NOT, CNOT, Toffoli and Fredkin gates will play this role?</p>
</li>
<li><p>Using the HINT, I was able to construct a table:</p>
</li>
</ol>
<p>a, b, c, d <strong>to</strong> a(bar)b(bar), ab(bar), a(bar)b, ab   [n]</p>
<p>0  0  0  0                1      0        0        0    n= 2b + a = 0</p>
<p>1  0  0  0                0      1        0        0    n= 2b + a = 1</p>
<p>0  1  0  0                0      0        1        0    n= 2b + a = 2</p>
<p>1  1  0  0                0      0        0        1    n= 2b + a = 3</p>
<ol start=""3"">
<li>My first question re: &quot;where only the  nth  output is  1  (the others are all  0 ), and  n=2b+a .&quot;</li>
</ol>
<p>If a and b inputs are arbitrary, how do I ensure the appropriate nth output? If for n=1, a=1 and b=0 (vs. a=0,b=0), what can I do to ensure that for n=1 the output is 1 0 0 0.</p>
<ol start=""4"">
<li>Second question, should I be using a circuit composer at this stage? If so, how do I begin to think about arbitrary nature of inputs a and b with respect to the boolean logic gates?</li>
</ol>
<p>Any guidance and hints are appreciated.</p>
<p><a href=""https://i.sstatic.net/BRiga.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BRiga.png"" alt=""Reversible 2-bit demultiplexer"" /></a></p>
",qc,one begin map circuit problem reversible demultiplexer using cnot toffoli fredkin p relative beginner building qc circuits programming please share would begin approach problem steps would take draw circuit thank p worked thus far ol li p studied basic idea demultiplexer however know selector switch would case assume cnot toffoli fredkin gates play role li p using hint able construct table p b c strong bar b bar ab bar bar b ab n p 0 0 0 0 1 0 0 0 2b 0 p 1 0 0 0 0 1 0 0 2b 1 p 0 1 0 0 0 0 1 0 2b 2 p 1 1 0 0 0 0 0 1 2b 3 ol 3 li first question quot nth output 1 others 0 quot p b inputs arbitrary ensure appropriate nth output ensure output 1 0 0 ol 4 li second question using circuit composer stage begin think arbitrary nature inputs b respect boolean logic gates p guidance hints p https nofollow noreferrer img https reversible demultiplexer,"[(2, 0.30865788), (3, 0.0577538), (4, 0.09969498), (7, 0.052791107), (8, 0.124056935), (9, 0.09462854), (12, 0.024738621), (13, 0.13201109), (14, 0.092211045), (19, 0.01285751)]"
27532,,2022-07-29 11:46:41,1,30,"<p>How to visualize a transformation that looks like <span class=""math-container"">$$\rho = \frac{\textbf{I} + r_1 \sigma_1 + r_2 \sigma_2 + r_3 \sigma_3}{2} \rightarrow \frac{\textbf{I} + r_1 \sigma_1 + \lambda ~r_2 \sigma_2 + r_3 \sigma_3}{2},$$</span>
where <span class=""math-container"">$\lambda$</span> is real? What happens on the Bloch sphere under this transformation?</p>
",How can one visual a transformation which affects a component of density matrix?,<textbook-and-exercises><bloch-sphere>,0,3,,,"How can one visual a transformation which affects a component of density matrix? <p>How to visualize a transformation that looks like <span class=""math-container"">$$\rho = \frac{\textbf{I} + r_1 \sigma_1 + r_2 \sigma_2 + r_3 \sigma_3}{2} \rightarrow \frac{\textbf{I} + r_1 \sigma_1 + \lambda ~r_2 \sigma_2 + r_3 \sigma_3}{2},$$</span>
where <span class=""math-container"">$\lambda$</span> is real? What happens on the Bloch sphere under this transformation?</p>
",qc,one visual transformation affects component density matrix p visualize transformation looks like span 2 2 span real happens bloch sphere transformation,"[(2, 0.07143173), (3, 0.47579464), (9, 0.06747361), (11, 0.08711313), (12, 0.04778415), (13, 0.2437949)]"
27645,27646.0,2022-08-06 04:29:21,1,184,"<p>I am looking for some help to understand what I am doing wrong.</p>
<p>I am new to QC and I am trying to create circuit that would be in below state -</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{8}}(|000,0\rangle + |001,0\rangle + |010,0\rangle + |011,0\rangle + |100,0\rangle + |101,0\rangle + |110,0\rangle + |111,1\rangle)$$</span></p>
<p>Below is my code:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import C4XGate

qc = QuantumCircuit(3+1) # n number of qubits plus one ancilla qubit. 

qc.h(0)
qc.h(1)
qc.h(2)
qc.mct([0, 1, 2], 3, mode=&quot;noancilla&quot;)
qc.measure_all()

# qc.draw(output=&quot;mpl&quot;)

from qiskit import Aer, execute, assemble

backend = Aer.get_backend(&quot;aer_simulator&quot;)
qc.save_statevector()
job = execute(qc, backend, shots=1000)
counts = job.result().get_counts()

print(counts)
</code></pre>
<p>I am getting below output.</p>
<p><code>{'0001': 141, '0010': 120, '0011': 129, '0000': 121, '0101': 122, '1111': 134, '0110': 129, '0100': 104}</code></p>
<p>My question is 4th qubit should be 1 when qubit 0, 1 and 2 are 1 (which is true), however, 4th qubit should be 0 otherwise, so why do I have output such as <code>0001</code> or <code>0101</code>?</p>
<p>Thanks for the help in advanced!</p>
",Qiskit - MultiCX gate mcxgate,<qiskit>,1,0,,,"Qiskit - MultiCX gate mcxgate <p>I am looking for some help to understand what I am doing wrong.</p>
<p>I am new to QC and I am trying to create circuit that would be in below state -</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{8}}(|000,0\rangle + |001,0\rangle + |010,0\rangle + |011,0\rangle + |100,0\rangle + |101,0\rangle + |110,0\rangle + |111,1\rangle)$$</span></p>
<p>Below is my code:</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.circuit.library import C4XGate

qc = QuantumCircuit(3+1) # n number of qubits plus one ancilla qubit. 

qc.h(0)
qc.h(1)
qc.h(2)
qc.mct([0, 1, 2], 3, mode=&quot;noancilla&quot;)
qc.measure_all()

# qc.draw(output=&quot;mpl&quot;)

from qiskit import Aer, execute, assemble

backend = Aer.get_backend(&quot;aer_simulator&quot;)
qc.save_statevector()
job = execute(qc, backend, shots=1000)
counts = job.result().get_counts()

print(counts)
</code></pre>
<p>I am getting below output.</p>
<p><code>{'0001': 141, '0010': 120, '0011': 129, '0000': 121, '0101': 122, '1111': 134, '0110': 129, '0100': 104}</code></p>
<p>My question is 4th qubit should be 1 when qubit 0, 1 and 2 are 1 (which is true), however, 4th qubit should be 0 otherwise, so why do I have output such as <code>0001</code> or <code>0101</code>?</p>
<p>Thanks for the help in advanced!</p>
",qc,qiskit multicx gate mcxgate p looking help understand p new qc trying create circuit would state p span 1 8 p code pre code qiskit import quantumcircuit import c4xgate qc quantumcircuit n number qubits plus one ancilla qubit 0 1 2 0 1 2 3 quot noancilla quot quot mpl quot qiskit import aer execute assemble backend quot quot job execute qc backend counts print counts p getting p code 141 120 129 121 122 134 129 104 p question 4th qubit 1 qubit 0 1 2 1 true however 4th qubit 0 otherwise output code 0001 code 0101 p thanks help advanced,"[(0, 0.4768756), (2, 0.13508782), (6, 0.023146082), (8, 0.05083219), (12, 0.020066196), (14, 0.05274361), (18, 0.16660011), (19, 0.07344742)]"
27684,,2022-08-08 18:31:53,1,338,"<p>I have a circuit that encodes the <span class=""math-container"">$[[5,1,3]]$</span> code, adds noise on one of the qubits and then measures the syndrome on 4 ancilla qubits :</p>
<pre><code> import stim

circuit_encode=stim.Circuit('''
H 0
CX 0 4
H 1
CZ 1 0
CX 1 4
CZ 1 4
H 2
CZ 2 1
CX 2 4
CZ 2 4
H 3
CZ 3 0
CZ 3 1
CX 3 4
''')

circuit_channel=stim.Circuit('''
 X_ERROR(0.1) 3
''')

circuit_syndrome=stim.Circuit('''
RZ 5 6 7 8
H 5 6 7 8
CX 5 0
CZ 5 2
CZ 5 3
CX 5 4
CZ 6 0
CX 6 1
CZ 6 1
CZ 6 2
CX 6 4
CZ 6 4
CZ 7 1
CX 7 2
CZ 7 2
CZ 7 3
CX 7 4
CZ 7 4
CZ 8 0
CZ 8 1
CX 8 3
CX 8 4
H 5 6 7 8
''')

circuit_measure=stim.Circuit('''
MPP Z5
DETECTOR rec[-1]
MPP Z6
DETECTOR rec[-1]
MPP Z7
DETECTOR rec[-1]
MPP Z8
DETECTOR rec[-1]
''')

circuit=circuit_encode+circuit_channel+circuit_syndrome+circuit_measure

circuit.detector_error_model()

sampler=circuit.compile_sampler()
print(sampler.sample(shots=20))
</code></pre>
<p>circuit_channel should apply an X error on qubit 3 10% of the time
The results I get are :</p>
<pre><code>[[False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [ True  True False False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [ True  True False False]
 [False  True  True False]
 [ True  True False False]]
</code></pre>
<p>I would expect all False to show up 90% of the time. This is when no error occurs; so the syndrome should be all 0. It does look like there are two patterns &quot;FTTF&quot; ~ 90% of the time and &quot;TTFF&quot; ~ 10% so there's probably some adjustment to make the &quot;no error&quot; case return with FFFF measurement; I don't know how that's done.</p>
",stim: how to control sign of syndrome measurements,<error-correction><stim>,1,7,,,"stim: how to control sign of syndrome measurements <p>I have a circuit that encodes the <span class=""math-container"">$[[5,1,3]]$</span> code, adds noise on one of the qubits and then measures the syndrome on 4 ancilla qubits :</p>
<pre><code> import stim

circuit_encode=stim.Circuit('''
H 0
CX 0 4
H 1
CZ 1 0
CX 1 4
CZ 1 4
H 2
CZ 2 1
CX 2 4
CZ 2 4
H 3
CZ 3 0
CZ 3 1
CX 3 4
''')

circuit_channel=stim.Circuit('''
 X_ERROR(0.1) 3
''')

circuit_syndrome=stim.Circuit('''
RZ 5 6 7 8
H 5 6 7 8
CX 5 0
CZ 5 2
CZ 5 3
CX 5 4
CZ 6 0
CX 6 1
CZ 6 1
CZ 6 2
CX 6 4
CZ 6 4
CZ 7 1
CX 7 2
CZ 7 2
CZ 7 3
CX 7 4
CZ 7 4
CZ 8 0
CZ 8 1
CX 8 3
CX 8 4
H 5 6 7 8
''')

circuit_measure=stim.Circuit('''
MPP Z5
DETECTOR rec[-1]
MPP Z6
DETECTOR rec[-1]
MPP Z7
DETECTOR rec[-1]
MPP Z8
DETECTOR rec[-1]
''')

circuit=circuit_encode+circuit_channel+circuit_syndrome+circuit_measure

circuit.detector_error_model()

sampler=circuit.compile_sampler()
print(sampler.sample(shots=20))
</code></pre>
<p>circuit_channel should apply an X error on qubit 3 10% of the time
The results I get are :</p>
<pre><code>[[False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [ True  True False False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [False  True  True False]
 [ True  True False False]
 [False  True  True False]
 [ True  True False False]]
</code></pre>
<p>I would expect all False to show up 90% of the time. This is when no error occurs; so the syndrome should be all 0. It does look like there are two patterns &quot;FTTF&quot; ~ 90% of the time and &quot;TTFF&quot; ~ 10% so there's probably some adjustment to make the &quot;no error&quot; case return with FFFF measurement; I don't know how that's done.</p>
",qc,stim control sign syndrome measurements p circuit encodes span code adds noise one qubits measures syndrome 4 ancilla qubits pre code import stim h 0 cx 0 4 h 1 cz 1 0 cx 1 4 cz 1 4 h 2 cz 2 1 cx 2 4 cz 2 4 h 3 cz 3 0 cz 3 1 cx 3 4 3 rz 5 6 7 8 h 5 6 7 8 cx 5 0 cz 5 2 cz 5 3 cx 5 4 cz 6 0 cx 6 1 cz 6 1 cz 6 2 cx 6 4 cz 6 4 cz 7 1 cx 7 2 cz 7 2 cz 7 3 cx 7 4 cz 7 4 cz 8 0 cz 8 1 cx 8 3 cx 8 4 h 5 6 7 8 mpp z5 detector rec mpp z6 detector rec mpp z7 detector rec mpp z8 detector rec print p apply x error qubit 3 10 time results get pre code false true true false false true true false false true true false false true true false false true true false false true true false false true true false false true true false false true true false false true true false true true false false false true true false false true true false false true true false false true true false false true true false false true true false true true false false false true true false true true false false p would expect false show 90 time error occurs syndrome look like two patterns quot fttf quot 90 time quot ttff quot 10 probably adjustment make quot error quot case return ffff measurement know,"[(0, 0.035188664), (5, 0.032079753), (6, 0.7968167), (12, 0.030087307), (18, 0.07126171), (19, 0.03188188)]"
27689,,2022-08-09 06:29:40,0,68,"<p>Want to learn how to simulate QLDPC code. what are the best tools available to do the same. can any one provide some sample python codes if possible for getting started with it.</p>
",What are the tools available that are used for analysing Quantum LDPC code?,<error-correction>,0,2,,,"What are the tools available that are used for analysing Quantum LDPC code? <p>Want to learn how to simulate QLDPC code. what are the best tools available to do the same. can any one provide some sample python codes if possible for getting started with it.</p>
",qc,tools available used analysing quantum ldpc code p want learn simulate qldpc code best tools available one provide sample python codes possible getting started,"[(5, 0.059621252), (8, 0.29004708), (9, 0.10543992), (12, 0.040089853), (14, 0.4985889)]"
27772,,2022-08-14 13:47:13,1,30,"<p>I am a starter of this quantum mostly new to quantum computing but I wonder if there is any option of simulating duality quantum computing in qiskit or IBM q or any other alternative way?</p>
<p><a href=""https://arxiv.org/abs/1507.03200#:%7E:text=In%20this%20review%2C%20we%20will%20show%20that%20duality,precision%20for%20simulating%20systems%20with%20a%20sparse%20Hamiltonian."" rel=""nofollow noreferrer"">Duality Quantum Computing and the efficient simulation </a></p>
",duality quantum computing simulation,<qiskit><ibm-q-experience><cirq>,0,1,,,"duality quantum computing simulation <p>I am a starter of this quantum mostly new to quantum computing but I wonder if there is any option of simulating duality quantum computing in qiskit or IBM q or any other alternative way?</p>
<p><a href=""https://arxiv.org/abs/1507.03200#:%7E:text=In%20this%20review%2C%20we%20will%20show%20that%20duality,precision%20for%20simulating%20systems%20with%20a%20sparse%20Hamiltonian."" rel=""nofollow noreferrer"">Duality Quantum Computing and the efficient simulation </a></p>
",qc,duality quantum computing simulation p starter quantum mostly new quantum computing wonder option simulating duality quantum computing qiskit ibm q alternative way p https 7e 20this 20review 2c 20we 20will 20show 20that 20duality precision 20for 20simulating 20systems 20with 20a 20sparse 20hamiltonian nofollow noreferrer duality quantum computing efficient simulation,"[(1, 0.246989), (4, 0.10699479), (7, 0.16442224), (8, 0.3171865), (9, 0.034135673), (10, 0.02902428), (12, 0.027640121), (13, 0.07036541)]"
27773,,2022-08-14 14:59:52,2,59,"<p>I need help. I'm a computer science student with a Data science major. I have a final graduation project this year. With that, I want to create a project in the Quantum computing field. I'm already studying Quantum Computing for about two years. I have remarkably Experience in Qiskit. My question is, what exactly should I focus on in the field of Quantum to do in my graduation project? For example, should I make it with Quantum AI, or what would be good for me as a Computer Science student with a data science major? If you can suggest how I can find a good idea I can work on and develop would be great.</p>
<p>Thank you so much for the help</p>
",A path towards building quantum Computing graduation project for undergraduates,<programming><quantum-gate><quantum-state><ibm-q-experience><quantum-enhanced-machine-learning>,0,0,,,"A path towards building quantum Computing graduation project for undergraduates <p>I need help. I'm a computer science student with a Data science major. I have a final graduation project this year. With that, I want to create a project in the Quantum computing field. I'm already studying Quantum Computing for about two years. I have remarkably Experience in Qiskit. My question is, what exactly should I focus on in the field of Quantum to do in my graduation project? For example, should I make it with Quantum AI, or what would be good for me as a Computer Science student with a data science major? If you can suggest how I can find a good idea I can work on and develop would be great.</p>
<p>Thank you so much for the help</p>
",qc,path towards building quantum computing graduation project undergraduates p need help computer science student data science major final graduation project year want create project quantum computing field already studying quantum computing two years remarkably experience qiskit question exactly focus field quantum graduation project example make quantum ai would good computer science student data science major suggest find good idea work develop would p thank much help,"[(8, 0.9805492), (12, 0.016508942)]"
27850,,2022-08-18 14:56:12,2,68,"<p>Suppose I have two quantum circuits <span class=""math-container"">$A_n,B_n$</span> that I have already found to approximate the operations <span class=""math-container"">$U,V$</span> within some error <span class=""math-container"">$\epsilon_n$</span> and each with an overall circuit depth <span class=""math-container"">$\ell_n$</span> using <span class=""math-container"">$n$</span> iterations of the <a href=""https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem"" rel=""nofollow noreferrer"">Solovay-Kitaev</a> algorithm.</p>
<p>If I then desired another approximation to the product <span class=""math-container"">$A_n B_n$</span>, is there a clever way I can use my knowledge of <span class=""math-container"">$A_n,B_n$</span> to more easily compute a circuit <span class=""math-container"">$C$</span> of equal depth as <span class=""math-container"">$A_n,B_n$</span> while perhaps accepting a greater additive error of <span class=""math-container"">$||A_nB_n - UV ||&lt;||C - UV ||$</span>?</p>
<p>A basic first attempt could be to use the initial guesses <span class=""math-container"">$(A_0,B_0)$</span> for <span class=""math-container"">$A_n,B_n$</span> with depth <span class=""math-container"">$\ell_0$</span> as the starting point for another call to the SK algorithm. The overall circuit depth will not be doubled but will still be greater than <span class=""math-container"">$\ell_n$</span>. Since I am really interested in if an exactly equal depth circuit can be found, this is insufficient. In this direction however a good place to start I think is to not to directly attempt a good approximation to <span class=""math-container"">$A_nB_n$</span> but rather settle for an easily determined initial value for <span class=""math-container"">$C_0$</span>, saving a lookup in the computed <span class=""math-container"">$\epsilon$</span>-net at the least when computing an approximation using Solovay-Kitaev.</p>
",Approximating the concatenation of two approximate circuits,<quantum-gate><circuit-construction><solovay-kitaev-algorithm><approximation>,0,0,,,"Approximating the concatenation of two approximate circuits <p>Suppose I have two quantum circuits <span class=""math-container"">$A_n,B_n$</span> that I have already found to approximate the operations <span class=""math-container"">$U,V$</span> within some error <span class=""math-container"">$\epsilon_n$</span> and each with an overall circuit depth <span class=""math-container"">$\ell_n$</span> using <span class=""math-container"">$n$</span> iterations of the <a href=""https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem"" rel=""nofollow noreferrer"">Solovay-Kitaev</a> algorithm.</p>
<p>If I then desired another approximation to the product <span class=""math-container"">$A_n B_n$</span>, is there a clever way I can use my knowledge of <span class=""math-container"">$A_n,B_n$</span> to more easily compute a circuit <span class=""math-container"">$C$</span> of equal depth as <span class=""math-container"">$A_n,B_n$</span> while perhaps accepting a greater additive error of <span class=""math-container"">$||A_nB_n - UV ||&lt;||C - UV ||$</span>?</p>
<p>A basic first attempt could be to use the initial guesses <span class=""math-container"">$(A_0,B_0)$</span> for <span class=""math-container"">$A_n,B_n$</span> with depth <span class=""math-container"">$\ell_0$</span> as the starting point for another call to the SK algorithm. The overall circuit depth will not be doubled but will still be greater than <span class=""math-container"">$\ell_n$</span>. Since I am really interested in if an exactly equal depth circuit can be found, this is insufficient. In this direction however a good place to start I think is to not to directly attempt a good approximation to <span class=""math-container"">$A_nB_n$</span> but rather settle for an easily determined initial value for <span class=""math-container"">$C_0$</span>, saving a lookup in the computed <span class=""math-container"">$\epsilon$</span>-net at the least when computing an approximation using Solovay-Kitaev.</p>
",qc,approximating concatenation two approximate circuits p suppose two quantum circuits span already found approximate operations span u v within error span overall circuit depth span using span n iterations https e2 80 nofollow noreferrer p desired another approximation product span clever way use knowledge span easily compute circuit span c equal depth span perhaps accepting greater additive error span uv lt uv p basic first attempt could use initial guesses span span depth span starting point another call sk algorithm overall circuit depth doubled still greater span since really interested exactly equal depth circuit found insufficient direction however good place start think directly attempt good approximation span rather settle easily determined initial value span saving lookup computed span least computing approximation using,"[(3, 0.40622425), (5, 0.021839524), (8, 0.22212663), (9, 0.15104768), (12, 0.017193561), (14, 0.1718165)]"
27903,,2022-08-23 12:50:09,1,130,"<p>I'm trying to run a quantum circuit created in Qiskit, on Ionq Device using <code>qiskit_braket_provider</code>. Getting some error while transpiling the circuit because circuit contains a <code>qiskit.initialize</code> instruction. Is there any alternative for <code>initialize</code> function in aws braket? Any other way out of this problem?</p>
<p>This problem can be recreated as:</p>
<p><strong>Code:</strong></p>
<pre><code>qc = QuantumCircuit(2)
st = random_statevector(2)
qc.initialize(st, 0)
qc.x(1)
tqc = transpile(qc,backend = ionq)
</code></pre>
<p><strong>Error:</strong></p>
<pre><code>TranspilerError                           Traceback (most recent call last)
Input In [66], in &lt;cell line: 1&gt;()
----&gt; 1 tqc = transpile(qc,backend = ionq)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:341, in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target)
    338     for circuit, unique_args in zip(circuits, unique_transpile_args):
    339         transpile_config, pass_manager = _combine_args(shared_args, unique_args)
    340         output_circuits.append(
--&gt; 341             _serial_transpile_circuit(
    342                 circuit,
    343                 pass_manager,
    344                 transpile_config[&quot;callback&quot;],
    345                 transpile_config[&quot;output_name&quot;],
    346                 transpile_config[&quot;backend_num_qubits&quot;],
    347                 transpile_config[&quot;faulty_qubits_map&quot;],
    348                 transpile_config[&quot;pass_manager_config&quot;].backend_properties,
    349             )
    350         )
    351     circuits = output_circuits
    352 end_time = time()

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:434, in _serial_transpile_circuit(circuit, pass_manager, callback, output_name, num_qubits, faulty_qubits_map, backend_prop)
    425 def _serial_transpile_circuit(
    426     circuit,
    427     pass_manager,
   (...)
    432     backend_prop=None,
    433 ):
--&gt; 434     result = pass_manager.run(circuit, callback=callback, output_name=output_name)
    435     if faulty_qubits_map:
    436         return _remap_circuit_faulty_backend(
    437             result,
    438             num_qubits,
    439             backend_prop,
    440             faulty_qubits_map,
    441         )

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:507, in StagedPassManager.run(self, circuits, output_name, callback)
    500 def run(
    501     self,
    502     circuits: Union[QuantumCircuit, List[QuantumCircuit]],
    503     output_name: str = None,
    504     callback: Callable = None,
    505 ) -&gt; Union[QuantumCircuit, List[QuantumCircuit]]:
    506     self._update_passmanager()
--&gt; 507     return super().run(circuits, output_name, callback)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:224, in PassManager.run(self, circuits, output_name, callback)
    222     return circuits
    223 if isinstance(circuits, QuantumCircuit):
--&gt; 224     return self._run_single_circuit(circuits, output_name, callback)
    225 if len(circuits) == 1:
    226     return self._run_single_circuit(circuits[0], output_name, callback)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:279, in PassManager._run_single_circuit(self, circuit, output_name, callback)
    267 &quot;&quot;&quot;Run all the passes on a ``circuit``.
    268 
    269 Args:
   (...)
    276     The transformed circuit.
    277 &quot;&quot;&quot;
    278 running_passmanager = self._create_running_passmanager()
--&gt; 279 result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    280 self.property_set = running_passmanager.property_set
    281 return result

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:124, in RunningPassManager.run(***failed resolving arguments***)
    122 for passset in self.working_list:
    123     for pass_ in passset:
--&gt; 124         dag = self._do_pass(pass_, dag, passset.options)
    126 circuit = dag_to_circuit(dag)
    127 if output_name:

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:167, in RunningPassManager._do_pass(self, pass_, dag, options)
    165 # Run the pass itself, if not already run
    166 if pass_ not in self.valid_passes:
--&gt; 167     dag = self._run_this_pass(pass_, dag)
    169     # update the valid_passes property
    170     self._update_valid_passes(pass_)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:196, in RunningPassManager._run_this_pass(self, pass_, dag)
    193 if pass_.is_transformation_pass:
    194     # Measure time if we have a callback or logging set
    195     start_time = time()
--&gt; 196     new_dag = pass_.run(dag)
    197     end_time = time()
    198     run_time = end_time - start_time

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py:184, in BasisTranslator.run(self, dag)
    179 logger.info(
    180     &quot;Basis translation path search completed in %.3fs.&quot;, search_end_time - search_start_time
    181 )
    183 if basis_transforms is None:
--&gt; 184     raise TranspilerError(
    185         &quot;Unable to map source basis {} to target basis {} &quot;
    186         &quot;over library {}.&quot;.format(source_basis, target_basis, self._equiv_lib)
    187     )
    189 # Compose found path into a set of instruction substitution rules.
    191 compose_start_time = time.time()

TranspilerError: &quot;Unable to map source basis {('reset', 1), ('x', 1), ('rz', 1), ('ry', 1)} to target basis {'h', 'rzz', 's', 'sdg', 'tdg', 'rz', 'swap', 'barrier', 'cx', 'x', 'id', 'z', 'sx', 'sxdg', 'y', 'measure', 't', 'rxx', 'rx', 'ryy', 'snapshot', 'ry'} over library &lt;qiskit.circuit.equivalence.EquivalenceLibrary object at 0x7f0900dd5ea0&gt;.&quot;
<span class=""math-container"">```</span>
</code></pre>
",Is there any alternative for `qiskit.initialize` in aws braket for running circuit on `Ionq Device`?,<qiskit><amazon-braket><ionq>,1,0,,,"Is there any alternative for `qiskit.initialize` in aws braket for running circuit on `Ionq Device`? <p>I'm trying to run a quantum circuit created in Qiskit, on Ionq Device using <code>qiskit_braket_provider</code>. Getting some error while transpiling the circuit because circuit contains a <code>qiskit.initialize</code> instruction. Is there any alternative for <code>initialize</code> function in aws braket? Any other way out of this problem?</p>
<p>This problem can be recreated as:</p>
<p><strong>Code:</strong></p>
<pre><code>qc = QuantumCircuit(2)
st = random_statevector(2)
qc.initialize(st, 0)
qc.x(1)
tqc = transpile(qc,backend = ionq)
</code></pre>
<p><strong>Error:</strong></p>
<pre><code>TranspilerError                           Traceback (most recent call last)
Input In [66], in &lt;cell line: 1&gt;()
----&gt; 1 tqc = transpile(qc,backend = ionq)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:341, in transpile(circuits, backend, basis_gates, inst_map, coupling_map, backend_properties, initial_layout, layout_method, routing_method, translation_method, scheduling_method, instruction_durations, dt, approximation_degree, timing_constraints, seed_transpiler, optimization_level, callback, output_name, unitary_synthesis_method, unitary_synthesis_plugin_config, target)
    338     for circuit, unique_args in zip(circuits, unique_transpile_args):
    339         transpile_config, pass_manager = _combine_args(shared_args, unique_args)
    340         output_circuits.append(
--&gt; 341             _serial_transpile_circuit(
    342                 circuit,
    343                 pass_manager,
    344                 transpile_config[&quot;callback&quot;],
    345                 transpile_config[&quot;output_name&quot;],
    346                 transpile_config[&quot;backend_num_qubits&quot;],
    347                 transpile_config[&quot;faulty_qubits_map&quot;],
    348                 transpile_config[&quot;pass_manager_config&quot;].backend_properties,
    349             )
    350         )
    351     circuits = output_circuits
    352 end_time = time()

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/compiler/transpiler.py:434, in _serial_transpile_circuit(circuit, pass_manager, callback, output_name, num_qubits, faulty_qubits_map, backend_prop)
    425 def _serial_transpile_circuit(
    426     circuit,
    427     pass_manager,
   (...)
    432     backend_prop=None,
    433 ):
--&gt; 434     result = pass_manager.run(circuit, callback=callback, output_name=output_name)
    435     if faulty_qubits_map:
    436         return _remap_circuit_faulty_backend(
    437             result,
    438             num_qubits,
    439             backend_prop,
    440             faulty_qubits_map,
    441         )

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:507, in StagedPassManager.run(self, circuits, output_name, callback)
    500 def run(
    501     self,
    502     circuits: Union[QuantumCircuit, List[QuantumCircuit]],
    503     output_name: str = None,
    504     callback: Callable = None,
    505 ) -&gt; Union[QuantumCircuit, List[QuantumCircuit]]:
    506     self._update_passmanager()
--&gt; 507     return super().run(circuits, output_name, callback)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:224, in PassManager.run(self, circuits, output_name, callback)
    222     return circuits
    223 if isinstance(circuits, QuantumCircuit):
--&gt; 224     return self._run_single_circuit(circuits, output_name, callback)
    225 if len(circuits) == 1:
    226     return self._run_single_circuit(circuits[0], output_name, callback)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passmanager.py:279, in PassManager._run_single_circuit(self, circuit, output_name, callback)
    267 &quot;&quot;&quot;Run all the passes on a ``circuit``.
    268 
    269 Args:
   (...)
    276     The transformed circuit.
    277 &quot;&quot;&quot;
    278 running_passmanager = self._create_running_passmanager()
--&gt; 279 result = running_passmanager.run(circuit, output_name=output_name, callback=callback)
    280 self.property_set = running_passmanager.property_set
    281 return result

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:124, in RunningPassManager.run(***failed resolving arguments***)
    122 for passset in self.working_list:
    123     for pass_ in passset:
--&gt; 124         dag = self._do_pass(pass_, dag, passset.options)
    126 circuit = dag_to_circuit(dag)
    127 if output_name:

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:167, in RunningPassManager._do_pass(self, pass_, dag, options)
    165 # Run the pass itself, if not already run
    166 if pass_ not in self.valid_passes:
--&gt; 167     dag = self._run_this_pass(pass_, dag)
    169     # update the valid_passes property
    170     self._update_valid_passes(pass_)

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/runningpassmanager.py:196, in RunningPassManager._run_this_pass(self, pass_, dag)
    193 if pass_.is_transformation_pass:
    194     # Measure time if we have a callback or logging set
    195     start_time = time()
--&gt; 196     new_dag = pass_.run(dag)
    197     end_time = time()
    198     run_time = end_time - start_time

File ~/anaconda3/envs/qlab/lib/python3.10/site-packages/qiskit/transpiler/passes/basis/basis_translator.py:184, in BasisTranslator.run(self, dag)
    179 logger.info(
    180     &quot;Basis translation path search completed in %.3fs.&quot;, search_end_time - search_start_time
    181 )
    183 if basis_transforms is None:
--&gt; 184     raise TranspilerError(
    185         &quot;Unable to map source basis {} to target basis {} &quot;
    186         &quot;over library {}.&quot;.format(source_basis, target_basis, self._equiv_lib)
    187     )
    189 # Compose found path into a set of instruction substitution rules.
    191 compose_start_time = time.time()

TranspilerError: &quot;Unable to map source basis {('reset', 1), ('x', 1), ('rz', 1), ('ry', 1)} to target basis {'h', 'rzz', 's', 'sdg', 'tdg', 'rz', 'swap', 'barrier', 'cx', 'x', 'id', 'z', 'sx', 'sxdg', 'y', 'measure', 't', 'rxx', 'rx', 'ryy', 'snapshot', 'ry'} over library &lt;qiskit.circuit.equivalence.EquivalenceLibrary object at 0x7f0900dd5ea0&gt;.&quot;
<span class=""math-container"">```</span>
</code></pre>
",qc,alternative aws braket running circuit ionq device p trying run quantum circuit created qiskit ionq device using code getting error transpiling circuit circuit contains code instruction alternative code initialize function aws braket way problem p problem recreated p strong code pre code qc quantumcircuit 2 st 2 st 0 1 tqc transpile qc backend ionq p strong error pre code transpilererror traceback recent call last input 66 lt cell line 1 gt gt 1 tqc transpile qc backend ionq file transpile circuits backend dt callback target 338 circuit zip circuits 339 340 gt 341 342 circuit 343 344 quot callback quot 345 quot quot 346 quot quot 347 quot quot 348 quot quot 349 350 351 circuits 352 time file circuit callback 425 def 426 circuit 427 432 433 gt 434 result circuit 435 436 return 437 result 438 439 440 441 file self circuits callback 500 def run 501 self 502 circuits union quantumcircuit list quantumcircuit 503 str none 504 callback callable none 505 gt union quantumcircuit list quantumcircuit 506 gt 507 return super circuits callback file self circuits callback 222 return circuits 223 isinstance circuits quantumcircuit gt 224 return circuits callback 225 len circuits 1 226 return circuits 0 callback file self circuit callback 267 quot quot quot run passes circuit 268 269 args 276 transformed circuit 277 quot quot quot 278 gt 279 result circuit 280 281 return result file failed resolving arguments 122 passset 123 passset gt 124 dag dag 126 circuit dag 127 file self dag options 165 run pass already run 166 gt 167 dag dag 169 update property 170 file self dag 193 194 measure time callback logging set 195 time gt 196 dag 197 time 198 file self dag 179 180 quot basis translation path search completed quot 181 183 none gt 184 raise transpilererror 185 quot unable map source basis target basis quot 186 quot library quot 187 189 compose found path set instruction substitution rules 191 transpilererror quot unable map source basis 1 x 1 1 1 target basis h x z library lt object 0x7f0900dd5ea0 gt quot span,"[(0, 0.47356626), (2, 0.019491179), (5, 0.0114531955), (12, 0.010118153), (14, 0.18306547), (15, 0.018207526), (19, 0.25723276)]"
27980,,2022-08-29 12:48:04,1,502,"<p>I am a beginner in Quantum Computing programing and I need HELP.
I do not know why the Python or Qiskit does not recognize the &quot;transpile&quot; command? For example,</p>
<pre><code>from qiskit import (
    QuantumRegister,
    ClassicalRegister,
    QuantumCircuit,
    Aer,
    transpile,
)

simulator = Aer.get_backend('aer_simulator')

qreg = QuantumRegister(2, 'q0') # greg is filled with two qubits
creg = ClassicalRegister(2, 'c0') # creg is filled with two classical bits

cir = QuantumCircuit(qreg,creg) # we put registers qreg and creg together to make our circuit, called entangled

cir.h(0) # apply the Hadamard gate to the first qubit
cir.cx(0,1) # apply the CNOT gate with the first as the control and the second qubit as the target

cir.measure(0,0)
cir.measure(1,1)

cir=transpile(cir,simulator)
</code></pre>
<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

Input In [1], in &lt;cell line: 1&gt;()
----&gt; 1 cir=transpile(cir,simulator)
    

NameError: name 'transpile' is not defined
</code></pre>
<p>I am using:</p>
<ul>
<li>Qiskit Version 0.21.2</li>
<li>Python Version 3.9.12</li>
</ul>
<p>In the case the question cannot be answered by this group can you direct me to someone who can help me.</p>
<p>Thank you in advance for your consideration.</p>
<p>Full <code>conda list</code>:</p>
<pre><code>    # packages in environment at C:\Users\Sirob\anaconda3:
    Note: you may need to restart the kernel to use updated packages.
    
    #
    # Name                    Version                   Build  Channel
    _ipyw_jlab_nb_ext_conf    0.1.0            py39haa95532_0  
    aiohttp                   3.8.1            py39h2bbff1b_1  
    aiosignal                 1.2.0              pyhd3eb1b0_0  
    alabaster                 0.7.12             pyhd3eb1b0_0  
    anaconda                  2022.05                  py39_0  
    anaconda-client           1.9.0            py39haa95532_0  
    anaconda-navigator        2.2.0            py39haa95532_0  
    anaconda-project          0.10.2             pyhd3eb1b0_0  
    anyio                     3.5.0            py39haa95532_0  
    appdirs                   1.4.4              pyhd3eb1b0_0  
    argon2-cffi               21.3.0             pyhd3eb1b0_0  
    argon2-cffi-bindings      21.2.0           py39h2bbff1b_0  
    arrow                     1.2.2              pyhd3eb1b0_0  
    astroid                   2.6.6            py39haa95532_0  
    astropy                   5.0.4            py39h080aedc_0  
    asttokens                 2.0.5              pyhd3eb1b0_0  
    async-timeout             4.0.1              pyhd3eb1b0_0  
    atomicwrites              1.4.0                      py_0  
    attrs                     21.4.0             pyhd3eb1b0_0  
    automat                   20.2.0                     py_0  
    autopep8                  1.6.0              pyhd3eb1b0_0  
    babel                     2.9.1              pyhd3eb1b0_0  
    backcall                  0.2.0              pyhd3eb1b0_0  
    backports                 1.1                pyhd3eb1b0_0  
    backports.functools_lru_cache 1.6.4              pyhd3eb1b0_0  
    backports.tempfile        1.0                pyhd3eb1b0_1  
    backports.weakref         1.0.post1                  py_1  
    bcrypt                    3.2.0            py39h196d8e1_0  
    beautifulsoup4            4.11.1           py39haa95532_0  
    binaryornot               0.4.4              pyhd3eb1b0_1  
    bitarray                  2.4.1            py39h2bbff1b_0  
    bkcharts                  0.2              py39haa95532_0  
    black                     19.10b0                    py_0  
    blas                      1.0                         mkl  
    bleach                    4.1.0              pyhd3eb1b0_0  
    blosc                     1.21.0               h19a0ad4_0  
    bokeh                     2.4.2            py39haa95532_0  
    boto3                     1.21.32            pyhd3eb1b0_0  
    botocore                  1.24.32            pyhd3eb1b0_0  
    bottleneck                1.3.4            py39h080aedc_0  
    brotli                    1.0.9                ha925a31_2  
    brotlipy                  0.7.0           py39h2bbff1b_1003  
    bzip2                     1.0.8                he774522_0  
    ca-certificates           2022.3.29            haa95532_1  
    cachetools                4.2.2              pyhd3eb1b0_0  
    certifi                   2021.10.8        py39haa95532_2  
    cffi                      1.15.0           py39h2bbff1b_1  
    cfitsio                   3.470                he774522_6  
    chardet                   4.0.0           py39haa95532_1003  
    charls                    2.2.0                h6c2663c_0  
    charset-normalizer        2.0.4              pyhd3eb1b0_0  
    click                     8.0.4            py39haa95532_0  
    cloudpickle               2.0.0              pyhd3eb1b0_0  
    clyent                    1.2.2            py39haa95532_1  
    colorama                  0.4.4              pyhd3eb1b0_0  
    colorcet                  2.0.6              pyhd3eb1b0_0  
    comtypes                  1.1.10          py39haa95532_1002  
    conda                     4.14.0           py39haa95532_0  
    conda-build               3.21.8           py39haa95532_2  
    conda-content-trust       0.1.1              pyhd3eb1b0_0  
    conda-env                 2.6.0                haa95532_1  
    conda-pack                0.6.0              pyhd3eb1b0_0  
    conda-package-handling    1.8.1            py39h8cc25b3_0  
    conda-repo-cli            1.0.4              pyhd3eb1b0_0  
    conda-token               0.3.0              pyhd3eb1b0_0  
    conda-verify              3.4.2                      py_1  
    console_shortcut          0.1.1                         4  
    constantly                15.1.0             pyh2b92418_0  
    cookiecutter              1.7.3              pyhd3eb1b0_0  
    cryptography              3.4.8            py39h71e12ea_0  
    cssselect                 1.1.0              pyhd3eb1b0_0  
    curl                      7.82.0               h2bbff1b_0  
    cycler                    0.11.0             pyhd3eb1b0_0  
    cython                    0.29.28          py39hd77b12b_0  
    cytoolz                   0.11.0           py39h2bbff1b_0  
    daal4py                   2021.5.0         py39h8cb3d55_0  
    dal                       2021.5.0           haa95532_796  
    dask                      2022.2.1           pyhd3eb1b0_0  
    dask-core                 2022.2.1           pyhd3eb1b0_0  
    dataclasses               0.8                pyh6d0b6a4_7  
    datashader                0.13.0             pyhd3eb1b0_1  
    datashape                 0.5.4            py39haa95532_1  
    debugpy                   1.5.1            py39hd77b12b_0  
    decorator                 5.1.1              pyhd3eb1b0_0  
    defusedxml                0.7.1              pyhd3eb1b0_0  
    diff-match-patch          20200713           pyhd3eb1b0_0  
    dill                      0.3.5.1                  pypi_0    pypi
    distributed               2022.2.1           pyhd3eb1b0_0  
    docutils                  0.17.1           py39haa95532_1  
    entrypoints               0.4              py39haa95532_0  
    et_xmlfile                1.1.0            py39haa95532_0  
    executing                 0.8.3              pyhd3eb1b0_0  
    filelock                  3.6.0              pyhd3eb1b0_0  
    flake8                    3.9.2              pyhd3eb1b0_0  
    flask                     1.1.2              pyhd3eb1b0_0  
    fonttools                 4.25.0             pyhd3eb1b0_0  
    freetype                  2.10.4               hd328e21_0  
    frozenlist                1.2.0            py39h2bbff1b_0  
    fsspec                    2022.2.0           pyhd3eb1b0_0  
    future                    0.18.2           py39haa95532_1  
    gensim                    4.1.2            py39hd77b12b_0  
    giflib                    5.2.1                h62dcd97_0  
    glob2                     0.7                pyhd3eb1b0_0  
    google-api-core           1.25.1             pyhd3eb1b0_0  
    google-auth               1.33.0             pyhd3eb1b0_0  
    google-cloud-core         1.7.1              pyhd3eb1b0_0  
    google-cloud-storage      1.31.0                     py_0  
    google-crc32c             1.1.2            py39h2bbff1b_0  
    google-resumable-media    1.3.1              pyhd3eb1b0_1  
    googleapis-common-protos  1.53.0           py39h2eaa2aa_0  
    greenlet                  1.1.1            py39hd77b12b_0  
    grpcio                    1.42.0           py39hc60d5dd_0  
    h5py                      3.6.0            py39h3de5c98_0  
    hdf5                      1.10.6               h7ebc959_0  
    heapdict                  1.0.1              pyhd3eb1b0_0  
    holoviews                 1.14.8             pyhd3eb1b0_0  
    hvplot                    0.7.3              pyhd3eb1b0_1  
    hyperlink                 21.0.0             pyhd3eb1b0_0  
    icc_rt                    2019.0.0             h0cc432a_1  
    icu                       58.2                 ha925a31_3  
    idna                      3.3                pyhd3eb1b0_0  
    imagecodecs               2021.8.26        py39ha1f97ea_0  
    imageio                   2.9.0              pyhd3eb1b0_0  
    imagesize                 1.3.0              pyhd3eb1b0_0  
    importlib-metadata        4.11.3           py39haa95532_0  
    importlib_metadata        4.11.3               hd3eb1b0_0  
    incremental               21.3.0             pyhd3eb1b0_0  
    inflection                0.5.1            py39haa95532_0  
    iniconfig                 1.1.1              pyhd3eb1b0_0  
    intake                    0.6.5              pyhd3eb1b0_0  
    intel-openmp              2021.4.0          haa95532_3556  
    intervaltree              3.1.0              pyhd3eb1b0_0  
    ipykernel                 6.9.1            py39haa95532_0  
    ipython                   8.2.0            py39haa95532_0  
    ipython_genutils          0.2.0              pyhd3eb1b0_1  
    ipywidgets                7.6.5              pyhd3eb1b0_1  
    isort                     5.9.3              pyhd3eb1b0_0  
    itemadapter               0.3.0              pyhd3eb1b0_0  
    itemloaders               1.0.4              pyhd3eb1b0_1  
    itsdangerous              2.0.1              pyhd3eb1b0_0  
    jdcal                     1.4.1              pyhd3eb1b0_0  
    jedi                      0.18.1           py39haa95532_1  
    jinja2                    2.11.3             pyhd3eb1b0_0  
    jinja2-time               0.2.0              pyhd3eb1b0_3  
    jmespath                  0.10.0             pyhd3eb1b0_0  
    joblib                    1.1.0              pyhd3eb1b0_0  
    jpeg                      9e                   h2bbff1b_0  
    jq                        1.6                  haa95532_1  
    json5                     0.9.6              pyhd3eb1b0_0  
    jsonschema                4.4.0            py39haa95532_0  
    jupyter                   1.0.0            py39haa95532_7  
    jupyter_client            6.1.12             pyhd3eb1b0_0  
    jupyter_console           6.4.0              pyhd3eb1b0_0  
    jupyter_core              4.9.2            py39haa95532_0  
    jupyter_server            1.13.5             pyhd3eb1b0_0  
    jupyterlab                3.3.2              pyhd3eb1b0_0  
    jupyterlab_pygments       0.1.2                      py_0  
    jupyterlab_server         2.10.3             pyhd3eb1b0_1  
    jupyterlab_widgets        1.0.0              pyhd3eb1b0_1  
    keyring                   23.4.0           py39haa95532_0  
    kiwisolver                1.3.2            py39hd77b12b_0  
    lazy-object-proxy         1.6.0            py39h2bbff1b_0  
    lcms2                     2.12                 h83e58a3_0  
    lerc                      3.0                  hd77b12b_0  
    libaec                    1.0.4                h33f27b4_1  
    libarchive                3.4.2                h5e25573_0  
    libcrc32c                 1.1.1                ha925a31_2  
    libcurl                   7.82.0               h86230a5_0  
    libdeflate                1.8                  h2bbff1b_5  
    libiconv                  1.16                 h2bbff1b_2  
    liblief                   0.11.5               hd77b12b_1  
    libpng                    1.6.37               h2a8f88b_0  
    libprotobuf               3.19.1               h23ce68f_0  
    libspatialindex           1.9.3                h6c2663c_0  
    libssh2                   1.10.0               hcd4344a_0  
    libtiff                   4.2.0                hd0e1b90_0  
    libwebp                   1.2.2                h2bbff1b_0  
    libxml2                   2.9.12               h0ad7f3c_0  
    libxslt                   1.1.34               he774522_0  
    libzopfli                 1.0.3                ha925a31_0  
    llvmlite                  0.38.0           py39h23ce68f_0  
    locket                    0.2.1            py39haa95532_2  
    lxml                      4.8.0            py39h1985fb9_0  
    lz4-c                     1.9.3                h2bbff1b_1  
    lzo                       2.10                 he774522_2  
    m2w64-libwinpthread-git   5.0.0.4634.697f757               2  
    markdown                  3.3.4            py39haa95532_0  
    markupsafe                2.0.1            py39h2bbff1b_0  
    matplotlib                3.5.1            py39haa95532_1  
    matplotlib-base           3.5.1            py39hd77b12b_1  
    matplotlib-inline         0.1.2              pyhd3eb1b0_2  
    mccabe                    0.6.1            py39haa95532_1  
    menuinst                  1.4.18           py39h59b6b97_0  
    mistune                   0.8.4           py39h2bbff1b_1000  
    mkl                       2021.4.0           haa95532_640  
    mkl-service               2.4.0            py39h2bbff1b_0  
    mkl_fft                   1.3.1            py39h277e83a_0  
    mkl_random                1.2.2            py39hf11a4ad_0  
    mock                      4.0.3              pyhd3eb1b0_0  
    mpmath                    1.2.1            py39haa95532_0  
    msgpack-python            1.0.2            py39h59b6b97_1  
    msys2-conda-epoch         20160418                      1  
    multidict                 5.1.0            py39h2bbff1b_2  
    multipledispatch          0.6.0            py39haa95532_0  
    munkres                   1.1.4                      py_0  
    mypy_extensions           0.4.3            py39haa95532_1  
    navigator-updater         0.2.1                    py39_1  
    nbclassic                 0.3.5              pyhd3eb1b0_0  
    nbclient                  0.5.13           py39haa95532_0  
    nbconvert                 6.4.4            py39haa95532_0  
    nbformat                  5.3.0            py39haa95532_0  
    nest-asyncio              1.5.5            py39haa95532_0  
    networkx                  2.7.1              pyhd3eb1b0_0  
    nltk                      3.7                pyhd3eb1b0_0  
    nose                      1.3.7           pyhd3eb1b0_1008  
    notebook                  6.4.8            py39haa95532_0  
    ntlm-auth                 1.5.0                    pypi_0    pypi
    numba                     0.55.1           py39hf11a4ad_0  
    numexpr                   2.8.1            py39hb80d3ca_0  
    numpy                     1.21.5           py39h7a0a035_1  
    numpy-base                1.21.5           py39hca35cd5_1  
    numpydoc                  1.2                pyhd3eb1b0_0  
    olefile                   0.46               pyhd3eb1b0_0  
    openjpeg                  2.4.0                h4fc8c34_0  
    openpyxl                  3.0.9              pyhd3eb1b0_0  
    openssl                   1.1.1n               h2bbff1b_0  
    packaging                 21.3               pyhd3eb1b0_0  
    pandas                    1.4.2            py39hd77b12b_0  
    pandocfilters             1.5.0              pyhd3eb1b0_0  
    panel                     0.13.0           py39haa95532_0  
    param                     1.12.0             pyhd3eb1b0_0  
    paramiko                  2.8.1              pyhd3eb1b0_0  
    parsel                    1.6.0            py39haa95532_0  
    parso                     0.8.3              pyhd3eb1b0_0  
    partd                     1.2.0              pyhd3eb1b0_1  
    pathspec                  0.7.0                      py_0  
    patsy                     0.5.2            py39haa95532_1  
    pbr                       5.10.0                   pypi_0    pypi
    pep8                      1.7.1            py39haa95532_0  
    pexpect                   4.8.0              pyhd3eb1b0_3  
    pickleshare               0.7.5           pyhd3eb1b0_1003  
    pillow                    9.0.1            py39hdc2b20a_0  
    pip                       21.2.4           py39haa95532_0  
    pkginfo                   1.8.2              pyhd3eb1b0_0  
    plotly                    5.6.0              pyhd3eb1b0_0  
    pluggy                    1.0.0            py39haa95532_1  
    ply                       3.11                     pypi_0    pypi
    powershell_shortcut       0.0.1                         3  
    poyo                      0.5.0              pyhd3eb1b0_0  
    prometheus_client         0.13.1             pyhd3eb1b0_0  
    prompt-toolkit            3.0.20             pyhd3eb1b0_0  
    prompt_toolkit            3.0.20               hd3eb1b0_0  
    protego                   0.1.16                     py_0  
    protobuf                  3.19.1           py39hd77b12b_0  
    psutil                    5.8.0            py39h2bbff1b_1  
    ptyprocess                0.7.0              pyhd3eb1b0_2  
    pure_eval                 0.2.2              pyhd3eb1b0_0  
    py                        1.11.0             pyhd3eb1b0_0  
    py-lief                   0.11.5           py39hd77b12b_1  
    pyasn1                    0.4.8              pyhd3eb1b0_0  
    pyasn1-modules            0.2.8                      py_0  
    pycodestyle               2.7.0              pyhd3eb1b0_0  
    pycosat                   0.6.3            py39h2bbff1b_0  
    pycparser                 2.21               pyhd3eb1b0_0  
    pyct                      0.4.6            py39haa95532_0  
    pycurl                    7.44.1           py39hcd4344a_1  
    pydispatcher              2.0.5            py39haa95532_2  
    pydocstyle                6.1.1              pyhd3eb1b0_0  
    pyerfa                    2.0.0            py39h2bbff1b_0  
    pyflakes                  2.3.1              pyhd3eb1b0_0  
    pygments                  2.11.2             pyhd3eb1b0_0  
    pyhamcrest                2.0.2              pyhd3eb1b0_2  
    pyjwt                     2.1.0            py39haa95532_0  
    pylatexenc                2.10                     pypi_0    pypi
    pylint                    2.9.6            py39haa95532_1  
    pyls-spyder               0.4.0              pyhd3eb1b0_0  
    pynacl                    1.4.0            py39hbd8134f_1  
    pyodbc                    4.0.32           py39hd77b12b_1  
    pyopenssl                 21.0.0             pyhd3eb1b0_1  
    pyparsing                 3.0.4              pyhd3eb1b0_0  
    pyqt                      5.9.2            py39hd77b12b_6  
    pyreadline                2.1              py39haa95532_1  
    pyrsistent                0.18.0           py39h196d8e1_0  
    pysocks                   1.7.1            py39haa95532_0  
    pytables                  3.6.1            py39h56d22b6_1  
    pytest                    7.1.1            py39haa95532_0  
    python                    3.9.12               h6244533_0  
    python-dateutil           2.8.2              pyhd3eb1b0_0  
    python-fastjsonschema     2.15.1             pyhd3eb1b0_0  
    python-libarchive-c       2.9                pyhd3eb1b0_1  
    python-lsp-black          1.0.0              pyhd3eb1b0_0  
    python-lsp-jsonrpc        1.0.0              pyhd3eb1b0_0  
    python-lsp-server         1.2.4              pyhd3eb1b0_0  
    python-slugify            5.0.2              pyhd3eb1b0_0  
    python-snappy             0.6.0            py39hd77b12b_3  
    pytz                      2021.3             pyhd3eb1b0_0  
    pyviz_comms               2.0.2              pyhd3eb1b0_0  
    pywavelets                1.3.0            py39h2bbff1b_0  
    pywin32                   302              py39h2bbff1b_2  
    pywin32-ctypes            0.2.0           py39haa95532_1000  
    pywinpty                  2.0.2            py39h5da7b33_0  
    pyyaml                    6.0              py39h2bbff1b_1  
    pyzmq                     22.3.0           py39hd77b12b_2  
    qdarkstyle                3.0.2              pyhd3eb1b0_0  
    qiskit                    0.37.2                   pypi_0    pypi
    qiskit-aer                0.10.4                   pypi_0    pypi
    qiskit-ibmq-provider      0.19.2                   pypi_0    pypi
    qiskit-terra              0.21.2                   pypi_0    pypi
    qstylizer                 0.1.10             pyhd3eb1b0_0  
    qt                        5.9.7            vc14h73c81de_0  
    qtawesome                 1.0.3              pyhd3eb1b0_0  
    qtconsole                 5.3.0              pyhd3eb1b0_0  
    qtpy                      2.0.1              pyhd3eb1b0_0  
    queuelib                  1.5.0            py39haa95532_0  
    regex                     2022.3.15        py39h2bbff1b_0  
    requests                  2.27.1             pyhd3eb1b0_0  
    requests-file             1.5.1              pyhd3eb1b0_0  
    requests-ntlm             1.1.0                    pypi_0    pypi
    retworkx                  0.11.0                   pypi_0    pypi
    rope                      0.22.0             pyhd3eb1b0_0  
    rsa                       4.7.2              pyhd3eb1b0_1  
    rtree                     0.9.7            py39h2eaa2aa_1  
    ruamel_yaml               0.15.100         py39h2bbff1b_0  
    s3transfer                0.5.0              pyhd3eb1b0_0  
    scikit-image              0.19.2           py39hf11a4ad_0  
    scikit-learn              1.0.2            py39hf11a4ad_1  
    scikit-learn-intelex      2021.5.0         py39haa95532_0  
    scipy                     1.7.3            py39h0a974cb_0  
    scrapy                    2.6.1            py39haa95532_0  
    seaborn                   0.11.2             pyhd3eb1b0_0  
    send2trash                1.8.0              pyhd3eb1b0_1  
    service_identity          18.1.0             pyhd3eb1b0_1  
    setuptools                61.2.0           py39haa95532_0  
    sip                       4.19.13          py39hd77b12b_0  
    six                       1.16.0             pyhd3eb1b0_1  
    smart_open                5.1.0              pyhd3eb1b0_0  
    snappy                    1.1.9                h6c2663c_0  
    sniffio                   1.2.0            py39haa95532_1  
    snowballstemmer           2.2.0              pyhd3eb1b0_0  
    sortedcollections         2.1.0              pyhd3eb1b0_0  
    sortedcontainers          2.4.0              pyhd3eb1b0_0  
    soupsieve                 2.3.1              pyhd3eb1b0_0  
    sphinx                    4.4.0              pyhd3eb1b0_0  
    sphinxcontrib-applehelp   1.0.2              pyhd3eb1b0_0  
    sphinxcontrib-devhelp     1.0.2              pyhd3eb1b0_0  
    sphinxcontrib-htmlhelp    2.0.0              pyhd3eb1b0_0  
    sphinxcontrib-jsmath      1.0.1              pyhd3eb1b0_0  
    sphinxcontrib-qthelp      1.0.3              pyhd3eb1b0_0  
    sphinxcontrib-serializinghtml 1.1.5              pyhd3eb1b0_0  
    spyder                    5.1.5            py39haa95532_1  
    spyder-kernels            2.1.3            py39haa95532_0  
    sqlalchemy                1.4.32           py39h2bbff1b_0  
    sqlite                    3.38.2               h2bbff1b_0  
    stack_data                0.2.0              pyhd3eb1b0_0  
    statsmodels               0.13.2           py39h2bbff1b_0  
    stevedore                 4.0.0                    pypi_0    pypi
    sympy                     1.10.1           py39haa95532_0  
    tabulate                  0.8.9            py39haa95532_0  
    tbb                       2021.5.0             h59b6b97_0  
    tbb4py                    2021.5.0         py39h59b6b97_0  
    tblib                     1.7.0              pyhd3eb1b0_0  
    tenacity                  8.0.1            py39haa95532_0  
    terminado                 0.13.1           py39haa95532_0  
    testpath                  0.5.0              pyhd3eb1b0_0  
    text-unidec
</code></pre>
",qiskit transpile NameError,<qiskit><programming>,1,5,,,"qiskit transpile NameError <p>I am a beginner in Quantum Computing programing and I need HELP.
I do not know why the Python or Qiskit does not recognize the &quot;transpile&quot; command? For example,</p>
<pre><code>from qiskit import (
    QuantumRegister,
    ClassicalRegister,
    QuantumCircuit,
    Aer,
    transpile,
)

simulator = Aer.get_backend('aer_simulator')

qreg = QuantumRegister(2, 'q0') # greg is filled with two qubits
creg = ClassicalRegister(2, 'c0') # creg is filled with two classical bits

cir = QuantumCircuit(qreg,creg) # we put registers qreg and creg together to make our circuit, called entangled

cir.h(0) # apply the Hadamard gate to the first qubit
cir.cx(0,1) # apply the CNOT gate with the first as the control and the second qubit as the target

cir.measure(0,0)
cir.measure(1,1)

cir=transpile(cir,simulator)
</code></pre>
<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

Input In [1], in &lt;cell line: 1&gt;()
----&gt; 1 cir=transpile(cir,simulator)
    

NameError: name 'transpile' is not defined
</code></pre>
<p>I am using:</p>
<ul>
<li>Qiskit Version 0.21.2</li>
<li>Python Version 3.9.12</li>
</ul>
<p>In the case the question cannot be answered by this group can you direct me to someone who can help me.</p>
<p>Thank you in advance for your consideration.</p>
<p>Full <code>conda list</code>:</p>
<pre><code>    # packages in environment at C:\Users\Sirob\anaconda3:
    Note: you may need to restart the kernel to use updated packages.
    
    #
    # Name                    Version                   Build  Channel
    _ipyw_jlab_nb_ext_conf    0.1.0            py39haa95532_0  
    aiohttp                   3.8.1            py39h2bbff1b_1  
    aiosignal                 1.2.0              pyhd3eb1b0_0  
    alabaster                 0.7.12             pyhd3eb1b0_0  
    anaconda                  2022.05                  py39_0  
    anaconda-client           1.9.0            py39haa95532_0  
    anaconda-navigator        2.2.0            py39haa95532_0  
    anaconda-project          0.10.2             pyhd3eb1b0_0  
    anyio                     3.5.0            py39haa95532_0  
    appdirs                   1.4.4              pyhd3eb1b0_0  
    argon2-cffi               21.3.0             pyhd3eb1b0_0  
    argon2-cffi-bindings      21.2.0           py39h2bbff1b_0  
    arrow                     1.2.2              pyhd3eb1b0_0  
    astroid                   2.6.6            py39haa95532_0  
    astropy                   5.0.4            py39h080aedc_0  
    asttokens                 2.0.5              pyhd3eb1b0_0  
    async-timeout             4.0.1              pyhd3eb1b0_0  
    atomicwrites              1.4.0                      py_0  
    attrs                     21.4.0             pyhd3eb1b0_0  
    automat                   20.2.0                     py_0  
    autopep8                  1.6.0              pyhd3eb1b0_0  
    babel                     2.9.1              pyhd3eb1b0_0  
    backcall                  0.2.0              pyhd3eb1b0_0  
    backports                 1.1                pyhd3eb1b0_0  
    backports.functools_lru_cache 1.6.4              pyhd3eb1b0_0  
    backports.tempfile        1.0                pyhd3eb1b0_1  
    backports.weakref         1.0.post1                  py_1  
    bcrypt                    3.2.0            py39h196d8e1_0  
    beautifulsoup4            4.11.1           py39haa95532_0  
    binaryornot               0.4.4              pyhd3eb1b0_1  
    bitarray                  2.4.1            py39h2bbff1b_0  
    bkcharts                  0.2              py39haa95532_0  
    black                     19.10b0                    py_0  
    blas                      1.0                         mkl  
    bleach                    4.1.0              pyhd3eb1b0_0  
    blosc                     1.21.0               h19a0ad4_0  
    bokeh                     2.4.2            py39haa95532_0  
    boto3                     1.21.32            pyhd3eb1b0_0  
    botocore                  1.24.32            pyhd3eb1b0_0  
    bottleneck                1.3.4            py39h080aedc_0  
    brotli                    1.0.9                ha925a31_2  
    brotlipy                  0.7.0           py39h2bbff1b_1003  
    bzip2                     1.0.8                he774522_0  
    ca-certificates           2022.3.29            haa95532_1  
    cachetools                4.2.2              pyhd3eb1b0_0  
    certifi                   2021.10.8        py39haa95532_2  
    cffi                      1.15.0           py39h2bbff1b_1  
    cfitsio                   3.470                he774522_6  
    chardet                   4.0.0           py39haa95532_1003  
    charls                    2.2.0                h6c2663c_0  
    charset-normalizer        2.0.4              pyhd3eb1b0_0  
    click                     8.0.4            py39haa95532_0  
    cloudpickle               2.0.0              pyhd3eb1b0_0  
    clyent                    1.2.2            py39haa95532_1  
    colorama                  0.4.4              pyhd3eb1b0_0  
    colorcet                  2.0.6              pyhd3eb1b0_0  
    comtypes                  1.1.10          py39haa95532_1002  
    conda                     4.14.0           py39haa95532_0  
    conda-build               3.21.8           py39haa95532_2  
    conda-content-trust       0.1.1              pyhd3eb1b0_0  
    conda-env                 2.6.0                haa95532_1  
    conda-pack                0.6.0              pyhd3eb1b0_0  
    conda-package-handling    1.8.1            py39h8cc25b3_0  
    conda-repo-cli            1.0.4              pyhd3eb1b0_0  
    conda-token               0.3.0              pyhd3eb1b0_0  
    conda-verify              3.4.2                      py_1  
    console_shortcut          0.1.1                         4  
    constantly                15.1.0             pyh2b92418_0  
    cookiecutter              1.7.3              pyhd3eb1b0_0  
    cryptography              3.4.8            py39h71e12ea_0  
    cssselect                 1.1.0              pyhd3eb1b0_0  
    curl                      7.82.0               h2bbff1b_0  
    cycler                    0.11.0             pyhd3eb1b0_0  
    cython                    0.29.28          py39hd77b12b_0  
    cytoolz                   0.11.0           py39h2bbff1b_0  
    daal4py                   2021.5.0         py39h8cb3d55_0  
    dal                       2021.5.0           haa95532_796  
    dask                      2022.2.1           pyhd3eb1b0_0  
    dask-core                 2022.2.1           pyhd3eb1b0_0  
    dataclasses               0.8                pyh6d0b6a4_7  
    datashader                0.13.0             pyhd3eb1b0_1  
    datashape                 0.5.4            py39haa95532_1  
    debugpy                   1.5.1            py39hd77b12b_0  
    decorator                 5.1.1              pyhd3eb1b0_0  
    defusedxml                0.7.1              pyhd3eb1b0_0  
    diff-match-patch          20200713           pyhd3eb1b0_0  
    dill                      0.3.5.1                  pypi_0    pypi
    distributed               2022.2.1           pyhd3eb1b0_0  
    docutils                  0.17.1           py39haa95532_1  
    entrypoints               0.4              py39haa95532_0  
    et_xmlfile                1.1.0            py39haa95532_0  
    executing                 0.8.3              pyhd3eb1b0_0  
    filelock                  3.6.0              pyhd3eb1b0_0  
    flake8                    3.9.2              pyhd3eb1b0_0  
    flask                     1.1.2              pyhd3eb1b0_0  
    fonttools                 4.25.0             pyhd3eb1b0_0  
    freetype                  2.10.4               hd328e21_0  
    frozenlist                1.2.0            py39h2bbff1b_0  
    fsspec                    2022.2.0           pyhd3eb1b0_0  
    future                    0.18.2           py39haa95532_1  
    gensim                    4.1.2            py39hd77b12b_0  
    giflib                    5.2.1                h62dcd97_0  
    glob2                     0.7                pyhd3eb1b0_0  
    google-api-core           1.25.1             pyhd3eb1b0_0  
    google-auth               1.33.0             pyhd3eb1b0_0  
    google-cloud-core         1.7.1              pyhd3eb1b0_0  
    google-cloud-storage      1.31.0                     py_0  
    google-crc32c             1.1.2            py39h2bbff1b_0  
    google-resumable-media    1.3.1              pyhd3eb1b0_1  
    googleapis-common-protos  1.53.0           py39h2eaa2aa_0  
    greenlet                  1.1.1            py39hd77b12b_0  
    grpcio                    1.42.0           py39hc60d5dd_0  
    h5py                      3.6.0            py39h3de5c98_0  
    hdf5                      1.10.6               h7ebc959_0  
    heapdict                  1.0.1              pyhd3eb1b0_0  
    holoviews                 1.14.8             pyhd3eb1b0_0  
    hvplot                    0.7.3              pyhd3eb1b0_1  
    hyperlink                 21.0.0             pyhd3eb1b0_0  
    icc_rt                    2019.0.0             h0cc432a_1  
    icu                       58.2                 ha925a31_3  
    idna                      3.3                pyhd3eb1b0_0  
    imagecodecs               2021.8.26        py39ha1f97ea_0  
    imageio                   2.9.0              pyhd3eb1b0_0  
    imagesize                 1.3.0              pyhd3eb1b0_0  
    importlib-metadata        4.11.3           py39haa95532_0  
    importlib_metadata        4.11.3               hd3eb1b0_0  
    incremental               21.3.0             pyhd3eb1b0_0  
    inflection                0.5.1            py39haa95532_0  
    iniconfig                 1.1.1              pyhd3eb1b0_0  
    intake                    0.6.5              pyhd3eb1b0_0  
    intel-openmp              2021.4.0          haa95532_3556  
    intervaltree              3.1.0              pyhd3eb1b0_0  
    ipykernel                 6.9.1            py39haa95532_0  
    ipython                   8.2.0            py39haa95532_0  
    ipython_genutils          0.2.0              pyhd3eb1b0_1  
    ipywidgets                7.6.5              pyhd3eb1b0_1  
    isort                     5.9.3              pyhd3eb1b0_0  
    itemadapter               0.3.0              pyhd3eb1b0_0  
    itemloaders               1.0.4              pyhd3eb1b0_1  
    itsdangerous              2.0.1              pyhd3eb1b0_0  
    jdcal                     1.4.1              pyhd3eb1b0_0  
    jedi                      0.18.1           py39haa95532_1  
    jinja2                    2.11.3             pyhd3eb1b0_0  
    jinja2-time               0.2.0              pyhd3eb1b0_3  
    jmespath                  0.10.0             pyhd3eb1b0_0  
    joblib                    1.1.0              pyhd3eb1b0_0  
    jpeg                      9e                   h2bbff1b_0  
    jq                        1.6                  haa95532_1  
    json5                     0.9.6              pyhd3eb1b0_0  
    jsonschema                4.4.0            py39haa95532_0  
    jupyter                   1.0.0            py39haa95532_7  
    jupyter_client            6.1.12             pyhd3eb1b0_0  
    jupyter_console           6.4.0              pyhd3eb1b0_0  
    jupyter_core              4.9.2            py39haa95532_0  
    jupyter_server            1.13.5             pyhd3eb1b0_0  
    jupyterlab                3.3.2              pyhd3eb1b0_0  
    jupyterlab_pygments       0.1.2                      py_0  
    jupyterlab_server         2.10.3             pyhd3eb1b0_1  
    jupyterlab_widgets        1.0.0              pyhd3eb1b0_1  
    keyring                   23.4.0           py39haa95532_0  
    kiwisolver                1.3.2            py39hd77b12b_0  
    lazy-object-proxy         1.6.0            py39h2bbff1b_0  
    lcms2                     2.12                 h83e58a3_0  
    lerc                      3.0                  hd77b12b_0  
    libaec                    1.0.4                h33f27b4_1  
    libarchive                3.4.2                h5e25573_0  
    libcrc32c                 1.1.1                ha925a31_2  
    libcurl                   7.82.0               h86230a5_0  
    libdeflate                1.8                  h2bbff1b_5  
    libiconv                  1.16                 h2bbff1b_2  
    liblief                   0.11.5               hd77b12b_1  
    libpng                    1.6.37               h2a8f88b_0  
    libprotobuf               3.19.1               h23ce68f_0  
    libspatialindex           1.9.3                h6c2663c_0  
    libssh2                   1.10.0               hcd4344a_0  
    libtiff                   4.2.0                hd0e1b90_0  
    libwebp                   1.2.2                h2bbff1b_0  
    libxml2                   2.9.12               h0ad7f3c_0  
    libxslt                   1.1.34               he774522_0  
    libzopfli                 1.0.3                ha925a31_0  
    llvmlite                  0.38.0           py39h23ce68f_0  
    locket                    0.2.1            py39haa95532_2  
    lxml                      4.8.0            py39h1985fb9_0  
    lz4-c                     1.9.3                h2bbff1b_1  
    lzo                       2.10                 he774522_2  
    m2w64-libwinpthread-git   5.0.0.4634.697f757               2  
    markdown                  3.3.4            py39haa95532_0  
    markupsafe                2.0.1            py39h2bbff1b_0  
    matplotlib                3.5.1            py39haa95532_1  
    matplotlib-base           3.5.1            py39hd77b12b_1  
    matplotlib-inline         0.1.2              pyhd3eb1b0_2  
    mccabe                    0.6.1            py39haa95532_1  
    menuinst                  1.4.18           py39h59b6b97_0  
    mistune                   0.8.4           py39h2bbff1b_1000  
    mkl                       2021.4.0           haa95532_640  
    mkl-service               2.4.0            py39h2bbff1b_0  
    mkl_fft                   1.3.1            py39h277e83a_0  
    mkl_random                1.2.2            py39hf11a4ad_0  
    mock                      4.0.3              pyhd3eb1b0_0  
    mpmath                    1.2.1            py39haa95532_0  
    msgpack-python            1.0.2            py39h59b6b97_1  
    msys2-conda-epoch         20160418                      1  
    multidict                 5.1.0            py39h2bbff1b_2  
    multipledispatch          0.6.0            py39haa95532_0  
    munkres                   1.1.4                      py_0  
    mypy_extensions           0.4.3            py39haa95532_1  
    navigator-updater         0.2.1                    py39_1  
    nbclassic                 0.3.5              pyhd3eb1b0_0  
    nbclient                  0.5.13           py39haa95532_0  
    nbconvert                 6.4.4            py39haa95532_0  
    nbformat                  5.3.0            py39haa95532_0  
    nest-asyncio              1.5.5            py39haa95532_0  
    networkx                  2.7.1              pyhd3eb1b0_0  
    nltk                      3.7                pyhd3eb1b0_0  
    nose                      1.3.7           pyhd3eb1b0_1008  
    notebook                  6.4.8            py39haa95532_0  
    ntlm-auth                 1.5.0                    pypi_0    pypi
    numba                     0.55.1           py39hf11a4ad_0  
    numexpr                   2.8.1            py39hb80d3ca_0  
    numpy                     1.21.5           py39h7a0a035_1  
    numpy-base                1.21.5           py39hca35cd5_1  
    numpydoc                  1.2                pyhd3eb1b0_0  
    olefile                   0.46               pyhd3eb1b0_0  
    openjpeg                  2.4.0                h4fc8c34_0  
    openpyxl                  3.0.9              pyhd3eb1b0_0  
    openssl                   1.1.1n               h2bbff1b_0  
    packaging                 21.3               pyhd3eb1b0_0  
    pandas                    1.4.2            py39hd77b12b_0  
    pandocfilters             1.5.0              pyhd3eb1b0_0  
    panel                     0.13.0           py39haa95532_0  
    param                     1.12.0             pyhd3eb1b0_0  
    paramiko                  2.8.1              pyhd3eb1b0_0  
    parsel                    1.6.0            py39haa95532_0  
    parso                     0.8.3              pyhd3eb1b0_0  
    partd                     1.2.0              pyhd3eb1b0_1  
    pathspec                  0.7.0                      py_0  
    patsy                     0.5.2            py39haa95532_1  
    pbr                       5.10.0                   pypi_0    pypi
    pep8                      1.7.1            py39haa95532_0  
    pexpect                   4.8.0              pyhd3eb1b0_3  
    pickleshare               0.7.5           pyhd3eb1b0_1003  
    pillow                    9.0.1            py39hdc2b20a_0  
    pip                       21.2.4           py39haa95532_0  
    pkginfo                   1.8.2              pyhd3eb1b0_0  
    plotly                    5.6.0              pyhd3eb1b0_0  
    pluggy                    1.0.0            py39haa95532_1  
    ply                       3.11                     pypi_0    pypi
    powershell_shortcut       0.0.1                         3  
    poyo                      0.5.0              pyhd3eb1b0_0  
    prometheus_client         0.13.1             pyhd3eb1b0_0  
    prompt-toolkit            3.0.20             pyhd3eb1b0_0  
    prompt_toolkit            3.0.20               hd3eb1b0_0  
    protego                   0.1.16                     py_0  
    protobuf                  3.19.1           py39hd77b12b_0  
    psutil                    5.8.0            py39h2bbff1b_1  
    ptyprocess                0.7.0              pyhd3eb1b0_2  
    pure_eval                 0.2.2              pyhd3eb1b0_0  
    py                        1.11.0             pyhd3eb1b0_0  
    py-lief                   0.11.5           py39hd77b12b_1  
    pyasn1                    0.4.8              pyhd3eb1b0_0  
    pyasn1-modules            0.2.8                      py_0  
    pycodestyle               2.7.0              pyhd3eb1b0_0  
    pycosat                   0.6.3            py39h2bbff1b_0  
    pycparser                 2.21               pyhd3eb1b0_0  
    pyct                      0.4.6            py39haa95532_0  
    pycurl                    7.44.1           py39hcd4344a_1  
    pydispatcher              2.0.5            py39haa95532_2  
    pydocstyle                6.1.1              pyhd3eb1b0_0  
    pyerfa                    2.0.0            py39h2bbff1b_0  
    pyflakes                  2.3.1              pyhd3eb1b0_0  
    pygments                  2.11.2             pyhd3eb1b0_0  
    pyhamcrest                2.0.2              pyhd3eb1b0_2  
    pyjwt                     2.1.0            py39haa95532_0  
    pylatexenc                2.10                     pypi_0    pypi
    pylint                    2.9.6            py39haa95532_1  
    pyls-spyder               0.4.0              pyhd3eb1b0_0  
    pynacl                    1.4.0            py39hbd8134f_1  
    pyodbc                    4.0.32           py39hd77b12b_1  
    pyopenssl                 21.0.0             pyhd3eb1b0_1  
    pyparsing                 3.0.4              pyhd3eb1b0_0  
    pyqt                      5.9.2            py39hd77b12b_6  
    pyreadline                2.1              py39haa95532_1  
    pyrsistent                0.18.0           py39h196d8e1_0  
    pysocks                   1.7.1            py39haa95532_0  
    pytables                  3.6.1            py39h56d22b6_1  
    pytest                    7.1.1            py39haa95532_0  
    python                    3.9.12               h6244533_0  
    python-dateutil           2.8.2              pyhd3eb1b0_0  
    python-fastjsonschema     2.15.1             pyhd3eb1b0_0  
    python-libarchive-c       2.9                pyhd3eb1b0_1  
    python-lsp-black          1.0.0              pyhd3eb1b0_0  
    python-lsp-jsonrpc        1.0.0              pyhd3eb1b0_0  
    python-lsp-server         1.2.4              pyhd3eb1b0_0  
    python-slugify            5.0.2              pyhd3eb1b0_0  
    python-snappy             0.6.0            py39hd77b12b_3  
    pytz                      2021.3             pyhd3eb1b0_0  
    pyviz_comms               2.0.2              pyhd3eb1b0_0  
    pywavelets                1.3.0            py39h2bbff1b_0  
    pywin32                   302              py39h2bbff1b_2  
    pywin32-ctypes            0.2.0           py39haa95532_1000  
    pywinpty                  2.0.2            py39h5da7b33_0  
    pyyaml                    6.0              py39h2bbff1b_1  
    pyzmq                     22.3.0           py39hd77b12b_2  
    qdarkstyle                3.0.2              pyhd3eb1b0_0  
    qiskit                    0.37.2                   pypi_0    pypi
    qiskit-aer                0.10.4                   pypi_0    pypi
    qiskit-ibmq-provider      0.19.2                   pypi_0    pypi
    qiskit-terra              0.21.2                   pypi_0    pypi
    qstylizer                 0.1.10             pyhd3eb1b0_0  
    qt                        5.9.7            vc14h73c81de_0  
    qtawesome                 1.0.3              pyhd3eb1b0_0  
    qtconsole                 5.3.0              pyhd3eb1b0_0  
    qtpy                      2.0.1              pyhd3eb1b0_0  
    queuelib                  1.5.0            py39haa95532_0  
    regex                     2022.3.15        py39h2bbff1b_0  
    requests                  2.27.1             pyhd3eb1b0_0  
    requests-file             1.5.1              pyhd3eb1b0_0  
    requests-ntlm             1.1.0                    pypi_0    pypi
    retworkx                  0.11.0                   pypi_0    pypi
    rope                      0.22.0             pyhd3eb1b0_0  
    rsa                       4.7.2              pyhd3eb1b0_1  
    rtree                     0.9.7            py39h2eaa2aa_1  
    ruamel_yaml               0.15.100         py39h2bbff1b_0  
    s3transfer                0.5.0              pyhd3eb1b0_0  
    scikit-image              0.19.2           py39hf11a4ad_0  
    scikit-learn              1.0.2            py39hf11a4ad_1  
    scikit-learn-intelex      2021.5.0         py39haa95532_0  
    scipy                     1.7.3            py39h0a974cb_0  
    scrapy                    2.6.1            py39haa95532_0  
    seaborn                   0.11.2             pyhd3eb1b0_0  
    send2trash                1.8.0              pyhd3eb1b0_1  
    service_identity          18.1.0             pyhd3eb1b0_1  
    setuptools                61.2.0           py39haa95532_0  
    sip                       4.19.13          py39hd77b12b_0  
    six                       1.16.0             pyhd3eb1b0_1  
    smart_open                5.1.0              pyhd3eb1b0_0  
    snappy                    1.1.9                h6c2663c_0  
    sniffio                   1.2.0            py39haa95532_1  
    snowballstemmer           2.2.0              pyhd3eb1b0_0  
    sortedcollections         2.1.0              pyhd3eb1b0_0  
    sortedcontainers          2.4.0              pyhd3eb1b0_0  
    soupsieve                 2.3.1              pyhd3eb1b0_0  
    sphinx                    4.4.0              pyhd3eb1b0_0  
    sphinxcontrib-applehelp   1.0.2              pyhd3eb1b0_0  
    sphinxcontrib-devhelp     1.0.2              pyhd3eb1b0_0  
    sphinxcontrib-htmlhelp    2.0.0              pyhd3eb1b0_0  
    sphinxcontrib-jsmath      1.0.1              pyhd3eb1b0_0  
    sphinxcontrib-qthelp      1.0.3              pyhd3eb1b0_0  
    sphinxcontrib-serializinghtml 1.1.5              pyhd3eb1b0_0  
    spyder                    5.1.5            py39haa95532_1  
    spyder-kernels            2.1.3            py39haa95532_0  
    sqlalchemy                1.4.32           py39h2bbff1b_0  
    sqlite                    3.38.2               h2bbff1b_0  
    stack_data                0.2.0              pyhd3eb1b0_0  
    statsmodels               0.13.2           py39h2bbff1b_0  
    stevedore                 4.0.0                    pypi_0    pypi
    sympy                     1.10.1           py39haa95532_0  
    tabulate                  0.8.9            py39haa95532_0  
    tbb                       2021.5.0             h59b6b97_0  
    tbb4py                    2021.5.0         py39h59b6b97_0  
    tblib                     1.7.0              pyhd3eb1b0_0  
    tenacity                  8.0.1            py39haa95532_0  
    terminado                 0.13.1           py39haa95532_0  
    testpath                  0.5.0              pyhd3eb1b0_0  
    text-unidec
</code></pre>
",qc,qiskit transpile nameerror p beginner quantum computing programing need help know python qiskit recognize quot transpile quot command example pre code qiskit import quantumregister classicalregister quantumcircuit aer transpile simulator qreg quantumregister 2 greg filled two qubits creg classicalregister 2 creg filled two classical bits cir quantumcircuit qreg creg put registers qreg creg together make circuit called entangled 0 apply hadamard gate first qubit apply cnot gate first control second qubit target cir simulator pre code nameerror traceback recent call last input 1 lt cell line 1 gt gt 1 cir simulator nameerror name defined p using ul li qiskit version li python version p case question answered group direct someone help p thank advance p full code conda list pre code packages environment c note may need restart kernel use updated packages name version build channel aiohttp aiosignal alabaster anaconda anyio appdirs arrow astroid astropy asttokens atomicwrites attrs automat autopep8 babel backcall backports bcrypt beautifulsoup4 binaryornot bitarray bkcharts black blas mkl bleach blosc bokeh boto3 botocore bottleneck brotli brotlipy bzip2 cachetools certifi cffi cfitsio chardet charls click cloudpickle clyent colorama colorcet comtypes conda 4 constantly cookiecutter cryptography cssselect curl cycler cython cytoolz daal4py dal dask dataclasses datashader datashape debugpy decorator defusedxml 20200713 dill pypi distributed docutils entrypoints executing filelock flake8 flask fonttools freetype frozenlist fsspec future gensim giflib glob2 greenlet grpcio h5py hdf5 heapdict holoviews hvplot hyperlink icu idna imagecodecs imageio imagesize incremental inflection iniconfig intake intervaltree ipykernel ipython ipywidgets isort itemadapter itemloaders itsdangerous jdcal jedi jinja2 jmespath joblib jpeg 9e jq json5 jsonschema jupyter jupyterlab keyring kiwisolver lcms2 lerc libaec libarchive libcrc32c libcurl libdeflate libiconv liblief libpng libprotobuf libspatialindex libssh2 libtiff libwebp libxml2 libxslt libzopfli llvmlite locket lxml lzo 2 markdown markupsafe matplotlib mccabe menuinst mistune mkl mock mpmath 20160418 1 multidict multipledispatch munkres nbclassic nbclient nbconvert nbformat networkx nltk nose notebook pypi numba numexpr numpy numpydoc olefile openjpeg openpyxl openssl packaging pandas pandocfilters panel param paramiko parsel parso partd pathspec patsy pbr pypi pep8 pexpect pickleshare pillow pip pkginfo plotly pluggy ply pypi 3 poyo protego protobuf psutil ptyprocess py pyasn1 pycodestyle pycosat pycparser pyct pycurl pydispatcher pydocstyle pyerfa pyflakes pygments pyhamcrest pyjwt pylatexenc pypi pylint pynacl pyodbc pyopenssl pyparsing pyqt pyreadline pyrsistent pysocks pytables pytest python pytz pywavelets pywin32 302 pywinpty pyyaml pyzmq qdarkstyle qiskit pypi pypi pypi pypi qstylizer qt qtawesome qtconsole qtpy queuelib regex requests pypi retworkx pypi rope rsa rtree s3transfer scipy scrapy seaborn send2trash setuptools sip six snappy sniffio snowballstemmer sortedcollections sortedcontainers soupsieve sphinx spyder sqlalchemy sqlite statsmodels stevedore pypi sympy tabulate tbb tbb4py tblib tenacity terminado testpath,"[(0, 0.36189485), (2, 0.103323825), (4, 0.019770076), (7, 0.03364099), (8, 0.08702261), (9, 0.028462859), (12, 0.023249006), (14, 0.25228575), (18, 0.07931166), (19, 0.010456408)]"
28049,28063.0,2022-09-04 02:26:38,0,172,"<p>I need to rewrite a following circuit from <a href=""https://quantumai.google/cirq"" rel=""nofollow noreferrer"">Cirq</a> to <a href=""https://qiskit.org/"" rel=""nofollow noreferrer"">Qiskit</a> with <span class=""math-container"">$2\varphi = \pi$</span>.</p>
<p><a href=""https://i.sstatic.net/MqJQM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MqJQM.png"" alt=""enter image description here"" /></a></p>
<p>It's a circuit representing an initial state for VQE calculation. Considering, that <code>qiskit_nature</code> considers a different ordering of spin-orbitals (first all spin-up, then all spin-down), I've rewritten the circuit like this (switching 1st and 2nd qubit, indexing from 0):</p>
<p><a href=""https://i.sstatic.net/2QMAi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2QMAi.png"" alt=""enter image description here"" /></a></p>
<p>In both cases the statevector equals to</p>
<pre><code>array([ 0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ,  0.70710678, -0.        ,  0.        , -0.70710678,
        0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ])
</code></pre>
<p>, i.e.</p>
<p><span class=""math-container"">$$
\left|\psi\right&gt; = \frac{1}{\sqrt{2}}\left| 0110 \right&gt; - \frac{1}{\sqrt{2}}\left| 1001 \right&gt;.
$$</span></p>
<p>In Cirq, the total angular momentum <span class=""math-container"">$\left&lt;\psi \middle| S^2 \middle| \psi \right&gt; = 0$</span>, i.e. the state should be singlet. But when I try the same in qiskit with the help of <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html"" rel=""nofollow noreferrer"">second_q_ops()</a>, I'm getting <code>1.999999...</code>.</p>
<p>Why does my result differ?</p>
<hr />
<h3>My Code</h3>
<pre><code>#!/usr/bin/env python3
import numpy as np
import qiskit_nature
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.providers.aer import Aer
from qiskit.quantum_info import Statevector
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureMoleculeDriver, ElectronicStructureDriverType
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer

if __name__ == '__main__':

    qiskit_nature.settings.dict_aux_operators = True
    backend = Aer.get_backend('statevector_simulator')

    geometry = [('N', [0.000000000000, 0.000000000000, 0.000000000000]),
                ('C', [0.000000000000, 0.000000000000, 1.498047000000]),
                ('H', [0.000000000000, -0.938765985000, 2.004775984000]),
                ('H', [0.000000000000, 0.938765985000, 2.004775984000]),
                ('H', [-0.744681452, -0.131307432, -0.634501434])]

    # Obtaining ground state
    driver = ElectronicStructureMoleculeDriver(Molecule(geometry),
                                               basis=&quot;sto3g&quot;,
                                               driver_type=ElectronicStructureDriverType.PSI4)

    as_transformer = ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)
    es_problem = ElectronicStructureProblem(driver, transformers=[as_transformer])
    converter = QubitConverter(JordanWignerMapper())

    # Create circuit
    qreg_q = QuantumRegister(4, 'q')
    circuit = QuantumCircuit(qreg_q)

    circuit.x(qreg_q[2])
    circuit.ry(np.pi, qreg_q[0])
    circuit.ch(qreg_q[0], qreg_q[3])
    circuit.cx(qreg_q[3], qreg_q[2])
    circuit.cx(qreg_q[3], qreg_q[0])
    circuit.cx(qreg_q[0], qreg_q[1])
    circuit.z(qreg_q[3])
    circuit.x(qreg_q[0])
    print(f'Circuit:\n{circuit}')

    statevec = Statevector(circuit).data
    print(f'Statevector:\n{statevec}')

    # Obtain S^2 operator
    ss_op = es_problem.second_q_ops()['AngularMomentum']
    print(f'S^2 operator:\n{ss_op}')

    print(f'&lt;psi|S^2|psi&gt; = {statevec @ converter.convert(ss_op).to_matrix() @ statevec}')
</code></pre>
<h3>The Output</h3>
<pre><code>Circuit:
     ┌───────┐          ┌───┐     ┌───┐
q_0: ┤ Ry(π) ├──■───────┤ X ├──■──┤ X ├
     └───────┘  │       └─┬─┘┌─┴─┐└───┘
q_1: ───────────┼─────────┼──┤ X ├─────
       ┌───┐    │  ┌───┐  │  └───┘     
q_2: ──┤ X ├────┼──┤ X ├──┼────────────
       └───┘  ┌─┴─┐└─┬─┘  │  ┌───┐     
q_3: ─────────┤ H ├──■────■──┤ Z ├─────
              └───┘          └───┘     
Statevector:
[ 0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  6.12323400e-17+0.j
  7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
 -7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j]
S^2 operator:
Fermionic Operator
register length=4, number terms=12
  (0.75+0j) * ( +_0 -_0 )
+ (0.75+0j) * ( +_1 -_1 )
+ (0.75+0j) * ( +_2 -_2 )
+ (0.75+0j) * ( +_3 -_3 )
+ (0.5+0j) * ( +_0 -_0 +_1 -_1 )
+ (-1.5+0j) * ( +_0 -_0 +_2 -_2 )
+ (-0.5+0j) * ( +_0 -_0 + ...
&lt;psi|S^2|psi&gt; = (1.9999999999999996+0j)
</code></pre>
",$S^2$ expectation value of a circuit seems wrong,<qiskit><cirq><angular-momentum>,1,0,,,"$S^2$ expectation value of a circuit seems wrong <p>I need to rewrite a following circuit from <a href=""https://quantumai.google/cirq"" rel=""nofollow noreferrer"">Cirq</a> to <a href=""https://qiskit.org/"" rel=""nofollow noreferrer"">Qiskit</a> with <span class=""math-container"">$2\varphi = \pi$</span>.</p>
<p><a href=""https://i.sstatic.net/MqJQM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MqJQM.png"" alt=""enter image description here"" /></a></p>
<p>It's a circuit representing an initial state for VQE calculation. Considering, that <code>qiskit_nature</code> considers a different ordering of spin-orbitals (first all spin-up, then all spin-down), I've rewritten the circuit like this (switching 1st and 2nd qubit, indexing from 0):</p>
<p><a href=""https://i.sstatic.net/2QMAi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2QMAi.png"" alt=""enter image description here"" /></a></p>
<p>In both cases the statevector equals to</p>
<pre><code>array([ 0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ,  0.70710678, -0.        ,  0.        , -0.70710678,
        0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ])
</code></pre>
<p>, i.e.</p>
<p><span class=""math-container"">$$
\left|\psi\right&gt; = \frac{1}{\sqrt{2}}\left| 0110 \right&gt; - \frac{1}{\sqrt{2}}\left| 1001 \right&gt;.
$$</span></p>
<p>In Cirq, the total angular momentum <span class=""math-container"">$\left&lt;\psi \middle| S^2 \middle| \psi \right&gt; = 0$</span>, i.e. the state should be singlet. But when I try the same in qiskit with the help of <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html"" rel=""nofollow noreferrer"">second_q_ops()</a>, I'm getting <code>1.999999...</code>.</p>
<p>Why does my result differ?</p>
<hr />
<h3>My Code</h3>
<pre><code>#!/usr/bin/env python3
import numpy as np
import qiskit_nature
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.providers.aer import Aer
from qiskit.quantum_info import Statevector
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureMoleculeDriver, ElectronicStructureDriverType
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer

if __name__ == '__main__':

    qiskit_nature.settings.dict_aux_operators = True
    backend = Aer.get_backend('statevector_simulator')

    geometry = [('N', [0.000000000000, 0.000000000000, 0.000000000000]),
                ('C', [0.000000000000, 0.000000000000, 1.498047000000]),
                ('H', [0.000000000000, -0.938765985000, 2.004775984000]),
                ('H', [0.000000000000, 0.938765985000, 2.004775984000]),
                ('H', [-0.744681452, -0.131307432, -0.634501434])]

    # Obtaining ground state
    driver = ElectronicStructureMoleculeDriver(Molecule(geometry),
                                               basis=&quot;sto3g&quot;,
                                               driver_type=ElectronicStructureDriverType.PSI4)

    as_transformer = ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)
    es_problem = ElectronicStructureProblem(driver, transformers=[as_transformer])
    converter = QubitConverter(JordanWignerMapper())

    # Create circuit
    qreg_q = QuantumRegister(4, 'q')
    circuit = QuantumCircuit(qreg_q)

    circuit.x(qreg_q[2])
    circuit.ry(np.pi, qreg_q[0])
    circuit.ch(qreg_q[0], qreg_q[3])
    circuit.cx(qreg_q[3], qreg_q[2])
    circuit.cx(qreg_q[3], qreg_q[0])
    circuit.cx(qreg_q[0], qreg_q[1])
    circuit.z(qreg_q[3])
    circuit.x(qreg_q[0])
    print(f'Circuit:\n{circuit}')

    statevec = Statevector(circuit).data
    print(f'Statevector:\n{statevec}')

    # Obtain S^2 operator
    ss_op = es_problem.second_q_ops()['AngularMomentum']
    print(f'S^2 operator:\n{ss_op}')

    print(f'&lt;psi|S^2|psi&gt; = {statevec @ converter.convert(ss_op).to_matrix() @ statevec}')
</code></pre>
<h3>The Output</h3>
<pre><code>Circuit:
     ┌───────┐          ┌───┐     ┌───┐
q_0: ┤ Ry(π) ├──■───────┤ X ├──■──┤ X ├
     └───────┘  │       └─┬─┘┌─┴─┐└───┘
q_1: ───────────┼─────────┼──┤ X ├─────
       ┌───┐    │  ┌───┐  │  └───┘     
q_2: ──┤ X ├────┼──┤ X ├──┼────────────
       └───┘  ┌─┴─┐└─┬─┘  │  ┌───┐     
q_3: ─────────┤ H ├──■────■──┤ Z ├─────
              └───┘          └───┘     
Statevector:
[ 0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  6.12323400e-17+0.j
  7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
 -7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j]
S^2 operator:
Fermionic Operator
register length=4, number terms=12
  (0.75+0j) * ( +_0 -_0 )
+ (0.75+0j) * ( +_1 -_1 )
+ (0.75+0j) * ( +_2 -_2 )
+ (0.75+0j) * ( +_3 -_3 )
+ (0.5+0j) * ( +_0 -_0 +_1 -_1 )
+ (-1.5+0j) * ( +_0 -_0 +_2 -_2 )
+ (-0.5+0j) * ( +_0 -_0 + ...
&lt;psi|S^2|psi&gt; = (1.9999999999999996+0j)
</code></pre>
",qc,expectation value circuit seems wrong p need rewrite following circuit https nofollow noreferrer cirq https nofollow noreferrer qiskit span p https nofollow noreferrer img https enter image description p circuit representing initial state vqe calculation considering code considers different ordering first rewritten circuit like switching 1st 2nd qubit indexing 0 p https nofollow noreferrer img https enter image description p cases statevector equals pre code array p p span gt 1 2 0110 gt 1 2 1001 gt p cirq total angular momentum span lt gt 0 state singlet try qiskit help https nofollow noreferrer getting code p result differ hr h3 code pre code python3 import numpy np import qiskit import quantumcircuit quantumregister import aer import statevector import qubitconverter import molecule import electronicstructuremoleculedriver electronicstructuredrivertype import jordanwignermapper import electronicstructureproblem import activespacetransformer true backend geometry c h h h obtaining ground state driver electronicstructuremoleculedriver molecule geometry quot sto3g quot activespacetransformer electronicstructureproblem driver converter qubitconverter jordanwignermapper create circuit quantumregister 4 q circuit quantumcircuit 2 0 0 3 3 2 3 0 0 1 3 0 print circuit statevec statevector circuit print statevec obtain operator print operator print f lt gt statevec statevec h3 output pre code circuit ry π x x x x x h z statevector operator fermionic operator register number lt gt,"[(0, 0.4354121), (2, 0.08138322), (3, 0.03835698), (4, 0.23128848), (10, 0.041283187), (12, 0.010552346), (13, 0.017728971), (14, 0.015760144), (17, 0.03241723), (18, 0.08047333)]"
28071,,2022-09-05 21:17:36,0,766,"<p>This seems like a basic operation, but I can't see how it's done in qiskit.</p>
<p>The solution here
<a href=""https://quantumcomputing.stackexchange.com/questions/20688/measuring-tensor-products-of-pauli-operators"">Measuring tensor products of Pauli operators</a> doesn't work anymore.</p>
<p>I get an error &quot;qiskit has no attribute 'aqua'&quot;.</p>
<p>Stim has MPP command that does the job, but I'm working with qiskit on this circuit.</p>
",qiskit : how to measure multiple pauli strings,<qiskit><measurement><stim>,1,0,,,"qiskit : how to measure multiple pauli strings <p>This seems like a basic operation, but I can't see how it's done in qiskit.</p>
<p>The solution here
<a href=""https://quantumcomputing.stackexchange.com/questions/20688/measuring-tensor-products-of-pauli-operators"">Measuring tensor products of Pauli operators</a> doesn't work anymore.</p>
<p>I get an error &quot;qiskit has no attribute 'aqua'&quot;.</p>
<p>Stim has MPP command that does the job, but I'm working with qiskit on this circuit.</p>
",qc,qiskit measure multiple pauli strings p seems like basic operation ca see done p solution https measuring tensor products pauli operators work p get error quot qiskit attribute quot p stim mpp command job working qiskit,"[(4, 0.04781435), (5, 0.16678827), (12, 0.02835795), (14, 0.68442833), (19, 0.068466425)]"
28221,,2022-09-19 08:25:15,0,258,"<p>This link
<a href=""https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.kernels.QuantumKernel.construct_circuit.html#qiskit_machine_learning.kernels.QuantumKernel.construct_circuit"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.kernels.QuantumKernel.construct_circuit.html#qiskit_machine_learning.kernels.QuantumKernel.construct_circuit</a>
tells us that the circuit can be built automatically, but an error was found after using it, how can I solve it?</p>
<pre><code>from qiskit import BasicAer
from qiskit.circuit.library import ZZFeatureMap
from qiskit.utils import QuantumInstance, algorithm_globals
from qiskit_machine_learning.algorithms import QSVC
from qiskit_machine_learning.kernels import QuantumKernel
seed = 12345
X_data = np.array([[1,2,7,12],[3,7,7,11],[12,18,7,90]])
Y_data = np.array([[1,12,7,22],[3,71,7,111],[12,118,7,90]])
y_train = np.array([12,5,9])
print(X_data.shape[0],X_data.shape[1])
qbits = X_data.shape[0]
ansatz0 = ZZFeatureMap(feature_dimension=qbits, insert_barriers = True, name = 'Quantum Kernel',reps=1, parameter_prefix='x')
ansatz1 = ZZFeatureMap(feature_dimension=qbits, insert_barriers = True, name = 'Quantum Kernel',reps=1, parameter_prefix='y').inverse()
qc = ansatz0.compose(ansatz1)
qc.draw('mpl')
QI = QuantumInstance(BasicAer.get_backend(&quot;qasm_simulator&quot;), shots=1024, seed_simulator=seed, seed_transpiler=seed)
qk = QuantumKernel(feature_map=ansatz0, quantum_instance=QI)
qc = qk.construct_circuit(x=X_data, y=Y_data, is_statevector_sim = False)
qc.draw('mpl')
</code></pre>
<p>OUT:</p>
<pre><code>3 4
---------------------------------------------------------------------------
CircuitError                              Traceback (most recent call last)
Input In [323], in &lt;cell line: 18&gt;()
     16 QI = QuantumInstance(BasicAer.get_backend(&quot;qasm_simulator&quot;), shots=1024, seed_simulator=seed, seed_transpiler=seed)
     17 qk = QuantumKernel(feature_map=ansatz0, quantum_instance=QI)
---&gt; 18 qc = qk.construct_circuit(x=X_data, y=Y_data, is_statevector_sim = False)
     19 qc.draw('mpl')

File d:\miniconda3\lib\site-packages\qiskit_machine_learning\kernels\quantum_kernel.py:317, in QuantumKernel.construct_circuit(self, x, y, measurement, is_statevector_sim)
    314 qc = QuantumCircuit(q, c)
    316 x_dict = dict(zip(self._feature_map.parameters, x))
--&gt; 317 psi_x = self._feature_map.assign_parameters(x_dict)
    318 qc.append(psi_x.to_instruction(), qc.qubits)
    320 if not is_statevector_sim:

File d:\miniconda3\lib\site-packages\qiskit\circuit\library\n_local\n_local.py:810, in NLocal.assign_parameters(self, parameters, inplace)
    807 if not self._is_built:
    808     self._build()
--&gt; 810 return super().assign_parameters(parameters, inplace=inplace)

File d:\miniconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py:2663, in QuantumCircuit.assign_parameters(self, parameters, inplace)
   2661     # replace the parameters with a new Parameter (&quot;substitute&quot;) or numeric value (&quot;bind&quot;)
   2662     for parameter, value in unrolled_param_dict.items():
-&gt; 2663         bound_circuit._assign_parameter(parameter, value)
   2664 else:
   2665     if len(parameters) != self.num_parameters:

File d:\miniconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py:2749, in QuantumCircuit._assign_parameter(self, parameter, value)
   2747 # Normal ParameterExpression.
   2748 if isinstance(assignee, ParameterExpression):
-&gt; 2749     new_param = assignee.assign(parameter, value)
   2750     # if fully bound, validate
   2751     if len(new_param.parameters) == 0:

File d:\miniconda3\lib\site-packages\qiskit\circuit\parameterexpression.py:91, in ParameterExpression.assign(self, parameter, value)
     89 if isinstance(value, ParameterExpression):
     90     return self.subs({parameter: value})
---&gt; 91 return self.bind({parameter: value})

File d:\miniconda3\lib\site-packages\qiskit\circuit\parameterexpression.py:113, in ParameterExpression.bind(self, parameter_values)
     94 &quot;&quot;&quot;Binds the provided set of parameters to their corresponding values.
     95 
     96 Args:
   (...)
    109     parameter_values.
    110 &quot;&quot;&quot;
    112 self._raise_if_passed_unknown_parameters(parameter_values.keys())
--&gt; 113 self._raise_if_passed_nan(parameter_values)
    115 symbol_values = {}
    116 for parameter, value in parameter_values.items():

File d:\miniconda3\lib\site-packages\qiskit\circuit\parameterexpression.py:207, in ParameterExpression._raise_if_passed_nan(self, parameter_values)
    203 nan_parameter_values = {
    204     p: v for p, v in parameter_values.items() if not isinstance(v, numbers.Number)
    205 }
    206 if nan_parameter_values:
--&gt; 207     raise CircuitError(
    208         f&quot;Expression cannot bind non-numeric values ({nan_parameter_values})&quot;
    209     )

CircuitError: 'Expression cannot bind non-numeric values ({ParameterVectorElement(x[0]): array([ 1,  2,  7, 12])})'
</code></pre>
",QuantumKernel.construct_circuit:How to automatically build a quantum kernel circuit according to the QISKIT file？,<qiskit><kernel-methods>,1,0,,,"QuantumKernel.construct_circuit:How to automatically build a quantum kernel circuit according to the QISKIT file？ <p>This link
<a href=""https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.kernels.QuantumKernel.construct_circuit.html#qiskit_machine_learning.kernels.QuantumKernel.construct_circuit"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/machine-learning/stubs/qiskit_machine_learning.kernels.QuantumKernel.construct_circuit.html#qiskit_machine_learning.kernels.QuantumKernel.construct_circuit</a>
tells us that the circuit can be built automatically, but an error was found after using it, how can I solve it?</p>
<pre><code>from qiskit import BasicAer
from qiskit.circuit.library import ZZFeatureMap
from qiskit.utils import QuantumInstance, algorithm_globals
from qiskit_machine_learning.algorithms import QSVC
from qiskit_machine_learning.kernels import QuantumKernel
seed = 12345
X_data = np.array([[1,2,7,12],[3,7,7,11],[12,18,7,90]])
Y_data = np.array([[1,12,7,22],[3,71,7,111],[12,118,7,90]])
y_train = np.array([12,5,9])
print(X_data.shape[0],X_data.shape[1])
qbits = X_data.shape[0]
ansatz0 = ZZFeatureMap(feature_dimension=qbits, insert_barriers = True, name = 'Quantum Kernel',reps=1, parameter_prefix='x')
ansatz1 = ZZFeatureMap(feature_dimension=qbits, insert_barriers = True, name = 'Quantum Kernel',reps=1, parameter_prefix='y').inverse()
qc = ansatz0.compose(ansatz1)
qc.draw('mpl')
QI = QuantumInstance(BasicAer.get_backend(&quot;qasm_simulator&quot;), shots=1024, seed_simulator=seed, seed_transpiler=seed)
qk = QuantumKernel(feature_map=ansatz0, quantum_instance=QI)
qc = qk.construct_circuit(x=X_data, y=Y_data, is_statevector_sim = False)
qc.draw('mpl')
</code></pre>
<p>OUT:</p>
<pre><code>3 4
---------------------------------------------------------------------------
CircuitError                              Traceback (most recent call last)
Input In [323], in &lt;cell line: 18&gt;()
     16 QI = QuantumInstance(BasicAer.get_backend(&quot;qasm_simulator&quot;), shots=1024, seed_simulator=seed, seed_transpiler=seed)
     17 qk = QuantumKernel(feature_map=ansatz0, quantum_instance=QI)
---&gt; 18 qc = qk.construct_circuit(x=X_data, y=Y_data, is_statevector_sim = False)
     19 qc.draw('mpl')

File d:\miniconda3\lib\site-packages\qiskit_machine_learning\kernels\quantum_kernel.py:317, in QuantumKernel.construct_circuit(self, x, y, measurement, is_statevector_sim)
    314 qc = QuantumCircuit(q, c)
    316 x_dict = dict(zip(self._feature_map.parameters, x))
--&gt; 317 psi_x = self._feature_map.assign_parameters(x_dict)
    318 qc.append(psi_x.to_instruction(), qc.qubits)
    320 if not is_statevector_sim:

File d:\miniconda3\lib\site-packages\qiskit\circuit\library\n_local\n_local.py:810, in NLocal.assign_parameters(self, parameters, inplace)
    807 if not self._is_built:
    808     self._build()
--&gt; 810 return super().assign_parameters(parameters, inplace=inplace)

File d:\miniconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py:2663, in QuantumCircuit.assign_parameters(self, parameters, inplace)
   2661     # replace the parameters with a new Parameter (&quot;substitute&quot;) or numeric value (&quot;bind&quot;)
   2662     for parameter, value in unrolled_param_dict.items():
-&gt; 2663         bound_circuit._assign_parameter(parameter, value)
   2664 else:
   2665     if len(parameters) != self.num_parameters:

File d:\miniconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py:2749, in QuantumCircuit._assign_parameter(self, parameter, value)
   2747 # Normal ParameterExpression.
   2748 if isinstance(assignee, ParameterExpression):
-&gt; 2749     new_param = assignee.assign(parameter, value)
   2750     # if fully bound, validate
   2751     if len(new_param.parameters) == 0:

File d:\miniconda3\lib\site-packages\qiskit\circuit\parameterexpression.py:91, in ParameterExpression.assign(self, parameter, value)
     89 if isinstance(value, ParameterExpression):
     90     return self.subs({parameter: value})
---&gt; 91 return self.bind({parameter: value})

File d:\miniconda3\lib\site-packages\qiskit\circuit\parameterexpression.py:113, in ParameterExpression.bind(self, parameter_values)
     94 &quot;&quot;&quot;Binds the provided set of parameters to their corresponding values.
     95 
     96 Args:
   (...)
    109     parameter_values.
    110 &quot;&quot;&quot;
    112 self._raise_if_passed_unknown_parameters(parameter_values.keys())
--&gt; 113 self._raise_if_passed_nan(parameter_values)
    115 symbol_values = {}
    116 for parameter, value in parameter_values.items():

File d:\miniconda3\lib\site-packages\qiskit\circuit\parameterexpression.py:207, in ParameterExpression._raise_if_passed_nan(self, parameter_values)
    203 nan_parameter_values = {
    204     p: v for p, v in parameter_values.items() if not isinstance(v, numbers.Number)
    205 }
    206 if nan_parameter_values:
--&gt; 207     raise CircuitError(
    208         f&quot;Expression cannot bind non-numeric values ({nan_parameter_values})&quot;
    209     )

CircuitError: 'Expression cannot bind non-numeric values ({ParameterVectorElement(x[0]): array([ 1,  2,  7, 12])})'
</code></pre>
",qc,automatically build quantum kernel circuit according qiskit p link https nofollow noreferrer https tells us circuit built automatically error found using solve pre code qiskit import basicaer import zzfeaturemap import quantuminstance import qsvc import quantumkernel seed 12345 print 0 1 qbits 0 ansatz0 zzfeaturemap true name kernel x ansatz1 zzfeaturemap true name kernel qc ansatz1 qi quantuminstance quot quot qk quantumkernel qc false p pre code 3 4 circuiterror traceback recent call last input 323 lt cell line 18 gt 16 qi quantuminstance quot quot 17 qk quantumkernel gt 18 qc false 19 file self x measurement 314 qc quantumcircuit q c 316 dict zip x gt 317 318 320 file self parameters inplace 807 808 gt 810 return super parameters file self parameters inplace 2661 replace parameters new parameter quot substitute quot numeric value quot bind quot 2662 parameter value gt 2663 parameter value 2664 else 2665 len parameters file self parameter value 2747 normal parameterexpression 2748 isinstance assignee parameterexpression gt 2749 parameter value 2750 fully bound validate 2751 len 0 file self parameter value 89 isinstance value parameterexpression 90 return parameter value gt 91 return parameter value file self 94 quot quot quot binds provided set parameters corresponding values 95 96 args 109 110 quot quot quot 112 gt 113 115 116 parameter value file self 203 204 p v p v isinstance v 205 206 gt 207 raise circuiterror 208 f quot expression bind values quot 209 circuiterror bind values parametervectorelement x 0 array 1 2 7 12,"[(0, 0.5464216), (3, 0.017831402), (4, 0.02515244), (6, 0.06448806), (8, 0.016978033), (10, 0.02786186), (12, 0.04051784), (13, 0.014218701), (14, 0.079594396), (19, 0.15715568)]"
28285,28339.0,2022-09-26 11:14:30,5,835,"<p>I was trying to obtain the quasi-probability decomposition of the CNOT gate by using the information in this <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/abd7bc/pdf"" rel=""nofollow noreferrer"">paper</a>.</p>
<p>The authors give us the example for the CZ gate (Figure 2, i.e. the one below).</p>
<p><img src=""https://i.sstatic.net/qb0Q6.png"" alt=""figure2"" /></p>
<p>The problem is that by using that decomposition I get <span class=""math-container"">$\begin{bmatrix}
                            1-i &amp; 0 &amp; 0 &amp; 0 \\
                            0 &amp; 1+i&amp; 0 &amp; 0 \\
                            0 &amp; 0 &amp; 1+i &amp; 0 \\
                            0 &amp; 0 &amp; 0 &amp; -1-i
                        \end{bmatrix}$</span>
instead of the CZ gate that is <span class=""math-container"">$\begin{bmatrix}
                            1 &amp; 0 &amp; 0 &amp; 0 \\
                            0 &amp; 1&amp; 0 &amp; 0 \\
                            0 &amp; 0 &amp; 1 &amp; 0 \\
                            0 &amp; 0 &amp; 0 &amp; -1
                        \end{bmatrix}$</span>.</p>
<p>I'm not even sure on how to convert this information to obtain the CNOT gate, but first I need to get the CZ gate with that calculation. Is there anybody that can help me obtaining the correct result?</p>
<p>I used a small python script to obtain that matrix:</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

i = np.eye(2)

z = np.array([[1,0],[0,-1]])

t1  = 1/2*np.kron(1/np.sqrt(2)*(i+1j*z), 1/np.sqrt(2)*(i+1j*z))

t2  = 1/2*np.kron(1/np.sqrt(2)*(i-1j*z), 1/np.sqrt(2)*(i-1j*z))

t3 = 0
for a1 in [-1,1]:
   for a2 in [-1,1]:
       t3 += -1/2 *a1*a2*( np.kron((i+a1*z)/2, np.cos((a2+1)*np.pi/4)*i+1j*np.sin((a2+1)*np.pi/4)*z) + np.kron(np.cos((a1+1)*np.pi/4)*i+1j*np.sin((a1+1)*np.pi/4)*z, (i+a2*z)/2) )

print(t1+t2+t3)
</code></pre>
<p>EDIT: I'm starting to think that the &quot;=&quot; in that image is not totally true. If I use that decomposition the expectation values of all observables are the same of the original circuit ones, but the final state changes. Since they focus on the expectation value, probably they mean that they are equal in that way.</p>
",Quasiprobability decomposition of the CZ-gate,<quantum-gate><gate-synthesis>,3,3,,,"Quasiprobability decomposition of the CZ-gate <p>I was trying to obtain the quasi-probability decomposition of the CNOT gate by using the information in this <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/abd7bc/pdf"" rel=""nofollow noreferrer"">paper</a>.</p>
<p>The authors give us the example for the CZ gate (Figure 2, i.e. the one below).</p>
<p><img src=""https://i.sstatic.net/qb0Q6.png"" alt=""figure2"" /></p>
<p>The problem is that by using that decomposition I get <span class=""math-container"">$\begin{bmatrix}
                            1-i &amp; 0 &amp; 0 &amp; 0 \\
                            0 &amp; 1+i&amp; 0 &amp; 0 \\
                            0 &amp; 0 &amp; 1+i &amp; 0 \\
                            0 &amp; 0 &amp; 0 &amp; -1-i
                        \end{bmatrix}$</span>
instead of the CZ gate that is <span class=""math-container"">$\begin{bmatrix}
                            1 &amp; 0 &amp; 0 &amp; 0 \\
                            0 &amp; 1&amp; 0 &amp; 0 \\
                            0 &amp; 0 &amp; 1 &amp; 0 \\
                            0 &amp; 0 &amp; 0 &amp; -1
                        \end{bmatrix}$</span>.</p>
<p>I'm not even sure on how to convert this information to obtain the CNOT gate, but first I need to get the CZ gate with that calculation. Is there anybody that can help me obtaining the correct result?</p>
<p>I used a small python script to obtain that matrix:</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np

i = np.eye(2)

z = np.array([[1,0],[0,-1]])

t1  = 1/2*np.kron(1/np.sqrt(2)*(i+1j*z), 1/np.sqrt(2)*(i+1j*z))

t2  = 1/2*np.kron(1/np.sqrt(2)*(i-1j*z), 1/np.sqrt(2)*(i-1j*z))

t3 = 0
for a1 in [-1,1]:
   for a2 in [-1,1]:
       t3 += -1/2 *a1*a2*( np.kron((i+a1*z)/2, np.cos((a2+1)*np.pi/4)*i+1j*np.sin((a2+1)*np.pi/4)*z) + np.kron(np.cos((a1+1)*np.pi/4)*i+1j*np.sin((a1+1)*np.pi/4)*z, (i+a2*z)/2) )

print(t1+t2+t3)
</code></pre>
<p>EDIT: I'm starting to think that the &quot;=&quot; in that image is not totally true. If I use that decomposition the expectation values of all observables are the same of the original circuit ones, but the final state changes. Since they focus on the expectation value, probably they mean that they are equal in that way.</p>
",qc,quasiprobability decomposition p trying obtain decomposition cnot gate using information https nofollow noreferrer paper p authors give us example cz gate figure 2 one p img https figure2 p problem using decomposition get span bmatrix amp 0 amp 0 amp 0 0 amp amp 0 amp 0 0 amp 0 amp amp 0 0 amp 0 amp 0 amp bmatrix instead cz gate span bmatrix 1 amp 0 amp 0 amp 0 0 amp 1 amp 0 amp 0 0 amp 0 amp 1 amp 0 0 amp 0 amp 0 amp bmatrix p even sure convert information obtain cnot gate first need get cz gate calculation anybody help obtaining correct result p used small python script obtain matrix pre code import numpy np 2 z 0 t1 2 z 2 z t2 2 z 2 z t3 0 a1 a2 t3 a1 a2 z z z z print p edit starting think quot quot image totally true use decomposition expectation values observables original circuit ones final state changes since focus expectation value probably mean equal,"[(0, 0.081110545), (2, 0.20727849), (4, 0.06485953), (9, 0.12306789), (12, 0.011808765), (14, 0.17075711), (15, 0.31803995), (19, 0.012937966)]"
28389,30377.0,2022-10-03 16:25:20,8,379,"<p>From the middle-late decades of the last century, many researchers such as Bennett, Benoif, Deutsch, Feynman, Manin, Wiesner, among others, had some intuition that qubits are computationally more powerful or more interesting than classical bits.</p>
<p>Physically embodied qubits as we understand and intuit nowadays are fundamentally <em>distinguishable</em> &quot;particles&quot; or &quot;atoms&quot;.  For example, at a high level we need to separate and index the wires in our circuit diagrams, but also more concretely we can point to individual ions in a trap or individual transmons and identify and label them as separate and distinguished.</p>
<p>But, quantum mechanics is also concerned with two classes of <em>indistinguishable</em> particles - namely fermions and bosons.</p>
<p>Going back all the way to the 1920's, <a href=""https://en.wikipedia.org/wiki/Jordan%E2%80%93Wigner_transformation"" rel=""noreferrer"">Jordan and Wigner</a> provided a mapping between the wavefunction in a Hilbert space spanned by a number of qubits and the wavefunction in a Fock space spanned by fermions.  Feynman also hinted that a qubit could be defined by the presence or absence of such a particle.  But, for fermions at least the <a href=""https://en.wikipedia.org/wiki/Numerical_sign_problem"" rel=""noreferrer"">sign problem</a> is a separate issue that needs to be carefully addressed - e.g. whenever two fermions are swapped, the wavefunction picks up a negative phase.</p>
<p>Furthermore regarding bosons, Aaronson and Arkhipov noted that <a href=""https://en.wikipedia.org/wiki/Boson_sampling"" rel=""noreferrer"">sampling</a> bosons such as photons from a network of mirrors and beam splitters is related to calculation of the <a href=""https://en.wikipedia.org/wiki/Permanent_(mathematics)"" rel=""noreferrer"">permanent</a>, while sampling the same for fermions is related to the determinant.  It follows from <a href=""https://en.wikipedia.org/wiki/%E2%99%AFP-completeness_of_01-permanent"" rel=""noreferrer"">Valiant's theorem</a> that boson sampling is likely much (much) more difficult than fermion sampling.</p>
<p>On the one hand we have fermions, which naively have the sign problem making simulation more difficult; however, fermion sampling is in <strong>P</strong>.  On the other hand boson sampling is most likely not in <strong>P</strong> - nor is it likely to <em>contain</em> <strong>P</strong>.</p>
<blockquote>
<p><strong>But, can we translate between fermions, bosons, and qubits efficiently?  For example could we have created a quantum computer out of indistinguishable bosons instead of distinguishable qubits?</strong></p>
</blockquote>
<hr />
<p><sup>Because of the <a href=""https://en.wikipedia.org/wiki/Pauli_exclusion_principle"" rel=""noreferrer"">Pauli exclusion principle</a>, a chain can be either occupied or not with precisely one fermion, while bosonic occupancy is unlimited.  BosonSampling experiments try to mitigate this by having at least quadratically more modes than bosons</sup>.</p>
",Are indistinguishable bosons and fermions computationally equivalent to distinguishable qubits?,<architecture><history><boson-sampling>,1,2,,,"Are indistinguishable bosons and fermions computationally equivalent to distinguishable qubits? <p>From the middle-late decades of the last century, many researchers such as Bennett, Benoif, Deutsch, Feynman, Manin, Wiesner, among others, had some intuition that qubits are computationally more powerful or more interesting than classical bits.</p>
<p>Physically embodied qubits as we understand and intuit nowadays are fundamentally <em>distinguishable</em> &quot;particles&quot; or &quot;atoms&quot;.  For example, at a high level we need to separate and index the wires in our circuit diagrams, but also more concretely we can point to individual ions in a trap or individual transmons and identify and label them as separate and distinguished.</p>
<p>But, quantum mechanics is also concerned with two classes of <em>indistinguishable</em> particles - namely fermions and bosons.</p>
<p>Going back all the way to the 1920's, <a href=""https://en.wikipedia.org/wiki/Jordan%E2%80%93Wigner_transformation"" rel=""noreferrer"">Jordan and Wigner</a> provided a mapping between the wavefunction in a Hilbert space spanned by a number of qubits and the wavefunction in a Fock space spanned by fermions.  Feynman also hinted that a qubit could be defined by the presence or absence of such a particle.  But, for fermions at least the <a href=""https://en.wikipedia.org/wiki/Numerical_sign_problem"" rel=""noreferrer"">sign problem</a> is a separate issue that needs to be carefully addressed - e.g. whenever two fermions are swapped, the wavefunction picks up a negative phase.</p>
<p>Furthermore regarding bosons, Aaronson and Arkhipov noted that <a href=""https://en.wikipedia.org/wiki/Boson_sampling"" rel=""noreferrer"">sampling</a> bosons such as photons from a network of mirrors and beam splitters is related to calculation of the <a href=""https://en.wikipedia.org/wiki/Permanent_(mathematics)"" rel=""noreferrer"">permanent</a>, while sampling the same for fermions is related to the determinant.  It follows from <a href=""https://en.wikipedia.org/wiki/%E2%99%AFP-completeness_of_01-permanent"" rel=""noreferrer"">Valiant's theorem</a> that boson sampling is likely much (much) more difficult than fermion sampling.</p>
<p>On the one hand we have fermions, which naively have the sign problem making simulation more difficult; however, fermion sampling is in <strong>P</strong>.  On the other hand boson sampling is most likely not in <strong>P</strong> - nor is it likely to <em>contain</em> <strong>P</strong>.</p>
<blockquote>
<p><strong>But, can we translate between fermions, bosons, and qubits efficiently?  For example could we have created a quantum computer out of indistinguishable bosons instead of distinguishable qubits?</strong></p>
</blockquote>
<hr />
<p><sup>Because of the <a href=""https://en.wikipedia.org/wiki/Pauli_exclusion_principle"" rel=""noreferrer"">Pauli exclusion principle</a>, a chain can be either occupied or not with precisely one fermion, while bosonic occupancy is unlimited.  BosonSampling experiments try to mitigate this by having at least quadratically more modes than bosons</sup>.</p>
",qc,indistinguishable bosons fermions computationally equivalent distinguishable qubits p decades last century many researchers bennett benoif deutsch feynman manin wiesner among others intuition qubits computationally powerful interesting classical p physically embodied qubits understand intuit nowadays fundamentally em distinguishable quot particles quot quot atoms quot example high level need separate index wires circuit diagrams also concretely point individual ions trap individual transmons identify label separate p quantum mechanics also concerned two classes em indistinguishable particles namely fermions p going back way 1920 https e2 80 noreferrer jordan wigner provided mapping wavefunction hilbert space spanned number qubits wavefunction fock space spanned fermions feynman also hinted qubit could defined presence absence particle fermions least https noreferrer sign problem separate issue needs carefully addressed whenever two fermions swapped wavefunction picks negative p furthermore regarding bosons aaronson arkhipov noted https noreferrer sampling bosons photons network mirrors beam splitters related calculation https mathematics noreferrer permanent sampling fermions related determinant follows https e2 99 noreferrer valiant theorem boson sampling likely much much difficult fermion p one hand fermions naively sign problem making simulation difficult however fermion sampling strong p hand boson sampling likely strong p likely em contain strong p blockquote p strong translate fermions bosons qubits efficiently example could created quantum computer indistinguishable bosons instead distinguishable qubits hr p sup https noreferrer pauli exclusion principle chain either occupied precisely one fermion bosonic occupancy unlimited bosonsampling experiments try mitigate least quadratically modes bosons,"[(1, 0.017777076), (3, 0.098381214), (4, 0.030465206), (7, 0.015977668), (8, 0.21174985), (9, 0.2948584), (10, 0.06057361), (12, 0.014074986), (13, 0.19173826), (14, 0.024763905), (19, 0.03153365)]"
28452,,2022-10-07 15:30:41,1,56,"<p>For OpenPulse enabled backends, the Hamiltonian can be retrieved via its configuration. The configuration holds a dictionary containing for example the Hamiltonian as a LaTeX string.
Example code:</p>
<pre><code>from qiskit.providers.fake_provider import FakeBelem
backend = FakeBelem()
print(backend.configuration().hamiltonian['h_latex'])
</code></pre>
<p>When rendered, the Hamiltonian (for fake backend <code>FakeBelem</code>) is defined as seen in this picture:</p>
<p><a href=""https://i.sstatic.net/YOJjV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YOJjV.png"" alt=""Hamiltonian returned by FakeBelem"" /></a></p>
<p>The Hamiltonian for other backends, for example the real <code>ibmq_guadalupe</code> look similar, just with more coupling(J)- and control channel(U)-Terms.</p>
<p>What is the meaning of the <span class=""math-container"">$\Delta_i$</span> and <span class=""math-container"">$O_i$</span> symbols (marked red, first line) in these kind of Hamiltonians?</p>
",Meaning of 'O_i' and 'Δ_i' terms in PulseBackend Hamiltonians,<qiskit><superconducting-quantum-computing><openpulse><hamiltonian>,1,0,,,"Meaning of 'O_i' and 'Δ_i' terms in PulseBackend Hamiltonians <p>For OpenPulse enabled backends, the Hamiltonian can be retrieved via its configuration. The configuration holds a dictionary containing for example the Hamiltonian as a LaTeX string.
Example code:</p>
<pre><code>from qiskit.providers.fake_provider import FakeBelem
backend = FakeBelem()
print(backend.configuration().hamiltonian['h_latex'])
</code></pre>
<p>When rendered, the Hamiltonian (for fake backend <code>FakeBelem</code>) is defined as seen in this picture:</p>
<p><a href=""https://i.sstatic.net/YOJjV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YOJjV.png"" alt=""Hamiltonian returned by FakeBelem"" /></a></p>
<p>The Hamiltonian for other backends, for example the real <code>ibmq_guadalupe</code> look similar, just with more coupling(J)- and control channel(U)-Terms.</p>
<p>What is the meaning of the <span class=""math-container"">$\Delta_i$</span> and <span class=""math-container"">$O_i$</span> symbols (marked red, first line) in these kind of Hamiltonians?</p>
",qc,meaning terms pulsebackend hamiltonians p openpulse enabled backends hamiltonian retrieved via configuration configuration holds dictionary containing example hamiltonian latex string example code pre code import fakebelem backend fakebelem print p rendered hamiltonian fake backend code fakebelem defined seen picture p https nofollow noreferrer img https hamiltonian returned fakebelem p hamiltonian backends example real code look similar coupling j control channel u p meaning span span symbols marked red first line kind hamiltonians,"[(0, 0.19914477), (1, 0.1010781), (3, 0.13166854), (4, 0.13131368), (8, 0.024358666), (9, 0.14279829), (12, 0.014690094), (14, 0.22871451), (18, 0.024569184)]"
28462,,2022-10-08 14:16:00,7,663,"<p>The 2022 Nobel Prize in Physics was <a href=""https://www.nobelprize.org/prizes/physics/2022/press-release/"" rel=""noreferrer"">awarded to</a> Alain Aspect, John Clauser, and Anton Zeilinger for &quot;experiments with entangled photons... pioneering quantum information science&quot;.</p>
<p>Presumably there were noteworthy publications of each.</p>
<blockquote>
<p><strong>Are there separate publications at least partially authored by each of the three, that can each be said to be a &quot;Nobel-prize winning paper&quot;?</strong></p>
</blockquote>
<p>The Nobel prizes have historically been awarded for theorists whose work is later experimentally validated; some more recent Nobel prizes have somewhat loosened that theory vs. experiment dichotomy.</p>
<p>Can we create a timeline, with links to papers, from EPR to Bell to CHSH to the 70s - early 80's work of experiments of Clauser and Aspect to the GHZ/teleportation experiments and the Delft experiments, identifying noteworthy <a href=""https://en.wikipedia.org/wiki/Thought_experiment"" rel=""noreferrer"">gedanken</a>- and actual experiments, and how they anticipated or led into each other?</p>
","What are the 2022 Nobel Prize winning papers of Alain Aspect, John Clauser, and Anton Zeilinger, and how do they fit into the timeline of QIS?",<teleportation><bell-experiment><foundations><history>,1,2,,,"What are the 2022 Nobel Prize winning papers of Alain Aspect, John Clauser, and Anton Zeilinger, and how do they fit into the timeline of QIS? <p>The 2022 Nobel Prize in Physics was <a href=""https://www.nobelprize.org/prizes/physics/2022/press-release/"" rel=""noreferrer"">awarded to</a> Alain Aspect, John Clauser, and Anton Zeilinger for &quot;experiments with entangled photons... pioneering quantum information science&quot;.</p>
<p>Presumably there were noteworthy publications of each.</p>
<blockquote>
<p><strong>Are there separate publications at least partially authored by each of the three, that can each be said to be a &quot;Nobel-prize winning paper&quot;?</strong></p>
</blockquote>
<p>The Nobel prizes have historically been awarded for theorists whose work is later experimentally validated; some more recent Nobel prizes have somewhat loosened that theory vs. experiment dichotomy.</p>
<p>Can we create a timeline, with links to papers, from EPR to Bell to CHSH to the 70s - early 80's work of experiments of Clauser and Aspect to the GHZ/teleportation experiments and the Delft experiments, identifying noteworthy <a href=""https://en.wikipedia.org/wiki/Thought_experiment"" rel=""noreferrer"">gedanken</a>- and actual experiments, and how they anticipated or led into each other?</p>
",qc,2022 nobel prize winning papers alain aspect john clauser anton zeilinger fit timeline qis p 2022 nobel prize physics https noreferrer awarded alain aspect john clauser anton zeilinger quot experiments entangled photons pioneering quantum information science quot p presumably noteworthy publications blockquote p strong separate publications least partially authored three said quot winning paper quot p nobel prizes historically awarded theorists whose work later experimentally validated recent nobel prizes somewhat loosened theory experiment p create timeline links papers epr bell chsh 70s early 80 work experiments clauser aspect experiments delft experiments identifying noteworthy https noreferrer gedanken actual experiments anticipated led,"[(7, 0.018664928), (8, 0.121019386), (9, 0.3834162), (12, 0.03925282), (13, 0.20975962), (15, 0.04207694), (17, 0.02550138), (18, 0.10617429), (19, 0.05272264)]"
28469,28472.0,2022-10-09 08:46:27,0,80,"<p>I am struggling to find how an <span class=""math-container"">$X$</span> noise propagates through a controlled-<span class=""math-container"">$S$</span> gate.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22X%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D%5D%7D"" rel=""nofollow noreferrer"">Here`s the circuit.</a></p>
",How $X$ noise propagates through controlled-$S$ gate,<quantum-state><quantum-circuit><transpile><compiling>,2,0,,,"How $X$ noise propagates through controlled-$S$ gate <p>I am struggling to find how an <span class=""math-container"">$X$</span> noise propagates through a controlled-<span class=""math-container"">$S$</span> gate.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22X%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D%5D%7D"" rel=""nofollow noreferrer"">Here`s the circuit.</a></p>
",qc,x noise propagates gate p struggling find span x noise propagates span p https 7b 22cols 22 5b 5b 22x 22 5d 5b 22z 5e c2 bd 22 22 e2 80 a2 22 5d 5d 7d nofollow noreferrer,"[(3, 0.03584567), (4, 0.1269673), (5, 0.06527967), (10, 0.07044736), (12, 0.59907013), (13, 0.09872364)]"
28490,,2022-10-10 07:31:19,0,149,"<p>I am trying to build a <span class=""math-container"">$T$</span> injecton protocol and study how an <span class=""math-container"">$X^b$</span> post-process, supposed to happen before the protocol, behaves if delayed after the protocol.</p>
<p>The first example comes from the combination of the two protocols of figure 2. from <a href=""https://www.nature.com/articles/srep01939"" rel=""nofollow noreferrer"">this paper</a>.</p>
<p><a href=""https://i.sstatic.net/zdUAn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zdUAn.png"" alt=""enter image description here"" /></a></p>
<p>The result is something like <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,%22Z%5E%C2%BC%22%5D,%5B%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22,%22%E2%80%A2%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,1,%22H%22%5D,%5B%22Z%22,1,%22%E2%80%A2%22%5D%5D,%22init%22:%5B%22+%22,0,%22+%22%5D%7D"" rel=""nofollow noreferrer"">this</a>. Where I deferred and removed the measurements. It seems catalytic.</p>
<p><a href=""https://i.sstatic.net/dzlXg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dzlXg.png"" alt=""enter image description here"" /></a></p>
<p>An alternative comes from <a href=""https://docs.google.com/presentation/d/128QRFOVRhPRBJ-zq2k0NG-dV8LG2u99T3-YgxwO4-pY/edit#slide=id.gaf0081a86d_0_685"" rel=""nofollow noreferrer"">this slide</a>. Which, without measurements, looks <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,%22H%22,%22H%22%5D,%5B1,%22Z%5E%C2%BD%22,%22Z%5E%C2%BC%22%5D,%5B%22%E2%80%A2%22,%22X%22,%22X%22%5D,%5B1,%22H%22,%22%E2%97%A6%22%5D,%5B%22Z%22,%22%E2%80%A2%22%5D%5D,%22init%22:%5B%22+%22%5D%7D"" rel=""nofollow noreferrer"">like this</a>.</p>
<p><a href=""https://i.sstatic.net/iTZJZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/iTZJZ.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/3X6At.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/3X6At.png"" alt=""enter image description here"" /></a></p>
<p>To conclude, my question is:
Assuming an <span class=""math-container"">$X^b$</span> operation at the beginning of a protocol. What it the equivalent operation that post-pone the correction?</p>
",Postponing post-processing through state injection protocols,<state-injection-model>,1,3,,,"Postponing post-processing through state injection protocols <p>I am trying to build a <span class=""math-container"">$T$</span> injecton protocol and study how an <span class=""math-container"">$X^b$</span> post-process, supposed to happen before the protocol, behaves if delayed after the protocol.</p>
<p>The first example comes from the combination of the two protocols of figure 2. from <a href=""https://www.nature.com/articles/srep01939"" rel=""nofollow noreferrer"">this paper</a>.</p>
<p><a href=""https://i.sstatic.net/zdUAn.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zdUAn.png"" alt=""enter image description here"" /></a></p>
<p>The result is something like <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,%22Z%5E%C2%BC%22%5D,%5B%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22,%22%E2%80%A2%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,1,%22H%22%5D,%5B%22Z%22,1,%22%E2%80%A2%22%5D%5D,%22init%22:%5B%22+%22,0,%22+%22%5D%7D"" rel=""nofollow noreferrer"">this</a>. Where I deferred and removed the measurements. It seems catalytic.</p>
<p><a href=""https://i.sstatic.net/dzlXg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dzlXg.png"" alt=""enter image description here"" /></a></p>
<p>An alternative comes from <a href=""https://docs.google.com/presentation/d/128QRFOVRhPRBJ-zq2k0NG-dV8LG2u99T3-YgxwO4-pY/edit#slide=id.gaf0081a86d_0_685"" rel=""nofollow noreferrer"">this slide</a>. Which, without measurements, looks <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,%22H%22,%22H%22%5D,%5B1,%22Z%5E%C2%BD%22,%22Z%5E%C2%BC%22%5D,%5B%22%E2%80%A2%22,%22X%22,%22X%22%5D,%5B1,%22H%22,%22%E2%97%A6%22%5D,%5B%22Z%22,%22%E2%80%A2%22%5D%5D,%22init%22:%5B%22+%22%5D%7D"" rel=""nofollow noreferrer"">like this</a>.</p>
<p><a href=""https://i.sstatic.net/iTZJZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/iTZJZ.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/3X6At.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/3X6At.png"" alt=""enter image description here"" /></a></p>
<p>To conclude, my question is:
Assuming an <span class=""math-container"">$X^b$</span> operation at the beginning of a protocol. What it the equivalent operation that post-pone the correction?</p>
",qc,postponing state injection protocols p trying build span injecton protocol study span supposed happen protocol behaves delayed p first example comes combination two protocols figure https nofollow noreferrer paper p https nofollow noreferrer img https enter image description p result something like https 7b 22cols 22 5b 22z 5e c2 bc 22 5d 5b 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 22 e2 80 a2 22 5d 5b1 22 e2 80 a2 22 22x 22 5d 5b1 22z 5e c2 bd 22 22 e2 80 a2 22 5d 22h 22 5d 5b 22z 22 e2 80 a2 22 5d 5d 22init 22 5b 22 5d 7d nofollow noreferrer deferred removed measurements seems p https nofollow noreferrer img https enter image description p alternative comes https nofollow noreferrer slide without measurements looks https 7b 22cols 22 5b 5b1 22h 22 22h 22 5d 5b1 22z 5e c2 bd 22 22z 5e c2 bc 22 5d 5b 22 e2 80 a2 22 22x 22 22x 22 5d 5b1 22h 22 22 e2 97 a6 22 5d 5b 22z 22 22 e2 80 a2 22 5d 5d 22init 22 5b 22 5d 7d nofollow noreferrer like p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p conclude question assuming span operation beginning protocol equivalent operation correction,"[(3, 0.021402445), (4, 0.26396024), (5, 0.041031826), (9, 0.06090494), (12, 0.5693021), (18, 0.037940174)]"
28550,,2022-10-15 00:40:23,1,139,"<p><a href=""https://i.sstatic.net/ebOTk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ebOTk.jpg"" alt=""enter image description here"" /></a></p>
<p>Basically, I want to simulate the above photosystem process of light absorption. Above is a diagram of laser beams shot into antenna pigment molecules and traveling to the reaction center. Two theories surround the laser path: Random and shortest distance. The latter is more feasible.</p>
<p><a href=""https://i.sstatic.net/HOQuD.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HOQuD.jpg"" alt=""enter image description here"" /></a></p>
<p>My goal is to simulate the quantum effect behind this process regardless of which pigment molecule the light is being shot at. I came across this github repo on <a href=""https://github.com/fancompute/qpga"" rel=""nofollow noreferrer"">Quantum programmable gate arrays</a> so I want to know how to remodel it to simulate the above process.</p>
",Simulating light absorption in Photosynthesis through Quantum computing,<qiskit><programming><photonics><quantum-biology>,0,7,,,"Simulating light absorption in Photosynthesis through Quantum computing <p><a href=""https://i.sstatic.net/ebOTk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ebOTk.jpg"" alt=""enter image description here"" /></a></p>
<p>Basically, I want to simulate the above photosystem process of light absorption. Above is a diagram of laser beams shot into antenna pigment molecules and traveling to the reaction center. Two theories surround the laser path: Random and shortest distance. The latter is more feasible.</p>
<p><a href=""https://i.sstatic.net/HOQuD.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HOQuD.jpg"" alt=""enter image description here"" /></a></p>
<p>My goal is to simulate the quantum effect behind this process regardless of which pigment molecule the light is being shot at. I came across this github repo on <a href=""https://github.com/fancompute/qpga"" rel=""nofollow noreferrer"">Quantum programmable gate arrays</a> so I want to know how to remodel it to simulate the above process.</p>
",qc,simulating light absorption photosynthesis quantum computing p https nofollow noreferrer img https enter image description p basically want simulate photosystem process light absorption diagram laser beams shot antenna pigment molecules traveling reaction center two theories surround laser path random shortest distance latter p https nofollow noreferrer img https enter image description p goal simulate quantum effect behind process regardless pigment molecule light shot came across github repo https nofollow noreferrer quantum programmable gate arrays want know remodel simulate,"[(4, 0.4291603), (5, 0.019221695), (6, 0.014579262), (7, 0.01825757), (8, 0.18370773), (9, 0.06712806), (12, 0.013959811), (14, 0.1919729), (17, 0.033236105), (19, 0.027384797)]"
28591,28592.0,2022-10-18 14:08:08,0,130,"<p><a href=""https://i.sstatic.net/rpjBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/rpjBM.png"" alt=""enter image description here"" /></a></p>
<p>Here [+1] represents X gate for qutrit. How the Counter value is coming to 5? which is the measurement outcome(q0q1q2-&gt;102). Even for (q0q1q2-&gt;101) also counter value is 5.
In total, for this 3 qutrits composite system, we have access to 27 levels (0,1,_ _ _ 26) but the counter value is not exceeding more than 7(q0q1q2-&gt;222).</p>
<p>Can someone suggest how to get true levels in Cirq for qudits after measurement? as well as what does counter value represent?</p>
",Interpretation of Qudit measurement output in cirq,<cirq><quantum-state>,1,0,,,"Interpretation of Qudit measurement output in cirq <p><a href=""https://i.sstatic.net/rpjBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/rpjBM.png"" alt=""enter image description here"" /></a></p>
<p>Here [+1] represents X gate for qutrit. How the Counter value is coming to 5? which is the measurement outcome(q0q1q2-&gt;102). Even for (q0q1q2-&gt;101) also counter value is 5.
In total, for this 3 qutrits composite system, we have access to 27 levels (0,1,_ _ _ 26) but the counter value is not exceeding more than 7(q0q1q2-&gt;222).</p>
<p>Can someone suggest how to get true levels in Cirq for qudits after measurement? as well as what does counter value represent?</p>
",qc,interpretation qudit measurement output cirq p https nofollow noreferrer img https enter image description p represents x gate qutrit counter value coming 5 measurement outcome gt 102 even gt 101 also counter value total 3 qutrits composite system access 27 levels 26 counter value exceeding 7 gt 222 p someone suggest get true levels cirq qudits measurement well counter value represent,"[(0, 0.06182274), (4, 0.17921521), (6, 0.07109457), (9, 0.16340142), (10, 0.019193515), (12, 0.01689035), (13, 0.20139953), (16, 0.034193464), (18, 0.25096047)]"
28648,28654.0,2022-10-23 21:43:42,0,241,"<p>I'm trying to simulate 3 qubit (distance 3) bit-flip code in stim.
I wrote code similar to <a href=""https://quantumcomputing.stackexchange.com/questions/21485/how-to-import-a-generic-stabilizer-code-in-stim"">How to import a generic stabilizer code in stim</a> using MPP operation. I found the following way yields logical error rate below physical error rate</p>
<pre><code>MPP Z0*Z1 #stabilizer measurement in the last round
MPP Z1*Z2 #stabilizer measurement in the last round

M 0 1 2 #measure logical Z
DETECTOR rec[-2] rec[-3] rec[-5]
DETECTOR rec[-1] rec[-2] rec[-4]
OBSERVABLE_INCLUDE(0) rec[-1]
</code></pre>
<p>However is it possible to use MPP in the end? If so, how? I'm asking this because I'm confused when trying to write a similar readout for 7-qubit code where the relation is more complex.</p>
",How to use MPP to measure the logical Z in stim,<error-correction><simulation><stabilizer-code><stim>,1,0,,,"How to use MPP to measure the logical Z in stim <p>I'm trying to simulate 3 qubit (distance 3) bit-flip code in stim.
I wrote code similar to <a href=""https://quantumcomputing.stackexchange.com/questions/21485/how-to-import-a-generic-stabilizer-code-in-stim"">How to import a generic stabilizer code in stim</a> using MPP operation. I found the following way yields logical error rate below physical error rate</p>
<pre><code>MPP Z0*Z1 #stabilizer measurement in the last round
MPP Z1*Z2 #stabilizer measurement in the last round

M 0 1 2 #measure logical Z
DETECTOR rec[-2] rec[-3] rec[-5]
DETECTOR rec[-1] rec[-2] rec[-4]
OBSERVABLE_INCLUDE(0) rec[-1]
</code></pre>
<p>However is it possible to use MPP in the end? If so, how? I'm asking this because I'm confused when trying to write a similar readout for 7-qubit code where the relation is more complex.</p>
",qc,use mpp measure logical z stim p trying simulate 3 qubit distance 3 code stim wrote code similar https import generic stabilizer code stim using mpp operation found following way yields logical error rate physical error rate pre code mpp z0 z1 stabilizer measurement last round mpp z1 z2 stabilizer measurement last round 0 1 2 measure logical z detector rec rec rec detector rec rec rec 0 rec p however possible use mpp end asking confused trying write similar readout code relation,"[(0, 0.036885098), (5, 0.40964833), (6, 0.21329042), (7, 0.022179503), (12, 0.07410584), (14, 0.19741754), (17, 0.044910062)]"
28672,28676.0,2022-10-25 11:55:21,1,161,"<p>I have a stim circuit and when I call shortest graphlike error I find that it has distance 3:</p>
<p><code>assert len(shortsurfacecode.circ.shortest_graphlike_error()) == 3</code></p>
<p><strong>When I draw the match-graph-3d it consists of a single node and I don't understand why:</strong></p>
<p><code>shortsurfacecode.circ.detector_error_model().diagram(type=&quot;match-graph-3d&quot;)</code></p>
<p><a href=""https://i.sstatic.net/l6BzY.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/l6BzY.png"" alt=""enter image description here"" /></a></p>
<p>Here is the stim circuit:</p>
<pre><code>QUBIT_COORDS(0, 2) 0
QUBIT_COORDS(1, 1) 1
QUBIT_COORDS(2, 0) 2
QUBIT_COORDS(1, 3) 3
QUBIT_COORDS(2, 2) 4
QUBIT_COORDS(3, 1) 5
QUBIT_COORDS(2, 4) 6
QUBIT_COORDS(3, 3) 7
QUBIT_COORDS(4, 2) 8
R 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 3) 9
R 9
QUBIT_COORDS(1, 2) 10
R 10
QUBIT_COORDS(0, 1) 11
R 11
QUBIT_COORDS(3, 0) 12
R 12
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8 9 10 11 12
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 9 11
M 9 11
X_ERROR(0.01) 10 12
M 10 12
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 1) 13
R 13
QUBIT_COORDS(3, 2) 14
R 14
QUBIT_COORDS(4, 3) 15
R 15
QUBIT_COORDS(1, 4) 16
R 16
X_ERROR(0.01) 13 14 15 16
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
CX 13 5 8 14 6 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 5 8 14 6 16
DEPOLARIZE1(0.01) 0 1 2 3 4 7 15
CX 13 4 5 14 3 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 4 5 14 3 16
DEPOLARIZE1(0.01) 0 1 2 6 7 8 15
CX 13 2 7 14 15 8
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 2 7 14 15 8
DEPOLARIZE1(0.01) 0 1 3 4 5 6 16
CX 13 1 4 14 15 7
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 1 4 14 15 7
DEPOLARIZE1(0.01) 0 2 3 5 6 8 16
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
X_ERROR(0.01) 13 15
M 13 15
X_ERROR(0.01) 14 16
M 14 16
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
R 9 10 11 12
X_ERROR(0.01) 9 10 11 12
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 11
M 11
DETECTOR rec[-1] rec[-8]
X_ERROR(0.01) 12
M 12
DETECTOR rec[-1] rec[-7]
X_ERROR(0.01) 10
M 10
DETECTOR rec[-1] rec[-9]
X_ERROR(0.01) 9
M 9
DETECTOR rec[-1] rec[-12]
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8
M 0 1 2 3 4 5 6 7 8
DETECTOR rec[-11] rec[-9] rec[-6] rec[-8] rec[-5]
DETECTOR rec[-15] rec[-5] rec[-2] rec[-4] rec[-1]
DETECTOR rec[-12] rec[-7] rec[-4]
DETECTOR rec[-14] rec[-3] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-9] rec[-8] rec[-7]
</code></pre>
<p>And it's detector error model</p>
<pre><code>error(0.03185674550515311954) D0 D3
error(0.04975735925829932738) D0 D5
error(0.03809865556508435641) D0 L0
error(0.03059997378373536733) D1 D2
error(0.001338700097173320998) D1 D2 D4
error(0.01911873511075361937) D1 D3
error(0.004005357180252827609) D1 D4 D6
error(0.01126977837777042371) D1 D4 L0
error(0.03874469856294735642) D1 D6
error(0.04914933380809191621) D1 L0
error(0.04425734015754984041) D2
error(0.002673815958446297981) D2 D3
error(0.002673815958446297981) D2 D3 D7
error(0.001338700097173320998) D2 D4 D6
error(0.02293841413224595796) D2 D6
error(0.02165770036624231967) D2 D6 D7
error(0.02230280153587052214) D2 D7
error(0.002673815958446297981) D2 D7 D11
error(0.04733668245378268302) D2 D11
error(0.1110374976726973273) D3
error(0.04360252789818236385) D3 D5
error(0.001338700097173320998) D3 D5 D7
error(0.03557524547345392724) D3 D6
error(0.02676856776605827937) D3 D6 D7
error(0.03432845639209641808) D3 D7
error(0.002673815958446297981) D3 D7 D9
error(0.03997966359665833247) D3 D9
error(0.1662642703886834938) D4
error(0.08897217728373547907) D4 D6 L0
error(0.004005357180252827609) D5 D6
error(0.001338700097173320998) D5 D6 D7
error(0.05570001667892007791) D5 D9
error(0.04975735925829932738) D5 D10
error(0.09227216989561401461) D5 L0
error(0.004005357180252827609) D6 D7 D8
error(0.01584743398905801709) D6 D7 D9
error(0.02867209751539220169) D6 D7 D11
error(0.001338700097173320998) D6 D7 L0
error(0.03874469856294735642) D6 D8
error(0.01584743398905801709) D6 D9
error(0.02867209751539220169) D6 D11
error(0.09985261856122865098) D6 L0
error(0.2093485274052065692) D7
error(0.006000449842759884161) D7 D8 D9
error(0.005333333333333313206) D7 D8 D11
error(0.001338700097173320998) D7 D8 L0
error(0.02101172802650804611) D7 D9
error(0.002673815958446297981) D7 D9 D11
error(0.02867209751539220169) D7 D11
error(0.02870423005727528593) D8 D9
error(0.02169031111111104776) D8 D11
error(0.04854864330815450435) D8 L0
error(0.1298754953638350251) D9
error(0.02553048530927685272) D9 D10
error(0.002673815958446297981) D9 D11
error(0.01911873511075363324) D10 L0
error(0.05632945683604310971) D11
</code></pre>
",stim match graph of circuit with distance 3 only has one node,<error-correction><stim>,1,0,,,"stim match graph of circuit with distance 3 only has one node <p>I have a stim circuit and when I call shortest graphlike error I find that it has distance 3:</p>
<p><code>assert len(shortsurfacecode.circ.shortest_graphlike_error()) == 3</code></p>
<p><strong>When I draw the match-graph-3d it consists of a single node and I don't understand why:</strong></p>
<p><code>shortsurfacecode.circ.detector_error_model().diagram(type=&quot;match-graph-3d&quot;)</code></p>
<p><a href=""https://i.sstatic.net/l6BzY.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/l6BzY.png"" alt=""enter image description here"" /></a></p>
<p>Here is the stim circuit:</p>
<pre><code>QUBIT_COORDS(0, 2) 0
QUBIT_COORDS(1, 1) 1
QUBIT_COORDS(2, 0) 2
QUBIT_COORDS(1, 3) 3
QUBIT_COORDS(2, 2) 4
QUBIT_COORDS(3, 1) 5
QUBIT_COORDS(2, 4) 6
QUBIT_COORDS(3, 3) 7
QUBIT_COORDS(4, 2) 8
R 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 3) 9
R 9
QUBIT_COORDS(1, 2) 10
R 10
QUBIT_COORDS(0, 1) 11
R 11
QUBIT_COORDS(3, 0) 12
R 12
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8 9 10 11 12
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 9 11
M 9 11
X_ERROR(0.01) 10 12
M 10 12
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 1) 13
R 13
QUBIT_COORDS(3, 2) 14
R 14
QUBIT_COORDS(4, 3) 15
R 15
QUBIT_COORDS(1, 4) 16
R 16
X_ERROR(0.01) 13 14 15 16
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
CX 13 5 8 14 6 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 5 8 14 6 16
DEPOLARIZE1(0.01) 0 1 2 3 4 7 15
CX 13 4 5 14 3 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 4 5 14 3 16
DEPOLARIZE1(0.01) 0 1 2 6 7 8 15
CX 13 2 7 14 15 8
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 2 7 14 15 8
DEPOLARIZE1(0.01) 0 1 3 4 5 6 16
CX 13 1 4 14 15 7
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 1 4 14 15 7
DEPOLARIZE1(0.01) 0 2 3 5 6 8 16
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
X_ERROR(0.01) 13 15
M 13 15
X_ERROR(0.01) 14 16
M 14 16
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
R 9 10 11 12
X_ERROR(0.01) 9 10 11 12
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 11
M 11
DETECTOR rec[-1] rec[-8]
X_ERROR(0.01) 12
M 12
DETECTOR rec[-1] rec[-7]
X_ERROR(0.01) 10
M 10
DETECTOR rec[-1] rec[-9]
X_ERROR(0.01) 9
M 9
DETECTOR rec[-1] rec[-12]
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8
M 0 1 2 3 4 5 6 7 8
DETECTOR rec[-11] rec[-9] rec[-6] rec[-8] rec[-5]
DETECTOR rec[-15] rec[-5] rec[-2] rec[-4] rec[-1]
DETECTOR rec[-12] rec[-7] rec[-4]
DETECTOR rec[-14] rec[-3] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-9] rec[-8] rec[-7]
</code></pre>
<p>And it's detector error model</p>
<pre><code>error(0.03185674550515311954) D0 D3
error(0.04975735925829932738) D0 D5
error(0.03809865556508435641) D0 L0
error(0.03059997378373536733) D1 D2
error(0.001338700097173320998) D1 D2 D4
error(0.01911873511075361937) D1 D3
error(0.004005357180252827609) D1 D4 D6
error(0.01126977837777042371) D1 D4 L0
error(0.03874469856294735642) D1 D6
error(0.04914933380809191621) D1 L0
error(0.04425734015754984041) D2
error(0.002673815958446297981) D2 D3
error(0.002673815958446297981) D2 D3 D7
error(0.001338700097173320998) D2 D4 D6
error(0.02293841413224595796) D2 D6
error(0.02165770036624231967) D2 D6 D7
error(0.02230280153587052214) D2 D7
error(0.002673815958446297981) D2 D7 D11
error(0.04733668245378268302) D2 D11
error(0.1110374976726973273) D3
error(0.04360252789818236385) D3 D5
error(0.001338700097173320998) D3 D5 D7
error(0.03557524547345392724) D3 D6
error(0.02676856776605827937) D3 D6 D7
error(0.03432845639209641808) D3 D7
error(0.002673815958446297981) D3 D7 D9
error(0.03997966359665833247) D3 D9
error(0.1662642703886834938) D4
error(0.08897217728373547907) D4 D6 L0
error(0.004005357180252827609) D5 D6
error(0.001338700097173320998) D5 D6 D7
error(0.05570001667892007791) D5 D9
error(0.04975735925829932738) D5 D10
error(0.09227216989561401461) D5 L0
error(0.004005357180252827609) D6 D7 D8
error(0.01584743398905801709) D6 D7 D9
error(0.02867209751539220169) D6 D7 D11
error(0.001338700097173320998) D6 D7 L0
error(0.03874469856294735642) D6 D8
error(0.01584743398905801709) D6 D9
error(0.02867209751539220169) D6 D11
error(0.09985261856122865098) D6 L0
error(0.2093485274052065692) D7
error(0.006000449842759884161) D7 D8 D9
error(0.005333333333333313206) D7 D8 D11
error(0.001338700097173320998) D7 D8 L0
error(0.02101172802650804611) D7 D9
error(0.002673815958446297981) D7 D9 D11
error(0.02867209751539220169) D7 D11
error(0.02870423005727528593) D8 D9
error(0.02169031111111104776) D8 D11
error(0.04854864330815450435) D8 L0
error(0.1298754953638350251) D9
error(0.02553048530927685272) D9 D10
error(0.002673815958446297981) D9 D11
error(0.01911873511075363324) D10 L0
error(0.05632945683604310971) D11
</code></pre>
",qc,stim match graph circuit distance 3 one node p stim circuit call shortest graphlike error find distance 3 p code assert len 3 p strong draw consists single node understand p code quot quot p https nofollow noreferrer img https enter image description p stim circuit pre code 0 2 0 1 1 1 2 0 2 1 3 3 2 2 4 3 1 5 2 4 6 3 3 7 4 2 8 r 0 1 2 3 4 5 6 7 8 2 3 9 r 9 1 2 10 r 10 0 1 11 r 11 3 0 12 r 12 0 1 2 3 4 5 6 7 8 9 10 11 12 h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 cx 9 7 11 1 4 10 tick depolarize1 depolarize2 9 7 11 1 4 10 depolarize1 0 2 3 5 6 8 12 cx 9 6 1 10 11 0 tick depolarize1 depolarize2 9 6 1 10 11 0 depolarize1 2 3 4 5 7 8 12 cx 9 4 3 10 5 12 tick depolarize1 depolarize2 9 4 3 10 5 12 depolarize1 0 1 2 6 7 8 11 cx 9 3 0 10 2 12 tick depolarize1 depolarize2 9 3 0 10 2 12 depolarize1 1 4 5 6 7 8 11 h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 9 11 9 11 10 12 10 12 detector rec detector rec depolarize1 0 1 2 3 4 5 6 7 8 2 1 13 r 13 3 2 14 r 14 4 3 15 r 15 1 4 16 r 16 13 14 15 16 depolarize1 0 1 2 3 4 5 6 7 8 h 13 15 tick depolarize1 13 15 0 1 2 3 4 5 6 7 8 14 16 cx 13 5 8 14 6 16 tick depolarize1 depolarize2 13 5 8 14 6 16 depolarize1 0 1 2 3 4 7 15 cx 13 4 5 14 3 16 tick depolarize1 depolarize2 13 4 5 14 3 16 depolarize1 0 1 2 6 7 8 15 cx 13 2 7 14 15 8 tick depolarize1 depolarize2 13 2 7 14 15 8 depolarize1 0 1 3 4 5 6 16 cx 13 1 4 14 15 7 tick depolarize1 depolarize2 13 1 4 14 15 7 depolarize1 0 2 3 5 6 8 16 h 13 15 tick depolarize1 13 15 0 1 2 3 4 5 6 7 8 14 16 13 15 13 15 14 16 14 16 detector rec detector rec depolarize1 0 1 2 3 4 5 6 7 8 tick r 9 10 11 12 9 10 11 12 depolarize1 0 1 2 3 4 5 6 7 8 tick h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 cx 9 7 11 1 4 10 tick depolarize1 depolarize2 9 7 11 1 4 10 depolarize1 0 2 3 5 6 8 12 cx 9 6 1 10 11 0 tick depolarize1 depolarize2 9 6 1 10 11 0 depolarize1 2 3 4 5 7 8 12 cx 9 4 3 10 5 12 tick depolarize1 depolarize2 9 4 3 10 5 12 depolarize1 0 1 2 6 7 8 11 cx 9 3 0 10 2 12 tick depolarize1 depolarize2 9 3 0 10 2 12 depolarize1 1 4 5 6 7 8 11 h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 11 11 detector rec rec 12 12 detector rec rec 10 10 detector rec rec 9 9 detector rec rec 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 detector rec rec rec rec rec detector rec rec rec rec rec detector rec rec rec detector rec rec rec 0 rec rec rec p detector error model pre code error d0 d3 error d0 d5 error d0 l0 error d1 d2 error d1 d2 d4 error d1 d3 error d1 d4 d6 error d1 d4 l0 error d1 d6 error d1 l0 error d2 error d2 d3 error d2 d3 d7 error d2 d4 d6 error d2 d6 error d2 d6 d7 error d2 d7 error d2 d7 d11 error d2 d11 error d3 error d3 d5 error d3 d5 d7 error d3 d6 error d3 d6 d7 error d3 d7 error d3 d7 d9 error d3 d9 error d4 error d4 d6 l0 error d5 d6 error d5 d6 d7 error d5 d9 error d5 d10 error d5 l0 error d6 d7 d8 error d6 d7 d9 error d6 d7 d11 error d6 d7 l0 error d6 d8 error d6 d9 error d6 d11 error d6 l0 error d7 error d7 d8 d9 error d7 d8 d11 error d7 d8 l0 error d7 d9 error d7 d9 d11 error d7 d11 error d8 d9 error d8 d11 error d8 l0 error d9 error d9 d10 error d9 d11 error d10 l0 error d11,"[(4, 0.013661991), (6, 0.9187669), (12, 0.015522798), (14, 0.026377957), (17, 0.012391423)]"
28751,28754.0,2022-10-31 09:58:56,2,427,"<p>Suppose I have a <code>PauliSumOp</code> as follows:</p>
<pre><code>from qiskit.opflow import X, Z, I, Y

h = (X ^ X ^ I) + (I ^ Y ^ Y) + (Z ^ Z ^ X)
</code></pre>
<p>I would like to go over the Pauli strings and do something with each string (for example, I need to know the positions of nontrivial Pauli matrices, but that's beside the point). I can iterate over <code>h</code>:</p>
<pre><code>for k in h:
    ...
</code></pre>
<p>In this case, <code>k</code> will be a <code>PauliSumOp</code> with one Pauli string and one weight. The trouble is, I can't understand how to get the string itself (for example as a <code>str</code>, but a <code>PauliOp</code> will also do).</p>
<p>Is there a recommended way to extract individual Pauli strings from a <code>PauliSumOp</code>?</p>
",Qiskit: Extract individual Pauli strings from a PauliSumOp,<qiskit>,1,0,,,"Qiskit: Extract individual Pauli strings from a PauliSumOp <p>Suppose I have a <code>PauliSumOp</code> as follows:</p>
<pre><code>from qiskit.opflow import X, Z, I, Y

h = (X ^ X ^ I) + (I ^ Y ^ Y) + (Z ^ Z ^ X)
</code></pre>
<p>I would like to go over the Pauli strings and do something with each string (for example, I need to know the positions of nontrivial Pauli matrices, but that's beside the point). I can iterate over <code>h</code>:</p>
<pre><code>for k in h:
    ...
</code></pre>
<p>In this case, <code>k</code> will be a <code>PauliSumOp</code> with one Pauli string and one weight. The trouble is, I can't understand how to get the string itself (for example as a <code>str</code>, but a <code>PauliOp</code> will also do).</p>
<p>Is there a recommended way to extract individual Pauli strings from a <code>PauliSumOp</code>?</p>
",qc,qiskit extract individual pauli strings paulisumop p suppose code paulisumop follows pre code import x z h x x z z x p would like go pauli strings something string example need know positions nontrivial pauli matrices beside point iterate code h pre code k h p case code k code paulisumop one pauli string one weight trouble ca understand get string example code str code pauliop also p recommended way extract individual pauli strings code paulisumop,"[(0, 0.10982074), (3, 0.18340851), (5, 0.22480685), (8, 0.02382085), (10, 0.060945015), (12, 0.013883365), (14, 0.381534)]"
28790,,2022-11-02 09:57:56,1,95,"<p>I don't understand why the stated equation is not equal to the expectation value of <span class=""math-container"">$m^2$</span>
<a href=""https://i.sstatic.net/jbmM7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jbmM7.png"" alt=""calculation"" /></a></p>
","Nielsen & Chuang, 10th anniversary edition, page 85, equation 2.92",<textbook-and-exercises><nielsen-and-chuang>,1,8,,,"Nielsen & Chuang, 10th anniversary edition, page 85, equation 2.92 <p>I don't understand why the stated equation is not equal to the expectation value of <span class=""math-container"">$m^2$</span>
<a href=""https://i.sstatic.net/jbmM7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jbmM7.png"" alt=""calculation"" /></a></p>
",qc,nielsen chuang 10th anniversary edition page 85 equation p understand stated equation equal expectation value span https nofollow noreferrer img https calculation,"[(3, 0.5862968), (4, 0.36007157), (12, 0.04597024)]"
28860,28894.0,2022-11-07 01:06:27,2,661,"<p>I was curious about the various ways of generating code for MCX when there are multiple controls.  I saw that qiskit provided multiple algorithms for generating code, depending on the number of ancilla qubits provided.</p>
<p>I tried the following experiment:</p>
<pre><code>circuit = QuantumCircuit(7)
circuit.mcx([0, 1, 2, 3, 4], 5, ancilla_qubits=[6], mode='recursion')
circuit.decompose().draw()
</code></pre>
<p>I got the circuit shown below with four gates</p>
<ul>
<li>The first and second gates perform the operating and put the result into q5.</li>
<li>The third is the uncomputation to clean up the ancilla qubit.</li>
</ul>
<p>What is the fourth gate for? I somehow feel like I'm missing some fundamental concept.</p>
<p><a href=""https://i.sstatic.net/UA3yLm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UA3yLm.png"" alt=""Drawing of Qiskit Circuit"" /></a></p>
<hr />
<p>Update.  I also ran my code through <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Density%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B%22Bloch%22%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a>. To look like a Grover oracle, the input bits were initialized to |+&gt;, the output bit to |-&gt;, and the ancilla bit to |0&gt;.  I added in excessive &quot;detectors&quot;. I could see no difference in state caused by the fourth gate. As expected, only the input |11111&gt; had a negative phase shift.</p>
<hr />
<p>Update number 2.  <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C%22X%22%2C%22X%5Et%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Y%5E-t%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Density%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B%22Bloch%22%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a> program with a time-variant dirty ancilla.</p>
","Not understanding gates being generated by MCX in ""recursion"" mode",<qiskit><quantum-gate><quirk><qiskit-runtime>,1,0,,,"Not understanding gates being generated by MCX in ""recursion"" mode <p>I was curious about the various ways of generating code for MCX when there are multiple controls.  I saw that qiskit provided multiple algorithms for generating code, depending on the number of ancilla qubits provided.</p>
<p>I tried the following experiment:</p>
<pre><code>circuit = QuantumCircuit(7)
circuit.mcx([0, 1, 2, 3, 4], 5, ancilla_qubits=[6], mode='recursion')
circuit.decompose().draw()
</code></pre>
<p>I got the circuit shown below with four gates</p>
<ul>
<li>The first and second gates perform the operating and put the result into q5.</li>
<li>The third is the uncomputation to clean up the ancilla qubit.</li>
</ul>
<p>What is the fourth gate for? I somehow feel like I'm missing some fundamental concept.</p>
<p><a href=""https://i.sstatic.net/UA3yLm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UA3yLm.png"" alt=""Drawing of Qiskit Circuit"" /></a></p>
<hr />
<p>Update.  I also ran my code through <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Density%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B%22Bloch%22%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a>. To look like a Grover oracle, the input bits were initialized to |+&gt;, the output bit to |-&gt;, and the ancilla bit to |0&gt;.  I added in excessive &quot;detectors&quot;. I could see no difference in state caused by the fourth gate. As expected, only the input |11111&gt; had a negative phase shift.</p>
<hr />
<p>Update number 2.  <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C%22X%22%2C%22X%5Et%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Y%5E-t%22%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22Density%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B%22Bloch%22%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22Amps5%22%2C1%2C1%2C1%2C1%2C%22Density%22%2C%22Density%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22Bloch%22%2C%22Bloch%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a> program with a time-variant dirty ancilla.</p>
",qc,understanding gates generated mcx recursion mode p curious various ways generating code mcx multiple controls saw qiskit provided multiple algorithms generating code depending number ancilla qubits p tried following experiment pre code circuit quantumcircuit 7 0 1 2 3 4 5 6 p got circuit shown four gates ul li first second gates perform operating put result li third uncomputation clean ancilla p fourth gate somehow feel like missing fundamental p https nofollow noreferrer img https drawing qiskit circuit hr p update also ran code https 7b 22cols 22 3a 5b 5b1 2c1 2c1 2c1 2c1 2c 22x 22 5d 2c 5b 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 5d 2c 5b 22density 22 2c1 2c1 2c1 2c1 2c 22density 22 2c 22density 22 5d 2c 5b 22bloch 22 2c1 2c1 2c1 2c1 2c 22bloch 22 2c 22bloch 22 5d 2c 5b 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 22x 22 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22x 22 2c 22 e2 80 a2 22 5d 2c 5b 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 22x 22 5d 2c 5b 22amps5 22 2c1 2c1 2c1 2c1 2c 22density 22 2c 22density 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22bloch 22 2c 22bloch 22 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22x 22 2c 22 e2 80 a2 22 5d 2c 5b 22amps5 22 2c1 2c1 2c1 2c1 2c 22density 22 2c 22density 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22bloch 22 2c 22bloch 22 5d 5d 7d nofollow noreferrer quirk look like grover oracle input bits initialized gt output bit gt ancilla bit gt added excessive quot detectors quot could see difference state caused fourth gate expected input gt negative phase hr p update number 2 https 7b 22cols 22 3a 5b 5b1 2c1 2c1 2c1 2c1 2c 22x 22 2c 22x 5et 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22y 22 5d 2c 5b 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 5d 2c 5b 22density 22 2c1 2c1 2c1 2c1 2c 22density 22 2c 22density 22 5d 2c 5b 22bloch 22 2c1 2c1 2c1 2c1 2c 22bloch 22 2c 22bloch 22 5d 2c 5b 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 22x 22 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22x 22 2c 22 e2 80 a2 22 5d 2c 5b 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 22x 22 5d 2c 5b 22amps5 22 2c1 2c1 2c1 2c1 2c 22density 22 2c 22density 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22bloch 22 2c 22bloch 22 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22x 22 2c 22 e2 80 a2 22 5d 2c 5b 22amps5 22 2c1 2c1 2c1 2c1 2c 22density 22 2c 22density 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22bloch 22 2c 22bloch 22 5d 5d 7d nofollow noreferrer quirk program dirty,"[(0, 0.012189892), (4, 0.022217207), (6, 0.014271665), (9, 0.016362049), (12, 0.81321687), (14, 0.080651425), (18, 0.040861618)]"
28976,28995.0,2022-11-13 11:39:32,2,268,"<p>As a practice exercise, I am trying to factor <span class=""math-container"">$N=14$</span> using Shor's algorithm. My initial guess is <span class=""math-container"">$a = 5$</span>, and I need a quantum circuit <span class=""math-container"">$U$</span> for:</p>
<p><span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 14 \rangle$</span> for <span class=""math-container"">$y=1, 2, \cdots, 13$</span>, i.e. for <span class=""math-container"">$y=0001, 0010,  ... , 1101$</span>. The modular arithmetic yields the table:</p>
<p>01 0001 0011 <br />
02 0010 0110 <br />
03 0011 1001 <br />
04 0100 1100 <br />
05 0101 0001 <br />
06 0110 0100 <br />
07 0111 0111 <br />
08 1000 1010 <br />
09 1001 1101 <br />
10 1010 0010 <br />
11 1011 0101 <br />
12 1100 1000 <br />
13 1101 1011</p>
<p>The qiskit examples give a circuit for <span class=""math-container"">$N=15$</span>, and
I was able to find a similar circuit for factoring <span class=""math-container"">$N=6$</span> by trial and error. <span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 6 \rangle$</span> is reproduced by:</p>
<p><a href=""https://i.sstatic.net/qaF7A.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qaF7A.jpg"" alt=""enter image description here"" /></a></p>
<p>Clearly, trial and error isn't going to work for <span class=""math-container"">$N=14$</span>. Is there a systematic method that will provide the circuit I am looking for?</p>
",How to factor $N=14$ with Shor's algorithm?,<quantum-algorithms><circuit-construction><shors-algorithm>,2,1,,,"How to factor $N=14$ with Shor's algorithm? <p>As a practice exercise, I am trying to factor <span class=""math-container"">$N=14$</span> using Shor's algorithm. My initial guess is <span class=""math-container"">$a = 5$</span>, and I need a quantum circuit <span class=""math-container"">$U$</span> for:</p>
<p><span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 14 \rangle$</span> for <span class=""math-container"">$y=1, 2, \cdots, 13$</span>, i.e. for <span class=""math-container"">$y=0001, 0010,  ... , 1101$</span>. The modular arithmetic yields the table:</p>
<p>01 0001 0011 <br />
02 0010 0110 <br />
03 0011 1001 <br />
04 0100 1100 <br />
05 0101 0001 <br />
06 0110 0100 <br />
07 0111 0111 <br />
08 1000 1010 <br />
09 1001 1101 <br />
10 1010 0010 <br />
11 1011 0101 <br />
12 1100 1000 <br />
13 1101 1011</p>
<p>The qiskit examples give a circuit for <span class=""math-container"">$N=15$</span>, and
I was able to find a similar circuit for factoring <span class=""math-container"">$N=6$</span> by trial and error. <span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 6 \rangle$</span> is reproduced by:</p>
<p><a href=""https://i.sstatic.net/qaF7A.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qaF7A.jpg"" alt=""enter image description here"" /></a></p>
<p>Clearly, trial and error isn't going to work for <span class=""math-container"">$N=14$</span>. Is there a systematic method that will provide the circuit I am looking for?</p>
",qc,factor shor algorithm p practice exercise trying factor span using shor algorithm initial guess span 5 need quantum circuit span u p span 5 mod 14 span 2 13 span 0010 1101 modular arithmetic yields table p 01 0001 0011 br 02 0010 0110 br 03 0011 1001 br 04 0100 1100 br 05 0101 0001 br 06 0110 0100 br 07 0111 0111 br 08 1000 1010 br 09 1001 1101 br 10 1010 0010 br 11 1011 0101 br 12 1100 1000 br 13 1101 1011 p qiskit examples give circuit span able find similar circuit factoring span trial error span 5 mod 6 reproduced p https nofollow noreferrer img https enter image description p clearly trial error going work span systematic method provide circuit looking,"[(3, 0.19624029), (4, 0.2456238), (6, 0.12288077), (7, 0.102600046), (8, 0.059165563), (12, 0.06665884), (13, 0.16601714), (17, 0.039722923)]"
29002,,2022-11-15 21:59:26,1,212,"<p>I was trying to run a QAOA job using the below script:</p>
<pre><code>job = provider.runtime.run(
    program_id=program_id,
    options=options,
    inputs=runtime_inputs,
)

from qiskit.tools import job_monitor
job_monitor(job)
</code></pre>
<p>But I'm getting the below error:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Cell In [24], line 73
     65 #Now, we run the program using the provider.
     67 job = provider.runtime.run(
     68     program_id=program_id,
     69     options=options,
     70     inputs=runtime_inputs,
     71 )
---&gt; 73 job_monitor(job)
     75 #Job Status: job has successfully run
     77 print(f&quot;Job id: {job.job_id()}&quot;)

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:89, in job_monitor(job, interval, quiet, output, line_discipline)
     86 else:
     87     _interval_set = True
---&gt; 89 _text_checker(
     90     job, interval, _interval_set, quiet=quiet, output=output, line_discipline=line_discipline
     91 )

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:49, in _text_checker(job, interval, _interval_set, quiet, output, line_discipline)
     46 msg = status.value
     48 if status.name == &quot;QUEUED&quot;:
---&gt; 49     msg += &quot; (%s)&quot; % job.queue_position()
     50     if job.queue_position() is None:
     51         interval = 2

AttributeError: 'RuntimeJob' object has no attribute 'queue_position'
</code></pre>
<p>In the IBM portal, it is showing my job is queued, but my code is failing at job_monitor(job)</p>
<p><a href=""https://i.sstatic.net/aKKpv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/aKKpv.png"" alt=""enter image description here"" /></a></p>
<p>Can anyone suggest what can be done for this issue?</p>
",'RuntimeJob' object has no attribute 'queue_position',<qiskit><ibm-quantum-devices><qiskit-runtime>,0,4,,,"'RuntimeJob' object has no attribute 'queue_position' <p>I was trying to run a QAOA job using the below script:</p>
<pre><code>job = provider.runtime.run(
    program_id=program_id,
    options=options,
    inputs=runtime_inputs,
)

from qiskit.tools import job_monitor
job_monitor(job)
</code></pre>
<p>But I'm getting the below error:</p>
<pre><code>AttributeError                            Traceback (most recent call last)
Cell In [24], line 73
     65 #Now, we run the program using the provider.
     67 job = provider.runtime.run(
     68     program_id=program_id,
     69     options=options,
     70     inputs=runtime_inputs,
     71 )
---&gt; 73 job_monitor(job)
     75 #Job Status: job has successfully run
     77 print(f&quot;Job id: {job.job_id()}&quot;)

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:89, in job_monitor(job, interval, quiet, output, line_discipline)
     86 else:
     87     _interval_set = True
---&gt; 89 _text_checker(
     90     job, interval, _interval_set, quiet=quiet, output=output, line_discipline=line_discipline
     91 )

File ~/venv/lib/python3.9/site-packages/qiskit/tools/monitor/job_monitor.py:49, in _text_checker(job, interval, _interval_set, quiet, output, line_discipline)
     46 msg = status.value
     48 if status.name == &quot;QUEUED&quot;:
---&gt; 49     msg += &quot; (%s)&quot; % job.queue_position()
     50     if job.queue_position() is None:
     51         interval = 2

AttributeError: 'RuntimeJob' object has no attribute 'queue_position'
</code></pre>
<p>In the IBM portal, it is showing my job is queued, but my code is failing at job_monitor(job)</p>
<p><a href=""https://i.sstatic.net/aKKpv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/aKKpv.png"" alt=""enter image description here"" /></a></p>
<p>Can anyone suggest what can be done for this issue?</p>
",qc,object attribute p trying run qaoa job using script pre code job import job p getting error pre code attributeerror traceback recent call last cell 24 line 73 65 run program using provider 67 job 68 69 70 71 gt 73 job 75 job status job successfully run 77 print f quot job id quot file job interval quiet output 86 else 87 true gt 89 90 job interval 91 file job interval quiet output 46 msg 48 quot queued quot gt 49 msg quot quot 50 none 51 interval 2 attributeerror object attribute p ibm portal showing job queued code failing job p https nofollow noreferrer img https enter image description p anyone suggest done issue,"[(0, 0.5525913), (4, 0.12088762), (5, 0.057393465), (6, 0.0420615), (12, 0.025638651), (16, 0.021462068), (19, 0.17077897)]"
29004,29006.0,2022-11-16 00:21:36,0,233,"<p>I have a GHZ state. I want to measure the third qubit in Hadamard basis, after which the state left behind should be a maximally entangled state <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state#Pairwise_entanglement"" rel=""nofollow noreferrer"">as mentioned here</a>.</p>
<p>But when I measure the third qubit, the entire state collapses into either <span class=""math-container"">$|000\rangle$</span> or <span class=""math-container"">$|{111}\rangle$</span></p>
<p>I am representing the quantum state as a statevector then measuring that.</p>
<pre><code>#Create a circuit to generate GHZ state
circ = QuantumCircuit(3)

circ.h(0)
circ.cx(0, 1)
circ.cx(0, 2)

#Get the statevector from circuit
ghz_statevec = Statevector(circ)

H_matrix = 1/np.sqrt(2)*np.array([[1, 1],
                                [1,-1]])

#To measure in X basis, apply the Hadamard transform
evolved_state = ghz_statevec.evolve(H_matrix, [0])

evolved_state.draw('latex')
</code></pre>
<p>The output after applying Hadamard to the third qubit is <span class=""math-container"">$ \frac{1}{2} |{000}\rangle + \frac{1}{2} \ |001\rangle + \frac{1}{2} |110\rangle - \frac{1}{2} |111\rangle$</span></p>
<pre><code>outcome, state = ghz_statevec.measure([0])

state.draw('latex')
</code></pre>
<p>But the state after measuring the third qubit is <span class=""math-container"">$|000\rangle$</span></p>
<p>When I use the circuit representation and do measurement, I get the expected outcome but not in the statevector representation.</p>
",Qiskit - Statevector measurement of single qubit in GHZ state collapses the entire state,<qiskit><measurement>,2,0,,,"Qiskit - Statevector measurement of single qubit in GHZ state collapses the entire state <p>I have a GHZ state. I want to measure the third qubit in Hadamard basis, after which the state left behind should be a maximally entangled state <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state#Pairwise_entanglement"" rel=""nofollow noreferrer"">as mentioned here</a>.</p>
<p>But when I measure the third qubit, the entire state collapses into either <span class=""math-container"">$|000\rangle$</span> or <span class=""math-container"">$|{111}\rangle$</span></p>
<p>I am representing the quantum state as a statevector then measuring that.</p>
<pre><code>#Create a circuit to generate GHZ state
circ = QuantumCircuit(3)

circ.h(0)
circ.cx(0, 1)
circ.cx(0, 2)

#Get the statevector from circuit
ghz_statevec = Statevector(circ)

H_matrix = 1/np.sqrt(2)*np.array([[1, 1],
                                [1,-1]])

#To measure in X basis, apply the Hadamard transform
evolved_state = ghz_statevec.evolve(H_matrix, [0])

evolved_state.draw('latex')
</code></pre>
<p>The output after applying Hadamard to the third qubit is <span class=""math-container"">$ \frac{1}{2} |{000}\rangle + \frac{1}{2} \ |001\rangle + \frac{1}{2} |110\rangle - \frac{1}{2} |111\rangle$</span></p>
<pre><code>outcome, state = ghz_statevec.measure([0])

state.draw('latex')
</code></pre>
<p>But the state after measuring the third qubit is <span class=""math-container"">$|000\rangle$</span></p>
<p>When I use the circuit representation and do measurement, I get the expected outcome but not in the statevector representation.</p>
",qc,qiskit statevector measurement single qubit ghz state collapses entire state p ghz state want measure third qubit hadamard basis state left behind maximally entangled state https e2 80 93horne e2 80 nofollow noreferrer mentioned p measure third qubit entire state collapses either span span 111 p representing quantum state statevector measuring pre code create circuit generate ghz state circ quantumcircuit 3 0 0 1 0 2 get statevector circuit statevector circ 2 1 1 1 measure x basis apply hadamard transform 0 p output applying hadamard third qubit span 1 2 000 1 2 1 2 1 2 pre code outcome state 0 p state measuring third qubit span p use circuit representation measurement get expected outcome statevector,"[(0, 0.15120026), (2, 0.1713125), (3, 0.057421952), (4, 0.05458927), (12, 0.036564432), (18, 0.51399004)]"
29007,29008.0,2022-11-16 05:02:34,1,899,"<p><a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#5.-Solving-Sudoku-using-Grover%27s-Algorithm-"" rel=""nofollow noreferrer"">The Qiskit tutorial</a> shows the application of Grover's Algorithm to solve a 2x2 sudoku. However, I don't understand how why its diffuser works as intended. Precisely, why the control bit is on a &quot;variable&quot; qubit (labeled as &quot;v&quot;) rather than on the auxiliary qubit (labeled as &quot;out_0&quot;)?</p>
<pre><code>var_qubits = QuantumRegister(4, name='v')
clause_qubits = QuantumRegister(4, name='c')
output_qubit = QuantumRegister(1, name='out')
cbits = ClassicalRegister(4, name='cbits')
qc = QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def sudoku_oracle(qc, clause_list, clause_qubits):
# Compute clauses
    i = 0
    for clause in clause_list:
       XOR(qc, clause[0], clause[1], clause_qubits[I])
       i += 1

# Flip 'output' bit if all clauses are satisfied
    qc.mct(clause_qubits, output_qubit)

# Uncompute clauses to reset clause-checking bits to 0
    i = 0
    for clause in clause_list:
        XOR(qc, clause[0], clause[1], clause_qubits[I])
        i += 1

sudoku_oracle(qc, clause_list, clause_qubits)
qc.draw()

Define difusser:
def diffuser(nqubits):
    qc = QuantumCircuit(nqubits)
# Apply transformation |s&gt; -&gt; |00..0&gt; (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
# Apply transformation |00..0&gt; -&gt; |11..1&gt; (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit) 
# Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
# Apply transformation |11..1&gt; -&gt; |00..0&gt;
    for qubit in range(nqubits):
       qc.x(qubit)
# Apply transformation |00..0&gt; -&gt; |s&gt;
    for qubit in range(nqubits):
       qc.h(qubit)
# We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = &quot;U<span class=""math-container"">$_s$</span>&quot;
    return U_s

#Put everything together
# Initialize 'out0' in state |-&gt;
qc.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s&gt;
qc.h(var_qubits)
qc.barrier()  # for visual separation

## First Iteration
# Apply our oracle
sudoku_oracle(qc, clause_list, clause_qubits)
qc.barrier()  # for visual separation
# Apply our diffuser
qc.append(diffuser(4), [0,1,2,3])

## Second Iteration
sudoku_oracle(qc, clause_list, clause_qubits)
qc.barrier()  # for visual separation
# Apply our diffuser
qc.append(diffuser(4), [0,1,2,3])

# Measure the variable qubits
qc.measure(var_qubits, cbits)

qc.draw(fold=-1)
</code></pre>
<p>The whole circuit looks like this:<a href=""https://i.sstatic.net/O0XcA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/O0XcA.png"" alt=""enter image description here"" /></a></p>
<p>The diffuser (U_s) looks like this:<a href=""https://i.sstatic.net/PfPvt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PfPvt.png"" alt=""enter image description here"" /></a></p>
",Solve sudoku using Grover's algorithm,<qiskit><programming><grovers-algorithm><applications>,1,0,,,"Solve sudoku using Grover's algorithm <p><a href=""https://qiskit.org/textbook/ch-algorithms/grover.html#5.-Solving-Sudoku-using-Grover%27s-Algorithm-"" rel=""nofollow noreferrer"">The Qiskit tutorial</a> shows the application of Grover's Algorithm to solve a 2x2 sudoku. However, I don't understand how why its diffuser works as intended. Precisely, why the control bit is on a &quot;variable&quot; qubit (labeled as &quot;v&quot;) rather than on the auxiliary qubit (labeled as &quot;out_0&quot;)?</p>
<pre><code>var_qubits = QuantumRegister(4, name='v')
clause_qubits = QuantumRegister(4, name='c')
output_qubit = QuantumRegister(1, name='out')
cbits = ClassicalRegister(4, name='cbits')
qc = QuantumCircuit(var_qubits, clause_qubits, output_qubit, cbits)

def sudoku_oracle(qc, clause_list, clause_qubits):
# Compute clauses
    i = 0
    for clause in clause_list:
       XOR(qc, clause[0], clause[1], clause_qubits[I])
       i += 1

# Flip 'output' bit if all clauses are satisfied
    qc.mct(clause_qubits, output_qubit)

# Uncompute clauses to reset clause-checking bits to 0
    i = 0
    for clause in clause_list:
        XOR(qc, clause[0], clause[1], clause_qubits[I])
        i += 1

sudoku_oracle(qc, clause_list, clause_qubits)
qc.draw()

Define difusser:
def diffuser(nqubits):
    qc = QuantumCircuit(nqubits)
# Apply transformation |s&gt; -&gt; |00..0&gt; (H-gates)
    for qubit in range(nqubits):
        qc.h(qubit)
# Apply transformation |00..0&gt; -&gt; |11..1&gt; (X-gates)
    for qubit in range(nqubits):
        qc.x(qubit) 
# Do multi-controlled-Z gate
    qc.h(nqubits-1)
    qc.mct(list(range(nqubits-1)), nqubits-1)  # multi-controlled-toffoli
    qc.h(nqubits-1)
# Apply transformation |11..1&gt; -&gt; |00..0&gt;
    for qubit in range(nqubits):
       qc.x(qubit)
# Apply transformation |00..0&gt; -&gt; |s&gt;
    for qubit in range(nqubits):
       qc.h(qubit)
# We will return the diffuser as a gate
    U_s = qc.to_gate()
    U_s.name = &quot;U<span class=""math-container"">$_s$</span>&quot;
    return U_s

#Put everything together
# Initialize 'out0' in state |-&gt;
qc.initialize([1, -1]/np.sqrt(2), output_qubit)

# Initialize qubits in state |s&gt;
qc.h(var_qubits)
qc.barrier()  # for visual separation

## First Iteration
# Apply our oracle
sudoku_oracle(qc, clause_list, clause_qubits)
qc.barrier()  # for visual separation
# Apply our diffuser
qc.append(diffuser(4), [0,1,2,3])

## Second Iteration
sudoku_oracle(qc, clause_list, clause_qubits)
qc.barrier()  # for visual separation
# Apply our diffuser
qc.append(diffuser(4), [0,1,2,3])

# Measure the variable qubits
qc.measure(var_qubits, cbits)

qc.draw(fold=-1)
</code></pre>
<p>The whole circuit looks like this:<a href=""https://i.sstatic.net/O0XcA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/O0XcA.png"" alt=""enter image description here"" /></a></p>
<p>The diffuser (U_s) looks like this:<a href=""https://i.sstatic.net/PfPvt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PfPvt.png"" alt=""enter image description here"" /></a></p>
",qc,solve sudoku using grover algorithm p https nofollow noreferrer qiskit tutorial shows application grover algorithm solve 2x2 sudoku however understand diffuser works intended precisely control bit quot variable quot qubit labeled quot v quot rather auxiliary qubit labeled quot quot pre code quantumregister 4 v quantumregister 4 c quantumregister 1 cbits classicalregister 4 qc quantumcircuit cbits def qc compute clauses 0 clause xor qc clause 0 clause 1 1 flip bit clauses satisfied uncompute clauses reset bits 0 0 clause xor qc clause 0 clause 1 1 qc define difusser def diffuser nqubits qc quantumcircuit nqubits apply transformation gt gt 0 gt qubit range nqubits qubit apply transformation 0 gt gt 1 gt qubit range nqubits qubit gate list range apply transformation 1 gt gt 0 gt qubit range nqubits qubit apply transformation 0 gt gt gt qubit range nqubits qubit return diffuser gate quot u span quot return put everything together initialize state gt 1 2 initialize qubits state gt visual separation first iteration apply oracle qc visual separation apply diffuser diffuser 4 second iteration qc visual separation apply diffuser diffuser 4 measure variable qubits cbits p whole circuit looks like https nofollow noreferrer img https enter image description p diffuser looks like https nofollow noreferrer img https enter image description,"[(0, 0.29449287), (2, 0.10350977), (4, 0.15935251), (7, 0.042370982), (9, 0.10904661), (12, 0.024601161), (18, 0.22249974), (19, 0.043549564)]"
29055,,2022-11-17 15:42:20,2,96,"<p>I am learning quantum chemistry at the moment and I'm trying to understand the Hamiltonian generated by the <a href=""https://www.google.com/search?as_q=openfermion"" rel=""nofollow noreferrer"">OpenFermion</a> package. I'm now stuck at understanding how openfermion calculates the coefficients in second quantization Hamiltonians.</p>
<p>Take the for Hydrogen molecule for example. My understanding is that the coefficients</p>
<blockquote>
<ul>
<li><span class=""math-container"">$h_{00}$</span>, represents electron 1 in 1s orbit with spin up.</li>
<li><span class=""math-container"">$h_{11}$</span>, represents electron 1 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{22}$</span>, represents electron 2 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{33}$</span>, represents electron 2 in 1s orbit with spin down.</li>
</ul>
</blockquote>
<p>As the wavefunction of 1s orbits takes the form</p>
<p><span class=""math-container"">$$\psi_{1s}(r) = \frac{1}{\sqrt{\pi}}e^{-r}$$</span></p>
<p>The <span class=""math-container"">$h_{ii}$</span> should be</p>
<p><span class=""math-container"">\begin{equation}
2\pi \int_0^{\infty}\int_0^{\pi}\psi_{1s}(r)\left(-\frac{1}{2}\nabla^2-\frac{1}{r}-\frac{1}{\sqrt{r^2+R^2-2r R\cos\theta}}\right)\psi_{1s}(r)r^2 \sin\theta d\theta dr
= -1.07123
\end{equation}</span>
when <span class=""math-container"">$R = 0.74$</span> Bohr radius, which does not match with openfermion's
<span class=""math-container"">\begin{align}
h_{00} &amp;= h_{11} = -1.2524635735648988\\
h_{22} &amp;= h_{33} = -0.47594871522096416\\
\end{align}</span></p>
<p>Can anyone tell me why I am wrong?</p>
",Reproducing Hydrogen Molecule Hamiltonian in OpenFermion,<chemistry><openfermion>,0,3,,,"Reproducing Hydrogen Molecule Hamiltonian in OpenFermion <p>I am learning quantum chemistry at the moment and I'm trying to understand the Hamiltonian generated by the <a href=""https://www.google.com/search?as_q=openfermion"" rel=""nofollow noreferrer"">OpenFermion</a> package. I'm now stuck at understanding how openfermion calculates the coefficients in second quantization Hamiltonians.</p>
<p>Take the for Hydrogen molecule for example. My understanding is that the coefficients</p>
<blockquote>
<ul>
<li><span class=""math-container"">$h_{00}$</span>, represents electron 1 in 1s orbit with spin up.</li>
<li><span class=""math-container"">$h_{11}$</span>, represents electron 1 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{22}$</span>, represents electron 2 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{33}$</span>, represents electron 2 in 1s orbit with spin down.</li>
</ul>
</blockquote>
<p>As the wavefunction of 1s orbits takes the form</p>
<p><span class=""math-container"">$$\psi_{1s}(r) = \frac{1}{\sqrt{\pi}}e^{-r}$$</span></p>
<p>The <span class=""math-container"">$h_{ii}$</span> should be</p>
<p><span class=""math-container"">\begin{equation}
2\pi \int_0^{\infty}\int_0^{\pi}\psi_{1s}(r)\left(-\frac{1}{2}\nabla^2-\frac{1}{r}-\frac{1}{\sqrt{r^2+R^2-2r R\cos\theta}}\right)\psi_{1s}(r)r^2 \sin\theta d\theta dr
= -1.07123
\end{equation}</span>
when <span class=""math-container"">$R = 0.74$</span> Bohr radius, which does not match with openfermion's
<span class=""math-container"">\begin{align}
h_{00} &amp;= h_{11} = -1.2524635735648988\\
h_{22} &amp;= h_{33} = -0.47594871522096416\\
\end{align}</span></p>
<p>Can anyone tell me why I am wrong?</p>
",qc,reproducing hydrogen molecule hamiltonian openfermion p learning quantum chemistry moment trying understand hamiltonian generated https nofollow noreferrer openfermion package stuck understanding openfermion calculates coefficients second quantization p take hydrogen molecule example understanding coefficients blockquote ul li span 00 represents electron 1 1s orbit spin li span 11 represents electron 1 1s orbit spin li span 22 represents electron 2 1s orbit spin li span 33 represents electron 2 1s orbit spin p wavefunction 1s orbits takes form p span 1s r 1 p span ii p span equation 1s r 1 2 1 r 1 1s r dr equation span r bohr radius match openfermion span align 00 amp 11 22 amp 33 align p anyone tell wrong,"[(1, 0.039787408), (2, 0.125357), (3, 0.37252584), (4, 0.05850182), (6, 0.03307925), (7, 0.1542187), (8, 0.107961245), (12, 0.017579742), (15, 0.07197446), (17, 0.01815252)]"
29036,29049.0,2022-11-17 23:11:47,8,229,"<p>The generalized <a href=""https://en.wikipedia.org/wiki/W_state"" rel=""nofollow noreferrer"">W state</a>:</p>
<p><span class=""math-container"">$$W_n=\frac{1}{\sqrt{n}}(|100\cdots 0\rangle + |010\cdots 0\rangle + \ldots + |00\cdots 01\rangle)$$</span></p>
<p>is often thought of as the uniform superposition over all &quot;<a href=""https://en.wikipedia.org/wiki/One-hot"" rel=""nofollow noreferrer"">one-hot</a>&quot; basis vectors, as each such vector has a single qubit in the <span class=""math-container"">$|1\rangle$</span> state with all others in the <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>Reviewing <a href=""https://quantumcomputing.stackexchange.com/questions/4350/general-construction-of-w-n-state"">this question</a> it appears that the generalized W state on <span class=""math-container"">$n$</span> qubits can be prepare from the all-zeroes ket with roughly a linear number of non-Clifford gates.  This is in some contrast to the generalized <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""nofollow noreferrer"">GHZ state</a>/cat state, which can similarly be prepared but only with a single Hadamard and a linear number of CNOT/SWAP gates.</p>
<p>In considering <a href=""https://quantumcomputing.stackexchange.com/questions/29001/types-of-states-that-can-be-created-with-a-given-number-of-entangling-gates?noredirect=1&amp;lq=1"">this question</a> I proposed that a generalized superposition over all &quot;two-hot&quot; basis states, e.g.:</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{n(n-1)/2}}(|1100\cdots 0\rangle + |1010\cdots 0\rangle + \ldots + |0\cdots 0011\rangle)$$</span></p>
<p>may require a quadratic number of non-Clifford gates to prepare, starting from the all-zeroes ket.  My intuition is that there are <span class=""math-container"">$n\choose 2$</span> such states, and accordingly there may be a quadratic number of gates required.</p>
<blockquote>
<p>Is this guess correct?  In general, does it take a minimum of roughly <span class=""math-container"">$n\choose k$</span> gates to prepare a uniform superposition of all &quot;<span class=""math-container"">$k$</span>-hot&quot; vectors on <span class=""math-container"">$n$</span> qubits, starting from some canonical state such as the all-zeroes ket?</p>
</blockquote>
<p>This question is borne out of idle curiosity more than anything, to be honest, but it is perhaps interesting to ponder simple states that are a bit hard - but not too hard - to prepare, especially now in the NISQ era where generalized GHZ states are often prepared as test cases, as they are the most sensitive to decoherence, but such cat states can nonetheless be produced with &quot;easier&quot; Clifford gates.</p>
<p><strong>EDIT</strong></p>
<p>Hmmm... it appears that what I call the &quot;<span class=""math-container"">$k$</span>-hot&quot; state is also known as a Dicke state.  In &quot;<a href=""https://arxiv.org/abs/1904.07358"" rel=""nofollow noreferrer"">Deterministic Preparation of Dicke States</a>&quot; by Andreas Bärtschi and Stephan Eidenbenz can prepare just such a state with only <span class=""math-container"">$O(nk)$</span> gates. This <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22Chance%22%2C%22Chance%22%2C%22Chance%22%2C%22Chance%22%2C%22Chance%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%7Ed6b5%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%7Ef38g%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C%22%7Edcqq%22%2C%22%E2%80%A2%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22%7Er6tk%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C%22%7Eq81a%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%7Ejrlp%22%2C%22%E2%80%A2%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22%7Etue7%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22%7E7h3f%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22%7Eok6s%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Eok6s%22%2C%22name%22%3A%22%E2%88%9A1%2F2%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%C2%BD%2C-%E2%88%9A%C2%BD%7D%2C%7B%E2%88%9A%C2%BD%2C%E2%88%9A%C2%BD%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Etue7%22%2C%22name%22%3A%22%E2%88%9A1%2F3%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%93%2C-%E2%88%9A%E2%85%94%7D%2C%7B%E2%88%9A%E2%85%94%2C%E2%88%9A%E2%85%93%7D%7D%22%7D%2C%7B%22id%22%3A%22%7E7h3f%22%2C%22name%22%3A%22%E2%88%9A2%2F3%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%94%2C-%E2%88%9A%E2%85%93%7D%2C%7B%E2%88%9A%E2%85%93%2C%E2%88%9A%E2%85%94%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Er6tk%22%2C%22name%22%3A%22%E2%88%9A1%2F4%22%2C%22matrix%22%3A%22%7B%7B%C2%BD%2C-%E2%88%9A%C2%BE%7D%2C%7B%E2%88%9A%C2%BE%2C%C2%BD%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Eq81a%22%2C%22name%22%3A%22%E2%88%9A2%2F4%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%C2%BD%2C-%E2%88%9A%C2%BD%7D%2C%7B%E2%88%9A%C2%BD%2C%E2%88%9A%C2%BD%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Ejrlp%22%2C%22name%22%3A%22%E2%88%9A3%2F4%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%C2%BE%2C-%C2%BD%7D%2C%7B%C2%BD%2C%E2%88%9A%C2%BE%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Ed6b5%22%2C%22name%22%3A%22%E2%88%9A1%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%95%2C-%E2%88%9A%E2%85%98%7D%2C%7B%E2%88%9A%E2%85%98%2C%E2%88%9A%E2%85%95%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Ef38g%22%2C%22name%22%3A%22%E2%88%9A2%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%96%2C-%E2%88%9A%E2%85%97%7D%2C%7B%E2%88%9A%E2%85%97%2C%E2%88%9A%E2%85%96%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Edcqq%22%2C%22name%22%3A%22%E2%88%9A3%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%97%2C-%E2%88%9A%E2%85%96%7D%2C%7B%E2%88%9A%E2%85%96%2C%E2%88%9A%E2%85%97%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Eit96%22%2C%22name%22%3A%22%E2%88%9A4%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%98%2C-%E2%88%9A%E2%85%95%7D%2C%7B%E2%88%9A%E2%85%95%2C%E2%88%9A%E2%85%98%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk circuit</a> from their paper gives the <span class=""math-container"">$3$</span>-hot Dicke state on five qubits.</p>
","What is the minimum number of non-Clifford gates does it take to prepare a superposition over all ""two-hot"" basis vectors?",<quantum-state><gate-synthesis><w-state>,1,3,,,"What is the minimum number of non-Clifford gates does it take to prepare a superposition over all ""two-hot"" basis vectors? <p>The generalized <a href=""https://en.wikipedia.org/wiki/W_state"" rel=""nofollow noreferrer"">W state</a>:</p>
<p><span class=""math-container"">$$W_n=\frac{1}{\sqrt{n}}(|100\cdots 0\rangle + |010\cdots 0\rangle + \ldots + |00\cdots 01\rangle)$$</span></p>
<p>is often thought of as the uniform superposition over all &quot;<a href=""https://en.wikipedia.org/wiki/One-hot"" rel=""nofollow noreferrer"">one-hot</a>&quot; basis vectors, as each such vector has a single qubit in the <span class=""math-container"">$|1\rangle$</span> state with all others in the <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>Reviewing <a href=""https://quantumcomputing.stackexchange.com/questions/4350/general-construction-of-w-n-state"">this question</a> it appears that the generalized W state on <span class=""math-container"">$n$</span> qubits can be prepare from the all-zeroes ket with roughly a linear number of non-Clifford gates.  This is in some contrast to the generalized <a href=""https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state"" rel=""nofollow noreferrer"">GHZ state</a>/cat state, which can similarly be prepared but only with a single Hadamard and a linear number of CNOT/SWAP gates.</p>
<p>In considering <a href=""https://quantumcomputing.stackexchange.com/questions/29001/types-of-states-that-can-be-created-with-a-given-number-of-entangling-gates?noredirect=1&amp;lq=1"">this question</a> I proposed that a generalized superposition over all &quot;two-hot&quot; basis states, e.g.:</p>
<p><span class=""math-container"">$$\frac{1}{\sqrt{n(n-1)/2}}(|1100\cdots 0\rangle + |1010\cdots 0\rangle + \ldots + |0\cdots 0011\rangle)$$</span></p>
<p>may require a quadratic number of non-Clifford gates to prepare, starting from the all-zeroes ket.  My intuition is that there are <span class=""math-container"">$n\choose 2$</span> such states, and accordingly there may be a quadratic number of gates required.</p>
<blockquote>
<p>Is this guess correct?  In general, does it take a minimum of roughly <span class=""math-container"">$n\choose k$</span> gates to prepare a uniform superposition of all &quot;<span class=""math-container"">$k$</span>-hot&quot; vectors on <span class=""math-container"">$n$</span> qubits, starting from some canonical state such as the all-zeroes ket?</p>
</blockquote>
<p>This question is borne out of idle curiosity more than anything, to be honest, but it is perhaps interesting to ponder simple states that are a bit hard - but not too hard - to prepare, especially now in the NISQ era where generalized GHZ states are often prepared as test cases, as they are the most sensitive to decoherence, but such cat states can nonetheless be produced with &quot;easier&quot; Clifford gates.</p>
<p><strong>EDIT</strong></p>
<p>Hmmm... it appears that what I call the &quot;<span class=""math-container"">$k$</span>-hot&quot; state is also known as a Dicke state.  In &quot;<a href=""https://arxiv.org/abs/1904.07358"" rel=""nofollow noreferrer"">Deterministic Preparation of Dicke States</a>&quot; by Andreas Bärtschi and Stephan Eidenbenz can prepare just such a state with only <span class=""math-container"">$O(nk)$</span> gates. This <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22Chance%22%2C%22Chance%22%2C%22Chance%22%2C%22Chance%22%2C%22Chance%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%7Ed6b5%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%7Ef38g%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C%22%7Edcqq%22%2C%22%E2%80%A2%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22%7Er6tk%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C%22%7Eq81a%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%7Ejrlp%22%2C%22%E2%80%A2%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22%7Etue7%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22%7E7h3f%22%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22%7Eok6s%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance5%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Eok6s%22%2C%22name%22%3A%22%E2%88%9A1%2F2%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%C2%BD%2C-%E2%88%9A%C2%BD%7D%2C%7B%E2%88%9A%C2%BD%2C%E2%88%9A%C2%BD%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Etue7%22%2C%22name%22%3A%22%E2%88%9A1%2F3%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%93%2C-%E2%88%9A%E2%85%94%7D%2C%7B%E2%88%9A%E2%85%94%2C%E2%88%9A%E2%85%93%7D%7D%22%7D%2C%7B%22id%22%3A%22%7E7h3f%22%2C%22name%22%3A%22%E2%88%9A2%2F3%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%94%2C-%E2%88%9A%E2%85%93%7D%2C%7B%E2%88%9A%E2%85%93%2C%E2%88%9A%E2%85%94%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Er6tk%22%2C%22name%22%3A%22%E2%88%9A1%2F4%22%2C%22matrix%22%3A%22%7B%7B%C2%BD%2C-%E2%88%9A%C2%BE%7D%2C%7B%E2%88%9A%C2%BE%2C%C2%BD%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Eq81a%22%2C%22name%22%3A%22%E2%88%9A2%2F4%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%C2%BD%2C-%E2%88%9A%C2%BD%7D%2C%7B%E2%88%9A%C2%BD%2C%E2%88%9A%C2%BD%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Ejrlp%22%2C%22name%22%3A%22%E2%88%9A3%2F4%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%C2%BE%2C-%C2%BD%7D%2C%7B%C2%BD%2C%E2%88%9A%C2%BE%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Ed6b5%22%2C%22name%22%3A%22%E2%88%9A1%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%95%2C-%E2%88%9A%E2%85%98%7D%2C%7B%E2%88%9A%E2%85%98%2C%E2%88%9A%E2%85%95%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Ef38g%22%2C%22name%22%3A%22%E2%88%9A2%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%96%2C-%E2%88%9A%E2%85%97%7D%2C%7B%E2%88%9A%E2%85%97%2C%E2%88%9A%E2%85%96%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Edcqq%22%2C%22name%22%3A%22%E2%88%9A3%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%97%2C-%E2%88%9A%E2%85%96%7D%2C%7B%E2%88%9A%E2%85%96%2C%E2%88%9A%E2%85%97%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Eit96%22%2C%22name%22%3A%22%E2%88%9A4%2F5%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%98%2C-%E2%88%9A%E2%85%95%7D%2C%7B%E2%88%9A%E2%85%95%2C%E2%88%9A%E2%85%98%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk circuit</a> from their paper gives the <span class=""math-container"">$3$</span>-hot Dicke state on five qubits.</p>
",qc,minimum number gates take prepare superposition basis vectors p generalized https nofollow noreferrer w state p span 1 n p often thought uniform superposition quot https nofollow noreferrer quot basis vectors vector single qubit span state others span p reviewing https question appears generalized w state span n qubits prepare ket roughly linear number gates contrast generalized https e2 80 93horne e2 80 nofollow noreferrer ghz state state similarly prepared single hadamard linear number p considering https amp question proposed generalized superposition quot quot basis states p span 1 n p may require quadratic number gates prepare starting ket intuition span 2 states accordingly may quadratic number gates blockquote p guess correct general take minimum roughly span k gates prepare uniform superposition quot span k quot vectors span n qubits starting canonical state ket p question borne idle curiosity anything honest perhaps interesting ponder simple states bit hard hard prepare especially nisq era generalized ghz states often prepared test cases sensitive decoherence cat states nonetheless produced quot easier quot clifford p strong edit p hmmm appears call quot span k quot state also known dicke state quot https nofollow noreferrer deterministic preparation dicke states quot andreas bärtschi stephan eidenbenz prepare state span nk gates https 7b 22cols 22 3a 5b 5b1 2c1 2c 22x 22 2c 22x 22 2c 22x 22 5d 2c 5b 22chance 22 2c 22chance 22 2c 22chance 22 2c 22chance 22 2c 22chance 22 5d 2c 5b 22chance5 22 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 22x 22 5d 2c 5b1 2c1 2c1 2c 22 7ed6b5 22 2c 22 e2 80 a2 22 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b1 2c1 2c 22 7ef38g 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 22x 22 5d 2c 5b1 2c 22 7edcqq 22 2c 22 e2 80 a2 22 2c1 2c 22 e2 80 a2 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 22x 22 5d 2c 5b1 2c1 2c 22 7er6tk 22 2c 22 e2 80 a2 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b1 2c 22 7eq81a 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 22x 22 5d 2c 5b 22 7ejrlp 22 2c 22 e2 80 a2 22 2c1 2c 22 e2 80 a2 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c 22x 22 5d 2c 5b1 2c 22 7etue7 22 2c 22 e2 80 a2 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b 22 7e7h3f 22 2c 22 e2 80 a2 22 2c 22 e2 80 a2 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b 22chance5 22 5d 2c 5b 22 e2 80 a2 22 2c 22x 22 5d 2c 5b 22 7eok6s 22 2c 22 e2 80 a2 22 5d 2c 5b 22 e2 80 a2 22 2c 22x 22 5d 2c 5b 22chance5 22 5d 5d 2c 22gates 22 3a 5b 7b 22id 22 3a 22 7eok6s 22 2c 22name 22 3a 22 e2 88 9a1 2f2 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a c2 bd e2 88 9a c2 bd 7d 2c 7b e2 88 9a c2 bd 2c e2 88 9a c2 bd 7d 7d 22 7d 2c 7b 22id 22 3a 22 7etue7 22 2c 22name 22 3a 22 e2 88 9a1 2f3 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 93 e2 88 9a e2 85 94 7d 2c 7b e2 88 9a e2 85 94 2c e2 88 9a e2 85 93 7d 7d 22 7d 2c 7b 22id 22 3a 22 7e7h3f 22 2c 22name 22 3a 22 e2 88 9a2 2f3 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 94 e2 88 9a e2 85 93 7d 2c 7b e2 88 9a e2 85 93 2c e2 88 9a e2 85 94 7d 7d 22 7d 2c 7b 22id 22 3a 22 7er6tk 22 2c 22name 22 3a 22 e2 88 9a1 2f4 22 2c 22matrix 22 3a 22 7b 7b c2 bd e2 88 9a c2 7d 2c 7b e2 88 9a c2 2c c2 bd 7d 7d 22 7d 2c 7b 22id 22 3a 22 7eq81a 22 2c 22name 22 3a 22 e2 88 9a2 2f4 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a c2 bd e2 88 9a c2 bd 7d 2c 7b e2 88 9a c2 bd 2c e2 88 9a c2 bd 7d 7d 22 7d 2c 7b 22id 22 3a 22 7ejrlp 22 2c 22name 22 3a 22 e2 88 9a3 2f4 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a c2 c2 bd 7d 2c 7b c2 bd 2c e2 88 9a c2 7d 7d 22 7d 2c 7b 22id 22 3a 22 7ed6b5 22 2c 22name 22 3a 22 e2 88 9a1 2f5 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 95 e2 88 9a e2 85 98 7d 2c 7b e2 88 9a e2 85 98 2c e2 88 9a e2 85 95 7d 7d 22 7d 2c 7b 22id 22 3a 22 7ef38g 22 2c 22name 22 3a 22 e2 88 9a2 2f5 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 96 e2 88 9a e2 85 97 7d 2c 7b e2 88 9a e2 85 97 2c e2 88 9a e2 85 96 7d 7d 22 7d 2c 7b 22id 22 3a 22 7edcqq 22 2c 22name 22 3a 22 e2 88 9a3 2f5 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 97 e2 88 9a e2 85 96 7d 2c 7b e2 88 9a e2 85 96 2c e2 88 9a e2 85 97 7d 7d 22 7d 2c 7b 22id 22 3a 22 7eit96 22 2c 22name 22 3a 22 e2 88 9a4 2f5 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 98 e2 88 9a e2 85 95 7d 2c 7b e2 88 9a e2 85 95 2c e2 88 9a e2 85 98 7d 7d 22 7d 5d 7d nofollow noreferrer quirk circuit paper gives span 3 dicke state five,"[(3, 0.01840748), (7, 0.010546847), (9, 0.036781862), (12, 0.86508507), (13, 0.014605918), (18, 0.037133604)]"
29100,29102.0,2022-11-22 23:26:20,2,384,"<p>Another user asked about the Ekert Quantum Key Distribution protocol: Alice and Bob each randomly choose one of three bases separated by <span class=""math-container"">$120^{\circ} $</span> in which to measure, and then later compare the results both when choosing the same base and when choosing a different base. For fun, I decided to implement this in Quirk. <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22%7Eagdi%22%2C1%2C%22H%22%2C%22%7Eagdi%22%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%2C%22%7E7to7%22%5D%2C%5B%22inputA2%22%2C1%2C1%2C%22inputB2%22%2C1%2C1%2C%22%5EA%3DB%22%2C%22%7Etn0e%22%5D%2C%5B1%2C1%2C%22inputA1%22%2C1%2C1%2C%22inputB1%22%2C1%2C%22%5EA%3DB%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22Chance%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%97%A6%22%2C%22Chance%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Eagdi%22%2C%22name%22%3A%220%2F1%2F2%22%2C%22circuit%22%3A%7B%22cols%22%3A%5B%5B%7B%22id%22%3A%22Rxft%22%2C%22arg%22%3A%222%20acos(sqrt(1%2F3))%22%7D%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C%22H%22%5D%2C%5B%22X%22%5D%5D%7D%7D%2C%7B%22id%22%3A%22%7E7to7%22%2C%22name%22%3A%22Same%20basis%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Etn0e%22%2C%22name%22%3A%22Same%20result%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk: Alice and Bob</a>.  Picture below.</p>
<p>[The gate &quot;0/1/2&quot; maps <span class=""math-container"">$|00\rangle$</span> to <span class=""math-container"">$(|00\rangle + |01\rangle + |10\rangle)/\sqrt3$</span> so that each of the three basis is chosen with equal probability.]</p>
<p>As you can see, Alice and Bob always get the same result when they use the same basis, and agree <span class=""math-container"">$\frac14$</span> of the time when they use a different basis. Exactly what theory demands.</p>
<p>I was uncertain how to implement Eve. To start, I gave Eve a copy of the entangled qubit by adding an X gate on the empty line between the two spacers.  <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22%7Eagdi%22%2C1%2C%22H%22%2C%22%7Eagdi%22%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%2C%22%7E7to7%22%5D%2C%5B%22inputA2%22%2C1%2C1%2C%22inputB2%22%2C1%2C1%2C%22%5EA%3DB%22%2C%22%7Etn0e%22%5D%2C%5B1%2C1%2C%22inputA1%22%2C1%2C1%2C%22inputB1%22%2C1%2C%22%5EA%3DB%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22Chance%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%97%A6%22%2C%22Chance%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Eagdi%22%2C%22name%22%3A%220%2F1%2F2%22%2C%22circuit%22%3A%7B%22cols%22%3A%5B%5B%7B%22id%22%3A%22Rxft%22%2C%22arg%22%3A%222%20acos(sqrt(1%2F3))%22%7D%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C%22H%22%5D%2C%5B%22X%22%5D%5D%7D%7D%2C%7B%22id%22%3A%22%7E7to7%22%2C%22name%22%3A%22Same%20basis%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Etn0e%22%2C%22name%22%3A%22Same%20result%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk: Eve</a>. Much to my surprise, that was all that was needed.  The probabilities immediately changed to
<span class=""math-container"">$\frac34$</span> and <span class=""math-container"">$\frac38$</span>, as predicted by theory.</p>
<p>I have two questions:</p>
<ol>
<li><p>Why does the existence of the third entangled qubit destroy the algorithm? I could understand if we measured the qubit or used it to control something, then we'd get another algorithm.  But somehow the very fact that Alice and Bob's pair is actually a triplet is all that is necessary.  I don't quite grok why that is sufficient.</p>
</li>
<li><p>If Eve decides not to e[a]vesdrop, is there anything that she can do to her qubit so that Alice and Bob can exchange keys in peace? Or is the very fact that the third entangled qubit was created mean the algorithm won't work?</p>
</li>
</ol>
<p><a href=""https://i.sstatic.net/BRi7ml.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BRi7ml.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>Update:  Adding response to Craig Gidney's answer.</p>
<p>You didn't quite answer my question, but you got me awfully close.</p>
<p>You gave me the insight I needed to realize that I could simplify my query to the following <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,%22X%22,%22X%22%5D,%5B%22Chance2%22,1,1,%22Chance2%22%5D,%5B%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D,1,1,%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D%5D,%5B%22Chance2%22,1,1,%22Chance2%22%5D,%5B1,1,1,%22Chance3%22%5D,%5B1,%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D,1,1,%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D%5D,%5B%22Chance2%22,1,1,%22Chance2%22%5D,%5B1,1,1,%22Chance3%22%5D,%5B%22inputA1%22,%22inputB1%22,%22%5EA=B%22%5D,%5B1,1,1,%22inputA1%22,%22inputB1%22,%22%5EA=B%22%5D,%5B1,1,%22Chance%22,1,1,%22Chance%22%5D%5D%7D"" rel=""nofollow noreferrer"">circuit</a>. If you only look at two qubits, things look a lot alike until suddenly they don't.  I need to look a bit more with the linear algebra to see why the third qubit makes such a big difference.</p>
<p><a href=""https://i.sstatic.net/B4Ics.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/B4Ics.png"" alt=""enter image description here"" /></a></p>
",Why does entanglement of 3 qubits break this?,<entanglement><qkd><quirk>,2,0,,,"Why does entanglement of 3 qubits break this? <p>Another user asked about the Ekert Quantum Key Distribution protocol: Alice and Bob each randomly choose one of three bases separated by <span class=""math-container"">$120^{\circ} $</span> in which to measure, and then later compare the results both when choosing the same base and when choosing a different base. For fun, I decided to implement this in Quirk. <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22%7Eagdi%22%2C1%2C%22H%22%2C%22%7Eagdi%22%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%2C%22%7E7to7%22%5D%2C%5B%22inputA2%22%2C1%2C1%2C%22inputB2%22%2C1%2C1%2C%22%5EA%3DB%22%2C%22%7Etn0e%22%5D%2C%5B1%2C1%2C%22inputA1%22%2C1%2C1%2C%22inputB1%22%2C1%2C%22%5EA%3DB%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22Chance%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%97%A6%22%2C%22Chance%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Eagdi%22%2C%22name%22%3A%220%2F1%2F2%22%2C%22circuit%22%3A%7B%22cols%22%3A%5B%5B%7B%22id%22%3A%22Rxft%22%2C%22arg%22%3A%222%20acos(sqrt(1%2F3))%22%7D%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C%22H%22%5D%2C%5B%22X%22%5D%5D%7D%7D%2C%7B%22id%22%3A%22%7E7to7%22%2C%22name%22%3A%22Same%20basis%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Etn0e%22%2C%22name%22%3A%22Same%20result%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk: Alice and Bob</a>.  Picture below.</p>
<p>[The gate &quot;0/1/2&quot; maps <span class=""math-container"">$|00\rangle$</span> to <span class=""math-container"">$(|00\rangle + |01\rangle + |10\rangle)/\sqrt3$</span> so that each of the three basis is chosen with equal probability.]</p>
<p>As you can see, Alice and Bob always get the same result when they use the same basis, and agree <span class=""math-container"">$\frac14$</span> of the time when they use a different basis. Exactly what theory demands.</p>
<p>I was uncertain how to implement Eve. To start, I gave Eve a copy of the entangled qubit by adding an X gate on the empty line between the two spacers.  <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22%7Eagdi%22%2C1%2C%22H%22%2C%22%7Eagdi%22%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A6%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Y%5Eft%22%2C%22arg%22%3A%22-2%2F3%22%7D%2C%22%7E7to7%22%5D%2C%5B%22inputA2%22%2C1%2C1%2C%22inputB2%22%2C1%2C1%2C%22%5EA%3DB%22%2C%22%7Etn0e%22%5D%2C%5B1%2C1%2C%22inputA1%22%2C1%2C1%2C%22inputB1%22%2C1%2C%22%5EA%3DB%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22Chance%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%97%A6%22%2C%22Chance%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Eagdi%22%2C%22name%22%3A%220%2F1%2F2%22%2C%22circuit%22%3A%7B%22cols%22%3A%5B%5B%7B%22id%22%3A%22Rxft%22%2C%22arg%22%3A%222%20acos(sqrt(1%2F3))%22%7D%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C%22H%22%5D%2C%5B%22X%22%5D%5D%7D%7D%2C%7B%22id%22%3A%22%7E7to7%22%2C%22name%22%3A%22Same%20basis%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%2C%7B%22id%22%3A%22%7Etn0e%22%2C%22name%22%3A%22Same%20result%3F%22%2C%22matrix%22%3A%22%7B%7B1%2C0%7D%2C%7B0%2C1%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk: Eve</a>. Much to my surprise, that was all that was needed.  The probabilities immediately changed to
<span class=""math-container"">$\frac34$</span> and <span class=""math-container"">$\frac38$</span>, as predicted by theory.</p>
<p>I have two questions:</p>
<ol>
<li><p>Why does the existence of the third entangled qubit destroy the algorithm? I could understand if we measured the qubit or used it to control something, then we'd get another algorithm.  But somehow the very fact that Alice and Bob's pair is actually a triplet is all that is necessary.  I don't quite grok why that is sufficient.</p>
</li>
<li><p>If Eve decides not to e[a]vesdrop, is there anything that she can do to her qubit so that Alice and Bob can exchange keys in peace? Or is the very fact that the third entangled qubit was created mean the algorithm won't work?</p>
</li>
</ol>
<p><a href=""https://i.sstatic.net/BRi7ml.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BRi7ml.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>Update:  Adding response to Craig Gidney's answer.</p>
<p>You didn't quite answer my question, but you got me awfully close.</p>
<p>You gave me the insight I needed to realize that I could simplify my query to the following <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,%22X%22,%22X%22%5D,%5B%22Chance2%22,1,1,%22Chance2%22%5D,%5B%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D,1,1,%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D%5D,%5B%22Chance2%22,1,1,%22Chance2%22%5D,%5B1,1,1,%22Chance3%22%5D,%5B1,%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D,1,1,%7B%22id%22:%22Y%5Eft%22,%22arg%22:%222/3%22%7D%5D,%5B%22Chance2%22,1,1,%22Chance2%22%5D,%5B1,1,1,%22Chance3%22%5D,%5B%22inputA1%22,%22inputB1%22,%22%5EA=B%22%5D,%5B1,1,1,%22inputA1%22,%22inputB1%22,%22%5EA=B%22%5D,%5B1,1,%22Chance%22,1,1,%22Chance%22%5D%5D%7D"" rel=""nofollow noreferrer"">circuit</a>. If you only look at two qubits, things look a lot alike until suddenly they don't.  I need to look a bit more with the linear algebra to see why the third qubit makes such a big difference.</p>
<p><a href=""https://i.sstatic.net/B4Ics.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/B4Ics.png"" alt=""enter image description here"" /></a></p>
",qc,entanglement 3 qubits break p another user asked ekert quantum key distribution protocol alice bob randomly choose one three bases separated span measure later compare results choosing base choosing different base fun decided implement quirk https 7b 22cols 22 3a 5b 5b 22 7eagdi 22 2c1 2c 22h 22 2c 22 7eagdi 22 2c1 2c1 2c1 2c1 2c 22 e2 80 a6 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 22x 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a6 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 2f3 22 7d 2c 22 7e7to7 22 5d 2c 5b 22inputa2 22 2c1 2c1 2c 22inputb2 22 2c1 2c1 2c 22 5ea 3db 22 2c 22 7etn0e 22 5d 2c 5b1 2c1 2c 22inputa1 22 2c1 2c1 2c 22inputb1 22 2c1 2c 22 5ea 3db 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 22chance 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 97 a6 22 2c 22chance 22 5d 5d 2c 22gates 22 3a 5b 7b 22id 22 3a 22 7eagdi 22 2c 22name 22 3a 220 2f1 2f2 22 2c 22circuit 22 3a 7b 22cols 22 3a 5b 5b 7b 22id 22 3a 22rxft 22 2c 22arg 22 3a 222 20acos sqrt 1 2f3 22 7d 5d 2c 5b 5d 2c 5b 5d 2c 5b 5d 2c 5b 22 e2 80 a2 22 2c 22h 22 5d 2c 5b 22x 22 5d 5d 7d 7d 2c 7b 22id 22 3a 22 7e7to7 22 2c 22name 22 3a 22same 20basis 3f 22 2c 22matrix 22 3a 22 7b 7b1 2c0 7d 2c 7b0 2c1 7d 7d 22 7d 2c 7b 22id 22 3a 22 7etn0e 22 2c 22name 22 3a 22same 20result 3f 22 2c 22matrix 22 3a 22 7b 7b1 2c0 7d 2c 7b0 2c1 7d 7d 22 7d 5d 7d nofollow noreferrer quirk alice bob picture p gate quot quot maps span span three basis chosen equal probability p see alice bob always get result use basis agree span time use different basis exactly theory p uncertain implement eve start gave eve copy entangled qubit adding x gate empty line two spacers https 7b 22cols 22 3a 5b 5b 22 7eagdi 22 2c1 2c 22h 22 2c 22 7eagdi 22 2c1 2c1 2c1 2c1 2c 22 e2 80 a6 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 22x 22 2c1 2c1 2c 22x 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a6 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22y 5eft 22 2c 22arg 22 3a 2f3 22 7d 2c 22 7e7to7 22 5d 2c 5b 22inputa2 22 2c1 2c1 2c 22inputb2 22 2c1 2c1 2c 22 5ea 3db 22 2c 22 7etn0e 22 5d 2c 5b1 2c1 2c 22inputa1 22 2c1 2c1 2c 22inputb1 22 2c1 2c 22 5ea 3db 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 22chance 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 97 a6 22 2c 22chance 22 5d 5d 2c 22gates 22 3a 5b 7b 22id 22 3a 22 7eagdi 22 2c 22name 22 3a 220 2f1 2f2 22 2c 22circuit 22 3a 7b 22cols 22 3a 5b 5b 7b 22id 22 3a 22rxft 22 2c 22arg 22 3a 222 20acos sqrt 1 2f3 22 7d 5d 2c 5b 5d 2c 5b 5d 2c 5b 5d 2c 5b 22 e2 80 a2 22 2c 22h 22 5d 2c 5b 22x 22 5d 5d 7d 7d 2c 7b 22id 22 3a 22 7e7to7 22 2c 22name 22 3a 22same 20basis 3f 22 2c 22matrix 22 3a 22 7b 7b1 2c0 7d 2c 7b0 2c1 7d 7d 22 7d 2c 7b 22id 22 3a 22 7etn0e 22 2c 22name 22 3a 22same 20result 3f 22 2c 22matrix 22 3a 22 7b 7b1 2c0 7d 2c 7b0 2c1 7d 7d 22 7d 5d 7d nofollow noreferrer quirk eve much surprise needed probabilities immediately changed span span predicted p two questions ol li p existence third entangled qubit destroy algorithm could understand measured qubit used control something get another algorithm somehow fact alice bob pair actually triplet necessary quite grok li p eve decides e vesdrop anything qubit alice bob exchange keys peace fact third entangled qubit created mean algorithm wo work p https nofollow noreferrer img https enter image description hr p update adding response craig gidney p quite answer question got awfully p gave insight needed realize could simplify query following https 7b 22cols 22 5b 5b 22h 22h 22 5d 5b 22 e2 80 a2 22 22x 22 5d 22 e2 80 a2 22 22x 22 22x 22 5d 5b 22chance2 22chance2 22 5d 5b 7b 22id 22 22y 5eft 22 22arg 22 22 7b 22id 22 22y 5eft 22 22arg 22 22 7d 5d 5b 22chance2 22chance2 22 5d 22chance3 22 5d 5b1 7b 22id 22 22y 5eft 22 22arg 22 22 7b 22id 22 22y 5eft 22 22arg 22 22 7d 5d 5b 22chance2 22chance2 22 5d 22chance3 22 5d 5b 22inputa1 22 22inputb1 22 22 22 5d 22inputa1 22 22inputb1 22 22 22 5d 22chance 22chance 22 5d 5d 7d nofollow noreferrer circuit look two qubits things look lot alike suddenly need look bit linear algebra see third qubit makes big p https nofollow noreferrer img https enter image description,"[(3, 0.01403007), (4, 0.03367077), (8, 0.025775671), (12, 0.81528676), (13, 0.015663637), (18, 0.084965184)]"
29145,,2022-11-26 15:07:50,1,74,"<p>The density matrix for an entangled state when both the qubits decohere with probability D1 and D2 in amplitude damping channel is given as <span class=""math-container"">$\rho_d$</span> in <a href=""https://doi.org/10.1038/nphys2178"" rel=""nofollow noreferrer"">this paper on page 2</a>. I am reproducing it here,
<span class=""math-container"">$$
\begin{bmatrix}
|\alpha^2|+|\beta^2|D_1 D_2 &amp; 0 &amp; 0 &amp; \sqrt{\bar{D_1}\bar{D_2}}\alpha^*\beta \\
0 &amp; D_1 \bar{D_2}|\beta^2| &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; D_2 \bar{D_1}|\beta^2| &amp; 0 \\
\sqrt{\bar{D_1}\bar{D_2}}\alpha\beta^* &amp; 0 &amp; 0 &amp; \bar{D_2} \bar{D_1}|\beta^2|
\end{bmatrix}
$$</span>
I am deriving the same expression using amplitude damping modeling, but I am not getting these non-diagonal terms <span class=""math-container"">$\sqrt{\bar{D_1}\bar{D_2}}\alpha \beta $</span> at matrix element <span class=""math-container"">$a_{34}$</span> and <span class=""math-container"">$a_{43}$</span> positions.
Solving this using amplitude damping modeling we get,
<span class=""math-container"">$\alpha \vert 0_S\rangle \vert 0_S\rangle \otimes \vert 0_E\rangle$</span> = <span class=""math-container"">$\alpha \vert 0_S\rangle\vert 0_S\rangle \otimes \vert 0_E\rangle$</span>
similarly,
<span class=""math-container"">\begin{equation}
\begin{split}
\beta \vert 1_S\rangle\vert 1_S\rangle \otimes \vert 0_E\rangle &amp; = \beta \bar{D_1}\bar{D_2}\vert 1_S\rangle \vert 1_S\rangle \otimes \vert 0_E\rangle\\ 
&amp;=  \beta \bar{D_1}D_2\vert 1_S\rangle\vert 0_S\rangle \otimes \vert 0_E\rangle\\ &amp;=\beta \bar{D_2}D_1\vert 0_S\rangle\vert 1_S\rangle \otimes \vert 0_E\rangle\\ &amp;=\beta D_1 D_2\vert 0_S\rangle\vert 0_S\rangle \otimes \vert 0_E\rangle
\end{split}
\end{equation}</span>
Considering the density matrix of the above terms we get all the diagonal terms of the matrix. But I am not getting these non-diagonal terms. Please explain.</p>
<p>Thank you.</p>
",Density matrix derivation of an entangled state in amplitude dampling channel,<density-matrix><decoherence>,0,0,,,"Density matrix derivation of an entangled state in amplitude dampling channel <p>The density matrix for an entangled state when both the qubits decohere with probability D1 and D2 in amplitude damping channel is given as <span class=""math-container"">$\rho_d$</span> in <a href=""https://doi.org/10.1038/nphys2178"" rel=""nofollow noreferrer"">this paper on page 2</a>. I am reproducing it here,
<span class=""math-container"">$$
\begin{bmatrix}
|\alpha^2|+|\beta^2|D_1 D_2 &amp; 0 &amp; 0 &amp; \sqrt{\bar{D_1}\bar{D_2}}\alpha^*\beta \\
0 &amp; D_1 \bar{D_2}|\beta^2| &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; D_2 \bar{D_1}|\beta^2| &amp; 0 \\
\sqrt{\bar{D_1}\bar{D_2}}\alpha\beta^* &amp; 0 &amp; 0 &amp; \bar{D_2} \bar{D_1}|\beta^2|
\end{bmatrix}
$$</span>
I am deriving the same expression using amplitude damping modeling, but I am not getting these non-diagonal terms <span class=""math-container"">$\sqrt{\bar{D_1}\bar{D_2}}\alpha \beta $</span> at matrix element <span class=""math-container"">$a_{34}$</span> and <span class=""math-container"">$a_{43}$</span> positions.
Solving this using amplitude damping modeling we get,
<span class=""math-container"">$\alpha \vert 0_S\rangle \vert 0_S\rangle \otimes \vert 0_E\rangle$</span> = <span class=""math-container"">$\alpha \vert 0_S\rangle\vert 0_S\rangle \otimes \vert 0_E\rangle$</span>
similarly,
<span class=""math-container"">\begin{equation}
\begin{split}
\beta \vert 1_S\rangle\vert 1_S\rangle \otimes \vert 0_E\rangle &amp; = \beta \bar{D_1}\bar{D_2}\vert 1_S\rangle \vert 1_S\rangle \otimes \vert 0_E\rangle\\ 
&amp;=  \beta \bar{D_1}D_2\vert 1_S\rangle\vert 0_S\rangle \otimes \vert 0_E\rangle\\ &amp;=\beta \bar{D_2}D_1\vert 0_S\rangle\vert 1_S\rangle \otimes \vert 0_E\rangle\\ &amp;=\beta D_1 D_2\vert 0_S\rangle\vert 0_S\rangle \otimes \vert 0_E\rangle
\end{split}
\end{equation}</span>
Considering the density matrix of the above terms we get all the diagonal terms of the matrix. But I am not getting these non-diagonal terms. Please explain.</p>
<p>Thank you.</p>
",qc,density matrix derivation entangled state amplitude dampling channel p density matrix entangled state qubits decohere probability d1 d2 amplitude damping channel given span https nofollow noreferrer paper page 2 reproducing span bmatrix amp 0 amp 0 amp 0 amp amp 0 amp 0 0 amp 0 amp amp 0 amp 0 amp 0 amp bmatrix deriving expression using amplitude damping modeling getting terms span matrix element span 34 span 43 positions solving using amplitude damping modeling get span span similarly span equation split amp amp amp amp split equation considering density matrix terms get diagonal terms matrix getting terms please p thank,"[(2, 0.09070948), (3, 0.16723329), (4, 0.09607934), (5, 0.010109032), (6, 0.010701983), (11, 0.064420804), (12, 0.010039692), (15, 0.448284), (18, 0.10133359)]"
29174,29178.0,2022-11-29 05:27:16,0,157,"<p><a href=""https://www.researchgate.net/publication/326978036_Solving_Sudoku_game_using_a_hybrid_classical-quantum_algorithm"" rel=""nofollow noreferrer"">This paper</a> simulates duality mode to solve sudoku puzzles. The last diagram in the paper (shown below) illustrates multi-qubit controlled gates with two Z/X gates. I wonder if Qiskit can directly implement these gates.</p>
<p><a href=""https://i.sstatic.net/DXaIE.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/DXaIE.png"" alt=""enter image description here"" /></a></p>
",Implement muti-qubit controlled gate with 2 Z/X gates,<qiskit><programming><quantum-gate><ibm-q-experience>,1,1,,,"Implement muti-qubit controlled gate with 2 Z/X gates <p><a href=""https://www.researchgate.net/publication/326978036_Solving_Sudoku_game_using_a_hybrid_classical-quantum_algorithm"" rel=""nofollow noreferrer"">This paper</a> simulates duality mode to solve sudoku puzzles. The last diagram in the paper (shown below) illustrates multi-qubit controlled gates with two Z/X gates. I wonder if Qiskit can directly implement these gates.</p>
<p><a href=""https://i.sstatic.net/DXaIE.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/DXaIE.png"" alt=""enter image description here"" /></a></p>
",qc,implement controlled gate 2 gates p https nofollow noreferrer paper simulates duality mode solve sudoku puzzles last diagram paper shown illustrates controlled gates two gates wonder qiskit directly implement p https nofollow noreferrer img https enter image description,"[(4, 0.62574095), (7, 0.09754816), (9, 0.24516544), (12, 0.0272413)]"
29193,,2022-11-30 15:02:32,1,412,"<p>I'm not sure how to bind the parameters in the Qiskit RawFeatureVector circuit.
Here is my code:</p>
<pre><code>feature_map = RawFeatureVector(feature_dimension = num_features)
feature_map = feature_map.assign_parameters(np.array([1,1]) / np.sqrt(2))
sampler = Sampler()
fidelity = ComputeUncompute(sampler=sampler)
kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=feature_map)
svm = OneClassSVM(kernel = kernel.evaluate, verbose=True, nu=outliers_fraction)
svm.fit(X)
</code></pre>
<p>I am probably missing something very obvious, but I think I bound the parameters when I assigned the paramters.
Now when I run this with some data, I get the following error traceback.</p>
<pre><code>QiskitError                               Traceback (most recent call last)
~\AppData\Local\Temp/ipykernel_8160/3101503440.py in &lt;module&gt;
      4     dataset_count = dataset_count + 1
      5     print(&quot;For dataset: {}&quot;.format(dataset_count))
----&gt; 6     Algorithm2(X, y, 1, outliers_fraction=outliers_fraction)
      7     break

~\AppData\Local\Temp/ipykernel_8160/1216541068.py in Algorithm2(X, y, shots, outliers_fraction, num_features, seed, predict, supervised)
     17     if supervised:
     18         X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=seed)
---&gt; 19         svm.fit(X_train, y_train)
     20         y_pred = svm.predict(X_test)
     21         # TODO save to Matrix

~\anaconda3\lib\site-packages\sklearn\svm\_classes.py in fit(self, X, y, sample_weight, **params)
   1374 
   1375         &quot;&quot;&quot;
-&gt; 1376         super().fit(X, np.ones(_num_samples(X)),
   1377                     sample_weight=sample_weight, **params)
   1378         self.offset_ = -self._intercept_

~\anaconda3\lib\site-packages\sklearn\svm\_base.py in fit(self, X, y, sample_weight)
    224 
    225         seed = rnd.randint(np.iinfo('i').max)
--&gt; 226         fit(X, y, sample_weight, solver_type, kernel, random_seed=seed)
    227         # see comment on the other call to np.iinfo in this file
    228 

~\anaconda3\lib\site-packages\sklearn\svm\_base.py in _dense_fit(self, X, y, sample_weight, solver_type, kernel, random_seed)
    264             # TODO: add keyword copy to copy on demand
    265             self.__Xfit = X
--&gt; 266             X = self._compute_kernel(X)
    267 
    268             if X.shape[0] != X.shape[1]:

~\anaconda3\lib\site-packages\sklearn\svm\_base.py in _compute_kernel(self, X)
    394             # in the case of precomputed kernel given as a function, we
    395             # have to compute explicitly the kernel matrix
--&gt; 396             kernel = self.kernel(X, self.__Xfit)
    397             if sp.issparse(kernel):
    398                 kernel = kernel.toarray()

~\anaconda3\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py in evaluate(self, x_vec, y_vec)
    119         if is_symmetric:
    120             left_parameters, right_parameters, indices = self._get_symmetric_parameterization(x_vec)
--&gt; 121             kernel_matrix = self._get_symmetric_kernel_matrix(
    122                 kernel_shape, left_parameters, right_parameters, indices
    123             )

~\anaconda3\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py in _get_symmetric_kernel_matrix(self, kernel_shape, left_parameters, right_parameters, indices)
    210         Given a set of parameterization, this computes the kernel matrix.
    211         &quot;&quot;&quot;
--&gt; 212         kernel_entries = self._get_kernel_entries(left_parameters, right_parameters)
    213         kernel_matrix = np.ones(kernel_shape)
    214 

~\anaconda3\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py in _get_kernel_entries(self, left_parameters, right_parameters)
    232                 right_parameters,
    233             )
--&gt; 234             kernel_entries = np.real(job.result().fidelities)
    235         else:
    236             # trivial case, only identical samples

~\anaconda3\lib\site-packages\qiskit\primitives\primitive_job.py in result(self)
     48         &quot;&quot;&quot;Return the results of the job.&quot;&quot;&quot;
     49         self._check_submitted()
---&gt; 50         return self._future.result()
     51 
     52     def cancel(self):

~\anaconda3\lib\concurrent\futures\_base.py in result(self, timeout)
    436                     raise CancelledError()
    437                 elif self._state == FINISHED:
--&gt; 438                     return self.__get_result()
    439 
    440                 self._condition.wait(timeout)

~\anaconda3\lib\concurrent\futures\_base.py in __get_result(self)
    388         if self._exception:
    389             try:
--&gt; 390                 raise self._exception
    391             finally:
    392                 # Break a reference cycle with the exception in self._exception

~\anaconda3\lib\concurrent\futures\thread.py in run(self)
     50 
     51         try:
---&gt; 52             result = self.fn(*self.args, **self.kwargs)
     53         except BaseException as exc:
     54             self.future.set_exception(exc)

~\anaconda3\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py in _run(self, circuits_1, circuits_2, values_1, values_2, **options)
    126         &quot;&quot;&quot;
    127 
--&gt; 128         circuits = self._construct_circuits(circuits_1, circuits_2)
    129         if len(circuits) == 0:
    130             raise ValueError(

~\anaconda3\lib\site-packages\qiskit\algorithms\state_fidelities\base_state_fidelity.py in _construct_circuits(self, circuits_1, circuits_2)
    186                 parametrized_circuit_2 = circuit_2.assign_parameters(parameters_2)
    187 
--&gt; 188                 circuit = self.create_fidelity_circuit(
    189                     parametrized_circuit_1, parametrized_circuit_2
    190                 )

~\anaconda3\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py in create_fidelity_circuit(self, circuit_1, circuit_2)
     91             circuit_2.remove_final_measurements()
     92 
---&gt; 93         circuit = circuit_1.compose(circuit_2.inverse())
     94         circuit.measure_all()
     95         return circuit

~\anaconda3\lib\site-packages\qiskit\circuit\library\blueprintcircuit.py in inverse(self)
    132         if not self._is_built:
    133             self._build()
--&gt; 134         return super().inverse()
    135 
    136     def __len__(self):

~\anaconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py in inverse(self)
    605 
    606         for instruction in reversed(self._data):
--&gt; 607             inverse_circ._append(instruction.replace(operation=instruction.operation.inverse()))
    608         return inverse_circ
    609 

~\anaconda3\lib\site-packages\qiskit\circuit\instruction.py in inverse(self)
    364                 and an inverse has not been implemented for it.
    365         &quot;&quot;&quot;
--&gt; 366         if self.definition is None:
    367             raise CircuitError(&quot;inverse() not implemented for %s.&quot; % self.name)
    368 

~\anaconda3\lib\site-packages\qiskit\circuit\instruction.py in definition(self)
    235         &quot;&quot;&quot;Return definition in terms of other basic gates.&quot;&quot;&quot;
    236         if self._definition is None:
--&gt; 237             self._define()
    238         return self._definition
    239 

~\anaconda3\lib\site-packages\qiskit_machine_learning\circuit\library\raw_feature_vector.py in _define(self)
    168                 cleaned_params.append(complex(param))
    169             else:
--&gt; 170                 raise QiskitError(&quot;Cannot define a ParameterizedInitialize with unbound parameters&quot;)
    171 
    172         # normalize

QiskitError: 'Cannot define a ParameterizedInitialize with unbound parameters'
</code></pre>
<p>Thanks in advance!</p>
",How do I bound parameters in RawFeatureVector with ParameterizedInitialize in Qiskit?,<qiskit><circuit-construction><quantum-circuit>,1,3,,,"How do I bound parameters in RawFeatureVector with ParameterizedInitialize in Qiskit? <p>I'm not sure how to bind the parameters in the Qiskit RawFeatureVector circuit.
Here is my code:</p>
<pre><code>feature_map = RawFeatureVector(feature_dimension = num_features)
feature_map = feature_map.assign_parameters(np.array([1,1]) / np.sqrt(2))
sampler = Sampler()
fidelity = ComputeUncompute(sampler=sampler)
kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=feature_map)
svm = OneClassSVM(kernel = kernel.evaluate, verbose=True, nu=outliers_fraction)
svm.fit(X)
</code></pre>
<p>I am probably missing something very obvious, but I think I bound the parameters when I assigned the paramters.
Now when I run this with some data, I get the following error traceback.</p>
<pre><code>QiskitError                               Traceback (most recent call last)
~\AppData\Local\Temp/ipykernel_8160/3101503440.py in &lt;module&gt;
      4     dataset_count = dataset_count + 1
      5     print(&quot;For dataset: {}&quot;.format(dataset_count))
----&gt; 6     Algorithm2(X, y, 1, outliers_fraction=outliers_fraction)
      7     break

~\AppData\Local\Temp/ipykernel_8160/1216541068.py in Algorithm2(X, y, shots, outliers_fraction, num_features, seed, predict, supervised)
     17     if supervised:
     18         X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=seed)
---&gt; 19         svm.fit(X_train, y_train)
     20         y_pred = svm.predict(X_test)
     21         # TODO save to Matrix

~\anaconda3\lib\site-packages\sklearn\svm\_classes.py in fit(self, X, y, sample_weight, **params)
   1374 
   1375         &quot;&quot;&quot;
-&gt; 1376         super().fit(X, np.ones(_num_samples(X)),
   1377                     sample_weight=sample_weight, **params)
   1378         self.offset_ = -self._intercept_

~\anaconda3\lib\site-packages\sklearn\svm\_base.py in fit(self, X, y, sample_weight)
    224 
    225         seed = rnd.randint(np.iinfo('i').max)
--&gt; 226         fit(X, y, sample_weight, solver_type, kernel, random_seed=seed)
    227         # see comment on the other call to np.iinfo in this file
    228 

~\anaconda3\lib\site-packages\sklearn\svm\_base.py in _dense_fit(self, X, y, sample_weight, solver_type, kernel, random_seed)
    264             # TODO: add keyword copy to copy on demand
    265             self.__Xfit = X
--&gt; 266             X = self._compute_kernel(X)
    267 
    268             if X.shape[0] != X.shape[1]:

~\anaconda3\lib\site-packages\sklearn\svm\_base.py in _compute_kernel(self, X)
    394             # in the case of precomputed kernel given as a function, we
    395             # have to compute explicitly the kernel matrix
--&gt; 396             kernel = self.kernel(X, self.__Xfit)
    397             if sp.issparse(kernel):
    398                 kernel = kernel.toarray()

~\anaconda3\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py in evaluate(self, x_vec, y_vec)
    119         if is_symmetric:
    120             left_parameters, right_parameters, indices = self._get_symmetric_parameterization(x_vec)
--&gt; 121             kernel_matrix = self._get_symmetric_kernel_matrix(
    122                 kernel_shape, left_parameters, right_parameters, indices
    123             )

~\anaconda3\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py in _get_symmetric_kernel_matrix(self, kernel_shape, left_parameters, right_parameters, indices)
    210         Given a set of parameterization, this computes the kernel matrix.
    211         &quot;&quot;&quot;
--&gt; 212         kernel_entries = self._get_kernel_entries(left_parameters, right_parameters)
    213         kernel_matrix = np.ones(kernel_shape)
    214 

~\anaconda3\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py in _get_kernel_entries(self, left_parameters, right_parameters)
    232                 right_parameters,
    233             )
--&gt; 234             kernel_entries = np.real(job.result().fidelities)
    235         else:
    236             # trivial case, only identical samples

~\anaconda3\lib\site-packages\qiskit\primitives\primitive_job.py in result(self)
     48         &quot;&quot;&quot;Return the results of the job.&quot;&quot;&quot;
     49         self._check_submitted()
---&gt; 50         return self._future.result()
     51 
     52     def cancel(self):

~\anaconda3\lib\concurrent\futures\_base.py in result(self, timeout)
    436                     raise CancelledError()
    437                 elif self._state == FINISHED:
--&gt; 438                     return self.__get_result()
    439 
    440                 self._condition.wait(timeout)

~\anaconda3\lib\concurrent\futures\_base.py in __get_result(self)
    388         if self._exception:
    389             try:
--&gt; 390                 raise self._exception
    391             finally:
    392                 # Break a reference cycle with the exception in self._exception

~\anaconda3\lib\concurrent\futures\thread.py in run(self)
     50 
     51         try:
---&gt; 52             result = self.fn(*self.args, **self.kwargs)
     53         except BaseException as exc:
     54             self.future.set_exception(exc)

~\anaconda3\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py in _run(self, circuits_1, circuits_2, values_1, values_2, **options)
    126         &quot;&quot;&quot;
    127 
--&gt; 128         circuits = self._construct_circuits(circuits_1, circuits_2)
    129         if len(circuits) == 0:
    130             raise ValueError(

~\anaconda3\lib\site-packages\qiskit\algorithms\state_fidelities\base_state_fidelity.py in _construct_circuits(self, circuits_1, circuits_2)
    186                 parametrized_circuit_2 = circuit_2.assign_parameters(parameters_2)
    187 
--&gt; 188                 circuit = self.create_fidelity_circuit(
    189                     parametrized_circuit_1, parametrized_circuit_2
    190                 )

~\anaconda3\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py in create_fidelity_circuit(self, circuit_1, circuit_2)
     91             circuit_2.remove_final_measurements()
     92 
---&gt; 93         circuit = circuit_1.compose(circuit_2.inverse())
     94         circuit.measure_all()
     95         return circuit

~\anaconda3\lib\site-packages\qiskit\circuit\library\blueprintcircuit.py in inverse(self)
    132         if not self._is_built:
    133             self._build()
--&gt; 134         return super().inverse()
    135 
    136     def __len__(self):

~\anaconda3\lib\site-packages\qiskit\circuit\quantumcircuit.py in inverse(self)
    605 
    606         for instruction in reversed(self._data):
--&gt; 607             inverse_circ._append(instruction.replace(operation=instruction.operation.inverse()))
    608         return inverse_circ
    609 

~\anaconda3\lib\site-packages\qiskit\circuit\instruction.py in inverse(self)
    364                 and an inverse has not been implemented for it.
    365         &quot;&quot;&quot;
--&gt; 366         if self.definition is None:
    367             raise CircuitError(&quot;inverse() not implemented for %s.&quot; % self.name)
    368 

~\anaconda3\lib\site-packages\qiskit\circuit\instruction.py in definition(self)
    235         &quot;&quot;&quot;Return definition in terms of other basic gates.&quot;&quot;&quot;
    236         if self._definition is None:
--&gt; 237             self._define()
    238         return self._definition
    239 

~\anaconda3\lib\site-packages\qiskit_machine_learning\circuit\library\raw_feature_vector.py in _define(self)
    168                 cleaned_params.append(complex(param))
    169             else:
--&gt; 170                 raise QiskitError(&quot;Cannot define a ParameterizedInitialize with unbound parameters&quot;)
    171 
    172         # normalize

QiskitError: 'Cannot define a ParameterizedInitialize with unbound parameters'
</code></pre>
<p>Thanks in advance!</p>
",qc,bound parameters rawfeaturevector parameterizedinitialize qiskit p sure bind parameters qiskit rawfeaturevector circuit code pre code rawfeaturevector 2 sampler sampler fidelity computeuncompute kernel fidelityquantumkernel svm oneclasssvm kernel x p probably missing something obvious think bound parameters assigned paramters run data get following error pre code qiskiterror traceback recent call last lt module gt 4 1 5 print quot dataset quot gt 6 algorithm2 x 1 7 break algorithm2 x shots seed predict supervised 17 supervised 18 x gt 19 20 21 todo save matrix fit self x params 1374 1375 quot quot quot gt 1376 super x x 1377 params 1378 fit self x 224 225 seed gt 226 fit x kernel 227 see comment call file 228 self x kernel 264 todo add keyword copy copy demand 265 x gt 266 x x 267 268 0 1 self x 394 case precomputed kernel given function 395 compute explicitly kernel matrix gt 396 kernel x 397 kernel 398 kernel evaluate self 119 120 indices gt 121 122 indices 123 self indices 210 given set parameterization computes kernel matrix 211 quot quot quot gt 212 213 214 self 232 233 gt 234 235 else 236 trivial case identical samples result self 48 quot quot quot return results quot quot quot 49 gt 50 return 51 52 def cancel self result self timeout 436 raise cancellederror 437 elif finished gt 438 return 439 440 timeout self 388 389 try gt 390 raise 391 finally 392 break reference cycle exception run self 50 51 try gt 52 result 53 except baseexception exc 54 exc self options 126 quot quot quot 127 gt 128 circuits 129 len circuits 0 130 raise valueerror self 186 187 gt 188 circuit 189 190 self 91 92 gt 93 circuit 94 95 return circuit inverse self 132 133 gt 134 return super 135 136 def self inverse self 605 606 instruction reversed gt 607 608 return 609 inverse self 364 inverse implemented 365 quot quot quot gt 366 none 367 raise circuiterror quot inverse implemented quot 368 definition self 235 quot quot quot return definition terms basic quot quot quot 236 none gt 237 238 return 239 self 168 complex param 169 else gt 170 raise qiskiterror quot define parameterizedinitialize unbound parameters quot 171 172 normalize qiskiterror define parameterizedinitialize unbound parameters p thanks advance,"[(0, 0.46035478), (5, 0.036277555), (6, 0.06298851), (9, 0.06716083), (10, 0.045398552), (12, 0.014297784), (13, 0.015725583), (14, 0.056198522), (15, 0.023806242), (19, 0.20964319)]"
29202,,2022-12-01 16:41:28,8,291,"<p>A recently published <a href=""https://www.nature.com/articles/s41586-022-05424-3"" rel=""nofollow noreferrer"">Nature paper</a> of Jafferis <em>et al.</em> describes an experiment with a handful of qubits performed on Google's Sycamore processor to explore the <a href=""https://en.wikipedia.org/wiki/Sachdev%E2%80%93Ye%E2%80%93Kitaev_model"" rel=""nofollow noreferrer"">SYK model</a> in the context of AdS/CFT and quantum gravity, and states that the experiment &quot;represents a step towards a program for studying quantum gravity in the laboratory&quot;.</p>
<p>The figures in the Nature article appear to present a high-level summary of the experiment but not at the level of gates acting on the particular topology of Sycamore.  Figure 1c of Jafferis <em>et al.</em> appears to provide a standard wormhole-inspired teleportation circuit diagram, with time advancing upwards.</p>
<hr />
<p>Figure 1 in an earlier counterpart <a href=""https://arxiv.org/abs/2205.14081"" rel=""nofollow noreferrer"">paper</a> of Shapoval <em>et al.</em>, as below, also provides a high-level summary of a wormhole-inspired teleportation protocol - this appears to be almost the same as in Figure 1c of Jafferis <em>et al.</em> with time advancing to the right.</p>
<p><a href=""https://i.sstatic.net/dbL2M.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dbL2M.png"" alt=""Figure 1 of Shapoval et al."" /></a></p>
<p>In step 0, the Left and Right qubits are created as Bell pairs and correspond to the mouths of a wormhole.  In step 1, the Left black hole scrambles and evolves backwards in time until the target qubit <span class=""math-container"">$|\psi\rangle$</span> is introduced in step 2 while then evolving forward in time in step 3; in step 4 the wormhole gets injected with a negative-energy Hamiltonian <span class=""math-container"">$V$</span>; while in step 5, by time-evolving the Right black hole the qubit <span class=""math-container"">$|\psi\rangle$</span> is teleported.</p>
<p>Additionally, Figure 4 in Shapoval <em>et al.</em> gets into the weeds of individual gates, and how they might be implemented on IBM's transmon devices and/or Quantinuum's trapped ion devices.</p>
<hr />
<p>We know that the native 2-qubit gates used in earlier Sycamore experiments are related to <strong>iSWAP</strong> gates.  The Jafferis <em>et al.</em> experiment reportedly was done on a 72-qubit version of Sycamore but only uses nine of these qubits and apparently involves several hundred 1- and 2-qubit gates.</p>
<blockquote>
<p>What was the particular circuit used in this experiment, preferably at the level provided by the other <a href=""https://quantumcomputing.stackexchange.com/questions/8342/understanding-googles-quantum-supremacy-using-a-programmable-superconducting-p"">Sycamore experiments</a> or at the level of Shapoval <em>et al.</em>'s proposal?</p>
</blockquote>
<p>For example, were the other qubits on Sycamore <strong>Id</strong>ling, or were they doing any other supportive ancillary work (such as <strong>SWAP</strong>ping info and out)? Did the circuit use these <strong>iSWAP</strong> gates, or something more subtle?  How deep was the circuit?  Apparently an important aspect of the experiment involved classical machine-learning to simplify and sparsify the Hamiltonian - did this machine learning characterize other qubits not used in the circuit, to know which ones not to use?</p>
",What is a gate-level circuit used in the 2022 Jafferis et al. experiment on Sycamore?,<quantum-circuit><experimental-realization><google-sycamore>,0,6,,,"What is a gate-level circuit used in the 2022 Jafferis et al. experiment on Sycamore? <p>A recently published <a href=""https://www.nature.com/articles/s41586-022-05424-3"" rel=""nofollow noreferrer"">Nature paper</a> of Jafferis <em>et al.</em> describes an experiment with a handful of qubits performed on Google's Sycamore processor to explore the <a href=""https://en.wikipedia.org/wiki/Sachdev%E2%80%93Ye%E2%80%93Kitaev_model"" rel=""nofollow noreferrer"">SYK model</a> in the context of AdS/CFT and quantum gravity, and states that the experiment &quot;represents a step towards a program for studying quantum gravity in the laboratory&quot;.</p>
<p>The figures in the Nature article appear to present a high-level summary of the experiment but not at the level of gates acting on the particular topology of Sycamore.  Figure 1c of Jafferis <em>et al.</em> appears to provide a standard wormhole-inspired teleportation circuit diagram, with time advancing upwards.</p>
<hr />
<p>Figure 1 in an earlier counterpart <a href=""https://arxiv.org/abs/2205.14081"" rel=""nofollow noreferrer"">paper</a> of Shapoval <em>et al.</em>, as below, also provides a high-level summary of a wormhole-inspired teleportation protocol - this appears to be almost the same as in Figure 1c of Jafferis <em>et al.</em> with time advancing to the right.</p>
<p><a href=""https://i.sstatic.net/dbL2M.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dbL2M.png"" alt=""Figure 1 of Shapoval et al."" /></a></p>
<p>In step 0, the Left and Right qubits are created as Bell pairs and correspond to the mouths of a wormhole.  In step 1, the Left black hole scrambles and evolves backwards in time until the target qubit <span class=""math-container"">$|\psi\rangle$</span> is introduced in step 2 while then evolving forward in time in step 3; in step 4 the wormhole gets injected with a negative-energy Hamiltonian <span class=""math-container"">$V$</span>; while in step 5, by time-evolving the Right black hole the qubit <span class=""math-container"">$|\psi\rangle$</span> is teleported.</p>
<p>Additionally, Figure 4 in Shapoval <em>et al.</em> gets into the weeds of individual gates, and how they might be implemented on IBM's transmon devices and/or Quantinuum's trapped ion devices.</p>
<hr />
<p>We know that the native 2-qubit gates used in earlier Sycamore experiments are related to <strong>iSWAP</strong> gates.  The Jafferis <em>et al.</em> experiment reportedly was done on a 72-qubit version of Sycamore but only uses nine of these qubits and apparently involves several hundred 1- and 2-qubit gates.</p>
<blockquote>
<p>What was the particular circuit used in this experiment, preferably at the level provided by the other <a href=""https://quantumcomputing.stackexchange.com/questions/8342/understanding-googles-quantum-supremacy-using-a-programmable-superconducting-p"">Sycamore experiments</a> or at the level of Shapoval <em>et al.</em>'s proposal?</p>
</blockquote>
<p>For example, were the other qubits on Sycamore <strong>Id</strong>ling, or were they doing any other supportive ancillary work (such as <strong>SWAP</strong>ping info and out)? Did the circuit use these <strong>iSWAP</strong> gates, or something more subtle?  How deep was the circuit?  Apparently an important aspect of the experiment involved classical machine-learning to simplify and sparsify the Hamiltonian - did this machine learning characterize other qubits not used in the circuit, to know which ones not to use?</p>
",qc,circuit used 2022 jafferis et al experiment sycamore p recently published https nofollow noreferrer nature paper jafferis em et describes experiment handful qubits performed google sycamore processor explore https e2 80 93ye e2 80 nofollow noreferrer syk model context quantum gravity states experiment quot represents step towards program studying quantum gravity laboratory quot p figures nature article appear present summary experiment level gates acting particular topology sycamore figure 1c jafferis em et appears provide standard teleportation circuit diagram time advancing hr p figure 1 earlier counterpart https nofollow noreferrer paper shapoval em et also provides summary teleportation protocol appears almost figure 1c jafferis em et time advancing p https nofollow noreferrer img https figure 1 shapoval et al p step 0 left right qubits created bell pairs correspond mouths wormhole step 1 left black hole scrambles evolves backwards time target qubit span introduced step 2 evolving forward time step 3 step 4 wormhole gets injected hamiltonian span v step 5 right black hole qubit span p additionally figure 4 shapoval em et gets weeds individual gates might implemented ibm transmon devices quantinuum trapped ion hr p know native gates used earlier sycamore experiments related strong iswap gates jafferis em et experiment reportedly done version sycamore uses nine qubits apparently involves several hundred blockquote p particular circuit used experiment preferably level provided https sycamore experiments level shapoval em et proposal p example qubits sycamore strong id ling supportive ancillary work strong swap ping info circuit use strong iswap gates something subtle deep circuit apparently important aspect experiment involved classical simplify sparsify hamiltonian machine learning characterize qubits used circuit know ones use,"[(1, 0.030913087), (2, 0.02128202), (3, 0.016824871), (4, 0.19150683), (8, 0.13831843), (9, 0.34199303), (10, 0.013139188), (12, 0.01697972), (13, 0.09809886), (14, 0.03483244), (17, 0.011080738), (18, 0.07467872), (19, 0.0100625735)]"
29255,,2022-12-05 19:20:55,1,151,"<p>I have created a noise model which uses depolarizing error and I add it using the add to all qubits quantum error command. I also use readout error and add that using the add to all qubits readoute error command.</p>
<p>When I've tested this noisemodel on a simple circuit I can successfully vary the amount of noise the circuit receives, however when I try to add it in to my VQE code which is the code from the QisKit textbook, when I increase the parameters there isn't a noticeable change.</p>
<p>I was thinking this is because the VQE algorithm is already quite good at handling noise, however when I am increasing these parameters by a power of 10 there should be some sort of change.</p>
<p>Any insight would be greatly appreciated.</p>
<p>Here is my code for my simple example:</p>
<pre><code>from qiskit import QuantumCircuit, execute
from qiskit import IBMQ, Aer
from qiskit.visualization import plot_histogram
from qiskit_aer.noise import NoiseModel

# Build noise model from backend properties
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_quito')
noise_model = NoiseModel.from_backend(backend)

# Get coupling map from backend
coupling_map = backend.configuration().coupling_map

# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 coupling_map=coupling_map,
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>The reuslts from this are below
<a href=""https://i.sstatic.net/E6QkZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/E6QkZ.png"" alt=""The results from this example"" /></a></p>
<p>I then created by own noisemodel with the following</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
import qiskit_aer.noise as noise
from qiskit.providers.aer.noise import QuantumError, ReadoutError

# Error probabilities
prob_1 = 0.02  # 1-qubit gate
prob_2 = 0.2  # 2-qubit gate

# Depolarizing quantum errors
error_1 = noise.depolarizing_error(prob_1, 1)
error_2 = noise.depolarizing_error(prob_2, 2)

# Readout quantum errors
p0given1 = 0.1
p1given0 = 0.05

ReadoutError = ReadoutError([[1 - p1given0, p1given0], [p0given1, 1 - p0given1]])

# Add errors to noise model
noise_model = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model.add_all_qubit_readout_error(ReadoutError)
print(noise_model)
# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>And I get the following:</p>
<p><a href=""https://i.sstatic.net/jRfhK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jRfhK.png"" alt=""Own noise model results"" /></a></p>
<p>I can then change my parameters: prob_1, prob_2, p0given1 and p1given0
Increasing these increases my noise, decreasing these decreases my noise. This is what I wanted to achieve of having controllable noise. Then when I take this code over to my VQE code I add them to a noise model through the following:</p>
<pre><code>noise_model1 = noise.NoiseModel()
noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model1.add_all_qubit_readout_error(readout_error)
sim_noise = AerSimulator(noise_model=noise_model1)
qi = QuantumInstance(sim_noise,
                    noise_model=noise_model1)
</code></pre>
<p>This then gives me the quantum instance which I can use in my VQE code. However all of my results are very similar even if I'm changing my probabilities massively. Even when I put the probabilities to almost no error it still acts as if I have set the probabilities to a very high error.</p>
<p>Below is my entire VQE code:
Note: I am aware that I could nest my parameters increasing in size into a loop instead of using if statements, I've just done it this way to help me visualize.</p>
<p>I also have 3 parameters p_reset,p_meas and p_gate1 which I used when testing a different type of &quot;quantum_error&quot; which also didn't help improving my results so these can be ignored. They aren't applied to the noisemodel.</p>
<p>I also have tried with 'qasm_simulator' and AerSimulator, both give the same result and don't really change with changes in these parameters.</p>
<pre><code>from qiskit.algorithms import VQE
from qiskit.algorithms import NumPyMinimumEigensolver
from qiskit_nature.algorithms import (GroundStateEigensolver,
                                      NumPyMinimumEigensolverFactory)
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import (
    ElectronicStructureMoleculeDriver, ElectronicStructureDriverType)
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.mappers.second_quantization import ParityMapper

import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
import numpy as np
from qiskit.providers.aer import AerSimulator

# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.providers.aer import QasmSimulator

def get_qubit_op(dist):
    molecule = Molecule(
        geometry=[ [&quot;H&quot;, [0.0, 0.0, 0.0] ],
                  [&quot;H&quot;, [dist, 0.0, 0.0725] ]],
        multiplicity=1,charge=0)

    driver = ElectronicStructureMoleculeDriver(
        molecule=molecule,
        basis=&quot;sto3g&quot;,
        driver_type=ElectronicStructureDriverType.PYSCF)

    problem = ElectronicStructureProblem(driver)

    second_q_ops = problem.second_q_ops()  # Get 2nd Quant OP
    num_spin_orbitals = problem.num_spin_orbitals
    num_particles = problem.num_particles

    mapper = ParityMapper()  # Set Mapper

    hamiltonian = second_q_ops[0]  # Set Hamiltonian

    # Do two qubit reduction
    converter = QubitConverter(mapper,two_qubit_reduction=True)
    reducer = TwoQubitReduction(num_particles)
    qubit_op = converter.convert(hamiltonian)
    qubit_op = reducer.convert(qubit_op)
    return qubit_op, num_particles, num_spin_orbitals, problem, converter

from qiskit.providers.aer.noise import pauli_error
from qiskit import IBMQ
from qiskit.providers.aer.noise import NoiseModel, ReadoutError
from qiskit.providers.fake_provider import FakeMelbourne
backend = FakeMelbourne()
from qiskit.providers.aer.noise import depolarizing_error
nm_1 = NoiseModel.from_backend(backend)
import qiskit_aer.noise as noise
def custom_noise(idx): 
    # Error probabilities
    if idx == 0:
        prob_1 = 0.005  # 1-qubit gate
        prob_2 = 0.01   # 2-qubit gate
        p0_1 = 0.99
        p1_0 = 0.005
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.015
        p_meas = 0.01
        p_gate1 = 0.0125
    elif idx == 1:
        prob_1 = 0.05  # 1-qubit gate
        prob_2 = 0.1   # 2-qubit gate
        p0_1 = 0.9
        p1_0 = 0.05
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.15
        p_meas = 0.1
        p_gate1 = 0.125
    elif idx == 2:
        prob_1 = 0.1  # 1-qubit gate
        prob_2 = 0.2   # 2-qubit gate
        p0_1 = 0.8
        p1_0 = 0.1
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.3
        p_meas = 0.2
        p_gate1 = 0.35
    elif idx == 3:
        prob_1 = 0.15  # 1-qubit gate
        prob_2 = 0.3   # 2-qubit gate
        p0_1 = 0.6
        p1_0 = 0.3
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.45
        p_meas = 0.3
        p_gate1 = 0.475
    elif idx == 4:
        prob_1 = 0.2  # 1-qubit gate
        prob_2 = 0.4   # 2-qubit gate
        p0_1 = 0.5
        p1_0 = 0.4
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.60
        p_meas = 0.4
        p_gate1 = 0.6
    print(prob_1,p0_1,p_reset)
    #adding quantum error objects
    '''
    error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)])
    error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)])
    error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)])
    error_gate2 = error_gate1.tensor(error_gate1)
    '''
    
    # Depolarizing quantum errors
    error_1 = noise.depolarizing_error(prob_1, 1)
    error_2 = noise.depolarizing_error(prob_2, 2)
    
    #Readout errors
    readout_error = ReadoutError([[p0_1, p0], [p1_0, p1]])
    
    # Add errors to noise model
    noise_model1 = noise.NoiseModel()
   # noise_model.add_all_qubit_quantum_error(error_reset, &quot;reset&quot;)
   # noise_model.add_all_qubit_quantum_error(error_meas, &quot;measure&quot;)
   # noise_model.add_all_qubit_quantum_error(error_gate1, [&quot;u1&quot;, &quot;u2&quot;, &quot;u3&quot;])
   # noise_model.add_all_qubit_quantum_error(error_gate2, [&quot;cx&quot;])
   # noise_model.add_all_qubit_readout_error(readout_error)
    noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
    noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
    noise_model1.add_all_qubit_readout_error(readout_error)
    print(noise_model1)
    
    '''
    noise_model = NoiseModel()
    error = depolarizing_error(prob_1,1)
    noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])
    '''
    backend1 = Aer.get_backend('qasm_simulator')
    basis_gates = noise_model1.basis_gates
    sim_noise = AerSimulator(noise_model=noise_model1)
    qi = QuantumInstance(backend1,
                         noise_model=noise_model1,
                         basis_gates=basis_gates,
                         measurement_error_mitigation_cls=CompleteMeasFitter)
    return qi

def exact_solver(problem, converter):
    solver = NumPyMinimumEigensolverFactory()
    calc = GroundStateEigensolver(converter, solver)
    result = calc.solve(problem)
    return result

distances = np.arange(0.2, 2.5, 0.2)

for idx in range(0,5):
    exact_energies = []
    vqe_energies = []
    optimizer = SLSQP(maxiter=100)
    qi = custom_noise(idx)
    for dist in distances:
        (qubit_op, num_particles, num_spin_orbitals,
                                 problem, converter) = get_qubit_op(dist)
        result = exact_solver(problem,converter)
        exact_energies.append(result.total_energies[0])
        init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
        var_form = EfficientSU2(qubit_op.num_qubits, entanglement=&quot;linear&quot;)
        vqe = VQE(var_form, optimizer=optimizer, quantum_instance=qi)
        vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
        vqe_result = problem.interpret(vqe_calc).total_energies[0].real
        vqe_energies.append(vqe_result)
        print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
              f&quot;VQE Result: {vqe_result:.5f}&quot;,
              f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
    print(&quot;Energies for idx {} have been calculated&quot;.format(idx))
    plt.plot(distances, vqe_energies, label=&quot;VQE Energy index = {}&quot;.format(idx))
    
print(&quot;All energies have been calculated&quot;)
plt.plot(distances, exact_energies, label=&quot;Exact Energy&quot;)
plt.xlabel('Atomic distance (Angstrom)')
plt.ylabel('Energy')
plt.legend()
plt.show()
</code></pre>
<p>Below are the results:
<a href=""https://i.sstatic.net/psoz3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/psoz3.png"" alt=""Image of diff noises by similar"" /></a>
This shows that increasing the noise doesn't have the same affect as which it has on my simple example above.</p>
",Why my noise model acts different on my VQE circuit compared to a simple circuit,<qiskit><noise>,0,7,,,"Why my noise model acts different on my VQE circuit compared to a simple circuit <p>I have created a noise model which uses depolarizing error and I add it using the add to all qubits quantum error command. I also use readout error and add that using the add to all qubits readoute error command.</p>
<p>When I've tested this noisemodel on a simple circuit I can successfully vary the amount of noise the circuit receives, however when I try to add it in to my VQE code which is the code from the QisKit textbook, when I increase the parameters there isn't a noticeable change.</p>
<p>I was thinking this is because the VQE algorithm is already quite good at handling noise, however when I am increasing these parameters by a power of 10 there should be some sort of change.</p>
<p>Any insight would be greatly appreciated.</p>
<p>Here is my code for my simple example:</p>
<pre><code>from qiskit import QuantumCircuit, execute
from qiskit import IBMQ, Aer
from qiskit.visualization import plot_histogram
from qiskit_aer.noise import NoiseModel

# Build noise model from backend properties
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_quito')
noise_model = NoiseModel.from_backend(backend)

# Get coupling map from backend
coupling_map = backend.configuration().coupling_map

# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 coupling_map=coupling_map,
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>The reuslts from this are below
<a href=""https://i.sstatic.net/E6QkZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/E6QkZ.png"" alt=""The results from this example"" /></a></p>
<p>I then created by own noisemodel with the following</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
import qiskit_aer.noise as noise
from qiskit.providers.aer.noise import QuantumError, ReadoutError

# Error probabilities
prob_1 = 0.02  # 1-qubit gate
prob_2 = 0.2  # 2-qubit gate

# Depolarizing quantum errors
error_1 = noise.depolarizing_error(prob_1, 1)
error_2 = noise.depolarizing_error(prob_2, 2)

# Readout quantum errors
p0given1 = 0.1
p1given0 = 0.05

ReadoutError = ReadoutError([[1 - p1given0, p1given0], [p0given1, 1 - p0given1]])

# Add errors to noise model
noise_model = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model.add_all_qubit_readout_error(ReadoutError)
print(noise_model)
# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>And I get the following:</p>
<p><a href=""https://i.sstatic.net/jRfhK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jRfhK.png"" alt=""Own noise model results"" /></a></p>
<p>I can then change my parameters: prob_1, prob_2, p0given1 and p1given0
Increasing these increases my noise, decreasing these decreases my noise. This is what I wanted to achieve of having controllable noise. Then when I take this code over to my VQE code I add them to a noise model through the following:</p>
<pre><code>noise_model1 = noise.NoiseModel()
noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model1.add_all_qubit_readout_error(readout_error)
sim_noise = AerSimulator(noise_model=noise_model1)
qi = QuantumInstance(sim_noise,
                    noise_model=noise_model1)
</code></pre>
<p>This then gives me the quantum instance which I can use in my VQE code. However all of my results are very similar even if I'm changing my probabilities massively. Even when I put the probabilities to almost no error it still acts as if I have set the probabilities to a very high error.</p>
<p>Below is my entire VQE code:
Note: I am aware that I could nest my parameters increasing in size into a loop instead of using if statements, I've just done it this way to help me visualize.</p>
<p>I also have 3 parameters p_reset,p_meas and p_gate1 which I used when testing a different type of &quot;quantum_error&quot; which also didn't help improving my results so these can be ignored. They aren't applied to the noisemodel.</p>
<p>I also have tried with 'qasm_simulator' and AerSimulator, both give the same result and don't really change with changes in these parameters.</p>
<pre><code>from qiskit.algorithms import VQE
from qiskit.algorithms import NumPyMinimumEigensolver
from qiskit_nature.algorithms import (GroundStateEigensolver,
                                      NumPyMinimumEigensolverFactory)
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import (
    ElectronicStructureMoleculeDriver, ElectronicStructureDriverType)
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.mappers.second_quantization import ParityMapper

import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
import numpy as np
from qiskit.providers.aer import AerSimulator

# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.providers.aer import QasmSimulator

def get_qubit_op(dist):
    molecule = Molecule(
        geometry=[ [&quot;H&quot;, [0.0, 0.0, 0.0] ],
                  [&quot;H&quot;, [dist, 0.0, 0.0725] ]],
        multiplicity=1,charge=0)

    driver = ElectronicStructureMoleculeDriver(
        molecule=molecule,
        basis=&quot;sto3g&quot;,
        driver_type=ElectronicStructureDriverType.PYSCF)

    problem = ElectronicStructureProblem(driver)

    second_q_ops = problem.second_q_ops()  # Get 2nd Quant OP
    num_spin_orbitals = problem.num_spin_orbitals
    num_particles = problem.num_particles

    mapper = ParityMapper()  # Set Mapper

    hamiltonian = second_q_ops[0]  # Set Hamiltonian

    # Do two qubit reduction
    converter = QubitConverter(mapper,two_qubit_reduction=True)
    reducer = TwoQubitReduction(num_particles)
    qubit_op = converter.convert(hamiltonian)
    qubit_op = reducer.convert(qubit_op)
    return qubit_op, num_particles, num_spin_orbitals, problem, converter

from qiskit.providers.aer.noise import pauli_error
from qiskit import IBMQ
from qiskit.providers.aer.noise import NoiseModel, ReadoutError
from qiskit.providers.fake_provider import FakeMelbourne
backend = FakeMelbourne()
from qiskit.providers.aer.noise import depolarizing_error
nm_1 = NoiseModel.from_backend(backend)
import qiskit_aer.noise as noise
def custom_noise(idx): 
    # Error probabilities
    if idx == 0:
        prob_1 = 0.005  # 1-qubit gate
        prob_2 = 0.01   # 2-qubit gate
        p0_1 = 0.99
        p1_0 = 0.005
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.015
        p_meas = 0.01
        p_gate1 = 0.0125
    elif idx == 1:
        prob_1 = 0.05  # 1-qubit gate
        prob_2 = 0.1   # 2-qubit gate
        p0_1 = 0.9
        p1_0 = 0.05
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.15
        p_meas = 0.1
        p_gate1 = 0.125
    elif idx == 2:
        prob_1 = 0.1  # 1-qubit gate
        prob_2 = 0.2   # 2-qubit gate
        p0_1 = 0.8
        p1_0 = 0.1
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.3
        p_meas = 0.2
        p_gate1 = 0.35
    elif idx == 3:
        prob_1 = 0.15  # 1-qubit gate
        prob_2 = 0.3   # 2-qubit gate
        p0_1 = 0.6
        p1_0 = 0.3
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.45
        p_meas = 0.3
        p_gate1 = 0.475
    elif idx == 4:
        prob_1 = 0.2  # 1-qubit gate
        prob_2 = 0.4   # 2-qubit gate
        p0_1 = 0.5
        p1_0 = 0.4
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.60
        p_meas = 0.4
        p_gate1 = 0.6
    print(prob_1,p0_1,p_reset)
    #adding quantum error objects
    '''
    error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)])
    error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)])
    error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)])
    error_gate2 = error_gate1.tensor(error_gate1)
    '''
    
    # Depolarizing quantum errors
    error_1 = noise.depolarizing_error(prob_1, 1)
    error_2 = noise.depolarizing_error(prob_2, 2)
    
    #Readout errors
    readout_error = ReadoutError([[p0_1, p0], [p1_0, p1]])
    
    # Add errors to noise model
    noise_model1 = noise.NoiseModel()
   # noise_model.add_all_qubit_quantum_error(error_reset, &quot;reset&quot;)
   # noise_model.add_all_qubit_quantum_error(error_meas, &quot;measure&quot;)
   # noise_model.add_all_qubit_quantum_error(error_gate1, [&quot;u1&quot;, &quot;u2&quot;, &quot;u3&quot;])
   # noise_model.add_all_qubit_quantum_error(error_gate2, [&quot;cx&quot;])
   # noise_model.add_all_qubit_readout_error(readout_error)
    noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
    noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
    noise_model1.add_all_qubit_readout_error(readout_error)
    print(noise_model1)
    
    '''
    noise_model = NoiseModel()
    error = depolarizing_error(prob_1,1)
    noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])
    '''
    backend1 = Aer.get_backend('qasm_simulator')
    basis_gates = noise_model1.basis_gates
    sim_noise = AerSimulator(noise_model=noise_model1)
    qi = QuantumInstance(backend1,
                         noise_model=noise_model1,
                         basis_gates=basis_gates,
                         measurement_error_mitigation_cls=CompleteMeasFitter)
    return qi

def exact_solver(problem, converter):
    solver = NumPyMinimumEigensolverFactory()
    calc = GroundStateEigensolver(converter, solver)
    result = calc.solve(problem)
    return result

distances = np.arange(0.2, 2.5, 0.2)

for idx in range(0,5):
    exact_energies = []
    vqe_energies = []
    optimizer = SLSQP(maxiter=100)
    qi = custom_noise(idx)
    for dist in distances:
        (qubit_op, num_particles, num_spin_orbitals,
                                 problem, converter) = get_qubit_op(dist)
        result = exact_solver(problem,converter)
        exact_energies.append(result.total_energies[0])
        init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
        var_form = EfficientSU2(qubit_op.num_qubits, entanglement=&quot;linear&quot;)
        vqe = VQE(var_form, optimizer=optimizer, quantum_instance=qi)
        vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
        vqe_result = problem.interpret(vqe_calc).total_energies[0].real
        vqe_energies.append(vqe_result)
        print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
              f&quot;VQE Result: {vqe_result:.5f}&quot;,
              f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
    print(&quot;Energies for idx {} have been calculated&quot;.format(idx))
    plt.plot(distances, vqe_energies, label=&quot;VQE Energy index = {}&quot;.format(idx))
    
print(&quot;All energies have been calculated&quot;)
plt.plot(distances, exact_energies, label=&quot;Exact Energy&quot;)
plt.xlabel('Atomic distance (Angstrom)')
plt.ylabel('Energy')
plt.legend()
plt.show()
</code></pre>
<p>Below are the results:
<a href=""https://i.sstatic.net/psoz3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/psoz3.png"" alt=""Image of diff noises by similar"" /></a>
This shows that increasing the noise doesn't have the same affect as which it has on my simple example above.</p>
",qc,noise model acts different vqe circuit compared simple circuit p created noise model uses depolarizing error add using add qubits quantum error command also use readout error add using add qubits readoute error p tested noisemodel simple circuit successfully vary amount noise circuit receives however try add vqe code code qiskit textbook increase parameters noticeable p thinking vqe algorithm already quite good handling noise however increasing parameters power 10 sort p insight would greatly p code simple example pre code qiskit import quantumcircuit execute qiskit import ibmq aer import import noisemodel build noise model backend properties provider backend backend get coupling map backend get basis gates noise model make circuit circ quantumcircuit 3 3 0 0 1 1 2 0 1 2 0 1 2 perform noise simulation result execute circ counts 0 counts p reuslts https nofollow noreferrer img https results example p created noisemodel following pre code qiskit import quantumcircuit execute aer import import noise import quantumerror readouterror error probabilities gate gate depolarizing quantum errors 1 2 readout quantum errors p0given1 p1given0 readouterror readouterror 1 p1given0 p1given0 p0given1 1 p0given1 add errors noise model readouterror print get basis gates noise model make circuit circ quantumcircuit 3 3 0 0 1 1 2 0 1 2 0 1 2 perform noise simulation result execute circ counts 0 counts p get following p https nofollow noreferrer img https noise model results p change parameters p0given1 p1given0 increasing increases noise decreasing decreases noise wanted achieve controllable noise take code vqe code add noise model following pre code aersimulator qi quantuminstance p gives quantum instance use vqe code however results similar even changing probabilities massively even put probabilities almost error still acts set probabilities high p entire vqe code note aware could nest parameters increasing size loop instead using statements done way help p also 3 parameters used testing different type quot quot also help improving results ignored applied p also tried aersimulator give result really change changes pre code import vqe import numpyminimumeigensolver import groundstateeigensolver numpyminimumeigensolverfactory import molecule import electronicstructuremoleculedriver electronicstructuredrivertype import freezecoretransformer import electronicstructureproblem import qubitconverter import paritymapper import plt import numpy np import uccsd hartreefock import efficientsu2 import cobyla spsa slsqp import twoqubitreduction qiskit import basicaer aer import quantuminstance import completemeasfitter import noisemodel import numpy np import aersimulator importing standard qiskit libraries qiskit import quantumcircuit transpile aer ibmq import qasmsimulator def dist molecule molecule quot h quot quot h quot dist driver electronicstructuremoleculedriver quot sto3g quot problem electronicstructureproblem driver get 2nd quant op mapper paritymapper set mapper hamiltonian 0 set hamiltonian two qubit reduction converter qubitconverter mapper reducer twoqubitreduction hamiltonian return problem converter import qiskit import ibmq import noisemodel readouterror import fakemelbourne backend fakemelbourne import backend import noise def idx error probabilities idx 0 gate gate p0 1 p1 1 elif idx 1 gate gate p0 1 p1 1 elif idx 2 gate gate p0 1 p1 1 elif idx 3 gate gate p0 1 p1 1 elif idx 4 gate gate p0 1 p1 1 print adding quantum error objects x 1 x 1 x 1 depolarizing quantum errors 1 2 readout errors readouterror p0 p1 add errors noise model quot reset quot quot measure quot quot u1 quot quot u2 quot quot u3 quot quot cx quot print noisemodel error error backend1 aersimulator qi quantuminstance backend1 return qi def problem converter solver numpyminimumeigensolverfactory calc groundstateeigensolver converter solver result problem return result distances idx range optimizer slsqp qi idx dist distances problem converter dist result problem converter 0 hartreefock converter efficientsu2 quot linear quot vqe vqe 0 print f quot interatomic distance dist 2 quot f quot vqe result quot f quot exact energy quot print quot energies idx calculated quot idx distances quot vqe energy index quot idx print quot energies calculated quot distances quot exact energy quot distance angstrom p results https nofollow noreferrer img https image diff noises similar shows increasing noise affect simple example,"[(0, 0.33382562), (2, 0.09343485), (4, 0.03416691), (5, 0.019585501), (8, 0.056674495), (9, 0.03427455), (12, 0.0125162415), (14, 0.2688809), (17, 0.05268304), (19, 0.08164184)]"
29288,29291.0,2022-12-07 16:38:31,2,270,"<p>Premise: I am not sure whether I am missing something theoretically.</p>
<p>Given a circuit creating a GHZ state over 3 qubits, say q1, q2 and q3. If I do not consider q3 and perform a state tomography over q1 and q2, then intuitively, I should get a Bell state as output, i.e. <span class=""math-container"">$|\Phi^+\rangle\langle\Phi^+|$</span>.</p>
<p>Nevertheless the output is the following matrix:</p>
<pre><code>[[ 0.5, -0. ,  0. , -0. ],
   [-0. ,  0. ,  0. , -0. ],
   [ 0. ,  0. ,  0. ,  0. ],
   [-0. , -0. ,  0. ,  0.5]]
</code></pre>
<p>I am not observing q3. I also tried to reset it with the command <code>circuit.reset(2)</code>.</p>
<p>This is how may look one of the 9 circuits prepared for the tomography:</p>
<p><a href=""https://i.sstatic.net/8MtjB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8MtjB.png"" alt=""enter image description here"" /></a></p>
<p>EDIT: <a href=""https://algassert.com/quantum/2015/09/02/Partially-Erasing-Entanglement-with-Measurement.html#:%7E:text=A%20Bell%20pair%20is%20a,1%E2%88%9A2%7C111%E2%9F%A9."" rel=""nofollow noreferrer"">here</a> there is a partial answer, however, I'd still like to understand what is the meaning of my output matrix.</p>
",State tomography on a subsystem of the GHZ state,<qiskit><quantum-state><state-tomography><bell-basis>,2,0,,,"State tomography on a subsystem of the GHZ state <p>Premise: I am not sure whether I am missing something theoretically.</p>
<p>Given a circuit creating a GHZ state over 3 qubits, say q1, q2 and q3. If I do not consider q3 and perform a state tomography over q1 and q2, then intuitively, I should get a Bell state as output, i.e. <span class=""math-container"">$|\Phi^+\rangle\langle\Phi^+|$</span>.</p>
<p>Nevertheless the output is the following matrix:</p>
<pre><code>[[ 0.5, -0. ,  0. , -0. ],
   [-0. ,  0. ,  0. , -0. ],
   [ 0. ,  0. ,  0. ,  0. ],
   [-0. , -0. ,  0. ,  0.5]]
</code></pre>
<p>I am not observing q3. I also tried to reset it with the command <code>circuit.reset(2)</code>.</p>
<p>This is how may look one of the 9 circuits prepared for the tomography:</p>
<p><a href=""https://i.sstatic.net/8MtjB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8MtjB.png"" alt=""enter image description here"" /></a></p>
<p>EDIT: <a href=""https://algassert.com/quantum/2015/09/02/Partially-Erasing-Entanglement-with-Measurement.html#:%7E:text=A%20Bell%20pair%20is%20a,1%E2%88%9A2%7C111%E2%9F%A9."" rel=""nofollow noreferrer"">here</a> there is a partial answer, however, I'd still like to understand what is the meaning of my output matrix.</p>
",qc,state tomography subsystem ghz state p premise sure whether missing something p given circuit creating ghz state 3 qubits say q1 q2 q3 consider q3 perform state tomography q1 q2 intuitively get bell state output span p nevertheless output following matrix pre code 0 p observing q3 also tried reset command code 2 p may look one 9 circuits prepared tomography p https nofollow noreferrer img https enter image description p edit https 7e 20bell 20pair 20is e2 88 9a2 7c111 e2 9f a9 nofollow noreferrer partial answer however still like understand meaning output,"[(2, 0.019805636), (4, 0.2446583), (6, 0.017333867), (9, 0.07763796), (12, 0.034813404), (13, 0.15043126), (14, 0.25227466), (16, 0.023388814), (18, 0.16906561)]"
29402,,2022-12-17 03:10:47,1,225,"<p>I wrote code again using updated qiskit nature libraries but I am facing error , I need help to finding solution so that we can run this code on latest version of qiskit.</p>
<p>I am attaching code below......</p>
<p>import numpy as np</p>
<h1>Importing standard Qiskit libraries</h1>
<p>from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from ibm_quantum_widgets import *
from qiskit.providers.aer import QasmSimulator</p>
<h1>Loading your IBM Quantum account(s)</h1>
<p>provider = IBMQ.load_account()
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [3]:
from qiskit.algorithms import VQE
from qiskit_nature.second_q.algorithms import (GroundStateEigensolver,
NumPyMinimumEigensolverFactory)
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.mappers import ParityMapper, QubitConverter, JordanWignerMapper</p>
<p>import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.second_q.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [4]:
def get_qubit_op(dist):
# Define Molecule
molecule = MoleculeInfo(
# Coordinates in Angstrom
[&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (dist, 0.0, 0.0)],
multiplicity=1,  # = 2*spin + 1
charge=0,
)</p>
<pre><code>driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

# Get properties
properties = driver.run()
num_particles = properties.num_particles
num_spatial_orbitals = properties.num_spatial_orbitals

# Define Problem, Use freeze core approximation, remove orbitals.

transformer = FreezeCoreTransformer(freeze_core=True,remove_orbitals=[-3,-2])
problem = transformer.transform(properties)

num_spatial_orbitals = problem.num_spatial_orbitals
num_particles = problem.num_particles

hamiltonian = problem.hamiltonian.second_q_op()
# Do two qubit reduction
converter = QubitConverter(JordanWignerMapper())
reducer = TwoQubitReduction(num_particles)
qubit_op = converter.convert(hamiltonian)
qubit_op = reducer.convert(qubit_op)

return qubit_op, num_particles, num_spatial_orbitals, problem, converter
</code></pre>
<p>In [5]:
def exact_solver(problem, converter):
solver = NumPyMinimumEigensolverFactory()
calc = GroundStateEigensolver(converter, solver)
result = calc.solve(problem)
return result</p>
<p>backend = BasicAer.get_backend(&quot;statevector_simulator&quot;)
distances = np.arange(0.5, 4.0, 0.2)
exact_energies = []
vqe_energies = []
optimizer = SLSQP(maxiter=5)
for dist in distances:
(qubit_op, num_particles, num_spatial_orbitals,
problem, converter) = get_qubit_op(dist)
result = exact_solver(problem,converter)
exact_energies.append(result.total_energies[0].real)</p>
<pre><code>var_form = UCCSD()
var_form.num_particles = num_particles
var_form.num_spatial_orbitals = (num_spatial_orbitals)
var_form.qubit_converter = converter
init_state = HartreeFock()
init_state.num_particles = num_particles
init_state.num_spatial_orbitals = (num_spatial_orbitals)
init_state.qubit_converter = converter

var_form.initial_state=init_state

vqe = VQE(var_form, optimizer, quantum_instance=backend)
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
vqe_result = problem.interpret(vqe_calc).total_energies[0].real
vqe_energies.append(vqe_result)
print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
      f&quot;VQE Result: {vqe_result:.5f}&quot;,
      f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
</code></pre>
<p>print(&quot;All energies have been calculated&quot;)
Traceback (most recent call last):
Input In [5] in &lt;cell line: 12&gt;
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:496 in compute_minimum_eigenvalue
self._check_operator_ansatz(operator)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:331 in _check_operator_ansatz
raise AlgorithmError(
AlgorithmError: 'The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using <code>num_qubits</code>.'</p>
<p>Use %tb to get the full traceback.
Search for solution online</p>
",getting error while simulating LiH using VQE,<quantum-algorithms><simulation><vqe>,0,2,,,"getting error while simulating LiH using VQE <p>I wrote code again using updated qiskit nature libraries but I am facing error , I need help to finding solution so that we can run this code on latest version of qiskit.</p>
<p>I am attaching code below......</p>
<p>import numpy as np</p>
<h1>Importing standard Qiskit libraries</h1>
<p>from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from ibm_quantum_widgets import *
from qiskit.providers.aer import QasmSimulator</p>
<h1>Loading your IBM Quantum account(s)</h1>
<p>provider = IBMQ.load_account()
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [3]:
from qiskit.algorithms import VQE
from qiskit_nature.second_q.algorithms import (GroundStateEigensolver,
NumPyMinimumEigensolverFactory)
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.mappers import ParityMapper, QubitConverter, JordanWignerMapper</p>
<p>import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.second_q.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [4]:
def get_qubit_op(dist):
# Define Molecule
molecule = MoleculeInfo(
# Coordinates in Angstrom
[&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (dist, 0.0, 0.0)],
multiplicity=1,  # = 2*spin + 1
charge=0,
)</p>
<pre><code>driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

# Get properties
properties = driver.run()
num_particles = properties.num_particles
num_spatial_orbitals = properties.num_spatial_orbitals

# Define Problem, Use freeze core approximation, remove orbitals.

transformer = FreezeCoreTransformer(freeze_core=True,remove_orbitals=[-3,-2])
problem = transformer.transform(properties)

num_spatial_orbitals = problem.num_spatial_orbitals
num_particles = problem.num_particles

hamiltonian = problem.hamiltonian.second_q_op()
# Do two qubit reduction
converter = QubitConverter(JordanWignerMapper())
reducer = TwoQubitReduction(num_particles)
qubit_op = converter.convert(hamiltonian)
qubit_op = reducer.convert(qubit_op)

return qubit_op, num_particles, num_spatial_orbitals, problem, converter
</code></pre>
<p>In [5]:
def exact_solver(problem, converter):
solver = NumPyMinimumEigensolverFactory()
calc = GroundStateEigensolver(converter, solver)
result = calc.solve(problem)
return result</p>
<p>backend = BasicAer.get_backend(&quot;statevector_simulator&quot;)
distances = np.arange(0.5, 4.0, 0.2)
exact_energies = []
vqe_energies = []
optimizer = SLSQP(maxiter=5)
for dist in distances:
(qubit_op, num_particles, num_spatial_orbitals,
problem, converter) = get_qubit_op(dist)
result = exact_solver(problem,converter)
exact_energies.append(result.total_energies[0].real)</p>
<pre><code>var_form = UCCSD()
var_form.num_particles = num_particles
var_form.num_spatial_orbitals = (num_spatial_orbitals)
var_form.qubit_converter = converter
init_state = HartreeFock()
init_state.num_particles = num_particles
init_state.num_spatial_orbitals = (num_spatial_orbitals)
init_state.qubit_converter = converter

var_form.initial_state=init_state

vqe = VQE(var_form, optimizer, quantum_instance=backend)
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
vqe_result = problem.interpret(vqe_calc).total_energies[0].real
vqe_energies.append(vqe_result)
print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
      f&quot;VQE Result: {vqe_result:.5f}&quot;,
      f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
</code></pre>
<p>print(&quot;All energies have been calculated&quot;)
Traceback (most recent call last):
Input In [5] in &lt;cell line: 12&gt;
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:496 in compute_minimum_eigenvalue
self._check_operator_ansatz(operator)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:331 in _check_operator_ansatz
raise AlgorithmError(
AlgorithmError: 'The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using <code>num_qubits</code>.'</p>
<p>Use %tb to get the full traceback.
Search for solution online</p>
",qc,getting error simulating lih using vqe p wrote code using updated qiskit nature libraries facing error need help finding solution run code latest version p attaching code p import numpy np h1 importing standard qiskit libraries p qiskit import quantumcircuit transpile aer ibmq import import import import qasmsimulator h1 loading ibm quantum account p provider runtimewarning size changed may indicate binary incompatibility expected 56 c header got 64 pyobject 3 import vqe import groundstateeigensolver numpyminimumeigensolverfactory import pyscfdriver import moleculeinfo import freezecoretransformer import paritymapper qubitconverter jordanwignermapper p import plt import numpy np import uccsd hartreefock import efficientsu2 import cobyla spsa slsqp import twoqubitreduction qiskit import basicaer aer import quantuminstance import completemeasfitter import noisemodel runtimewarning size changed may indicate binary incompatibility expected 56 c header got 64 pyobject 4 def dist define molecule molecule moleculeinfo coordinates angstrom quot li quot quot h quot dist 2 spin 1 pre code driver molecule quot sto3g quot get properties properties define problem use freeze core approximation remove orbitals transformer freezecoretransformer problem properties hamiltonian two qubit reduction converter qubitconverter jordanwignermapper reducer twoqubitreduction hamiltonian return problem converter p 5 def problem converter solver numpyminimumeigensolverfactory calc groundstateeigensolver converter solver result problem return result p backend quot quot distances optimizer slsqp dist distances problem converter dist result problem converter 0 pre code uccsd converter hartreefock converter vqe vqe optimizer 0 print f quot interatomic distance dist 2 quot f quot vqe result quot f quot exact energy quot p print quot energies calculated quot traceback recent call last input 5 lt cell line 12 gt file operator file raise algorithmerror algorithmerror number qubits ansatz match operator ansatz allow setting number qubits using code p use tb get full traceback search solution online,"[(0, 0.55189323), (1, 0.021958997), (6, 0.010477144), (7, 0.03003769), (8, 0.11583022), (12, 0.035755754), (14, 0.046884537), (17, 0.081974424), (19, 0.09275688)]"
29497,29498.0,2022-12-28 18:57:36,0,485,"<p>I'm working my way through the ASPLOS paper &quot;CutQC: Using Small Quantum Computers for Large Quantum Circuit Evaluations&quot;. At the heart of the paper is, of course, the technique of circuit cutting. However, I find this early derivation perplexing.</p>
<p>We know that we can Pauli-decompose any <span class=""math-container"">$2 \times 2$</span> matrix as:
<span class=""math-container"">$$
  A = \frac{1}{2}\bigl(Tr(AI) I + Tr(AX)X + Tr(AY)Y + Tr(AZ)Z\bigr).
$$</span></p>
<p>The paper suggests to further decompose the Pauli matrices into their eigenbasis and write as:
<span class=""math-container"">$$
  A = \frac{A_1 + A_2 + A_3 + A_4}{2},
$$</span>
with
<span class=""math-container"">$$
A_1 = \bigl(Tr(AI) + Tr(AZ)\bigr)|0\rangle\langle 0| \\
A_2 = \bigl(Tr(AI) - Tr(AZ)\bigr)|1\rangle\langle 1| \\
A_3 = Tr(AX)\bigl( 2 |+\rangle\langle +| - |0\rangle\langle 0| - |1\rangle\langle 1|\bigr) \\
A_4 = Tr(AY)\bigl( 2 |+i\rangle\langle +i| - |0\rangle\langle 0| - |1\rangle\langle 1|\bigr)
$$</span></p>
<p>How is this being derived?</p>
",Decomposition of a $2\times2$ matrix in terms of Pauli matrices and rank-one projectors,<textbook-and-exercises><linear-algebra>,1,3,,,"Decomposition of a $2\times2$ matrix in terms of Pauli matrices and rank-one projectors <p>I'm working my way through the ASPLOS paper &quot;CutQC: Using Small Quantum Computers for Large Quantum Circuit Evaluations&quot;. At the heart of the paper is, of course, the technique of circuit cutting. However, I find this early derivation perplexing.</p>
<p>We know that we can Pauli-decompose any <span class=""math-container"">$2 \times 2$</span> matrix as:
<span class=""math-container"">$$
  A = \frac{1}{2}\bigl(Tr(AI) I + Tr(AX)X + Tr(AY)Y + Tr(AZ)Z\bigr).
$$</span></p>
<p>The paper suggests to further decompose the Pauli matrices into their eigenbasis and write as:
<span class=""math-container"">$$
  A = \frac{A_1 + A_2 + A_3 + A_4}{2},
$$</span>
with
<span class=""math-container"">$$
A_1 = \bigl(Tr(AI) + Tr(AZ)\bigr)|0\rangle\langle 0| \\
A_2 = \bigl(Tr(AI) - Tr(AZ)\bigr)|1\rangle\langle 1| \\
A_3 = Tr(AX)\bigl( 2 |+\rangle\langle +| - |0\rangle\langle 0| - |1\rangle\langle 1|\bigr) \\
A_4 = Tr(AY)\bigl( 2 |+i\rangle\langle +i| - |0\rangle\langle 0| - |1\rangle\langle 1|\bigr)
$$</span></p>
<p>How is this being derived?</p>
",qc,decomposition matrix terms pauli matrices projectors p working way asplos paper quot cutqc using small quantum computers large quantum circuit evaluations quot heart paper course technique circuit cutting however find early derivation p know span 2 2 matrix span 1 2 tr ai tr ax x tr ay tr az p paper suggests decompose pauli matrices eigenbasis write span 2 span tr ai tr az tr ai tr az tr ax 2 tr ay 2 p derived,"[(1, 0.050364114), (2, 0.08847376), (3, 0.56657), (4, 0.021193212), (9, 0.050066426), (10, 0.016654335), (11, 0.02535688), (12, 0.05728722), (14, 0.073428184), (19, 0.04919625)]"
29565,,2023-01-04 19:46:09,1,71,"<p>Consider the circuit below.</p>
<p><a href=""https://i.sstatic.net/PEp6Am.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PEp6Am.png"" alt="""" /></a></p>
<p>This is almost the same as the standard protocol to perform a non-local <span class=""math-container"">$CNOT_{0,3}$</span>. The only difference is that I decomposed the upper local <span class=""math-container"">$CNOT_{0,1}$</span> into one Ising gate and some local rotational gates.</p>
<p>When I attempt a simulated process tomography over qubits <span class=""math-container"">$q_0,q_3$</span> and evaluate the fidelity w.r.t. the ideal <span class=""math-container"">$CNOT$</span> I get a fidelity <span class=""math-container"">$\approx$</span>85%, with 100k shots.</p>
<p>Why does this happen? Does such a transpiling mess with the logic behind the non-local <span class=""math-container"">$CNOT$</span>?</p>
",Non-local $CNOT$ By means of Ising gates,<qiskit><simulation><gate-synthesis><non-locality><quantum-process-tomography>,0,0,,,"Non-local $CNOT$ By means of Ising gates <p>Consider the circuit below.</p>
<p><a href=""https://i.sstatic.net/PEp6Am.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PEp6Am.png"" alt="""" /></a></p>
<p>This is almost the same as the standard protocol to perform a non-local <span class=""math-container"">$CNOT_{0,3}$</span>. The only difference is that I decomposed the upper local <span class=""math-container"">$CNOT_{0,1}$</span> into one Ising gate and some local rotational gates.</p>
<p>When I attempt a simulated process tomography over qubits <span class=""math-container"">$q_0,q_3$</span> and evaluate the fidelity w.r.t. the ideal <span class=""math-container"">$CNOT$</span> I get a fidelity <span class=""math-container"">$\approx$</span>85%, with 100k shots.</p>
<p>Why does this happen? Does such a transpiling mess with the logic behind the non-local <span class=""math-container"">$CNOT$</span>?</p>
",qc,cnot means ising gates p consider circuit p https nofollow noreferrer img https p almost standard protocol perform span difference decomposed upper local span one ising gate local rotational p attempt simulated process tomography qubits span evaluate fidelity ideal span cnot get fidelity span 85 100k p happen transpiling mess logic behind span cnot,"[(1, 0.04690427), (3, 0.21422862), (4, 0.13481908), (9, 0.25650337), (12, 0.018940106), (14, 0.26159152), (15, 0.019025074), (18, 0.045762926)]"
29569,,2023-01-05 02:55:43,1,614,"<p>I'm working my way through the ASPLOS paper &quot;CutQC: Using Small Quantum Computers for Large Quantum Circuit Evaluations&quot;. At the heart of the paper is, of course, the technique of circuit cutting. A first derivation in the paper was already explained <a href=""https://quantumcomputing.stackexchange.com/a/29498/11582"">here</a>. However, I am lost after that.</p>
<p>Does anybody have a (pointer to a) clear, understandable example of quantum circuit cutting, preferably starting from a single qubit and expanding to a larger circuit after that?</p>
","Is there a clear, understandable example of Quantum Circuit Cutting I can use to understand the process?",<quantum-circuit>,2,3,,,"Is there a clear, understandable example of Quantum Circuit Cutting I can use to understand the process? <p>I'm working my way through the ASPLOS paper &quot;CutQC: Using Small Quantum Computers for Large Quantum Circuit Evaluations&quot;. At the heart of the paper is, of course, the technique of circuit cutting. A first derivation in the paper was already explained <a href=""https://quantumcomputing.stackexchange.com/a/29498/11582"">here</a>. However, I am lost after that.</p>
<p>Does anybody have a (pointer to a) clear, understandable example of quantum circuit cutting, preferably starting from a single qubit and expanding to a larger circuit after that?</p>
",qc,clear understandable example quantum circuit cutting use understand process p working way asplos paper quot cutqc using small quantum computers large quantum circuit evaluations quot heart paper course technique circuit cutting first derivation paper already explained https however lost p anybody pointer clear understandable example quantum circuit cutting preferably starting single qubit expanding larger circuit,"[(4, 0.1137891), (8, 0.23689851), (9, 0.2429873), (12, 0.019307612), (14, 0.3285278), (19, 0.0558025)]"
29618,,2023-01-09 09:57:46,2,135,"<p>I am using stim and sinter to compute the logical error rate of a QEC code.<br />
For the code I am testing, calling the function <code>sinter.collect()</code> triggers the following error:</p>
<pre><code>ValueError                                Traceback (most recent call last)
ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D31, D34, D58, D82, D994'.

In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to `stim.Circuit.detector_error_model(...)`.
From the command line, you can ignore this error by passing the flag `--ignore_decomposition_failures` to `stim analyze_errors`.
 
The function was called with arguments:
collected_qec_stats: List[sinter.TaskStats] = sinter.collect(
     20     num_workers=4,
     21     tasks=qec_tasks,
     22     decoders=['pymatching'],
     23     max_shots=100_000,
     24     max_errors=100,
     25     print_progress=True)
</code></pre>
<p>I was wondering if there is a way to enable the <code>ignore_decomposition_failures</code> from sinter API. If not, would this be possible by extending sinter API?
(the latter question might be more suitable as an issue in stim's repo)</p>
<p>What are the implications of ignoring decomposition failures in the computation of the logical error rates?</p>
",How to enable ignore_decomposition_failures in sinter.collect()?,<stim>,1,0,,,"How to enable ignore_decomposition_failures in sinter.collect()? <p>I am using stim and sinter to compute the logical error rate of a QEC code.<br />
For the code I am testing, calling the function <code>sinter.collect()</code> triggers the following error:</p>
<pre><code>ValueError                                Traceback (most recent call last)
ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D31, D34, D58, D82, D994'.

In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to `stim.Circuit.detector_error_model(...)`.
From the command line, you can ignore this error by passing the flag `--ignore_decomposition_failures` to `stim analyze_errors`.
 
The function was called with arguments:
collected_qec_stats: List[sinter.TaskStats] = sinter.collect(
     20     num_workers=4,
     21     tasks=qec_tasks,
     22     decoders=['pymatching'],
     23     max_shots=100_000,
     24     max_errors=100,
     25     print_progress=True)
</code></pre>
<p>I was wondering if there is a way to enable the <code>ignore_decomposition_failures</code> from sinter API. If not, would this be possible by extending sinter API?
(the latter question might be more suitable as an issue in stim's repo)</p>
<p>What are the implications of ignoring decomposition failures in the computation of the logical error rates?</p>
",qc,enable p using stim sinter compute logical error rate qec br code testing calling function code triggers following error pre code valueerror traceback recent call last valueerror failed decompose errors graphlike components two symptoms error component failed decompose d34 d58 d82 d994 python ignore error passing command line ignore error passing flag stim function called arguments list 20 21 22 23 24 25 p wondering way enable code sinter api would possible extending sinter api latter question might suitable issue stim repo p implications ignoring decomposition failures computation logical error rates,"[(0, 0.15786745), (5, 0.24787317), (6, 0.062744826), (9, 0.08874514), (12, 0.02304674), (14, 0.26986796), (16, 0.016489835), (19, 0.13198675)]"
29814,,2023-01-23 05:42:19,5,319,"<p>Theorem 2 of <a href=""https://arxiv.org/pdf/2101.02464.pdf"" rel=""noreferrer"">this paper</a> says if one is able to prepare <span class=""math-container"">$\rho^{\otimes k}$</span> then it is possible to predict expectation values of all <span class=""math-container"">$n$</span>-qubit Pauli observables using <span class=""math-container"">$O(n)$</span> number of copies of <span class=""math-container"">$\rho$</span>. It then gives an explicit procedure in Appendix E2, which is composed of two parts: (1) Estimating <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span> and (2) Estimating a sign of <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert$</span>. The paper mentioned that main idea to achieve (1) is to use the fact that <span class=""math-container"">$\sigma \otimes \sigma$</span> for any Pauli operator <span class=""math-container"">$\sigma$</span> commutes so that one can simultaneously measure them using Bell basis measurements. In Appendix E2 Eq. (E8) shows how to estimate <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span> using the Bell measurement as follows:</p>
<ol>
<li><p>Perform the Bell measurement on <span class=""math-container"">$\rho \otimes \rho$</span>; the outcome will be one of the Bell pairs.</p>
</li>
<li><p>Every Bell pair is an <span class=""math-container"">$\pm1$</span> eigenstate of any single qubit Pauli operator <span class=""math-container"">$\sigma \in \{I,X,Y,Z\}$</span>, where probability of getting <span class=""math-container"">$\pm1$</span> is <span class=""math-container"">$\frac{1}{2}\text{Tr}((I\otimes I \pm \sigma \otimes \sigma)(\rho \otimes \rho))$</span>. Hence, we have <span class=""math-container"">$\mathbb{E}[\text{Tr}((\sigma \otimes \sigma)S] = Prob(+) - Prob(-) = \lvert \text{Tr}(\sigma \rho)\rvert^2$</span> (Eq.(E8)).</p>
</li>
<li><p>So, as far as I understand, to obtain <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span>, we can perform Bell measurements on many copies of <span class=""math-container"">$\rho \otimes \rho$</span>, gather results of the outcomes <span class=""math-container"">$S_k$</span>, and classically calculate the above expectation value.</p>
</li>
</ol>
<p>Then the paper generalized this method to <span class=""math-container"">$n$</span>-qubit system and proved that only <span class=""math-container"">$O(n)$</span> copies of <span class=""math-container"">$\rho \otimes \rho$</span> are required in order to estimate <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span> for all <span class=""math-container"">$n$</span>-qubit Pauli operators <span class=""math-container"">$\sigma$</span>.</p>
<p>My question is: I understand the protocol but I couldn't immediately see how this procedure is related to the notion of &quot;simultaneous measurement&quot;? Does anyone catch this point?</p>
",Simultaneous measurements and Bell basis measurements to estimate $\lvert\text{Tr}(\sigma \rho)\rvert^2$ in Huang et al. paper,<measurement><machine-learning><bell-basis><probability>,2,1,,,"Simultaneous measurements and Bell basis measurements to estimate $\lvert\text{Tr}(\sigma \rho)\rvert^2$ in Huang et al. paper <p>Theorem 2 of <a href=""https://arxiv.org/pdf/2101.02464.pdf"" rel=""noreferrer"">this paper</a> says if one is able to prepare <span class=""math-container"">$\rho^{\otimes k}$</span> then it is possible to predict expectation values of all <span class=""math-container"">$n$</span>-qubit Pauli observables using <span class=""math-container"">$O(n)$</span> number of copies of <span class=""math-container"">$\rho$</span>. It then gives an explicit procedure in Appendix E2, which is composed of two parts: (1) Estimating <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span> and (2) Estimating a sign of <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert$</span>. The paper mentioned that main idea to achieve (1) is to use the fact that <span class=""math-container"">$\sigma \otimes \sigma$</span> for any Pauli operator <span class=""math-container"">$\sigma$</span> commutes so that one can simultaneously measure them using Bell basis measurements. In Appendix E2 Eq. (E8) shows how to estimate <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span> using the Bell measurement as follows:</p>
<ol>
<li><p>Perform the Bell measurement on <span class=""math-container"">$\rho \otimes \rho$</span>; the outcome will be one of the Bell pairs.</p>
</li>
<li><p>Every Bell pair is an <span class=""math-container"">$\pm1$</span> eigenstate of any single qubit Pauli operator <span class=""math-container"">$\sigma \in \{I,X,Y,Z\}$</span>, where probability of getting <span class=""math-container"">$\pm1$</span> is <span class=""math-container"">$\frac{1}{2}\text{Tr}((I\otimes I \pm \sigma \otimes \sigma)(\rho \otimes \rho))$</span>. Hence, we have <span class=""math-container"">$\mathbb{E}[\text{Tr}((\sigma \otimes \sigma)S] = Prob(+) - Prob(-) = \lvert \text{Tr}(\sigma \rho)\rvert^2$</span> (Eq.(E8)).</p>
</li>
<li><p>So, as far as I understand, to obtain <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span>, we can perform Bell measurements on many copies of <span class=""math-container"">$\rho \otimes \rho$</span>, gather results of the outcomes <span class=""math-container"">$S_k$</span>, and classically calculate the above expectation value.</p>
</li>
</ol>
<p>Then the paper generalized this method to <span class=""math-container"">$n$</span>-qubit system and proved that only <span class=""math-container"">$O(n)$</span> copies of <span class=""math-container"">$\rho \otimes \rho$</span> are required in order to estimate <span class=""math-container"">$\lvert\text{Tr}(\sigma \rho)\rvert^2$</span> for all <span class=""math-container"">$n$</span>-qubit Pauli operators <span class=""math-container"">$\sigma$</span>.</p>
<p>My question is: I understand the protocol but I couldn't immediately see how this procedure is related to the notion of &quot;simultaneous measurement&quot;? Does anyone catch this point?</p>
",qc,simultaneous measurements bell basis measurements estimate tr huang et al paper p theorem 2 https noreferrer paper says one able prepare span k possible predict expectation values span n pauli observables using span n number copies span gives explicit procedure appendix e2 composed two parts 1 estimating span tr 2 estimating sign span tr paper mentioned main idea achieve 1 use fact span pauli operator span commutes one simultaneously measure using bell basis measurements appendix e2 eq e8 shows estimate span tr using bell measurement follows ol li p perform bell measurement span outcome one bell li p every bell pair span eigenstate single qubit pauli operator span x probability getting span span 1 2 tr hence span e tr prob prob tr eq e8 li p far understand obtain span tr perform bell measurements many copies span gather results outcomes span classically calculate expectation p paper generalized method span n system proved span n copies span required order estimate span tr span n pauli operators span p question understand protocol could immediately see procedure related notion quot simultaneous measurement quot anyone catch point,"[(3, 0.5962905), (7, 0.07028276), (9, 0.048526857), (11, 0.013988921), (12, 0.011356074), (18, 0.24211244), (19, 0.012817909)]"
29961,30105.0,2023-01-31 11:20:43,3,70,"<p>I am reading a paper on Quantum Annealing [1], and the paper writes the following:</p>
<p>&quot;one of the fundamental challenges in building a fully programmable quantum annealer is the competing requirements of full controllable all-to-all connectivity and the quasi locality of the interactions between physical qubits.&quot;</p>
<p>I am not sure how to understand this sentence. In particular,</p>
<ul>
<li>What is meant by the 'quasi-locality' of the interactions, and</li>
<li>Why are these requirements competing?</li>
</ul>
<p>Many thanks!</p>
<p>[1] Lechner W, Hauke P, Zoller P. (2015). <em>A quantum annealing architecture with all-to-all connectivity from local interactions.</em> <a href=""https://www.science.org/doi/10.1126/sciadv.1500838"" rel=""nofollow noreferrer"">https://www.science.org/doi/10.1126/sciadv.1500838</a></p>
","What is meant by the ""quasi-locality"" of the interactions in a quantum annealer?",<annealing>,1,0,,,"What is meant by the ""quasi-locality"" of the interactions in a quantum annealer? <p>I am reading a paper on Quantum Annealing [1], and the paper writes the following:</p>
<p>&quot;one of the fundamental challenges in building a fully programmable quantum annealer is the competing requirements of full controllable all-to-all connectivity and the quasi locality of the interactions between physical qubits.&quot;</p>
<p>I am not sure how to understand this sentence. In particular,</p>
<ul>
<li>What is meant by the 'quasi-locality' of the interactions, and</li>
<li>Why are these requirements competing?</li>
</ul>
<p>Many thanks!</p>
<p>[1] Lechner W, Hauke P, Zoller P. (2015). <em>A quantum annealing architecture with all-to-all connectivity from local interactions.</em> <a href=""https://www.science.org/doi/10.1126/sciadv.1500838"" rel=""nofollow noreferrer"">https://www.science.org/doi/10.1126/sciadv.1500838</a></p>
",qc,meant interactions quantum annealer p reading paper quantum annealing 1 paper writes following p quot one fundamental challenges building fully programmable quantum annealer competing requirements full controllable connectivity quasi locality interactions physical quot p sure understand sentence particular ul li meant interactions li requirements competing p many thanks p 1 lechner w hauke p zoller 2015 em quantum annealing architecture connectivity local https nofollow noreferrer https,"[(1, 0.10478265), (2, 0.02320048), (3, 0.09843705), (8, 0.080337994), (9, 0.5510328), (11, 0.034228213), (12, 0.016590111), (15, 0.056046266), (19, 0.033539455)]"
30062,30065.0,2023-02-06 12:45:43,0,411,"<p>Let's say we have an error mechanism <code>error(0.1) D7 D8 ^ D9 D10 ^ D13 D15</code>. I understand that Stim is trying to decompose the complex errors into graphlike errors. It is saying: ok, we have one error mechanism, when it happens, we have three edges <code>D7--D8</code>, <code>D9--D10</code>, and <code>D13--D15</code>.</p>
<p>My understanding is that: we are adding these 3 weighted edges to the matching graph. And these 3 edges are <strong>dependent</strong> on each other. Namely, if <code>D7--D8</code> is triggered, then we also know that <code>D9--D10</code>, and <code>D13--D15</code> is triggered.</p>
<p>However, it is not right. Because the MWPM decoder assumes <strong>independent</strong> probability of each qubit suffering an error (if I understand it in the right way), which means the weights of the matching graph should also be <strong>independent</strong> of each other so that we can add weights of edges that connect two defects.</p>
<p>My questions are the followings:</p>
<ol>
<li>How does Stim convert a DEM to a matching graph with <strong>independent</strong> edges?</li>
<li>Let's say we have a DEM with two error mechanisms: <code>error(0.1) D1 D2 ^ D2 D3 ^ D7 D8</code> and <code>error(0.2) D2 D3 ^ D4 D7 ^ D7 </code>. How does Stim deal with the weight of edge <code>D2--D3</code>?</li>
<li>Can we get the matching graph <strong>with weights</strong> in some way?</li>
</ol>
<p>Thanks!</p>
",How is the match graph extracted from a stim.circuit.detector_error_model?,<error-correction><stim><pymatching>,1,0,,,"How is the match graph extracted from a stim.circuit.detector_error_model? <p>Let's say we have an error mechanism <code>error(0.1) D7 D8 ^ D9 D10 ^ D13 D15</code>. I understand that Stim is trying to decompose the complex errors into graphlike errors. It is saying: ok, we have one error mechanism, when it happens, we have three edges <code>D7--D8</code>, <code>D9--D10</code>, and <code>D13--D15</code>.</p>
<p>My understanding is that: we are adding these 3 weighted edges to the matching graph. And these 3 edges are <strong>dependent</strong> on each other. Namely, if <code>D7--D8</code> is triggered, then we also know that <code>D9--D10</code>, and <code>D13--D15</code> is triggered.</p>
<p>However, it is not right. Because the MWPM decoder assumes <strong>independent</strong> probability of each qubit suffering an error (if I understand it in the right way), which means the weights of the matching graph should also be <strong>independent</strong> of each other so that we can add weights of edges that connect two defects.</p>
<p>My questions are the followings:</p>
<ol>
<li>How does Stim convert a DEM to a matching graph with <strong>independent</strong> edges?</li>
<li>Let's say we have a DEM with two error mechanisms: <code>error(0.1) D1 D2 ^ D2 D3 ^ D7 D8</code> and <code>error(0.2) D2 D3 ^ D4 D7 ^ D7 </code>. How does Stim deal with the weight of edge <code>D2--D3</code>?</li>
<li>Can we get the matching graph <strong>with weights</strong> in some way?</li>
</ol>
<p>Thanks!</p>
",qc,match graph extracted p let say error mechanism code error d7 d8 d9 d10 d13 d15 understand stim trying decompose complex errors graphlike errors saying ok one error mechanism happens three edges code d7 d8 code d9 d10 code d13 d15 p understanding adding 3 weighted edges matching graph 3 edges strong dependent namely code d7 d8 triggered also know code d9 d10 code d13 d15 p however right mwpm decoder assumes strong independent probability qubit suffering error understand right way means weights matching graph also strong independent add weights edges connect two p questions followings ol li stim convert dem matching graph strong independent edges li let say dem two error mechanisms code error d1 d2 d2 d3 d7 d8 code error d2 d3 d4 d7 d7 stim deal weight edge code d2 d3 li get matching graph strong weights way p thanks,"[(5, 0.3233097), (6, 0.0891451), (7, 0.026954053), (8, 0.02788715), (12, 0.04003255), (13, 0.21950006), (14, 0.21297462), (17, 0.04826538), (19, 0.011058448)]"
30074,,2023-02-06 20:09:22,0,188,"<p>Did anyone try to simulate erasures with stim and can tell me whether he achieved values that hold with the literature?</p>
<p>I tried an unrotated surface code with erasures at the data qubits initialization and no other errors, and got threshold of ~0.2, far below the expected 0.5 of 2D surface code, and even below the 0.249 of a 3D surface code.</p>
<p>I tried to follow the method described in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim/26583#26583"">How do I perform an erasure error in stim?</a>.</p>
<p>Attached here the stim circuit (for d=3). I simulated an unrotated ladder-like surface code, for a Z logical memory.
Qubits with integer coordinates are data qubits and measurement ancilla, while qubits with half-integer are the erasure heralding ancillas.</p>
<p>The code and indexing scheme (| for dual data qubit, _ for primal data qubit, s for star syndrome ancilla, and f for face syndrome ancilla):</p>
<pre><code># Code- indices-
# |f|f| 0,5,10,15,20
# s-s-s 1,6,11,16,21
# |f|f| 2,7,12,17,22
# s-s-s 3,8,13,18,23
# |f|f| 4,9,14,19,24
QUBIT_COORDS(0, 0) 0
QUBIT_COORDS(0.5, 0.5) 25
QUBIT_COORDS(1, 0) 1
QUBIT_COORDS(2, 0) 2
QUBIT_COORDS(2.5, 0.5) 27
QUBIT_COORDS(3, 0) 3
QUBIT_COORDS(4, 0) 4
QUBIT_COORDS(4.5, 0.5) 29
QUBIT_COORDS(0, 1) 5
QUBIT_COORDS(1, 1) 6
QUBIT_COORDS(1.5, 1.5) 31
QUBIT_COORDS(2, 1) 7
QUBIT_COORDS(3, 1) 8
QUBIT_COORDS(3.5, 1.5) 33
QUBIT_COORDS(4, 1) 9
QUBIT_COORDS(0, 2) 10
QUBIT_COORDS(0.5, 2.5) 35
QUBIT_COORDS(1, 2) 11
QUBIT_COORDS(2, 2) 12
QUBIT_COORDS(2.5, 2.5) 37
QUBIT_COORDS(3, 2) 13
QUBIT_COORDS(4, 2) 14
QUBIT_COORDS(4.5, 2.5) 39
QUBIT_COORDS(0, 3) 15
QUBIT_COORDS(1, 3) 16
QUBIT_COORDS(1.5, 3.5) 41
QUBIT_COORDS(2, 3) 17
QUBIT_COORDS(3, 3) 18
QUBIT_COORDS(3.5, 3.5) 43
QUBIT_COORDS(4, 3) 19
QUBIT_COORDS(0, 4) 20
QUBIT_COORDS(0.5, 4.5) 45
QUBIT_COORDS(1, 4) 21
QUBIT_COORDS(2, 4) 22
QUBIT_COORDS(2.5, 4.5) 47
QUBIT_COORDS(3, 4) 23
QUBIT_COORDS(4, 4) 24
QUBIT_COORDS(4.5, 4.5) 49
TICK
R 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 27 29 31 33 35 37 39 41 43 45 47 49
PAULI_CHANNEL_2(0.0025, 0, 0, 0, 0.0025, 0, 0, 0, 0.0025, 0, 0, 0, 0.0025, 0, 0) 0 25 2 27 4 29 6 31 8 33 10 35 12 37 14 39 16 41 18 43 20 45 22 47 24 49
M 25
DETECTOR(0.5, 0.5, 0, 0) rec[-1]
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 29
DETECTOR(4.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 45
DETECTOR(0.5, 4.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 49
DETECTOR(4.5, 4.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE1(0) 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
TICK
H 1 3 11 13 21 23
DEPOLARIZE1(0) 1 3 11 13 21 23
TICK
CX 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
R 27 31 29 33 37 39 41 47 43 49
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 2 27 6 31 4 29 8 33 12 37 14 39 16 41 22 47 18 43 24 49
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 29
DETECTOR(4.5, 0.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 49
DETECTOR(4.5, 4.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
TICK
CX 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
R 31 35 33 37 41 39 43 45 47 49
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 6 31 10 35 8 33 12 37 16 41 14 39 18 43 20 45 22 47 24 49
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 45
DETECTOR(0.5, 4.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 49
DETECTOR(4.5, 4.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
TICK
CX 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
R 25 27 31 29 33 35 41 37 43 39
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 4 29 8 33 10 35 16 41 12 37 18 43 14 39
M 25
DETECTOR(0.5, 0.5, 0, 0) rec[-1]
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 29
DETECTOR(4.5, 0.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
TICK
CX 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
R 25 27 31 35 33 37 45 41 47 43
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 10 35 8 33 12 37 20 45 16 41 22 47 18 43
M 25
DETECTOR(0.5, 0.5, 0, 0) rec[-1]
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 45
DETECTOR(0.5, 4.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
SHIFT_COORDS(0, 0, 0, -5)
TICK
H 1 3 11 13 21 23
DEPOLARIZE1(0) 1 3 11 13 21 23
TICK
M(0) 1 3 11 13 21 23 5 7 9 15 17 19
DETECTOR(4, 3, 0) rec[-1]
DETECTOR(2, 3, 0) rec[-2]
DETECTOR(0, 3, 0) rec[-3]
DETECTOR(4, 1, 0) rec[-4]
DETECTOR(2, 1, 0) rec[-5]
DETECTOR(0, 1, 0) rec[-6]
REPEAT 3 {
    TICK
    R 1 3 11 13 21 23 5 7 9 15 17 19
    DEPOLARIZE1(0) 1 3 11 13 21 23 5 7 9 15 17 19
    TICK
    H 1 3 11 13 21 23
    DEPOLARIZE1(0) 1 3 11 13 21 23
    SHIFT_COORDS(0, 0, 1, 0)
    TICK
    CX 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
    R 27 31 29 33 37 39 41 47 43 49
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 2 27 6 31 4 29 8 33 12 37 14 39 16 41 22 47 18 43 24 49
    M 27
    DETECTOR(2.5, 0.5, 0, 0) rec[-1]
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 29
    DETECTOR(4.5, 0.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 39
    DETECTOR(4.5, 2.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 47
    DETECTOR(2.5, 4.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    M 49
    DETECTOR(4.5, 4.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
    TICK
    CX 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
    R 31 35 33 37 41 39 43 45 47 49
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 6 31 10 35 8 33 12 37 16 41 14 39 18 43 20 45 22 47 24 49
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 35
    DETECTOR(0.5, 2.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 39
    DETECTOR(4.5, 2.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    M 45
    DETECTOR(0.5, 4.5, 0, 0) rec[-1]
    M 47
    DETECTOR(2.5, 4.5, 0, 0) rec[-1]
    M 49
    DETECTOR(4.5, 4.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
    TICK
    CX 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
    R 25 27 31 29 33 35 41 37 43 39
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 4 29 8 33 10 35 16 41 12 37 18 43 14 39
    M 25
    DETECTOR(0.5, 0.5, 0, 0) rec[-1]
    M 27
    DETECTOR(2.5, 0.5, 0, 0) rec[-1]
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 29
    DETECTOR(4.5, 0.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 35
    DETECTOR(0.5, 2.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    M 39
    DETECTOR(4.5, 2.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
    TICK
    CX 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
    R 25 27 31 35 33 37 45 41 47 43
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 10 35 8 33 12 37 20 45 16 41 22 47 18 43
    M 25
    DETECTOR(0.5, 0.5, 0, 0) rec[-1]
    M 27
    DETECTOR(2.5, 0.5, 0, 0) rec[-1]
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 35
    DETECTOR(0.5, 2.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 45
    DETECTOR(0.5, 4.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 47
    DETECTOR(2.5, 4.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
    SHIFT_COORDS(0, 0, 0, -4)
    TICK
    H 1 3 11 13 21 23
    DEPOLARIZE1(0) 1 3 11 13 21 23
    TICK
    M(0) 1 3 11 13 21 23 5 7 9 15 17 19
    DETECTOR(4, 3, 0) rec[-1] rec[-53]
    DETECTOR(2, 3, 0) rec[-2] rec[-54]
    DETECTOR(0, 3, 0) rec[-3] rec[-55]
    DETECTOR(4, 1, 0) rec[-4] rec[-56]
    DETECTOR(2, 1, 0) rec[-5] rec[-57]
    DETECTOR(0, 1, 0) rec[-6] rec[-58]
    DETECTOR(3, 4, 0) rec[-7] rec[-59]
    DETECTOR(1, 4, 0) rec[-8] rec[-60]
    DETECTOR(3, 2, 0) rec[-9] rec[-61]
    DETECTOR(1, 2, 0) rec[-10] rec[-62]
    DETECTOR(3, 0, 0) rec[-11] rec[-63]
    DETECTOR(1, 0, 0) rec[-12] rec[-64]
}
TICK
SHIFT_COORDS(0, 0, 1, 0)
M(0) 0 2 4 10 12 14 20 22 24 6 8 16 18
DETECTOR(0, 1, 0) rec[-19] rec[-4] rec[-10] rec[-13]
DETECTOR(2, 1, 0) rec[-18] rec[-3] rec[-9] rec[-12] rec[-4]
DETECTOR(4, 1, 0) rec[-17] rec[-8] rec[-11] rec[-3]
DETECTOR(0, 3, 0) rec[-16] rec[-2] rec[-7] rec[-10]
DETECTOR(2, 3, 0) rec[-15] rec[-1] rec[-6] rec[-9] rec[-2]
DETECTOR(4, 3, 0) rec[-14] rec[-5] rec[-8] rec[-1]
OBSERVABLE_INCLUDE(0) rec[-13] rec[-12] rec[-11]
</code></pre>
",Threshold value when simulating erasures with stim,<error-correction><stim>,1,5,,,"Threshold value when simulating erasures with stim <p>Did anyone try to simulate erasures with stim and can tell me whether he achieved values that hold with the literature?</p>
<p>I tried an unrotated surface code with erasures at the data qubits initialization and no other errors, and got threshold of ~0.2, far below the expected 0.5 of 2D surface code, and even below the 0.249 of a 3D surface code.</p>
<p>I tried to follow the method described in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim/26583#26583"">How do I perform an erasure error in stim?</a>.</p>
<p>Attached here the stim circuit (for d=3). I simulated an unrotated ladder-like surface code, for a Z logical memory.
Qubits with integer coordinates are data qubits and measurement ancilla, while qubits with half-integer are the erasure heralding ancillas.</p>
<p>The code and indexing scheme (| for dual data qubit, _ for primal data qubit, s for star syndrome ancilla, and f for face syndrome ancilla):</p>
<pre><code># Code- indices-
# |f|f| 0,5,10,15,20
# s-s-s 1,6,11,16,21
# |f|f| 2,7,12,17,22
# s-s-s 3,8,13,18,23
# |f|f| 4,9,14,19,24
QUBIT_COORDS(0, 0) 0
QUBIT_COORDS(0.5, 0.5) 25
QUBIT_COORDS(1, 0) 1
QUBIT_COORDS(2, 0) 2
QUBIT_COORDS(2.5, 0.5) 27
QUBIT_COORDS(3, 0) 3
QUBIT_COORDS(4, 0) 4
QUBIT_COORDS(4.5, 0.5) 29
QUBIT_COORDS(0, 1) 5
QUBIT_COORDS(1, 1) 6
QUBIT_COORDS(1.5, 1.5) 31
QUBIT_COORDS(2, 1) 7
QUBIT_COORDS(3, 1) 8
QUBIT_COORDS(3.5, 1.5) 33
QUBIT_COORDS(4, 1) 9
QUBIT_COORDS(0, 2) 10
QUBIT_COORDS(0.5, 2.5) 35
QUBIT_COORDS(1, 2) 11
QUBIT_COORDS(2, 2) 12
QUBIT_COORDS(2.5, 2.5) 37
QUBIT_COORDS(3, 2) 13
QUBIT_COORDS(4, 2) 14
QUBIT_COORDS(4.5, 2.5) 39
QUBIT_COORDS(0, 3) 15
QUBIT_COORDS(1, 3) 16
QUBIT_COORDS(1.5, 3.5) 41
QUBIT_COORDS(2, 3) 17
QUBIT_COORDS(3, 3) 18
QUBIT_COORDS(3.5, 3.5) 43
QUBIT_COORDS(4, 3) 19
QUBIT_COORDS(0, 4) 20
QUBIT_COORDS(0.5, 4.5) 45
QUBIT_COORDS(1, 4) 21
QUBIT_COORDS(2, 4) 22
QUBIT_COORDS(2.5, 4.5) 47
QUBIT_COORDS(3, 4) 23
QUBIT_COORDS(4, 4) 24
QUBIT_COORDS(4.5, 4.5) 49
TICK
R 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 27 29 31 33 35 37 39 41 43 45 47 49
PAULI_CHANNEL_2(0.0025, 0, 0, 0, 0.0025, 0, 0, 0, 0.0025, 0, 0, 0, 0.0025, 0, 0) 0 25 2 27 4 29 6 31 8 33 10 35 12 37 14 39 16 41 18 43 20 45 22 47 24 49
M 25
DETECTOR(0.5, 0.5, 0, 0) rec[-1]
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 29
DETECTOR(4.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 45
DETECTOR(0.5, 4.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 49
DETECTOR(4.5, 4.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE1(0) 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
TICK
H 1 3 11 13 21 23
DEPOLARIZE1(0) 1 3 11 13 21 23
TICK
CX 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
R 27 31 29 33 37 39 41 47 43 49
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 2 27 6 31 4 29 8 33 12 37 14 39 16 41 22 47 18 43 24 49
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 29
DETECTOR(4.5, 0.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 49
DETECTOR(4.5, 4.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
TICK
CX 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
R 31 35 33 37 41 39 43 45 47 49
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 6 31 10 35 8 33 12 37 16 41 14 39 18 43 20 45 22 47 24 49
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 45
DETECTOR(0.5, 4.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 49
DETECTOR(4.5, 4.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
TICK
CX 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
R 25 27 31 29 33 35 41 37 43 39
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 4 29 8 33 10 35 16 41 12 37 18 43 14 39
M 25
DETECTOR(0.5, 0.5, 0, 0) rec[-1]
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 29
DETECTOR(4.5, 0.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
M 39
DETECTOR(4.5, 2.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
TICK
CX 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
R 25 27 31 35 33 37 45 41 47 43
PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 10 35 8 33 12 37 20 45 16 41 22 47 18 43
M 25
DETECTOR(0.5, 0.5, 0, 0) rec[-1]
M 27
DETECTOR(2.5, 0.5, 0, 0) rec[-1]
M 31
DETECTOR(1.5, 1.5, 0, 0) rec[-1]
M 35
DETECTOR(0.5, 2.5, 0, 0) rec[-1]
M 33
DETECTOR(3.5, 1.5, 0, 0) rec[-1]
M 37
DETECTOR(2.5, 2.5, 0, 0) rec[-1]
M 45
DETECTOR(0.5, 4.5, 0, 0) rec[-1]
M 41
DETECTOR(1.5, 3.5, 0, 0) rec[-1]
M 47
DETECTOR(2.5, 4.5, 0, 0) rec[-1]
M 43
DETECTOR(3.5, 3.5, 0, 0) rec[-1]
SHIFT_COORDS(0, 0, 0, 1)
DEPOLARIZE2(0) 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
SHIFT_COORDS(0, 0, 0, -5)
TICK
H 1 3 11 13 21 23
DEPOLARIZE1(0) 1 3 11 13 21 23
TICK
M(0) 1 3 11 13 21 23 5 7 9 15 17 19
DETECTOR(4, 3, 0) rec[-1]
DETECTOR(2, 3, 0) rec[-2]
DETECTOR(0, 3, 0) rec[-3]
DETECTOR(4, 1, 0) rec[-4]
DETECTOR(2, 1, 0) rec[-5]
DETECTOR(0, 1, 0) rec[-6]
REPEAT 3 {
    TICK
    R 1 3 11 13 21 23 5 7 9 15 17 19
    DEPOLARIZE1(0) 1 3 11 13 21 23 5 7 9 15 17 19
    TICK
    H 1 3 11 13 21 23
    DEPOLARIZE1(0) 1 3 11 13 21 23
    SHIFT_COORDS(0, 0, 1, 0)
    TICK
    CX 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
    R 27 31 29 33 37 39 41 47 43 49
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 2 27 6 31 4 29 8 33 12 37 14 39 16 41 22 47 18 43 24 49
    M 27
    DETECTOR(2.5, 0.5, 0, 0) rec[-1]
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 29
    DETECTOR(4.5, 0.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 39
    DETECTOR(4.5, 2.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 47
    DETECTOR(2.5, 4.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    M 49
    DETECTOR(4.5, 4.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24
    TICK
    CX 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
    R 31 35 33 37 41 39 43 45 47 49
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 6 31 10 35 8 33 12 37 16 41 14 39 18 43 20 45 22 47 24 49
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 35
    DETECTOR(0.5, 2.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 39
    DETECTOR(4.5, 2.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    M 45
    DETECTOR(0.5, 4.5, 0, 0) rec[-1]
    M 47
    DETECTOR(2.5, 4.5, 0, 0) rec[-1]
    M 49
    DETECTOR(4.5, 4.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19
    TICK
    CX 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
    R 25 27 31 29 33 35 41 37 43 39
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 4 29 8 33 10 35 16 41 12 37 18 43 14 39
    M 25
    DETECTOR(0.5, 0.5, 0, 0) rec[-1]
    M 27
    DETECTOR(2.5, 0.5, 0, 0) rec[-1]
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 29
    DETECTOR(4.5, 0.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 35
    DETECTOR(0.5, 2.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    M 39
    DETECTOR(4.5, 2.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19
    TICK
    CX 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
    R 25 27 31 35 33 37 45 41 47 43
    PAULI_CHANNEL_2(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) 0 25 2 27 6 31 10 35 8 33 12 37 20 45 16 41 22 47 18 43
    M 25
    DETECTOR(0.5, 0.5, 0, 0) rec[-1]
    M 27
    DETECTOR(2.5, 0.5, 0, 0) rec[-1]
    M 31
    DETECTOR(1.5, 1.5, 0, 0) rec[-1]
    M 35
    DETECTOR(0.5, 2.5, 0, 0) rec[-1]
    M 33
    DETECTOR(3.5, 1.5, 0, 0) rec[-1]
    M 37
    DETECTOR(2.5, 2.5, 0, 0) rec[-1]
    M 45
    DETECTOR(0.5, 4.5, 0, 0) rec[-1]
    M 41
    DETECTOR(1.5, 3.5, 0, 0) rec[-1]
    M 47
    DETECTOR(2.5, 4.5, 0, 0) rec[-1]
    M 43
    DETECTOR(3.5, 3.5, 0, 0) rec[-1]
    SHIFT_COORDS(0, 0, 0, 1)
    DEPOLARIZE2(0) 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19
    SHIFT_COORDS(0, 0, 0, -4)
    TICK
    H 1 3 11 13 21 23
    DEPOLARIZE1(0) 1 3 11 13 21 23
    TICK
    M(0) 1 3 11 13 21 23 5 7 9 15 17 19
    DETECTOR(4, 3, 0) rec[-1] rec[-53]
    DETECTOR(2, 3, 0) rec[-2] rec[-54]
    DETECTOR(0, 3, 0) rec[-3] rec[-55]
    DETECTOR(4, 1, 0) rec[-4] rec[-56]
    DETECTOR(2, 1, 0) rec[-5] rec[-57]
    DETECTOR(0, 1, 0) rec[-6] rec[-58]
    DETECTOR(3, 4, 0) rec[-7] rec[-59]
    DETECTOR(1, 4, 0) rec[-8] rec[-60]
    DETECTOR(3, 2, 0) rec[-9] rec[-61]
    DETECTOR(1, 2, 0) rec[-10] rec[-62]
    DETECTOR(3, 0, 0) rec[-11] rec[-63]
    DETECTOR(1, 0, 0) rec[-12] rec[-64]
}
TICK
SHIFT_COORDS(0, 0, 1, 0)
M(0) 0 2 4 10 12 14 20 22 24 6 8 16 18
DETECTOR(0, 1, 0) rec[-19] rec[-4] rec[-10] rec[-13]
DETECTOR(2, 1, 0) rec[-18] rec[-3] rec[-9] rec[-12] rec[-4]
DETECTOR(4, 1, 0) rec[-17] rec[-8] rec[-11] rec[-3]
DETECTOR(0, 3, 0) rec[-16] rec[-2] rec[-7] rec[-10]
DETECTOR(2, 3, 0) rec[-15] rec[-1] rec[-6] rec[-9] rec[-2]
DETECTOR(4, 3, 0) rec[-14] rec[-5] rec[-8] rec[-1]
OBSERVABLE_INCLUDE(0) rec[-13] rec[-12] rec[-11]
</code></pre>
",qc,threshold value simulating erasures stim p anyone try simulate erasures stim tell whether achieved values hold literature p tried unrotated surface code erasures data qubits initialization errors got threshold far expected 2d surface code even 3d surface p tried follow method described https 26583 perform erasure error stim p attached stim circuit simulated unrotated surface code z logical memory qubits integer coordinates data qubits measurement ancilla qubits erasure heralding p code indexing scheme dual data qubit primal data qubit star syndrome ancilla f face syndrome ancilla pre code 0 0 0 25 1 0 1 2 0 2 27 3 0 3 4 0 4 29 0 1 5 1 1 6 31 2 1 7 3 1 8 33 4 1 9 0 2 10 35 1 2 11 2 2 12 37 3 2 13 4 2 14 39 0 3 15 1 3 16 41 2 3 17 3 3 18 43 4 3 19 0 4 20 45 1 4 21 2 4 22 47 3 4 23 4 4 24 49 tick r 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 27 29 31 33 35 37 39 41 43 45 47 49 0 0 0 0 0 0 0 0 0 0 0 0 25 2 27 4 29 6 31 8 33 10 35 12 37 14 39 16 41 18 43 20 45 22 47 24 49 25 detector 0 0 rec 27 detector 0 0 rec 29 detector 0 0 rec 31 detector 0 0 rec 33 detector 0 0 rec 35 detector 0 0 rec 37 detector 0 0 rec 39 detector 0 0 rec 41 detector 0 0 rec 43 detector 0 0 rec 45 detector 0 0 rec 47 detector 0 0 rec 49 detector 0 0 rec 0 0 0 1 depolarize1 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 tick h 1 3 11 13 21 23 depolarize1 0 1 3 11 13 21 23 tick cx 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24 r 27 31 29 33 37 39 41 47 43 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 27 6 31 4 29 8 33 12 37 14 39 16 41 22 47 18 43 24 49 27 detector 0 0 rec 31 detector 0 0 rec 29 detector 0 0 rec 33 detector 0 0 rec 37 detector 0 0 rec 39 detector 0 0 rec 41 detector 0 0 rec 47 detector 0 0 rec 43 detector 0 0 rec 49 detector 0 0 rec 0 0 0 1 depolarize2 0 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24 tick cx 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19 r 31 35 33 37 41 39 43 45 47 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 31 10 35 8 33 12 37 16 41 14 39 18 43 20 45 22 47 24 49 31 detector 0 0 rec 35 detector 0 0 rec 33 detector 0 0 rec 37 detector 0 0 rec 41 detector 0 0 rec 39 detector 0 0 rec 43 detector 0 0 rec 45 detector 0 0 rec 47 detector 0 0 rec 49 detector 0 0 rec 0 0 0 1 depolarize2 0 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19 tick cx 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19 r 25 27 31 29 33 35 41 37 43 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 25 2 27 6 31 4 29 8 33 10 35 16 41 12 37 18 43 14 39 25 detector 0 0 rec 27 detector 0 0 rec 31 detector 0 0 rec 29 detector 0 0 rec 33 detector 0 0 rec 35 detector 0 0 rec 41 detector 0 0 rec 37 detector 0 0 rec 43 detector 0 0 rec 39 detector 0 0 rec 0 0 0 1 depolarize2 0 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19 tick cx 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19 r 25 27 31 35 33 37 45 41 47 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 25 2 27 6 31 10 35 8 33 12 37 20 45 16 41 22 47 18 43 25 detector 0 0 rec 27 detector 0 0 rec 31 detector 0 0 rec 35 detector 0 0 rec 33 detector 0 0 rec 37 detector 0 0 rec 45 detector 0 0 rec 41 detector 0 0 rec 47 detector 0 0 rec 43 detector 0 0 rec 0 0 0 1 depolarize2 0 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19 0 0 0 tick h 1 3 11 13 21 23 depolarize1 0 1 3 11 13 21 23 tick 0 1 3 11 13 21 23 5 7 9 15 17 19 detector 4 3 0 rec detector 2 3 0 rec detector 0 3 0 rec detector 4 1 0 rec detector 2 1 0 rec detector 0 1 0 rec repeat 3 tick r 1 3 11 13 21 23 5 7 9 15 17 19 depolarize1 0 1 3 11 13 21 23 5 7 9 15 17 19 tick h 1 3 11 13 21 23 depolarize1 0 1 3 11 13 21 23 0 0 1 0 tick cx 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24 r 27 31 29 33 37 39 41 47 43 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 27 6 31 4 29 8 33 12 37 14 39 16 41 22 47 18 43 24 49 27 detector 0 0 rec 31 detector 0 0 rec 29 detector 0 0 rec 33 detector 0 0 rec 37 detector 0 0 rec 39 detector 0 0 rec 41 detector 0 0 rec 47 detector 0 0 rec 43 detector 0 0 rec 49 detector 0 0 rec 0 0 0 1 depolarize2 0 1 2 6 5 3 4 8 7 11 12 13 14 16 15 21 22 18 17 23 24 tick cx 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19 r 31 35 33 37 41 39 43 45 47 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 31 10 35 8 33 12 37 16 41 14 39 18 43 20 45 22 47 24 49 31 detector 0 0 rec 35 detector 0 0 rec 33 detector 0 0 rec 37 detector 0 0 rec 41 detector 0 0 rec 39 detector 0 0 rec 43 detector 0 0 rec 45 detector 0 0 rec 47 detector 0 0 rec 49 detector 0 0 rec 0 0 0 1 depolarize2 0 1 6 10 5 3 8 12 7 11 16 14 9 13 18 20 15 22 17 24 19 tick cx 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19 r 25 27 31 29 33 35 41 37 43 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 25 2 27 6 31 4 29 8 33 10 35 16 41 12 37 18 43 14 39 25 detector 0 0 rec 27 detector 0 0 rec 31 detector 0 0 rec 29 detector 0 0 rec 33 detector 0 0 rec 35 detector 0 0 rec 41 detector 0 0 rec 37 detector 0 0 rec 43 detector 0 0 rec 39 detector 0 0 rec 0 0 0 1 depolarize2 0 0 5 2 7 11 6 4 9 13 8 10 15 21 16 12 17 23 18 14 19 tick cx 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19 r 25 27 31 35 33 37 45 41 47 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 25 2 27 6 31 10 35 8 33 12 37 20 45 16 41 22 47 18 43 25 detector 0 0 rec 27 detector 0 0 rec 31 detector 0 0 rec 35 detector 0 0 rec 33 detector 0 0 rec 37 detector 0 0 rec 45 detector 0 0 rec 41 detector 0 0 rec 47 detector 0 0 rec 43 detector 0 0 rec 0 0 0 1 depolarize2 0 1 0 3 2 6 7 11 10 8 9 13 12 21 20 16 17 23 22 18 19 0 0 0 tick h 1 3 11 13 21 23 depolarize1 0 1 3 11 13 21 23 tick 0 1 3 11 13 21 23 5 7 9 15 17 19 detector 4 3 0 rec rec detector 2 3 0 rec rec detector 0 3 0 rec rec detector 4 1 0 rec rec detector 2 1 0 rec rec detector 0 1 0 rec rec detector 3 4 0 rec rec detector 1 4 0 rec rec detector 3 2 0 rec rec detector 1 2 0 rec rec detector 3 0 0 rec rec detector 1 0 0 rec rec tick 0 0 1 0 0 0 2 4 10 12 14 20 22 24 6 8 16 18 detector 0 1 0 rec rec rec rec detector 2 1 0 rec rec rec rec rec detector 4 1 0 rec rec rec rec detector 0 3 0 rec rec rec rec detector 2 3 0 rec rec rec rec rec detector 4 3 0 rec rec rec rec 0 rec rec rec,"[(2, 0.28858325), (6, 0.59745103), (9, 0.09131573), (12, 0.013180394)]"
30137,,2023-02-09 11:21:23,0,121,"<p>Trying to run <a href=""https://learn.microsoft.com/en-us/azure/quantum/quickstart-microsoft-qiskit?pivots=platform-rigetti"" rel=""nofollow noreferrer"">this example</a> (<strong>Submit a circuit with Qiskit to Azure Quantum</strong>) on Riggeti from Azure, with a US account, but job <strong>failed</strong> with this error on the Job management console of Azure:</p>
<pre><code>Error code: QIRPreProcessingFailed
Error message: No match found for output recording set converter from outputrecordingset.v2.labeled to outputrecordingset.v1.nonlabeled
</code></pre>
<p>And this error in my python console when running <code>job_monitor()</code>:</p>
<pre><code>Job Status: job incurred error  
</code></pre>
<p>(It is working when I try IONQ or Quantinuum)</p>
<p><strong>Any suggestions?</strong></p>
<p>BTW - one of the main differences between running Ionq/Quantinuum to running on Rigetti is the <code>_translate_input</code> function.
In the first two, the method is overided in the context of backend, to support non QIR circuit.
In Rigetti they use the default <code>_translate_input</code> of <code>AzureBackend</code>.</p>
<p>Rigetti, under <code>AzureBackend</code> general object:</p>
<pre><code>    def _translate_input(self, circuit, data_format, input_params, to_qir_kwargs={}):
    &quot;&quot;&quot; Translates the input values to the format expected by the AzureBackend. &quot;&quot;&quot;
    if data_format != &quot;qir.v1&quot;:
        target = self.name()
        raise ValueError(f&quot;{data_format} is not a supported data format for target {target}.&quot;)

    logger.info(f&quot;Using QIR as the job's payload format.&quot;)
    from qiskit_qir import to_qir_bitcode, to_qir

    # Set of gates supported by QIR targets.
    from qiskit_qir import SUPPORTED_INSTRUCTIONS as qir_supported_instructions

    capability = input_params[&quot;targetCapability&quot;] if &quot;targetCapability&quot; in input_params else &quot;AdaptiveExecution&quot;

    if logger.isEnabledFor(logging.DEBUG):
        logger.debug(f&quot;QIR:\n{to_qir(circuit, capability, **to_qir_kwargs)}&quot;)

    # all qir payload needs to define an entryPoint and arguments:
    if not &quot;entryPoint&quot; in input_params:
        input_params[&quot;entryPoint&quot;] = &quot;main&quot;
    if not &quot;arguments&quot; in input_params:
        input_params[&quot;arguments&quot;] = []

    # We'll transpile automatically to the supported gates in QIR unless explicitly skipped.
    if not input_params.get(&quot;skipTranspile&quot;, False):
        circuit = transpile(circuit, basis_gates = qir_supported_instructions)

        # We'll only log the QIR again if we performed a transpilation.
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug(f&quot;QIR (Post-transpilation):\n{to_qir(circuit, capability, **to_qir_kwargs)}&quot;)

    qir = bytes(to_qir_bitcode(circuit, capability, **to_qir_kwargs))
    return (qir, data_format, input_params)
</code></pre>
<p>In Qunatinuum, under <code>QuantinuumBackend</code>:</p>
<pre><code>    def _translate_input(self, circuit, data_format, input_params, to_qir_kwargs={}):
    &quot;&quot;&quot; Translates the input values to the format expected by the AzureBackend. &quot;&quot;&quot;
    if input_params[&quot;targetCapability&quot;] == &quot;openqasm&quot;:
        return (circuit.qasm(), data_format, input_params)
    else:
        # Not using openqasm, assume qir then:
        return super()._translate_input(circuit, &quot;qir.v1&quot;, input_params, to_qir_kwargs)
</code></pre>
<p>In Ionq, under <code>IonQBackendBackend</code>:</p>
<pre><code>    def _translate_input(self, circuit, data_format, input_params, to_qir_kwargs={}):
    &quot;&quot;&quot; Translates the input values to the format expected by the AzureBackend. &quot;&quot;&quot;
    if data_format == &quot;ionq.circuit.v1&quot;:
        ionq_circ, _, _ = qiskit_circ_to_ionq_circ(circuit, gateset=self.gateset())
        input_data = {
            &quot;gateset&quot;: self.gateset(),
            &quot;qubits&quot;: circuit.num_qubits,
            &quot;circuit&quot;: ionq_circ,
        }
        return (IonQ._encode_input_data(input_data), data_format, input_params)
    else:
        return super()._translate_input(circuit, data_format, input_params, to_qir_kwargs)
</code></pre>
<p>One more difference is <code>content_type</code> of <code>run()</code> function. Looks like in Rigetti they mistakenly took the same <code>str</code> as <code>input_data_format</code>:
<a href=""https://i.sstatic.net/G1xWL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/G1xWL.png"" alt=""enter image description here"" /></a></p>
<p>This is not the case in Quantinuum:
<a href=""https://i.sstatic.net/4cKPT.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4cKPT.png"" alt=""enter image description here"" /></a></p>
",Not able to run on Riggeti from Azure,<qiskit><azure-quantum><rigetti>,1,0,,,"Not able to run on Riggeti from Azure <p>Trying to run <a href=""https://learn.microsoft.com/en-us/azure/quantum/quickstart-microsoft-qiskit?pivots=platform-rigetti"" rel=""nofollow noreferrer"">this example</a> (<strong>Submit a circuit with Qiskit to Azure Quantum</strong>) on Riggeti from Azure, with a US account, but job <strong>failed</strong> with this error on the Job management console of Azure:</p>
<pre><code>Error code: QIRPreProcessingFailed
Error message: No match found for output recording set converter from outputrecordingset.v2.labeled to outputrecordingset.v1.nonlabeled
</code></pre>
<p>And this error in my python console when running <code>job_monitor()</code>:</p>
<pre><code>Job Status: job incurred error  
</code></pre>
<p>(It is working when I try IONQ or Quantinuum)</p>
<p><strong>Any suggestions?</strong></p>
<p>BTW - one of the main differences between running Ionq/Quantinuum to running on Rigetti is the <code>_translate_input</code> function.
In the first two, the method is overided in the context of backend, to support non QIR circuit.
In Rigetti they use the default <code>_translate_input</code> of <code>AzureBackend</code>.</p>
<p>Rigetti, under <code>AzureBackend</code> general object:</p>
<pre><code>    def _translate_input(self, circuit, data_format, input_params, to_qir_kwargs={}):
    &quot;&quot;&quot; Translates the input values to the format expected by the AzureBackend. &quot;&quot;&quot;
    if data_format != &quot;qir.v1&quot;:
        target = self.name()
        raise ValueError(f&quot;{data_format} is not a supported data format for target {target}.&quot;)

    logger.info(f&quot;Using QIR as the job's payload format.&quot;)
    from qiskit_qir import to_qir_bitcode, to_qir

    # Set of gates supported by QIR targets.
    from qiskit_qir import SUPPORTED_INSTRUCTIONS as qir_supported_instructions

    capability = input_params[&quot;targetCapability&quot;] if &quot;targetCapability&quot; in input_params else &quot;AdaptiveExecution&quot;

    if logger.isEnabledFor(logging.DEBUG):
        logger.debug(f&quot;QIR:\n{to_qir(circuit, capability, **to_qir_kwargs)}&quot;)

    # all qir payload needs to define an entryPoint and arguments:
    if not &quot;entryPoint&quot; in input_params:
        input_params[&quot;entryPoint&quot;] = &quot;main&quot;
    if not &quot;arguments&quot; in input_params:
        input_params[&quot;arguments&quot;] = []

    # We'll transpile automatically to the supported gates in QIR unless explicitly skipped.
    if not input_params.get(&quot;skipTranspile&quot;, False):
        circuit = transpile(circuit, basis_gates = qir_supported_instructions)

        # We'll only log the QIR again if we performed a transpilation.
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug(f&quot;QIR (Post-transpilation):\n{to_qir(circuit, capability, **to_qir_kwargs)}&quot;)

    qir = bytes(to_qir_bitcode(circuit, capability, **to_qir_kwargs))
    return (qir, data_format, input_params)
</code></pre>
<p>In Qunatinuum, under <code>QuantinuumBackend</code>:</p>
<pre><code>    def _translate_input(self, circuit, data_format, input_params, to_qir_kwargs={}):
    &quot;&quot;&quot; Translates the input values to the format expected by the AzureBackend. &quot;&quot;&quot;
    if input_params[&quot;targetCapability&quot;] == &quot;openqasm&quot;:
        return (circuit.qasm(), data_format, input_params)
    else:
        # Not using openqasm, assume qir then:
        return super()._translate_input(circuit, &quot;qir.v1&quot;, input_params, to_qir_kwargs)
</code></pre>
<p>In Ionq, under <code>IonQBackendBackend</code>:</p>
<pre><code>    def _translate_input(self, circuit, data_format, input_params, to_qir_kwargs={}):
    &quot;&quot;&quot; Translates the input values to the format expected by the AzureBackend. &quot;&quot;&quot;
    if data_format == &quot;ionq.circuit.v1&quot;:
        ionq_circ, _, _ = qiskit_circ_to_ionq_circ(circuit, gateset=self.gateset())
        input_data = {
            &quot;gateset&quot;: self.gateset(),
            &quot;qubits&quot;: circuit.num_qubits,
            &quot;circuit&quot;: ionq_circ,
        }
        return (IonQ._encode_input_data(input_data), data_format, input_params)
    else:
        return super()._translate_input(circuit, data_format, input_params, to_qir_kwargs)
</code></pre>
<p>One more difference is <code>content_type</code> of <code>run()</code> function. Looks like in Rigetti they mistakenly took the same <code>str</code> as <code>input_data_format</code>:
<a href=""https://i.sstatic.net/G1xWL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/G1xWL.png"" alt=""enter image description here"" /></a></p>
<p>This is not the case in Quantinuum:
<a href=""https://i.sstatic.net/4cKPT.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4cKPT.png"" alt=""enter image description here"" /></a></p>
",qc,able run riggeti azure p trying run https nofollow noreferrer example strong submit circuit qiskit azure quantum riggeti azure us account job strong failed error job management console azure pre code error code qirpreprocessingfailed error message match found output recording set converter p error python console running code pre code job status job incurred error p working try ionq quantinuum p strong suggestions p btw one main differences running running rigetti code function first two method overided context backend support non qir circuit rigetti use default code code azurebackend p rigetti code azurebackend general object pre code def self circuit quot quot quot translates input values format expected azurebackend quot quot quot quot quot target raise valueerror f quot supported data format target target quot f quot using qir job payload quot import set gates supported qir targets import capability quot targetcapability quot quot targetcapability quot else quot adaptiveexecution quot f quot qir circuit capability quot qir payload needs define entrypoint arguments quot entrypoint quot quot entrypoint quot quot main quot quot arguments quot quot arguments quot transpile automatically supported gates qir unless explicitly skipped quot skiptranspile quot false circuit transpile circuit log qir performed transpilation f quot qir circuit capability quot qir bytes circuit capability return qir p qunatinuum code quantinuumbackend pre code def self circuit quot quot quot translates input values format expected azurebackend quot quot quot quot targetcapability quot quot openqasm quot return else using openqasm assume qir return super circuit quot quot p ionq code ionqbackendbackend pre code def self circuit quot quot quot translates input values format expected azurebackend quot quot quot quot quot circuit quot gateset quot quot qubits quot quot circuit quot return else return super circuit p one difference code code run function looks like rigetti mistakenly took code str code https nofollow noreferrer img https enter image description p case quantinuum https nofollow noreferrer img https enter image description,"[(0, 0.18037212), (4, 0.0986697), (8, 0.060973734), (12, 0.010682046), (14, 0.28082547), (19, 0.35857835)]"
30188,30189.0,2023-02-12 23:17:43,0,63,"<p>I've copied these lines from Stim's <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">Getting Started</a> notebook:</p>
<pre><code>circuit = stim.Circuit.generated(
    &quot;repetition_code:memory&quot;,
    rounds=30,
    distance=9,
    before_round_data_depolarization=0.03,
    before_measure_flip_probability=0.01)
dem = circuit.detector_error_model()
dem.diagram(&quot;matchgraph-svg&quot;)
</code></pre>
<p>but when I run it the final line gives an error:</p>
<pre><code>TypeError                                 Traceback (most recent call last)
Cell In[99], line 8
      1 circuit = stim.Circuit.generated(
      2     &quot;repetition_code:memory&quot;,
      3     rounds=30,
      4     distance=9,
      5     before_round_data_depolarization=0.03,
      6     before_measure_flip_probability=0.01)
      7 dem = circuit.detector_error_model()
----&gt; 8 dem.diagram(&quot;matchgraph-svg&quot;)

TypeError: diagram(): incompatible function arguments. The following argument types are supported:
    1. (self: stim._stim_avx2.DetectorErrorModel, *, type: str) -&gt; stim._stim_avx2._DiagramHelper

Invoked with: stim.DetectorErrorModel('''
    error(0.02) D0
    error(0.02) D0 D1
    error(0.01) D0 D8
    error(0.02) D1 D2
    error(0.01) D1 D9
    error(0.02) D2 D3
    error(0.01) D2 D10
    error(0.02) D3 D4
    error(0.01) D3 D11
...
    detector(9, 1) D20
    detector(11, 1) D21
    detector(13, 1) D22
    detector(15, 1) D23
'''), 'matchgraph-svg'
</code></pre>
",Stim's dem.diagram (detector error model diagram) not working for me?,<stim>,1,0,,,"Stim's dem.diagram (detector error model diagram) not working for me? <p>I've copied these lines from Stim's <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">Getting Started</a> notebook:</p>
<pre><code>circuit = stim.Circuit.generated(
    &quot;repetition_code:memory&quot;,
    rounds=30,
    distance=9,
    before_round_data_depolarization=0.03,
    before_measure_flip_probability=0.01)
dem = circuit.detector_error_model()
dem.diagram(&quot;matchgraph-svg&quot;)
</code></pre>
<p>but when I run it the final line gives an error:</p>
<pre><code>TypeError                                 Traceback (most recent call last)
Cell In[99], line 8
      1 circuit = stim.Circuit.generated(
      2     &quot;repetition_code:memory&quot;,
      3     rounds=30,
      4     distance=9,
      5     before_round_data_depolarization=0.03,
      6     before_measure_flip_probability=0.01)
      7 dem = circuit.detector_error_model()
----&gt; 8 dem.diagram(&quot;matchgraph-svg&quot;)

TypeError: diagram(): incompatible function arguments. The following argument types are supported:
    1. (self: stim._stim_avx2.DetectorErrorModel, *, type: str) -&gt; stim._stim_avx2._DiagramHelper

Invoked with: stim.DetectorErrorModel('''
    error(0.02) D0
    error(0.02) D0 D1
    error(0.01) D0 D8
    error(0.02) D1 D2
    error(0.01) D1 D9
    error(0.02) D2 D3
    error(0.01) D2 D10
    error(0.02) D3 D4
    error(0.01) D3 D11
...
    detector(9, 1) D20
    detector(11, 1) D21
    detector(13, 1) D22
    detector(15, 1) D23
'''), 'matchgraph-svg'
</code></pre>
",qc,stim detector error model diagram working p copied lines stim https nofollow noreferrer getting started notebook pre code circuit quot memory quot dem quot quot p run final line gives error pre code typeerror traceback recent call last cell 99 line 8 1 circuit 2 quot memory quot 3 4 5 6 7 dem gt 8 quot quot typeerror diagram incompatible function arguments following argument types supported 1 self type str gt invoked error d0 error d0 d1 error d0 d8 error d1 d2 error d1 d9 error d2 d3 error d2 d10 error d3 d4 error d3 d11 detector 9 1 d20 detector 11 1 d21 detector 13 1 d22 detector 15 1 d23,"[(0, 0.21647905), (4, 0.06487589), (5, 0.08539548), (6, 0.37796), (12, 0.037760284), (14, 0.07649387), (19, 0.13982181)]"
30246,30247.0,2023-02-17 06:06:12,0,227,"<p>I have the following Hamiltonian</p>
<pre><code>H = - Z1Z2 - Z2Z3 - Z1Z3 - 6(Z1 + Z2 + Z3)
</code></pre>
<p>Here, Z1, Z2, Z3 represent the Pauli-Z operators acting on qubits 1, 2, and 3, respectively. The interaction terms Z1Z2, Z2Z3, and Z1Z3 indicate that there is a ferromagnetic coupling between adjacent qubits. How can I simplify this further by substituting for Z1Z2, Z2Z3, Z1Z3 etc. in tensor product form in computational basis? Something like this (not sure how this can be obtained)</p>
<pre><code>Z1Z2 = (Z ⊗ Z) (|1⟩⟨1| ⊗ |0⟩⟨0| + |0⟩⟨0| ⊗ |1⟩⟨1|)
</code></pre>
",How to find the matrix representation of a given many-qubit Hamiltonian?,<matrix-representation><linear-algebra>,1,0,,,"How to find the matrix representation of a given many-qubit Hamiltonian? <p>I have the following Hamiltonian</p>
<pre><code>H = - Z1Z2 - Z2Z3 - Z1Z3 - 6(Z1 + Z2 + Z3)
</code></pre>
<p>Here, Z1, Z2, Z3 represent the Pauli-Z operators acting on qubits 1, 2, and 3, respectively. The interaction terms Z1Z2, Z2Z3, and Z1Z3 indicate that there is a ferromagnetic coupling between adjacent qubits. How can I simplify this further by substituting for Z1Z2, Z2Z3, Z1Z3 etc. in tensor product form in computational basis? Something like this (not sure how this can be obtained)</p>
<pre><code>Z1Z2 = (Z ⊗ Z) (|1⟩⟨1| ⊗ |0⟩⟨0| + |0⟩⟨0| ⊗ |1⟩⟨1|)
</code></pre>
",qc,find matrix representation given hamiltonian p following hamiltonian pre code h z1z2 z2z3 z1z3 6 z1 z2 z3 p z1 z2 z3 represent operators acting qubits 1 2 3 respectively interaction terms z1z2 z2z3 z1z3 indicate ferromagnetic coupling adjacent qubits simplify substituting z1z2 z2z3 z1z3 etc tensor product form computational basis something like sure obtained pre code z1z2 z z,"[(1, 0.063566186), (3, 0.3532053), (6, 0.061476782), (11, 0.044875525), (12, 0.040904764), (14, 0.3127634), (17, 0.1207152)]"
75495060,,2023-02-18 17:22:09,1,239,"<p>I am solving a commutator algebra in SymPy with the Hamiltonian</p>
<pre><code>
    from sympy import*
    a=Operator(&quot;a&quot;)
    ad=Dagger(a)
    b=Operator(&quot;b&quot;)
    bd=Dagger(b)

    H= ad*a + bd*b
</code></pre>
<p>Is there any way I can define commutation relations such as $[a,a^\dagger]=1$,
$[b,b^\dagger]=1$ and
$[a,b]=0$ ?</p>
<p>I want it such that if I calculate $[a,ad*b]$ I get $b$.
There is a code in answer to one of the <a href=""https://stackoverflow.com/questions/59523322/in-sympy-simplify-an-expression-using-a-canonical-commutation-relation"">questions</a>  but it does not work in this case.</p>
",Commutator algebra in SymPy,<sympy><physics><quantum-computing>,1,0,,,"Commutator algebra in SymPy <p>I am solving a commutator algebra in SymPy with the Hamiltonian</p>
<pre><code>
    from sympy import*
    a=Operator(&quot;a&quot;)
    ad=Dagger(a)
    b=Operator(&quot;b&quot;)
    bd=Dagger(b)

    H= ad*a + bd*b
</code></pre>
<p>Is there any way I can define commutation relations such as $[a,a^\dagger]=1$,
$[b,b^\dagger]=1$ and
$[a,b]=0$ ?</p>
<p>I want it such that if I calculate $[a,ad*b]$ I get $b$.
There is a code in answer to one of the <a href=""https://stackoverflow.com/questions/59523322/in-sympy-simplify-an-expression-using-a-canonical-commutation-relation"">questions</a>  but it does not work in this case.</p>
",so_new,commutator algebra sympy p solving commutator algebra sympy hamiltonian pre code sympy import quot quot quot b quot b ad bd b p way define commutation relations b b p want calculate ad b get b code answer one https questions work,"[(0, 0.20946322), (1, 0.04664213), (4, 0.08081859), (5, 0.10375267), (12, 0.02422701), (14, 0.06610181), (15, 0.36738446), (19, 0.098764576)]"
30287,,2023-02-20 04:51:04,2,133,"<p>The <a href=""https://en.wikipedia.org/wiki/M%C3%B8lmer%E2%80%93S%C3%B8rensen_gate"" rel=""nofollow noreferrer"">Mølmer–Sørensen gate</a> is a common ion trap gate. Does Stim support it? I tried <code>MS 0 1</code> but it didn't work.</p>
",Does Stim support the Mølmer–Sørensen gate?,<stim><ion-trap-quantum-computing>,1,5,,,"Does Stim support the Mølmer–Sørensen gate? <p>The <a href=""https://en.wikipedia.org/wiki/M%C3%B8lmer%E2%80%93S%C3%B8rensen_gate"" rel=""nofollow noreferrer"">Mølmer–Sørensen gate</a> is a common ion trap gate. Does Stim support it? I tried <code>MS 0 1</code> but it didn't work.</p>
",qc,stim support gate p https c3 b8lmer e2 80 93s c3 nofollow noreferrer gate common ion trap gate stim support tried code ms 0 1,"[(2, 0.09836405), (4, 0.30850393), (5, 0.24008003), (12, 0.091683134), (14, 0.25461012)]"
30432,,2023-03-01 09:54:54,4,167,"<p>As mentioned <em>e.g.</em> in <a href=""https://en.wikipedia.org/wiki/Fubini%E2%80%93Study_metric"" rel=""nofollow noreferrer"">the Wikipedia page</a>, given a pair of pure states <span class=""math-container"">$\psi,\phi\in\mathbb{CP}^{N-1}$</span>, the geodesic distance between them is
<span class=""math-container"">$$\gamma(\psi,\phi) = \arccos\sqrt{\frac{\langle\psi|\phi\rangle\langle\phi|\psi\rangle}{\langle\psi|\psi\rangle\langle\phi|\phi\rangle}},$$</span>
while the corresponding infinitesimal form, obtained taking <span class=""math-container"">$\phi=\psi+\delta\psi$</span>, reads
<span class=""math-container"">$$ds^2 = \frac{\langle \delta\psi|\delta\psi\rangle}{\langle\psi|\psi\rangle} - \frac{\langle\delta\psi|\psi\rangle \langle\psi|\delta\psi\rangle}{\langle\psi|\psi\rangle^2}.$$</span></p>
<p>This should be a simpler case of the more general calculation for the Bures metric discussed in <a href=""https://quantumcomputing.stackexchange.com/a/18349/55"">this answer</a>, while a related discussion is also found <a href=""https://quantumcomputing.stackexchange.com/a/12756/55"">here</a>.
What's a direct way to perform this calculation?</p>
",How to go from finite to infinitesimal form of the Fubini-Study metric?,<state-space-geometry><metrics><fubini-study-metric>,1,0,,,"How to go from finite to infinitesimal form of the Fubini-Study metric? <p>As mentioned <em>e.g.</em> in <a href=""https://en.wikipedia.org/wiki/Fubini%E2%80%93Study_metric"" rel=""nofollow noreferrer"">the Wikipedia page</a>, given a pair of pure states <span class=""math-container"">$\psi,\phi\in\mathbb{CP}^{N-1}$</span>, the geodesic distance between them is
<span class=""math-container"">$$\gamma(\psi,\phi) = \arccos\sqrt{\frac{\langle\psi|\phi\rangle\langle\phi|\psi\rangle}{\langle\psi|\psi\rangle\langle\phi|\phi\rangle}},$$</span>
while the corresponding infinitesimal form, obtained taking <span class=""math-container"">$\phi=\psi+\delta\psi$</span>, reads
<span class=""math-container"">$$ds^2 = \frac{\langle \delta\psi|\delta\psi\rangle}{\langle\psi|\psi\rangle} - \frac{\langle\delta\psi|\psi\rangle \langle\psi|\delta\psi\rangle}{\langle\psi|\psi\rangle^2}.$$</span></p>
<p>This should be a simpler case of the more general calculation for the Bures metric discussed in <a href=""https://quantumcomputing.stackexchange.com/a/18349/55"">this answer</a>, while a related discussion is also found <a href=""https://quantumcomputing.stackexchange.com/a/12756/55"">here</a>.
What's a direct way to perform this calculation?</p>
",qc,go finite infinitesimal form metric p mentioned em https e2 80 nofollow noreferrer wikipedia page given pair pure states span cp geodesic distance span corresponding infinitesimal form obtained taking span reads span p simpler case general calculation bures metric discussed https answer related discussion also found https direct way perform calculation,"[(3, 0.56935436), (4, 0.1376556), (7, 0.08130525), (8, 0.14322048), (11, 0.024919111), (12, 0.040754832)]"
30445,34013.0,2023-03-01 22:36:13,1,599,"<p>In <a href=""https://en.wikipedia.org/wiki/The_Fabric_of_Reality"" rel=""nofollow noreferrer"">The Fabric of Reality</a>, David Deutsch argues the following:</p>
<blockquote>
<p>To those who still cling to a single-universe world-view, I issue this challenge: <em>explain how Shor's algorithm works.</em> I do not merely mean predict that it will work, which is merely a matter of solving a few uncontroversial equations. I mean provide an explanation. When Shor's algorithm has factorized a number, using <span class=""math-container"">$10^{500}$</span> or so times the computational resources that can be seen to be present, where was the number factorized? There are only about <span class=""math-container"">$10^{80}$</span> atoms in the entire visible universe, an utterly minuscule number compared with <span class=""math-container"">$10^{500}$</span>. So if the visible universe where the extent of physical reality, physical reality would not even remotely contain the resources required to factorize such a large number. Who did factorize it, then? How, and where, was the computation performed?</p>
</blockquote>
<p>Doesn't this imply the existence of the multiverse? How/where could the number be factorized otherwise?</p>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/8662/effects-of-quantum-computing-on-parallel-universes"">This thread</a> does not answer this question, as 1. the fact that there are still <a href=""https://quantumcomputing.stackexchange.com/a/8663/23560"">some unknowns</a> doesn't necessarily mean the multiverse theory is wrong, and 2. it doesn't explain how/where the number could be factorized otherwise if not in the so-called &quot;parallel universes&quot;.</p>
",Does Shor's algorithm imply the existence of the multiverse?,<shors-algorithm>,3,5,,,"Does Shor's algorithm imply the existence of the multiverse? <p>In <a href=""https://en.wikipedia.org/wiki/The_Fabric_of_Reality"" rel=""nofollow noreferrer"">The Fabric of Reality</a>, David Deutsch argues the following:</p>
<blockquote>
<p>To those who still cling to a single-universe world-view, I issue this challenge: <em>explain how Shor's algorithm works.</em> I do not merely mean predict that it will work, which is merely a matter of solving a few uncontroversial equations. I mean provide an explanation. When Shor's algorithm has factorized a number, using <span class=""math-container"">$10^{500}$</span> or so times the computational resources that can be seen to be present, where was the number factorized? There are only about <span class=""math-container"">$10^{80}$</span> atoms in the entire visible universe, an utterly minuscule number compared with <span class=""math-container"">$10^{500}$</span>. So if the visible universe where the extent of physical reality, physical reality would not even remotely contain the resources required to factorize such a large number. Who did factorize it, then? How, and where, was the computation performed?</p>
</blockquote>
<p>Doesn't this imply the existence of the multiverse? How/where could the number be factorized otherwise?</p>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/8662/effects-of-quantum-computing-on-parallel-universes"">This thread</a> does not answer this question, as 1. the fact that there are still <a href=""https://quantumcomputing.stackexchange.com/a/8663/23560"">some unknowns</a> doesn't necessarily mean the multiverse theory is wrong, and 2. it doesn't explain how/where the number could be factorized otherwise if not in the so-called &quot;parallel universes&quot;.</p>
",qc,shor algorithm imply existence multiverse p https nofollow noreferrer fabric reality david deutsch argues following blockquote p still cling issue challenge em explain shor algorithm merely mean predict work merely matter solving uncontroversial equations mean provide explanation shor algorithm factorized number using span 500 times computational resources seen present number factorized span 80 atoms entire visible universe utterly minuscule number compared span 500 visible universe extent physical reality physical reality would even remotely contain resources required factorize large number factorize computation performed p imply existence multiverse could number factorized otherwise p https thread answer question fact still https unknowns necessarily mean multiverse theory wrong explain number could factorized otherwise quot parallel universes quot,"[(4, 0.031878024), (7, 0.2805644), (8, 0.443018), (9, 0.05377508), (10, 0.012267578), (12, 0.01052544), (14, 0.0381473), (15, 0.087428816), (17, 0.019460129), (19, 0.021925706)]"
31602,31605.0,2023-03-12 10:28:47,1,244,"<p>I am trying to compute the number of circuit layers in a UCC ansatz in Qiskit in order to estimate the circuit running time using CLOPS estimates on IBM quantum devices. Here is what I tried to do:</p>
<pre><code>from qiskit.transpiler import PassManager, StagedPassManager
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.second_q.circuit.library.ansatzes import UCC
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;H&quot;, &quot;Be&quot;, &quot;H&quot;], [(0., 0., -1.3264), (0., 0., 0.), (0., 0., 1.3264)],)
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()   
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

uccsdt_ansatz = UCC(int(num_spin_orbitals/2), num_particles, excitations=&quot;sdt&quot;, qubit_converter=qubit_converter)

# more info on pass managers here: https://qiskit.org/documentation/apidoc/transpiler.html
pm = StagedPassManager(stages=[&quot;init&quot;])
circuit = pm.run(uccsdt_ansatz)
print(circuit.depth())
</code></pre>
<p>However, the above does not work, an exception is thrown ('ListOp' object has no attribute 'to_circuit'). Here is the qiskit version I am using: <a href=""https://i.sstatic.net/nLHVN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nLHVN.png"" alt=""enter image description here"" /></a></p>
",Compute the number of circuit layers in an UCC type ansatz using Qiskit,<qiskit><clops>,2,0,,,"Compute the number of circuit layers in an UCC type ansatz using Qiskit <p>I am trying to compute the number of circuit layers in a UCC ansatz in Qiskit in order to estimate the circuit running time using CLOPS estimates on IBM quantum devices. Here is what I tried to do:</p>
<pre><code>from qiskit.transpiler import PassManager, StagedPassManager
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.second_q.circuit.library.ansatzes import UCC
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;H&quot;, &quot;Be&quot;, &quot;H&quot;], [(0., 0., -1.3264), (0., 0., 0.), (0., 0., 1.3264)],)
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()   
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

uccsdt_ansatz = UCC(int(num_spin_orbitals/2), num_particles, excitations=&quot;sdt&quot;, qubit_converter=qubit_converter)

# more info on pass managers here: https://qiskit.org/documentation/apidoc/transpiler.html
pm = StagedPassManager(stages=[&quot;init&quot;])
circuit = pm.run(uccsdt_ansatz)
print(circuit.depth())
</code></pre>
<p>However, the above does not work, an exception is thrown ('ListOp' object has no attribute 'to_circuit'). Here is the qiskit version I am using: <a href=""https://i.sstatic.net/nLHVN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nLHVN.png"" alt=""enter image description here"" /></a></p>
",qc,compute number circuit layers ucc type ansatz using qiskit p trying compute number circuit layers ucc ansatz qiskit order estimate circuit running time using clops estimates ibm quantum devices tried pre code import passmanager stagedpassmanager import qubitconverter import ucc import pyscfdriver import moleculeinfo import paritymapper qubitconverter paritymapper molecule moleculeinfo quot h quot quot quot quot h quot 0 driver molecule quot sto3g quot 0 ucc int quot sdt quot info pass managers https pm stagedpassmanager quot init quot circuit print p however work exception thrown object attribute qiskit version using https nofollow noreferrer img https enter image description,"[(0, 0.32731548), (2, 0.017084233), (4, 0.16185075), (8, 0.11558032), (12, 0.011556718), (14, 0.12077794), (17, 0.051779255), (19, 0.19267802)]"
31672,31682.0,2023-03-15 11:55:27,1,276,"<p><strong>Question:</strong>
Is there a parameterization of a a general qutrit 3-level system similar to:
<span class=""math-container"">$$\rho = \begin{bmatrix} p_1 &amp; r_{12}e^{-i\phi_{12}} &amp; r_{13}e^{-i\phi_{13}}\\ \cdot &amp; p_2 &amp; r_{23}e^{-i\phi_{23}}\\ \cdot &amp; \cdot &amp; 1-p_1-p_2 \end{bmatrix} \tag{1.1}$$</span>
With the constraints:
<span class=""math-container"">$$\begin{align}
&amp; 0\leq p_j \\
&amp; p_1+p_2\leq1 \\
&amp; 0\leq r_{ij}\leq \sqrt{p_ip_j} \\
&amp; 0 \leq \phi_{ij} &lt; 2\pi
\end{align} \tag{1.2}$$</span>
?</p>
<p><a href=""https://iopscience.iop.org/article/10.1088/0305-4470/39/36/012/pdf"" rel=""nofollow noreferrer"">Today I learned</a> a 3-level system can be parameterized, from <a href=""https://en.wikipedia.org/wiki/Gell-Mann_matrices"" rel=""nofollow noreferrer"">Gell-Mann matrices</a>, as:</p>
<p><span class=""math-container"">$$ \rho = \begin{bmatrix} \frac13+a_3+\frac{a_8}{\sqrt 3} &amp; a_1-ia_2 &amp;a_4-ia_5 \\ \cdot &amp; \frac13-a_3+\frac{a_8}{\sqrt 3} &amp; a_6-ia_7 \\ \cdot &amp;\cdot &amp; \frac13-\frac{2a_8}{\sqrt 3} \end{bmatrix} \tag{2.1}$$</span>
Subject to the constraints:
<span class=""math-container"">$$\begin{align}
&amp; 0\leq \frac13\pm a_3+\frac{a_8}{\sqrt 3}\leq1 \\
&amp; 0\leq \frac13-\frac{2a_8}{\sqrt 3}\leq1 \\
&amp; \mathbf a\cdot \mathbf a\leq\frac13 \\
&amp; 0 \leq \det(\rho)
\end{align} \tag{2.2}$$</span></p>
<p>Disclaimer: I know parameterization <span class=""math-container"">$(1)$</span> is not correct, hence I am asking if there is anything <em>similar</em>. In particular, my problem with the Gell-Mann parameterization <span class=""math-container"">$(2)$</span> is that I have to compute a determinant each time I draw 8 random numbers... I would like something <em>faster</em> to generate and validate.</p>
<hr />
<p><strong>Background:</strong> I am doing numerical simulations, where I need to quickly generate a large number of random 3-level density operators. I was using parameterization <span class=""math-container"">$(2)$</span>, with which you can easily draw the <a href=""https://physics.stackexchange.com/q/398114"">eight degrees of freedom of the qutrit</a>.</p>
<p>However, the parameterization is wrong since it allows non-physical states, such as:
<span class=""math-container"">$$\rho = \begin{bmatrix} p_1 &amp;\sqrt{p_1 p_2} &amp;\sqrt{p_1 p_3}\\ \cdot &amp;p_2 &amp;\sqrt{p_2 p_3}e^{-i\pi}\\ \cdot &amp;\cdot &amp;p_3 \end{bmatrix}$$</span>
which is <a href=""https://www.wolframalpha.com/input?i2d=true&amp;i=eig%7B%7B.5%2Csqrt%5C%2840%29.5*.3%5C%2841%29%2Csqrt%5C%2840%29.5*.2%5C%2841%29%7D%2C%7Bsqrt%5C%2840%29.5*.3%5C%2841%29%2C.3%2C-sqrt%5C%2840%29.3*.2%5C%2841%29%7D%2C%7Bsqrt%5C%2840%29.5*.2%5C%2841%29%2C-sqrt%5C%2840%29.3*.2%5C%2841%29%2C.2%7D%7D"" rel=""nofollow noreferrer"">not positive semidefinite</a>.</p>
","Is there another parameterization of a qutrit 3-level system, besides Gell-Mann?",<density-matrix><quantum-state>,2,7,,,"Is there another parameterization of a qutrit 3-level system, besides Gell-Mann? <p><strong>Question:</strong>
Is there a parameterization of a a general qutrit 3-level system similar to:
<span class=""math-container"">$$\rho = \begin{bmatrix} p_1 &amp; r_{12}e^{-i\phi_{12}} &amp; r_{13}e^{-i\phi_{13}}\\ \cdot &amp; p_2 &amp; r_{23}e^{-i\phi_{23}}\\ \cdot &amp; \cdot &amp; 1-p_1-p_2 \end{bmatrix} \tag{1.1}$$</span>
With the constraints:
<span class=""math-container"">$$\begin{align}
&amp; 0\leq p_j \\
&amp; p_1+p_2\leq1 \\
&amp; 0\leq r_{ij}\leq \sqrt{p_ip_j} \\
&amp; 0 \leq \phi_{ij} &lt; 2\pi
\end{align} \tag{1.2}$$</span>
?</p>
<p><a href=""https://iopscience.iop.org/article/10.1088/0305-4470/39/36/012/pdf"" rel=""nofollow noreferrer"">Today I learned</a> a 3-level system can be parameterized, from <a href=""https://en.wikipedia.org/wiki/Gell-Mann_matrices"" rel=""nofollow noreferrer"">Gell-Mann matrices</a>, as:</p>
<p><span class=""math-container"">$$ \rho = \begin{bmatrix} \frac13+a_3+\frac{a_8}{\sqrt 3} &amp; a_1-ia_2 &amp;a_4-ia_5 \\ \cdot &amp; \frac13-a_3+\frac{a_8}{\sqrt 3} &amp; a_6-ia_7 \\ \cdot &amp;\cdot &amp; \frac13-\frac{2a_8}{\sqrt 3} \end{bmatrix} \tag{2.1}$$</span>
Subject to the constraints:
<span class=""math-container"">$$\begin{align}
&amp; 0\leq \frac13\pm a_3+\frac{a_8}{\sqrt 3}\leq1 \\
&amp; 0\leq \frac13-\frac{2a_8}{\sqrt 3}\leq1 \\
&amp; \mathbf a\cdot \mathbf a\leq\frac13 \\
&amp; 0 \leq \det(\rho)
\end{align} \tag{2.2}$$</span></p>
<p>Disclaimer: I know parameterization <span class=""math-container"">$(1)$</span> is not correct, hence I am asking if there is anything <em>similar</em>. In particular, my problem with the Gell-Mann parameterization <span class=""math-container"">$(2)$</span> is that I have to compute a determinant each time I draw 8 random numbers... I would like something <em>faster</em> to generate and validate.</p>
<hr />
<p><strong>Background:</strong> I am doing numerical simulations, where I need to quickly generate a large number of random 3-level density operators. I was using parameterization <span class=""math-container"">$(2)$</span>, with which you can easily draw the <a href=""https://physics.stackexchange.com/q/398114"">eight degrees of freedom of the qutrit</a>.</p>
<p>However, the parameterization is wrong since it allows non-physical states, such as:
<span class=""math-container"">$$\rho = \begin{bmatrix} p_1 &amp;\sqrt{p_1 p_2} &amp;\sqrt{p_1 p_3}\\ \cdot &amp;p_2 &amp;\sqrt{p_2 p_3}e^{-i\pi}\\ \cdot &amp;\cdot &amp;p_3 \end{bmatrix}$$</span>
which is <a href=""https://www.wolframalpha.com/input?i2d=true&amp;i=eig%7B%7B.5%2Csqrt%5C%2840%29.5*.3%5C%2841%29%2Csqrt%5C%2840%29.5*.2%5C%2841%29%7D%2C%7Bsqrt%5C%2840%29.5*.3%5C%2841%29%2C.3%2C-sqrt%5C%2840%29.3*.2%5C%2841%29%7D%2C%7Bsqrt%5C%2840%29.5*.2%5C%2841%29%2C-sqrt%5C%2840%29.3*.2%5C%2841%29%2C.2%7D%7D"" rel=""nofollow noreferrer"">not positive semidefinite</a>.</p>
",qc,another parameterization qutrit system besides p strong question parameterization general qutrit system similar span bmatrix amp 12 12 amp 13 13 amp amp 23 23 amp amp bmatrix constraints span align amp amp amp ij amp 0 ij lt align p https nofollow noreferrer today learned system parameterized https nofollow noreferrer matrices p span bmatrix 3 amp amp amp 3 amp amp amp 3 bmatrix subject constraints span align amp 3 amp 3 amp amp 0 align p disclaimer know parameterization span 1 correct hence asking anything em similar particular problem parameterization span 2 compute determinant time draw 8 random numbers would like something em faster generate hr p strong background numerical simulations need quickly generate large number random density operators using parameterization span 2 easily draw https eight degrees freedom qutrit p however parameterization wrong since allows states span bmatrix amp amp amp amp amp amp bmatrix https amp 7b 2csqrt 5c 2840 5c 2841 29 2csqrt 5c 2840 5c 2841 29 7d 2c 7bsqrt 5c 2840 5c 2841 29 5c 2840 5c 2841 29 7d 2c 7bsqrt 5c 2840 5c 2841 29 5c 2840 5c 2841 29 7d 7d nofollow noreferrer positive semidefinite,"[(1, 0.035754792), (3, 0.1296848), (4, 0.062047355), (6, 0.0823228), (7, 0.02642494), (8, 0.05082654), (9, 0.1793455), (11, 0.021209558), (12, 0.043332897), (15, 0.36285213)]"
31713,,2023-03-17 14:09:05,1,127,"<p>I have wrote some code using Qiskit in Jupyter notebook using Microsoft Visual Studio Code. Is there any way to run directly on an IBM quantum computer through Visual Studio?</p>
",Execute using circuits on IBM hardware using visual studio code,<ibm-q-experience><ibm-quantum-devices>,0,0,,,"Execute using circuits on IBM hardware using visual studio code <p>I have wrote some code using Qiskit in Jupyter notebook using Microsoft Visual Studio Code. Is there any way to run directly on an IBM quantum computer through Visual Studio?</p>
",qc,execute using circuits ibm hardware using visual studio code p wrote code using qiskit jupyter notebook using microsoft visual studio code way run directly ibm quantum computer visual studio,"[(12, 0.206603), (14, 0.7526098), (17, 0.034964174)]"
31724,,2023-03-17 22:31:29,4,154,"<p>Consider the following scenario:</p>
<p>Alice and Bob run BB84 to each other.</p>
<p>Eavesdropper Eve is present in the middle. Here we assume that she has access to all channels: the quantum channel, in the classical control channel (where the BB84 protocol runs), and the classical payload channel (where the encrypted traffic is exchanged).</p>
<p>Let's assume for this scenario that the classical control channel (where the BB84 protocol runs) is <strong>NOT</strong> authenticated.</p>
<p>The lack of authentication allows Eve to perform a woman-in-the-middle attack as follows:</p>
<ul>
<li><p>Eve can negotiate a key with Alice, where Alice thinks she is negotiating a key with Bob.</p>
</li>
<li><p>Eve can negotiate a key with Bob, where Bob thinks he is negotiating a key with Alice.</p>
</li>
<li><p>Eve can decrypt the payload traffic from Alice (using the Alice-Eve key) and re-encrypt it (using the Eve-Bob key) and send it to Bob.</p>
</li>
<li><p>Eve can decrypt the payload traffic from Bob (using the Bob-Eve key) and re-encrypt it (using the Eve-Alice key) and send it to Alice.</p>
</li>
<li><p>In general, the Alice-Eve and the Bob-Eve keys will be different.</p>
</li>
</ul>
<p>My question is: is there any way for Eve to perform a woman-in-the-middle attack and force the Alice-Eve key and the Bob-Eve key to be the same?</p>
","Is there a BB84 ""man""-in-the-middle attack forcing the same keys on Alice and Bob known to Eve",<bb84><qkd>,0,4,,,"Is there a BB84 ""man""-in-the-middle attack forcing the same keys on Alice and Bob known to Eve <p>Consider the following scenario:</p>
<p>Alice and Bob run BB84 to each other.</p>
<p>Eavesdropper Eve is present in the middle. Here we assume that she has access to all channels: the quantum channel, in the classical control channel (where the BB84 protocol runs), and the classical payload channel (where the encrypted traffic is exchanged).</p>
<p>Let's assume for this scenario that the classical control channel (where the BB84 protocol runs) is <strong>NOT</strong> authenticated.</p>
<p>The lack of authentication allows Eve to perform a woman-in-the-middle attack as follows:</p>
<ul>
<li><p>Eve can negotiate a key with Alice, where Alice thinks she is negotiating a key with Bob.</p>
</li>
<li><p>Eve can negotiate a key with Bob, where Bob thinks he is negotiating a key with Alice.</p>
</li>
<li><p>Eve can decrypt the payload traffic from Alice (using the Alice-Eve key) and re-encrypt it (using the Eve-Bob key) and send it to Bob.</p>
</li>
<li><p>Eve can decrypt the payload traffic from Bob (using the Bob-Eve key) and re-encrypt it (using the Eve-Alice key) and send it to Alice.</p>
</li>
<li><p>In general, the Alice-Eve and the Bob-Eve keys will be different.</p>
</li>
</ul>
<p>My question is: is there any way for Eve to perform a woman-in-the-middle attack and force the Alice-Eve key and the Bob-Eve key to be the same?</p>
",qc,bb84 man attack forcing keys alice bob known eve p consider following scenario p alice bob run bb84 p eavesdropper eve present middle assume access channels quantum channel classical control channel bb84 protocol runs classical payload channel encrypted traffic exchanged p let assume scenario classical control channel bb84 protocol runs strong p lack authentication allows eve perform attack follows ul li p eve negotiate key alice alice thinks negotiating key li p eve negotiate key bob bob thinks negotiating key li p eve decrypt payload traffic alice using key using key send li p eve decrypt payload traffic bob using key using key send li p general keys p question way eve perform attack force key key,"[(3, 0.040552817), (7, 0.092572674), (8, 0.108142756), (12, 0.028292578), (18, 0.72903794)]"
31739,31740.0,2023-03-20 09:04:16,2,1906,"<p>How I can implement this CNOT gate with control activated when input is 0 instead of 1 in Qiskit. Refer <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22X%22%5D%5D%7D"" rel=""nofollow noreferrer"">circuit</a></p>
<p>I'm adding 8 to the input with the CNOT and X gates. I want to set a flag when the sum adds up to 8. When the sum is 8, the 2nd and 3rd qubit outputs 0. In which case I want to apply the CNOT with control activated when input is 0 rather than 1.</p>
<p>I do not want to apply X gate before the controlled-gate to achieve this.</p>
",Controlled NOT gate with Control activated when input is 0 instead of 1,<qiskit><circuit-construction><quantum-circuit>,2,0,,,"Controlled NOT gate with Control activated when input is 0 instead of 1 <p>How I can implement this CNOT gate with control activated when input is 0 instead of 1 in Qiskit. Refer <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%97%A6%22,%22%E2%97%A6%22,%22%E2%97%A6%22,%22X%22%5D%5D%7D"" rel=""nofollow noreferrer"">circuit</a></p>
<p>I'm adding 8 to the input with the CNOT and X gates. I want to set a flag when the sum adds up to 8. When the sum is 8, the 2nd and 3rd qubit outputs 0. In which case I want to apply the CNOT with control activated when input is 0 rather than 1.</p>
<p>I do not want to apply X gate before the controlled-gate to achieve this.</p>
",qc,controlled gate control activated input 0 instead 1 p implement cnot gate control activated input 0 instead 1 qiskit refer https 7b 22cols 22 5b 5b1 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 5d 5b1 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 5d 5b1 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 5d 5b1 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 5d 5b 22 e2 97 a6 22 22 e2 97 a6 22 22 e2 97 a6 22 22x 22 5d 5d 7d nofollow noreferrer circuit p adding 8 input cnot x gates want set flag sum adds sum 8 2nd 3rd qubit outputs case want apply cnot control activated input 0 rather p want apply x gate achieve,"[(2, 0.039166294), (4, 0.041760877), (6, 0.017252276), (9, 0.022751896), (10, 0.020462627), (12, 0.62486833), (14, 0.07250483), (18, 0.16031806)]"
31773,31777.0,2023-03-22 22:44:30,5,212,"<p>On Wikipedia, the <a href=""https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem"" rel=""nofollow noreferrer"">Gottesman-Knill theorem</a> is said to state the following:</p>
<blockquote>
<p>A quantum circuit using only the following elements can be simulated efficiently on a classical computer.</p>
<ol>
<li><p>Preparation of qubits in computational basis states,</p>
</li>
<li><p>Clifford gates, and</p>
</li>
<li><p>measurements in the computational basis.</p>
</li>
</ol>
</blockquote>
<p>However, in my class it was said that the theorem applies when the input is the &quot;all-zeroes&quot; state <span class=""math-container"">$|0\rangle^{\otimes n}$</span>. Is it indeed true that the theorem applies if we instead input <span class=""math-container"">$| x \rangle$</span> for any <span class=""math-container"">$x \in \{0,1\}^n$</span>?</p>
",Does Gottesman-Knill theorem apply with any computational basis input?,<simulation><clifford-group><stabilizer-state><gottesman-knill>,1,0,,,"Does Gottesman-Knill theorem apply with any computational basis input? <p>On Wikipedia, the <a href=""https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem"" rel=""nofollow noreferrer"">Gottesman-Knill theorem</a> is said to state the following:</p>
<blockquote>
<p>A quantum circuit using only the following elements can be simulated efficiently on a classical computer.</p>
<ol>
<li><p>Preparation of qubits in computational basis states,</p>
</li>
<li><p>Clifford gates, and</p>
</li>
<li><p>measurements in the computational basis.</p>
</li>
</ol>
</blockquote>
<p>However, in my class it was said that the theorem applies when the input is the &quot;all-zeroes&quot; state <span class=""math-container"">$|0\rangle^{\otimes n}$</span>. Is it indeed true that the theorem applies if we instead input <span class=""math-container"">$| x \rangle$</span> for any <span class=""math-container"">$x \in \{0,1\}^n$</span>?</p>
",qc,theorem apply computational basis input p wikipedia https e2 80 nofollow noreferrer theorem said state following blockquote p quantum circuit using following elements simulated efficiently classical ol li p preparation qubits computational basis states li p clifford gates li p measurements computational p however class said theorem applies input quot quot state span n indeed true theorem applies instead input span x span x,"[(1, 0.030649226), (3, 0.10977773), (4, 0.051867813), (9, 0.27780458), (10, 0.085119046), (12, 0.0326161), (18, 0.3693424), (19, 0.040953316)]"
31795,31797.0,2023-03-24 10:16:17,0,380,"<p>I used <code>minimize</code> for optimizing the ansatz parameter. I wrote the line like
<code>result = minimize(cost, init_params, method=&quot;COBYLA&quot;, options={'maxiter':200})</code>
and it is throwing this error <code>ValueError: Mismatching number of values and parameters. For partial binding please pass a dictionary of {parameter: value} pairs.</code>. Although I'm sure this is how <code>maxiter</code> is given and shown in Qiskit notebooks.
For further information, this is my circuit
<a href=""https://i.sstatic.net/fnGJJ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fnGJJ.png"" alt=""circuit"" /></a></p>
<p>and I'm sure <code>init_params</code> have been given 9 initial parameters for each <span class=""math-container"">$R_y$</span> gates in the ansatz. So I'm wondering where did I go wrong?</p>
",scipy.optimize.minimize throwing error,<qiskit><quantum-circuit><optimization>,1,0,,,"scipy.optimize.minimize throwing error <p>I used <code>minimize</code> for optimizing the ansatz parameter. I wrote the line like
<code>result = minimize(cost, init_params, method=&quot;COBYLA&quot;, options={'maxiter':200})</code>
and it is throwing this error <code>ValueError: Mismatching number of values and parameters. For partial binding please pass a dictionary of {parameter: value} pairs.</code>. Although I'm sure this is how <code>maxiter</code> is given and shown in Qiskit notebooks.
For further information, this is my circuit
<a href=""https://i.sstatic.net/fnGJJ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fnGJJ.png"" alt=""circuit"" /></a></p>
<p>and I'm sure <code>init_params</code> have been given 9 initial parameters for each <span class=""math-container"">$R_y$</span> gates in the ansatz. So I'm wondering where did I go wrong?</p>
",qc,throwing error p used code minimize optimizing ansatz parameter wrote line like code result minimize cost quot cobyla quot throwing error code valueerror mismatching number values parameters partial binding please pass dictionary parameter value although sure code maxiter given shown qiskit notebooks information circuit https nofollow noreferrer img https circuit p sure code given 9 initial parameters span gates ansatz wondering go wrong,"[(0, 0.29010922), (3, 0.036985688), (4, 0.22681658), (6, 0.019818405), (12, 0.016574984), (14, 0.2921263), (19, 0.115442835)]"
31874,32444.0,2023-03-28 16:58:06,0,271,"<p>I'm trying to study QPE with the motivation of obtaining eigenvalues of Hamiltonian, i.e. energies of a system. My problem is, that while <a href=""https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html"" rel=""nofollow noreferrer"">np.linalg.eig</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.minimum_eigensolvers.VQE.html#qiskit.algorithms.minimum_eigensolvers.VQE"" rel=""nofollow noreferrer"">VQE</a> are agreeing on the lowest energy, energy obtained via QPE is completely off.</p>
<p>My Hamiltonian looks like this
<span class=""math-container"">$$
\widehat{H} = -II + 0.3IZ -0.01ZY + 0.1YX
$$</span></p>
<p>and I'd expect its eigenvalues to be (roughly) <code>[-0.39328755, -0.89, -1.11, -1.60671245]</code>. Using VQE I'm obtaining <code>-1.6067123508302064</code>, i.e. the number very close to the lowest eigenvalue.</p>
<p>On the other hand, when I run my QPE code, I'm getting number like <code>-0.392699</code>, not knowing, where is the problem.</p>
<hr />
<h3>My code</h3>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, execute
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import PhaseEstimation, TwoLocal
from qiskit.extensions import HamiltonianGate
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator

H = SparsePauliOp.from_list([('II', -1), ('IZ', 0.3), ('XI', -0.3), ('ZY', -0.01), ('YX', 0.1)])
Hmat = H.to_matrix()

eig = np.linalg.eigvals(Hmat)
print(eig)

estimator = Estimator()
optimizer = SLSQP()
ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks='cz')

vqe = VQE(estimator, ansatz, optimizer)
result = vqe.compute_minimum_eigenvalue(operator=H)
print(result.eigenvalue)

n_qpe_qbits = 10

U = HamiltonianGate(Hmat, 1, label='H')

# Obtain a solution via QPE
total_qbits = U.num_qubits + n_qpe_qbits
measure_circ = QuantumCircuit(total_qbits, n_qpe_qbits)
qpe = PhaseEstimation(n_qpe_qbits, U)

measure_circ = measure_circ.compose(qpe)
measure_circ.measure(range(n_qpe_qbits), range(n_qpe_qbits))
print(measure_circ.decompose())

backend = AerSimulator(method='statevector')
job = execute(measure_circ, backend, shots=2048)
counts = job.result().get_counts()
print(counts)

max_count = max(counts.items(), key=lambda x: x[1])
print(f'MAX count: {max_count}')

theta = int(max_count[0][::-1], 2) / 2**n_qpe_qbits
print(f'Theta value: {theta}')
print(f'QPE-approximated U-eigenvalue: {np.exp(2*1j*np.pi * theta)}')
print(f'QPE-approximated H-eigenvalue: {-2 * np.pi * theta}')
<span class=""math-container"">```</span>
</code></pre>
",Qiskit - Approximation of Hamiltonian energy via QPE,<qiskit><programming><hamiltonian-simulation><quantum-phase-estimation><chemistry>,1,0,,,"Qiskit - Approximation of Hamiltonian energy via QPE <p>I'm trying to study QPE with the motivation of obtaining eigenvalues of Hamiltonian, i.e. energies of a system. My problem is, that while <a href=""https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html"" rel=""nofollow noreferrer"">np.linalg.eig</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.minimum_eigensolvers.VQE.html#qiskit.algorithms.minimum_eigensolvers.VQE"" rel=""nofollow noreferrer"">VQE</a> are agreeing on the lowest energy, energy obtained via QPE is completely off.</p>
<p>My Hamiltonian looks like this
<span class=""math-container"">$$
\widehat{H} = -II + 0.3IZ -0.01ZY + 0.1YX
$$</span></p>
<p>and I'd expect its eigenvalues to be (roughly) <code>[-0.39328755, -0.89, -1.11, -1.60671245]</code>. Using VQE I'm obtaining <code>-1.6067123508302064</code>, i.e. the number very close to the lowest eigenvalue.</p>
<p>On the other hand, when I run my QPE code, I'm getting number like <code>-0.392699</code>, not knowing, where is the problem.</p>
<hr />
<h3>My code</h3>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, execute
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import PhaseEstimation, TwoLocal
from qiskit.extensions import HamiltonianGate
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator

H = SparsePauliOp.from_list([('II', -1), ('IZ', 0.3), ('XI', -0.3), ('ZY', -0.01), ('YX', 0.1)])
Hmat = H.to_matrix()

eig = np.linalg.eigvals(Hmat)
print(eig)

estimator = Estimator()
optimizer = SLSQP()
ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks='cz')

vqe = VQE(estimator, ansatz, optimizer)
result = vqe.compute_minimum_eigenvalue(operator=H)
print(result.eigenvalue)

n_qpe_qbits = 10

U = HamiltonianGate(Hmat, 1, label='H')

# Obtain a solution via QPE
total_qbits = U.num_qubits + n_qpe_qbits
measure_circ = QuantumCircuit(total_qbits, n_qpe_qbits)
qpe = PhaseEstimation(n_qpe_qbits, U)

measure_circ = measure_circ.compose(qpe)
measure_circ.measure(range(n_qpe_qbits), range(n_qpe_qbits))
print(measure_circ.decompose())

backend = AerSimulator(method='statevector')
job = execute(measure_circ, backend, shots=2048)
counts = job.result().get_counts()
print(counts)

max_count = max(counts.items(), key=lambda x: x[1])
print(f'MAX count: {max_count}')

theta = int(max_count[0][::-1], 2) / 2**n_qpe_qbits
print(f'Theta value: {theta}')
print(f'QPE-approximated U-eigenvalue: {np.exp(2*1j*np.pi * theta)}')
print(f'QPE-approximated H-eigenvalue: {-2 * np.pi * theta}')
<span class=""math-container"">```</span>
</code></pre>
",qc,qiskit approximation hamiltonian energy via qpe p trying study qpe motivation obtaining eigenvalues hamiltonian energies system problem https nofollow noreferrer https nofollow noreferrer vqe agreeing lowest energy energy obtained via qpe completely p hamiltonian looks like span h p expect eigenvalues roughly code using vqe obtaining code number close lowest p hand run qpe code getting number like code knowing hr h3 code pre code import numpy np qiskit import quantumcircuit execute import vqe import slsqp import phaseestimation twolocal import hamiltoniangate import estimator import sparsepauliop import aersimulator h hmat eig hmat print eig estimator estimator optimizer slsqp ansatz twolocal vqe vqe estimator ansatz optimizer result print 10 u hamiltoniangate hmat 1 h obtain solution via qpe quantumcircuit qpe phaseestimation u qpe range range print backend aersimulator job execute backend counts print counts max x x 1 print count theta int 0 2 2 print value theta print 2 1j theta print theta span,"[(0, 0.6186037), (1, 0.043738313), (3, 0.09431775), (4, 0.049370613), (7, 0.12568103), (10, 0.013244933), (12, 0.029274542), (17, 0.02495833)]"
31996,31997.0,2023-04-05 09:43:28,0,224,"<p>I want to understand how the number of function evaluation is calculated by Qiskit when running VQE algorithms. Here is some code I used in order to test this:</p>
<pre><code>from qiskit.primitives import Estimator
from qiskit.providers.aer import QasmSimulator, AerSimulator
from qiskit.algorithms.optimizers import SLSQP
from qiskit.utils import QuantumInstance
from qiskit_nature.second_q.algorithms import NumPyMinimumEigensolverFactory
from qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint
from qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import QubitConverter
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.circuit.library.ansatzes import UCC

objective_function_tolerance = 1e-6
slsqp = SLSQP(maxiter=10000, tol=objective_function_tolerance)

numpy_solver = NumPyMinimumEigensolverFactory()
quantum_instance = QuantumInstance(AerSimulator(method='statevector', device=&quot;CPU&quot;))

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])

driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(electronic_structure_problem)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
uccsd = UCC(num_spatial_orbitals, num_particles, excitations='sd')

def callback(eval_count, parameters, mean, std): print(eval_count)

vqe_factory = VQEUCCFactory(Estimator(), uccsd, slsqp, initial_point = HFInitialPoint()) 
vqe_factory.minimum_eigensolver.callback = callback
converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction=None)
gse = GroundStateEigensolver(converter, vqe_factory)
result = gse.solve(electronic_structure_problem)

print(&quot;function evaluations: &quot;, result.raw_result.cost_function_evals)
</code></pre>
<p>From inspecting the Qiskit code, it seems to me that the number of function evaluations is incremented once after each expectation value of the Hamiltonian is measured or calculated in case of running a simulation on a classical computer. This might appear quite reasonable, except that I was somehow expecting/hoping that the number of function evaluation is incremented after each Pauli string (or group of Pauli strings in case those are grouped in commuting sets) is evaluated during a VQE calculation. Could someone please confirm if my conclusion is correct or not? If possible, some pointers towards the relevant Qiskit code would help.</p>
<p>My Qiskit version:</p>
<p><a href=""https://i.sstatic.net/4lar3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4lar3.png"" alt=""enter image description here"" /></a></p>
",How the number of function evaluations is calculated in Qiskit when running VQE,<qiskit><vqe>,1,0,,,"How the number of function evaluations is calculated in Qiskit when running VQE <p>I want to understand how the number of function evaluation is calculated by Qiskit when running VQE algorithms. Here is some code I used in order to test this:</p>
<pre><code>from qiskit.primitives import Estimator
from qiskit.providers.aer import QasmSimulator, AerSimulator
from qiskit.algorithms.optimizers import SLSQP
from qiskit.utils import QuantumInstance
from qiskit_nature.second_q.algorithms import NumPyMinimumEigensolverFactory
from qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint
from qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import QubitConverter
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.circuit.library.ansatzes import UCC

objective_function_tolerance = 1e-6
slsqp = SLSQP(maxiter=10000, tol=objective_function_tolerance)

numpy_solver = NumPyMinimumEigensolverFactory()
quantum_instance = QuantumInstance(AerSimulator(method='statevector', device=&quot;CPU&quot;))

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])

driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(electronic_structure_problem)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
uccsd = UCC(num_spatial_orbitals, num_particles, excitations='sd')

def callback(eval_count, parameters, mean, std): print(eval_count)

vqe_factory = VQEUCCFactory(Estimator(), uccsd, slsqp, initial_point = HFInitialPoint()) 
vqe_factory.minimum_eigensolver.callback = callback
converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction=None)
gse = GroundStateEigensolver(converter, vqe_factory)
result = gse.solve(electronic_structure_problem)

print(&quot;function evaluations: &quot;, result.raw_result.cost_function_evals)
</code></pre>
<p>From inspecting the Qiskit code, it seems to me that the number of function evaluations is incremented once after each expectation value of the Hamiltonian is measured or calculated in case of running a simulation on a classical computer. This might appear quite reasonable, except that I was somehow expecting/hoping that the number of function evaluation is incremented after each Pauli string (or group of Pauli strings in case those are grouped in commuting sets) is evaluated during a VQE calculation. Could someone please confirm if my conclusion is correct or not? If possible, some pointers towards the relevant Qiskit code would help.</p>
<p>My Qiskit version:</p>
<p><a href=""https://i.sstatic.net/4lar3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4lar3.png"" alt=""enter image description here"" /></a></p>
",qc,number function evaluations calculated qiskit running vqe p want understand number function evaluation calculated qiskit running vqe algorithms code used order test pre code import estimator import qasmsimulator aersimulator import slsqp import quantuminstance import numpyminimumeigensolverfactory import hfinitialpoint import groundstateeigensolver vqeuccfactory import moleculeinfo import qubitconverter import pyscfdriver import freezecoretransformer import ucc slsqp slsqp numpyminimumeigensolverfactory quantuminstance aersimulator quot cpu quot molecule moleculeinfo quot li quot quot h quot driver molecule quot sto3g quot transformer freezecoretransformer uccsd ucc def callback parameters mean std print vqeuccfactory estimator uccsd slsqp hfinitialpoint callback converter qubitconverter paritymapper gse groundstateeigensolver converter result print quot function evaluations quot p inspecting qiskit code seems number function evaluations incremented expectation value hamiltonian measured calculated case running simulation classical computer might appear quite reasonable except somehow number function evaluation incremented pauli string group pauli strings case grouped commuting sets evaluated vqe calculation could someone please confirm conclusion correct possible pointers towards relevant qiskit code would p qiskit version p https nofollow noreferrer img https enter image description,"[(0, 0.40390372), (1, 0.019122208), (4, 0.084457904), (7, 0.045171663), (8, 0.21606302), (9, 0.017507192), (12, 0.020265782), (17, 0.055504046), (19, 0.13726632)]"
32010,,2023-04-06 09:51:06,1,168,"<p>I have an AWS account with some credits on it. I enabled the following policies:</p>
<ul>
<li>AmazonBraketFullAccess,
AmazonBraketJobsExecutionPolicy,
AmazonS3FullAccess</li>
</ul>
<p>but I am still getting the following error:</p>
<pre><code>AccessDeniedException: An error occurred (AccessDeniedException) when calling the CreateQuantumTask operation: This account is not authorized to use this resource. In order to access additional resources, please contact customer support
</code></pre>
<p>when trying to run the following code example:</p>
<pre><code>import boto3
from braket.aws import AwsDevice
from braket.circuits import Circuit

device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)

bell = Circuit().h(0).cnot(0, 1)
task = device.run(bell, shots=100)
print(task.result().measurement_counts)
</code></pre>
<p>from amazon-braket-sdk-python GitHub page:
<a href=""https://github.com/aws/amazon-braket-sdk-python"" rel=""nofollow noreferrer"">https://github.com/aws/amazon-braket-sdk-python</a></p>
<p>I would appreciate any help regarding that. Thank you so much in advance!</p>
",CreateQuantumTask operation: This account is not authorized to use this resource,<amazon-braket>,1,1,,,"CreateQuantumTask operation: This account is not authorized to use this resource <p>I have an AWS account with some credits on it. I enabled the following policies:</p>
<ul>
<li>AmazonBraketFullAccess,
AmazonBraketJobsExecutionPolicy,
AmazonS3FullAccess</li>
</ul>
<p>but I am still getting the following error:</p>
<pre><code>AccessDeniedException: An error occurred (AccessDeniedException) when calling the CreateQuantumTask operation: This account is not authorized to use this resource. In order to access additional resources, please contact customer support
</code></pre>
<p>when trying to run the following code example:</p>
<pre><code>import boto3
from braket.aws import AwsDevice
from braket.circuits import Circuit

device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)

bell = Circuit().h(0).cnot(0, 1)
task = device.run(bell, shots=100)
print(task.result().measurement_counts)
</code></pre>
<p>from amazon-braket-sdk-python GitHub page:
<a href=""https://github.com/aws/amazon-braket-sdk-python"" rel=""nofollow noreferrer"">https://github.com/aws/amazon-braket-sdk-python</a></p>
<p>I would appreciate any help regarding that. Thank you so much in advance!</p>
",qc,createquantumtask operation account authorized use resource p aws account credits enabled following policies ul li amazonbraketfullaccess amazonbraketjobsexecutionpolicy amazons3fullaccess p still getting following error pre code accessdeniedexception error occurred accessdeniedexception calling createquantumtask operation account authorized use resource order access additional resources please contact customer support p trying run following code example pre code import boto3 import awsdevice import circuit device awsdevice quot arn aws braket quot bell circuit 0 0 1 task bell print p github page https nofollow noreferrer https p would appreciate help regarding thank much advance,"[(0, 0.11061966), (2, 0.03664426), (4, 0.108640626), (8, 0.16435154), (12, 0.038519494), (14, 0.46090105), (18, 0.050059743), (19, 0.028727084)]"
75996453,,2023-04-12 14:07:33,3,136,"<p>I am evaluating CUDA Quantum; the goal is to build and run code with multi-GPU support
on an HPC system. I use CUDA Quantum via the official container image and using Nvidia <code>enroot</code> as container engine.</p>
<p>I build as follow with no errors:</p>
<pre class=""lang-bash prettyprint-override""><code>nvq++ cuquantum_backends.cpp -o cuquantum_backends.x --qpu cuquantum --platform mqpu 
</code></pre>
<p>as shown in the last GTC talk: &quot;Inside CUDA Quantum&quot; (<a href=""https://www.nvidia.com/en-us/on-demand/session/gtcspring23-s51762/"" rel=""nofollow noreferrer"">https://www.nvidia.com/en-us/on-demand/session/gtcspring23-s51762/</a>).</p>
<p>To get the number of available GPUs (each simulating a QPUs) I added the following (see <a href=""https://nvidia.github.io/cuda-quantum/api/languages/cpp_api.html#platform"" rel=""nofollow noreferrer"">https://nvidia.github.io/cuda-quantum/api/languages/cpp_api.html#platform</a>)</p>
<pre class=""lang-cpp prettyprint-override""><code>auto &amp;platform = cudaq::get_platform();
printf(&quot;Num QPU %zu\n&quot;, platform.num_qpus())
</code></pre>
<p>Once executed the application prints</p>
<pre class=""lang-bash prettyprint-override""><code>[ ... ]
Num QPU 1
</code></pre>
<p>while I am expecting</p>
<pre class=""lang-bash prettyprint-override""><code>[ ... ]
Num QPU 2
</code></pre>
<p>As a check I ran <code>nvidia-smi</code> inside the container and both GPUs are seen.</p>
<p>I also built the code using the multi-gpu flag shown in the <a href=""https://nvidia.github.io/cuda-quantum/using/simulators.html#cuquantum-multi-node-multi-gpu"" rel=""nofollow noreferrer"">official documentation</a></p>
<pre class=""lang-bash prettyprint-override""><code>nvq++ cuquantum_backends.cpp -o cuquantum_backends.x --qpu cuquantum_mgmn 
</code></pre>
<p>However that was not recognised by <code>nvq++</code>.</p>
<p>I see many possibilities for the code to behave in this way, among those are <code>enroot</code> and me missing something in how CUDA Quantum and cuQuantum work together, but I do not see a solution. Does anyone has any suggestion?</p>
<p>Thanks for helping</p>
<p>Marco</p>
",CUDA Quantum code built with multiGPU support flag works as single with multiple GPU assigned,<nvidia><multi-gpu><quantum-computing>,1,0,,,"CUDA Quantum code built with multiGPU support flag works as single with multiple GPU assigned <p>I am evaluating CUDA Quantum; the goal is to build and run code with multi-GPU support
on an HPC system. I use CUDA Quantum via the official container image and using Nvidia <code>enroot</code> as container engine.</p>
<p>I build as follow with no errors:</p>
<pre class=""lang-bash prettyprint-override""><code>nvq++ cuquantum_backends.cpp -o cuquantum_backends.x --qpu cuquantum --platform mqpu 
</code></pre>
<p>as shown in the last GTC talk: &quot;Inside CUDA Quantum&quot; (<a href=""https://www.nvidia.com/en-us/on-demand/session/gtcspring23-s51762/"" rel=""nofollow noreferrer"">https://www.nvidia.com/en-us/on-demand/session/gtcspring23-s51762/</a>).</p>
<p>To get the number of available GPUs (each simulating a QPUs) I added the following (see <a href=""https://nvidia.github.io/cuda-quantum/api/languages/cpp_api.html#platform"" rel=""nofollow noreferrer"">https://nvidia.github.io/cuda-quantum/api/languages/cpp_api.html#platform</a>)</p>
<pre class=""lang-cpp prettyprint-override""><code>auto &amp;platform = cudaq::get_platform();
printf(&quot;Num QPU %zu\n&quot;, platform.num_qpus())
</code></pre>
<p>Once executed the application prints</p>
<pre class=""lang-bash prettyprint-override""><code>[ ... ]
Num QPU 1
</code></pre>
<p>while I am expecting</p>
<pre class=""lang-bash prettyprint-override""><code>[ ... ]
Num QPU 2
</code></pre>
<p>As a check I ran <code>nvidia-smi</code> inside the container and both GPUs are seen.</p>
<p>I also built the code using the multi-gpu flag shown in the <a href=""https://nvidia.github.io/cuda-quantum/using/simulators.html#cuquantum-multi-node-multi-gpu"" rel=""nofollow noreferrer"">official documentation</a></p>
<pre class=""lang-bash prettyprint-override""><code>nvq++ cuquantum_backends.cpp -o cuquantum_backends.x --qpu cuquantum_mgmn 
</code></pre>
<p>However that was not recognised by <code>nvq++</code>.</p>
<p>I see many possibilities for the code to behave in this way, among those are <code>enroot</code> and me missing something in how CUDA Quantum and cuQuantum work together, but I do not see a solution. Does anyone has any suggestion?</p>
<p>Thanks for helping</p>
<p>Marco</p>
",so_new,cuda quantum code built multigpu support flag works single multiple gpu assigned p evaluating cuda quantum goal build run code support hpc system use cuda quantum via official container image using nvidia code enroot container p build follow errors pre code qpu cuquantum platform mqpu p shown last gtc talk quot inside cuda quantum quot https nofollow noreferrer https p get number available gpus simulating qpus added following see https platform nofollow noreferrer https platform pre code auto amp platform cudaq printf quot num qpu quot p executed application prints pre code num qpu 1 p expecting pre code num qpu 2 p check ran code inside container gpus p also built code using flag shown https nofollow noreferrer official documentation pre code qpu p however recognised code p see many possibilities code behave way among code enroot missing something cuda quantum cuquantum work together see solution anyone suggestion p thanks helping p marco,"[(0, 0.09055821), (4, 0.28878522), (8, 0.032632004), (12, 0.04047335), (14, 0.5005832), (19, 0.03818106)]"
32116,32118.0,2023-04-13 15:05:32,0,69,"<p>Following Qiskit code throws: AttributeError: 'ListOp' object has no attribute 'to_circuit'. This seems to be related to: z2symmetry_reduction='auto'. If the z2symmetry_reduction argument in QubitConverter is set to 'None', the code runs fine.</p>
<pre><code>from qiskit import transpile
from qiskit.transpiler import PassManager, StagedPassManager
from qiskit.providers.fake_provider import FakeWashington

from qiskit_nature.converters.second_quantization import QubitConverter
# from qiskit_nature.second_q.mappers import QubitConverter (same result)
from qiskit_nature.second_q.circuit.library.ansatzes import UCC, UCCSD
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper
from qiskit_nature.second_q.transformers import FreezeCoreTransformer

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(driver.run())

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

ucc_ansatz = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter, 
                 alpha_spin=True, beta_spin=True, max_spin_excitation=1, generalized=True, preserve_spin=True, reps=5)

decomposed_circuit = ucc_ansatz.decompose().decompose().decompose()
print(&quot;depth: &quot;, decomposed_circuit.depth())

transpiled_circuit = transpile(ucc_ansatz, FakeWashington(), optimization_level=3)
print(&quot;depth transpiled: &quot;, transpiled_circuit.depth())
print(dict(transpiled_circuit.count_ops()))

print(&quot;ansatz parameters: &quot;, len(ucc_ansatz.parameters.data))
</code></pre>
<p>My software version:</p>
<p><a href=""https://i.sstatic.net/lcR4p.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lcR4p.png"" alt=""enter image description here"" /></a></p>
",Qiskit code throws when z2symmetry_reduction argument in QubitConverter is set to 'auto',<qiskit>,1,0,,,"Qiskit code throws when z2symmetry_reduction argument in QubitConverter is set to 'auto' <p>Following Qiskit code throws: AttributeError: 'ListOp' object has no attribute 'to_circuit'. This seems to be related to: z2symmetry_reduction='auto'. If the z2symmetry_reduction argument in QubitConverter is set to 'None', the code runs fine.</p>
<pre><code>from qiskit import transpile
from qiskit.transpiler import PassManager, StagedPassManager
from qiskit.providers.fake_provider import FakeWashington

from qiskit_nature.converters.second_quantization import QubitConverter
# from qiskit_nature.second_q.mappers import QubitConverter (same result)
from qiskit_nature.second_q.circuit.library.ansatzes import UCC, UCCSD
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper
from qiskit_nature.second_q.transformers import FreezeCoreTransformer

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(driver.run())

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

ucc_ansatz = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter, 
                 alpha_spin=True, beta_spin=True, max_spin_excitation=1, generalized=True, preserve_spin=True, reps=5)

decomposed_circuit = ucc_ansatz.decompose().decompose().decompose()
print(&quot;depth: &quot;, decomposed_circuit.depth())

transpiled_circuit = transpile(ucc_ansatz, FakeWashington(), optimization_level=3)
print(&quot;depth transpiled: &quot;, transpiled_circuit.depth())
print(dict(transpiled_circuit.count_ops()))

print(&quot;ansatz parameters: &quot;, len(ucc_ansatz.parameters.data))
</code></pre>
<p>My software version:</p>
<p><a href=""https://i.sstatic.net/lcR4p.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lcR4p.png"" alt=""enter image description here"" /></a></p>
",qc,qiskit code throws argument qubitconverter set p following qiskit code throws attributeerror object attribute seems related argument qubitconverter set code runs pre code qiskit import transpile import passmanager stagedpassmanager import fakewashington import qubitconverter import qubitconverter result import ucc uccsd import pyscfdriver import moleculeinfo import paritymapper import freezecoretransformer qubitconverter paritymapper molecule moleculeinfo quot li quot quot h quot driver molecule quot sto3g quot transformer freezecoretransformer 0 ucc print quot depth quot transpile fakewashington print quot depth transpiled quot print dict print quot ansatz parameters quot len p software version p https nofollow noreferrer img https enter image description,"[(0, 0.5011487), (4, 0.1174299), (8, 0.1132172), (12, 0.011635635), (14, 0.049508065), (17, 0.05221258), (19, 0.15333857)]"
32154,,2023-04-16 04:52:38,4,202,"<p>QAOA is a well-known heuristic for solving optimization problems, and it has the desirable property that as p -&gt; infinity, the true minimum objective function value is reached.</p>
<p>There is a generalization of QAOA cleverly named with the same acronym, but for the purpose of avoiding confusion in this question I'll call it QAO Ansatz (<a href=""https://arxiv.org/pdf/1709.03489.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1709.03489.pdf</a>)</p>
<p>Nowhere in this paper, or any other paper have I ever found any formal performance guarantees for QAO Ansatz.  Is there any reason to expect it to perform better, aside from an informal argument that it only explores feasible states?</p>
",Does QAO Ansatz have any better performance guarantees than QAOA?,<optimization><qaoa>,1,0,,,"Does QAO Ansatz have any better performance guarantees than QAOA? <p>QAOA is a well-known heuristic for solving optimization problems, and it has the desirable property that as p -&gt; infinity, the true minimum objective function value is reached.</p>
<p>There is a generalization of QAOA cleverly named with the same acronym, but for the purpose of avoiding confusion in this question I'll call it QAO Ansatz (<a href=""https://arxiv.org/pdf/1709.03489.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1709.03489.pdf</a>)</p>
<p>Nowhere in this paper, or any other paper have I ever found any formal performance guarantees for QAO Ansatz.  Is there any reason to expect it to perform better, aside from an informal argument that it only explores feasible states?</p>
",qc,qao ansatz better performance guarantees qaoa p qaoa heuristic solving optimization problems desirable property p gt infinity true minimum objective function value p generalization qaoa cleverly named acronym purpose avoiding confusion question call qao ansatz https nofollow noreferrer https p nowhere paper paper ever found formal performance guarantees qao ansatz reason expect perform better aside informal argument explores feasible states,"[(0, 0.109056376), (1, 0.12554428), (5, 0.032244377), (8, 0.33441228), (9, 0.33271694), (12, 0.017048517), (14, 0.046648607)]"
32158,32160.0,2023-04-16 16:29:15,1,413,"<p>Any two qubit density matrix can be written as</p>
<p><span class=""math-container"">$$ \rho = \frac{1}{4} \sum_{n,m = 0}^{3} M_{nm} (\sigma_n \otimes \sigma_m), $$</span></p>
<p>where <span class=""math-container"">$\sigma_\mu$</span>'s are the identity and Pauli matrices.</p>
<p>Is it possible to do a local unitary transformation on the system, like <span class=""math-container"">$U_1 \otimes U_2$</span>, which will transform <span class=""math-container"">$\rho$</span> into <span class=""math-container"">$\rho'$</span> which looks like this:</p>
<p><span class=""math-container"">$$\rho' = \frac{1}{4} \left( \sigma_0 \otimes \sigma_0 +  M^{'}_{11} \sigma_1 \otimes \sigma_1 +  M^{'}_{22} \sigma_2 \otimes \sigma_2 + M^{'}_{33} \sigma_3 \otimes \sigma_3 \right)$$</span></p>
<p>i.e. the matrix whose elements are <span class=""math-container"">$\{M_{nm}\}$</span> is diagonal?</p>
","How to write a two qubit state as ""diagonal"" in the basis of Pauli matrices?",<quantum-state><density-matrix><unitarity>,1,0,,,"How to write a two qubit state as ""diagonal"" in the basis of Pauli matrices? <p>Any two qubit density matrix can be written as</p>
<p><span class=""math-container"">$$ \rho = \frac{1}{4} \sum_{n,m = 0}^{3} M_{nm} (\sigma_n \otimes \sigma_m), $$</span></p>
<p>where <span class=""math-container"">$\sigma_\mu$</span>'s are the identity and Pauli matrices.</p>
<p>Is it possible to do a local unitary transformation on the system, like <span class=""math-container"">$U_1 \otimes U_2$</span>, which will transform <span class=""math-container"">$\rho$</span> into <span class=""math-container"">$\rho'$</span> which looks like this:</p>
<p><span class=""math-container"">$$\rho' = \frac{1}{4} \left( \sigma_0 \otimes \sigma_0 +  M^{'}_{11} \sigma_1 \otimes \sigma_1 +  M^{'}_{22} \sigma_2 \otimes \sigma_2 + M^{'}_{33} \sigma_3 \otimes \sigma_3 \right)$$</span></p>
<p>i.e. the matrix whose elements are <span class=""math-container"">$\{M_{nm}\}$</span> is diagonal?</p>
",qc,write two qubit state diagonal basis pauli matrices p two qubit density matrix written p span 1 4 n 0 3 nm p span identity pauli p possible local unitary transformation system like span transform span span looks like p span 1 4 11 22 33 p matrix whose elements span nm diagonal,"[(2, 0.10527616), (3, 0.6352967), (6, 0.05257484), (11, 0.05620684), (12, 0.019245476), (14, 0.07353813), (18, 0.055417147)]"
32219,,2023-04-19 10:07:46,3,653,"<p>I am trying to formulate a problem as QUBO problem and am not able to transform the inequality constraint.</p>
<p><span class=""math-container"">$$ \sum_i^N x_i \geq 1 $$</span> into a suitable penalty function. For N = 2, the penalty term can be written as <span class=""math-container"">$$ P(1-x_1-x_2+x_1x_2)$$</span> as mentioned in <a href=""https://leeds-faculty.colorado.edu/glover/511%20-%20QUBO%20Tutorial%20-%20updated%20version%20-%20May%204,%202019.pdf"" rel=""nofollow noreferrer"">A Tutorial on Formulating and Using QUBO Models</a>. Can someone help me in generalising the above constraint to equivalent penalty.</p>
",Inequality constraint to QUBO penalty,<optimization><qubo>,2,0,,,"Inequality constraint to QUBO penalty <p>I am trying to formulate a problem as QUBO problem and am not able to transform the inequality constraint.</p>
<p><span class=""math-container"">$$ \sum_i^N x_i \geq 1 $$</span> into a suitable penalty function. For N = 2, the penalty term can be written as <span class=""math-container"">$$ P(1-x_1-x_2+x_1x_2)$$</span> as mentioned in <a href=""https://leeds-faculty.colorado.edu/glover/511%20-%20QUBO%20Tutorial%20-%20updated%20version%20-%20May%204,%202019.pdf"" rel=""nofollow noreferrer"">A Tutorial on Formulating and Using QUBO Models</a>. Can someone help me in generalising the above constraint to equivalent penalty.</p>
",qc,inequality constraint qubo penalty p trying formulate problem qubo problem able transform inequality p span 1 suitable penalty function n 2 penalty term written span p mentioned https 20qubo 20tutorial 20updated 20version 20may 204 nofollow noreferrer tutorial formulating using qubo models someone help generalising constraint equivalent,"[(1, 0.17941341), (2, 0.026851473), (3, 0.27841318), (4, 0.19103552), (7, 0.058909323), (8, 0.097606), (11, 0.14007242), (12, 0.024709107)]"
32237,,2023-04-20 05:28:23,0,596,"<p>I went through the link &quot; <a href=""https://learn.qiskit.org/course/ch-applications/hybrid-quantum-classical-neural-networks-with-pytorch-and-qiskit%22"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/ch-applications/hybrid-quantum-classical-neural-networks-with-pytorch-and-qiskit&quot;</a> where a hybrid of classical and quantum computation is used. As per my understanding the classical components is encoded using angle encoding for quantum computation. I could not understand that if I want to use some other encoding such as amplitude encoding...how would I go about.I am not sure how to implement angle encoding and amplitude encoding in pytorch. Thanks in Adv.</p>
",Encoding classical data to quantum space,<qiskit><encoding>,1,0,,,"Encoding classical data to quantum space <p>I went through the link &quot; <a href=""https://learn.qiskit.org/course/ch-applications/hybrid-quantum-classical-neural-networks-with-pytorch-and-qiskit%22"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/ch-applications/hybrid-quantum-classical-neural-networks-with-pytorch-and-qiskit&quot;</a> where a hybrid of classical and quantum computation is used. As per my understanding the classical components is encoded using angle encoding for quantum computation. I could not understand that if I want to use some other encoding such as amplitude encoding...how would I go about.I am not sure how to implement angle encoding and amplitude encoding in pytorch. Thanks in Adv.</p>
",qc,encoding classical data quantum space p went link quot https 22 nofollow noreferrer https quot hybrid classical quantum computation used per understanding classical components encoded using angle encoding quantum computation could understand want use encoding amplitude encoding would go sure implement angle encoding amplitude encoding pytorch thanks,"[(1, 0.066256925), (4, 0.112811476), (8, 0.66077393), (9, 0.05434143), (12, 0.02217009), (14, 0.03552643), (19, 0.045304336)]"
32271,,2023-04-22 10:39:12,0,248,"<p>I have been reading the paper &quot;Resource theory of unextendibility and non-asymptotic quantum capacity&quot; (<a href=""https://arxiv.org/pdf/1803.10710.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1803.10710.pdf</a>)  by Kaur et.al, I have two questions specifically.
How does the inequality (114) come about and how does this inequality transform into (115)?</p>
<p>The authors mention
&quot;The first equality (115) is due to the “transpose trick” property of the maximally entangled state, which leads to its <span class=""math-container"">$U\otimes U^{*}$</span> invariance.&quot; Firstly, I don't understand why <span class=""math-container"">$\Phi_{RA}$</span> can be written in this way( as an integral), after some preliminary reading I have found that this is related to Haar measures and twirls. I am completely unfamiliar with the subject. The references that I have looked at online treat the topic from a pure mathematics perspective, being a physics student I find it hard to grasp it fully. I am looking for a treatment of this subject from a quantum information point of view. Any help will be appreciated. Basically, I am confused about how (115) is coming at all.</p>
",Twirling of quantum states: Maximally entangled states,<information-theory><unitarity><haar-distribution><channel-capacity><resource-theories>,1,1,,,"Twirling of quantum states: Maximally entangled states <p>I have been reading the paper &quot;Resource theory of unextendibility and non-asymptotic quantum capacity&quot; (<a href=""https://arxiv.org/pdf/1803.10710.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1803.10710.pdf</a>)  by Kaur et.al, I have two questions specifically.
How does the inequality (114) come about and how does this inequality transform into (115)?</p>
<p>The authors mention
&quot;The first equality (115) is due to the “transpose trick” property of the maximally entangled state, which leads to its <span class=""math-container"">$U\otimes U^{*}$</span> invariance.&quot; Firstly, I don't understand why <span class=""math-container"">$\Phi_{RA}$</span> can be written in this way( as an integral), after some preliminary reading I have found that this is related to Haar measures and twirls. I am completely unfamiliar with the subject. The references that I have looked at online treat the topic from a pure mathematics perspective, being a physics student I find it hard to grasp it fully. I am looking for a treatment of this subject from a quantum information point of view. Any help will be appreciated. Basically, I am confused about how (115) is coming at all.</p>
",qc,twirling quantum states maximally entangled states p reading paper quot resource theory unextendibility quantum capacity quot https nofollow noreferrer https kaur two questions specifically inequality 114 come inequality transform 115 p authors mention quot first equality 115 due transpose trick property maximally entangled state leads span quot firstly understand span ra written way integral preliminary reading found related haar measures twirls completely unfamiliar subject references looked online treat topic pure mathematics perspective physics student find hard grasp fully looking treatment subject quantum information point view help appreciated basically confused 115 coming,"[(0, 0.035947997), (3, 0.20363049), (7, 0.09970076), (8, 0.34700915), (9, 0.11677131), (12, 0.01137521), (18, 0.1247307), (19, 0.05945523)]"
32280,32294.0,2023-04-23 16:11:08,3,145,"<p>I've recently been studying Deutsch's 1985 paper &quot;Quantum theory, the Church-Turing principle and the universal quantum computer&quot; (<a href=""https://www.daviddeutsch.org.uk/wp-content/deutsch85.pdf%5D"" rel=""nofollow noreferrer"">pdf here</a>).  In this he endorses the position that a naïve statement of the Church-Turing thesis is in tension with quantum mechanics.  He augments the Church-Turing thesis to consider universal quantum Turing machines (QTM), in lieu of or in addition to the (classical) Turing machines, and suggests a number of ways to use such quantum Turing machines to test various predictions of quantum mechanics.</p>
<p>Deutsch finds it instructive to program his QTM with a high-level programming language. For example, he contends that the following <code>ALGOL</code>-68 code &quot;<em>is</em> a performance of the Einstein-Podolsky-Rosen experiment&quot; (emphasis in original):</p>
<pre><code>BEGIN
   INT n=8*random;                %pick one of eight random rotation matrices%
   BOOL x, y;                     %prepare two qubits%
   x:=y:=FALSE;                   %initialize the qubits to |0&gt;%
   V(8,y);                        %apply a Hadamard matrix to the second qubit%
   x eorab y;                     %perform a CNOT (exclusive OR) operation%
   IF V(n,y)≠                     %perform the random rotation on qubit y%
      V(n,x)                      %do the same on qubit x%
      THEN print((&quot;Quantum theory refuted.&quot;))
      ELSE print((&quot;Quantum theory corroborated.&quot;))
   FI
END
</code></pre>
<p>Deutsch ends his paper rather cheekily with a couple of challenges:</p>
<blockquote>
<p>Quantum computers raise interesting problems for the design of programming languages, which I shall not go into here. From what I have said, programs exist that would (in order of increasing difficulty) test the Bell inequality, <strong>test the linearity of quantum dynamics</strong>, and test the Everett interpretation. <strong>I leave it to the reader to write them.</strong>  (Emphasis added).</p>
</blockquote>
<p>In addition to the <code>ALGOL</code> pseudocode for the EPR experiment above, of the three other challenges proposed by Deutsch we regularly program quantum computers to run Bell experiments now, for example with CHSH games.  While, Deutsch's grand vision of combining AI with quantum computers to place a conscious AI in superposition so as to test the Everettian many-worlds hypothesis is manifestly difficult and perhaps reliant on questionable or at least controversial assumptions.</p>
<p><strong>But, what kind of program could test for the (non)linearity of quantum dynamics?</strong></p>
<p>For example, would a failure of quantum phase estimation falsify linearity?  Are there old ideas of, say, Weinberg or others, that could be put to the test with a quantum computer succinctly described with a snippet of code or a quantum circuit?</p>
<hr />
<p><sup> As far as I can see, this is the first explicitly written program to perform a purely quantum task. For example as Deutsch notes, Feynman's earlier 1982 talk/paper proposed something that we would now call a <a href=""https://en.wikipedia.org/wiki/Quantum_simulator"" rel=""nofollow noreferrer"">quantum simulator</a> but only briefly described how such a device could be &quot;programmed&quot; with ladder operators, while Feynman's 1985 proposal of a quantum mechanical computer offered reversible circuits for the (classical) <a href=""https://en.wikipedia.org/wiki/Adder_(electronics)"" rel=""nofollow noreferrer"">half- and full-adder</a>.</sup></p>
",What kind of program was Deutsch envisioning to test for the linearity of quantum mechanics?,<programming><history><church-turing-thesis>,1,2,,,"What kind of program was Deutsch envisioning to test for the linearity of quantum mechanics? <p>I've recently been studying Deutsch's 1985 paper &quot;Quantum theory, the Church-Turing principle and the universal quantum computer&quot; (<a href=""https://www.daviddeutsch.org.uk/wp-content/deutsch85.pdf%5D"" rel=""nofollow noreferrer"">pdf here</a>).  In this he endorses the position that a naïve statement of the Church-Turing thesis is in tension with quantum mechanics.  He augments the Church-Turing thesis to consider universal quantum Turing machines (QTM), in lieu of or in addition to the (classical) Turing machines, and suggests a number of ways to use such quantum Turing machines to test various predictions of quantum mechanics.</p>
<p>Deutsch finds it instructive to program his QTM with a high-level programming language. For example, he contends that the following <code>ALGOL</code>-68 code &quot;<em>is</em> a performance of the Einstein-Podolsky-Rosen experiment&quot; (emphasis in original):</p>
<pre><code>BEGIN
   INT n=8*random;                %pick one of eight random rotation matrices%
   BOOL x, y;                     %prepare two qubits%
   x:=y:=FALSE;                   %initialize the qubits to |0&gt;%
   V(8,y);                        %apply a Hadamard matrix to the second qubit%
   x eorab y;                     %perform a CNOT (exclusive OR) operation%
   IF V(n,y)≠                     %perform the random rotation on qubit y%
      V(n,x)                      %do the same on qubit x%
      THEN print((&quot;Quantum theory refuted.&quot;))
      ELSE print((&quot;Quantum theory corroborated.&quot;))
   FI
END
</code></pre>
<p>Deutsch ends his paper rather cheekily with a couple of challenges:</p>
<blockquote>
<p>Quantum computers raise interesting problems for the design of programming languages, which I shall not go into here. From what I have said, programs exist that would (in order of increasing difficulty) test the Bell inequality, <strong>test the linearity of quantum dynamics</strong>, and test the Everett interpretation. <strong>I leave it to the reader to write them.</strong>  (Emphasis added).</p>
</blockquote>
<p>In addition to the <code>ALGOL</code> pseudocode for the EPR experiment above, of the three other challenges proposed by Deutsch we regularly program quantum computers to run Bell experiments now, for example with CHSH games.  While, Deutsch's grand vision of combining AI with quantum computers to place a conscious AI in superposition so as to test the Everettian many-worlds hypothesis is manifestly difficult and perhaps reliant on questionable or at least controversial assumptions.</p>
<p><strong>But, what kind of program could test for the (non)linearity of quantum dynamics?</strong></p>
<p>For example, would a failure of quantum phase estimation falsify linearity?  Are there old ideas of, say, Weinberg or others, that could be put to the test with a quantum computer succinctly described with a snippet of code or a quantum circuit?</p>
<hr />
<p><sup> As far as I can see, this is the first explicitly written program to perform a purely quantum task. For example as Deutsch notes, Feynman's earlier 1982 talk/paper proposed something that we would now call a <a href=""https://en.wikipedia.org/wiki/Quantum_simulator"" rel=""nofollow noreferrer"">quantum simulator</a> but only briefly described how such a device could be &quot;programmed&quot; with ladder operators, while Feynman's 1985 proposal of a quantum mechanical computer offered reversible circuits for the (classical) <a href=""https://en.wikipedia.org/wiki/Adder_(electronics)"" rel=""nofollow noreferrer"">half- and full-adder</a>.</sup></p>
",qc,kind program deutsch envisioning test linearity quantum mechanics p recently studying deutsch 1985 paper quot quantum theory principle universal quantum computer quot https 5d nofollow noreferrer pdf endorses position naïve statement thesis tension quantum mechanics augments thesis consider universal quantum turing machines qtm lieu addition classical turing machines suggests number ways use quantum turing machines test various predictions quantum p deutsch finds instructive program qtm programming language example contends following code algol code quot em performance experiment quot emphasis original pre code begin int random pick one eight random rotation matrices bool x prepare two qubits x initialize qubits gt v 8 apply hadamard matrix second qubit x eorab perform cnot exclusive operation v n perform random rotation qubit v n x qubit x print quot quantum theory quot else print quot quantum theory quot fi end p deutsch ends paper rather cheekily couple challenges blockquote p quantum computers raise interesting problems design programming languages shall go said programs exist would order increasing difficulty test bell inequality strong test linearity quantum dynamics test everett interpretation strong leave reader write emphasis added p addition code algol pseudocode epr experiment three challenges proposed deutsch regularly program quantum computers run bell experiments example chsh games deutsch grand vision combining ai quantum computers place conscious ai superposition test everettian hypothesis manifestly difficult perhaps reliant questionable least controversial p strong kind program could test non linearity quantum dynamics p example would failure quantum phase estimation falsify linearity old ideas say weinberg others could put test quantum computer succinctly described snippet code quantum circuit hr p sup far see first explicitly written program perform purely quantum task example deutsch notes feynman earlier 1982 proposed something would call https nofollow noreferrer quantum simulator briefly described device could quot programmed quot ladder operators feynman 1985 proposal quantum mechanical computer offered reversible circuits classical https electronics nofollow noreferrer,"[(0, 0.045491435), (1, 0.06097952), (3, 0.062627636), (7, 0.018906806), (8, 0.33523458), (9, 0.15593503), (10, 0.06477657), (12, 0.010812836), (13, 0.055437014), (14, 0.05528394), (18, 0.07682002), (19, 0.05092532)]"
32328,,2023-04-27 01:35:15,1,60,"<p>Is there an interactive coding platform for learning quantum computing (like DataCamp, but for quantum computing)?</p>
<p>With DataCamp, after each new concept, it gives you a window with incomplete code for you to complete and then run.  If the result is correct, you move forward.</p>
<p>Is there something like this for quantum computing?</p>
","Is there an interactive coding platform for learning quantum computing (like DataCamp, but for quantum computing)?",<resource-request>,0,0,,,"Is there an interactive coding platform for learning quantum computing (like DataCamp, but for quantum computing)? <p>Is there an interactive coding platform for learning quantum computing (like DataCamp, but for quantum computing)?</p>
<p>With DataCamp, after each new concept, it gives you a window with incomplete code for you to complete and then run.  If the result is correct, you move forward.</p>
<p>Is there something like this for quantum computing?</p>
",qc,interactive coding platform learning quantum computing like datacamp quantum computing p interactive coding platform learning quantum computing like datacamp quantum computing p datacamp new concept gives window incomplete code complete run result correct move p something like quantum computing,"[(8, 0.7199812), (12, 0.057329834), (14, 0.21785715)]"
32379,,2023-04-30 09:46:40,2,66,"<p>I am doing an experiment in Qiskit - trying to mimic convolution of 2 vectors and getting the result of convolution using element-wise approach.</p>
<p>However, I as doing necessary steps the result I get is very different from actual result.
As I was searching internet, there was an research paper that quantum convolution is not possible.</p>
<p>Could someone in this sub could affirm this and I am wasting my time trying to create which is not possible?</p>
<p>The steps I taking for this in Qiskit:</p>
<ol>
<li>Normalizing 2 same size vectors and create circuits for them.</li>
<li>Apply QFT for both circuits.</li>
<li>Combine them and perform controlled rotations with values.</li>
<li>Apply IQFT.</li>
<li>Measure result.</li>
</ol>
",Convolution using QFT with 2 vectors,<quantum-fourier-transform>,0,0,,,"Convolution using QFT with 2 vectors <p>I am doing an experiment in Qiskit - trying to mimic convolution of 2 vectors and getting the result of convolution using element-wise approach.</p>
<p>However, I as doing necessary steps the result I get is very different from actual result.
As I was searching internet, there was an research paper that quantum convolution is not possible.</p>
<p>Could someone in this sub could affirm this and I am wasting my time trying to create which is not possible?</p>
<p>The steps I taking for this in Qiskit:</p>
<ol>
<li>Normalizing 2 same size vectors and create circuits for them.</li>
<li>Apply QFT for both circuits.</li>
<li>Combine them and perform controlled rotations with values.</li>
<li>Apply IQFT.</li>
<li>Measure result.</li>
</ol>
",qc,convolution using qft 2 vectors p experiment qiskit trying mimic convolution 2 vectors getting result convolution using p however necessary steps result get different actual result searching internet research paper quantum convolution p could someone sub could affirm wasting time trying create possible p steps taking qiskit ol li normalizing 2 size vectors create circuits li apply qft li combine perform controlled rotations li apply li measure,"[(2, 0.059408464), (7, 0.28706506), (8, 0.056674417), (12, 0.064619355), (13, 0.09999026), (14, 0.43005994)]"
32419,,2023-05-03 14:36:28,1,36,"<p>The holevo information of <span class=""math-container"">$\rho_{ABC}$</span> w.r.t to measurements on A and B (for the sake of this we'll assume local measurements suffice), is given by <span class=""math-container"">$$\chi(\hat{A},\hat{B}:C)$$</span> where <span class=""math-container"">$\hat{A}$</span> and <span class=""math-container"">$\hat{B}$</span> are a local measurement channel using projectors after the maximisation is taken over all possible rank 1 projectors on the two subsystems.</p>
<p>These projective measurements on the subsystems <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> would give a classica-classical-quantum state after their action of <span class=""math-container"">$\rho_{ABC}$</span></p>
<p>However, this is just the mutual information of the resultant classical-quantum state you obtain after you perform said measurements on <span class=""math-container"">$\rho_{ABC}$</span>, which means it will be upperbound by the mutual information of the state before the action of the local measurement map has taken place:
<span class=""math-container"">$$I(A,B:C)\ge\chi(\hat{A},\hat{B}:C)$$</span></p>
<p>However, this should also obey the monotonicity of the relative entropy function under the action of a local channel:</p>
<p><span class=""math-container"">$$S(\rho_{ABC}||\rho_{AB}\otimes \rho_{C})\ge S((I\otimes\Phi_{B})\rho_{ABC}||(I\otimes\Phi_{B})\rho_{AB}\otimes \rho_{C}) \ge$$</span></p>
<p><span class=""math-container"">$$S((\Phi_{A} \otimes\Phi_{B})\rho_{ABC}||(\Phi_{A} \otimes\Phi_{B})\rho_{AB}\otimes \rho_{C})$$</span></p>
<p>This implies that <span class=""math-container"">$\chi(\hat{A},\hat{B}:C) \le \chi(\hat{A},B:C)$</span>, where in this case <span class=""math-container"">$\Phi_{A}$</span> and <span class=""math-container"">$\Phi_{B}$</span> are the local measurement channels. This seems right given everything I know regarding the relative entropy.</p>
<p>However, how does having a whole other system to measure decrease the holevo information? I believe my confusion is maybe as a result of the maximisation, ie the measurements that maximise it given a local operation on one system don't remain the same when you consider another system to maximise across as well. Or I am misinterpreting <span class=""math-container"">$\chi(\hat{A},B:C)$</span> as a holveo information function given only one of the systems has been measured.</p>
<p>Either that or I am misunderstanding a key property regarding the monotonicity of the relative entropy function. Any other map and I would say that <span class=""math-container"">$I(\hat{A},\hat{B}:C) \le I(\hat{A},B:C)$</span>, where the hat denotes the action of a map. But I am having trouble with the interpretation behind this. ie how does measurement on one subsystem give more informatio than measuring on two?</p>
","How can $\chi(\hat{A},\hat{B}:C) \le \chi(\hat{A},B:C)$ be true?",<quantum-operation><information-theory><relative-entropy><mutual-information>,0,8,,,"How can $\chi(\hat{A},\hat{B}:C) \le \chi(\hat{A},B:C)$ be true? <p>The holevo information of <span class=""math-container"">$\rho_{ABC}$</span> w.r.t to measurements on A and B (for the sake of this we'll assume local measurements suffice), is given by <span class=""math-container"">$$\chi(\hat{A},\hat{B}:C)$$</span> where <span class=""math-container"">$\hat{A}$</span> and <span class=""math-container"">$\hat{B}$</span> are a local measurement channel using projectors after the maximisation is taken over all possible rank 1 projectors on the two subsystems.</p>
<p>These projective measurements on the subsystems <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> would give a classica-classical-quantum state after their action of <span class=""math-container"">$\rho_{ABC}$</span></p>
<p>However, this is just the mutual information of the resultant classical-quantum state you obtain after you perform said measurements on <span class=""math-container"">$\rho_{ABC}$</span>, which means it will be upperbound by the mutual information of the state before the action of the local measurement map has taken place:
<span class=""math-container"">$$I(A,B:C)\ge\chi(\hat{A},\hat{B}:C)$$</span></p>
<p>However, this should also obey the monotonicity of the relative entropy function under the action of a local channel:</p>
<p><span class=""math-container"">$$S(\rho_{ABC}||\rho_{AB}\otimes \rho_{C})\ge S((I\otimes\Phi_{B})\rho_{ABC}||(I\otimes\Phi_{B})\rho_{AB}\otimes \rho_{C}) \ge$$</span></p>
<p><span class=""math-container"">$$S((\Phi_{A} \otimes\Phi_{B})\rho_{ABC}||(\Phi_{A} \otimes\Phi_{B})\rho_{AB}\otimes \rho_{C})$$</span></p>
<p>This implies that <span class=""math-container"">$\chi(\hat{A},\hat{B}:C) \le \chi(\hat{A},B:C)$</span>, where in this case <span class=""math-container"">$\Phi_{A}$</span> and <span class=""math-container"">$\Phi_{B}$</span> are the local measurement channels. This seems right given everything I know regarding the relative entropy.</p>
<p>However, how does having a whole other system to measure decrease the holevo information? I believe my confusion is maybe as a result of the maximisation, ie the measurements that maximise it given a local operation on one system don't remain the same when you consider another system to maximise across as well. Or I am misinterpreting <span class=""math-container"">$\chi(\hat{A},B:C)$</span> as a holveo information function given only one of the systems has been measured.</p>
<p>Either that or I am misunderstanding a key property regarding the monotonicity of the relative entropy function. Any other map and I would say that <span class=""math-container"">$I(\hat{A},\hat{B}:C) \le I(\hat{A},B:C)$</span>, where the hat denotes the action of a map. But I am having trouble with the interpretation behind this. ie how does measurement on one subsystem give more informatio than measuring on two?</p>
",qc,b c b c true p holevo information span abc measurements b sake assume local measurements suffice given span b c span span b local measurement channel using projectors maximisation taken possible rank 1 projectors two p projective measurements subsystems span span b would give state action span abc p however mutual information resultant state obtain perform said measurements span abc means upperbound mutual information state action local measurement map taken place span b c b c p however also obey monotonicity relative entropy function action local channel p span abc ab c b abc b ab c p span b abc b ab c p implies span b c b c case span span b local measurement channels seems right given everything know regarding relative p however whole system measure decrease holevo information believe confusion maybe result maximisation ie measurements maximise given local operation one system remain consider another system maximise across well misinterpreting span b c holveo information function given one systems p either misunderstanding key property regarding monotonicity relative entropy function map would say span b c b c hat denotes action map trouble interpretation behind ie measurement one subsystem give informatio measuring two,"[(3, 0.88165873), (12, 0.010593952), (14, 0.023416325), (18, 0.08348909)]"
32467,,2023-05-06 01:17:12,2,45,"<p>I often hear about the graph isomorphism problem reducing to the HSP with the symmetric group and a mapping <span class=""math-container"">$f \colon \pi \in S_N \mapsto \pi(G)$</span> with <span class=""math-container"">$G$</span> being some graph (the union of the graphs we’re checking). And occasionally, it is mentioned that the Shortest Vector Problem (SVP) reduces to the HSP with the dihedral group attached to it.</p>
<p>While it is known, very well actually, that graph isomorphism, the SVP, factoring, and so on are in NP and therefore reduce to SAT, what I don’t know is if the HSP reduces to SAT in the general case. A key point is that the HSP does not necessarily reduce back to its ‘representation’ problem. I use ‘representation’ problem here to refer to factoring, graph isomorphism and SVP.</p>
<p>That is, if we had a solution to SAT given as an oracle, could we solve the HSP? If not, are there exceptions?</p>
<p>I think that the HSP for all abelian groups (may) be in NP? But does this hold for all non-abelian groups? Am I wrong about this being true for abelian groups?</p>
","Does a solution to SAT solve the HSP for $S_N$, $D_{2N}$, or even the general case?",<hidden-subgroup-problem><factorization><graph-isomorphism>,0,5,,,"Does a solution to SAT solve the HSP for $S_N$, $D_{2N}$, or even the general case? <p>I often hear about the graph isomorphism problem reducing to the HSP with the symmetric group and a mapping <span class=""math-container"">$f \colon \pi \in S_N \mapsto \pi(G)$</span> with <span class=""math-container"">$G$</span> being some graph (the union of the graphs we’re checking). And occasionally, it is mentioned that the Shortest Vector Problem (SVP) reduces to the HSP with the dihedral group attached to it.</p>
<p>While it is known, very well actually, that graph isomorphism, the SVP, factoring, and so on are in NP and therefore reduce to SAT, what I don’t know is if the HSP reduces to SAT in the general case. A key point is that the HSP does not necessarily reduce back to its ‘representation’ problem. I use ‘representation’ problem here to refer to factoring, graph isomorphism and SVP.</p>
<p>That is, if we had a solution to SAT given as an oracle, could we solve the HSP? If not, are there exceptions?</p>
<p>I think that the HSP for all abelian groups (may) be in NP? But does this hold for all non-abelian groups? Am I wrong about this being true for abelian groups?</p>
",qc,solution sat solve hsp 2n even general case p often hear graph isomorphism problem reducing hsp symmetric group mapping span f g span g graph union graphs checking occasionally mentioned shortest vector problem svp reduces hsp dihedral group attached p known well actually graph isomorphism svp factoring np therefore reduce sat know hsp reduces sat general case key point hsp necessarily reduce back representation problem use representation problem refer factoring graph isomorphism p solution sat given oracle could solve hsp exceptions p think hsp abelian groups may np hold groups wrong true abelian groups,"[(1, 0.14038323), (3, 0.47372538), (7, 0.038312312), (8, 0.04918225), (10, 0.021339877), (11, 0.017276261), (12, 0.010018359), (13, 0.24844334)]"
32468,,2023-05-06 05:34:00,0,126,"<p>The following is a part of the syndrome measurement circuit for Steane's seven qubit code in Stim(For ease of viewing, the TICK is omitted.). Since we are considering the detection of X errors, we use the measurement results of the Z stabilizers' ancilla. Circuit_1 is a circuit that constructs the CNOTs of the Z stabilizer circuit after configuring the CNOTs of the X stabilizer circuit, and since it is a circuit with no errors, the results of DETECTOR in circuit_1 will always be False, which is the desired result. On the other hand, when considering circuit_2, which is a circuit designed to reduce the overall circuit depth by cleverly arranging the order of CNOTs, the CNOT operations are the same as in circuit_1, but the result of qubit 12 becomes random. Why is this happening?</p>
<pre><code>circuit_1=stim.Circuit('''

    #encode into code state
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6
    
    #ancilla of X stabilizers
    RX 7 8 9 
    
    #ancilla of Z stabilizers
    R 10 11 12 
    
    #CNOT of X stabilizers
    CX 7 6 8 5
    CX 7 2 8 1
    CX 7 4 8 6
    CX 7 0 8 2 9 5
    CX 9 6
    CX 9 3
    CX 9 4
    
    #CNOT of Z stabilizers
    CX 6 12
    CX 3 12
    CX 4 12
    CX 6 10 5 11
    CX 2 10 1 11
    CX 4 10 6 11    
    CX 0 10 2 11 5 12
    
    #measurement of stabilizers
    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
</code></pre>
<pre><code>circuit_2=stim.Circuit('''

    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6

    RX 7 8 9 
    R 10 11 12 

    CX 7 6 8 5
    CX 7 2 8 1 6 12
    CX 7 4 8 6 3 12
    CX 7 0 8 2 9 5 4 12
    CX 6 10 5 11
    CX 9 6 2 10 1 11
    CX 9 3 4 10 6 11    
    CX 9 4 0 10 2 11 5 12

    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
<span class=""math-container"">```</span>
</code></pre>
",Why does the qubit give random results in the circuit with rearranged CNOTs for Steane's seven qubit code in Stim?,<measurement><error-correction><stabilizer-code><stim><stabilizer-state>,2,0,,,"Why does the qubit give random results in the circuit with rearranged CNOTs for Steane's seven qubit code in Stim? <p>The following is a part of the syndrome measurement circuit for Steane's seven qubit code in Stim(For ease of viewing, the TICK is omitted.). Since we are considering the detection of X errors, we use the measurement results of the Z stabilizers' ancilla. Circuit_1 is a circuit that constructs the CNOTs of the Z stabilizer circuit after configuring the CNOTs of the X stabilizer circuit, and since it is a circuit with no errors, the results of DETECTOR in circuit_1 will always be False, which is the desired result. On the other hand, when considering circuit_2, which is a circuit designed to reduce the overall circuit depth by cleverly arranging the order of CNOTs, the CNOT operations are the same as in circuit_1, but the result of qubit 12 becomes random. Why is this happening?</p>
<pre><code>circuit_1=stim.Circuit('''

    #encode into code state
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6
    
    #ancilla of X stabilizers
    RX 7 8 9 
    
    #ancilla of Z stabilizers
    R 10 11 12 
    
    #CNOT of X stabilizers
    CX 7 6 8 5
    CX 7 2 8 1
    CX 7 4 8 6
    CX 7 0 8 2 9 5
    CX 9 6
    CX 9 3
    CX 9 4
    
    #CNOT of Z stabilizers
    CX 6 12
    CX 3 12
    CX 4 12
    CX 6 10 5 11
    CX 2 10 1 11
    CX 4 10 6 11    
    CX 0 10 2 11 5 12
    
    #measurement of stabilizers
    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
</code></pre>
<pre><code>circuit_2=stim.Circuit('''

    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6

    RX 7 8 9 
    R 10 11 12 

    CX 7 6 8 5
    CX 7 2 8 1 6 12
    CX 7 4 8 6 3 12
    CX 7 0 8 2 9 5 4 12
    CX 6 10 5 11
    CX 9 6 2 10 1 11
    CX 9 3 4 10 6 11    
    CX 9 4 0 10 2 11 5 12

    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
<span class=""math-container"">```</span>
</code></pre>
",qc,qubit give random results circuit rearranged cnots steane seven qubit code stim p following part syndrome measurement circuit steane seven qubit code stim ease viewing tick since considering detection x errors use measurement results z stabilizers ancilla circuit constructs cnots z stabilizer circuit configuring cnots x stabilizer circuit since circuit errors results detector always false desired result hand considering circuit designed reduce overall circuit depth cleverly arranging order cnots cnot operations result qubit 12 becomes random happening pre code encode code state mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp x0 x2 x4 x6 ancilla x stabilizers rx 7 8 9 ancilla z stabilizers r 10 11 12 cnot x stabilizers cx 7 6 8 5 cx 7 2 8 1 cx 7 4 8 6 cx 7 0 8 2 9 5 cx 9 6 cx 9 3 cx 9 4 cnot z stabilizers cx 6 12 cx 3 12 cx 4 12 cx 6 10 5 11 cx 2 10 1 11 cx 4 10 6 11 cx 0 10 2 11 5 12 measurement stabilizers mrx 7 8 9 mr 10 11 12 detector rec detector rec detector rec pre code mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp x0 x2 x4 x6 rx 7 8 9 r 10 11 12 cx 7 6 8 5 cx 7 2 8 1 6 12 cx 7 4 8 6 3 12 cx 7 0 8 2 9 5 4 12 cx 6 10 5 11 cx 9 6 2 10 1 11 cx 9 3 4 10 6 11 cx 9 4 0 10 2 11 5 12 mrx 7 8 9 mr 10 11 12 detector rec detector rec detector rec span,"[(4, 0.010423158), (5, 0.11730933), (6, 0.6755729), (9, 0.030547796), (10, 0.014155013), (12, 0.021320641), (14, 0.06402523), (17, 0.02413691), (18, 0.034258336)]"
32530,,2023-05-11 02:49:14,2,1184,"<p>If I want to condition adding a gate to a circuit in qiskit, I understand how to use <code>c_if()</code> to condition on one classical register, but is there a way to condition it on the measurement of two or more classical registers? Say I have</p>
<pre><code>q = QuantumRegister(5)
c1 = ClassicalRegister(1)
c2 = ClassicalRegister(1)

qc = QuantumCircuit(q,c1)
qc.add_register(c2)
</code></pre>
<p>So there are two classical registers and 5 qubits. Then say</p>
<pre><code>circuit.measure(q[1],c1)
circuit.measure(q[3],c2)
</code></pre>
<p>Is there a way for me to do something like
<code>qc.x(q[4]).c_if((c1,1) AND (c2,3))</code>?</p>
",Is there a way to have multiple conditions in a `c_if` in Qiskit?,<qiskit><measurement><quantum-circuit>,1,0,,,"Is there a way to have multiple conditions in a `c_if` in Qiskit? <p>If I want to condition adding a gate to a circuit in qiskit, I understand how to use <code>c_if()</code> to condition on one classical register, but is there a way to condition it on the measurement of two or more classical registers? Say I have</p>
<pre><code>q = QuantumRegister(5)
c1 = ClassicalRegister(1)
c2 = ClassicalRegister(1)

qc = QuantumCircuit(q,c1)
qc.add_register(c2)
</code></pre>
<p>So there are two classical registers and 5 qubits. Then say</p>
<pre><code>circuit.measure(q[1],c1)
circuit.measure(q[3],c2)
</code></pre>
<p>Is there a way for me to do something like
<code>qc.x(q[4]).c_if((c1,1) AND (c2,3))</code>?</p>
",qc,way multiple conditions qiskit p want condition adding gate circuit qiskit understand use code condition one classical register way condition measurement two classical registers say pre code q quantumregister 5 c1 classicalregister 1 c2 classicalregister 1 qc quantumcircuit q c1 c2 p two classical registers 5 qubits say pre code q 1 c1 q 3 c2 p way something like code q 4,"[(0, 0.24009769), (1, 0.036702633), (6, 0.0883951), (10, 0.08659526), (12, 0.048103813), (14, 0.3408447), (18, 0.15720351)]"
32606,32614.0,2023-05-16 22:00:34,0,70,"<p>I am trying to create a custom ansatz to use the built-in Qiskit VQE() function. My ansatz is composed of single qubit gates and a hamiltonian gate which cannot be decomposed into  Qiskit supported gates. Here is my ansatz function:</p>
<pre><code>def quantum_state_preparation(sites, reps):
qc = QuantumCircuit(sites)
num_params = reps*(2*sites+1)
params = ParameterVector('θ', num_params)  

H = 0*SparsePauliOp('I'*(sites))
for j in range(1, sites):
    H -= 1/2 * (SparsePauliOp('I'*(j-1) + 'XX' + 'I'*(sites-j-1)) + SparsePauliOp('I'*(j-1) + 'YY' + 'I'*(sites-j-1)))
ham_op = H.simplify()

for n in range(reps):
    ham_gate = HamiltonianGate(ham_op, params[n*(2*sites+1)]/2)
    qc.append(ham_gate, range(sites))

    for i in range(sites): #single qubit gates
        qc.p(params[n*(2*sites+1)+1+2*i] ,i)
        qc.rx(params[n*(2*sites+1)+2+2*i] ,i)
qc.parameter_bounds=[[0,2*np.pi]]*num_params 
return qc
</code></pre>
<p>When I plug quantum_state_preparation(sites, reps) into the VQE() function it fails. I am pretty sure it is because HamiltonianGate() is unable to handle unbound parameters but I don't know a way around this.</p>
",Creating a parameterized Operator in Qiskit that cannot be decomposed into Qiskit supported gates,<qiskit><quantum-gate><hamiltonian-simulation><vqe>,1,0,,,"Creating a parameterized Operator in Qiskit that cannot be decomposed into Qiskit supported gates <p>I am trying to create a custom ansatz to use the built-in Qiskit VQE() function. My ansatz is composed of single qubit gates and a hamiltonian gate which cannot be decomposed into  Qiskit supported gates. Here is my ansatz function:</p>
<pre><code>def quantum_state_preparation(sites, reps):
qc = QuantumCircuit(sites)
num_params = reps*(2*sites+1)
params = ParameterVector('θ', num_params)  

H = 0*SparsePauliOp('I'*(sites))
for j in range(1, sites):
    H -= 1/2 * (SparsePauliOp('I'*(j-1) + 'XX' + 'I'*(sites-j-1)) + SparsePauliOp('I'*(j-1) + 'YY' + 'I'*(sites-j-1)))
ham_op = H.simplify()

for n in range(reps):
    ham_gate = HamiltonianGate(ham_op, params[n*(2*sites+1)]/2)
    qc.append(ham_gate, range(sites))

    for i in range(sites): #single qubit gates
        qc.p(params[n*(2*sites+1)+1+2*i] ,i)
        qc.rx(params[n*(2*sites+1)+2+2*i] ,i)
qc.parameter_bounds=[[0,2*np.pi]]*num_params 
return qc
</code></pre>
<p>When I plug quantum_state_preparation(sites, reps) into the VQE() function it fails. I am pretty sure it is because HamiltonianGate() is unable to handle unbound parameters but I don't know a way around this.</p>
",qc,creating parameterized operator qiskit decomposed qiskit supported gates p trying create custom ansatz use qiskit vqe function ansatz composed single qubit gates hamiltonian gate decomposed qiskit supported gates ansatz function pre code def sites reps qc quantumcircuit sites reps 2 params parametervector θ h 0 sparsepauliop sites j range 1 sites h sparsepauliop sparsepauliop n range reps hamiltoniangate params n 2 range sites range sites single qubit gates params n 2 params n 2 return qc p plug sites reps vqe function fails pretty sure hamiltoniangate unable handle unbound parameters know way around,"[(0, 0.4685547), (2, 0.04975377), (3, 0.0148573695), (9, 0.07145312), (10, 0.12328702), (12, 0.021684514), (14, 0.23823857), (16, 0.010879513)]"
32667,32668.0,2023-05-20 14:57:58,2,1383,"<p>Recently, I have been completing a VQE code and implementing the VQE algorithm for noisy models. However, during this process, I discovered that there are two types of Estimators provided in different tutorials.</p>
<pre><code>from qiskit_aer.primitives import Estimator as AerEstimator
from qiskit.primitives import Estimator
</code></pre>
<p>I tested them separately and encountered the following confusion:
A shortened version of my code is as follows:</p>
<pre><code>def UCCSD_VQE(hamiltonian, n_particles, num_qubits....):
    seed = 170
    algorithm_globals.random_seed = seed    
    num_particles = [n_particles // 2, n_particles // 2]
    mapper = JordanWignerMapper()
    converter = QubitConverter(mapper=mapper)
    hf = HartreeFock(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2)
    ansatz = UCCSD(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2, initial_state=hf, generalized=False, preserve_spin=True)
    optimizer = COBYLA(maxiter=1000)
    estimator = Estimator()
    vqe = VQE(estimator, ansatz=ansatz, optimizer=optimizer)
    vqe.initial_point = np.zeros(ansatz.num_parameters)
    result = vqe.compute_minimum_eigenvalue(hamiltonian)
    circ = result.optimal_circuit.bind_parameters(result.optimal_parameters)
   
    print(result)
    print(f&quot;VQE on Aer qasm simulator (no noise): {result.optimal_value.real:.8f}&quot;)
    print(f&quot;Delta from reference energy value is {(result.optimal_value.real - ref_value):.8f}&quot;)
</code></pre>
<p>If this is the setting, the result is relatively good. I calculated LiH with a molecular spacing of 2.8, and the returned result is as follows:</p>
<pre><code> 'optimizer_time': 25.174492597579956}
VQE on Aer qasm simulator (no noise): -7.80622948
Delta from reference energy value is 0.00000008
</code></pre>
<p>You can find time is approximately 25 seconds, and the error from the reference value is also within 0.00000008.</p>
<p>When I switch the simulator &quot;from qiskit_aer.primitives import Estimator&quot;, my setting is：</p>
<pre><code>try:
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)
   noiseless_estimator.set_options(device='GPU')
except AerError as e:
   print(&quot;Failed to initialize GPU estimator in creating no_Real_Noisy_model:&quot;, str(e))
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)

vqe = VQE(noiseless_estimator, ansatz=ansatz, optimizer=optimizer)
</code></pre>
<p>The rest of the code remains unchanged.</p>
<p>I have two pieces of NVIDIA GTX3090Ti, but the results after modifying this code are very poor.</p>
<pre><code>'optimizer_time': 899.3149755001068}
VQE on Aer qasm simulator (no noise): -7.81485699
Delta from reference energy value is -0.00862743
</code></pre>
<p>You can see that not only has the running time of the program increased, but also the accuracy has decreased.</p>
<p>My question is:</p>
<ol>
<li>Why does this phenomenon occur?</li>
<li>How can I set it up to fix this problem?</li>
</ol>
<p>My Virtual Environment Settings：</p>
<pre><code>qiskit                   0.39.2
qiskit-aer               0.11.1
qiskit-aer-gpu           0.11.2
qiskit-ibmq-provider     0.19.2
qiskit-nature            0.5.0
qiskit-terra             0.22.2
</code></pre>
<p>Thanks!!</p>
",What are the differences between the two Estimator in the qiskit,<qiskit>,1,0,,,"What are the differences between the two Estimator in the qiskit <p>Recently, I have been completing a VQE code and implementing the VQE algorithm for noisy models. However, during this process, I discovered that there are two types of Estimators provided in different tutorials.</p>
<pre><code>from qiskit_aer.primitives import Estimator as AerEstimator
from qiskit.primitives import Estimator
</code></pre>
<p>I tested them separately and encountered the following confusion:
A shortened version of my code is as follows:</p>
<pre><code>def UCCSD_VQE(hamiltonian, n_particles, num_qubits....):
    seed = 170
    algorithm_globals.random_seed = seed    
    num_particles = [n_particles // 2, n_particles // 2]
    mapper = JordanWignerMapper()
    converter = QubitConverter(mapper=mapper)
    hf = HartreeFock(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2)
    ansatz = UCCSD(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2, initial_state=hf, generalized=False, preserve_spin=True)
    optimizer = COBYLA(maxiter=1000)
    estimator = Estimator()
    vqe = VQE(estimator, ansatz=ansatz, optimizer=optimizer)
    vqe.initial_point = np.zeros(ansatz.num_parameters)
    result = vqe.compute_minimum_eigenvalue(hamiltonian)
    circ = result.optimal_circuit.bind_parameters(result.optimal_parameters)
   
    print(result)
    print(f&quot;VQE on Aer qasm simulator (no noise): {result.optimal_value.real:.8f}&quot;)
    print(f&quot;Delta from reference energy value is {(result.optimal_value.real - ref_value):.8f}&quot;)
</code></pre>
<p>If this is the setting, the result is relatively good. I calculated LiH with a molecular spacing of 2.8, and the returned result is as follows:</p>
<pre><code> 'optimizer_time': 25.174492597579956}
VQE on Aer qasm simulator (no noise): -7.80622948
Delta from reference energy value is 0.00000008
</code></pre>
<p>You can find time is approximately 25 seconds, and the error from the reference value is also within 0.00000008.</p>
<p>When I switch the simulator &quot;from qiskit_aer.primitives import Estimator&quot;, my setting is：</p>
<pre><code>try:
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)
   noiseless_estimator.set_options(device='GPU')
except AerError as e:
   print(&quot;Failed to initialize GPU estimator in creating no_Real_Noisy_model:&quot;, str(e))
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)

vqe = VQE(noiseless_estimator, ansatz=ansatz, optimizer=optimizer)
</code></pre>
<p>The rest of the code remains unchanged.</p>
<p>I have two pieces of NVIDIA GTX3090Ti, but the results after modifying this code are very poor.</p>
<pre><code>'optimizer_time': 899.3149755001068}
VQE on Aer qasm simulator (no noise): -7.81485699
Delta from reference energy value is -0.00862743
</code></pre>
<p>You can see that not only has the running time of the program increased, but also the accuracy has decreased.</p>
<p>My question is:</p>
<ol>
<li>Why does this phenomenon occur?</li>
<li>How can I set it up to fix this problem?</li>
</ol>
<p>My Virtual Environment Settings：</p>
<pre><code>qiskit                   0.39.2
qiskit-aer               0.11.1
qiskit-aer-gpu           0.11.2
qiskit-ibmq-provider     0.19.2
qiskit-nature            0.5.0
qiskit-terra             0.22.2
</code></pre>
<p>Thanks!!</p>
",qc,differences two estimator qiskit p recently completing vqe code implementing vqe algorithm noisy models however process discovered two types estimators provided different pre code import estimator aerestimator import estimator p tested separately encountered following confusion shortened version code follows pre code def hamiltonian seed 170 seed 2 2 mapper jordanwignermapper converter qubitconverter hf hartreefock 2 ansatz uccsd 2 optimizer cobyla estimator estimator vqe vqe estimator result hamiltonian circ print result print f quot vqe aer qasm simulator noise quot print f quot delta reference energy value quot p setting result relatively good calculated lih molecular spacing returned result follows pre code vqe aer qasm simulator noise delta reference energy value p find time approximately 25 seconds error reference value also within p switch simulator quot import estimator quot setting pre code try aerestimator quot seed quot seed quot quot seed except aererror e print quot failed initialize gpu estimator creating quot str e aerestimator quot seed quot seed quot quot seed vqe vqe p rest code remains p two pieces nvidia gtx3090ti results modifying code pre code vqe aer qasm simulator noise delta reference energy value p see running time program increased also accuracy p question ol li phenomenon occur li set fix problem p virtual environment pre code qiskit p thanks,"[(0, 0.47300208), (4, 0.01881341), (7, 0.04614793), (8, 0.089510344), (9, 0.044240538), (12, 0.019544492), (14, 0.09280325), (17, 0.056560222), (19, 0.15883301)]"
32712,,2023-05-24 16:18:11,1,142,"<p>I'm researching the quantum random number service offered by the computer maker Quantinuum. They say that they have verified quantum randomness by a Bell test. I took Bell's 1964 classic paper and coded up the corresponding circuit. The circuit prepares a singlet Bell state, rotates by 45 degrees about the x axis in the Bloch sphere and performs a measurement. Adding one to the correlation (mean spin product) gives the left hand side of Bell's equation 15 for the angles he specifies in the discussion following equation 22. I repeated the circuit and took the absolute value of the correlation, giving the right-hand side of equation 15. The inequality is violated, implying that there is quantum randomness and that there is no hidden variable. If a simulator can pass the Bell test, what does it prove that Quantinuum's product passes the Bell test? Furthermore, the numbers aren't truly random - they are derived from a seed. So shouldn't they fail the Bell test?</p>
<p>(15) <span class=""math-container"">$$1+P(b,c)\ge|P(a,b)-P(a,c)|$$</span></p>
<pre><code>from make_bell import *
config=get_config()
def initialize(qc):
    qc=QuantumCircuit(2,2)
    qc = make_bell_nc(1,1,0,1,qc) #singlet
    theta = np.pi/4
    qc.rx(theta,0)
    return qc
compute_state=0
shots=100
simulate=0
q = QuantumRegister(2)
c = ClassicalRegister(2)
qc = QuantumCircuit(q,c)
qc = initialize(qc)
for i_qubit in range(2):
    qc.measure(i_qubit,i_qubit)
counts_both=[]
# IBMQ.save_account(&quot;&quot;)
for irun in range(2):
    if simulate==0: #Live back end
        backend_name = config['BACKENDS']['live']
        IBMQ.load_account()
        provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')
        backend = provider.get_backend(backend_name)

    elif simulate == 1:
        if compute_state:
            backend=qiskit.BasicAer.get_backend('statevector_simulator')
            backend_name = 'statevector_simulator'
        else:
            from qiskit.providers.aer import QasmSimulator
            backend = QasmSimulator()  #    Use Aer's qasm_simulator
            backend_name = 'qasm_simulator'
    if simulate==1:
        result = execute(qc, backend=backend,shots=shots).result()
        counts=result.get_counts()
    elif simulate==0: #Live back end
        compiled_circuit = transpile(qc, backend)
        job = backend.run(compiled_circuit, shots=20000)
        job_monitor(job)
        result = job.result()
        counts=result.get_counts()
    counts_both.append(counts)
pbc=(counts_both[0]['11']+counts_both[0]['00']-counts_both[0]['01']-counts_both[0]['10'])/shots
pab=(counts_both[1]['11']+counts_both[1]['00']-counts_both[1]['01']-counts_both[1]['10'])/shots
print(f'correlations {pbc:.2f} {pab:.2f}')
lhs = 1+pbc
rhs = np.abs(pab)
print(f&quot;lhs {lhs:.3f} rhs {rhs:.3f} {lhs&gt;=rhs}&quot;)

</code></pre>
<p>The left-hand side was about .3 <span class=""math-container"">$$1-1/\sqrt{2}$$</span> and the right-hand side was about .7 <span class=""math-container"">$$1/\sqrt{2}$$</span></p>
",Quantinuum corporation says they have a Bell test for quantum randomness. Why does the simulator pass the test?,<bell-experiment>,1,2,,,"Quantinuum corporation says they have a Bell test for quantum randomness. Why does the simulator pass the test? <p>I'm researching the quantum random number service offered by the computer maker Quantinuum. They say that they have verified quantum randomness by a Bell test. I took Bell's 1964 classic paper and coded up the corresponding circuit. The circuit prepares a singlet Bell state, rotates by 45 degrees about the x axis in the Bloch sphere and performs a measurement. Adding one to the correlation (mean spin product) gives the left hand side of Bell's equation 15 for the angles he specifies in the discussion following equation 22. I repeated the circuit and took the absolute value of the correlation, giving the right-hand side of equation 15. The inequality is violated, implying that there is quantum randomness and that there is no hidden variable. If a simulator can pass the Bell test, what does it prove that Quantinuum's product passes the Bell test? Furthermore, the numbers aren't truly random - they are derived from a seed. So shouldn't they fail the Bell test?</p>
<p>(15) <span class=""math-container"">$$1+P(b,c)\ge|P(a,b)-P(a,c)|$$</span></p>
<pre><code>from make_bell import *
config=get_config()
def initialize(qc):
    qc=QuantumCircuit(2,2)
    qc = make_bell_nc(1,1,0,1,qc) #singlet
    theta = np.pi/4
    qc.rx(theta,0)
    return qc
compute_state=0
shots=100
simulate=0
q = QuantumRegister(2)
c = ClassicalRegister(2)
qc = QuantumCircuit(q,c)
qc = initialize(qc)
for i_qubit in range(2):
    qc.measure(i_qubit,i_qubit)
counts_both=[]
# IBMQ.save_account(&quot;&quot;)
for irun in range(2):
    if simulate==0: #Live back end
        backend_name = config['BACKENDS']['live']
        IBMQ.load_account()
        provider = IBMQ.get_provider(hub='ibm-q', group='open', project='main')
        backend = provider.get_backend(backend_name)

    elif simulate == 1:
        if compute_state:
            backend=qiskit.BasicAer.get_backend('statevector_simulator')
            backend_name = 'statevector_simulator'
        else:
            from qiskit.providers.aer import QasmSimulator
            backend = QasmSimulator()  #    Use Aer's qasm_simulator
            backend_name = 'qasm_simulator'
    if simulate==1:
        result = execute(qc, backend=backend,shots=shots).result()
        counts=result.get_counts()
    elif simulate==0: #Live back end
        compiled_circuit = transpile(qc, backend)
        job = backend.run(compiled_circuit, shots=20000)
        job_monitor(job)
        result = job.result()
        counts=result.get_counts()
    counts_both.append(counts)
pbc=(counts_both[0]['11']+counts_both[0]['00']-counts_both[0]['01']-counts_both[0]['10'])/shots
pab=(counts_both[1]['11']+counts_both[1]['00']-counts_both[1]['01']-counts_both[1]['10'])/shots
print(f'correlations {pbc:.2f} {pab:.2f}')
lhs = 1+pbc
rhs = np.abs(pab)
print(f&quot;lhs {lhs:.3f} rhs {rhs:.3f} {lhs&gt;=rhs}&quot;)

</code></pre>
<p>The left-hand side was about .3 <span class=""math-container"">$$1-1/\sqrt{2}$$</span> and the right-hand side was about .7 <span class=""math-container"">$$1/\sqrt{2}$$</span></p>
",qc,quantinuum corporation says bell test quantum randomness simulator pass test p researching quantum random number service offered computer maker quantinuum say verified quantum randomness bell test took bell 1964 classic paper coded corresponding circuit circuit prepares singlet bell state rotates 45 degrees x axis bloch sphere performs measurement adding one correlation mean spin product gives left hand side bell equation 15 angles specifies discussion following equation repeated circuit took absolute value correlation giving side equation inequality violated implying quantum randomness hidden variable simulator pass bell test prove quantinuum product passes bell test furthermore numbers truly random derived seed fail bell test p 15 span b c b c pre code import def initialize qc qc qc singlet theta return qc q quantumregister 2 c classicalregister 2 qc quantumcircuit q c qc initialize qc range 2 quot quot irun range 2 live back end config provider backend elif simulate 1 else import qasmsimulator backend qasmsimulator use aer result execute qc elif live back end transpile qc backend job job result counts 0 0 0 0 1 1 1 1 print pbc pab lhs rhs pab print f quot lhs lhs rhs rhs lhs gt quot p side span 2 side span 2,"[(0, 0.29252088), (2, 0.07232927), (3, 0.16046658), (6, 0.01695412), (8, 0.032394543), (9, 0.032266226), (10, 0.041259702), (12, 0.019986), (13, 0.12698096), (14, 0.07194872), (18, 0.0952189), (19, 0.037267413)]"
32765,32957.0,2023-05-29 11:07:29,1,54,"<p>I am new to this field, so i would like to be sure that the local simulator is actually free.
Then, I would like to know how to check the number of qubits avaiable in the simulator.</p>
",Local Simulator for Aquila Aws,<quantum-gate>,1,0,,,"Local Simulator for Aquila Aws <p>I am new to this field, so i would like to be sure that the local simulator is actually free.
Then, I would like to know how to check the number of qubits avaiable in the simulator.</p>
",qc,local simulator aquila aws p new field would like sure local simulator actually free would like know check number qubits avaiable,"[(1, 0.14985688), (12, 0.04957834), (14, 0.7921417)]"
32836,,2023-06-02 14:51:16,1,72,"<p>Relative entropy of coherence for a density matrix p is defined as follow</p>
<p><span class=""math-container"">$C(p)=S(p_{diag})-S(p)$</span></p>
<p>Where S is the von neumann entropy.</p>
<p>for more info check the <a href=""https://www.nature.com/articles/s41598-017-09332-9"" rel=""nofollow noreferrer"">link</a> (look at the section result)</p>
<p>I know how to calculate the von neumann entropy. I just dont know how to calculate <span class=""math-container"">$p_{diag}$</span>?</p>
<p>I tried using the diagonal elements of p to obtain  <span class=""math-container"">$p_{diag}$</span> but the result of C(p) became over 1. I think C(p) is in range 0 to 1. Isnt it?</p>
",How to calculate relative entropy of coherence?,<relative-entropy>,0,0,,,"How to calculate relative entropy of coherence? <p>Relative entropy of coherence for a density matrix p is defined as follow</p>
<p><span class=""math-container"">$C(p)=S(p_{diag})-S(p)$</span></p>
<p>Where S is the von neumann entropy.</p>
<p>for more info check the <a href=""https://www.nature.com/articles/s41598-017-09332-9"" rel=""nofollow noreferrer"">link</a> (look at the section result)</p>
<p>I know how to calculate the von neumann entropy. I just dont know how to calculate <span class=""math-container"">$p_{diag}$</span>?</p>
<p>I tried using the diagonal elements of p to obtain  <span class=""math-container"">$p_{diag}$</span> but the result of C(p) became over 1. I think C(p) is in range 0 to 1. Isnt it?</p>
",qc,calculate relative entropy coherence p relative entropy coherence density matrix p defined follow p span c p diag p p von neumann p info check https nofollow noreferrer link look section result p know calculate von neumann entropy dont know calculate span diag p tried using diagonal elements p obtain span diag result c p became think c p range 0 isnt,"[(0, 0.029189441), (2, 0.017819352), (3, 0.63554883), (4, 0.23494078), (8, 0.04556439), (11, 0.019725738), (12, 0.015117128)]"
32898,,2023-06-09 07:10:45,0,120,"<p>There are things I do not understand about the following circuit, and I would appreciate it if you could explain.</p>
<pre><code>circuit=stim.Circuit(f'''
    MPP X0*X1*X2*X3
    CX 1 0 2 0 3 0 
    M 0
    DETECTOR rec[-1]
''')
dem = circuit.detector_error_model()
print(repr(dem))
</code></pre>
<p>This circuit initially prepares a stabilizer state stabilized by <span class=""math-container"">$XXXX$</span> through <code>MPP X0*X1*X2*X3</code>. I understand that part, but I do not understand what the subsequent operations imply.</p>
<p>One interpretation is that, by measuring <span class=""math-container"">$ZZZZ$</span> with three CNOTs, since <span class=""math-container"">$XXXX$</span> and <span class=""math-container"">$ZZZZ$</span> commute, the state after the measurement is thought to remain stabilized by <span class=""math-container"">$XXXX$</span>. However, another interpretation is that we are actually measuring <span class=""math-container"">$ZIII$</span> at the end of the circuit, which anti-commutes with <span class=""math-container"">$XXXX$</span>, so the state after the measurement could be considered to be in a state that is not stabilized by <span class=""math-container"">$XXXX$</span>. Which interpretation is correct? In fact, simulations by Stim consistently return trivial measurement results, which suggests the former interpretation is correct. However, I do not understand why it's not appropriate to consider that we're measuring <span class=""math-container"">$ZIII$</span>, which anti-commutes with <span class=""math-container"">$XXXX$</span>.</p>
",Commutation relationship and measurement results,<error-correction><measurement><stabilizer-code><pauli-gates><stim>,1,0,,,"Commutation relationship and measurement results <p>There are things I do not understand about the following circuit, and I would appreciate it if you could explain.</p>
<pre><code>circuit=stim.Circuit(f'''
    MPP X0*X1*X2*X3
    CX 1 0 2 0 3 0 
    M 0
    DETECTOR rec[-1]
''')
dem = circuit.detector_error_model()
print(repr(dem))
</code></pre>
<p>This circuit initially prepares a stabilizer state stabilized by <span class=""math-container"">$XXXX$</span> through <code>MPP X0*X1*X2*X3</code>. I understand that part, but I do not understand what the subsequent operations imply.</p>
<p>One interpretation is that, by measuring <span class=""math-container"">$ZZZZ$</span> with three CNOTs, since <span class=""math-container"">$XXXX$</span> and <span class=""math-container"">$ZZZZ$</span> commute, the state after the measurement is thought to remain stabilized by <span class=""math-container"">$XXXX$</span>. However, another interpretation is that we are actually measuring <span class=""math-container"">$ZIII$</span> at the end of the circuit, which anti-commutes with <span class=""math-container"">$XXXX$</span>, so the state after the measurement could be considered to be in a state that is not stabilized by <span class=""math-container"">$XXXX$</span>. Which interpretation is correct? In fact, simulations by Stim consistently return trivial measurement results, which suggests the former interpretation is correct. However, I do not understand why it's not appropriate to consider that we're measuring <span class=""math-container"">$ZIII$</span>, which anti-commutes with <span class=""math-container"">$XXXX$</span>.</p>
",qc,commutation relationship measurement results p things understand following circuit would appreciate could pre code f mpp x0 x1 x2 x3 cx 1 0 2 0 3 0 0 detector rec dem print repr dem p circuit initially prepares stabilizer state stabilized span xxxx code mpp x0 x1 x2 x3 understand part understand subsequent operations p one interpretation measuring span zzzz three cnots since span xxxx span zzzz commute state measurement thought remain stabilized span xxxx however another interpretation actually measuring span ziii end circuit span xxxx state measurement could considered state stabilized span xxxx interpretation correct fact simulations stim consistently return trivial measurement results suggests former interpretation correct however understand appropriate consider measuring span ziii span xxxx,"[(0, 0.028756283), (2, 0.026397346), (3, 0.32174316), (5, 0.13551073), (6, 0.1669987), (10, 0.012374159), (12, 0.017614314), (14, 0.057081863), (17, 0.041536205), (18, 0.19112568)]"
32936,,2023-06-11 20:02:37,2,43,"<p>I have been using pickle (and also tried dill) to save and load Clifford gates coming from the Stim library. The following code:
<code>cliff_list = dill.load(filename)</code>
gives the error
<code>ImportError: generic_type: type &quot;CompiledDemSampler&quot; is already registered!</code>.</p>
<p>The code is running fine on my laptop but not on a remote computer, where this error occurs. I am using other methods from Stim in the script where I try to load the above file. How should I try to fix this?</p>
",Stim and pickle/dill incompatibility,<stim>,0,2,,,"Stim and pickle/dill incompatibility <p>I have been using pickle (and also tried dill) to save and load Clifford gates coming from the Stim library. The following code:
<code>cliff_list = dill.load(filename)</code>
gives the error
<code>ImportError: generic_type: type &quot;CompiledDemSampler&quot; is already registered!</code>.</p>
<p>The code is running fine on my laptop but not on a remote computer, where this error occurs. I am using other methods from Stim in the script where I try to load the above file. How should I try to fix this?</p>
",qc,stim incompatibility p using pickle also tried dill save load clifford gates coming stim library following code code filename gives error code importerror type quot compileddemsampler quot already registered p code running fine laptop remote computer error occurs using methods stim script try load file try fix,"[(0, 0.041977737), (5, 0.1618397), (12, 0.045162868), (14, 0.5917349), (19, 0.15580437)]"
33001,33009.0,2023-06-15 23:36:27,1,235,"<p>As pointed out in the QisKit tutorial <a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Single-Qubit-Quantum-states"" rel=""nofollow noreferrer"">here</a>, for one qubit there exists a general unitary (see the expression for it in the previous link). I wonder if there exists equally unambiguous expressions for two and three qubits that allow transformation from separable states to all the interesting states, like entangled states in the case of two qubits or GHZ states in the case of three qubits. I was looking at how <code>plot_bloch_multivector</code> works as shown <a href=""https://learn.qiskit.org/course/ch-gates/multiple-qubits-and-entangled-states#visual"" rel=""nofollow noreferrer"">here</a>. Is this in the right direction? An educated guess could be using the SU(N) matrices? It is a 4x4 matrix for two qubits and a 8x8 matrix for three qubits; and then decompose such SU(N) matrices in terms of Pauli and Clifford gates? I don't know if this is possible because the SU(N) matrices are supposed to be given in a parametric form. Another alternative that seems compelling is using Givens rotations, which are a general technique used to parametrize unitary matrices. However, I have no idea on how to implement this.</p>
",What is the general unitary matrix for two- and three-qubit states?,<entanglement><unitarity><matrix-representation>,1,0,,,"What is the general unitary matrix for two- and three-qubit states? <p>As pointed out in the QisKit tutorial <a href=""https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Single-Qubit-Quantum-states"" rel=""nofollow noreferrer"">here</a>, for one qubit there exists a general unitary (see the expression for it in the previous link). I wonder if there exists equally unambiguous expressions for two and three qubits that allow transformation from separable states to all the interesting states, like entangled states in the case of two qubits or GHZ states in the case of three qubits. I was looking at how <code>plot_bloch_multivector</code> works as shown <a href=""https://learn.qiskit.org/course/ch-gates/multiple-qubits-and-entangled-states#visual"" rel=""nofollow noreferrer"">here</a>. Is this in the right direction? An educated guess could be using the SU(N) matrices? It is a 4x4 matrix for two qubits and a 8x8 matrix for three qubits; and then decompose such SU(N) matrices in terms of Pauli and Clifford gates? I don't know if this is possible because the SU(N) matrices are supposed to be given in a parametric form. Another alternative that seems compelling is using Givens rotations, which are a general technique used to parametrize unitary matrices. However, I have no idea on how to implement this.</p>
",qc,general unitary matrix states p pointed qiskit tutorial https nofollow noreferrer one qubit exists general unitary see expression previous link wonder exists equally unambiguous expressions two three qubits allow transformation separable states interesting states like entangled states case two qubits ghz states case three qubits looking code works shown https visual nofollow noreferrer right direction educated guess could using su n matrices 4x4 matrix two qubits 8x8 matrix three qubits decompose su n matrices terms pauli clifford gates know possible su n matrices supposed given parametric form another alternative seems compelling using givens rotations general technique used parametrize unitary matrices however idea implement,"[(3, 0.23112491), (4, 0.07145214), (7, 0.05156424), (9, 0.2604921), (11, 0.05772939), (12, 0.010123097), (13, 0.045505114), (14, 0.07821279), (18, 0.19269714)]"
33020,,2023-06-17 19:05:33,1,251,"<p>The authors give the following definition for the Pauli group in the paper <a href=""https://doi.org/10.48550/arXiv.2108.05803"" rel=""nofollow noreferrer"">Averaged circuit eigenvalue sampling</a>.</p>
<blockquote>
<p>The n-qubit Pauli group <span class=""math-container"">$P_n$</span> consists of n-fold tensor products of single-qubit Pauli operators labeled as follows. Let <span class=""math-container"">$\mathbf{a}$</span> be a 2n-bit string <span class=""math-container"">$\mathbf{a}=a_1a_2\ldots a_{2n}$</span> and write <span class=""math-container"">$P_\mathbf{a} = i^{\mathbf{a}^T \Upsilon \mathbf{a}} \prod_{j=1}^{n} X^{\mathbf{a}_{2j-1}}_j Z^{\mathbf{a}_{2j}}_j$</span>, where <span class=""math-container"">$X_j$</span> and <span class=""math-container"">$Z_j$</span> are single-qubit Paulis acting on qubit <span class=""math-container"">$j$</span> and <span class=""math-container"">$$\Upsilon=\bigoplus^n_{k=1}\begin{pmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{pmatrix}$$</span> is such that <span class=""math-container"">$P_{\mathbf{a}}$</span> is always hermitian.</p>
</blockquote>
<p>How is this definition of the Pauli group derived? Is there a similar way to define the Clifford group?</p>
",How is the definition of $n$-qubit Pauli group derived?,<pauli-gates>,0,4,,,"How is the definition of $n$-qubit Pauli group derived? <p>The authors give the following definition for the Pauli group in the paper <a href=""https://doi.org/10.48550/arXiv.2108.05803"" rel=""nofollow noreferrer"">Averaged circuit eigenvalue sampling</a>.</p>
<blockquote>
<p>The n-qubit Pauli group <span class=""math-container"">$P_n$</span> consists of n-fold tensor products of single-qubit Pauli operators labeled as follows. Let <span class=""math-container"">$\mathbf{a}$</span> be a 2n-bit string <span class=""math-container"">$\mathbf{a}=a_1a_2\ldots a_{2n}$</span> and write <span class=""math-container"">$P_\mathbf{a} = i^{\mathbf{a}^T \Upsilon \mathbf{a}} \prod_{j=1}^{n} X^{\mathbf{a}_{2j-1}}_j Z^{\mathbf{a}_{2j}}_j$</span>, where <span class=""math-container"">$X_j$</span> and <span class=""math-container"">$Z_j$</span> are single-qubit Paulis acting on qubit <span class=""math-container"">$j$</span> and <span class=""math-container"">$$\Upsilon=\bigoplus^n_{k=1}\begin{pmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{pmatrix}$$</span> is such that <span class=""math-container"">$P_{\mathbf{a}}$</span> is always hermitian.</p>
</blockquote>
<p>How is this definition of the Pauli group derived? Is there a similar way to define the Clifford group?</p>
",qc,definition n pauli group derived p authors give following definition pauli group paper https nofollow noreferrer averaged circuit eigenvalue sampling blockquote p pauli group span consists tensor products pauli operators labeled follows let span string span 2n write span n 2j span span paulis acting qubit span j span pmatrix 0 amp 1 0 amp 0 pmatrix span always p definition pauli group derived similar way define clifford group,"[(2, 0.050248563), (3, 0.75459635), (4, 0.05331333), (9, 0.049240984), (12, 0.014683392), (15, 0.075893275)]"
33087,,2023-06-21 14:08:25,0,163,"<p>I'm trying to debug a qiskit circuit that won't &quot;unroll.&quot; Looking at the source code, there are a log of logging calls but they aren't enabled. How can I enable logging in qiskit? Where is the log written?</p>
",How to enable qiskit logging? Where is the log file?,<qiskit>,1,1,,,"How to enable qiskit logging? Where is the log file? <p>I'm trying to debug a qiskit circuit that won't &quot;unroll.&quot; Looking at the source code, there are a log of logging calls but they aren't enabled. How can I enable logging in qiskit? Where is the log written?</p>
",qc,enable qiskit logging log file p trying debug qiskit circuit wo quot quot looking source code log logging calls enabled enable logging qiskit log written,"[(0, 0.26321647), (12, 0.045129005), (14, 0.36912814), (19, 0.3153073)]"
33121,33125.0,2023-06-23 15:40:58,0,364,"<p>It is possible to create an <a href=""https://github.com/quantumlib/Stim/blob/main/glue/zx/stimzx/_text_diagram_parsing.py"" rel=""nofollow noreferrer"">ASCII graph in Stimzx</a> for a ZX calculus diagram.
I would like to create something like this
<a href=""https://i.sstatic.net/eACno.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eACno.png"" alt=""XX parity measurement"" /></a></p>
<p>but I cannot seem to recreate the correct ASCII format. When I do something like this</p>
<pre><code>stimzx.text_diagram_to_zx_graph(&quot;&quot;&quot;
        in---X---out
              \
               Z(pi)
              /
        in---X---out
    &quot;&quot;&quot;)
</code></pre>
<p>I get complaints like</p>
<pre><code>KeyError                                  Traceback (most recent call last)
&lt;ipython-input-57-09740d1c5674&gt; in &lt;module&gt;
      5              /
      6        in---X---out
----&gt; 7    &quot;&quot;&quot;))

c:~\_zx_graph_solver.py in text_diagram_to_zx_graph(text_diagram)
     89             reading ordering from the diagram, and have a &quot;value&quot; attribute of type `stimzx.ZxType`.
     90     &quot;&quot;&quot;
---&gt; 91     return text_diagram_to_networkx_graph(text_diagram, value_func=ZX_TYPES.__getitem__)
     92 
     93 
</code></pre>
<p>My questions:</p>
<ol>
<li>What is incorrect in my ASCII syntax?</li>
<li>Is there an easier way to import ZX graphs e.g. is there any interoperability with the <a href=""https://pyzx.readthedocs.io/en/latest/representations.html"" rel=""nofollow noreferrer"">PyZX format</a>?</li>
</ol>
",Zx graphs in Stim,<stim><zx-calculus>,1,0,,,"Zx graphs in Stim <p>It is possible to create an <a href=""https://github.com/quantumlib/Stim/blob/main/glue/zx/stimzx/_text_diagram_parsing.py"" rel=""nofollow noreferrer"">ASCII graph in Stimzx</a> for a ZX calculus diagram.
I would like to create something like this
<a href=""https://i.sstatic.net/eACno.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eACno.png"" alt=""XX parity measurement"" /></a></p>
<p>but I cannot seem to recreate the correct ASCII format. When I do something like this</p>
<pre><code>stimzx.text_diagram_to_zx_graph(&quot;&quot;&quot;
        in---X---out
              \
               Z(pi)
              /
        in---X---out
    &quot;&quot;&quot;)
</code></pre>
<p>I get complaints like</p>
<pre><code>KeyError                                  Traceback (most recent call last)
&lt;ipython-input-57-09740d1c5674&gt; in &lt;module&gt;
      5              /
      6        in---X---out
----&gt; 7    &quot;&quot;&quot;))

c:~\_zx_graph_solver.py in text_diagram_to_zx_graph(text_diagram)
     89             reading ordering from the diagram, and have a &quot;value&quot; attribute of type `stimzx.ZxType`.
     90     &quot;&quot;&quot;
---&gt; 91     return text_diagram_to_networkx_graph(text_diagram, value_func=ZX_TYPES.__getitem__)
     92 
     93 
</code></pre>
<p>My questions:</p>
<ol>
<li>What is incorrect in my ASCII syntax?</li>
<li>Is there an easier way to import ZX graphs e.g. is there any interoperability with the <a href=""https://pyzx.readthedocs.io/en/latest/representations.html"" rel=""nofollow noreferrer"">PyZX format</a>?</li>
</ol>
",qc,zx graphs stim p possible create https nofollow noreferrer ascii graph stimzx zx calculus diagram would like create something like https nofollow noreferrer img https xx parity measurement p seem recreate correct ascii format something like pre code quot quot quot z pi quot quot quot p get complaints like pre code keyerror traceback recent call last lt gt lt module gt 5 6 gt 7 quot quot quot c 89 reading ordering diagram quot value quot attribute type 90 quot quot quot gt 91 return 92 93 p questions ol li incorrect ascii syntax li easier way import zx graphs interoperability https nofollow noreferrer pyzx format,"[(0, 0.25574812), (4, 0.18983962), (5, 0.052405715), (6, 0.039101988), (9, 0.10460266), (11, 0.03852614), (12, 0.034048766), (13, 0.10626623), (19, 0.17839405)]"
33215,,2023-06-29 08:06:51,2,325,"<p>I am currently working on a project wherein I have to implement a Quantum Convolutional Neural Network. The best options for NISQ devices are hybrid algorithms, so I will try integrating quantum layers into existing CNN architectures. The primary idea is to utilize either Quantum Filters as they do in Quanvolutional NNs or to utilize PQCs as Convolutional Layers.</p>
<p>Please provide a comparative analysis of these packages based on your experience. The primary factors to consider include integrability with Classical Models, availability of QML tools such as optimizers and different encoding schemes, and availability of simulators and circuit visualizers. Which package would serve best for this project?</p>
<p>I am currently quite familiar with TensorFlow and Qiskit but do not mind learning other languages. Additionally, I have written code for QML models however I have done that from scratch and not used existing packages.</p>
<p>Thanks! Any help is greatly appreciated.</p>
","Comparative analysis of TensorFlow-Quantum, Pennylane, and Qiskit, to implement quantum CNNs",<qiskit><machine-learning><pennylane>,1,3,,,"Comparative analysis of TensorFlow-Quantum, Pennylane, and Qiskit, to implement quantum CNNs <p>I am currently working on a project wherein I have to implement a Quantum Convolutional Neural Network. The best options for NISQ devices are hybrid algorithms, so I will try integrating quantum layers into existing CNN architectures. The primary idea is to utilize either Quantum Filters as they do in Quanvolutional NNs or to utilize PQCs as Convolutional Layers.</p>
<p>Please provide a comparative analysis of these packages based on your experience. The primary factors to consider include integrability with Classical Models, availability of QML tools such as optimizers and different encoding schemes, and availability of simulators and circuit visualizers. Which package would serve best for this project?</p>
<p>I am currently quite familiar with TensorFlow and Qiskit but do not mind learning other languages. Additionally, I have written code for QML models however I have done that from scratch and not used existing packages.</p>
<p>Thanks! Any help is greatly appreciated.</p>
",qc,comparative analysis pennylane qiskit implement quantum cnns p currently working project wherein implement quantum convolutional neural network best options nisq devices hybrid algorithms try integrating quantum layers existing cnn architectures primary idea utilize either quantum filters quanvolutional nns utilize pqcs convolutional p please provide comparative analysis packages based experience primary factors consider include integrability classical models availability qml tools optimizers different encoding schemes availability simulators circuit visualizers package would serve best project p currently quite familiar tensorflow qiskit mind learning languages additionally written code qml models however done scratch used existing p thanks help greatly,"[(5, 0.048477408), (8, 0.45361388), (10, 0.011996558), (12, 0.055777315), (14, 0.36662623), (19, 0.061936747)]"
33224,33231.0,2023-06-30 06:56:09,4,152,"<p>Recently, the oracle separation between BQP and PH has been <a href=""https://eccc.weizmann.ac.il/report/2018/107/"" rel=""nofollow noreferrer"">proven</a>. Does this result tell us something about the relation between BQP-complete problems (e.g. approximation Jones polynomial solved by <a href=""https://en.wikipedia.org/wiki/Aharonov%E2%80%93Jones%E2%80%93Landau_algorithm"" rel=""nofollow noreferrer"">AJL algorithm</a>) and BQP\PH? In particular, is the latter included in the former?</p>
",Relation between BQP-Complete and BQP \ PH,<complexity-theory><bqp>,2,0,,,"Relation between BQP-Complete and BQP \ PH <p>Recently, the oracle separation between BQP and PH has been <a href=""https://eccc.weizmann.ac.il/report/2018/107/"" rel=""nofollow noreferrer"">proven</a>. Does this result tell us something about the relation between BQP-complete problems (e.g. approximation Jones polynomial solved by <a href=""https://en.wikipedia.org/wiki/Aharonov%E2%80%93Jones%E2%80%93Landau_algorithm"" rel=""nofollow noreferrer"">AJL algorithm</a>) and BQP\PH? In particular, is the latter included in the former?</p>
",qc,relation bqp ph p recently oracle separation bqp ph https nofollow noreferrer proven result tell us something relation problems approximation jones polynomial solved https e2 80 93jones e2 80 nofollow noreferrer ajl algorithm particular latter included former,"[(0, 0.07928396), (1, 0.14512336), (4, 0.17976733), (7, 0.13799629), (8, 0.33636737), (12, 0.11747778)]"
33302,,2023-07-06 12:43:07,1,71,"<p>I created a Jupyter file around two years ago that relies on the following packages:</p>
<p><a href=""https://i.sstatic.net/JPqui.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JPqui.png"" alt=""enter image description here"" /></a></p>
<p>However, it seems that Google has discontinued support for TensorFlow Quantum on Windows. This poses a problem as my file contains an important project that I need to work on.</p>
<p>Is there any way to make the file compatible with Windows? I would greatly appreciate any advice or suggestions.</p>
",Compatibility of TensorFlow Quantum on Windows,<machine-learning>,0,1,,,"Compatibility of TensorFlow Quantum on Windows <p>I created a Jupyter file around two years ago that relies on the following packages:</p>
<p><a href=""https://i.sstatic.net/JPqui.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JPqui.png"" alt=""enter image description here"" /></a></p>
<p>However, it seems that Google has discontinued support for TensorFlow Quantum on Windows. This poses a problem as my file contains an important project that I need to work on.</p>
<p>Is there any way to make the file compatible with Windows? I would greatly appreciate any advice or suggestions.</p>
",qc,compatibility tensorflow quantum windows p created jupyter file around two years ago relies following packages p https nofollow noreferrer img https enter image description p however seems google discontinued support tensorflow quantum windows poses problem file contains important project need work p way make file compatible windows would greatly appreciate advice,"[(4, 0.25846702), (8, 0.43785843), (12, 0.018598955), (14, 0.23467757), (19, 0.04746165)]"
33310,33311.0,2023-07-07 05:46:42,0,106,"<p>I am studying the BB84 protocol and I think I have a slight misunderstanding. As far as I understand, if Bob measures the photon in the same basis as it was prepared by Alice, he is going to receive the exact bit Alice intended to send him without any randomness. If Alice and Bob have a basis mismatch, then bits received by Bob are going to be random.</p>
<p>Now consider this image I got from an article on the same subject at</p>
<blockquote>
<p><a href=""https://medium.com/quantum-untangled/quantum-key-distribution-and-bb84-protocol-6f03cc6263c5"" rel=""nofollow noreferrer"">Medium</a></p>
</blockquote>
<p><a href=""https://i.sstatic.net/cRf3I.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cRf3I.jpg"" alt=""Image"" /></a></p>
<p>Lets take the third bit 0. Here A prepares the photon in diagonal basis and Bob measures it in the same basis. Yet the bit Bob records is different from the one Alice sends. I do not understand how. I would really appreciate someone telling me where exactly I am misunderstanding the protocol.</p>
",Misunderstanding of QKD BB84 protocol,<bb84><qkd>,1,0,,,"Misunderstanding of QKD BB84 protocol <p>I am studying the BB84 protocol and I think I have a slight misunderstanding. As far as I understand, if Bob measures the photon in the same basis as it was prepared by Alice, he is going to receive the exact bit Alice intended to send him without any randomness. If Alice and Bob have a basis mismatch, then bits received by Bob are going to be random.</p>
<p>Now consider this image I got from an article on the same subject at</p>
<blockquote>
<p><a href=""https://medium.com/quantum-untangled/quantum-key-distribution-and-bb84-protocol-6f03cc6263c5"" rel=""nofollow noreferrer"">Medium</a></p>
</blockquote>
<p><a href=""https://i.sstatic.net/cRf3I.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cRf3I.jpg"" alt=""Image"" /></a></p>
<p>Lets take the third bit 0. Here A prepares the photon in diagonal basis and Bob measures it in the same basis. Yet the bit Bob records is different from the one Alice sends. I do not understand how. I would really appreciate someone telling me where exactly I am misunderstanding the protocol.</p>
",qc,misunderstanding qkd bb84 protocol p studying bb84 protocol think slight misunderstanding far understand bob measures photon basis prepared alice going receive exact bit alice intended send without randomness alice bob basis mismatch bits received bob going p consider image got article subject blockquote p https nofollow noreferrer medium p https nofollow noreferrer img https image p lets take third bit prepares photon diagonal basis bob measures basis yet bit bob records different one alice sends understand would really appreciate someone telling exactly misunderstanding,"[(0, 0.012216612), (4, 0.20330822), (8, 0.068999216), (9, 0.08251213), (12, 0.011966572), (13, 0.12176609), (14, 0.03740791), (18, 0.46037605)]"
33441,,2023-07-17 06:18:56,1,80,"<p>There are 2 primary approaches for Image recognition using Quantum Neural Networks: 1. Quanvolutional one and 2. Quantum Convolutional Neural Networks. The primary difference is that in 1 we don't train the network and in 2 we do. In 1 we use the idea of using Random Filters and try to sort of magnify different features of the images which would lead to a more trainable dataset and in 2 we train the said filters like we normally do with Convolutional layers.</p>
<p>So the primary thing in two cases is that in the first one, we simply choose a random point(let's say A) and in the second one we start with A and we define a measure of accuracy for the model, using said measure of accuracy and A as starting point we move towards a better point. So isn't approach 2 always bound to overcome approach 1?</p>
",Quanvolutional NN vs Quantum Convolution NN,<machine-learning><quantum-enhanced-machine-learning>,0,0,,,"Quanvolutional NN vs Quantum Convolution NN <p>There are 2 primary approaches for Image recognition using Quantum Neural Networks: 1. Quanvolutional one and 2. Quantum Convolutional Neural Networks. The primary difference is that in 1 we don't train the network and in 2 we do. In 1 we use the idea of using Random Filters and try to sort of magnify different features of the images which would lead to a more trainable dataset and in 2 we train the said filters like we normally do with Convolutional layers.</p>
<p>So the primary thing in two cases is that in the first one, we simply choose a random point(let's say A) and in the second one we start with A and we define a measure of accuracy for the model, using said measure of accuracy and A as starting point we move towards a better point. So isn't approach 2 always bound to overcome approach 1?</p>
",qc,quanvolutional nn vs quantum convolution nn p 2 primary approaches image recognition using quantum neural networks quanvolutional one quantum convolutional neural networks primary difference 1 train network 2 1 use idea using random filters try sort magnify different features images would lead trainable dataset 2 train said filters like normally convolutional p primary thing two cases first one simply choose random point let say second one start define measure accuracy model using said measure accuracy starting point move towards better point approach 2 always bound overcome approach 1,"[(2, 0.080180585), (3, 0.025018556), (4, 0.010830861), (8, 0.48679283), (12, 0.085867584), (13, 0.10193969), (14, 0.101675235), (15, 0.028452551), (18, 0.07796471)]"
33460,33464.0,2023-07-18 06:15:15,2,268,"<p>You may be familiar with &quot;Klein's inequality&quot;; one form of it is
<span class=""math-container"">$$
-\operatorname{tr}(\rho \log \sigma) + \operatorname{tr}(\rho \log \rho) \ge 0,
$$</span>
stating that relative entropy is nonnegative (where <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> are density matrices). There are various other versions of it - some which are equivalent, and some which go by the same name but are inequivalent / more general. A rather general one is
<span class=""math-container"">$$
\operatorname{tr}(f(A)-f(B)-(A-B)f'(B)) \ge 0
$$</span>
(<span class=""math-container"">$f$</span> convex, such as <span class=""math-container"">$f(t) = t \log t$</span>), which is what <a href=""https://en.wikipedia.org/wiki/Trace_inequality"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Trace_inequality</a> calls Klein's inequality. I'm curious about the origins of the Klein inequality (or perhaps I should say, inequalities, plural).</p>
<p>I see Nielsen and Chuang, for example, cite a paper, O. Klein, <em>Zur quantenmechanischen Begründung des zweiten Hauptsatzes der Wärmelehre</em>, Zeitschrift für Physik A 72 (1931), 767 – 775. However - and maybe I'm just bad at reading German or the notation - I don't think I actually recognize &quot;Klein's inequality&quot; in there.</p>
<p>Did Oskar Klein prove what's now called Klein's inequality? Or if he didn't, then who did, and when?</p>
",Is Klein's inequality due to Klein?,<density-matrix><information-theory><entropy><history>,1,0,,,"Is Klein's inequality due to Klein? <p>You may be familiar with &quot;Klein's inequality&quot;; one form of it is
<span class=""math-container"">$$
-\operatorname{tr}(\rho \log \sigma) + \operatorname{tr}(\rho \log \rho) \ge 0,
$$</span>
stating that relative entropy is nonnegative (where <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> are density matrices). There are various other versions of it - some which are equivalent, and some which go by the same name but are inequivalent / more general. A rather general one is
<span class=""math-container"">$$
\operatorname{tr}(f(A)-f(B)-(A-B)f'(B)) \ge 0
$$</span>
(<span class=""math-container"">$f$</span> convex, such as <span class=""math-container"">$f(t) = t \log t$</span>), which is what <a href=""https://en.wikipedia.org/wiki/Trace_inequality"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Trace_inequality</a> calls Klein's inequality. I'm curious about the origins of the Klein inequality (or perhaps I should say, inequalities, plural).</p>
<p>I see Nielsen and Chuang, for example, cite a paper, O. Klein, <em>Zur quantenmechanischen Begründung des zweiten Hauptsatzes der Wärmelehre</em>, Zeitschrift für Physik A 72 (1931), 767 – 775. However - and maybe I'm just bad at reading German or the notation - I don't think I actually recognize &quot;Klein's inequality&quot; in there.</p>
<p>Did Oskar Klein prove what's now called Klein's inequality? Or if he didn't, then who did, and when?</p>
",qc,klein inequality due klein p may familiar quot klein inequality quot one form span tr tr 0 stating relative entropy nonnegative span span density matrices various versions equivalent go name inequivalent general rather general one span tr f b f b 0 span f convex span f https nofollow noreferrer https calls klein inequality curious origins klein inequality perhaps say inequalities plural p see nielsen chuang example cite paper klein em zur quantenmechanischen begründung des zweiten hauptsatzes der wärmelehre zeitschrift für physik 72 1931 767 however maybe bad reading german notation think actually recognize quot klein inequality quot p oskar klein prove called klein inequality,"[(2, 0.027744394), (3, 0.5154309), (7, 0.018503953), (9, 0.27723762), (10, 0.050059665), (12, 0.011287337), (17, 0.014170819), (19, 0.084065326)]"
33467,33471.0,2023-07-18 13:07:42,0,42,"<p>I'm using <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> and <a href=""https://github.com/quantumlib/Stim/blob/81142ac2bf20a9a0a5b2edb6e81860cbe95844c9/glue/sample/README.md"" rel=""nofollow noreferrer"">sinter</a> and can't figure out how to pass multiple arguments to <code>sinter plot --filter_func</code>. A single argument works as</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot;</code>.</p>
<p>I've tried passing multiple arguments a few different ways, e.g.</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; &quot;metadata['b']=='x'&quot;</code></p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; --filter_func &quot;metadata['b']=='x'&quot;</code></p>
<p>But can't get it to work so I'm wondering how.</p>
<p>My whole process is: first I use the terminal to collect some statistics on different distance surface codes using stim and sinter:</p>
<pre><code>mkdir circuits;
python3 -c &quot;
import stim

for p in [0.002]:
    for d in [3, 5, 7, 9]:
      for b in 'xz':
        with open(f'circuits/d={d},p={p},b={b}.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_{b}')
            print(c, file=f)
&quot;;

sinter collect \
    --processes 4  \
    --circuits circuits/*.stim \
    --metadata_func &quot;auto&quot; \
    --decoders pymatching \
    --max_shots 100_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<p>And then I plot it using <code>sinter plot</code>. I could specify that I only want to plot up to distance 7 even though I collected data up to distance 9 using     <code>--filter_func &quot;metadata['d']&lt;8&quot; </code></p>
<pre><code>sinter plot  \
    --in  stats.csv \
    --group_func &quot;f'''p={metadata['p']} b={metadata['b']}'''&quot;\
    --x_func &quot;metadata['d']&quot;  \
    --xaxis &quot;Distance&quot; \
    --filter_func &quot;metadata['d']&lt;8&quot; \
    --show \
    --out plot.png
</code></pre>
<p>Which gives this plot:
<a href=""https://i.sstatic.net/wxXJc.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wxXJc.png"" alt=""enter image description here"" /></a></p>
<p>However I don't know how to specify two filters, like only plotting up to distance 7 and only plotting the b=x line.</p>
",How to pass multiple arguments to sinter plot --filter_func?,<stim>,1,0,,,"How to pass multiple arguments to sinter plot --filter_func? <p>I'm using <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> and <a href=""https://github.com/quantumlib/Stim/blob/81142ac2bf20a9a0a5b2edb6e81860cbe95844c9/glue/sample/README.md"" rel=""nofollow noreferrer"">sinter</a> and can't figure out how to pass multiple arguments to <code>sinter plot --filter_func</code>. A single argument works as</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot;</code>.</p>
<p>I've tried passing multiple arguments a few different ways, e.g.</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; &quot;metadata['b']=='x'&quot;</code></p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; --filter_func &quot;metadata['b']=='x'&quot;</code></p>
<p>But can't get it to work so I'm wondering how.</p>
<p>My whole process is: first I use the terminal to collect some statistics on different distance surface codes using stim and sinter:</p>
<pre><code>mkdir circuits;
python3 -c &quot;
import stim

for p in [0.002]:
    for d in [3, 5, 7, 9]:
      for b in 'xz':
        with open(f'circuits/d={d},p={p},b={b}.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_{b}')
            print(c, file=f)
&quot;;

sinter collect \
    --processes 4  \
    --circuits circuits/*.stim \
    --metadata_func &quot;auto&quot; \
    --decoders pymatching \
    --max_shots 100_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<p>And then I plot it using <code>sinter plot</code>. I could specify that I only want to plot up to distance 7 even though I collected data up to distance 9 using     <code>--filter_func &quot;metadata['d']&lt;8&quot; </code></p>
<pre><code>sinter plot  \
    --in  stats.csv \
    --group_func &quot;f'''p={metadata['p']} b={metadata['b']}'''&quot;\
    --x_func &quot;metadata['d']&quot;  \
    --xaxis &quot;Distance&quot; \
    --filter_func &quot;metadata['d']&lt;8&quot; \
    --show \
    --out plot.png
</code></pre>
<p>Which gives this plot:
<a href=""https://i.sstatic.net/wxXJc.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wxXJc.png"" alt=""enter image description here"" /></a></p>
<p>However I don't know how to specify two filters, like only plotting up to distance 7 and only plotting the b=x line.</p>
",qc,pass multiple arguments sinter plot p using https nofollow noreferrer stim https nofollow noreferrer sinter ca figure pass multiple arguments code sinter plot single argument works p code quot metadata lt 8 quot p tried passing multiple arguments different ways p code quot metadata lt 8 quot quot metadata b x quot p code quot metadata lt 8 quot quot metadata b x quot p ca get work wondering p whole process first use terminal collect statistics different distance surface codes using stim sinter pre code mkdir circuits python3 quot import stim p 3 5 7 9 b open p b w f c b print c quot sinter collect processes 4 circuits quot auto quot decoders pymatching 1000 p plot using code sinter plot could specify want plot distance 7 even though collected data distance 9 using code quot metadata lt 8 quot pre code sinter plot quot f metadata p metadata b quot quot metadata quot xaxis quot distance quot quot metadata lt 8 quot show p gives plot https nofollow noreferrer img https enter image description p however know specify two filters like plotting distance 7 plotting,"[(0, 0.11774067), (4, 0.19800736), (5, 0.071948946), (6, 0.126883), (10, 0.023131205), (12, 0.0106618935), (14, 0.20321003), (17, 0.040771544), (19, 0.20706055)]"
33535,,2023-07-22 14:52:14,1,156,"<p>I am trying to simulate color code on STIM. I have provided my code below. But I am getting the following error</p>
<pre><code>Traceback (most recent call last)
ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D9, D18, D27'.
</code></pre>
<p>My code:</p>
<pre><code>color_code_tasks = [
    sinter.Task(
        circuit = stim.Circuit.generated(
            &quot;color_code:memory_xyz&quot;,
            rounds=10,
            distance=9,
            before_round_data_depolarization=1e-2,
        ),
    )
]

collected_color_code_stats: List[sinter.TaskStats] = sinter.collect(
    num_workers=4,
    tasks=surface_code_tasks,
    decoders=['pymatching'],
    max_shots=10000,
    max_errors=500,
    print_progress=True,
)
</code></pre>
<p>I tried to ignore this error by passing <code>ignore_decomposition_failures=True</code> to <code>stim.Circuit.detector_error_model(...)</code>. Here is my modified code:</p>
<pre><code>custom_dem = circuit.detector_error_model(
    decompose_errors=True,
    ignore_decomposition_failures=True,
)

color_code_tasks = [
    sinter.Task(
        circuit = stim.Circuit.generated(
            &quot;color_code:memory_xyz&quot;,
            rounds=10,
            distance=9,
            before_round_data_depolarization=1e-2,
        ),
        detector_error_model=custom_dem,
    )
]

collected_color_code_stats: List[sinter.TaskStats] = sinter.collect(
    num_workers=4,
    tasks=surface_code_tasks,
    decoders=['pymatching'],
    max_shots=10000,
    max_errors=500,
    print_progress=True,
)
</code></pre>
<p>But this time I am getting another <code>ValueError: circuit.num_detectors=300 != detector_error_model.num_detectors=132</code></p>
<p>How can I solve this issue?</p>
",How to run Color code on STIM?,<error-correction><stabilizer-code><noise><stim><surface-code>,1,0,,,"How to run Color code on STIM? <p>I am trying to simulate color code on STIM. I have provided my code below. But I am getting the following error</p>
<pre><code>Traceback (most recent call last)
ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D9, D18, D27'.
</code></pre>
<p>My code:</p>
<pre><code>color_code_tasks = [
    sinter.Task(
        circuit = stim.Circuit.generated(
            &quot;color_code:memory_xyz&quot;,
            rounds=10,
            distance=9,
            before_round_data_depolarization=1e-2,
        ),
    )
]

collected_color_code_stats: List[sinter.TaskStats] = sinter.collect(
    num_workers=4,
    tasks=surface_code_tasks,
    decoders=['pymatching'],
    max_shots=10000,
    max_errors=500,
    print_progress=True,
)
</code></pre>
<p>I tried to ignore this error by passing <code>ignore_decomposition_failures=True</code> to <code>stim.Circuit.detector_error_model(...)</code>. Here is my modified code:</p>
<pre><code>custom_dem = circuit.detector_error_model(
    decompose_errors=True,
    ignore_decomposition_failures=True,
)

color_code_tasks = [
    sinter.Task(
        circuit = stim.Circuit.generated(
            &quot;color_code:memory_xyz&quot;,
            rounds=10,
            distance=9,
            before_round_data_depolarization=1e-2,
        ),
        detector_error_model=custom_dem,
    )
]

collected_color_code_stats: List[sinter.TaskStats] = sinter.collect(
    num_workers=4,
    tasks=surface_code_tasks,
    decoders=['pymatching'],
    max_shots=10000,
    max_errors=500,
    print_progress=True,
)
</code></pre>
<p>But this time I am getting another <code>ValueError: circuit.num_detectors=300 != detector_error_model.num_detectors=132</code></p>
<p>How can I solve this issue?</p>
",qc,run color code stim p trying simulate color code stim provided code getting following error pre code traceback recent call last valueerror failed decompose errors graphlike components two symptoms error component failed decompose d18 d27 p code pre code circuit quot quot list p tried ignore error passing code code modified code pre code circuit quot quot list p time getting another code valueerror p solve issue,"[(0, 0.29837438), (5, 0.17777848), (12, 0.015032685), (14, 0.34765318), (19, 0.15885863)]"
33598,,2023-07-28 02:41:10,1,1480,"<p>I have coded this from a tutorial:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram
import cirq

m_simulator = Aer.backends(name=&quot;Quantum_Simulation&quot;)
qreg = QuantumRegister(2)
creg = ClassicalRegister(2)
entangler = QuantumCircuit(qreg, creg)
entangler.h(0)
entangler.cx(0, 1)
entangler.measure(0, 0)
entangler.measure(1, 1)
entangler.draw(output=&quot;mpl&quot;)
</code></pre>
<p>For some reason, <code>entangler.draw(output=&quot;mpl&quot;)</code> is not working. If someone can let me know why, that would be greatly appreciated. The link I am using is: <a href=""https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e"" rel=""nofollow noreferrer"">https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e</a></p>
",Quantum Circuit not drawing?,<qiskit><programming><quantum-circuit>,3,0,,,"Quantum Circuit not drawing? <p>I have coded this from a tutorial:</p>
<pre><code>from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram
import cirq

m_simulator = Aer.backends(name=&quot;Quantum_Simulation&quot;)
qreg = QuantumRegister(2)
creg = ClassicalRegister(2)
entangler = QuantumCircuit(qreg, creg)
entangler.h(0)
entangler.cx(0, 1)
entangler.measure(0, 0)
entangler.measure(1, 1)
entangler.draw(output=&quot;mpl&quot;)
</code></pre>
<p>For some reason, <code>entangler.draw(output=&quot;mpl&quot;)</code> is not working. If someone can let me know why, that would be greatly appreciated. The link I am using is: <a href=""https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e"" rel=""nofollow noreferrer"">https://towardsdatascience.com/what-is-quantum-entanglement-anyway-4ea97df4bb0e</a></p>
",qc,quantum circuit drawing p coded tutorial pre code qiskit import quantumregister classicalregister quantumcircuit aer execute import import cirq quot quot qreg quantumregister 2 creg classicalregister 2 entangler quantumcircuit qreg creg 0 0 1 0 0 1 1 quot mpl quot p reason code quot mpl quot working someone let know would greatly appreciated link using https nofollow noreferrer https,"[(0, 0.3995569), (2, 0.24435814), (4, 0.19657947), (12, 0.01723738), (16, 0.037750263), (19, 0.102111146)]"
33599,33656.0,2023-07-28 03:22:54,0,276,"<p>Hey Quantum Computing community,</p>
<p>I cannot get TensorFlow Quantum to work even though I am using</p>
<p><code>pip install tensorflow-quantum</code></p>
<p>I have TensorFlow already on Visual Studio Code, and I know it is a prerequisite for being able to download TensorFlow Quantum. I even tried going down a level of TensorFlow (I think it is called downgrading), but unfortunately, my Visual Studio Code terminal does not recognize it.</p>
<p>Thank You!</p>
<p>Update: Including image down below:<a href=""https://i.sstatic.net/8QIyM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8QIyM.png"" alt=""What I tried doing"" /></a></p>
",Cannot Download TensorFlow Quantum,<programming><tfq>,2,3,,,"Cannot Download TensorFlow Quantum <p>Hey Quantum Computing community,</p>
<p>I cannot get TensorFlow Quantum to work even though I am using</p>
<p><code>pip install tensorflow-quantum</code></p>
<p>I have TensorFlow already on Visual Studio Code, and I know it is a prerequisite for being able to download TensorFlow Quantum. I even tried going down a level of TensorFlow (I think it is called downgrading), but unfortunately, my Visual Studio Code terminal does not recognize it.</p>
<p>Thank You!</p>
<p>Update: Including image down below:<a href=""https://i.sstatic.net/8QIyM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/8QIyM.png"" alt=""What I tried doing"" /></a></p>
",qc,download tensorflow quantum p hey quantum computing community p get tensorflow quantum work even though using p code pip install p tensorflow already visual studio code know prerequisite able download tensorflow quantum even tried going level tensorflow think called downgrading unfortunately visual studio code terminal recognize p thank p update including image https nofollow noreferrer img https tried,"[(0, 0.100992784), (4, 0.19672541), (7, 0.050436094), (8, 0.43016002), (12, 0.09494004), (14, 0.08651167), (16, 0.037877746)]"
33624,,2023-07-30 12:15:34,2,146,"<p><a href=""https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem"" rel=""nofollow noreferrer"">The Solovay-Kitaev theorem</a> shows that &quot;this approximation can be made surprisingly efficient, thereby justifying that quantum computers need only implement a finite number of gates to gain the full power of quantum computation&quot;.</p>
<p>For a given unitary matrix quantum circuit <span class=""math-container"">$V$</span>, how to decompose it into a series of shortest possible elementary quantum gates is a fundamental problem in quantum information processing tasks such as quantum computing and quantum simulation. Currently available methods include machine learning, circuit structure search, Solovay-Kitaev algorithm, and so on.</p>
<p> 
 
 </p>
<p>My question is:</p>
<p>Is there programming projects that implement the decomposisiton? <strong>Which is the most practical one?</strong></p>
<p>I have found some Python modules/classes that would be helpful: e.g.</p>
<ul>
<li><p><a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.TwoQubitBasisDecomposer.html"" rel=""nofollow noreferrer""><code>qiskit.quantum_info.synthesis.TwoQubitBasisDecomposer</code></a>,</p>
</li>
<li><p><a href=""https://openql.readthedocs.io/en/latest/"" rel=""nofollow noreferrer""><code>openql</code></a></p>
</li>
<li><p><a href=""https://cqcl.github.io/tket/pytket/api/index.html"" rel=""nofollow noreferrer""><code>pytket</code></a></p>
</li>
</ul>
<p>But I'm not very familiar with <a href=""https://en.wikipedia.org/wiki/Quantum_programming"" rel=""nofollow noreferrer"">these Quantum Programming Tools</a>, <a href=""https://www.qtumist.com/open-quantum-projects"" rel=""nofollow noreferrer"">Quantum Programming Tools(Chinese article)</a></p>
<p>More recommendation? Any help would be appreciated.</p>
",Seeking Programming Projects and Tools for Quantum Gate Decomposition Implementations,<quantum-gate><quantum-algorithms><solovay-kitaev-algorithm>,3,1,,,"Seeking Programming Projects and Tools for Quantum Gate Decomposition Implementations <p><a href=""https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem"" rel=""nofollow noreferrer"">The Solovay-Kitaev theorem</a> shows that &quot;this approximation can be made surprisingly efficient, thereby justifying that quantum computers need only implement a finite number of gates to gain the full power of quantum computation&quot;.</p>
<p>For a given unitary matrix quantum circuit <span class=""math-container"">$V$</span>, how to decompose it into a series of shortest possible elementary quantum gates is a fundamental problem in quantum information processing tasks such as quantum computing and quantum simulation. Currently available methods include machine learning, circuit structure search, Solovay-Kitaev algorithm, and so on.</p>
<p> 
 
 </p>
<p>My question is:</p>
<p>Is there programming projects that implement the decomposisiton? <strong>Which is the most practical one?</strong></p>
<p>I have found some Python modules/classes that would be helpful: e.g.</p>
<ul>
<li><p><a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.TwoQubitBasisDecomposer.html"" rel=""nofollow noreferrer""><code>qiskit.quantum_info.synthesis.TwoQubitBasisDecomposer</code></a>,</p>
</li>
<li><p><a href=""https://openql.readthedocs.io/en/latest/"" rel=""nofollow noreferrer""><code>openql</code></a></p>
</li>
<li><p><a href=""https://cqcl.github.io/tket/pytket/api/index.html"" rel=""nofollow noreferrer""><code>pytket</code></a></p>
</li>
</ul>
<p>But I'm not very familiar with <a href=""https://en.wikipedia.org/wiki/Quantum_programming"" rel=""nofollow noreferrer"">these Quantum Programming Tools</a>, <a href=""https://www.qtumist.com/open-quantum-projects"" rel=""nofollow noreferrer"">Quantum Programming Tools(Chinese article)</a></p>
<p>More recommendation? Any help would be appreciated.</p>
",qc,seeking programming projects tools quantum gate decomposition implementations p https e2 80 nofollow noreferrer theorem shows quot approximation made surprisingly efficient thereby justifying quantum computers need implement finite number gates gain full power quantum computation quot p given unitary matrix quantum circuit span v decompose series shortest possible elementary quantum gates fundamental problem quantum information processing tasks quantum computing quantum simulation currently available methods include machine learning circuit structure search algorithm p p question p programming projects implement decomposisiton strong practical one p found python would helpful ul li p https nofollow noreferrer code li p https nofollow noreferrer code openql li p https nofollow noreferrer code pytket p familiar https nofollow noreferrer quantum programming tools https nofollow noreferrer quantum programming tools chinese article p recommendation help would,"[(1, 0.08770265), (3, 0.026878087), (4, 0.2270178), (7, 0.055730067), (8, 0.33012232), (9, 0.116257705), (12, 0.016464802), (13, 0.038365196), (14, 0.07860215), (19, 0.01652231)]"
33698,33705.0,2023-08-06 09:38:14,3,179,"<p><a href=""https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm"" rel=""nofollow noreferrer"">Wikipedia article about Deutsch-Jozsa algorithm</a> says, under the section Algorithm, that:</p>
<blockquote>
<p>At this point the last qubit, <span class=""math-container"">$$\frac{|0\rangle - |1\rangle}{\sqrt{2}}$$</span> may be ignored.</p>
</blockquote>
<p>Does it mean that, if we can factor (written in terms of tensor product) out some bits, not involving the oracle function <span class=""math-container"">$U_f$</span>, then we can always ignore when doing measurements, because it doesn't change the probability of the states?</p>
<p><a href=""https://i.sstatic.net/TMb07.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/TMb07.png"" alt=""enter image description here"" /></a></p>
","In Deutsch–Jozsa algorithm, why one can safely ignore the last qubit of oracle output?",<quantum-state><quantum-algorithms><deutsch-jozsa-algorithm>,2,2,,,"In Deutsch–Jozsa algorithm, why one can safely ignore the last qubit of oracle output? <p><a href=""https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm"" rel=""nofollow noreferrer"">Wikipedia article about Deutsch-Jozsa algorithm</a> says, under the section Algorithm, that:</p>
<blockquote>
<p>At this point the last qubit, <span class=""math-container"">$$\frac{|0\rangle - |1\rangle}{\sqrt{2}}$$</span> may be ignored.</p>
</blockquote>
<p>Does it mean that, if we can factor (written in terms of tensor product) out some bits, not involving the oracle function <span class=""math-container"">$U_f$</span>, then we can always ignore when doing measurements, because it doesn't change the probability of the states?</p>
<p><a href=""https://i.sstatic.net/TMb07.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/TMb07.png"" alt=""enter image description here"" /></a></p>
",qc,algorithm one safely ignore last qubit oracle output p https e2 80 nofollow noreferrer wikipedia article algorithm says section algorithm blockquote p point last qubit span 2 may p mean factor written terms tensor product bits involving oracle function span always ignore measurements change probability states p https nofollow noreferrer img https enter image description,"[(3, 0.10808237), (4, 0.3740167), (9, 0.10728583), (10, 0.10596662), (12, 0.03721919), (18, 0.2648913)]"
33707,,2023-08-06 20:41:58,2,224,"<p>I am trying to run VQE algorithm with Qiskit, using the following code:</p>
<pre><code>from qiskit.primitives import Estimator
from scipy import optimize
import numpy as np

def optimize_angles_ma_qiskit(graph: Graph, p: int) -&gt; float:
    estimator = Estimator()
    ansatz = get_ma_ansatz(graph, p)  # composes some parameterized QuantumCircuit
    optimizer = optimize.minimize
    initial_point = np.ones((ansatz.num_parameters,)) * np.pi / 8
    vqe = VQE(estimator, ansatz, optimizer, initial_point=initial_point)
    maxcut_hamiltonian = get_observable_maxcut(graph)  # returns SparsePauliOp representing target Hamiltonian
    result = vqe.compute_minimum_eigenvalue(-maxcut_hamiltonian)
    return -result.eigenvalue.real
</code></pre>
<p>The code was taking surprisingly long time to run, so I profiled it with <code>cProfile</code>, and I saw that &gt;80% of running time is spent on <code>~:0(&lt;method 'acquire' of '_thread.lock' objects&gt;)</code>, which seems to originate from within qiskit (I do not have any parallelization on my side of the code). Does anyone know if there is a setting to turn off internal parallelization or anything else I could do to make it spend less time on this?
<a href=""https://i.sstatic.net/7va0A.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7va0A.png"" alt=""profiler result"" /></a></p>
",Qiskit spends a lot of time on method acquire of thread.lock objects,<qiskit><programming>,1,0,,,"Qiskit spends a lot of time on method acquire of thread.lock objects <p>I am trying to run VQE algorithm with Qiskit, using the following code:</p>
<pre><code>from qiskit.primitives import Estimator
from scipy import optimize
import numpy as np

def optimize_angles_ma_qiskit(graph: Graph, p: int) -&gt; float:
    estimator = Estimator()
    ansatz = get_ma_ansatz(graph, p)  # composes some parameterized QuantumCircuit
    optimizer = optimize.minimize
    initial_point = np.ones((ansatz.num_parameters,)) * np.pi / 8
    vqe = VQE(estimator, ansatz, optimizer, initial_point=initial_point)
    maxcut_hamiltonian = get_observable_maxcut(graph)  # returns SparsePauliOp representing target Hamiltonian
    result = vqe.compute_minimum_eigenvalue(-maxcut_hamiltonian)
    return -result.eigenvalue.real
</code></pre>
<p>The code was taking surprisingly long time to run, so I profiled it with <code>cProfile</code>, and I saw that &gt;80% of running time is spent on <code>~:0(&lt;method 'acquire' of '_thread.lock' objects&gt;)</code>, which seems to originate from within qiskit (I do not have any parallelization on my side of the code). Does anyone know if there is a setting to turn off internal parallelization or anything else I could do to make it spend less time on this?
<a href=""https://i.sstatic.net/7va0A.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7va0A.png"" alt=""profiler result"" /></a></p>
",qc,qiskit spends lot time method acquire objects p trying run vqe algorithm qiskit using following code pre code import estimator scipy import optimize import numpy np def graph graph p int gt float estimator estimator ansatz graph p composes parameterized quantumcircuit optimizer 8 vqe vqe estimator ansatz optimizer graph returns sparsepauliop representing target hamiltonian result return p code taking surprisingly long time run profiled code cprofile saw gt 80 running time spent code lt method objects gt seems originate within qiskit parallelization side code anyone know setting turn internal parallelization anything else could make spend less time https nofollow noreferrer img https profiler result,"[(0, 0.5369167), (4, 0.061609097), (8, 0.042969964), (12, 0.010552976), (13, 0.09437783), (14, 0.25213245)]"
33732,,2023-08-08 19:48:31,3,273,"<p>We're trying to simulate erasure errors on the surface code using Stim. The threshold for erasure errors on the data qubits (after initialization) is 50%.</p>
<p>We followed the following post: <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a></p>
<p>However, we end up with a threshold of ~20%. This is the same as this post: <a href=""https://quantumcomputing.stackexchange.com/questions/30074/threshold-value-when-simulating-erasures-with-stim?noredirect=1&amp;lq=1"">Threshold value when simulating erasures with stim</a></p>
<p>That post did not get an answer and so we bring it up again here.</p>
<hr />
<p>This is our circuit for the unrotated <span class=""math-container"">$d=3$</span> surface code</p>
<pre><code>RX 0 2 4 10 12 14 20 22 24 6 8 16 18 1 3 5 7 9 11 13 15 17 19 21 23
TICK
R 999
E(0.025) X999
E(0.025) X0 X999
E(0.025) Y0 X999
E(0.025) Z0 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X2 X999
E(0.025) Y2 X999
E(0.025) Z2 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X4 X999
E(0.025) Y4 X999
E(0.025) Z4 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X10 X999
E(0.025) Y10 X999
E(0.025) Z10 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X12 X999
E(0.025) Y12 X999
E(0.025) Z12 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X14 X999
E(0.025) Y14 X999
E(0.025) Z14 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X20 X999
E(0.025) Y20 X999
E(0.025) Z20 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X22 X999
E(0.025) Y22 X999
E(0.025) Z22 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X24 X999
E(0.025) Y24 X999
E(0.025) Z24 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X6 X999
E(0.025) Y6 X999
E(0.025) Z6 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X8 X999
E(0.025) Y8 X999
E(0.025) Z8 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X16 X999
E(0.025) Y16 X999
E(0.025) Z16 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X18 X999
E(0.025) Y18 X999
E(0.025) Z18 X999
M 999
DETECTOR rec[-1]
CZ 6 1 8 3 16 11 18 13
CX 5 10 7 12 9 14 15 20 17 22 19 24
TICK
CZ 2 1 4 3 12 11 14 13 22 21 24 23
CX 5 6 7 8 15 16 17 18
TICK
CZ 0 1 2 3 10 11 12 13 20 21 22 23
CX 7 6 9 8 17 16 19 18
TICK
CZ 6 11 8 13 16 21 18 23
CX 5 0 7 2 9 4 15 10 17 12 19 14
TICK
MRX 1 3 5 7 9 11 13 15 17 19 21 23
DETECTOR rec[-10]
DETECTOR rec[-9]
DETECTOR rec[-8]
DETECTOR rec[-5]
DETECTOR rec[-4]
DETECTOR rec[-3]
REPEAT 2 {
    TICK
    CZ 6 1 8 3 16 11 18 13
    CX 5 10 7 12 9 14 15 20 17 22 19 24
    TICK
    CZ 2 1 4 3 12 11 14 13 22 21 24 23
    CX 5 6 7 8 15 16 17 18
    TICK
    CZ 0 1 2 3 10 11 12 13 20 21 22 23
    CX 7 6 9 8 17 16 19 18
    TICK
    CZ 6 11 8 13 16 21 18 23
    CX 5 0 7 2 9 4 15 10 17 12 19 14
    TICK
    MRX 1 3 5 7 9 11 13 15 17 19 21 23
    DETECTOR rec[-1] rec[-53]
    DETECTOR rec[-2] rec[-54]
    DETECTOR rec[-3] rec[-55]
    DETECTOR rec[-4] rec[-56]
    DETECTOR rec[-5] rec[-57]
    DETECTOR rec[-6] rec[-58]
    DETECTOR rec[-7] rec[-59]
    DETECTOR rec[-8] rec[-60]
    DETECTOR rec[-9] rec[-61]
    DETECTOR rec[-10] rec[-62]
    DETECTOR rec[-11] rec[-63]
    DETECTOR rec[-12] rec[-64]
}
MX 0 2 4 6 8 10 12 14 16 18 20 22 24
DETECTOR rec[-23] rec[-8] rec[-10] rec[-13]
DETECTOR rec[-22] rec[-7] rec[-9] rec[-10] rec[-12]
DETECTOR rec[-21] rec[-6] rec[-9] rec[-11]
DETECTOR rec[-18] rec[-3] rec[-5] rec[-8]
DETECTOR rec[-17] rec[-2] rec[-4] rec[-5] rec[-7]
DETECTOR rec[-16] rec[-1] rec[-4] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-13] rec[-12] rec[-11]
</code></pre>
<hr />
<p>Note: If we simulate our codes under pauli data noise we recover the expected thresholds so the error is not in the circuit for the codes but instead in the way we are handling erasures.</p>
<hr />
<h2>Decoding</h2>
<p>Decoding is done using Sinter to call PyMatching, as shown in the Stim tutorial. We passed 2 new flags to the detector error model: <code>approximate_disjoint_errors=True</code> and <code>ignore_decomposition_failures=True</code>. See the code below.</p>
<pre><code>import stim
import numpy as np
import pymatching
import sinter


def count_logical_errors(circuit: stim.Circuit, num_shots: int) -&gt; int:
    # Sample the circuit.
    sampler = circuit.compile_detector_sampler()
    detection_events, observable_flips = sampler.sample(num_shots, separate_observables=True)

    # Extract decoder configuration data from the circuit.
    detector_error_model = circuit.detector_error_model(decompose_errors=True,
                                                        approximate_disjoint_errors=True,
                                                        ignore_decomposition_failures=True)
    # Run the decoder.
    predictions = sinter.predict_observables(
        dem=detector_error_model,
        dets=detection_events,
        decoder='pymatching',
    )
    # Count the mistakes.
    num_errors = 0
    for actual_flip, predicted_flip in zip(observable_flips, predictions):
        if not np.array_equal(actual_flip, predicted_flip):
            num_errors += 1
    return num_errors
<span class=""math-container"">```</span>
</code></pre>
",Simulating erasures with stim,<stim><error-correction>,1,7,,,"Simulating erasures with stim <p>We're trying to simulate erasure errors on the surface code using Stim. The threshold for erasure errors on the data qubits (after initialization) is 50%.</p>
<p>We followed the following post: <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a></p>
<p>However, we end up with a threshold of ~20%. This is the same as this post: <a href=""https://quantumcomputing.stackexchange.com/questions/30074/threshold-value-when-simulating-erasures-with-stim?noredirect=1&amp;lq=1"">Threshold value when simulating erasures with stim</a></p>
<p>That post did not get an answer and so we bring it up again here.</p>
<hr />
<p>This is our circuit for the unrotated <span class=""math-container"">$d=3$</span> surface code</p>
<pre><code>RX 0 2 4 10 12 14 20 22 24 6 8 16 18 1 3 5 7 9 11 13 15 17 19 21 23
TICK
R 999
E(0.025) X999
E(0.025) X0 X999
E(0.025) Y0 X999
E(0.025) Z0 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X2 X999
E(0.025) Y2 X999
E(0.025) Z2 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X4 X999
E(0.025) Y4 X999
E(0.025) Z4 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X10 X999
E(0.025) Y10 X999
E(0.025) Z10 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X12 X999
E(0.025) Y12 X999
E(0.025) Z12 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X14 X999
E(0.025) Y14 X999
E(0.025) Z14 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X20 X999
E(0.025) Y20 X999
E(0.025) Z20 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X22 X999
E(0.025) Y22 X999
E(0.025) Z22 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X24 X999
E(0.025) Y24 X999
E(0.025) Z24 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X6 X999
E(0.025) Y6 X999
E(0.025) Z6 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X8 X999
E(0.025) Y8 X999
E(0.025) Z8 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X16 X999
E(0.025) Y16 X999
E(0.025) Z16 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X18 X999
E(0.025) Y18 X999
E(0.025) Z18 X999
M 999
DETECTOR rec[-1]
CZ 6 1 8 3 16 11 18 13
CX 5 10 7 12 9 14 15 20 17 22 19 24
TICK
CZ 2 1 4 3 12 11 14 13 22 21 24 23
CX 5 6 7 8 15 16 17 18
TICK
CZ 0 1 2 3 10 11 12 13 20 21 22 23
CX 7 6 9 8 17 16 19 18
TICK
CZ 6 11 8 13 16 21 18 23
CX 5 0 7 2 9 4 15 10 17 12 19 14
TICK
MRX 1 3 5 7 9 11 13 15 17 19 21 23
DETECTOR rec[-10]
DETECTOR rec[-9]
DETECTOR rec[-8]
DETECTOR rec[-5]
DETECTOR rec[-4]
DETECTOR rec[-3]
REPEAT 2 {
    TICK
    CZ 6 1 8 3 16 11 18 13
    CX 5 10 7 12 9 14 15 20 17 22 19 24
    TICK
    CZ 2 1 4 3 12 11 14 13 22 21 24 23
    CX 5 6 7 8 15 16 17 18
    TICK
    CZ 0 1 2 3 10 11 12 13 20 21 22 23
    CX 7 6 9 8 17 16 19 18
    TICK
    CZ 6 11 8 13 16 21 18 23
    CX 5 0 7 2 9 4 15 10 17 12 19 14
    TICK
    MRX 1 3 5 7 9 11 13 15 17 19 21 23
    DETECTOR rec[-1] rec[-53]
    DETECTOR rec[-2] rec[-54]
    DETECTOR rec[-3] rec[-55]
    DETECTOR rec[-4] rec[-56]
    DETECTOR rec[-5] rec[-57]
    DETECTOR rec[-6] rec[-58]
    DETECTOR rec[-7] rec[-59]
    DETECTOR rec[-8] rec[-60]
    DETECTOR rec[-9] rec[-61]
    DETECTOR rec[-10] rec[-62]
    DETECTOR rec[-11] rec[-63]
    DETECTOR rec[-12] rec[-64]
}
MX 0 2 4 6 8 10 12 14 16 18 20 22 24
DETECTOR rec[-23] rec[-8] rec[-10] rec[-13]
DETECTOR rec[-22] rec[-7] rec[-9] rec[-10] rec[-12]
DETECTOR rec[-21] rec[-6] rec[-9] rec[-11]
DETECTOR rec[-18] rec[-3] rec[-5] rec[-8]
DETECTOR rec[-17] rec[-2] rec[-4] rec[-5] rec[-7]
DETECTOR rec[-16] rec[-1] rec[-4] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-13] rec[-12] rec[-11]
</code></pre>
<hr />
<p>Note: If we simulate our codes under pauli data noise we recover the expected thresholds so the error is not in the circuit for the codes but instead in the way we are handling erasures.</p>
<hr />
<h2>Decoding</h2>
<p>Decoding is done using Sinter to call PyMatching, as shown in the Stim tutorial. We passed 2 new flags to the detector error model: <code>approximate_disjoint_errors=True</code> and <code>ignore_decomposition_failures=True</code>. See the code below.</p>
<pre><code>import stim
import numpy as np
import pymatching
import sinter


def count_logical_errors(circuit: stim.Circuit, num_shots: int) -&gt; int:
    # Sample the circuit.
    sampler = circuit.compile_detector_sampler()
    detection_events, observable_flips = sampler.sample(num_shots, separate_observables=True)

    # Extract decoder configuration data from the circuit.
    detector_error_model = circuit.detector_error_model(decompose_errors=True,
                                                        approximate_disjoint_errors=True,
                                                        ignore_decomposition_failures=True)
    # Run the decoder.
    predictions = sinter.predict_observables(
        dem=detector_error_model,
        dets=detection_events,
        decoder='pymatching',
    )
    # Count the mistakes.
    num_errors = 0
    for actual_flip, predicted_flip in zip(observable_flips, predictions):
        if not np.array_equal(actual_flip, predicted_flip):
            num_errors += 1
    return num_errors
<span class=""math-container"">```</span>
</code></pre>
",qc,simulating erasures stim p trying simulate erasure errors surface code using stim threshold erasure errors data qubits initialization 50 p followed following post https perform erasure error stim p however end threshold post https amp threshold value simulating erasures stim p post get answer bring hr p circuit unrotated span surface code pre code rx 0 2 4 10 12 14 20 22 24 6 8 16 18 1 3 5 7 9 11 13 15 17 19 21 23 tick r 999 e x999 e x0 x999 e y0 x999 e z0 x999 999 detector rec r 999 e x999 e x2 x999 e y2 x999 e z2 x999 999 detector rec r 999 e x999 e x4 x999 e y4 x999 e z4 x999 999 detector rec r 999 e x999 e x10 x999 e y10 x999 e z10 x999 999 detector rec r 999 e x999 e x12 x999 e y12 x999 e z12 x999 999 detector rec r 999 e x999 e x14 x999 e y14 x999 e z14 x999 999 detector rec r 999 e x999 e x20 x999 e y20 x999 e z20 x999 999 detector rec r 999 e x999 e x22 x999 e y22 x999 e z22 x999 999 detector rec r 999 e x999 e x24 x999 e y24 x999 e z24 x999 999 detector rec r 999 e x999 e x6 x999 e y6 x999 e z6 x999 999 detector rec r 999 e x999 e x8 x999 e y8 x999 e z8 x999 999 detector rec r 999 e x999 e x16 x999 e y16 x999 e z16 x999 999 detector rec r 999 e x999 e x18 x999 e y18 x999 e z18 x999 999 detector rec cz 6 1 8 3 16 11 18 13 cx 5 10 7 12 9 14 15 20 17 22 19 24 tick cz 2 1 4 3 12 11 14 13 22 21 24 23 cx 5 6 7 8 15 16 17 18 tick cz 0 1 2 3 10 11 12 13 20 21 22 23 cx 7 6 9 8 17 16 19 18 tick cz 6 11 8 13 16 21 18 23 cx 5 0 7 2 9 4 15 10 17 12 19 14 tick mrx 1 3 5 7 9 11 13 15 17 19 21 23 detector rec detector rec detector rec detector rec detector rec detector rec repeat 2 tick cz 6 1 8 3 16 11 18 13 cx 5 10 7 12 9 14 15 20 17 22 19 24 tick cz 2 1 4 3 12 11 14 13 22 21 24 23 cx 5 6 7 8 15 16 17 18 tick cz 0 1 2 3 10 11 12 13 20 21 22 23 cx 7 6 9 8 17 16 19 18 tick cz 6 11 8 13 16 21 18 23 cx 5 0 7 2 9 4 15 10 17 12 19 14 tick mrx 1 3 5 7 9 11 13 15 17 19 21 23 detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec mx 0 2 4 6 8 10 12 14 16 18 20 22 24 detector rec rec rec rec detector rec rec rec rec rec detector rec rec rec rec detector rec rec rec rec detector rec rec rec rec rec detector rec rec rec rec 0 rec rec rec hr p note simulate codes pauli data noise recover expected thresholds error circuit codes instead way handling hr h2 decoding p decoding done using sinter call pymatching shown stim tutorial passed 2 new flags detector error model code code see code pre code import stim import numpy np import pymatching import sinter def circuit int gt int sample circuit sampler extract decoder configuration data circuit run decoder predictions count mistakes 0 zip predictions 1 return span,"[(0, 0.029722769), (4, 0.010200254), (5, 0.025610445), (6, 0.6216934), (12, 0.018048225), (14, 0.026975812), (17, 0.26077944)]"
33770,,2023-08-12 06:55:10,2,90,"<p>I have recently been using Grover's algorithm to solve sudoku by coding. I am unsure how to interpret the graph produced. Could anyone explain?
I have included a link where you can view the graph: <a href=""https://github.com/seop02/sudoku-using-grover/blob/main/sudoku/%08sudoku_4.ipynb"" rel=""nofollow noreferrer"">https://github.com/seop02/sudoku-using-grover/blob/main/sudoku/%08sudoku_4.ipynb</a></p>
",How do I interpret the results of a grover's algorithm graph?,<qiskit><grovers-algorithm>,1,0,,,"How do I interpret the results of a grover's algorithm graph? <p>I have recently been using Grover's algorithm to solve sudoku by coding. I am unsure how to interpret the graph produced. Could anyone explain?
I have included a link where you can view the graph: <a href=""https://github.com/seop02/sudoku-using-grover/blob/main/sudoku/%08sudoku_4.ipynb"" rel=""nofollow noreferrer"">https://github.com/seop02/sudoku-using-grover/blob/main/sudoku/%08sudoku_4.ipynb</a></p>
",qc,interpret results grover algorithm graph p recently using grover algorithm solve sudoku coding unsure interpret graph produced could anyone explain included link view graph https nofollow noreferrer https,"[(4, 0.32387307), (7, 0.25942555), (8, 0.17262357), (12, 0.035835408), (13, 0.2029201)]"
33825,33826.0,2023-08-16 10:08:17,1,810,"<p>I am trying to convert the following qiskit QuantumCircuit to a gate using <a href=""https://qiskit.org/documentation/stable/0.19/stubs/qiskit.circuit.QuantumCircuit.to_gate.html"" rel=""nofollow noreferrer"">to_gate() method</a>.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.opflow import I, X, Y, Z

# construct one qubit circuit
circuit = QuantumCircuit(1, name='R')
    

# append gates as Pauli strings
circuit.append(0.5*I - 1j*np.sqrt(1-0.5**2)*Y, [0])



circuit.to_gate()
</code></pre>
<p>But I end up getting the following error.</p>
<pre><code>QiskitError: 'One or more instructions cannot be converted to a gate. &quot;circuit-304&quot; is not a gate instruction'
</code></pre>
<p>Are there limitations to the use of to_gate()? Bing AI tells me</p>
<blockquote>
<p>All instructions in the circuit must be gates.</p>
</blockquote>
<p>But I cannot find a reference to this, and if that indeed must be true, I do not know how to enforce this condition.</p>
",Can any Qiskit circuit be converted to a gate?,<qiskit><quantum-gate><quantum-circuit><pauli-gates>,2,0,,,"Can any Qiskit circuit be converted to a gate? <p>I am trying to convert the following qiskit QuantumCircuit to a gate using <a href=""https://qiskit.org/documentation/stable/0.19/stubs/qiskit.circuit.QuantumCircuit.to_gate.html"" rel=""nofollow noreferrer"">to_gate() method</a>.</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.opflow import I, X, Y, Z

# construct one qubit circuit
circuit = QuantumCircuit(1, name='R')
    

# append gates as Pauli strings
circuit.append(0.5*I - 1j*np.sqrt(1-0.5**2)*Y, [0])



circuit.to_gate()
</code></pre>
<p>But I end up getting the following error.</p>
<pre><code>QiskitError: 'One or more instructions cannot be converted to a gate. &quot;circuit-304&quot; is not a gate instruction'
</code></pre>
<p>Are there limitations to the use of to_gate()? Bing AI tells me</p>
<blockquote>
<p>All instructions in the circuit must be gates.</p>
</blockquote>
<p>But I cannot find a reference to this, and if that indeed must be true, I do not know how to enforce this condition.</p>
",qc,qiskit circuit converted gate p trying convert following qiskit quantumcircuit gate using https nofollow noreferrer method pre code qiskit import quantumcircuit import x z construct one qubit circuit circuit quantumcircuit 1 r append gates pauli strings 1j 2 0 p end getting following pre code qiskiterror instructions converted gate quot quot gate instruction p limitations use bing ai tells blockquote p instructions circuit must p find reference indeed must true know enforce,"[(0, 0.25153393), (2, 0.03893738), (4, 0.06554157), (8, 0.024190042), (9, 0.11133968), (10, 0.013042515), (12, 0.0145558985), (14, 0.443346), (19, 0.03596611)]"
33927,,2023-08-25 16:50:50,1,99,"<p>A while ago I wrote an example of quantum teleportation circuit in the IBM Composer which ran fine as of three days ago.  Yesterday, however, when I try to run the circuit, I get the following error:</p>
<blockquote>
<p>Failed - QASM2ParseError: '&lt;input&gt;:27,1: needed a start-of-statement token, but instead got /</p>
</blockquote>
<p>I am using the IBM Composer and not writing the OpenQASM 2.0 code directly, but of course the composer writes the code automatically.  The line that seems to be causing a problem is at the end, and seems to be there due to using 'Freeform alignment' in the composer:</p>
<p><code>// @columns [0,1,1,1,3,4,5,5,5,6,7,8,8,8,9,10,11,12,13,14]</code></p>
<p>If I delete that line the code will run, but I lose the freeform alignment and hence visual organization in the composer.   Is there a way to keep the freeform alignment line and still get working code?</p>
",New QASM2ParseError for old circuit on IBM composer,<ibm-quantum-devices><teleportation><qasm>,1,2,,,"New QASM2ParseError for old circuit on IBM composer <p>A while ago I wrote an example of quantum teleportation circuit in the IBM Composer which ran fine as of three days ago.  Yesterday, however, when I try to run the circuit, I get the following error:</p>
<blockquote>
<p>Failed - QASM2ParseError: '&lt;input&gt;:27,1: needed a start-of-statement token, but instead got /</p>
</blockquote>
<p>I am using the IBM Composer and not writing the OpenQASM 2.0 code directly, but of course the composer writes the code automatically.  The line that seems to be causing a problem is at the end, and seems to be there due to using 'Freeform alignment' in the composer:</p>
<p><code>// @columns [0,1,1,1,3,4,5,5,5,6,7,8,8,8,9,10,11,12,13,14]</code></p>
<p>If I delete that line the code will run, but I lose the freeform alignment and hence visual organization in the composer.   Is there a way to keep the freeform alignment line and still get working code?</p>
",qc,new qasm2parseerror old circuit ibm composer p ago wrote example quantum teleportation circuit ibm composer ran fine three days ago yesterday however try run circuit get following error blockquote p failed qasm2parseerror lt input gt needed token instead got p using ibm composer writing openqasm code directly course composer writes code automatically line seems causing problem end seems due using alignment composer p code columns p delete line code run lose freeform alignment hence visual organization composer way keep freeform alignment line still get working code,"[(0, 0.07873322), (4, 0.1917547), (7, 0.043091863), (12, 0.013139633), (13, 0.08465858), (14, 0.5868064)]"
33963,33964.0,2023-08-29 16:15:15,1,37,"<p>I am trying to understand <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,1,1,%22%E2%88%9Ai%22%5D,%5B%22H%22%5D,%5B%22Measure%22%5D,%5B%22Chance%22%5D,%5B%22%7C0%E2%9F%A9%E2%9F%A80%7C%22,%22Amps3%22%5D,%5B%5D,%5B%22H%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B1,%22H%22,%22H%22,%22H%22%5D,%5B1,%22Measure%22,%22Measure%22,%22Measure%22%5D,%5B1,%22Chance%22,%22Chance%22,%22Chance%22%5D,%5B%22Amps1%22,%22%7C0%E2%9F%A9%E2%9F%A80%7C%22,%22%7C0%E2%9F%A9%E2%9F%A80%7C%22,%22%7C0%E2%9F%A9%E2%9F%A80%7C%22%5D%5D%7D"" rel=""nofollow noreferrer"">this distillation</a> circuit (related to <a href=""https://quantumcomputing.stackexchange.com/questions/33960/15-to-1-distillation-protocol-implemented-with-lattice-surgery-dont-we-loose-t"">this question</a>), but I am confused by the meaning of the &quot;parity control Z&quot; operations represented with this symbol: <a href=""https://i.sstatic.net/pXEvG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pXEvG.png"" alt=""enter image description here"" /></a></p>
<p>The explanation in the simulator is &quot;Include a qubit's Z observable in the column parity control. Gates in the same column only apply if an odd number of parity controls are satisfied&quot;.</p>
<p>Does it mean that if the the first <span class=""math-container"">$k$</span> qubits are affected with this operator, and some unitary <span class=""math-container"">$U$</span> is applied on the last <span class=""math-container"">$n-k$</span> qubit, the resulting operation is a controlled <em>unitary</em> operation only applied if the first <span class=""math-container"">$k$</span> qubits have an odd number of <span class=""math-container"">$1$</span> once the state is expanded in the computational basis?</p>
<p>It seems to be the case with simple examples but I don't know if I just found out particular cases.</p>
","Exact meaning of ""parity control"" in quirk",<quirk>,1,0,,,"Exact meaning of ""parity control"" in quirk <p>I am trying to understand <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,1,1,%22%E2%88%9Ai%22%5D,%5B%22H%22%5D,%5B%22Measure%22%5D,%5B%22Chance%22%5D,%5B%22%7C0%E2%9F%A9%E2%9F%A80%7C%22,%22Amps3%22%5D,%5B%5D,%5B%22H%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,%22zpar%22,1,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,%22zpar%22,1,%22%E2%88%9Ai%22%5D,%5B%22zpar%22,1,1,%22zpar%22,%22%E2%88%9Ai%22%5D,%5B1,%22H%22,%22H%22,%22H%22%5D,%5B1,%22Measure%22,%22Measure%22,%22Measure%22%5D,%5B1,%22Chance%22,%22Chance%22,%22Chance%22%5D,%5B%22Amps1%22,%22%7C0%E2%9F%A9%E2%9F%A80%7C%22,%22%7C0%E2%9F%A9%E2%9F%A80%7C%22,%22%7C0%E2%9F%A9%E2%9F%A80%7C%22%5D%5D%7D"" rel=""nofollow noreferrer"">this distillation</a> circuit (related to <a href=""https://quantumcomputing.stackexchange.com/questions/33960/15-to-1-distillation-protocol-implemented-with-lattice-surgery-dont-we-loose-t"">this question</a>), but I am confused by the meaning of the &quot;parity control Z&quot; operations represented with this symbol: <a href=""https://i.sstatic.net/pXEvG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pXEvG.png"" alt=""enter image description here"" /></a></p>
<p>The explanation in the simulator is &quot;Include a qubit's Z observable in the column parity control. Gates in the same column only apply if an odd number of parity controls are satisfied&quot;.</p>
<p>Does it mean that if the the first <span class=""math-container"">$k$</span> qubits are affected with this operator, and some unitary <span class=""math-container"">$U$</span> is applied on the last <span class=""math-container"">$n-k$</span> qubit, the resulting operation is a controlled <em>unitary</em> operation only applied if the first <span class=""math-container"">$k$</span> qubits have an odd number of <span class=""math-container"">$1$</span> once the state is expanded in the computational basis?</p>
<p>It seems to be the case with simple examples but I don't know if I just found out particular cases.</p>
",qc,exact meaning parity control quirk p trying understand https 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 5d 5b 22zpar 22 22zpar 22 22zpar 22 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22 22zpar 22 22zpar 22 e2 88 9ai 22 5d 5b 22zpar 22 22zpar 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22 22zpar 22 e2 88 9ai 22 5d 5b 22zpar 22zpar 22 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22zpar 22 e2 88 9ai 22 5d 5b 22zpar 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22 e2 88 9ai 22 5d 5b 22h 22 5d 5b 22measure 22 5d 5b 22chance 22 5d 5b 22 7c0 e2 9f a9 e2 9f a80 7c 22 22amps3 22 5d 5b 5d 5b 22h 22 5d 5b 22zpar 22 22zpar 22 22zpar 22 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22 22zpar 22 22zpar 22 e2 88 9ai 22 5d 5b 22zpar 22 22zpar 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22 22zpar 22 e2 88 9ai 22 5d 5b 22zpar 22zpar 22 22zpar 22 22 e2 88 9ai 22 5d 5b 22zpar 22zpar 22 e2 88 9ai 22 5d 5b 22zpar 22zpar 22 22 e2 88 9ai 22 5d 5b1 22h 22 22h 22 22h 22 5d 5b1 22measure 22 22measure 22 22measure 22 5d 5b1 22chance 22 22chance 22 22chance 22 5d 5b 22amps1 22 22 7c0 e2 9f a9 e2 9f a80 7c 22 22 7c0 e2 9f a9 e2 9f a80 7c 22 22 7c0 e2 9f a9 e2 9f a80 7c 22 5d 5d 7d nofollow noreferrer distillation circuit related https question confused meaning quot parity control z quot operations represented symbol https nofollow noreferrer img https enter image description p explanation simulator quot include qubit z observable column parity control gates column apply odd number parity controls satisfied quot p mean first span k qubits affected operator unitary span u applied last span qubit resulting operation controlled em unitary operation applied first span k qubits odd number span 1 state expanded computational basis p seems case simple examples know found particular,"[(3, 0.08156658), (4, 0.06826017), (5, 0.05194782), (12, 0.6978175), (13, 0.011012075), (18, 0.06079658), (19, 0.013851398)]"
34087,,2023-09-08 08:24:05,0,136,"<p>A gigantic list of <strong>all the error correction codes(Classical Domain, Quantum Domain, Classical-quantum Domain)</strong>, see <a href=""https://errorcorrectionzoo.org/all"" rel=""nofollow noreferrer"">https://errorcorrectionzoo.org/all</a></p>
<hr />
<p>There are lots of <a href=""https://en.wikipedia.org/wiki/Quantum_error_correction"" rel=""nofollow noreferrer"">quantum error correction code</a>. e.g.</p>
<ul>
<li>Bit flip code</li>
<li>Sign flip code</li>
<li>Shor code(a.k.a., Peter Shor's 9-qubit-code)</li>
<li>Bosonic codes(including cat, Gottesman-Kitaev-Preskill (GKP), and binomial codes.)</li>
<li><a href=""https://en.wikipedia.org/wiki/Stabilizer_code"" rel=""nofollow noreferrer"">stabilizer code(also called additive codes)</a></li>
<li><a href=""https://en.wikipedia.org/wiki/CSS_code"" rel=""nofollow noreferrer"">CSS(named by Calderbank, Shor,and Steane)</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Quantum_convolutional_code"" rel=""nofollow noreferrer"">quantum convolutional code</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Bacon%E2%80%93Shor_code"" rel=""nofollow noreferrer"">Bacon–Shor code</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Steane_code"" rel=""nofollow noreferrer"">Steane code(namely, Steane's 7-qubit code)</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Toric_code"" rel=""nofollow noreferrer"">Toric code</a> (an example of topological quantum error correcting code, also an example of a stabilizer code)</li>
<li><a href=""https://en.wikipedia.org/wiki/Gnu_code"" rel=""nofollow noreferrer"">gnu code</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Five-qubit_error_correcting_code"" rel=""nofollow noreferrer"">Five-qubit error correcting code</a></li>
<li>entanglement-assisted stabilizer formalism as an extension of the standard stabilizer formalism (considering quantum entanglement)</li>
</ul>
<p>The list is not consistent with taxology, for the verison under taxology, see <a href=""https://errorcorrectionzoo.org/code_graph#domain_quantum_domain"" rel=""nofollow noreferrer"">the graph</a>.</p>
<hr />
<p>My question is:
Is there any programming project that <strong>implements</strong> one Quantum error correction code or <strong>demonstrates</strong> it?</p>
<p>I also want to know which one is the most practical?</p>
",Is there any programming project that implements one quantum error correction code or demonstrates it?,<programming><error-correction>,1,2,,,"Is there any programming project that implements one quantum error correction code or demonstrates it? <p>A gigantic list of <strong>all the error correction codes(Classical Domain, Quantum Domain, Classical-quantum Domain)</strong>, see <a href=""https://errorcorrectionzoo.org/all"" rel=""nofollow noreferrer"">https://errorcorrectionzoo.org/all</a></p>
<hr />
<p>There are lots of <a href=""https://en.wikipedia.org/wiki/Quantum_error_correction"" rel=""nofollow noreferrer"">quantum error correction code</a>. e.g.</p>
<ul>
<li>Bit flip code</li>
<li>Sign flip code</li>
<li>Shor code(a.k.a., Peter Shor's 9-qubit-code)</li>
<li>Bosonic codes(including cat, Gottesman-Kitaev-Preskill (GKP), and binomial codes.)</li>
<li><a href=""https://en.wikipedia.org/wiki/Stabilizer_code"" rel=""nofollow noreferrer"">stabilizer code(also called additive codes)</a></li>
<li><a href=""https://en.wikipedia.org/wiki/CSS_code"" rel=""nofollow noreferrer"">CSS(named by Calderbank, Shor,and Steane)</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Quantum_convolutional_code"" rel=""nofollow noreferrer"">quantum convolutional code</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Bacon%E2%80%93Shor_code"" rel=""nofollow noreferrer"">Bacon–Shor code</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Steane_code"" rel=""nofollow noreferrer"">Steane code(namely, Steane's 7-qubit code)</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Toric_code"" rel=""nofollow noreferrer"">Toric code</a> (an example of topological quantum error correcting code, also an example of a stabilizer code)</li>
<li><a href=""https://en.wikipedia.org/wiki/Gnu_code"" rel=""nofollow noreferrer"">gnu code</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Five-qubit_error_correcting_code"" rel=""nofollow noreferrer"">Five-qubit error correcting code</a></li>
<li>entanglement-assisted stabilizer formalism as an extension of the standard stabilizer formalism (considering quantum entanglement)</li>
</ul>
<p>The list is not consistent with taxology, for the verison under taxology, see <a href=""https://errorcorrectionzoo.org/code_graph#domain_quantum_domain"" rel=""nofollow noreferrer"">the graph</a>.</p>
<hr />
<p>My question is:
Is there any programming project that <strong>implements</strong> one Quantum error correction code or <strong>demonstrates</strong> it?</p>
<p>I also want to know which one is the most practical?</p>
",qc,programming project implements one quantum error correction code demonstrates p gigantic list strong error correction codes classical domain quantum domain domain see https nofollow noreferrer https hr p lots https nofollow noreferrer quantum error correction code ul li bit flip code li sign flip code li shor code peter shor li bosonic codes including cat gkp binomial codes li https nofollow noreferrer stabilizer code also called additive codes li https nofollow noreferrer css named calderbank shor steane li https nofollow noreferrer quantum convolutional code li https e2 80 nofollow noreferrer code li https nofollow noreferrer steane code namely steane code li https nofollow noreferrer toric code example topological quantum error correcting code also example stabilizer code li https nofollow noreferrer gnu code li https nofollow noreferrer error correcting code li stabilizer formalism extension standard stabilizer formalism considering quantum entanglement p list consistent taxology verison taxology see https nofollow noreferrer graph hr p question programming project strong implements one quantum error correction code strong demonstrates p also want know one practical,"[(4, 0.20731153), (5, 0.33567312), (7, 0.28693396), (9, 0.050983347), (12, 0.01633287), (13, 0.050831508), (14, 0.04468351)]"
34167,34192.0,2023-09-14 17:59:22,0,353,"<p>I am trying to understand the math behind the following applications of gates on three qubits:</p>
<p><a href=""https://i.sstatic.net/uU54R.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uU54R.png"" alt=""enter image description here"" /></a></p>
<p>You can view this via the Quirk simulator here:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22%5D,%5B%22%E2%80%A2%22,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D%5D%7D"" rel=""nofollow noreferrer"">https://algassert.com/quirk#circuit={%22cols%22:[[%22H%22],[%22%E2%80%A2%22,%22X%22],[1,%22%E2%80%A2%22,%22X%22]]}</a></p>
<p>What I have so far is the following:</p>
<p>(1) The first qubit begins in state</p>
<p><span class=""math-container"">$ \begin{bmatrix} 
1 \\
0 
\end{bmatrix} $</span></p>
<p>Any applying Hadamard gives:</p>
<p><span class=""math-container"">$ \begin{bmatrix} 
\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{bmatrix}
\times
\begin{bmatrix} 
1 \\
0 
\end{bmatrix} = \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} 
\end{bmatrix} $</span></p>
<p>(2) The next step is to apply the CNOT gate to the first two qubits. I compute the tensor produce of the states of the first two qubits in the following way:</p>
<p><span class=""math-container"">$ \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\otimes
\begin{bmatrix} 
1 \\
0 
\end{bmatrix} = \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
0 \\
\frac{1}{\sqrt{2}} \\
0
\end{bmatrix} $</span></p>
<p>Then, apply CNOT:</p>
<p><span class=""math-container"">$ \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 
\end{bmatrix}
\times \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
0 \\
\frac{1}{\sqrt{2}} \\
0
\end{bmatrix} = \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
0 \\
\frac{1}{\sqrt{2}}
\end{bmatrix} $</span></p>
<p>Now I have the first two qubits in an entangled state.</p>
<p>(3) In step three, I need to apply the CNOT gate to the second and third qubits. This is where I am unsure the correct way to do the math. I cannot just multiple the second and third qubits by the regular CNOT matrix independently, because the first and second qubits are entangled. One guess is that I need to create the state vector representing all three qubits:</p>
<p><span class=""math-container"">$ \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
0 \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\otimes 
\begin{bmatrix} 
1 \\
0 
\end{bmatrix} = \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
0 \\
0 \\
0 \\
0 \\
\frac{1}{\sqrt{2}} \\
0 \end{bmatrix} $</span></p>
<p>(NOTE: I edited the math above. When the question was initially posted it had the wrong result for the tensor product.)</p>
<p>What is the proper matrix to multiply this by? What is the technique to construct a version of the CNOT gate that will work for this length-8 state vector with two qubits already entangled?</p>
<p>Thanks.</p>
","How to apply CNOT on a three qubit system, with two qubits already entangled?",<hadamard><linear-algebra>,1,5,,,"How to apply CNOT on a three qubit system, with two qubits already entangled? <p>I am trying to understand the math behind the following applications of gates on three qubits:</p>
<p><a href=""https://i.sstatic.net/uU54R.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uU54R.png"" alt=""enter image description here"" /></a></p>
<p>You can view this via the Quirk simulator here:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22%5D,%5B%22%E2%80%A2%22,%22X%22%5D,%5B1,%22%E2%80%A2%22,%22X%22%5D%5D%7D"" rel=""nofollow noreferrer"">https://algassert.com/quirk#circuit={%22cols%22:[[%22H%22],[%22%E2%80%A2%22,%22X%22],[1,%22%E2%80%A2%22,%22X%22]]}</a></p>
<p>What I have so far is the following:</p>
<p>(1) The first qubit begins in state</p>
<p><span class=""math-container"">$ \begin{bmatrix} 
1 \\
0 
\end{bmatrix} $</span></p>
<p>Any applying Hadamard gives:</p>
<p><span class=""math-container"">$ \begin{bmatrix} 
\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{bmatrix}
\times
\begin{bmatrix} 
1 \\
0 
\end{bmatrix} = \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} 
\end{bmatrix} $</span></p>
<p>(2) The next step is to apply the CNOT gate to the first two qubits. I compute the tensor produce of the states of the first two qubits in the following way:</p>
<p><span class=""math-container"">$ \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\otimes
\begin{bmatrix} 
1 \\
0 
\end{bmatrix} = \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
0 \\
\frac{1}{\sqrt{2}} \\
0
\end{bmatrix} $</span></p>
<p>Then, apply CNOT:</p>
<p><span class=""math-container"">$ \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 
\end{bmatrix}
\times \begin{bmatrix} 
\frac{1}{\sqrt{2}} \\
0 \\
\frac{1}{\sqrt{2}} \\
0
\end{bmatrix} = \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
0 \\
\frac{1}{\sqrt{2}}
\end{bmatrix} $</span></p>
<p>Now I have the first two qubits in an entangled state.</p>
<p>(3) In step three, I need to apply the CNOT gate to the second and third qubits. This is where I am unsure the correct way to do the math. I cannot just multiple the second and third qubits by the regular CNOT matrix independently, because the first and second qubits are entangled. One guess is that I need to create the state vector representing all three qubits:</p>
<p><span class=""math-container"">$ \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
0 \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\otimes 
\begin{bmatrix} 
1 \\
0 
\end{bmatrix} = \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
0 \\
0 \\
0 \\
0 \\
0 \\
\frac{1}{\sqrt{2}} \\
0 \end{bmatrix} $</span></p>
<p>(NOTE: I edited the math above. When the question was initially posted it had the wrong result for the tensor product.)</p>
<p>What is the proper matrix to multiply this by? What is the technique to construct a version of the CNOT gate that will work for this length-8 state vector with two qubits already entangled?</p>
<p>Thanks.</p>
",qc,apply cnot three qubit system two qubits already entangled p trying understand math behind following applications gates three qubits p https nofollow noreferrer img https enter image description p view via quirk simulator p https 7b 22cols 22 5b 5b 22h 22 5d 5b 22 e2 80 a2 22 22x 22 5d 5b1 22 e2 80 a2 22 22x 22 5d 5d 7d nofollow noreferrer https 22cols 22 22h 22 22 e2 80 a2 22 22x 22 1 22 e2 80 a2 22 22x 22 p far following p 1 first qubit begins state p span bmatrix 1 0 bmatrix p applying hadamard gives p span bmatrix 1 2 amp 1 2 1 2 amp 1 2 bmatrix bmatrix 1 0 bmatrix bmatrix 1 2 1 2 bmatrix p 2 next step apply cnot gate first two qubits compute tensor produce states first two qubits following way p span bmatrix 1 2 1 2 bmatrix bmatrix 1 0 bmatrix bmatrix 1 2 0 1 2 0 bmatrix p apply cnot p span bmatrix 1 amp 0 amp 0 amp 0 0 amp 1 amp 0 amp 0 0 amp 0 amp 0 amp 1 0 amp 0 amp 1 amp 0 bmatrix bmatrix 1 2 0 1 2 0 bmatrix bmatrix 1 2 0 0 1 2 bmatrix p first two qubits entangled p 3 step three need apply cnot gate second third qubits unsure correct way math multiple second third qubits regular cnot matrix independently first second qubits entangled one guess need create state vector representing three qubits p span bmatrix 1 2 0 0 1 2 bmatrix bmatrix 1 0 bmatrix bmatrix 1 2 0 0 0 0 0 1 2 0 bmatrix p note edited math question initially posted wrong result tensor product p proper matrix multiply technique construct version cnot gate work state vector two qubits already entangled p,"[(2, 0.2896354), (4, 0.08372564), (9, 0.033885237), (12, 0.1552768), (15, 0.22951657), (18, 0.20751165)]"
34228,34231.0,2023-09-20 17:19:23,7,3308,"<p>I am studying quantum computing a little bit by myself, and I have simple questions.</p>
<p>I didn't find a clear definition of what is a completely positive and trace-preserving (CPTP) map. The best I've found was <a href=""https://www.quantiki.org/wiki/channel-cp-map#:%7E:text=In%20summary%2C%20a%20channel%20is,statistical%20interpretation%20of%20quantum%20mechanics."" rel=""nofollow noreferrer"">here</a> .</p>
<p>To summarize it -<br />
Let  <span class=""math-container"">$\,T:H\to H $</span> be a mapping with <span class=""math-container"">$H$</span> the space of operators (that means). In order for <span class=""math-container"">$T(\cdot)$</span> to be CPTP, it needs to verify:</p>
<ol>
<li><span class=""math-container"">$T(\cdot)$</span> need to be a linear mapping</li>
<li><span class=""math-container"">$\forall A \in H$</span> we have <span class=""math-container"">$ \text{Tr}(A)=\text{Tr}(T(A))$</span>. It means that <span class=""math-container"">$T(\cdot)$</span> is trace-preserving.</li>
<li><span class=""math-container"">$T(\cdot)$</span> need to be a positive map</li>
</ol>
<p>I have a question about this last point.</p>
<ul>
<li>What is a &quot;completely&quot; positive map?</li>
<li>More precisely, what does it mean concerning the matrix representation of <span class=""math-container"">$T(\cdot)$</span>? Does it mean that all its elements are positive?  Or (completely) positive map for an application <span class=""math-container"">$T(\cdot)$</span> is equivalent to say that the matrix representation of <span class=""math-container"">$T(\cdot)$</span> is a <a href=""https://en.wikipedia.org/wiki/Definite_matrix"" rel=""nofollow noreferrer"">positive semi-definite matrix</a>?</li>
</ul>
","What are ""completely positive"" and ""CPTP"" quantum maps?",<textbook-and-exercises><quantum-operation>,2,1,,,"What are ""completely positive"" and ""CPTP"" quantum maps? <p>I am studying quantum computing a little bit by myself, and I have simple questions.</p>
<p>I didn't find a clear definition of what is a completely positive and trace-preserving (CPTP) map. The best I've found was <a href=""https://www.quantiki.org/wiki/channel-cp-map#:%7E:text=In%20summary%2C%20a%20channel%20is,statistical%20interpretation%20of%20quantum%20mechanics."" rel=""nofollow noreferrer"">here</a> .</p>
<p>To summarize it -<br />
Let  <span class=""math-container"">$\,T:H\to H $</span> be a mapping with <span class=""math-container"">$H$</span> the space of operators (that means). In order for <span class=""math-container"">$T(\cdot)$</span> to be CPTP, it needs to verify:</p>
<ol>
<li><span class=""math-container"">$T(\cdot)$</span> need to be a linear mapping</li>
<li><span class=""math-container"">$\forall A \in H$</span> we have <span class=""math-container"">$ \text{Tr}(A)=\text{Tr}(T(A))$</span>. It means that <span class=""math-container"">$T(\cdot)$</span> is trace-preserving.</li>
<li><span class=""math-container"">$T(\cdot)$</span> need to be a positive map</li>
</ol>
<p>I have a question about this last point.</p>
<ul>
<li>What is a &quot;completely&quot; positive map?</li>
<li>More precisely, what does it mean concerning the matrix representation of <span class=""math-container"">$T(\cdot)$</span>? Does it mean that all its elements are positive?  Or (completely) positive map for an application <span class=""math-container"">$T(\cdot)$</span> is equivalent to say that the matrix representation of <span class=""math-container"">$T(\cdot)$</span> is a <a href=""https://en.wikipedia.org/wiki/Definite_matrix"" rel=""nofollow noreferrer"">positive semi-definite matrix</a>?</li>
</ul>
",qc,completely positive cptp quantum maps p studying quantum computing little bit simple p find clear definition completely positive cptp map best found https 7e 20summary 2c 20a 20channel 20is statistical 20interpretation 20of 20quantum 20mechanics nofollow noreferrer p summarize br let span h mapping span h space operators means order span cptp needs verify ol li span need linear mapping li span h span tr tr means span li span need positive map p question last ul li quot completely quot positive map li precisely mean concerning matrix representation span mean elements positive completely positive map application span equivalent say matrix representation span https nofollow noreferrer positive matrix,"[(3, 0.44307283), (4, 0.062774815), (7, 0.14530556), (11, 0.19489671), (12, 0.010096576), (13, 0.12121084), (19, 0.021370014)]"
34263,34294.0,2023-09-23 13:39:46,3,161,"<p>I am stuck in simplyfing the following cNOT teleportation in ZX-calculus. I don't know how to proceed further. The circuit I start from is taken from <a href=""https://arxiv.org/abs/2307.07908"" rel=""nofollow noreferrer"">this thesis</a> (Fig 2.14, page 22).</p>
<p>Which property can I use to simplify the circuit further? Am I forced to sit down and compute the matrix product?</p>
<p>In case the image is not super clear, in d), the element in the bottom green Z spider is <span class=""math-container"">$(-1)^{b_1} \pi b_2$</span> (I could have removed the <span class=""math-container"">$(-1)^{b_1}$</span> already as it is multiplied by <span class=""math-container"">$\pi$</span> but I kept it to be sure you see my step-by-step calculation).</p>
<p><a href=""https://i.sstatic.net/HiX4J.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HiX4J.jpg"" alt=""enter image description here"" /></a></p>
",$CNOT$ teleportation in ZX-calculus: how to simplify my circuit further?,<teleportation><zx-calculus>,1,0,,,"$CNOT$ teleportation in ZX-calculus: how to simplify my circuit further? <p>I am stuck in simplyfing the following cNOT teleportation in ZX-calculus. I don't know how to proceed further. The circuit I start from is taken from <a href=""https://arxiv.org/abs/2307.07908"" rel=""nofollow noreferrer"">this thesis</a> (Fig 2.14, page 22).</p>
<p>Which property can I use to simplify the circuit further? Am I forced to sit down and compute the matrix product?</p>
<p>In case the image is not super clear, in d), the element in the bottom green Z spider is <span class=""math-container"">$(-1)^{b_1} \pi b_2$</span> (I could have removed the <span class=""math-container"">$(-1)^{b_1}$</span> already as it is multiplied by <span class=""math-container"">$\pi$</span> but I kept it to be sure you see my step-by-step calculation).</p>
<p><a href=""https://i.sstatic.net/HiX4J.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HiX4J.jpg"" alt=""enter image description here"" /></a></p>
",qc,cnot teleportation simplify circuit p stuck simplyfing following cnot teleportation know proceed circuit start taken https nofollow noreferrer thesis fig page 22 p property use simplify circuit forced sit compute matrix product p case image super clear element bottom green z spider span could removed span already multiplied span kept sure see calculation p https nofollow noreferrer img https enter image description,"[(3, 0.26912078), (4, 0.45753166), (8, 0.1620824), (12, 0.018552002), (13, 0.066718966), (17, 0.02366372)]"
34276,,2023-09-25 02:13:47,1,132,"<p>Qiskit provides a <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseOracle.html"" rel=""nofollow noreferrer"">phase oracle method</a> that takes a Boolean formula as input and returns a phase oracle circuit for that function as output.
Their <a href=""https://qiskit.org/documentation/_modules/qiskit/circuit/library/phase_oracle.html#PhaseOracle"" rel=""nofollow noreferrer"">source code</a> informed me that the synthesis uses the <a href=""https://github.com/boschmitt/tweedledum/blob/master/src/Synthesis/pkrm_synth.cpp"" rel=""nofollow noreferrer"">Tweedledum's <code>pkrm_synth</code> method</a> for the actual synthesis.</p>
<p>However, apart from the fact that it somehow uses some combination of things called psuedo-Kronecker expression and Reed-Muller code (hence the 'pkrm' acronym), I could not decipher how the synthesis is being performed and what kind of algorithm is being used due to the lack of C++ proficiency.</p>
<p>If there are any documentations for the <code>pkrm_synth</code> method or the <code>Tweedledum</code> package in general, or if anyone recognizes the algorithm being used in the method, any such help would be greatly appreciated.</p>
",How does Qiskit's oracle synthesizer work?,<qiskit><oracles>,0,1,,,"How does Qiskit's oracle synthesizer work? <p>Qiskit provides a <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseOracle.html"" rel=""nofollow noreferrer"">phase oracle method</a> that takes a Boolean formula as input and returns a phase oracle circuit for that function as output.
Their <a href=""https://qiskit.org/documentation/_modules/qiskit/circuit/library/phase_oracle.html#PhaseOracle"" rel=""nofollow noreferrer"">source code</a> informed me that the synthesis uses the <a href=""https://github.com/boschmitt/tweedledum/blob/master/src/Synthesis/pkrm_synth.cpp"" rel=""nofollow noreferrer"">Tweedledum's <code>pkrm_synth</code> method</a> for the actual synthesis.</p>
<p>However, apart from the fact that it somehow uses some combination of things called psuedo-Kronecker expression and Reed-Muller code (hence the 'pkrm' acronym), I could not decipher how the synthesis is being performed and what kind of algorithm is being used due to the lack of C++ proficiency.</p>
<p>If there are any documentations for the <code>pkrm_synth</code> method or the <code>Tweedledum</code> package in general, or if anyone recognizes the algorithm being used in the method, any such help would be greatly appreciated.</p>
",qc,qiskit oracle synthesizer work p qiskit provides https nofollow noreferrer phase oracle method takes boolean formula input returns phase oracle circuit function output https phaseoracle nofollow noreferrer source code informed synthesis uses https nofollow noreferrer tweedledum code method actual p however apart fact somehow uses combination things called expression code hence acronym could decipher synthesis performed kind algorithm used due lack p documentations code method code tweedledum package general anyone recognizes algorithm used method help would greatly,"[(0, 0.025863117), (4, 0.14566347), (7, 0.25592804), (8, 0.09610409), (9, 0.14635979), (10, 0.05015663), (12, 0.012585989), (14, 0.2657166)]"
34281,,2023-09-25 17:47:22,2,46,"<p>Consider a set <span class=""math-container"">$ A = \{a_0,a_2,\ldots,a_{k-1}\} \subset [N] := \{0,1,\ldots,N-1\}$</span>.</p>
<p>Consider the diagonal matrix
<span class=""math-container"">\begin{equation}
R := I - 2 \sum_{a\in A} |a\rangle\langle a|,
\end{equation}</span>
which is just a Grover reflection.</p>
<p>Given knowledge of <span class=""math-container"">$A$</span>, and access to controlled Z and rotations, what is the optimal sequence of operations to implement <span class=""math-container"">$R$</span>?</p>
",Generic circuit for signature matrix,<circuit-construction><grovers-algorithm><matrix-representation>,0,2,,,"Generic circuit for signature matrix <p>Consider a set <span class=""math-container"">$ A = \{a_0,a_2,\ldots,a_{k-1}\} \subset [N] := \{0,1,\ldots,N-1\}$</span>.</p>
<p>Consider the diagonal matrix
<span class=""math-container"">\begin{equation}
R := I - 2 \sum_{a\in A} |a\rangle\langle a|,
\end{equation}</span>
which is just a Grover reflection.</p>
<p>Given knowledge of <span class=""math-container"">$A$</span>, and access to controlled Z and rotations, what is the optimal sequence of operations to implement <span class=""math-container"">$R$</span>?</p>
",qc,generic circuit signature matrix p consider set span n p consider diagonal matrix span equation r 2 equation grover p given knowledge span access controlled z rotations optimal sequence operations implement span r,"[(3, 0.5930899), (7, 0.041276935), (9, 0.19487719), (11, 0.078603365), (12, 0.030205397), (14, 0.05772541)]"
34339,34340.0,2023-10-02 19:30:22,0,104,"<p>I'm new to Qiskit.
I am trying to construct a gate from HamiltonianGate(), available on Qiskit. The Hamiltonian in question is:
<span class=""math-container"">$$H = - \pi\delta(Z_1 - Z_2)
       + 2\pi J ~ \mathbf{I}_1 \cdot \mathbf{I}_2$$</span>
where <span class=""math-container"">$\mathbf{I}_1$</span> and <span class=""math-container"">$\mathbf{I}_2$</span> are Pauli vectors, each for system 1 and system 2, respectively.</p>
<p>Although I was able to do so by using <code>HamiltonianGate()</code>, when I try to see my circuit, I end up getting something like this:</p>
<p><a href=""https://i.sstatic.net/jcTcr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jcTcr.png"" alt=""enter image description here"" /></a></p>
<p>I was hoping to find explicit gate decomposition of my unitary from <code>HamiltonianGate()</code>, but I'm unable to find a way to do so.</p>
<p>Please do let me know how I can proceed from here and obtain the explicit gate decompositions. If this is, for some reason, not possible, then please do let me know why it is so. Also, if given this scenario, any help in simulating the unitary associated with the above Hamiltonian via elementary gates would be very much appreciated!</p>
",How to find explicit gate decomposition of a circuit implementing a unitary using HamiltonianGate()?,<circuit-construction><hamiltonian-simulation>,1,3,,,"How to find explicit gate decomposition of a circuit implementing a unitary using HamiltonianGate()? <p>I'm new to Qiskit.
I am trying to construct a gate from HamiltonianGate(), available on Qiskit. The Hamiltonian in question is:
<span class=""math-container"">$$H = - \pi\delta(Z_1 - Z_2)
       + 2\pi J ~ \mathbf{I}_1 \cdot \mathbf{I}_2$$</span>
where <span class=""math-container"">$\mathbf{I}_1$</span> and <span class=""math-container"">$\mathbf{I}_2$</span> are Pauli vectors, each for system 1 and system 2, respectively.</p>
<p>Although I was able to do so by using <code>HamiltonianGate()</code>, when I try to see my circuit, I end up getting something like this:</p>
<p><a href=""https://i.sstatic.net/jcTcr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jcTcr.png"" alt=""enter image description here"" /></a></p>
<p>I was hoping to find explicit gate decomposition of my unitary from <code>HamiltonianGate()</code>, but I'm unable to find a way to do so.</p>
<p>Please do let me know how I can proceed from here and obtain the explicit gate decompositions. If this is, for some reason, not possible, then please do let me know why it is so. Also, if given this scenario, any help in simulating the unitary associated with the above Hamiltonian via elementary gates would be very much appreciated!</p>
",qc,find explicit gate decomposition circuit implementing unitary using hamiltoniangate p new qiskit trying construct gate hamiltoniangate available qiskit hamiltonian question span h j span span pauli vectors system 1 system 2 p although able using code hamiltoniangate try see circuit end getting something like p https nofollow noreferrer img https enter image description p hoping find explicit gate decomposition unitary code hamiltoniangate unable find way p please let know proceed obtain explicit gate decompositions reason possible please let know also given scenario help simulating unitary associated hamiltonian via elementary gates would much appreciated,"[(1, 0.05957536), (3, 0.29172963), (4, 0.17222717), (9, 0.08367047), (12, 0.04358272), (14, 0.34771198)]"
34345,,2023-10-03 06:42:05,1,282,"<p><a href=""https://i.sstatic.net/Y8f6F.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Y8f6F.png"" alt=""![image|690x196](upload://4duiwxn09NE1l4cRcdrgo1OATc8.png)"" /></a></p>
<p>The framework of Grover's algorithm is shown in Figure from Qiskit.
<a href=""https://learn.qiskit.org/course/ch-algorithms/grovers-algorithm"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/ch-algorithms/grovers-algorithm</a></p>
<p>But I didn't understand the tutorial's construction rules for <span class=""math-container"">$U_f$</span>. If there are four qubits, labeled 0001, 0010, 1001, and 1110, how to design <span class=""math-container"">$U_f$</span>?  If there are 5 bits, labeled 00101, 01010, 10101, and 11110, how to design <span class=""math-container"">$U_f$</span>? Can you summarize in code how Uf imposes  CZ gates?</p>
<p><a href=""https://i.sstatic.net/kpJ0P.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/kpJ0P.png"" alt=""@CatalinaAlbornoz"" /></a></p>
<p>Also, what is the difference between a Phase Oracle and a Boolean Oracle<a href=""https://i.sstatic.net/Y8f6F.png"" rel=""nofollow noreferrer"">1</a>?</p>
<p><a href=""https://i.sstatic.net/Y8f6F.png"" rel=""nofollow noreferrer"">1</a> C. Figgatt, D. Maslov et al., “Complete 3-qubit Grover search on a programmable quantum computer,” Nature Communications, vol. 8, no. 1, pp. 1918, 2017.
<a href=""https://www.nature.com/articles/s41467-017-01904-7"" rel=""nofollow noreferrer"">https://www.nature.com/articles/s41467-017-01904-7</a></p>
",Please teach the construction law of oracle $U_f$ in Grover’s algorithm,<grovers-algorithm>,1,0,,,"Please teach the construction law of oracle $U_f$ in Grover’s algorithm <p><a href=""https://i.sstatic.net/Y8f6F.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Y8f6F.png"" alt=""![image|690x196](upload://4duiwxn09NE1l4cRcdrgo1OATc8.png)"" /></a></p>
<p>The framework of Grover's algorithm is shown in Figure from Qiskit.
<a href=""https://learn.qiskit.org/course/ch-algorithms/grovers-algorithm"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/ch-algorithms/grovers-algorithm</a></p>
<p>But I didn't understand the tutorial's construction rules for <span class=""math-container"">$U_f$</span>. If there are four qubits, labeled 0001, 0010, 1001, and 1110, how to design <span class=""math-container"">$U_f$</span>?  If there are 5 bits, labeled 00101, 01010, 10101, and 11110, how to design <span class=""math-container"">$U_f$</span>? Can you summarize in code how Uf imposes  CZ gates?</p>
<p><a href=""https://i.sstatic.net/kpJ0P.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/kpJ0P.png"" alt=""@CatalinaAlbornoz"" /></a></p>
<p>Also, what is the difference between a Phase Oracle and a Boolean Oracle<a href=""https://i.sstatic.net/Y8f6F.png"" rel=""nofollow noreferrer"">1</a>?</p>
<p><a href=""https://i.sstatic.net/Y8f6F.png"" rel=""nofollow noreferrer"">1</a> C. Figgatt, D. Maslov et al., “Complete 3-qubit Grover search on a programmable quantum computer,” Nature Communications, vol. 8, no. 1, pp. 1918, 2017.
<a href=""https://www.nature.com/articles/s41467-017-01904-7"" rel=""nofollow noreferrer"">https://www.nature.com/articles/s41467-017-01904-7</a></p>
",qc,please teach construction law oracle grover algorithm p https nofollow noreferrer img https upload p framework grover algorithm shown figure qiskit https nofollow noreferrer https p understand tutorial construction rules span four qubits labeled 0001 0010 1001 1110 design span 5 bits labeled 00101 01010 10101 11110 design span summarize code uf imposes cz gates p https nofollow noreferrer img https catalinaalbornoz p also difference phase oracle boolean oracle https nofollow noreferrer 1 p https nofollow noreferrer 1 figgatt maslov et complete grover search programmable quantum computer nature communications vol 8 1 pp 1918 2017 https nofollow noreferrer https,"[(3, 0.0373851), (4, 0.42150033), (6, 0.041312575), (7, 0.065043546), (8, 0.12666418), (9, 0.17214088), (10, 0.027930474), (12, 0.011468781), (18, 0.09531476)]"
34436,34437.0,2023-10-11 12:54:25,2,28,"<p>When a qubit passes through a gate isnt it a 3D rotation of the vector on the Bloch sphere?</p>
",Is a qubit passing through a gate a 3D rotation of the vector on the Bloch sphere?,<quantum-state><bloch-sphere>,1,0,,,"Is a qubit passing through a gate a 3D rotation of the vector on the Bloch sphere? <p>When a qubit passes through a gate isnt it a 3D rotation of the vector on the Bloch sphere?</p>
",qc,qubit passing gate 3d rotation vector bloch sphere p qubit passes gate isnt 3d rotation vector bloch sphere,"[(9, 0.27071586), (12, 0.054865953), (13, 0.5212612), (14, 0.14435071)]"
34474,34476.0,2023-10-14 16:02:40,1,160,"<p>Does anyone know how to work with SwitchCaseOp? I want to use it as a tool to execute conditioned circuits. I have read the documentation, however, I can not figure out how to use it and run it on a simulator. It will be a great asset if you can help me on the matter.</p>
",How to work with SwitchCaseOp?,<qiskit-runtime><qiskit>,1,1,,,"How to work with SwitchCaseOp? <p>Does anyone know how to work with SwitchCaseOp? I want to use it as a tool to execute conditioned circuits. I have read the documentation, however, I can not figure out how to use it and run it on a simulator. It will be a great asset if you can help me on the matter.</p>
",qc,work switchcaseop p anyone know work switchcaseop want use tool execute conditioned circuits read documentation however figure use run simulator great asset help,"[(12, 0.047806647), (14, 0.94369984)]"
34518,34524.0,2023-10-19 00:28:36,1,48,"<p>Suppose Alice transmits a qubit in either of two states <span class=""math-container"">$|\psi\rangle_{1}, |\psi \rangle_{2}$</span>.</p>
<p>Bob has 3 Kraus operators: <span class=""math-container"">$\hat{E1}, \hat{E2}, \hat{E3}$</span> such that the average measurement value of <span class=""math-container"">$\hat{E1}$</span> on <span class=""math-container"">$|\psi\rangle_{1}$</span> yields 0, <span class=""math-container"">$\hat{E1}$</span> on <span class=""math-container"">$|\psi\rangle_{2}$</span> yields <span class=""math-container"">$E_{1}$</span>; similarly, <span class=""math-container"">$\hat{E2}$</span> on <span class=""math-container"">$|\psi\rangle_{2}$</span> yields 0, <span class=""math-container"">$\hat{E2}$</span> on <span class=""math-container"">$|\psi\rangle_{2}$</span> yields <span class=""math-container"">$E_{2}$</span>.</p>
<p>The action of <span class=""math-container"">$\hat{E3}$</span> on either states Alice sent yields an indeterministic results.</p>
<p>If this is the case why can't Bob stick with using <span class=""math-container"">$\hat{E1}, \hat{E2}$</span> and only <span class=""math-container"">$\hat{E1}, \hat{E2}$</span>? <strong>My best guess</strong> is that it could be possible but the completeness relation cannot be satisfied with <span class=""math-container"">$\hat{E1}, \hat{E2}$</span> and only <span class=""math-container"">$\hat{E1}, \hat{E2}$</span>. I.e, <span class=""math-container"">$\sum_{i=1}^{2} E_{i}^{\dagger}E_{i} \neq 
I$</span></p>
<p>Edit:</p>
<p>The above is in reference to Quantum Computation and Quantum Information by Michael A. Nielson and Isaac L. Chung, page 92.</p>
",indeterministic knowledge on unknown state using a Kraus operator,<measurement><quantum-operation>,1,2,,,"indeterministic knowledge on unknown state using a Kraus operator <p>Suppose Alice transmits a qubit in either of two states <span class=""math-container"">$|\psi\rangle_{1}, |\psi \rangle_{2}$</span>.</p>
<p>Bob has 3 Kraus operators: <span class=""math-container"">$\hat{E1}, \hat{E2}, \hat{E3}$</span> such that the average measurement value of <span class=""math-container"">$\hat{E1}$</span> on <span class=""math-container"">$|\psi\rangle_{1}$</span> yields 0, <span class=""math-container"">$\hat{E1}$</span> on <span class=""math-container"">$|\psi\rangle_{2}$</span> yields <span class=""math-container"">$E_{1}$</span>; similarly, <span class=""math-container"">$\hat{E2}$</span> on <span class=""math-container"">$|\psi\rangle_{2}$</span> yields 0, <span class=""math-container"">$\hat{E2}$</span> on <span class=""math-container"">$|\psi\rangle_{2}$</span> yields <span class=""math-container"">$E_{2}$</span>.</p>
<p>The action of <span class=""math-container"">$\hat{E3}$</span> on either states Alice sent yields an indeterministic results.</p>
<p>If this is the case why can't Bob stick with using <span class=""math-container"">$\hat{E1}, \hat{E2}$</span> and only <span class=""math-container"">$\hat{E1}, \hat{E2}$</span>? <strong>My best guess</strong> is that it could be possible but the completeness relation cannot be satisfied with <span class=""math-container"">$\hat{E1}, \hat{E2}$</span> and only <span class=""math-container"">$\hat{E1}, \hat{E2}$</span>. I.e, <span class=""math-container"">$\sum_{i=1}^{2} E_{i}^{\dagger}E_{i} \neq 
I$</span></p>
<p>Edit:</p>
<p>The above is in reference to Quantum Computation and Quantum Information by Michael A. Nielson and Isaac L. Chung, page 92.</p>
",qc,indeterministic knowledge unknown state using kraus operator p suppose alice transmits qubit either two states span 1 2 p bob 3 kraus operators span e1 e2 e3 average measurement value span e1 span 1 yields 0 span e1 span 2 yields span 1 similarly span e2 span 2 yields 0 span e2 span 2 yields span 2 p action span e3 either states alice sent yields indeterministic p case ca bob stick using span e1 e2 span e1 e2 strong best guess could possible completeness relation satisfied span e1 e2 span e1 e2 span 2 p edit p reference quantum computation quantum information michael nielson isaac chung page,"[(2, 0.09942008), (3, 0.5328676), (12, 0.07032694), (14, 0.12171145), (18, 0.17418988)]"
34616,,2023-10-26 23:37:51,2,532,"<p>I have a 3-qubit unitary represented by a circuit with the following dictionary: <code>{'cx': 30, 'h': 22, 'rz': 15, 's': 4, 'sdg': 4}</code>. I want to use this circuit on IBM machine with a pre-defined coupling map. However, the transpiled circuit with a map <em>i.e.</em>,</p>
<p><code>transpiled_circuit = transpile(circuit, basis_gates=['rz', 's', 'sdg', 'h', 'cx'], coupling_map=[[0, 1], [1, 2]], optimization_level=3)</code></p>
<p>is very different from the initial circuit which is incorrect. What am I doing wrong?</p>
",Coupling map in QISKIT transpile,<qiskit><pauli-gates><transpile>,1,0,,,"Coupling map in QISKIT transpile <p>I have a 3-qubit unitary represented by a circuit with the following dictionary: <code>{'cx': 30, 'h': 22, 'rz': 15, 's': 4, 'sdg': 4}</code>. I want to use this circuit on IBM machine with a pre-defined coupling map. However, the transpiled circuit with a map <em>i.e.</em>,</p>
<p><code>transpiled_circuit = transpile(circuit, basis_gates=['rz', 's', 'sdg', 'h', 'cx'], coupling_map=[[0, 1], [1, 2]], optimization_level=3)</code></p>
<p>is very different from the initial circuit which is incorrect. What am I doing wrong?</p>
",qc,coupling map qiskit transpile p unitary represented circuit following dictionary code 30 h 22 15 4 4 want use circuit ibm machine coupling map however transpiled circuit map em p code transpile circuit h 0 1 1 2 p different initial circuit incorrect wrong,"[(2, 0.12487442), (6, 0.10552452), (11, 0.09434392), (12, 0.02299789), (14, 0.6488649)]"
34632,,2023-10-28 13:25:55,2,62,"<p><a href=""https://arxiv.org/abs/quant-ph/0302002"" rel=""nofollow noreferrer"">This paper</a> introduces to the synthesis of a (optimal) circuit of CNOTs only; starting from a parity map encoded into a matrix.</p>
<p>It is based on <em>Gaussian Elimination</em>.</p>
<p>This is an important result, which find some revisits to make it work for topology constrained circuits.</p>
<p>For example, <a href=""https://arxiv.org/abs/1904.00633"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1904.00633</a> presents a <em>Gauss-Steiner</em> combination to be compliant with the topology.</p>
<p>Authors state that for the synthesis there is some freedom of choice and they greedily choose one that maximise the parallelism:</p>
<blockquote>
<p>Note that in this phase, we have <strong>some</strong> freedom to choose which row operations to perform. Here we have taken a greedy strategy for maximising the number of row operations that can be done in parallel.</p>
</blockquote>
<p>I would like to understand better such a method.
What observation can be made? E.g. What is the relation between the diagonal and the CNOTs? What freedom do we have when selecting a row/operation to synthesise?</p>
",CNOT circuit synthesis with Gauss elimination. Explanation and beyond?,<gate-synthesis><matrix-representation>,0,0,,,"CNOT circuit synthesis with Gauss elimination. Explanation and beyond? <p><a href=""https://arxiv.org/abs/quant-ph/0302002"" rel=""nofollow noreferrer"">This paper</a> introduces to the synthesis of a (optimal) circuit of CNOTs only; starting from a parity map encoded into a matrix.</p>
<p>It is based on <em>Gaussian Elimination</em>.</p>
<p>This is an important result, which find some revisits to make it work for topology constrained circuits.</p>
<p>For example, <a href=""https://arxiv.org/abs/1904.00633"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1904.00633</a> presents a <em>Gauss-Steiner</em> combination to be compliant with the topology.</p>
<p>Authors state that for the synthesis there is some freedom of choice and they greedily choose one that maximise the parallelism:</p>
<blockquote>
<p>Note that in this phase, we have <strong>some</strong> freedom to choose which row operations to perform. Here we have taken a greedy strategy for maximising the number of row operations that can be done in parallel.</p>
</blockquote>
<p>I would like to understand better such a method.
What observation can be made? E.g. What is the relation between the diagonal and the CNOTs? What freedom do we have when selecting a row/operation to synthesise?</p>
",qc,cnot circuit synthesis gauss elimination explanation beyond p https nofollow noreferrer paper introduces synthesis optimal circuit cnots starting parity map encoded p based em gaussian elimination p important result find revisits make work topology constrained p example https nofollow noreferrer https presents em combination compliant p authors state synthesis freedom choice greedily choose one maximise parallelism blockquote p note phase strong freedom choose row operations perform taken greedy strategy maximising number row operations done p would like understand better method observation made relation diagonal cnots freedom selecting synthesise,"[(5, 0.038246565), (7, 0.090004146), (8, 0.0770453), (9, 0.5045683), (11, 0.013831489), (12, 0.012142636), (13, 0.12597387), (14, 0.105867095), (18, 0.031012654)]"
34640,34642.0,2023-10-29 18:05:37,2,100,"<p>Suppose I have a 2-qubit system in the first Bell state, <span class=""math-container"">$\left| \beta_{00} \right&gt;$</span>. I want to make the measurement in the computational/<span class=""math-container"">$Z$</span>-basis on the first qubit, say qubit <span class=""math-container"">$A$</span>. That means I am calculating the quantity <span class=""math-container"">$\left&lt; \beta_{00} \right| \big(  \left| 0_A \right&gt; \left&lt; 0_A \right| ⊗ 1_B \big) \left| \beta_{00} \right&gt;$</span>.</p>
<p>Ignoring the <span class=""math-container"">$\frac{1}{2}$</span> that comes up, how do I quickly calculate the quantity <span class=""math-container"">$\big( \left&lt;00 \right|+\left&lt; 11 \right|\big)\left| 0_A \right&gt; \left&lt; 0_A \right|$</span>? I am ignoring the second part of the equation because I am stuck on calculating this quantity itself. In the notes I have, the <span class=""math-container"">$\left&lt; 11 \right|$</span> is also struck out to be 0 without any explanation.</p>
<p>Is there a way to do these kinds of calculations quickly?</p>
",How can I simplify tensor product expressions quickly?,<measurement><terminology-and-notation><bell-basis>,1,1,,,"How can I simplify tensor product expressions quickly? <p>Suppose I have a 2-qubit system in the first Bell state, <span class=""math-container"">$\left| \beta_{00} \right&gt;$</span>. I want to make the measurement in the computational/<span class=""math-container"">$Z$</span>-basis on the first qubit, say qubit <span class=""math-container"">$A$</span>. That means I am calculating the quantity <span class=""math-container"">$\left&lt; \beta_{00} \right| \big(  \left| 0_A \right&gt; \left&lt; 0_A \right| ⊗ 1_B \big) \left| \beta_{00} \right&gt;$</span>.</p>
<p>Ignoring the <span class=""math-container"">$\frac{1}{2}$</span> that comes up, how do I quickly calculate the quantity <span class=""math-container"">$\big( \left&lt;00 \right|+\left&lt; 11 \right|\big)\left| 0_A \right&gt; \left&lt; 0_A \right|$</span>? I am ignoring the second part of the equation because I am stuck on calculating this quantity itself. In the notes I have, the <span class=""math-container"">$\left&lt; 11 \right|$</span> is also struck out to be 0 without any explanation.</p>
<p>Is there a way to do these kinds of calculations quickly?</p>
",qc,simplify tensor product expressions quickly p suppose system first bell state span 00 gt want make measurement span z first qubit say qubit span means calculating quantity span lt 00 gt lt 00 gt p ignoring span 1 2 comes quickly calculate quantity span lt 00 lt 11 gt lt ignoring second part equation stuck calculating quantity notes span lt 11 also struck 0 without p way kinds calculations quickly,"[(0, 0.10803398), (3, 0.59483814), (6, 0.05909574), (12, 0.01129946), (18, 0.22458799)]"
34684,,2023-11-02 07:00:20,1,47,"<p>Let <span class=""math-container"">$\psi\rangle_{AB} = \sum_{i=1}^{d}\lambda_{i}|i_{A}\rangle |i_{B}\rangle$</span> be a state vector of a pure bipartite syste.</p>
<p>Now, <span class=""math-container"">$\rho_{AB} = |\psi\rangle\langle\psi| = \sum_{i=1}^{d} \lambda_{i}^{2}|i_{A}\rangle\langle i_{A}| \otimes |i_{B}\rangle \langle i_{B}|$</span>.</p>
<p>The reduced density operator for A, B is <span class=""math-container"">$\rho^{A} = \sum_{i=1}^{d}\lambda_{i}^{2}|i_{A}\rangle\langle i_{A}| , \rho^{B} = \sum_{i=1}^{d}\lambda_{i}^{2}|i_{B}\rangle\langle i_{B}|$</span></p>
<p>Suppose the set of eigenvalues for <span class=""math-container"">$\rho^{A}$</span>, <span class=""math-container"">$\rho^{B}$</span> is <span class=""math-container"">$S_{A} = {\lambda_{1}^{2}, ...}$</span>, <span class=""math-container"">$S_{B} = {\lambda_{1}^{2}, ...}$</span>.</p>
<blockquote>
<p>The schmidt coefficients are the square root of the eigenvalue of the two partial trace? [1]</p>
</blockquote>
<p>What does the above mean? Is the below accurate?</p>
<blockquote>
<p><span class=""math-container"">$\lambda_{i} = \sqrt{\lambda_{i}^{2}}$</span>?</p>
</blockquote>
<p>[1] <a href=""https://www.quantiki.org/wiki/bipartite-states-and-schmidt-decomposition#:%7E:text=The%20Schmidt%20coefficients%20%E2%88%9A%7E%CF%87,zero%20have%20the%20same%20multiplicity"" rel=""nofollow noreferrer"">https://www.quantiki.org/wiki/bipartite-states-and-schmidt-decomposition#:~:text=The%20Schmidt%20coefficients%20%E2%88%9A~%CF%87,zero%20have%20the%20same%20multiplicity</a>.</p>
",schmidt coefficients are the square root of the eigenvalue of the two partial trace of a density matrix,<linear-algebra><schmidt-decomposition>,0,6,,,"schmidt coefficients are the square root of the eigenvalue of the two partial trace of a density matrix <p>Let <span class=""math-container"">$\psi\rangle_{AB} = \sum_{i=1}^{d}\lambda_{i}|i_{A}\rangle |i_{B}\rangle$</span> be a state vector of a pure bipartite syste.</p>
<p>Now, <span class=""math-container"">$\rho_{AB} = |\psi\rangle\langle\psi| = \sum_{i=1}^{d} \lambda_{i}^{2}|i_{A}\rangle\langle i_{A}| \otimes |i_{B}\rangle \langle i_{B}|$</span>.</p>
<p>The reduced density operator for A, B is <span class=""math-container"">$\rho^{A} = \sum_{i=1}^{d}\lambda_{i}^{2}|i_{A}\rangle\langle i_{A}| , \rho^{B} = \sum_{i=1}^{d}\lambda_{i}^{2}|i_{B}\rangle\langle i_{B}|$</span></p>
<p>Suppose the set of eigenvalues for <span class=""math-container"">$\rho^{A}$</span>, <span class=""math-container"">$\rho^{B}$</span> is <span class=""math-container"">$S_{A} = {\lambda_{1}^{2}, ...}$</span>, <span class=""math-container"">$S_{B} = {\lambda_{1}^{2}, ...}$</span>.</p>
<blockquote>
<p>The schmidt coefficients are the square root of the eigenvalue of the two partial trace? [1]</p>
</blockquote>
<p>What does the above mean? Is the below accurate?</p>
<blockquote>
<p><span class=""math-container"">$\lambda_{i} = \sqrt{\lambda_{i}^{2}}$</span>?</p>
</blockquote>
<p>[1] <a href=""https://www.quantiki.org/wiki/bipartite-states-and-schmidt-decomposition#:%7E:text=The%20Schmidt%20coefficients%20%E2%88%9A%7E%CF%87,zero%20have%20the%20same%20multiplicity"" rel=""nofollow noreferrer"">https://www.quantiki.org/wiki/bipartite-states-and-schmidt-decomposition#:~:text=The%20Schmidt%20coefficients%20%E2%88%9A~%CF%87,zero%20have%20the%20same%20multiplicity</a>.</p>
",qc,schmidt coefficients square root eigenvalue two partial trace density matrix p let span ab b state vector pure bipartite p span ab 2 b b p reduced density operator b span 2 b 2 b b p suppose set eigenvalues span span b span 1 2 span b 1 2 blockquote p schmidt coefficients square root eigenvalue two partial trace 1 p mean accurate blockquote p span 2 p 1 https 7e 20schmidt 20coefficients 20 e2 88 9a 7e cf 87 zero 20have 20the 20same 20multiplicity nofollow noreferrer https 20schmidt 20coefficients 20 e2 88 cf 87 zero 20have 20the 20same 20multiplicity,"[(2, 0.105767585), (3, 0.66314954), (4, 0.06598699), (6, 0.023227936), (11, 0.057695072), (12, 0.08260266)]"
77430751,,2023-11-06 11:30:41,1,68,"<p>I am trying to optimize a Hamiltonian using QAOA in IBM Qiskit.</p>
<p>I used the following 'minimize' function to get my result. (I am not including the whole code because it will get unnecessarily long).</p>
<pre><code>   res = minimize(cost_func, x0, args=(ansatz, hamiltonian, estimator), method=&quot;COBYLA&quot;)
   res 
</code></pre>
<p>When I ran the problem on a 'ibmq qasm simulator' I got the following result:</p>
<pre><code>fun: -23.1424
   maxcv: 0.0
 message: 'Optimization terminated successfully.'
    nfev: 45
  status: 1
 success: True
       x: array([3.39824022, 4.17447906, 2.86297948, 3.1139919 ])
</code></pre>
<p>I got multiple attributes in the solution.</p>
<p>But when I ran this on an actual quantum computer (ibm brisbane), I used the same code and same variable 'res'; it went on Queue and I had to wait for around 4-5 hours. But after the job was done, I cannot get the value for res which was defined in the previous line of code.</p>
<pre><code>Traceback (most recent call last):
  Cell In[1], line 1
    res
NameError: name 'res' is not defined
</code></pre>
<p>And I tried using job.result() but that doesn't have the required attributes I got from the results of the simulator stored in variable 'res'.</p>
<p>How can I get the attributes such as res.x from the already completed job?</p>
",Retrieving result attributes in Qiskit,<quantum-computing><qiskit>,0,0,,,"Retrieving result attributes in Qiskit <p>I am trying to optimize a Hamiltonian using QAOA in IBM Qiskit.</p>
<p>I used the following 'minimize' function to get my result. (I am not including the whole code because it will get unnecessarily long).</p>
<pre><code>   res = minimize(cost_func, x0, args=(ansatz, hamiltonian, estimator), method=&quot;COBYLA&quot;)
   res 
</code></pre>
<p>When I ran the problem on a 'ibmq qasm simulator' I got the following result:</p>
<pre><code>fun: -23.1424
   maxcv: 0.0
 message: 'Optimization terminated successfully.'
    nfev: 45
  status: 1
 success: True
       x: array([3.39824022, 4.17447906, 2.86297948, 3.1139919 ])
</code></pre>
<p>I got multiple attributes in the solution.</p>
<p>But when I ran this on an actual quantum computer (ibm brisbane), I used the same code and same variable 'res'; it went on Queue and I had to wait for around 4-5 hours. But after the job was done, I cannot get the value for res which was defined in the previous line of code.</p>
<pre><code>Traceback (most recent call last):
  Cell In[1], line 1
    res
NameError: name 'res' is not defined
</code></pre>
<p>And I tried using job.result() but that doesn't have the required attributes I got from the results of the simulator stored in variable 'res'.</p>
<p>How can I get the attributes such as res.x from the already completed job?</p>
",so_new,retrieving result attributes qiskit p trying optimize hamiltonian using qaoa ibm p used following function get result including whole code get unnecessarily long pre code res minimize x0 ansatz hamiltonian estimator quot cobyla quot res p ran problem qasm simulator got following result pre code fun maxcv message terminated successfully nfev 45 status 1 success true x array p got multiple attributes p ran actual quantum computer ibm brisbane used code variable went queue wait around hours job done get value res defined previous line pre code traceback recent call last cell 1 line 1 res nameerror name defined p tried using required attributes got results simulator stored variable p get attributes already completed job,"[(0, 0.5443283), (1, 0.029316792), (12, 0.070071265), (14, 0.29937476), (19, 0.055605847)]"
34739,,2023-11-06 12:20:13,4,272,"<p>I am trying to optimize a Hamiltonian using QAOA in IBM Qiskit.</p>
<p>I used the following 'minimize' function to get my result. (I am not including the whole code because it will get unnecessarily long).</p>
<pre><code>   res = minimize(cost_func, x0, args=(ansatz, hamiltonian, estimator), method=&quot;COBYLA&quot;)
   res 
</code></pre>
<p>When I ran the problem on a 'ibmq qasm simulator' I got the following result:</p>
<pre><code>fun: -23.1424
   maxcv: 0.0
 message: 'Optimization terminated successfully.'
    nfev: 45
  status: 1
 success: True
       x: array([3.39824022, 4.17447906, 2.86297948, 3.1139919 ])
</code></pre>
<p>As you can see, I got multiple attributes in the solution.</p>
<p>But when I ran this on an actual quantum computer (ibm brisbane), I used the same code and same variable 'res'; it went on Queue and I had to wait for around 4-5 hours. But after the job was done, I cannot get the value for res which was defined in the previous line of code.</p>
<pre><code>Traceback (most recent call last):
  Cell In[1], line 1
    res
NameError: name 'res' is not defined
</code></pre>
<p>And I tried using job.result() but that doesn't have the required attributes I got from the results of the simulator stored in variable 'res'.</p>
<p>How can I get the attributes such as res.x from the already completed job? It is very much needed for my further work.</p>
",Retrieving job result attributes in Qiskit,<qiskit><quantum-algorithms><ibm-q-experience><qaoa><ibm-quantum-devices>,1,3,,,"Retrieving job result attributes in Qiskit <p>I am trying to optimize a Hamiltonian using QAOA in IBM Qiskit.</p>
<p>I used the following 'minimize' function to get my result. (I am not including the whole code because it will get unnecessarily long).</p>
<pre><code>   res = minimize(cost_func, x0, args=(ansatz, hamiltonian, estimator), method=&quot;COBYLA&quot;)
   res 
</code></pre>
<p>When I ran the problem on a 'ibmq qasm simulator' I got the following result:</p>
<pre><code>fun: -23.1424
   maxcv: 0.0
 message: 'Optimization terminated successfully.'
    nfev: 45
  status: 1
 success: True
       x: array([3.39824022, 4.17447906, 2.86297948, 3.1139919 ])
</code></pre>
<p>As you can see, I got multiple attributes in the solution.</p>
<p>But when I ran this on an actual quantum computer (ibm brisbane), I used the same code and same variable 'res'; it went on Queue and I had to wait for around 4-5 hours. But after the job was done, I cannot get the value for res which was defined in the previous line of code.</p>
<pre><code>Traceback (most recent call last):
  Cell In[1], line 1
    res
NameError: name 'res' is not defined
</code></pre>
<p>And I tried using job.result() but that doesn't have the required attributes I got from the results of the simulator stored in variable 'res'.</p>
<p>How can I get the attributes such as res.x from the already completed job? It is very much needed for my further work.</p>
",qc,retrieving job result attributes qiskit p trying optimize hamiltonian using qaoa ibm p used following function get result including whole code get unnecessarily long pre code res minimize x0 ansatz hamiltonian estimator quot cobyla quot res p ran problem qasm simulator got following result pre code fun maxcv message terminated successfully nfev 45 status 1 success true x array p see got multiple attributes p ran actual quantum computer ibm brisbane used code variable went queue wait around hours job done get value res defined previous line pre code traceback recent call last cell 1 line 1 res nameerror name defined p tried using required attributes got results simulator stored variable p get attributes already completed job much needed,"[(0, 0.5138469), (1, 0.028716134), (12, 0.06765769), (14, 0.32882893), (19, 0.059691045)]"
34885,,2023-11-17 02:42:59,3,131,"<p>I recently started learning about universal quantum computation using magic states, and I'm currently reading one of the <a href=""https://arxiv.org/abs/quant-ph/0403025"" rel=""nofollow noreferrer"">early papers</a> on the subject by Bravyi and Kitaev .</p>
<p>In the paper, they showed how copies of a single-qubit mixed state <span class=""math-container"">$\rho$</span> with relatively high fidelity between <span class=""math-container"">$\rho$</span> and a magic state could be &quot;distilled&quot; into a new mixed state with enhanced fidelity.</p>
<p>In particular, the paper had a nice geometric view of single-qubit mixed states. For example, those that were convex linear combinations of pure eigenstates of Pauli matrices lived within an octahedron inside the Bloch sphere. Such states (along with Clifford operations and Pauli measurements) could <em>not</em> be used for universal quantum computation. On the other hand, some of the mixed states outside the octahedron could be distilled to enhance their fidelity with the magic states.</p>
<p>However, it wasn't clear from the paper whether it might be the case that <em>all</em> mixed states outside of the octahedron could ultimately be distilled into magic states with some appropriate algorithm (the authors indeed flagged this as an interesting question). Is the answer now known?</p>
<p>To be explicit, can every <span class=""math-container"">$\rho = \frac{1}{2}(I + \rho_x \sigma^x + \rho_y \sigma^y + \rho_z \sigma^z)$</span> with <span class=""math-container"">$|\rho_x|+|\rho_y|+|\rho_z| &gt; 1$</span> be distilled to a magic state?</p>
<hr />
<p>I hope the answer is yes, because I would like it to be true that as soon as we can prepare a mixed state that is not a convex linear combination of eigenstates of Paulis, we have a resource that allows us to escape <a href=""https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem"" rel=""nofollow noreferrer"">Gottesman-Knill</a>.</p>
",Which single-qubit mixed states work for magic state distillation?,<quantum-state><universal-gates><magic-states>,1,1,,,"Which single-qubit mixed states work for magic state distillation? <p>I recently started learning about universal quantum computation using magic states, and I'm currently reading one of the <a href=""https://arxiv.org/abs/quant-ph/0403025"" rel=""nofollow noreferrer"">early papers</a> on the subject by Bravyi and Kitaev .</p>
<p>In the paper, they showed how copies of a single-qubit mixed state <span class=""math-container"">$\rho$</span> with relatively high fidelity between <span class=""math-container"">$\rho$</span> and a magic state could be &quot;distilled&quot; into a new mixed state with enhanced fidelity.</p>
<p>In particular, the paper had a nice geometric view of single-qubit mixed states. For example, those that were convex linear combinations of pure eigenstates of Pauli matrices lived within an octahedron inside the Bloch sphere. Such states (along with Clifford operations and Pauli measurements) could <em>not</em> be used for universal quantum computation. On the other hand, some of the mixed states outside the octahedron could be distilled to enhance their fidelity with the magic states.</p>
<p>However, it wasn't clear from the paper whether it might be the case that <em>all</em> mixed states outside of the octahedron could ultimately be distilled into magic states with some appropriate algorithm (the authors indeed flagged this as an interesting question). Is the answer now known?</p>
<p>To be explicit, can every <span class=""math-container"">$\rho = \frac{1}{2}(I + \rho_x \sigma^x + \rho_y \sigma^y + \rho_z \sigma^z)$</span> with <span class=""math-container"">$|\rho_x|+|\rho_y|+|\rho_z| &gt; 1$</span> be distilled to a magic state?</p>
<hr />
<p>I hope the answer is yes, because I would like it to be true that as soon as we can prepare a mixed state that is not a convex linear combination of eigenstates of Paulis, we have a resource that allows us to escape <a href=""https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem"" rel=""nofollow noreferrer"">Gottesman-Knill</a>.</p>
",qc,mixed states work magic state distillation p recently started learning universal quantum computation using magic states currently reading one https nofollow noreferrer early papers subject bravyi kitaev p paper showed copies mixed state span relatively high fidelity span magic state could quot distilled quot new mixed state enhanced p particular paper nice geometric view mixed states example convex linear combinations pure eigenstates pauli matrices lived within octahedron inside bloch sphere states along clifford operations pauli measurements could em used universal quantum computation hand mixed states outside octahedron could distilled enhance fidelity magic p however clear paper whether might case em mixed states outside octahedron could ultimately distilled magic states appropriate algorithm authors indeed flagged interesting question answer known p explicit every span 1 2 span gt 1 distilled magic state hr p hope answer yes would like true soon prepare mixed state convex linear combination eigenstates paulis resource allows us escape https e2 80 nofollow noreferrer,"[(3, 0.3694961), (5, 0.13721739), (7, 0.068005174), (8, 0.11074587), (9, 0.17794278), (12, 0.013847479), (13, 0.053846873), (18, 0.054390047), (19, 0.013775409)]"
35002,,2023-11-27 11:50:07,1,67,"<p>I would like to make a resource estimate based on Azure resource estimator.</p>
<p>However, the circuits I am interested in depend on some classical parameters: for this reason, I would like to make a modular script with sub-portions of the quantum circuits in separated parts.</p>
<p>I tried to do the following code (which does not work).</p>
<pre class=""lang-csharp prettyprint-override""><code>import qsharp.azure
targets = qsharp.azure.connect(
            resourceId = &quot;/subscriptions/MYSUBSCRIPTION&quot;,
            location = &quot;westeurope&quot;)
qsharp.azure.target(&quot;microsoft.estimator&quot;)
qsharp.azure.target(&quot;microsoft.estimator&quot;)

%%qsharp

open Microsoft.Quantum.Intrinsic;
open Microsoft.Quantum.Diagnostics;
open Microsoft.Quantum.Math;
open Microsoft.Quantum.Arrays;

operation subCircuit(q: Qubit[], x: Array[], n: Int) {
    for index in 0 .. n
    {
       H(q[index]); // Apply Hadamard on qubit &quot;index&quot;
       Rx(2.0*x[index],q[index]); // After the Hadamard, apply a Rx rotation on the qubit &quot;index&quot; of angle 2.0*x[index]
    }
}

operation AlgoTest() : Result[] {
    let n=3; // Number of qubits
    let x=[0.,1.,2.]; // Vector x
    mutable resultArray = [Zero, size = 3];
    use q = Qubit[n];
    subCircuit(q,x,n);

    for i in IndexRange(q) {
                set resultArray w/= i &lt;- M(q[i]);
            }
    return resultArray;
}

result = qsharp.azure.execute(AlgoTest)
</code></pre>
<p>My questions:</p>
<p>As you see, I wanted to separate a sub-portion of my example algorithm <code>subCircuit</code> inside another function <code>AlgoTest</code>. However, the script returns several errors.</p>
<p>I know that I am probably not using good syntax, in particular, to define operation subCircuit, but this is precisely why I am asking this question. I looked at the <a href=""https://learn.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/operationsandfunctions"" rel=""nofollow noreferrer"">documentation of operations and functions</a> but the explanations are very obscure. Having an example of a working script doing what I want would be helpful for me to understand the syntax.</p>
<p>The errors returned are below (but overall I am not surprized there are errors because I am not using the good syntax, my question is precisely to understand which syntax is expected by the program, which is not very clear from the documentations -- perhaps I am not looking at the good place --):</p>
<blockquote>
<p>fail: Microsoft.Quantum.IQSharp.Snippets[0]
QS3212 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
Expecting return type annotation. The argument tuple needs to be
followed by a colon and the return type of the callable. fail:
Microsoft.Quantum.IQSharp.Snippets[0]
QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
Unexpected code fragment. fail: Microsoft.Quantum.IQSharp.Snippets[0]
QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
An expression used as a statement must be a call expression. fail:
Microsoft.Quantum.IQSharp.Snippets[0]
QS6005 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
No type with the name &quot;Array&quot; exists in any of the open namespaces.
/snippet_.qs(7,53): error QS3212: Expecting return type annotation.
The argument tuple needs to be followed by a colon and the return type
of the callable. /snippet_.qs(28,8): error QS3035: Unexpected code
fragment. /snippet_.qs(28,1): error QS3036: An expression used as a
statement must be a call expression. /snippet_.qs(7,37): error QS6005:
No type with the name &quot;Array&quot; exists in any of the open namespaces.</p>
</blockquote>
",Q#: how to write an algorithm in modular form (I don't understand the syntax and the documentation is a bit obscure),<q#><azure-quantum>,1,2,,,"Q#: how to write an algorithm in modular form (I don't understand the syntax and the documentation is a bit obscure) <p>I would like to make a resource estimate based on Azure resource estimator.</p>
<p>However, the circuits I am interested in depend on some classical parameters: for this reason, I would like to make a modular script with sub-portions of the quantum circuits in separated parts.</p>
<p>I tried to do the following code (which does not work).</p>
<pre class=""lang-csharp prettyprint-override""><code>import qsharp.azure
targets = qsharp.azure.connect(
            resourceId = &quot;/subscriptions/MYSUBSCRIPTION&quot;,
            location = &quot;westeurope&quot;)
qsharp.azure.target(&quot;microsoft.estimator&quot;)
qsharp.azure.target(&quot;microsoft.estimator&quot;)

%%qsharp

open Microsoft.Quantum.Intrinsic;
open Microsoft.Quantum.Diagnostics;
open Microsoft.Quantum.Math;
open Microsoft.Quantum.Arrays;

operation subCircuit(q: Qubit[], x: Array[], n: Int) {
    for index in 0 .. n
    {
       H(q[index]); // Apply Hadamard on qubit &quot;index&quot;
       Rx(2.0*x[index],q[index]); // After the Hadamard, apply a Rx rotation on the qubit &quot;index&quot; of angle 2.0*x[index]
    }
}

operation AlgoTest() : Result[] {
    let n=3; // Number of qubits
    let x=[0.,1.,2.]; // Vector x
    mutable resultArray = [Zero, size = 3];
    use q = Qubit[n];
    subCircuit(q,x,n);

    for i in IndexRange(q) {
                set resultArray w/= i &lt;- M(q[i]);
            }
    return resultArray;
}

result = qsharp.azure.execute(AlgoTest)
</code></pre>
<p>My questions:</p>
<p>As you see, I wanted to separate a sub-portion of my example algorithm <code>subCircuit</code> inside another function <code>AlgoTest</code>. However, the script returns several errors.</p>
<p>I know that I am probably not using good syntax, in particular, to define operation subCircuit, but this is precisely why I am asking this question. I looked at the <a href=""https://learn.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/operationsandfunctions"" rel=""nofollow noreferrer"">documentation of operations and functions</a> but the explanations are very obscure. Having an example of a working script doing what I want would be helpful for me to understand the syntax.</p>
<p>The errors returned are below (but overall I am not surprized there are errors because I am not using the good syntax, my question is precisely to understand which syntax is expected by the program, which is not very clear from the documentations -- perhaps I am not looking at the good place --):</p>
<blockquote>
<p>fail: Microsoft.Quantum.IQSharp.Snippets[0]
QS3212 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
Expecting return type annotation. The argument tuple needs to be
followed by a colon and the return type of the callable. fail:
Microsoft.Quantum.IQSharp.Snippets[0]
QS3035 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
Unexpected code fragment. fail: Microsoft.Quantum.IQSharp.Snippets[0]
QS3036 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
An expression used as a statement must be a call expression. fail:
Microsoft.Quantum.IQSharp.Snippets[0]
QS6005 (/snippet_.qs:Microsoft.VisualStudio.LanguageServer.Protocol.Range):
No type with the name &quot;Array&quot; exists in any of the open namespaces.
/snippet_.qs(7,53): error QS3212: Expecting return type annotation.
The argument tuple needs to be followed by a colon and the return type
of the callable. /snippet_.qs(28,8): error QS3035: Unexpected code
fragment. /snippet_.qs(28,1): error QS3036: An expression used as a
statement must be a call expression. /snippet_.qs(7,37): error QS6005:
No type with the name &quot;Array&quot; exists in any of the open namespaces.</p>
</blockquote>
",qc,q write algorithm modular form understand syntax documentation bit obscure p would like make resource estimate based azure resource p however circuits interested depend classical parameters reason would like make modular script quantum circuits separated p tried following code work pre code import targets resourceid quot quot location quot westeurope quot quot quot quot quot qsharp open open open open operation subcircuit q qubit x array n int index 0 n h q index apply hadamard qubit quot index quot rx x index q index hadamard apply rx rotation qubit quot index quot angle x index operation algotest result let number qubits let vector x mutable resultarray zero size 3 use q qubit n subcircuit q x n indexrange q set resultarray lt q return resultarray result algotest p questions p see wanted separate example algorithm code subcircuit inside another function code algotest however script returns several p know probably using good syntax particular define operation subcircuit precisely asking question looked https nofollow noreferrer documentation operations functions explanations obscure example working script want would helpful understand p errors returned overall surprized errors using good syntax question precisely understand syntax expected program clear documentations perhaps looking good place blockquote p fail 0 qs3212 expecting return type annotation argument tuple needs followed colon return type callable fail 0 qs3035 unexpected code fragment fail 0 qs3036 expression used statement must call expression fail 0 qs6005 type name quot array quot exists open namespaces error qs3212 expecting return type annotation argument tuple needs followed colon return type callable error qs3035 unexpected code fragment error qs3036 expression used statement must call expression error qs6005 type name quot array quot exists open,"[(0, 0.18962738), (2, 0.01954181), (5, 0.043271247), (8, 0.0669847), (9, 0.07567473), (10, 0.076067105), (12, 0.021368634), (13, 0.22870821), (14, 0.1780965), (19, 0.100284725)]"
35020,,2023-11-28 17:28:44,1,53,"<p>In <a href=""https://arxiv.org/pdf/1810.03787.pdf"" rel=""nofollow noreferrer"">Iris Cong et. al. (2019)</a> they propose a Quantum Convolutional Neural Network that utilizes mid-circuit measurements to control an error-correcting ansatz <span class=""math-container"">$V_j$</span>. This is the equivalent of a pooling layer and is used to reduce the dimensionality of the state.</p>
<p>I'm trying to wrap my head around it, and I have a few questions:</p>
<ul>
<li>What's the motivation for error correction in this context, and why should it improve the results?</li>
<li>It's unclear from the paper which <span class=""math-container"">$V_j$</span> pooling ansatz they use, but I found two implementations using two different schemas <a href=""https://www.tensorflow.org/quantum/tutorials/qcnn"" rel=""nofollow noreferrer"">this</a> and <a href=""https://qiskit.org/ecosystem/machine-learning/tutorials/11_quantum_convolutional_neural_networks.html"" rel=""nofollow noreferrer"">this</a>. Is there a reason why those specific ansatz are used? And how can I select one for my specific application?</li>
</ul>
<p>Any suggestions or pointers to further material are welcome.</p>
",Effect of error correction gates in QCNN,<error-correction><machine-learning><quantum-neural-network>,0,5,,,"Effect of error correction gates in QCNN <p>In <a href=""https://arxiv.org/pdf/1810.03787.pdf"" rel=""nofollow noreferrer"">Iris Cong et. al. (2019)</a> they propose a Quantum Convolutional Neural Network that utilizes mid-circuit measurements to control an error-correcting ansatz <span class=""math-container"">$V_j$</span>. This is the equivalent of a pooling layer and is used to reduce the dimensionality of the state.</p>
<p>I'm trying to wrap my head around it, and I have a few questions:</p>
<ul>
<li>What's the motivation for error correction in this context, and why should it improve the results?</li>
<li>It's unclear from the paper which <span class=""math-container"">$V_j$</span> pooling ansatz they use, but I found two implementations using two different schemas <a href=""https://www.tensorflow.org/quantum/tutorials/qcnn"" rel=""nofollow noreferrer"">this</a> and <a href=""https://qiskit.org/ecosystem/machine-learning/tutorials/11_quantum_convolutional_neural_networks.html"" rel=""nofollow noreferrer"">this</a>. Is there a reason why those specific ansatz are used? And how can I select one for my specific application?</li>
</ul>
<p>Any suggestions or pointers to further material are welcome.</p>
",qc,effect error correction gates qcnn p https nofollow noreferrer iris cong et al 2019 propose quantum convolutional neural network utilizes measurements control ansatz span equivalent pooling layer used reduce dimensionality p trying wrap head around questions ul li motivation error correction context improve results li unclear paper span pooling ansatz use found two implementations using two different schemas https nofollow noreferrer https nofollow noreferrer reason specific ansatz used select one specific application p suggestions pointers material,"[(4, 0.098868966), (5, 0.10408658), (8, 0.22920077), (9, 0.45234072), (11, 0.013008777), (12, 0.054426577), (13, 0.046335433)]"
35047,,2023-12-01 06:36:18,2,252,"<p>I made an svg diagram from a stim circuit:</p>
<pre class=""lang-python prettyprint-override""><code>import stim
circuit = stim.Circuit(&quot;&quot;&quot;
    H 0
    CX 0 1
    M 0 1
&quot;&quot;&quot;)
diagram = circuit.diagram(&quot;timeline-svg&quot;)
display(diagram)
</code></pre>
<blockquote>
<p><a href=""https://i.sstatic.net/dMv9v.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dMv9v.png"" alt=""enter image description here"" /></a></p>
</blockquote>
<p>I tried to write the diagram to a file, but I got an error:</p>
<pre class=""lang-python prettyprint-override""><code>with open('diagram.svg', 'w') as f:
    f.write(diagram)
</code></pre>
<pre><code>TypeError: write() argument must be str, not stim._DiagramHelper
</code></pre>
<p>How do I save the diagram to an SVG image file?</p>
",How do I write a stim diagram to a file?,<stim>,1,1,,,"How do I write a stim diagram to a file? <p>I made an svg diagram from a stim circuit:</p>
<pre class=""lang-python prettyprint-override""><code>import stim
circuit = stim.Circuit(&quot;&quot;&quot;
    H 0
    CX 0 1
    M 0 1
&quot;&quot;&quot;)
diagram = circuit.diagram(&quot;timeline-svg&quot;)
display(diagram)
</code></pre>
<blockquote>
<p><a href=""https://i.sstatic.net/dMv9v.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dMv9v.png"" alt=""enter image description here"" /></a></p>
</blockquote>
<p>I tried to write the diagram to a file, but I got an error:</p>
<pre class=""lang-python prettyprint-override""><code>with open('diagram.svg', 'w') as f:
    f.write(diagram)
</code></pre>
<pre><code>TypeError: write() argument must be str, not stim._DiagramHelper
</code></pre>
<p>How do I save the diagram to an SVG image file?</p>
",qc,write stim diagram file p made svg diagram stim circuit pre code import stim circuit quot quot quot h 0 cx 0 1 0 1 quot quot quot diagram quot quot display diagram blockquote p https nofollow noreferrer img https enter image description p tried write diagram file got error pre code open w f diagram pre code typeerror write argument must str p save diagram svg image file,"[(0, 0.21289529), (2, 0.06856723), (4, 0.39463064), (5, 0.06436781), (6, 0.023298733), (12, 0.027217684), (19, 0.20713903)]"
35074,,2023-12-03 12:06:39,0,9,"<h1>Background</h1>
<p>I'm testing out the ability of the Metal GUI to save a simple circuit but it keeps generating code that gives rise to various errors. In the below code for example generates an error show below the code. I'm running this in Jupyter Notebooks.</p>
<h3>Code</h3>
<pre><code>Readout_1 = RoutePathfinder(
design,
name='Readout_1',
options={'_actual_length': '4.018685284646162 '
                   'mm',
 'anchors': {0: array([ 1.65, -0.8 ])},
 'fillet': '90um',
 'hfss_wire_bonds': True,
 'lead': {'end_jogged_extension': '',
          'end_straight': '200um',
          'start_jogged_extension': '',
          'start_straight': '200um'},
 'pin_inputs': {'end_pin': {'component': 'Cap_Readout_1',
                            'pin': 'north_end'},
                'start_pin': {'component': 'Q_1',
                              'pin': 'B3'}},
 'trace_gap': 'cpw_gap'},

type='CPW',
)
</code></pre>
<h3>Error</h3>
<p>TypeError                                 Traceback (most recent call last)
Cell In[22], line 6
1 Readout_1 = RoutePathfinder(
2 design,
3 name='Readout_1',
4 options={'_actual_length': '4.018685284646162 '
5                    'mm',
----&gt; 6  'anchors': {0: array([ 1.65, -0.8 ])},
7  'fillet': '90um',
8  'hfss_wire_bonds': True,
9  'lead': {'end_jogged_extension': '',
10           'end_straight': '200um',
11           'start_jogged_extension': '',
12           'start_straight': '200um'},
13  'pin_inputs': {'end_pin': {'component': 'Cap_Readout_1',
14                             'pin': 'north_end'},
15                 'start_pin': {'component': 'Q_1',
16                               'pin': 'B3'}},
17  'trace_gap': 'cpw_gap'},
18
19 type='CPW',
20 )</p>
<p>TypeError: array() argument 1 must be a unicode character, not list</p>
<h1>Question</h1>
<p>How can I fix this error? Is there a missing important statement or do I need to change the generated/saved code?</p>
",QISKIT Metal Saves Error Generating Python Code,<qiskit><programming>,0,0,,,"QISKIT Metal Saves Error Generating Python Code <h1>Background</h1>
<p>I'm testing out the ability of the Metal GUI to save a simple circuit but it keeps generating code that gives rise to various errors. In the below code for example generates an error show below the code. I'm running this in Jupyter Notebooks.</p>
<h3>Code</h3>
<pre><code>Readout_1 = RoutePathfinder(
design,
name='Readout_1',
options={'_actual_length': '4.018685284646162 '
                   'mm',
 'anchors': {0: array([ 1.65, -0.8 ])},
 'fillet': '90um',
 'hfss_wire_bonds': True,
 'lead': {'end_jogged_extension': '',
          'end_straight': '200um',
          'start_jogged_extension': '',
          'start_straight': '200um'},
 'pin_inputs': {'end_pin': {'component': 'Cap_Readout_1',
                            'pin': 'north_end'},
                'start_pin': {'component': 'Q_1',
                              'pin': 'B3'}},
 'trace_gap': 'cpw_gap'},

type='CPW',
)
</code></pre>
<h3>Error</h3>
<p>TypeError                                 Traceback (most recent call last)
Cell In[22], line 6
1 Readout_1 = RoutePathfinder(
2 design,
3 name='Readout_1',
4 options={'_actual_length': '4.018685284646162 '
5                    'mm',
----&gt; 6  'anchors': {0: array([ 1.65, -0.8 ])},
7  'fillet': '90um',
8  'hfss_wire_bonds': True,
9  'lead': {'end_jogged_extension': '',
10           'end_straight': '200um',
11           'start_jogged_extension': '',
12           'start_straight': '200um'},
13  'pin_inputs': {'end_pin': {'component': 'Cap_Readout_1',
14                             'pin': 'north_end'},
15                 'start_pin': {'component': 'Q_1',
16                               'pin': 'B3'}},
17  'trace_gap': 'cpw_gap'},
18
19 type='CPW',
20 )</p>
<p>TypeError: array() argument 1 must be a unicode character, not list</p>
<h1>Question</h1>
<p>How can I fix this error? Is there a missing important statement or do I need to change the generated/saved code?</p>
",qc,qiskit metal saves error generating python code h1 background p testing ability metal gui save simple circuit keeps generating code gives rise various errors code example generates error show code running jupyter h3 code pre code routepathfinder design 0 array true h3 error p typeerror traceback recent call last cell 22 line 6 1 routepathfinder 2 design 3 4 5 gt 6 0 array 7 8 true 9 10 11 12 13 14 15 16 17 18 19 20 p typeerror array argument 1 must unicode character list h1 question p fix error missing important statement need change code,"[(0, 0.22949988), (3, 0.016824948), (6, 0.28215846), (8, 0.04633387), (12, 0.011399027), (14, 0.41236946)]"
35152,,2023-12-10 17:38:45,1,45,"<p>With the following code</p>
<pre><code>from qiskit.providers.fake_provider import FakeGuadalupe
from qiskit.providers.aer.noise import NoiseModel
import numpy as np

backend = FakeGuadalupe()
nm = NoiseModel.from_backend(backend)

print(nm._local_quantum_errors['cx'][(0,1)].circuits[0])
print(len(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params))

k11=np.transpose(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[0].conj())*nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[0]
k22=np.transpose(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[1].conj())*nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[1]
k33=np.transpose(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[2].conj())*nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[2]
print(k11+k22+k33)
</code></pre>
<p>I get the following output:</p>
<pre><code>     ┌────────────┐┌───────┐
q_0: ┤0           ├┤ kraus ├
     │  Pauli(II) │├───────┤
q_1: ┤1           ├┤ kraus ├
     └────────────┘└───────┘
3
[[1.        +0.j 0.        +0.j]
 [0.        +0.j 0.99257842+0.j]]
</code></pre>
<p>But I think that this means that the completeness relation of the kraus operators is not satisfied. Am I missing anything?</p>
",Completeness relation of kraus operators not satisfied in Fake backends,<qiskit><noise><kraus-representation>,0,1,,,"Completeness relation of kraus operators not satisfied in Fake backends <p>With the following code</p>
<pre><code>from qiskit.providers.fake_provider import FakeGuadalupe
from qiskit.providers.aer.noise import NoiseModel
import numpy as np

backend = FakeGuadalupe()
nm = NoiseModel.from_backend(backend)

print(nm._local_quantum_errors['cx'][(0,1)].circuits[0])
print(len(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params))

k11=np.transpose(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[0].conj())*nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[0]
k22=np.transpose(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[1].conj())*nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[1]
k33=np.transpose(nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[2].conj())*nm._local_quantum_errors['cx'][(0,1)].circuits[0][1][0].params[2]
print(k11+k22+k33)
</code></pre>
<p>I get the following output:</p>
<pre><code>     ┌────────────┐┌───────┐
q_0: ┤0           ├┤ kraus ├
     │  Pauli(II) │├───────┤
q_1: ┤1           ├┤ kraus ├
     └────────────┘└───────┘
3
[[1.        +0.j 0.        +0.j]
 [0.        +0.j 0.99257842+0.j]]
</code></pre>
<p>But I think that this means that the completeness relation of the kraus operators is not satisfied. Am I missing anything?</p>
",qc,completeness relation kraus operators satisfied fake backends p following code pre code import fakeguadalupe import noisemodel import numpy np backend fakeguadalupe nm backend print 0 print len 0 1 0 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 print p get following output pre code kraus pauli ii kraus 3 1 0 0 p think means completeness relation kraus operators satisfied missing anything,"[(0, 0.2641908), (2, 0.4363987), (3, 0.23478523), (12, 0.022832096), (14, 0.039893)]"
35162,,2023-12-11 13:22:57,1,193,"<p>I'm trying to run state tomography on a custom pulse gate (currently just a CR(pi/4) pulse) and any attempt to run it on an IBM backend gives a maximum allowed dimension exceeded error. The code runs fine for any standard gates on the backend.</p>
<p>All the potentially relevant code is:</p>
<pre><code>from qiskit_experiments.library import StateTomography
from qiskit import pulse

service = QiskitRuntimeService()
backend = service.get_backend(name='ibm_kyoto')

#Extracts the CR(pi/4) pulse
from qiskit.pulse import Play

backend_defaults = backend.defaults()
inst_sched_map = backend_defaults.instruction_schedule_map 
cr_pulse = inst_sched_map.get('ecr', (1,0)).filter(channels = [ControlChannel(1)], instruction_types=[Play]).instructions[0][1].pulse

with pulse.build(backend, name=&quot;Default CR&quot;) as cr_sched_default:
        pulse.play(cr_pulse, ControlChannel(1))


from qiskit.circuit import Gate
from qiskit.pulse import builder
from qiskit.transpiler import InstructionProperties

# Makes the circuit, turns it into a schedule
circ = QuantumCircuit(4)
custom_gate = Gate('cr', num_qubits=2, params=[])
circ.add_calibration('cr', [0,1], cr_sched_default)
circ.append(custom_gate, [0,1])


backend.target.add_instruction(
    custom_gate, 
    {(0,1): InstructionProperties(calibration=cr_sched_default)},
)
circ = transpile(circ, backend)

#runs the state tomography and returns the results
from qiskit_ibm_provider import IBMProvider

provider = IBMProvider()
backend = provider.get_backend(name='ibm_kyoto')

with backend.open_session() as session:
    qstexp = StateTomography(circ, measurement_indices=[0,1])
    qstdata = qstexp.run(backend).block_for_results()

    for result in qstdata.analysis_results():
        print(result)
    state_result = qstdata.analysis_results(&quot;state&quot;)
    print(state_result.value)
</code></pre>
<p>Much of the code comes from the qiskit textbook: <a href=""https://github.com/Qiskit/textbook/blob/main/notebooks/quantum-hardware-pulses/hamiltonian-tomography.ipynb"" rel=""nofollow noreferrer"">https://github.com/Qiskit/textbook/blob/main/notebooks/quantum-hardware-pulses/hamiltonian-tomography.ipynb</a></p>
<p>The error is:</p>
<pre><code>ValueError                                Traceback (most recent call last)
Cell In[97], line 10
      6 backend = provider.get_backend(name='ibm_kyoto')
      9 with backend.open_session() as session:
---&gt; 10     qstexp = StateTomography(circ, measurement_indices=[0,1])
     11     qstdata = qstexp.run(backend).block_for_results()
     13     for result in qstdata.analysis_results():

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit_experiments\warnings.py:169, in deprecate_arguments.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
    160 if kwargs:
    161     _rename_kwargs(
    162         args[0].__class__.__name__ + &quot;.&quot; + func.__name__,
    163         kwargs,
   (...)
    167         stacklevel,
    168     )
--&gt; 169 return func(*args, **kwargs)

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit_experiments\library\tomography\qst_experiment.py:122, in StateTomography.__init__(self, circuit, backend, physical_qubits, measurement_basis, measurement_indices, basis_indices, conditional_circuit_clbits, analysis, target)
    120 if isinstance(self.analysis, TomographyAnalysis):
    121     if target == &quot;default&quot;:
--&gt; 122         target = self._target_quantum_state()
    123     self.analysis.set_options(target=target)

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit_experiments\library\tomography\qst_experiment.py:138, in StateTomography._target_quantum_state(self)
    136         state = DensityMatrix(circuit)
    137     else:
--&gt; 138         state = Statevector(circuit)
    139 except QiskitError:
    140     # Circuit couldn't be simulated
    141     return None

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit\quantum_info\states\statevector.py:91, in Statevector.__init__(self, data, dims)
     89     self._data = np.ravel(data.data)
     90 elif isinstance(data, (QuantumCircuit, Instruction)):
---&gt; 91     self._data = Statevector.from_instruction(data).data
     92 else:
     93     raise QiskitError(&quot;Invalid input data format for Statevector&quot;)

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit\quantum_info\states\statevector.py:765, in Statevector.from_instruction(cls, instruction)
    763     instruction = instruction.to_instruction()
    764 # Initialize an the statevector in the all |0&gt; state
--&gt; 765 init = np.zeros(2**instruction.num_qubits, dtype=complex)
    766 init[0] = 1.0
    767 vec = Statevector(init, dims=instruction.num_qubits * (2,))

ValueError: Maximum allowed dimension exceeded
</code></pre>
<p>Does anyone know what am I missing?</p>
",Qiskit experiments state tomography maximum allowed dimension exceeded for pulse gates,<qiskit><state-tomography><qiskit-runtime>,1,0,,,"Qiskit experiments state tomography maximum allowed dimension exceeded for pulse gates <p>I'm trying to run state tomography on a custom pulse gate (currently just a CR(pi/4) pulse) and any attempt to run it on an IBM backend gives a maximum allowed dimension exceeded error. The code runs fine for any standard gates on the backend.</p>
<p>All the potentially relevant code is:</p>
<pre><code>from qiskit_experiments.library import StateTomography
from qiskit import pulse

service = QiskitRuntimeService()
backend = service.get_backend(name='ibm_kyoto')

#Extracts the CR(pi/4) pulse
from qiskit.pulse import Play

backend_defaults = backend.defaults()
inst_sched_map = backend_defaults.instruction_schedule_map 
cr_pulse = inst_sched_map.get('ecr', (1,0)).filter(channels = [ControlChannel(1)], instruction_types=[Play]).instructions[0][1].pulse

with pulse.build(backend, name=&quot;Default CR&quot;) as cr_sched_default:
        pulse.play(cr_pulse, ControlChannel(1))


from qiskit.circuit import Gate
from qiskit.pulse import builder
from qiskit.transpiler import InstructionProperties

# Makes the circuit, turns it into a schedule
circ = QuantumCircuit(4)
custom_gate = Gate('cr', num_qubits=2, params=[])
circ.add_calibration('cr', [0,1], cr_sched_default)
circ.append(custom_gate, [0,1])


backend.target.add_instruction(
    custom_gate, 
    {(0,1): InstructionProperties(calibration=cr_sched_default)},
)
circ = transpile(circ, backend)

#runs the state tomography and returns the results
from qiskit_ibm_provider import IBMProvider

provider = IBMProvider()
backend = provider.get_backend(name='ibm_kyoto')

with backend.open_session() as session:
    qstexp = StateTomography(circ, measurement_indices=[0,1])
    qstdata = qstexp.run(backend).block_for_results()

    for result in qstdata.analysis_results():
        print(result)
    state_result = qstdata.analysis_results(&quot;state&quot;)
    print(state_result.value)
</code></pre>
<p>Much of the code comes from the qiskit textbook: <a href=""https://github.com/Qiskit/textbook/blob/main/notebooks/quantum-hardware-pulses/hamiltonian-tomography.ipynb"" rel=""nofollow noreferrer"">https://github.com/Qiskit/textbook/blob/main/notebooks/quantum-hardware-pulses/hamiltonian-tomography.ipynb</a></p>
<p>The error is:</p>
<pre><code>ValueError                                Traceback (most recent call last)
Cell In[97], line 10
      6 backend = provider.get_backend(name='ibm_kyoto')
      9 with backend.open_session() as session:
---&gt; 10     qstexp = StateTomography(circ, measurement_indices=[0,1])
     11     qstdata = qstexp.run(backend).block_for_results()
     13     for result in qstdata.analysis_results():

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit_experiments\warnings.py:169, in deprecate_arguments.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
    160 if kwargs:
    161     _rename_kwargs(
    162         args[0].__class__.__name__ + &quot;.&quot; + func.__name__,
    163         kwargs,
   (...)
    167         stacklevel,
    168     )
--&gt; 169 return func(*args, **kwargs)

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit_experiments\library\tomography\qst_experiment.py:122, in StateTomography.__init__(self, circuit, backend, physical_qubits, measurement_basis, measurement_indices, basis_indices, conditional_circuit_clbits, analysis, target)
    120 if isinstance(self.analysis, TomographyAnalysis):
    121     if target == &quot;default&quot;:
--&gt; 122         target = self._target_quantum_state()
    123     self.analysis.set_options(target=target)

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit_experiments\library\tomography\qst_experiment.py:138, in StateTomography._target_quantum_state(self)
    136         state = DensityMatrix(circuit)
    137     else:
--&gt; 138         state = Statevector(circuit)
    139 except QiskitError:
    140     # Circuit couldn't be simulated
    141     return None

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit\quantum_info\states\statevector.py:91, in Statevector.__init__(self, data, dims)
     89     self._data = np.ravel(data.data)
     90 elif isinstance(data, (QuantumCircuit, Instruction)):
---&gt; 91     self._data = Statevector.from_instruction(data).data
     92 else:
     93     raise QiskitError(&quot;Invalid input data format for Statevector&quot;)

File ~\AppData\Local\Programs\Python\Python312\Lib\site-packages\qiskit\quantum_info\states\statevector.py:765, in Statevector.from_instruction(cls, instruction)
    763     instruction = instruction.to_instruction()
    764 # Initialize an the statevector in the all |0&gt; state
--&gt; 765 init = np.zeros(2**instruction.num_qubits, dtype=complex)
    766 init[0] = 1.0
    767 vec = Statevector(init, dims=instruction.num_qubits * (2,))

ValueError: Maximum allowed dimension exceeded
</code></pre>
<p>Does anyone know what am I missing?</p>
",qc,qiskit experiments state tomography maximum allowed dimension exceeded pulse gates p trying run state tomography custom pulse gate currently cr pulse attempt run ibm backend gives maximum allowed dimension exceeded error code runs fine standard gates p potentially relevant code pre code import statetomography qiskit import pulse service qiskitruntimeservice backend extracts cr pulse import play channels controlchannel 1 play 0 1 backend quot default cr quot controlchannel 1 import gate import builder import instructionproperties makes circuit turns schedule circ quantumcircuit 4 gate instructionproperties circ transpile circ backend runs state tomography returns results import ibmprovider provider ibmprovider backend session qstexp statetomography circ qstdata backend result print result quot state quot print p much code comes qiskit textbook https nofollow noreferrer https p error pre code valueerror traceback recent call last cell 97 line 10 6 backend 9 session gt 10 qstexp statetomography circ 11 qstdata backend 13 result file lt locals gt lt locals gt args kwargs 160 kwargs 161 162 args 0 quot quot 163 kwargs 167 stacklevel 168 gt 169 return func args kwargs file self circuit backend analysis target 120 isinstance tomographyanalysis 121 target quot default quot gt 122 target 123 file self 136 state densitymatrix circuit 137 else gt 138 state statevector circuit 139 except qiskiterror 140 circuit could simulated 141 return none file self data dims 89 90 elif isinstance data quantumcircuit instruction gt 91 data 92 else 93 raise qiskiterror quot invalid input data format statevector quot file cls instruction 763 instruction 764 initialize statevector gt state gt 765 init 2 766 init 0 767 vec statevector init 2 valueerror maximum allowed dimension exceeded p anyone know missing,"[(0, 0.55869806), (4, 0.020770129), (6, 0.04032341), (12, 0.06109965), (13, 0.030607047), (14, 0.13125584), (19, 0.14688301)]"
35179,,2023-12-13 16:25:38,0,58,"<p>I am running an Estimator job using Session on an actual backend.</p>
<pre><code>from qiskit_ibm_runtime import Estimator, Session, Options

with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    job = estimator.run(circuit, observable, shots=1)
    print(f&quot;&gt;&gt;&gt; Job ID: {job.job_id()}&quot;)
    print(f&quot;&gt;&gt;&gt; Job Status: {job.status()}&quot;)
</code></pre>
<p>The following code prints the total number of jobs in queue.</p>
<pre><code>status = backend.status()
jobs_in_queue = status.pending_jobs

service.jobs(backend_name=backend)
print(jobs_in_queue)
</code></pre>
<p>And <code>job.status()</code> outputs the status.</p>
<p>Is there a way to get the position of the job in the queue? Something similar to <a href=""https://docs.quantum.ibm.com/api/qiskit/0.19/qiskit.providers.ibmq.job.QueueInfo"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/0.19/qiskit.providers.ibmq.job.QueueInfo</a>.</p>
<p>I am aware of this issue: <a href=""https://github.com/Qiskit/qiskit/issues/7865"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit/issues/7865</a>
I have commented on this thread asking for solution as well.</p>
<p>Thanks in advance.</p>
",I am running a IBM runtime estimator job. Is there anyway to retrieve the job position of the submitted job using Session?,<qiskit-runtime>,0,0,,,"I am running a IBM runtime estimator job. Is there anyway to retrieve the job position of the submitted job using Session? <p>I am running an Estimator job using Session on an actual backend.</p>
<pre><code>from qiskit_ibm_runtime import Estimator, Session, Options

with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    job = estimator.run(circuit, observable, shots=1)
    print(f&quot;&gt;&gt;&gt; Job ID: {job.job_id()}&quot;)
    print(f&quot;&gt;&gt;&gt; Job Status: {job.status()}&quot;)
</code></pre>
<p>The following code prints the total number of jobs in queue.</p>
<pre><code>status = backend.status()
jobs_in_queue = status.pending_jobs

service.jobs(backend_name=backend)
print(jobs_in_queue)
</code></pre>
<p>And <code>job.status()</code> outputs the status.</p>
<p>Is there a way to get the position of the job in the queue? Something similar to <a href=""https://docs.quantum.ibm.com/api/qiskit/0.19/qiskit.providers.ibmq.job.QueueInfo"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/0.19/qiskit.providers.ibmq.job.QueueInfo</a>.</p>
<p>I am aware of this issue: <a href=""https://github.com/Qiskit/qiskit/issues/7865"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit/issues/7865</a>
I have commented on this thread asking for solution as well.</p>
<p>Thanks in advance.</p>
",qc,running ibm runtime estimator job anyway retrieve job position submitted job using session p running estimator job using session actual pre code import estimator session options session session estimator estimator job circuit observable print f quot gt gt gt job id quot print f quot gt gt gt job status quot p following code prints total number jobs pre code status print p code outputs p way get position job queue something similar https nofollow noreferrer https p aware issue https nofollow noreferrer https commented thread asking solution p thanks,"[(0, 0.3200933), (4, 0.12933548), (12, 0.01095824), (13, 0.018534364), (14, 0.23854126), (19, 0.28098345)]"
35188,,2023-12-14 04:47:49,0,76,"<p>I am writing a small quantum program for supporting polynomial arithmetic, implemented from <a href=""https://arxiv.org/pdf/1910.02849.pdf"" rel=""nofollow noreferrer"">Space-efficient quantum multiplication of polynomials for binary finite fields with sub-quadratic Toffoli gate count</a> and <a href=""https://tches.iacr.org/index.php/TCHES/article/view/8741"" rel=""nofollow noreferrer"">Concrete quantum cryptanalysis of binary elliptic curves</a>. To run the code, I am using the <code>simulator_stabilizer</code> backend provided by IBM.</p>
<pre><code>service = QiskitRuntimeService()
qc = QuantumCircuit()
backend = service.backend(&quot;simulator_stabilizer&quot;)
</code></pre>
<p>However, when I run it, I get the following error:</p>
<pre><code>Traceback (most recent call last):                                                                                                                    
  File &quot;/home/adarsh/NITK/MP/Project/qbpolynomial.py&quot;, line 333, in &lt;module&gt;                                                                          
    print(qpoly3)                                                                                                                                     
  File &quot;/home/adarsh/NITK/MP/Project/qbpolynomial.py&quot;, line 300, in __str__                                                                           
    coeffs = self.measure()                                                                                                                           
  File &quot;/home/adarsh/NITK/MP/Project/qbpolynomial.py&quot;, line 221, in measure                                                                           
    return list(job.result().get_counts().keys())[0][::-1]                                                                                            
  File &quot;/home/adarsh/NITK/MP/venv/lib/python3.10/site-packages/qiskit_ibm_runtime/runtime_job.py&quot;, line 222, in result                                
    raise RuntimeJobFailureError(f&quot;Unable to retrieve job result. {error_message}&quot;)                                                                   
qiskit_ibm_runtime.exceptions.RuntimeJobFailureError: 'Unable to retrieve job result. TranspilerError: &quot;Unable to translate the operations in the circ
uit: [\'ccx\', \'measure\', \'x\', \'cx\', \'swap\'] to the backend\'s (or manually specified) target basis: [\'y\', \'sx\', \'if_else\', \'delay\', \
'swap\', \'save_amplitudes_sq\', \'while_loop\', \'snapshot\', \'z\', \'save_state\', \'continue_loop\', \'save_expval\', \'barrier\', \'cx\', \'for_l
oop\', \'save_probabilities_dict\', \'break_loop\', \'s\', \'sxdg\', \'cz\', \'sdg\', \'save_expval_var\', \'reset\', \'id\', \'save_clifford\', \'roe
rror\', \'quantum_channel\', \'measure\', \'h\', \'save_stabilizer\', \'cy\', \'save_probabilities\', \'qerror_loc\', \'x\', \'pauli\', \'set_stabiliz
er\']. This likely means the target basis is not universal or there are additional equivalence rules needed in the EquivalenceLibrary being used. For 
more details on this error see: https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.BasisTranslator.html#translation_errors'
</code></pre>
<p>This program works without issues when using the <code>AerSimulator</code> of Qiskit. Can anyone point out what is my mistake or guide me in the right direction?</p>
",TranspileError occurs when using Simulator Stabilizer,<qiskit><qiskit-runtime>,1,0,,,"TranspileError occurs when using Simulator Stabilizer <p>I am writing a small quantum program for supporting polynomial arithmetic, implemented from <a href=""https://arxiv.org/pdf/1910.02849.pdf"" rel=""nofollow noreferrer"">Space-efficient quantum multiplication of polynomials for binary finite fields with sub-quadratic Toffoli gate count</a> and <a href=""https://tches.iacr.org/index.php/TCHES/article/view/8741"" rel=""nofollow noreferrer"">Concrete quantum cryptanalysis of binary elliptic curves</a>. To run the code, I am using the <code>simulator_stabilizer</code> backend provided by IBM.</p>
<pre><code>service = QiskitRuntimeService()
qc = QuantumCircuit()
backend = service.backend(&quot;simulator_stabilizer&quot;)
</code></pre>
<p>However, when I run it, I get the following error:</p>
<pre><code>Traceback (most recent call last):                                                                                                                    
  File &quot;/home/adarsh/NITK/MP/Project/qbpolynomial.py&quot;, line 333, in &lt;module&gt;                                                                          
    print(qpoly3)                                                                                                                                     
  File &quot;/home/adarsh/NITK/MP/Project/qbpolynomial.py&quot;, line 300, in __str__                                                                           
    coeffs = self.measure()                                                                                                                           
  File &quot;/home/adarsh/NITK/MP/Project/qbpolynomial.py&quot;, line 221, in measure                                                                           
    return list(job.result().get_counts().keys())[0][::-1]                                                                                            
  File &quot;/home/adarsh/NITK/MP/venv/lib/python3.10/site-packages/qiskit_ibm_runtime/runtime_job.py&quot;, line 222, in result                                
    raise RuntimeJobFailureError(f&quot;Unable to retrieve job result. {error_message}&quot;)                                                                   
qiskit_ibm_runtime.exceptions.RuntimeJobFailureError: 'Unable to retrieve job result. TranspilerError: &quot;Unable to translate the operations in the circ
uit: [\'ccx\', \'measure\', \'x\', \'cx\', \'swap\'] to the backend\'s (or manually specified) target basis: [\'y\', \'sx\', \'if_else\', \'delay\', \
'swap\', \'save_amplitudes_sq\', \'while_loop\', \'snapshot\', \'z\', \'save_state\', \'continue_loop\', \'save_expval\', \'barrier\', \'cx\', \'for_l
oop\', \'save_probabilities_dict\', \'break_loop\', \'s\', \'sxdg\', \'cz\', \'sdg\', \'save_expval_var\', \'reset\', \'id\', \'save_clifford\', \'roe
rror\', \'quantum_channel\', \'measure\', \'h\', \'save_stabilizer\', \'cy\', \'save_probabilities\', \'qerror_loc\', \'x\', \'pauli\', \'set_stabiliz
er\']. This likely means the target basis is not universal or there are additional equivalence rules needed in the EquivalenceLibrary being used. For 
more details on this error see: https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.BasisTranslator.html#translation_errors'
</code></pre>
<p>This program works without issues when using the <code>AerSimulator</code> of Qiskit. Can anyone point out what is my mistake or guide me in the right direction?</p>
",qc,transpileerror occurs using simulator stabilizer p writing small quantum program supporting polynomial arithmetic implemented https nofollow noreferrer quantum multiplication polynomials binary finite fields toffoli gate count https nofollow noreferrer concrete quantum cryptanalysis binary elliptic curves run code using code backend provided pre code service qiskitruntimeservice qc quantumcircuit backend quot quot p however run get following error pre code traceback recent call last file quot quot line 333 lt module gt print qpoly3 file quot quot line 300 coeffs file quot quot line 221 measure return list 0 file quot quot line 222 result raise runtimejobfailureerror f quot unable retrieve job result quot retrieve job result transpilererror quot unable translate operations circ uit manually specified target basis likely means target basis universal additional equivalence rules needed equivalencelibrary used details error see https p program works without issues using code aersimulator qiskit anyone point mistake guide right direction,"[(0, 0.4664556), (1, 0.04320293), (4, 0.11499313), (5, 0.015379602), (7, 0.03787835), (9, 0.110342205), (12, 0.014222275), (19, 0.19668697)]"
35272,35277.0,2023-12-21 18:14:17,2,79,"<p>I have a quantum circuit with 4 input qubits, A, B, C, and D. A is at the top, D is at the bottom.</p>
<p>If I wanted to do a CNOT between B and C and leave A and D alone, I know the gate matrix for this would be computed as <span class=""math-container"">$$I \otimes CNOT \otimes I$$</span> where <span class=""math-container"">$I$</span> is the 2x2 identity matrix, <span class=""math-container"">$CNOT$</span> is the controlled not gate matrix, and <span class=""math-container"">$\otimes$</span> is tensor product.</p>
<p>But how do I compute the gate matrix if I want to CNOT A and D and leave B and C alone?</p>
<p>I've looked at <a href=""https://quantumcomputing.stackexchange.com/questions/34996/can-you-apply-a-cnot-gate-on-qubits-in-mbqc-that-aren%C2%B4t-next-to-each-other"">this question</a> and it seems close, but the MBQC terminology seems to be confusing everyone (including me).</p>
",How to compute the gate matrix for an operation on qubits not next to each other,<quantum-gate><quantum-circuit><matrix-representation>,1,0,,,"How to compute the gate matrix for an operation on qubits not next to each other <p>I have a quantum circuit with 4 input qubits, A, B, C, and D. A is at the top, D is at the bottom.</p>
<p>If I wanted to do a CNOT between B and C and leave A and D alone, I know the gate matrix for this would be computed as <span class=""math-container"">$$I \otimes CNOT \otimes I$$</span> where <span class=""math-container"">$I$</span> is the 2x2 identity matrix, <span class=""math-container"">$CNOT$</span> is the controlled not gate matrix, and <span class=""math-container"">$\otimes$</span> is tensor product.</p>
<p>But how do I compute the gate matrix if I want to CNOT A and D and leave B and C alone?</p>
<p>I've looked at <a href=""https://quantumcomputing.stackexchange.com/questions/34996/can-you-apply-a-cnot-gate-on-qubits-in-mbqc-that-aren%C2%B4t-next-to-each-other"">this question</a> and it seems close, but the MBQC terminology seems to be confusing everyone (including me).</p>
",qc,compute gate matrix operation qubits next p quantum circuit 4 input qubits b c top p wanted cnot b c leave alone know gate matrix would computed span cnot span 2x2 identity matrix span cnot controlled gate matrix span tensor p compute gate matrix want cnot leave b c alone p looked https c2 question seems close mbqc terminology seems confusing everyone including,"[(3, 0.3112547), (4, 0.090605006), (7, 0.022677168), (9, 0.18125004), (11, 0.09677839), (12, 0.016177824), (13, 0.062626585), (17, 0.04089548), (18, 0.17599341)]"
35281,,2023-12-22 04:13:19,2,89,"<p>I have an error when I want to run the <code>'LocalSimulator'</code>. I am not inside AWS, its mean I runnig from Google Colab. The code is the same on the notebooks from <a href=""https://amazon-braket-conexionaws.notebook.us-east-1.sagemaker.aws/lab/tree/Braket%20examples/getting_started/0_Getting_started/0_Getting_started.ipynb"" rel=""nofollow noreferrer"">0_Getting_started</a></p>
<pre><code>    # general imports
    import matplotlib.pyplot as plt
    %matplotlib inline

    # AWS imports: Import Braket SDK modules
    from braket.circuits import Circuit
    from braket.devices import LocalSimulator

    # build a Bell state with two qubits. Here 'cnot(control=0, target=1)' can be 
     simplified as 'cnot(0,1)'
    bell = Circuit().h(0).cnot(control=0, target=1)
    # set up device
    device = LocalSimulator()

    # run circuit
     result = device.run(bell, shots=1000).result()
    # get measurement shots
    counts = result.measurement_counts
    # print counts
    print(counts)
</code></pre>
<p>And the result is</p>
<p><code>ValueError: Only the following devices are available dict_keys([])</code></p>
",Error 'LocalSimulator' with Googlecolab,<textbook-and-exercises><simulation><amazon-braket>,1,3,,,"Error 'LocalSimulator' with Googlecolab <p>I have an error when I want to run the <code>'LocalSimulator'</code>. I am not inside AWS, its mean I runnig from Google Colab. The code is the same on the notebooks from <a href=""https://amazon-braket-conexionaws.notebook.us-east-1.sagemaker.aws/lab/tree/Braket%20examples/getting_started/0_Getting_started/0_Getting_started.ipynb"" rel=""nofollow noreferrer"">0_Getting_started</a></p>
<pre><code>    # general imports
    import matplotlib.pyplot as plt
    %matplotlib inline

    # AWS imports: Import Braket SDK modules
    from braket.circuits import Circuit
    from braket.devices import LocalSimulator

    # build a Bell state with two qubits. Here 'cnot(control=0, target=1)' can be 
     simplified as 'cnot(0,1)'
    bell = Circuit().h(0).cnot(control=0, target=1)
    # set up device
    device = LocalSimulator()

    # run circuit
     result = device.run(bell, shots=1000).result()
    # get measurement shots
    counts = result.measurement_counts
    # print counts
    print(counts)
</code></pre>
<p>And the result is</p>
<p><code>ValueError: Only the following devices are available dict_keys([])</code></p>
",qc,error googlecolab p error want run code inside aws mean runnig google colab code notebooks https nofollow noreferrer pre code general imports import plt matplotlib inline aws imports import braket sdk modules import circuit import localsimulator build bell state two qubits simplified bell circuit 0 set device device localsimulator run circuit result bell get measurement shots counts print counts print counts p result p code valueerror following devices available,"[(0, 0.4130085), (4, 0.09622813), (12, 0.049080182), (14, 0.28716898), (16, 0.026907543), (18, 0.108287245), (19, 0.017383516)]"
35305,,2023-12-25 17:23:59,1,92,"<p>This question should be theoretically simple, yet I'm struggling as something may be incorrect about my code. I am trying to plot a graph of the maximum probability (<span class=""math-container"">$P(x)$</span>) of a given system against CHSH violation values. We can do this using the expectation values through the NPA moment matrix and create an SDP where I maximise <span class=""math-container"">$(1+\langle A_0 \rangle)/2$</span>. This should give me <span class=""math-container"">$P(0)$</span>. The constraints lie in making sure the correct elements of the moment matrix sum up to a given CHSH value and the matrix is positive semi-definite.</p>
<p>However, I get values of 1 for all values of the inequality. Rather the curve should be around 1 for values 2 or less and curve to 1/2 for maximum violations of the CHSH Bell inequality (this is for two measurements). Are there more constraints to be added or am I missing something?</p>
<pre class=""lang-python prettyprint-override""><code>chsh_values = np.linspace(2, 2*np.sqrt(2), 100)
max_px_values = []
for chsh in chsh_values:
    # Define the moment matrix (5x5 for this setup)
    M = cp.Variable((5, 5), symmetric=True)

    # Objective function: Maximize (1 + &lt;A0&gt;) / 2
    objective = cp.Maximize((1 + M[0, 1]) / 2)

    # CHSH constraint
    constraints = [ 
                M[1, 3] + M[2, 3] + M[1, 4] - M[2, 4] == chsh, 
                M[0, 0] == 1, M[1, 1] == 1, M[2, 2] == 1, M[3, 3] == 1, M[4, 4] == 1,
                M &gt;&gt; 0,
                ]

    # Solve the problem
    prob = cp.Problem(objective, constraints)
    prob.solve(solver=cp.MOSEK)
       
    max_px_value = prob.value
    max_px_values.append(round(max_px_value, 3))

    # Print the moment matrix and the maximum value
    print(f&quot;CHSH Value: {chsh}&quot;)
    print(&quot;Moment Matrix:\n&quot;, M.value)
    print(&quot;Maximum (1 + expectation of A0) / 2:&quot;, max_px_value)
    print(&quot;--------------------------------------------------&quot;)
<span class=""math-container"">```</span>
</code></pre>
",Semi-Definite Program to maximise $P(X)$ with a fixed CHSH value,<programming><probability><bell-experiment><semidefinite-programming>,0,2,,,"Semi-Definite Program to maximise $P(X)$ with a fixed CHSH value <p>This question should be theoretically simple, yet I'm struggling as something may be incorrect about my code. I am trying to plot a graph of the maximum probability (<span class=""math-container"">$P(x)$</span>) of a given system against CHSH violation values. We can do this using the expectation values through the NPA moment matrix and create an SDP where I maximise <span class=""math-container"">$(1+\langle A_0 \rangle)/2$</span>. This should give me <span class=""math-container"">$P(0)$</span>. The constraints lie in making sure the correct elements of the moment matrix sum up to a given CHSH value and the matrix is positive semi-definite.</p>
<p>However, I get values of 1 for all values of the inequality. Rather the curve should be around 1 for values 2 or less and curve to 1/2 for maximum violations of the CHSH Bell inequality (this is for two measurements). Are there more constraints to be added or am I missing something?</p>
<pre class=""lang-python prettyprint-override""><code>chsh_values = np.linspace(2, 2*np.sqrt(2), 100)
max_px_values = []
for chsh in chsh_values:
    # Define the moment matrix (5x5 for this setup)
    M = cp.Variable((5, 5), symmetric=True)

    # Objective function: Maximize (1 + &lt;A0&gt;) / 2
    objective = cp.Maximize((1 + M[0, 1]) / 2)

    # CHSH constraint
    constraints = [ 
                M[1, 3] + M[2, 3] + M[1, 4] - M[2, 4] == chsh, 
                M[0, 0] == 1, M[1, 1] == 1, M[2, 2] == 1, M[3, 3] == 1, M[4, 4] == 1,
                M &gt;&gt; 0,
                ]

    # Solve the problem
    prob = cp.Problem(objective, constraints)
    prob.solve(solver=cp.MOSEK)
       
    max_px_value = prob.value
    max_px_values.append(round(max_px_value, 3))

    # Print the moment matrix and the maximum value
    print(f&quot;CHSH Value: {chsh}&quot;)
    print(&quot;Moment Matrix:\n&quot;, M.value)
    print(&quot;Maximum (1 + expectation of A0) / 2:&quot;, max_px_value)
    print(&quot;--------------------------------------------------&quot;)
<span class=""math-container"">```</span>
</code></pre>
",qc,program maximise p x fixed chsh value p question theoretically simple yet struggling something may incorrect code trying plot graph maximum probability span p x given system chsh violation values using expectation values npa moment matrix create sdp maximise span give span p 0 constraints lie making sure correct elements moment matrix sum given chsh value matrix positive p however get values 1 values inequality rather curve around 1 values 2 less curve maximum violations chsh bell inequality two measurements constraints added missing something pre code 2 2 2 100 chsh define moment matrix 5x5 setup 5 5 objective function maximize 1 lt a0 gt 2 objective 1 0 1 2 chsh constraint constraints 1 3 2 3 1 4 2 4 chsh 0 0 1 1 1 1 2 2 1 3 3 1 4 4 1 gt gt 0 solve problem prob objective constraints round 3 print moment matrix maximum value print f quot chsh value chsh quot print quot moment matrix quot print quot maximum 1 expectation a0 2 quot print quot quot span,"[(0, 0.26969928), (1, 0.024932856), (2, 0.20911641), (3, 0.12811922), (6, 0.022423277), (10, 0.018908449), (11, 0.07355493), (12, 0.011540425), (13, 0.036337268), (18, 0.14224288), (19, 0.05621658)]"
35306,,2023-12-25 18:15:50,3,90,"<p>I recently saw a piece of code that computes molecular bond energy with respect to bond length. I am trying to update the code to the newer qiskit framework (I'm running qiskit 0.45.1 and <code>qiskit-nature</code> instead of the depricated <code>qiskit.chemistry</code>). The complete original code is available as a <a href=""https://www.youtube.com/watch?v=Z-A6G0WVI9w&amp;t=1291s"" rel=""nofollow noreferrer"">video</a>, but I have extracted the relevant parts below.</p>
<p>In order to generate a qubit operator associated with the Hamiltonian in the process of finding the eigen energy, the older version of qiskit uses the class <code>qiskit.chemistry.core.Hamiltonian</code>, which does not exist anymore in <code>qiskit_nature</code>.</p>
<p>I'm wondering if there is an alternative way to generate the <code>qubitOp</code> such that I can use <code>NumPyMinimumEigensolver().run()</code> to find the exact bond energy? In other words, how can I make the following piece of code run correctly using <code>qiskit-nature</code>?</p>
<pre><code>driver = PySCFDriver(atom=moleculeRepr.format(dist/2), basis=&quot;sto3g&quot;)
molecule = driver.run()
operator = Hamiltonian(qubit_mapping=QubitMappingtype.PARITY, two_qubit_reduction=True, freeze_core=True,orbital_reduction=[-3, -2])
qubitOp, aux_ops = operator.run(molecule)

#classical result
exactResult = NumPyMinimumEigensolver(qubitOp, aux_operators=aux_ops).run()
exactResult = operator.process_algorithm_result(exactResult)
</code></pre>
<p>Any help or insights into this question would be greatly appreciated.</p>
",Updating qiskit.chemistry.core.Hamiltonian to qiskit-nature Framework,<qiskit><chemistry>,0,1,,,"Updating qiskit.chemistry.core.Hamiltonian to qiskit-nature Framework <p>I recently saw a piece of code that computes molecular bond energy with respect to bond length. I am trying to update the code to the newer qiskit framework (I'm running qiskit 0.45.1 and <code>qiskit-nature</code> instead of the depricated <code>qiskit.chemistry</code>). The complete original code is available as a <a href=""https://www.youtube.com/watch?v=Z-A6G0WVI9w&amp;t=1291s"" rel=""nofollow noreferrer"">video</a>, but I have extracted the relevant parts below.</p>
<p>In order to generate a qubit operator associated with the Hamiltonian in the process of finding the eigen energy, the older version of qiskit uses the class <code>qiskit.chemistry.core.Hamiltonian</code>, which does not exist anymore in <code>qiskit_nature</code>.</p>
<p>I'm wondering if there is an alternative way to generate the <code>qubitOp</code> such that I can use <code>NumPyMinimumEigensolver().run()</code> to find the exact bond energy? In other words, how can I make the following piece of code run correctly using <code>qiskit-nature</code>?</p>
<pre><code>driver = PySCFDriver(atom=moleculeRepr.format(dist/2), basis=&quot;sto3g&quot;)
molecule = driver.run()
operator = Hamiltonian(qubit_mapping=QubitMappingtype.PARITY, two_qubit_reduction=True, freeze_core=True,orbital_reduction=[-3, -2])
qubitOp, aux_ops = operator.run(molecule)

#classical result
exactResult = NumPyMinimumEigensolver(qubitOp, aux_operators=aux_ops).run()
exactResult = operator.process_algorithm_result(exactResult)
</code></pre>
<p>Any help or insights into this question would be greatly appreciated.</p>
",qc,updating framework p recently saw piece code computes molecular bond energy respect bond length trying update code newer qiskit framework running qiskit code instead depricated code complete original code available https amp nofollow noreferrer video extracted relevant parts p order generate qubit operator associated hamiltonian process finding eigen energy older version qiskit uses class code exist anymore code p wondering alternative way generate code qubitop use code numpyminimumeigensolver find exact bond energy words make following piece code run correctly using code pre code driver pyscfdriver quot sto3g quot molecule operator hamiltonian qubitop molecule classical result exactresult numpyminimumeigensolver qubitop exactresult exactresult p help insights question would greatly,"[(0, 0.1359077), (1, 0.04710412), (4, 0.031442836), (8, 0.15776142), (12, 0.06951162), (13, 0.06248302), (14, 0.3654815), (15, 0.010275818), (17, 0.09309772), (19, 0.025982445)]"
35381,35384.0,2024-01-05 10:50:36,2,84,"<p>I'm trying to understand the theory behind how a Stim Detector Error Model is created from a circuit. It is mentioned in the documentation that during analyzing the errors in the circuit, the circuit is analyzed <em>backwards</em>. What is the advantage of a backward analysis as compared to analysing the circuit forwards? Could you give me an example to show this advantage?</p>
",Advantage of backward analysis of a circuit over forward analysis in Stim,<quantum-circuit><stim>,1,0,,,"Advantage of backward analysis of a circuit over forward analysis in Stim <p>I'm trying to understand the theory behind how a Stim Detector Error Model is created from a circuit. It is mentioned in the documentation that during analyzing the errors in the circuit, the circuit is analyzed <em>backwards</em>. What is the advantage of a backward analysis as compared to analysing the circuit forwards? Could you give me an example to show this advantage?</p>
",qc,advantage backward analysis circuit forward analysis stim p trying understand theory behind stim detector error model created circuit mentioned documentation analyzing errors circuit circuit analyzed em backwards advantage backward analysis compared analysing circuit forwards could give example show advantage,"[(5, 0.10586422), (6, 0.03481862), (7, 0.31444213), (8, 0.10271417), (12, 0.025507074), (14, 0.36584148), (19, 0.047308974)]"
35401,,2024-01-08 04:49:25,1,288,"<p>I've lately been taking further coursework in abstract algebra, and it has struck me as fairly reminiscent of quantum computing. Of course, Pauli matrices, etc. have relevant roots within abstract algebra -- however, at a higher level (applications of quantum computing such as Grover's algorithm, decoherence and quantum information, etc.), how can quantum computing be understood through an algebraic framework?</p>
",How is Quantum Computing expressed in the language of abstract algebra?,<linear-algebra><information-theory><pauli-gates><decoherence>,1,7,,,"How is Quantum Computing expressed in the language of abstract algebra? <p>I've lately been taking further coursework in abstract algebra, and it has struck me as fairly reminiscent of quantum computing. Of course, Pauli matrices, etc. have relevant roots within abstract algebra -- however, at a higher level (applications of quantum computing such as Grover's algorithm, decoherence and quantum information, etc.), how can quantum computing be understood through an algebraic framework?</p>
",qc,quantum computing expressed language abstract algebra p lately taking coursework abstract algebra struck fairly reminiscent quantum computing course pauli matrices etc relevant roots within abstract algebra however higher level applications quantum computing grover algorithm decoherence quantum information etc quantum computing understood algebraic framework,"[(3, 0.108716324), (8, 0.6833127), (9, 0.04659559), (12, 0.047918648), (13, 0.10981033)]"
35495,,2024-01-16 09:40:50,0,90,"<p>I was wondering, how can one perform a multi-qubit rotation in Quirk?
For example, if I want to simulate the magic-state distillation protocol, I need e.g. a <span class=""math-container"">$(IIZZZ)_{\pi/8}$</span> rotation of 5 qubits. Is there a simple way to do it?</p>
",Multi-qubit rotation using Quirk,<quantum-gate><quirk>,1,0,,,"Multi-qubit rotation using Quirk <p>I was wondering, how can one perform a multi-qubit rotation in Quirk?
For example, if I want to simulate the magic-state distillation protocol, I need e.g. a <span class=""math-container"">$(IIZZZ)_{\pi/8}$</span> rotation of 5 qubits. Is there a simple way to do it?</p>
",qc,rotation using quirk p wondering one perform rotation quirk example want simulate distillation protocol need span iizzz rotation 5 qubits simple way,"[(5, 0.07751393), (6, 0.043036457), (9, 0.25320765), (12, 0.09647711), (14, 0.32602495), (18, 0.19713536)]"
35532,,2024-01-19 15:39:54,0,51,"<p>I'm going through this TensorFlow <a href=""https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning"" rel=""nofollow noreferrer"">tutorial</a> on quantum machine learning.  The code implements reinforcement learning algorithms based on parameterized/variational quantum circuits (PQCs or VQCs).</p>
<p>What is the difference between PQC and VQC?  Are they equivalent or are there subtle differences between them?  I'm trying to find literature that discusses this.</p>
",Difference between PQCs and VQCs,<quantum-algorithms><variational-quantum-algorithms>,0,0,,,"Difference between PQCs and VQCs <p>I'm going through this TensorFlow <a href=""https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning"" rel=""nofollow noreferrer"">tutorial</a> on quantum machine learning.  The code implements reinforcement learning algorithms based on parameterized/variational quantum circuits (PQCs or VQCs).</p>
<p>What is the difference between PQC and VQC?  Are they equivalent or are there subtle differences between them?  I'm trying to find literature that discusses this.</p>
",qc,difference pqcs vqcs p going tensorflow https nofollow noreferrer tutorial quantum machine learning code implements reinforcement learning algorithms based quantum circuits pqcs vqcs p difference pqc vqc equivalent subtle differences trying find literature discusses,"[(0, 0.07270347), (4, 0.11678524), (8, 0.5048974), (9, 0.15147458), (12, 0.118937925), (15, 0.031096915)]"
35719,,2024-02-04 08:00:49,1,200,"<h3>Background</h3>
<p>In 2022 Qiskit released a <a href=""https://www.youtube.com/watch?v=1oiYH87vx1A"" rel=""nofollow noreferrer"">very nice tutorial</a> detailing how the expectation value of an operator could be found using <code>CircuitOp</code>. As of 2024, these techniques (and others that I have found on the quantum computing stack exchange) are unusable as they are deprecated. The migration guide suggests using <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.Estimator"" rel=""nofollow noreferrer"">Estimators</a>. As a test, I tried writing some code to calculate the <em>exact</em> (non-simulated) expected value of <span class=""math-container"">$\langle0|H|0\rangle$</span> which, I believe, should be equal to <span class=""math-container"">$\dfrac{1}{\sqrt{2}}$</span>. Instead, I got <span class=""math-container"">$0.9999999999999999$</span>. I include my code below (as it is quite short).</p>
<h3>The Code</h3>
<pre><code>from qiskit import QuantumCircuit
from qiskit.primitives import Estimator

testCircuit = QuantumCircuit(1)
testCircuit.h(0)

estimator = Estimator()

result = estimator.run(testCircuit, 'I').result()
print(result.values[0])
</code></pre>
<h3>The Question</h3>
<p>What is the best practice (in 2024) for calculating the exact expected value of any observable specified as a matrix and/or circuit using Qiskit?</p>
",How to calculate the expected value of a quantum operator in Qiskit (after deprecations),<qiskit><programming>,2,0,,,"How to calculate the expected value of a quantum operator in Qiskit (after deprecations) <h3>Background</h3>
<p>In 2022 Qiskit released a <a href=""https://www.youtube.com/watch?v=1oiYH87vx1A"" rel=""nofollow noreferrer"">very nice tutorial</a> detailing how the expectation value of an operator could be found using <code>CircuitOp</code>. As of 2024, these techniques (and others that I have found on the quantum computing stack exchange) are unusable as they are deprecated. The migration guide suggests using <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.Estimator"" rel=""nofollow noreferrer"">Estimators</a>. As a test, I tried writing some code to calculate the <em>exact</em> (non-simulated) expected value of <span class=""math-container"">$\langle0|H|0\rangle$</span> which, I believe, should be equal to <span class=""math-container"">$\dfrac{1}{\sqrt{2}}$</span>. Instead, I got <span class=""math-container"">$0.9999999999999999$</span>. I include my code below (as it is quite short).</p>
<h3>The Code</h3>
<pre><code>from qiskit import QuantumCircuit
from qiskit.primitives import Estimator

testCircuit = QuantumCircuit(1)
testCircuit.h(0)

estimator = Estimator()

result = estimator.run(testCircuit, 'I').result()
print(result.values[0])
</code></pre>
<h3>The Question</h3>
<p>What is the best practice (in 2024) for calculating the exact expected value of any observable specified as a matrix and/or circuit using Qiskit?</p>
",qc,calculate expected value quantum operator qiskit deprecations h3 background p 2022 qiskit released https nofollow noreferrer nice tutorial detailing expectation value operator could found using code circuitop 2024 techniques others found quantum computing stack exchange unusable deprecated migration guide suggests using https nofollow noreferrer estimators test tried writing code calculate em exact expected value span believe equal span 1 2 instead got span include code quite short h3 code pre code qiskit import quantumcircuit import estimator testcircuit quantumcircuit 1 0 estimator estimator result testcircuit print 0 h3 question p best practice 2024 calculating exact expected value observable specified matrix circuit using qiskit,"[(0, 0.3472058), (1, 0.0282532), (2, 0.04434444), (3, 0.091145456), (4, 0.105932176), (7, 0.13857155), (8, 0.12098778), (12, 0.03178556), (14, 0.09067292)]"
35740,35748.0,2024-02-07 00:54:46,5,326,"<p>The (classical) lower bound on Fast Fourier transform is still open question. The complexity of <span class=""math-container"">$\mathcal{O}(N\log(N))$</span> (due to <a href=""https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm"" rel=""nofollow noreferrer"">Cooley-Tukey</a>) is <strong>not</strong> known to be optimal. (Here, <span class=""math-container"">$N$</span> is the vector size.)</p>
<p>In the quantum counterpart, there is an <span class=""math-container"">$\mathcal{O}(n^2)$</span> algorithm due to <a href=""https://arxiv.org/abs/quant-ph/0201067"" rel=""nofollow noreferrer"">Coppersmith</a>, 1994, and also Deutsch (unpublished). Here <span class=""math-container"">$n$</span> is number of qubits.</p>
<blockquote>
<p>Is this result known to be optimal?</p>
</blockquote>
<p>There has been some approximate QFT algorithm that do better - see, <span class=""math-container"">$\mathcal{O}(n\log(n))$</span> due to <a href=""https://arxiv.org/abs/quant-ph/0212002"" rel=""nofollow noreferrer"">Hales</a>, 2002. But, I am restricting to exact algorithms only for this question.</p>
",Is the $\mathcal O(n^2)$ cost of the quantum Fourier transform (QFT) known to be optimal?,<quantum-algorithms><quantum-fourier-transform><hidden-subgroup-problem>,2,1,,,"Is the $\mathcal O(n^2)$ cost of the quantum Fourier transform (QFT) known to be optimal? <p>The (classical) lower bound on Fast Fourier transform is still open question. The complexity of <span class=""math-container"">$\mathcal{O}(N\log(N))$</span> (due to <a href=""https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm"" rel=""nofollow noreferrer"">Cooley-Tukey</a>) is <strong>not</strong> known to be optimal. (Here, <span class=""math-container"">$N$</span> is the vector size.)</p>
<p>In the quantum counterpart, there is an <span class=""math-container"">$\mathcal{O}(n^2)$</span> algorithm due to <a href=""https://arxiv.org/abs/quant-ph/0201067"" rel=""nofollow noreferrer"">Coppersmith</a>, 1994, and also Deutsch (unpublished). Here <span class=""math-container"">$n$</span> is number of qubits.</p>
<blockquote>
<p>Is this result known to be optimal?</p>
</blockquote>
<p>There has been some approximate QFT algorithm that do better - see, <span class=""math-container"">$\mathcal{O}(n\log(n))$</span> due to <a href=""https://arxiv.org/abs/quant-ph/0212002"" rel=""nofollow noreferrer"">Hales</a>, 2002. But, I am restricting to exact algorithms only for this question.</p>
",qc,cost quantum fourier transform qft known optimal p classical lower bound fast fourier transform still open question complexity span n due https e2 80 nofollow noreferrer strong known optimal span n vector size p quantum counterpart span algorithm due https nofollow noreferrer coppersmith 1994 also deutsch unpublished span n number blockquote p result known optimal p approximate qft algorithm better see span n due https nofollow noreferrer hales restricting exact algorithms,"[(3, 0.13292588), (4, 0.10717145), (7, 0.5001032), (9, 0.20550981), (10, 0.022285003), (12, 0.029979317)]"
35766,,2024-02-08 20:39:30,8,203,"<p>Suppose I give you an <span class=""math-container"">$n$</span>-qubit state vector as a classical list of numbers (or as an oracle that can query the amplitudes). I tell you this state vector will contain exactly <span class=""math-container"">$k$</span> non-zero amplitudes, after you apply a Hadamard transform to it. You could determine what those non-zero amplitudes are in <span class=""math-container"">$O(n2^n)$</span> time by applying the <a href=""https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform"" rel=""nofollow noreferrer"">fast Walsh-Hadamard transform</a>. But that seems quite inefficient, given the promise that only <span class=""math-container"">$k$</span> of the <span class=""math-container"">$2^n$</span> outputs are actually needed.</p>
<p>Is there a way to compute a sparse representation of the the output, in time that scales polynomially in <span class=""math-container"">$k$</span> and <span class=""math-container"">$n$</span>, like <span class=""math-container"">$O(k^9 n^9)$</span>?</p>
<p>This would be the Hadamard analogue of the <a href=""https://en.wikipedia.org/wiki/Sparse_Fourier_transform"" rel=""nofollow noreferrer"">sparse fast Fourier transform</a>. Or more specifically the high-dimension all-dimension-lengths-equal-to-2 sparse Fourier transform.</p>
<p>For example, in the <span class=""math-container"">$k=1$</span> case, you can just look at the amplitudes of <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|2\rangle$</span>, <span class=""math-container"">$|4\rangle$</span>, <span class=""math-container"">$|8\rangle$</span>, ..., <span class=""math-container"">$|2^{n-1}\rangle$</span> to check if they are equal or opposite to the amplitude of <span class=""math-container"">$|0\rangle$</span>. The equal-or-opposite-ness directly reads off the bits of the state that has the single non-zero amplitude in the output. Under the hood this is because <span class=""math-container"">$HX = ZH$</span>: we're checking for the Z's negation to infer whether each qubit will be bit flipped away from 0 or not after the Hadamard. This takes time <span class=""math-container"">$O(n)$</span>.</p>
",Is there a fast sparse Hadamard transform?,<hadamard><classical-computing>,1,8,,,"Is there a fast sparse Hadamard transform? <p>Suppose I give you an <span class=""math-container"">$n$</span>-qubit state vector as a classical list of numbers (or as an oracle that can query the amplitudes). I tell you this state vector will contain exactly <span class=""math-container"">$k$</span> non-zero amplitudes, after you apply a Hadamard transform to it. You could determine what those non-zero amplitudes are in <span class=""math-container"">$O(n2^n)$</span> time by applying the <a href=""https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform"" rel=""nofollow noreferrer"">fast Walsh-Hadamard transform</a>. But that seems quite inefficient, given the promise that only <span class=""math-container"">$k$</span> of the <span class=""math-container"">$2^n$</span> outputs are actually needed.</p>
<p>Is there a way to compute a sparse representation of the the output, in time that scales polynomially in <span class=""math-container"">$k$</span> and <span class=""math-container"">$n$</span>, like <span class=""math-container"">$O(k^9 n^9)$</span>?</p>
<p>This would be the Hadamard analogue of the <a href=""https://en.wikipedia.org/wiki/Sparse_Fourier_transform"" rel=""nofollow noreferrer"">sparse fast Fourier transform</a>. Or more specifically the high-dimension all-dimension-lengths-equal-to-2 sparse Fourier transform.</p>
<p>For example, in the <span class=""math-container"">$k=1$</span> case, you can just look at the amplitudes of <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|2\rangle$</span>, <span class=""math-container"">$|4\rangle$</span>, <span class=""math-container"">$|8\rangle$</span>, ..., <span class=""math-container"">$|2^{n-1}\rangle$</span> to check if they are equal or opposite to the amplitude of <span class=""math-container"">$|0\rangle$</span>. The equal-or-opposite-ness directly reads off the bits of the state that has the single non-zero amplitude in the output. Under the hood this is because <span class=""math-container"">$HX = ZH$</span>: we're checking for the Z's negation to infer whether each qubit will be bit flipped away from 0 or not after the Hadamard. This takes time <span class=""math-container"">$O(n)$</span>.</p>
",qc,fast sparse hadamard transform p suppose give span n state vector classical list numbers oracle query amplitudes tell state vector contain exactly span k amplitudes apply hadamard transform could determine amplitudes span time applying https e2 80 nofollow noreferrer fast transform seems quite inefficient given promise span k span outputs actually p way compute sparse representation output time scales polynomially span k span n like span p would hadamard analogue https nofollow noreferrer sparse fast fourier transform specifically sparse fourier p example span case look amplitudes span span span span span check equal opposite amplitude span directly reads bits state single amplitude output hood span hx zh checking z negation infer whether qubit bit flipped away 0 hadamard takes time span n,"[(3, 0.30561838), (4, 0.044338908), (7, 0.200285), (8, 0.07714118), (9, 0.027478812), (12, 0.017184768), (14, 0.01712893), (18, 0.3010818)]"
35884,,2024-02-20 15:06:11,0,169,"<p>I'm using Qiskit 1.0.0.</p>
<p>I'm trying to define a custom gate from a certain wavefunction and insert it in a quantum circuit that I want to run and measure the counts.</p>
<p>The relevant code for the question is as follows:</p>
<pre><code>backend = FakePerth()
custom_gate_ch1 = Gate('ch1', 1, [])
circ = QuantumCircuit(4)
passmanager = generate_preset_pass_manager(optimization_level=1, backend=backend)

with builder.build() as ch1_gate:
    builder.play(wave, DriveChannel(0))

backend.target.add_instruction(
    custom_gate_ch1,
    {(0,): InstructionProperties(calibration=ch1_gate)},
)

circ.append(custom_gate_ch1, [0])
circ.measure_all()
circ = passmanager.run(circ)

tqc = transpile(circ, backend, scheduling_method='asap')
counts = backend.run(tqc).result().get_counts()
</code></pre>
<p>With this code, I'm able to obtain the transpiled circuits correctly, but when I try to run it I get the following error:</p>
<p><code>qiskit.providers.basic_provider.exceptions.BasicProviderError: 'basic_simulator encountered unrecognized operation &quot;ch1&quot;'</code></p>
<p>Where am I going wrong?</p>
",Implementing Custom Gates by using Qiskit Pulse in Qiskit 1.0.0,<qiskit><openpulse>,1,0,,,"Implementing Custom Gates by using Qiskit Pulse in Qiskit 1.0.0 <p>I'm using Qiskit 1.0.0.</p>
<p>I'm trying to define a custom gate from a certain wavefunction and insert it in a quantum circuit that I want to run and measure the counts.</p>
<p>The relevant code for the question is as follows:</p>
<pre><code>backend = FakePerth()
custom_gate_ch1 = Gate('ch1', 1, [])
circ = QuantumCircuit(4)
passmanager = generate_preset_pass_manager(optimization_level=1, backend=backend)

with builder.build() as ch1_gate:
    builder.play(wave, DriveChannel(0))

backend.target.add_instruction(
    custom_gate_ch1,
    {(0,): InstructionProperties(calibration=ch1_gate)},
)

circ.append(custom_gate_ch1, [0])
circ.measure_all()
circ = passmanager.run(circ)

tqc = transpile(circ, backend, scheduling_method='asap')
counts = backend.run(tqc).result().get_counts()
</code></pre>
<p>With this code, I'm able to obtain the transpiled circuits correctly, but when I try to run it I get the following error:</p>
<p><code>qiskit.providers.basic_provider.exceptions.BasicProviderError: 'basic_simulator encountered unrecognized operation &quot;ch1&quot;'</code></p>
<p>Where am I going wrong?</p>
",qc,implementing custom gates using qiskit pulse qiskit p using qiskit p trying define custom gate certain wavefunction insert quantum circuit want run measure p relevant code question follows pre code backend fakeperth gate 1 circ quantumcircuit 4 passmanager wave drivechannel 0 0 instructionproperties 0 circ circ tqc transpile circ backend counts tqc p code able obtain transpiled circuits correctly try run get following error p code encountered unrecognized operation quot ch1 quot p going wrong,"[(0, 0.34070015), (2, 0.06362295), (8, 0.023221238), (9, 0.06541394), (12, 0.01221249), (14, 0.46533468), (19, 0.027689712)]"
35885,36934.0,2024-02-20 17:41:58,6,141,"<p>An <span class=""math-container"">$ n $</span> qudit code always has distance bounded above by <span class=""math-container"">$ d \leq \frac{n+1}{2} $</span> (Edit: the correct bound appears to be <span class=""math-container"">$ d \leq \frac{n}{2}+1 $</span> but the <span class=""math-container"">$ [[6,0,4]] $</span> hexacode and the <span class=""math-container"">$ [[2,0,2]] $</span> Bell state are the only qubit codes that violates the tighter bound <span class=""math-container"">$ d \leq \frac{n+1}{2} $</span>. Indeed even the even tighter bound <span class=""math-container"">$ d \leq \frac{n}{2} $</span> appears to be only violated by a few codes namely <span class=""math-container"">$ [[6,0,4]], [[5,1,3]], [[3,0,2]],[[2,0,2]] $</span>). The <span class=""math-container"">$ 5 $</span> qudit generalization of the Knill-Laflamme code with parameters <span class=""math-container"">$ [[5,1,3]]_q $</span> ( <span class=""math-container"">$ q $</span> denoting the size of the qudit) has stabilizer generators
<span class=""math-container"">\begin{align*}
&amp; XZZ^\dagger X^\dagger I \\
&amp; IXZZ^\dagger X^\dagger \\
&amp; X^\dagger IXZZ^\dagger \\
&amp; Z^\dagger X^\dagger IXZ 
\end{align*}</span>
and for any <span class=""math-container"">$ q $</span> this code saturates the bound <span class=""math-container"">$ d \leq \frac{n+1}{2} $</span> since
<span class=""math-container"">$$
3 = \frac{5+1}{2}
$$</span>
The <a href=""https://errorcorrectionzoo.org/c/stab_3_1_2#:%7E:text=Holographic%20code%20%E2%80%94%20Three%2Dqutrit%20code,smallest%20nontrivial%20quantum%20MDS%20code"" rel=""nofollow noreferrer"">three qutrit code</a> with parameters <span class=""math-container"">$ [[3,1,2]]_3 $</span> also saturates this bound
<span class=""math-container"">$$
2 = \frac{3+1}{2}
$$</span>
Are there any other qudit codes that saturate this bound? Or are the <span class=""math-container"">$ [[5,1,3]]_q $</span> and <span class=""math-container"">$ [[3,1,2]]_3 $</span> codes essentially unique in this respect?</p>
",Codes saturating the bound d=(n+1)/2,<error-correction><stabilizer-code>,2,0,,,"Codes saturating the bound d=(n+1)/2 <p>An <span class=""math-container"">$ n $</span> qudit code always has distance bounded above by <span class=""math-container"">$ d \leq \frac{n+1}{2} $</span> (Edit: the correct bound appears to be <span class=""math-container"">$ d \leq \frac{n}{2}+1 $</span> but the <span class=""math-container"">$ [[6,0,4]] $</span> hexacode and the <span class=""math-container"">$ [[2,0,2]] $</span> Bell state are the only qubit codes that violates the tighter bound <span class=""math-container"">$ d \leq \frac{n+1}{2} $</span>. Indeed even the even tighter bound <span class=""math-container"">$ d \leq \frac{n}{2} $</span> appears to be only violated by a few codes namely <span class=""math-container"">$ [[6,0,4]], [[5,1,3]], [[3,0,2]],[[2,0,2]] $</span>). The <span class=""math-container"">$ 5 $</span> qudit generalization of the Knill-Laflamme code with parameters <span class=""math-container"">$ [[5,1,3]]_q $</span> ( <span class=""math-container"">$ q $</span> denoting the size of the qudit) has stabilizer generators
<span class=""math-container"">\begin{align*}
&amp; XZZ^\dagger X^\dagger I \\
&amp; IXZZ^\dagger X^\dagger \\
&amp; X^\dagger IXZZ^\dagger \\
&amp; Z^\dagger X^\dagger IXZ 
\end{align*}</span>
and for any <span class=""math-container"">$ q $</span> this code saturates the bound <span class=""math-container"">$ d \leq \frac{n+1}{2} $</span> since
<span class=""math-container"">$$
3 = \frac{5+1}{2}
$$</span>
The <a href=""https://errorcorrectionzoo.org/c/stab_3_1_2#:%7E:text=Holographic%20code%20%E2%80%94%20Three%2Dqutrit%20code,smallest%20nontrivial%20quantum%20MDS%20code"" rel=""nofollow noreferrer"">three qutrit code</a> with parameters <span class=""math-container"">$ [[3,1,2]]_3 $</span> also saturates this bound
<span class=""math-container"">$$
2 = \frac{3+1}{2}
$$</span>
Are there any other qudit codes that saturate this bound? Or are the <span class=""math-container"">$ [[5,1,3]]_q $</span> and <span class=""math-container"">$ [[3,1,2]]_3 $</span> codes essentially unique in this respect?</p>
",qc,codes saturating bound p span n qudit code always distance bounded span 2 edit correct bound appears span n 2 span hexacode span bell state qubit codes violates tighter bound span 2 indeed even even tighter bound span n 2 appears violated codes namely span span 5 qudit generalization code parameters span span q denoting size qudit stabilizer generators span align amp amp amp amp ixz align span q code saturates bound span 2 since span 3 2 https 7e 20code 20 e2 80 94 20three 2dqutrit 20code smallest 20nontrivial 20quantum 20mds 20code nofollow noreferrer three qutrit code parameters span also saturates bound span 2 2 qudit codes saturate bound span span codes essentially unique respect,"[(2, 0.042619113), (3, 0.63904357), (5, 0.14932086), (6, 0.030381074), (9, 0.03236612), (10, 0.015424859), (12, 0.02617003), (15, 0.063593045)]"
35889,,2024-02-20 22:25:46,6,321,"<h1>Background</h1>
<p>Phase estimation circuits prepare <span class=""math-container"">$n$</span> qubits <span class=""math-container"">$Q_0, \dots, Q_{n-1}$</span> in the <span class=""math-container"">$|+\rangle$</span> state, then apply <span class=""math-container"">$U^{2^q}$</span> controlled by <span class=""math-container"">$Q_q$</span> for each <span class=""math-container"">$q$</span>, then apply a quantum Fourier transform, then measure <span class=""math-container"">$Q_0, \dots, Q_{n-1}$</span>.</p>
<p>&quot;Qubit recycling&quot; refers to the fact that you can rearrange the phase estimation circuit so that <span class=""math-container"">$Q_{k}$</span> is measured and done with before you need to initialize <span class=""math-container"">$Q_{k+1}$</span>, allowing a single qubit to iteratively play the roles of <span class=""math-container"">$Q_0, \dots, Q_{n-1}$</span>. This reduces <span class=""math-container"">$n$</span> qubits of storage to 1 qubit of storage. Here's a diagram of phase estimation with qubit recycling:</p>
<blockquote>
<p><a href=""https://i.sstatic.net/dM0uh.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dM0uh.png"" alt=""enter image description here"" /></a>
source: <a href=""https://arxiv.org/abs/1706.07884"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1706.07884</a></p>
</blockquote>
<p>The binary representation of an integer is a series of bits where the bit at offset <span class=""math-container"">$k$</span> has a &quot;weight&quot; of <span class=""math-container"">$2^k$</span>. The integer is the sum of the weights of the bits that are 1. The <a href=""https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem"" rel=""nofollow noreferrer"">Zeckendorf representation</a> is similar, but the k'th bit's weight is the k'th Fibonacci number (instead of a power of 2). To make the representation unique, no two adjacent bits are set.</p>
<h1>Motivation</h1>
<p>In <a href=""https://arxiv.org/abs/2310.00899"" rel=""nofollow noreferrer"">&quot;Space-Efficient and Noise-Robust Quantum Factoring&quot;</a>, Ragavan and Vaikuntanathan use the Zeckendorf representation to reduce the storage of Regev's factoring algorithm. A key idea is that they replace <a href=""https://en.wikipedia.org/wiki/Exponentiation_by_squaring"" rel=""nofollow noreferrer"">exponentiation by repeated squaring</a> with <a href=""https://arxiv.org/abs/1711.02491"" rel=""nofollow noreferrer"">Fibonacci exponentiation</a>, which allows more operations to be done inplace reducing storage. However, a consequence of this change is that they can't use qubit recycling anymore.</p>
<h1>Actual Question</h1>
<p>...or can they? If I modify the phase estimation circuit so that it converts into the Zeckendorf representation before performing the controlled operations, and converts back into the binary representation before performing the QFT, is there still some way to rewrite that circuit so that it uses <span class=""math-container"">$O(1)$</span> storage instead of <span class=""math-container"">$O(n)$</span> storage? That's my question.</p>
<p>Here is <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A1%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22-%3DA5%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2213t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C1%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Chance5%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Ethkp%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%94%2C-%E2%88%9A%E2%85%93%7D%2C%7B%E2%88%9A%E2%85%93%2C%E2%88%9A%E2%85%94%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">the phase estimation circuit with a conversion into and out of Zeckendorf representation</a>. The goal is to keep the Zeckendorf representation part (keep the fact that <span class=""math-container"">$Z$</span> is raised to <span class=""math-container"">$t$</span> times Fibonacci numbers instead of <span class=""math-container"">$t$</span> times powers of 2) while only having <span class=""math-container"">$O(1)$</span> qubits at a time.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A1%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22-%3DA5%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2213t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C1%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Chance5%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Ethkp%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%94%2C-%E2%88%9A%E2%85%93%7D%2C%7B%E2%88%9A%E2%85%93%2C%E2%88%9A%E2%85%94%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BIHw7.png"" alt=""enter image description here"" /></a></p>
<h1>Attempts</h1>
<p>I sort of made a wild guess that maybe if I just took the qubit recycling circuit and replaced <span class=""math-container"">$U^{2^q}$</span> with <span class=""math-container"">$U^{f(q)}$</span> and replaced each phase fixup <span class=""math-container"">$Z^{2^a/2^b}$</span> with the phase fixup <span class=""math-container"">$Z^{F(a) / F(b)}$</span>, that that would work. So, turn <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2216t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%224t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer"">this</a>:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2216t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%224t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/58pMY.png"" alt=""enter image description here"" /></a></p>
<p>into <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer"">this</a>:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YARzi.png"" alt=""enter image description here"" /></a></p>
<p>But you can tell from the chance display on the right hand side getting more disordered that it's not pulling out the value of <span class=""math-container"">$t$</span> correctly.</p>
<p>I also tried tweaking the input integer to be in the Zeckendorf representation, by using two qubits of workspace and using anti-controlled Hadamards to avoid having adjacent bits set. But that <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%22%E2%97%A6%22%2C%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer"">also didn't work</a>:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%22%E2%97%A6%22%2C%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F834j.png"" alt=""enter image description here"" /></a></p>
",Is QFT qubit recycling compatible with Zeckendorf's Fibonacci representation of integers?,<quantum-fourier-transform><factorization>,1,0,,,"Is QFT qubit recycling compatible with Zeckendorf's Fibonacci representation of integers? <h1>Background</h1>
<p>Phase estimation circuits prepare <span class=""math-container"">$n$</span> qubits <span class=""math-container"">$Q_0, \dots, Q_{n-1}$</span> in the <span class=""math-container"">$|+\rangle$</span> state, then apply <span class=""math-container"">$U^{2^q}$</span> controlled by <span class=""math-container"">$Q_q$</span> for each <span class=""math-container"">$q$</span>, then apply a quantum Fourier transform, then measure <span class=""math-container"">$Q_0, \dots, Q_{n-1}$</span>.</p>
<p>&quot;Qubit recycling&quot; refers to the fact that you can rearrange the phase estimation circuit so that <span class=""math-container"">$Q_{k}$</span> is measured and done with before you need to initialize <span class=""math-container"">$Q_{k+1}$</span>, allowing a single qubit to iteratively play the roles of <span class=""math-container"">$Q_0, \dots, Q_{n-1}$</span>. This reduces <span class=""math-container"">$n$</span> qubits of storage to 1 qubit of storage. Here's a diagram of phase estimation with qubit recycling:</p>
<blockquote>
<p><a href=""https://i.sstatic.net/dM0uh.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dM0uh.png"" alt=""enter image description here"" /></a>
source: <a href=""https://arxiv.org/abs/1706.07884"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1706.07884</a></p>
</blockquote>
<p>The binary representation of an integer is a series of bits where the bit at offset <span class=""math-container"">$k$</span> has a &quot;weight&quot; of <span class=""math-container"">$2^k$</span>. The integer is the sum of the weights of the bits that are 1. The <a href=""https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem"" rel=""nofollow noreferrer"">Zeckendorf representation</a> is similar, but the k'th bit's weight is the k'th Fibonacci number (instead of a power of 2). To make the representation unique, no two adjacent bits are set.</p>
<h1>Motivation</h1>
<p>In <a href=""https://arxiv.org/abs/2310.00899"" rel=""nofollow noreferrer"">&quot;Space-Efficient and Noise-Robust Quantum Factoring&quot;</a>, Ragavan and Vaikuntanathan use the Zeckendorf representation to reduce the storage of Regev's factoring algorithm. A key idea is that they replace <a href=""https://en.wikipedia.org/wiki/Exponentiation_by_squaring"" rel=""nofollow noreferrer"">exponentiation by repeated squaring</a> with <a href=""https://arxiv.org/abs/1711.02491"" rel=""nofollow noreferrer"">Fibonacci exponentiation</a>, which allows more operations to be done inplace reducing storage. However, a consequence of this change is that they can't use qubit recycling anymore.</p>
<h1>Actual Question</h1>
<p>...or can they? If I modify the phase estimation circuit so that it converts into the Zeckendorf representation before performing the controlled operations, and converts back into the binary representation before performing the QFT, is there still some way to rewrite that circuit so that it uses <span class=""math-container"">$O(1)$</span> storage instead of <span class=""math-container"">$O(n)$</span> storage? That's my question.</p>
<p>Here is <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A1%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22-%3DA5%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2213t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C1%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Chance5%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Ethkp%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%94%2C-%E2%88%9A%E2%85%93%7D%2C%7B%E2%88%9A%E2%85%93%2C%E2%88%9A%E2%85%94%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer"">the phase estimation circuit with a conversion into and out of Zeckendorf representation</a>. The goal is to keep the Zeckendorf representation part (keep the fact that <span class=""math-container"">$Z$</span> is raised to <span class=""math-container"">$t$</span> times Fibonacci numbers instead of <span class=""math-container"">$t$</span> times powers of 2) while only having <span class=""math-container"">$O(1)$</span> qubits at a time.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22-%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A1%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22-%3DA5%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2213t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A2%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A3%7D%5D%2C%5B%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A5%7D%5D%2C%5B%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A8%7D%5D%2C%5B%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B1%2C%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setA%22%2C%22arg%22%3A13%7D%5D%2C%5B%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C1%2C%22%2B%3DA5%22%5D%2C%5B%22%5EA%3C%3DB%22%2C1%2C1%2C1%2C1%2C1%2C%22inputB5%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C1%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Swap%22%2C1%2C%22Swap%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C1%2C1%2C%22Chance5%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22%7Ethkp%22%2C%22matrix%22%3A%22%7B%7B%E2%88%9A%E2%85%94%2C-%E2%88%9A%E2%85%93%7D%2C%7B%E2%88%9A%E2%85%93%2C%E2%88%9A%E2%85%94%7D%7D%22%7D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/BIHw7.png"" alt=""enter image description here"" /></a></p>
<h1>Attempts</h1>
<p>I sort of made a wild guess that maybe if I just took the qubit recycling circuit and replaced <span class=""math-container"">$U^{2^q}$</span> with <span class=""math-container"">$U^{f(q)}$</span> and replaced each phase fixup <span class=""math-container"">$Z^{2^a/2^b}$</span> with the phase fixup <span class=""math-container"">$Z^{F(a) / F(b)}$</span>, that that would work. So, turn <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2216t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%224t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer"">this</a>:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%2216t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%224t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F16%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F4%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/58pMY.png"" alt=""enter image description here"" /></a></p>
<p>into <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer"">this</a>:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YARzi.png"" alt=""enter image description here"" /></a></p>
<p>But you can tell from the chance display on the right hand side getting more disordered that it's not pulling out the value of <span class=""math-container"">$t$</span> correctly.</p>
<p>I also tried tweaking the input integer to be in the Zeckendorf representation, by using two qubits of workspace and using anti-controlled Hadamards to avoid having adjacent bits set. But that <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%22%E2%97%A6%22%2C%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer"">also didn't work</a>:</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%22%E2%97%A6%22%2C%22H%22%5D%2C%5B%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%228t%22%7D%5D%2C%5B%22H%22%5D%2C%5B%22Measure%22%5D%2C%5B1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%225%2F8%22%7D%5D%2C%5B1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C%22H%22%5D%2C%5B1%2C%22Measure%22%5D%2C%5B1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%223%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%222%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%97%A6%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%22t%22%7D%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F8%22%7D%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F5%22%7D%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F3%22%7D%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%7B%22id%22%3A%22Z%5Eft%22%2C%22arg%22%3A%221%2F2%22%7D%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B%22Chance5%22%5D%5D%7D"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F834j.png"" alt=""enter image description here"" /></a></p>
",qc,qft qubit recycling compatible zeckendorf fibonacci representation integers h1 background p phase estimation circuits prepare span n qubits span span state apply span controlled span span q apply quantum fourier transform measure span p quot qubit recycling quot refers fact rearrange phase estimation circuit span k measured done need initialize span allowing single qubit iteratively play roles span reduces span n qubits storage 1 qubit storage diagram phase estimation qubit recycling blockquote p https nofollow noreferrer img https enter image description source https nofollow noreferrer https p binary representation integer series bits bit offset span k quot weight quot span integer sum weights bits https nofollow noreferrer zeckendorf representation similar bit weight fibonacci number instead power 2 make representation unique two adjacent bits h1 motivation p https nofollow noreferrer quot quantum factoring quot ragavan vaikuntanathan use zeckendorf representation reduce storage regev factoring algorithm key idea replace https nofollow noreferrer exponentiation repeated squaring https nofollow noreferrer fibonacci exponentiation allows operations done inplace reducing storage however consequence change ca use qubit recycling h1 actual question p modify phase estimation circuit converts zeckendorf representation performing controlled operations converts back binary representation performing qft still way rewrite circuit uses span 1 storage instead span n storage p https 7b 22cols 22 3a 5b 5b1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a13 7d 5d 2c 5b 5d 2c 5b 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a8 7d 5d 2c 5b 5d 2c 5b1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a5 7d 5d 2c 5b 5d 2c 5b1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a3 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a2 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a1 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 3da5 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 2213t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a2 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a3 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a5 7d 5d 2c 5b 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a8 7d 5d 2c 5b 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a13 7d 5d 2c 5b 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22swap 22 2c1 2c1 2c1 2c 22swap 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22swap 22 2c1 2c 22swap 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f16 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22chance5 22 5d 5d 2c 22gates 22 3a 5b 7b 22id 22 3a 22 7ethkp 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 94 e2 88 9a e2 85 93 7d 2c 7b e2 88 9a e2 85 93 2c e2 88 9a e2 85 94 7d 7d 22 7d 5d 7d nofollow noreferrer phase estimation circuit conversion zeckendorf representation goal keep zeckendorf representation part keep fact span z raised span times fibonacci numbers instead span times powers 2 span 1 qubits p https 7b 22cols 22 3a 5b 5b1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a13 7d 5d 2c 5b 5d 2c 5b 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a8 7d 5d 2c 5b 5d 2c 5b1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a5 7d 5d 2c 5b 5d 2c 5b1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a3 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a2 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a1 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 3da5 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 2213t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a2 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a3 7d 5d 2c 5b 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a5 7d 5d 2c 5b 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a8 7d 5d 2c 5b 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b1 2c 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 7b 22id 22 3a 22seta 22 2c 22arg 22 3a13 7d 5d 2c 5b 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c1 2c1 2c 22 2b 3da5 22 5d 2c 5b 22 5ea 3c 3db 22 2c1 2c1 2c1 2c1 2c1 2c 22inputb5 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22swap 22 2c1 2c1 2c1 2c 22swap 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22swap 22 2c1 2c 22swap 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f16 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c1 2c1 2c 22chance5 22 5d 5d 2c 22gates 22 3a 5b 7b 22id 22 3a 22 7ethkp 22 2c 22matrix 22 3a 22 7b 7b e2 88 9a e2 85 94 e2 88 9a e2 85 93 7d 2c 7b e2 88 9a e2 85 93 2c e2 88 9a e2 85 94 7d 7d 22 7d 5d 7d nofollow noreferrer img https enter image description h1 attempts p sort made wild guess maybe took qubit recycling circuit replaced span span f q replaced phase fixup span phase fixup span f f b would work turn https 7b 22cols 22 3a 5b 5b 22h 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 2216t 22 7d 5d 2c 5b 22h 22 5d 2c 5b 22measure 22 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 22measure 22 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 224t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f16 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b 22chance5 22 5d 5d 7d nofollow noreferrer p https 7b 22cols 22 3a 5b 5b 22h 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 2216t 22 7d 5d 2c 5b 22h 22 5d 2c 5b 22measure 22 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 22measure 22 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 224t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f16 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f4 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b 22chance5 22 5d 5d 7d nofollow noreferrer img https enter image description p https 7b 22cols 22 3a 5b 5b 22h 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 5d 2c 5b 22h 22 5d 2c 5b 22measure 22 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225 2f8 22 7d 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 22measure 22 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f5 22 7d 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b 22chance5 22 5d 5d 7d nofollow noreferrer p https 7b 22cols 22 3a 5b 5b 22h 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 5d 2c 5b 22h 22 5d 2c 5b 22measure 22 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225 2f8 22 7d 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 22measure 22 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f5 22 7d 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b 22chance5 22 5d 5d 7d nofollow noreferrer img https enter image description p tell chance display right hand side getting disordered pulling value span p also tried tweaking input integer zeckendorf representation using two qubits workspace using hadamards avoid adjacent bits set https 7b 22cols 22 3a 5b 5b 22h 22 5d 2c 5b 22 e2 97 a6 22 2c 22h 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 5d 2c 5b 22h 22 5d 2c 5b 22measure 22 5d 2c 5b1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225 2f8 22 7d 5d 2c 5b1 2c 22 e2 97 a6 22 2c 22h 22 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 22measure 22 5d 2c 5b1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 97 a6 22 2c 22h 22 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 97 a6 22 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b 22chance5 22 5d 5d 7d nofollow noreferrer also work p https 7b 22cols 22 3a 5b 5b 22h 22 5d 2c 5b 22 e2 97 a6 22 2c 22h 22 5d 2c 5b 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 228t 22 7d 5d 2c 5b 22h 22 5d 2c 5b 22measure 22 5d 2c 5b1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 225 2f8 22 7d 5d 2c 5b1 2c 22 e2 97 a6 22 2c 22h 22 5d 2c 5b1 2c 22h 22 5d 2c 5b1 2c 22measure 22 5d 2c 5b1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 223 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 97 a6 22 2c 22h 22 5d 2c 5b1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 222 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 97 a6 22 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22h 22 5d 2c 5b1 2c1 2c1 2c 22measure 22 5d 2c 5b1 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 22t 22 7d 5d 2c 5b 22 e2 80 a2 22 2c1 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f8 22 7d 5d 2c 5b1 2c 22 e2 80 a2 22 2c1 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f5 22 7d 5d 2c 5b1 2c1 2c 22 e2 80 a2 22 2c1 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f3 22 7d 5d 2c 5b1 2c1 2c1 2c 22 e2 80 a2 22 2c 7b 22id 22 3a 22z 5eft 22 2c 22arg 22 3a 221 2f2 22 7d 5d 2c 5b1 2c1 2c1 2c1 2c 22h 22 5d 2c 5b 22chance5 22 5d 5d 7d nofollow noreferrer img https enter image description,"[(12, 0.9999671)]"
36935,36944.0,2024-02-24 19:53:02,3,93,"<p>I'm trying to understand how syndrome extraction in bit-flip code works. I've been reading <a href=""https://arxiv.org/abs/1907.11157"" rel=""nofollow noreferrer"">Quantum Error Correction: An Introductory Guide</a>, and I was wondering how the syndrome extraction part in this circuit works:
<a href=""https://i.sstatic.net/m82LF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m82LF.png"" alt=""enter image description here"" /></a></p>
<p>For example, if the state before the syndrome extraction part is <span class=""math-container"">$|++⟩|100⟩$</span>, then <span class=""math-container"">$Z_2⊗Z_1$</span> is applied and the state is still <span class=""math-container"">$|++⟩|100⟩$</span> and then <span class=""math-container"">$Z_3⊗Z_2$</span> is applied, which turns the state to <span class=""math-container"">$-|++⟩|100⟩$</span>, then Hadamard gates are applied and I think the state should be <span class=""math-container"">$-|00⟩|100⟩$</span>, which means first qubit from left is <span class=""math-container"">$0$</span>, but it's <span class=""math-container"">$1$</span>. I used <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,1,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22X%22,%22X%22%5D,%5B1,1,%22X%22%5D,%5B%22Z%22,%22Z%22,1,%22%E2%80%A2%22%5D,%5B1,%22Z%22,%22Z%22,1,%22%E2%80%A2%22%5D,%5B1,1,1,%22H%22,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a> and it's also <span class=""math-container"">$1$</span> there:</p>
<p><a href=""https://i.sstatic.net/jEa9r.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jEa9r.png"" alt=""enter image description here"" /></a></p>
<p>How does it work? Why is the controlled qubit affected?</p>
",How does syndrome extraction in bit-flip codes using stabilizers work?,<quantum-gate><error-correction>,1,0,,,"How does syndrome extraction in bit-flip codes using stabilizers work? <p>I'm trying to understand how syndrome extraction in bit-flip code works. I've been reading <a href=""https://arxiv.org/abs/1907.11157"" rel=""nofollow noreferrer"">Quantum Error Correction: An Introductory Guide</a>, and I was wondering how the syndrome extraction part in this circuit works:
<a href=""https://i.sstatic.net/m82LF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m82LF.png"" alt=""enter image description here"" /></a></p>
<p>For example, if the state before the syndrome extraction part is <span class=""math-container"">$|++⟩|100⟩$</span>, then <span class=""math-container"">$Z_2⊗Z_1$</span> is applied and the state is still <span class=""math-container"">$|++⟩|100⟩$</span> and then <span class=""math-container"">$Z_3⊗Z_2$</span> is applied, which turns the state to <span class=""math-container"">$-|++⟩|100⟩$</span>, then Hadamard gates are applied and I think the state should be <span class=""math-container"">$-|00⟩|100⟩$</span>, which means first qubit from left is <span class=""math-container"">$0$</span>, but it's <span class=""math-container"">$1$</span>. I used <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,1,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22X%22,%22X%22%5D,%5B1,1,%22X%22%5D,%5B%22Z%22,%22Z%22,1,%22%E2%80%A2%22%5D,%5B1,%22Z%22,%22Z%22,1,%22%E2%80%A2%22%5D,%5B1,1,1,%22H%22,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk</a> and it's also <span class=""math-container"">$1$</span> there:</p>
<p><a href=""https://i.sstatic.net/jEa9r.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jEa9r.png"" alt=""enter image description here"" /></a></p>
<p>How does it work? Why is the controlled qubit affected?</p>
",qc,syndrome extraction codes using stabilizers work p trying understand syndrome extraction code works reading https nofollow noreferrer quantum error correction introductory guide wondering syndrome extraction part circuit works https nofollow noreferrer img https enter image description p example state syndrome extraction part span span applied state still span span applied turns state span hadamard gates applied think state span means first qubit left span 0 span 1 used https 7b 22cols 22 5b 22h 22 22h 22 5d 5b 22 e2 80 a2 22 22x 22 22x 22 5d 22x 22 5d 5b 22z 22 22z 22 e2 80 a2 22 5d 5b1 22z 22 22z 22 e2 80 a2 22 5d 22h 22 22h 22 5d 5d 7d nofollow noreferrer quirk also span 1 p https nofollow noreferrer img https enter image description p work controlled qubit affected,"[(2, 0.017068945), (3, 0.07249014), (4, 0.28003198), (5, 0.15795018), (12, 0.38751113), (18, 0.08394176)]"
36959,36964.0,2024-02-26 14:56:04,1,79,"<p>I want to find the operator that describes this qutrit quantum circuit. Where a TSub, some TRZ rotations and a TAdd are applied to 2 quitrits. I am using Pennylane 0.34.0. <a href=""https://i.sstatic.net/Cfgew.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Cfgew.png"" alt=""Qutrit circuit"" /></a></p>
<p>This is the code:</p>
<pre><code>import pennylane as qml

TSub = qml.adjoint(qml.TAdd)

res = qml.TAdd(wires=[0, 1]) @ qml.TRZ(0.5, wires=1, subspace=(0, 1)) @ \
    qml.TRZ(0.5, wires=1, subspace=(0, 2)) @ TSub(wires=[0, 1])

print(res.matrix())
</code></pre>
<p>And I get this error:</p>
<pre><code> File &quot;/home/dan/anaconda3/envs/q_env/lib/python3.12/site-packages/autoray/autoray.py&quot;, line 80, in do
    return get_lib_fn(backend, fn)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 6 is different from 9)
</code></pre>
",Pennylane and Qutrit quantum circuit matrix representation bug,<quantum-algorithms><pennylane><quantum-state>,1,0,,,"Pennylane and Qutrit quantum circuit matrix representation bug <p>I want to find the operator that describes this qutrit quantum circuit. Where a TSub, some TRZ rotations and a TAdd are applied to 2 quitrits. I am using Pennylane 0.34.0. <a href=""https://i.sstatic.net/Cfgew.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Cfgew.png"" alt=""Qutrit circuit"" /></a></p>
<p>This is the code:</p>
<pre><code>import pennylane as qml

TSub = qml.adjoint(qml.TAdd)

res = qml.TAdd(wires=[0, 1]) @ qml.TRZ(0.5, wires=1, subspace=(0, 1)) @ \
    qml.TRZ(0.5, wires=1, subspace=(0, 2)) @ TSub(wires=[0, 1])

print(res.matrix())
</code></pre>
<p>And I get this error:</p>
<pre><code> File &quot;/home/dan/anaconda3/envs/q_env/lib/python3.12/site-packages/autoray/autoray.py&quot;, line 80, in do
    return get_lib_fn(backend, fn)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 6 is different from 9)
</code></pre>
",qc,pennylane qutrit quantum circuit matrix representation bug p want find operator describes qutrit quantum circuit tsub trz rotations tadd applied 2 quitrits using pennylane https nofollow noreferrer img https qutrit circuit p code pre code import pennylane qml tsub res 0 1 0 1 0 2 tsub 0 1 print p get error pre code file quot quot line 80 return backend fn args kwargs valueerror matmul input operand 1 mismatch core dimension 0 gufunc signature n k k gt n size 6 different 9,"[(0, 0.39289603), (2, 0.15174718), (4, 0.09301639), (6, 0.044527642), (8, 0.042833604), (9, 0.07011293), (11, 0.013438553), (12, 0.0780061), (14, 0.07333528), (19, 0.038853)]"
36970,,2024-02-26 21:05:30,1,130,"<p>I am new to quantum computing, and I am following <a href=""https://qiskit-community.github.io/qiskit-optimization/tutorials/03_minimum_eigen_optimizer.html"" rel=""nofollow noreferrer"">this tutorial</a> trying to use Qiskit Optimization 0.6.0 to solve a simple quadratic problem by applying QAOA algorithm.</p>
<p>As stated in the tutorial, I used:</p>
<pre><code>algorithm_globals.random_seed = 10598
qaoa_mes = QAOA(sampler=Sampler(), optimizer=COBYLA(), initial_point=[0.0, 0.0])
qaoa = MinimumEigenOptimizer(qaoa_mes)  # using QAOA
exact_result = exact.solve(qubo)
print(exact_result.prettyprint())
</code></pre>
<p>The result returned as I expected. However, I think this (<code>MinimumEigenOptimizer</code> from qiskit optimization) was not executed on a real quantum machine, right? I didn't input any token to connect computing resources, and my account in the IBM quantum platform also didn't show the job.</p>
<p>Therefore, I used the following code to try to connect and execute the optimization through a real quantum resource backend(I chose the <code>ibmq_qasm_simulator</code> for testing, but ideally I want to use real hardware):</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=token)
backend=service.backend(&quot;ibmq_qasm_simulator&quot;)
sampler = Sampler(backend=backend)
qaoa_mes = QAOA(sampler=sampler,optimizer=COBYLA())
qaoa = MinimumEigenOptimizer(qaoa_mes)  # using QAOA
exact_result = qaoa.solve(q_model)
print(exact_result.prettyprint())
</code></pre>
<p>However, the terminal got stuck and didn't return the answer(not even an error message) as in the previous code, even though I could see a job was executed and completed by <code>ibmq_qasm_simulator</code> from the IBM quantum platform.</p>
<p>So my question is, what is the correct way to do so if I want to solve a QUBO problem by QAOA algorithm with Qiskit Optimization on real quantum resources/hardware?</p>
",How to solve a QUBO problem by QAOA algorithm with Qiskit Optimization on a real quantum resources/hardware?,<qiskit><optimization><qaoa>,0,0,,,"How to solve a QUBO problem by QAOA algorithm with Qiskit Optimization on a real quantum resources/hardware? <p>I am new to quantum computing, and I am following <a href=""https://qiskit-community.github.io/qiskit-optimization/tutorials/03_minimum_eigen_optimizer.html"" rel=""nofollow noreferrer"">this tutorial</a> trying to use Qiskit Optimization 0.6.0 to solve a simple quadratic problem by applying QAOA algorithm.</p>
<p>As stated in the tutorial, I used:</p>
<pre><code>algorithm_globals.random_seed = 10598
qaoa_mes = QAOA(sampler=Sampler(), optimizer=COBYLA(), initial_point=[0.0, 0.0])
qaoa = MinimumEigenOptimizer(qaoa_mes)  # using QAOA
exact_result = exact.solve(qubo)
print(exact_result.prettyprint())
</code></pre>
<p>The result returned as I expected. However, I think this (<code>MinimumEigenOptimizer</code> from qiskit optimization) was not executed on a real quantum machine, right? I didn't input any token to connect computing resources, and my account in the IBM quantum platform also didn't show the job.</p>
<p>Therefore, I used the following code to try to connect and execute the optimization through a real quantum resource backend(I chose the <code>ibmq_qasm_simulator</code> for testing, but ideally I want to use real hardware):</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=token)
backend=service.backend(&quot;ibmq_qasm_simulator&quot;)
sampler = Sampler(backend=backend)
qaoa_mes = QAOA(sampler=sampler,optimizer=COBYLA())
qaoa = MinimumEigenOptimizer(qaoa_mes)  # using QAOA
exact_result = qaoa.solve(q_model)
print(exact_result.prettyprint())
</code></pre>
<p>However, the terminal got stuck and didn't return the answer(not even an error message) as in the previous code, even though I could see a job was executed and completed by <code>ibmq_qasm_simulator</code> from the IBM quantum platform.</p>
<p>So my question is, what is the correct way to do so if I want to solve a QUBO problem by QAOA algorithm with Qiskit Optimization on real quantum resources/hardware?</p>
",qc,solve qubo problem qaoa algorithm qiskit optimization real quantum p new quantum computing following https nofollow noreferrer tutorial trying use qiskit optimization solve simple quadratic problem applying qaoa p stated tutorial used pre code 10598 qaoa qaoa minimumeigenoptimizer using qaoa qubo print p result returned expected however think code minimumeigenoptimizer qiskit optimization executed real quantum machine right input token connect computing resources account ibm quantum platform also show p therefore used following code try connect execute optimization real quantum resource backend chose code testing ideally want use real hardware pre code service qiskitruntimeservice quot quot quot quot sampler sampler qaoa qaoa minimumeigenoptimizer using qaoa print p however terminal got stuck return answer even error message previous code even though could see job executed completed code ibm quantum p question correct way want solve qubo problem qaoa algorithm qiskit optimization real quantum,"[(0, 0.2567206), (1, 0.19367139), (4, 0.03111951), (8, 0.17791067), (12, 0.014342542), (14, 0.29177696), (19, 0.03353726)]"
37014,,2024-02-28 17:56:57,1,73,"<p>In this paper <a href=""https://arxiv.org/pdf/2107.03053.pdf"" rel=""nofollow noreferrer"">Identification of Desired Pixels in an Image Using Grover's Quantum Search
Algorithm
</a> it is stated in the abstract that &quot;[...]As has been observed in complexity
analysis, Grover's unstructured search has the <span class=""math-container"">$O(2^n)$</span> while as for classical schemes
<span class=""math-container"">$O(2^{2n+2m})$</span>, where <span class=""math-container"">$m$</span> and <span class=""math-container"">$n$</span> denote the dimensions of the image.&quot;</p>
<p>Their goal is to apply Grover's algorithm in order to find the desired pixel (darkest ones below certain threshold). This could be useful for detecting data hiding in steganography.They use NEQR for image encoding.</p>
<p>What I don't undestand is the complexity <span class=""math-container"">$O$</span> for the classical scheme. Why is it <span class=""math-container"">$2^{2n+2m}$</span> against <span class=""math-container"">$2^{n}$</span> in the quantum case?</p>
<p>Any suggestions?</p>
<p><strong>EDIT</strong>
Here is the circuit for the following list of elements (it is not the implementation of a grayscale image, is just a reduced example): according to NEQR notation, the first two qubits represent the index of four elements, i.e. 00, 01, 10 and 11, whilst the others the encoding of the value, in this case 1,2,5 and 7 {00001,01010,10101,11111}. The threshold is all numbers less than 5, that is the oracle marks the numbers 00001 and 01010. The diffuser is the standard one that can be found anywhere on the web. Of course in the case of four pixel of a grayscale images we would need 8 (for intensity) + 2 (for position) qubits.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22X%22,%22X%22%5D,%5B%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22%7Ejom5%22%5D,%5B%22%7E5l72%22%5D,%5B%22%7Ejom5%22%5D,%5B%22%7E5l72%22%5D,%5B%22Measure%22,%22Measure%22%5D%5D,%22gates%22:%5B%7B%22id%22:%22%7En9ca%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22X%22,%22X%22%5D,%5B%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7Ejom5%22,%22name%22:%22Pf%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7E40tr%22,%22name%22:%22Pf%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7E5l72%22,%22name%22:%22D%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D%5D%7D%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk circuit</a> (<a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22X%22%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22Chance2%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22NeGate%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22NeGate%22%5D%2C%5B%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22NeGate%22%5D%2C%5B%22Chance2%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22NeGate%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22NeGate%22%5D%2C%5B%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22NeGate%22%5D%2C%5B%22Measure%22%2C%22Measure%22%5D%2C%5B%22Chance2%22%5D%5D%7D"" rel=""nofollow noreferrer"">simplified</a>)</p>
<p>I don't understand how to read Quirk measurements, if I run the circuit on Qiskit I get the following results: {'11': 20, '00': 468, '10': 487, '01': 25} over 1000 shots, that is '00' and '10' are the position of the elements below my threshold, so I think it's working.</p>
",Complexity of pixel detection in quantum images,<grovers-algorithm>,1,0,,,"Complexity of pixel detection in quantum images <p>In this paper <a href=""https://arxiv.org/pdf/2107.03053.pdf"" rel=""nofollow noreferrer"">Identification of Desired Pixels in an Image Using Grover's Quantum Search
Algorithm
</a> it is stated in the abstract that &quot;[...]As has been observed in complexity
analysis, Grover's unstructured search has the <span class=""math-container"">$O(2^n)$</span> while as for classical schemes
<span class=""math-container"">$O(2^{2n+2m})$</span>, where <span class=""math-container"">$m$</span> and <span class=""math-container"">$n$</span> denote the dimensions of the image.&quot;</p>
<p>Their goal is to apply Grover's algorithm in order to find the desired pixel (darkest ones below certain threshold). This could be useful for detecting data hiding in steganography.They use NEQR for image encoding.</p>
<p>What I don't undestand is the complexity <span class=""math-container"">$O$</span> for the classical scheme. Why is it <span class=""math-container"">$2^{2n+2m}$</span> against <span class=""math-container"">$2^{n}$</span> in the quantum case?</p>
<p>Any suggestions?</p>
<p><strong>EDIT</strong>
Here is the circuit for the following list of elements (it is not the implementation of a grayscale image, is just a reduced example): according to NEQR notation, the first two qubits represent the index of four elements, i.e. 00, 01, 10 and 11, whilst the others the encoding of the value, in this case 1,2,5 and 7 {00001,01010,10101,11111}. The threshold is all numbers less than 5, that is the oracle marks the numbers 00001 and 01010. The diffuser is the standard one that can be found anywhere on the web. Of course in the case of four pixel of a grayscale images we would need 8 (for intensity) + 2 (for position) qubits.</p>
<p><a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22X%22,%22X%22%5D,%5B%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22%7Ejom5%22%5D,%5B%22%7E5l72%22%5D,%5B%22%7Ejom5%22%5D,%5B%22%7E5l72%22%5D,%5B%22Measure%22,%22Measure%22%5D%5D,%22gates%22:%5B%7B%22id%22:%22%7En9ca%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22X%22,%22X%22%5D,%5B%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,1,%22X%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7Ejom5%22,%22name%22:%22Pf%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7E40tr%22,%22name%22:%22Pf%22,%22circuit%22:%7B%22cols%22:%5B%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,1,%22X%22,1,%22X%22%5D%5D%7D%7D,%7B%22id%22:%22%7E5l72%22,%22name%22:%22D%22,%22circuit%22:%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22%5D,%5B1,1,1,1,%22H%22%5D,%5B%22X%22,%22X%22,%22X%22,%22X%22,%22X%22%5D,%5B%22H%22,%22H%22,%22H%22,%22H%22,%22H%22%5D%5D%7D%7D%5D%7D"" rel=""nofollow noreferrer"">Quirk circuit</a> (<a href=""https://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C1%2C1%2C%22X%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22X%22%2C1%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22Chance2%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22NeGate%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22NeGate%22%5D%2C%5B%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22NeGate%22%5D%2C%5B%22Chance2%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%2C%22NeGate%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%2C%22NeGate%22%5D%2C%5B%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22%E2%8A%95%22%2C%22NeGate%22%5D%2C%5B%22Measure%22%2C%22Measure%22%5D%2C%5B%22Chance2%22%5D%5D%7D"" rel=""nofollow noreferrer"">simplified</a>)</p>
<p>I don't understand how to read Quirk measurements, if I run the circuit on Qiskit I get the following results: {'11': 20, '00': 468, '10': 487, '01': 25} over 1000 shots, that is '00' and '10' are the position of the elements below my threshold, so I think it's working.</p>
",qc,complexity pixel detection quantum images p paper https nofollow noreferrer identification desired pixels image using grover quantum search algorithm stated abstract quot observed complexity analysis grover unstructured search span classical schemes span span span n denote dimensions quot p goal apply grover algorithm order find desired pixel darkest ones certain threshold could useful detecting data hiding use neqr image p undestand complexity span classical scheme span span n quantum case p suggestions p strong edit circuit following list elements implementation grayscale image reduced example according neqr notation first two qubits represent index four elements 00 01 10 11 whilst others encoding value case 7 threshold numbers less 5 oracle marks numbers 00001 diffuser standard one found anywhere web course case four pixel grayscale images would need 8 intensity 2 position p https 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 22h 22 5d 5b 22x 22 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22x 22 22x 22 5d 5b 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22x 22 5d 5b1 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b 22 7ejom5 22 5d 5b 22 7e5l72 22 5d 5b 22 7ejom5 22 5d 5b 22 7e5l72 22 5d 5b 22measure 22 22measure 22 5d 5d 22gates 22 5b 7b 22id 22 22 7en9ca 22 22circuit 22 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 22h 22 5d 5b 22x 22 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22x 22 22x 22 5d 5b 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22x 22 5d 5b1 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b1 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22x 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b 22x 22 22x 22 22x 22 22x 22 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b 22x 22 22x 22 22x 22 22x 22 22h 22 5d 5b 22x 22x 22x 22 5d 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 22h 22 5d 5b 22x 22x 22x 22 5d 5d 7d 7d 7b 22id 22 22 7ejom5 22 22name 22 22pf 22 22circuit 22 7b 22cols 22 5b 5b 22x 22 22x 22 22x 22 22x 22 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b 22x 22 22x 22 22x 22 22x 22 22h 22 5d 5b 22x 22x 22x 22 5d 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 22h 22 5d 5b 22x 22x 22x 22 5d 5d 7d 7d 7b 22id 22 22 7e40tr 22 22name 22 22pf 22 22circuit 22 7b 22cols 22 5b 5b 22x 22 22x 22 22x 22 22x 22 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 5b 22x 22 22x 22 22x 22 22x 22 22h 22 5d 5b 22x 22x 22x 22 5d 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 22h 22 5d 5b 22x 22x 22x 22 5d 5d 7d 7d 7b 22id 22 22 7e5l72 22 22name 22 22d 22 22circuit 22 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 22h 22 5d 5b 22x 22 22x 22 22x 22 22x 22 22x 22 5d 22h 22 5d 5b 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22 e2 80 a2 22 22x 22 5d 22h 22 5d 5b 22x 22 22x 22 22x 22 22x 22 22x 22 5d 5b 22h 22 22h 22 22h 22 22h 22 22h 22 5d 5d 7d 7d 5d 7d nofollow noreferrer quirk circuit https 7b 22cols 22 3a 5b 5b 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 2c 22h 22 5d 2c 5b 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c1 2c1 2c 22x 22 5d 2c 5b 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c1 2c 22x 22 5d 2c 5b 22 e2 80 a2 22 2c 22 e2 97 a6 22 2c 22x 22 2c1 2c 22x 22 5d 2c 5b 22 e2 80 a2 22 2c 22 e2 80 a2 22 2c 22x 22 2c 22x 22 2c 22x 22 5d 2c 5b 22chance2 22 5d 2c 5b 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c 22negate 22 5d 2c 5b 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c 22 e2 97 a6 22 2c 22negate 22 5d 2c 5b 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22negate 22 5d 2c 5b 22chance2 22 5d 2c 5b 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c 22 e2 97 a6 22 2c 22negate 22 5d 2c 5b 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c 22 e2 97 a6 22 2c 22 e2 80 a2 22 2c 22negate 22 5d 2c 5b 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22 e2 8a 95 22 2c 22negate 22 5d 2c 5b 22measure 22 2c 22measure 22 5d 2c 5b 22chance2 22 5d 5d 7d nofollow noreferrer simplified p understand read quirk measurements run circuit qiskit get following results 20 468 487 25 1000 shots position elements threshold think,"[(7, 0.022182474), (10, 0.021861378), (12, 0.89486635), (13, 0.0195118), (18, 0.017366499)]"
37084,37086.0,2024-03-04 22:18:03,1,69,"<p>I'm trying to implement the <span class=""math-container"">$[\![7,1,3]\!]$</span> Steane code on <code>Stim</code>. My circuit is below:</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit('''
    R 0 1 2 3 4 5 6 7 8 9 10 11 12
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6

    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]
                           
    X_ERROR(1) 0
                           
    REPEAT 3 {
        MPP X0*X2*X4*X6
        MPP X3*X4*X5*X6
        MPP X1*X2*X5*X6
        
        MPP Z0*Z2*Z4*Z6
        MPP Z3*Z4*Z5*Z6
        MPP Z1*Z2*Z5*Z6
                                            
        .
        .  
        '''  
    }
</code></pre>
<p>The idea is that the first part puts my qubits into a logical state by measuring the <span class=""math-container"">$X$</span> stabilizers. I need to do two things.</p>
<ol>
<li><p>Keep the outcomes of the first three MPPs somewhere since these eigenvalues define my logical <span class=""math-container"">$\vert 0\rangle$</span>.</p>
</li>
<li><p>I want to implement a correction based on the stabilizer eigenvalues in the <code>REPEAT</code> section. If all of <code>MPP X0 X2 X4 X6</code>, <code>MPP X3 X4 X5 X6</code> and <code>MPP X1 X2 X5 X6</code> disagree with the answers in 1., then I have a <span class=""math-container"">$Z$</span> error on qubit <span class=""math-container"">$6$</span>. I want to implement a controlled <span class=""math-container"">$Z$</span> gate on qubit <span class=""math-container"">$6$</span> with the control being decided by the aforementioned logic.</p>
</li>
</ol>
<p>What's the best way to do this?</p>
<p>EDIT: Updated circuit based on Craig Gidney's answer.</p>
<pre><code>circuit = stim.Circuit('''
R 0 1 2 3 4 5 6 7 8 9 10 11 12

MPP X0*X2*X4*X6
MPP X3*X4*X5*X6
MPP X1*X2*X5*X6

MPP Z0*Z2*Z4*Z6
MPP Z3*Z4*Z5*Z6
MPP Z1*Z2*Z5*Z6
                       
X_ERROR(1) 0
                       
REPEAT 2 {
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    
    MPP Z0*Z2*Z4*Z6
    MPP Z3*Z4*Z5*Z6
    MPP Z1*Z2*Z5*Z6
                                        
    DETECTOR rec[-6] rec[-12]
    DETECTOR rec[-5] rec[-11]
    DETECTOR rec[-4] rec[-10]
    DETECTOR rec[-3] rec[-9]                                      
    DETECTOR rec[-2] rec[-8]
    DETECTOR rec[-1] rec[-7]
}
''')                                            
</code></pre>
<p>Indeed, I only get one <code>True</code> on the stabilizer <span class=""math-container"">$Z0Z2Z4Z6$</span> in the first round as that's where the error is.</p>
",How to implement a controlled gate in Stim with the following control logic?,<error-correction><stim>,1,0,,,"How to implement a controlled gate in Stim with the following control logic? <p>I'm trying to implement the <span class=""math-container"">$[\![7,1,3]\!]$</span> Steane code on <code>Stim</code>. My circuit is below:</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit('''
    R 0 1 2 3 4 5 6 7 8 9 10 11 12
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6

    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]
                           
    X_ERROR(1) 0
                           
    REPEAT 3 {
        MPP X0*X2*X4*X6
        MPP X3*X4*X5*X6
        MPP X1*X2*X5*X6
        
        MPP Z0*Z2*Z4*Z6
        MPP Z3*Z4*Z5*Z6
        MPP Z1*Z2*Z5*Z6
                                            
        .
        .  
        '''  
    }
</code></pre>
<p>The idea is that the first part puts my qubits into a logical state by measuring the <span class=""math-container"">$X$</span> stabilizers. I need to do two things.</p>
<ol>
<li><p>Keep the outcomes of the first three MPPs somewhere since these eigenvalues define my logical <span class=""math-container"">$\vert 0\rangle$</span>.</p>
</li>
<li><p>I want to implement a correction based on the stabilizer eigenvalues in the <code>REPEAT</code> section. If all of <code>MPP X0 X2 X4 X6</code>, <code>MPP X3 X4 X5 X6</code> and <code>MPP X1 X2 X5 X6</code> disagree with the answers in 1., then I have a <span class=""math-container"">$Z$</span> error on qubit <span class=""math-container"">$6$</span>. I want to implement a controlled <span class=""math-container"">$Z$</span> gate on qubit <span class=""math-container"">$6$</span> with the control being decided by the aforementioned logic.</p>
</li>
</ol>
<p>What's the best way to do this?</p>
<p>EDIT: Updated circuit based on Craig Gidney's answer.</p>
<pre><code>circuit = stim.Circuit('''
R 0 1 2 3 4 5 6 7 8 9 10 11 12

MPP X0*X2*X4*X6
MPP X3*X4*X5*X6
MPP X1*X2*X5*X6

MPP Z0*Z2*Z4*Z6
MPP Z3*Z4*Z5*Z6
MPP Z1*Z2*Z5*Z6
                       
X_ERROR(1) 0
                       
REPEAT 2 {
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    
    MPP Z0*Z2*Z4*Z6
    MPP Z3*Z4*Z5*Z6
    MPP Z1*Z2*Z5*Z6
                                        
    DETECTOR rec[-6] rec[-12]
    DETECTOR rec[-5] rec[-11]
    DETECTOR rec[-4] rec[-10]
    DETECTOR rec[-3] rec[-9]                                      
    DETECTOR rec[-2] rec[-8]
    DETECTOR rec[-1] rec[-7]
}
''')                                            
</code></pre>
<p>Indeed, I only get one <code>True</code> on the stabilizer <span class=""math-container"">$Z0Z2Z4Z6$</span> in the first round as that's where the error is.</p>
",qc,implement controlled gate stim following control logic p trying implement span steane code code stim circuit pre code circuit r 0 1 2 3 4 5 6 7 8 9 10 11 12 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 detector rec detector rec detector rec 1 0 repeat 3 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp z0 z2 z4 z6 mpp z3 z4 z5 z6 mpp z1 z2 z5 z6 p idea first part puts qubits logical state measuring span x stabilizers need two ol li p keep outcomes first three mpps somewhere since eigenvalues define logical span li p want implement correction based stabilizer eigenvalues code repeat section code mpp x0 x2 x4 x6 code mpp x3 x4 x5 x6 code mpp x1 x2 x5 x6 disagree answers span z error qubit span 6 want implement controlled span z gate qubit span 6 control decided aforementioned p best way p edit updated circuit based craig gidney pre code circuit r 0 1 2 3 4 5 6 7 8 9 10 11 12 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp z0 z2 z4 z6 mpp z3 z4 z5 z6 mpp z1 z2 z5 z6 1 0 repeat 2 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp z0 z2 z4 z6 mpp z3 z4 z5 z6 mpp z1 z2 z5 z6 detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec p indeed get one code true stabilizer span z0z2z4z6 first round error,"[(3, 0.042973883), (5, 0.10318422), (6, 0.41236302), (12, 0.19291776), (14, 0.071446456), (17, 0.093595915), (18, 0.08305952)]"
37124,,2024-03-06 19:02:43,3,63,"<p>I'm working on implementing the Quantum Fourier Transform (QFT) using Qiskit. I've encountered an issue where unexpected rotations occur in the presence of a Hadamard circuit, which contrasts with the expected behavior based on my simulations using Quirk. I suspect there might be a mistake in my Qiskit code, but I'm not certain about the source of the discrepancy.</p>
<p>Here's a detailed description of the problem:</p>
<p>In my Qiskit implementation of QFT, I observe rotations being applied in places where, theoretically, there shouldn't be any, especially after setting up the Hadamard gates for qubit initialization.
To cross-reference my results, I used the Quirk quantum circuit simulator with a similar setup. Here's the <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22Chance3%22%5D,%5B%22H%22,%22H%22,%22H%22%5D,%5B%22Swap%22,1,%22Swap%22%5D,%5B%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B1,%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B%22Z%5E%C2%BC%22,1,%22%E2%80%A2%22%5D,%5B1,1,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk circuit link</a>, which does not exhibit the same unexpected rotations.
I'm puzzled by the differences in the outcome between Qiskit and Quirk, as I expected the behavior of the QFT to be consistent across different platforms.
Below is the relevant portion of my Qiskit code where I think the issue might be occurring:</p>
<pre><code>def qft_inv(qc, a, b):
reverse(qc, a, b)
qc.barrier()
for i in range(a, b):
    for j in range(i - 1, a - 1, -1):
        theta = -np.pi / (2 ** (i - j))
        qc.crz(theta, i, j)
        visualize_on_bloch(qc)
    qc.h(i)
qc.barrier()
visualize_on_bloch(qc)
</code></pre>
<p>I'm looking for insights on why my Qiskit implementation behaves differently from the Quirk simulation and whether there's something I'm missing or doing incorrectly in my code. Any suggestions on how to align my Qiskit implementation with the expected theoretical behavior observed in Quirk would be greatly appreciated.</p>
<p>Thank you in advance for your assistance!</p>
<p><a href=""https://i.sstatic.net/wuuD9.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wuuD9.png"" alt=""enter image description here"" /></a></p>
",Unexpected Rotations in QFT Implementation with Qiskit vs. Expected Behavior in Quirk,<qiskit><quantum-circuit><quantum-fourier-transform>,1,2,,,"Unexpected Rotations in QFT Implementation with Qiskit vs. Expected Behavior in Quirk <p>I'm working on implementing the Quantum Fourier Transform (QFT) using Qiskit. I've encountered an issue where unexpected rotations occur in the presence of a Hadamard circuit, which contrasts with the expected behavior based on my simulations using Quirk. I suspect there might be a mistake in my Qiskit code, but I'm not certain about the source of the discrepancy.</p>
<p>Here's a detailed description of the problem:</p>
<p>In my Qiskit implementation of QFT, I observe rotations being applied in places where, theoretically, there shouldn't be any, especially after setting up the Hadamard gates for qubit initialization.
To cross-reference my results, I used the Quirk quantum circuit simulator with a similar setup. Here's the <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22Chance3%22%5D,%5B%22H%22,%22H%22,%22H%22%5D,%5B%22Swap%22,1,%22Swap%22%5D,%5B%22H%22%5D,%5B%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B1,%22H%22%5D,%5B1,%22Z%5E%C2%BD%22,%22%E2%80%A2%22%5D,%5B%22Z%5E%C2%BC%22,1,%22%E2%80%A2%22%5D,%5B1,1,%22H%22%5D%5D%7D"" rel=""nofollow noreferrer"">Quirk circuit link</a>, which does not exhibit the same unexpected rotations.
I'm puzzled by the differences in the outcome between Qiskit and Quirk, as I expected the behavior of the QFT to be consistent across different platforms.
Below is the relevant portion of my Qiskit code where I think the issue might be occurring:</p>
<pre><code>def qft_inv(qc, a, b):
reverse(qc, a, b)
qc.barrier()
for i in range(a, b):
    for j in range(i - 1, a - 1, -1):
        theta = -np.pi / (2 ** (i - j))
        qc.crz(theta, i, j)
        visualize_on_bloch(qc)
    qc.h(i)
qc.barrier()
visualize_on_bloch(qc)
</code></pre>
<p>I'm looking for insights on why my Qiskit implementation behaves differently from the Quirk simulation and whether there's something I'm missing or doing incorrectly in my code. Any suggestions on how to align my Qiskit implementation with the expected theoretical behavior observed in Quirk would be greatly appreciated.</p>
<p>Thank you in advance for your assistance!</p>
<p><a href=""https://i.sstatic.net/wuuD9.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wuuD9.png"" alt=""enter image description here"" /></a></p>
",qc,unexpected rotations qft implementation qiskit expected behavior quirk p working implementing quantum fourier transform qft using qiskit encountered issue unexpected rotations occur presence hadamard circuit contrasts expected behavior based simulations using quirk suspect might mistake qiskit code certain source p detailed description problem p qiskit implementation qft observe rotations applied places theoretically especially setting hadamard gates qubit initialization results used quirk quantum circuit simulator similar setup https 7b 22cols 22 5b 5b 22chance3 22 5d 5b 22h 22 22h 22 22h 22 5d 5b 22swap 22swap 22 5d 5b 22h 22 5d 5b 22z 5e c2 bd 22 22 e2 80 a2 22 5d 5b1 22h 22 5d 5b1 22z 5e c2 bd 22 22 e2 80 a2 22 5d 5b 22z 5e c2 bc 22 e2 80 a2 22 5d 22h 22 5d 5d 7d nofollow noreferrer quirk circuit link exhibit unexpected rotations puzzled differences outcome qiskit quirk expected behavior qft consistent across different platforms relevant portion qiskit code think issue might occurring pre code def qc b reverse qc b range b j range 1 1 theta 2 j theta j qc qc p looking insights qiskit implementation behaves differently quirk simulation whether something missing incorrectly code suggestions align qiskit implementation expected theoretical behavior observed quirk would greatly p thank advance assistance p https nofollow noreferrer img https enter image description,"[(0, 0.1344647), (2, 0.0130634755), (4, 0.07955922), (7, 0.051020924), (9, 0.12745586), (12, 0.35052088), (14, 0.23342669)]"
37166,,2024-03-09 06:11:56,2,42,"<p>I am trying to bulid a quantum convolutional neural network for image classification with Pennylane and Keras but the model isn't training and I keep getting the warning:</p>
<blockquote>
<p>WARNING:tensorflow:Gradients do not exist for variables ['params:0',
'params:0'] when minimizing the loss. If you're using
<code>model.compile()</code>, did you forget to provide a <code>loss</code> argument?</p>
</blockquote>
<p>How do I fix this issue?</p>
<p>I have used code from <a href=""https://discuss.pennylane.ai/t/quantum-convolution-neural-network-using-keras/2905"" rel=""nofollow noreferrer"">Quantum Convolutional Neural Network using Keras</a> and <a href=""https://pennylane.ai/qml/demos/tutorial_quanvolution/"" rel=""nofollow noreferrer"">Quanvolutional Neural Network</a>.</p>
<p>Here are the relavent snippents of my code:</p>
<pre><code>import pennylane as qml
from pennylane import numpy as np
import tensorflow as tf
from tensorflow import keras
</code></pre>
<p>This code creates the quantum circuit to act as a filter:</p>
<pre><code>q = 4

layers=2

dev = qml.device(&quot;lightning.qubit&quot;, wires=q)

#params has dimension 2
def unit2(params, wires=[0, 1]):
    for j in range(2):
        qml.RY(params[j], wires=wires[j])
    qml.CNOT(wires=wires)

##### POOLING UNITS

#ZX pooling, params has dimensions 2
def pool1(params, wires=[0, 1]):
    qml.CRZ(params[0], wires=wires)
    qml.CRX(params[1], wires=wires)

@qml.qnode(dev, diff_method='parameter-shift')
def circuit(inputs, params):
    height = int(q/2)
    site = range(int(q))
    
    ##### ENCODING
    for i in range(q):
        qml.RX(inputs[i]*2*np.pi, wires=i)
    
    count = 0
    pdim = 2 #param dimension of unit
    for t in range(1, layers + 1):
        l = int(len(site)/2)
        
        ### CONVOLUTION
        for i in range(l):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i], site[2*i + 1]])
            count += pdim
        for i in range(l-1):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i + 1], site[2*i + 2]])
            count += pdim
        
        ### POOLING
        for i in range(l):
            ## Change unit here
            pool1(params[count:count + 2], wires=[site[2*i], site[2*i + 1]])
            count += 2
            
        trial = []
        for u in range(int(len(site)/2)):
            trial = trial + [site[2*u+1]]
        site = trial
    #print(count)
        
    return [qml.expval(qml.PauliZ(q-1))] #### Only measures off final qubit
</code></pre>
<p>which looks like this where I only read off the final qubit (numbers on gates are placeholders for the filters weights):
<a href=""https://i.sstatic.net/iQkMe.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/iQkMe.png"" alt=""graph of quantum circuit defined above"" /></a></p>
<p>I create the model here:</p>
<pre><code>class QuantumClassifier(tf.keras.Model):

    def __init__(self, filter_channels, kernal_params):
        super(QuantumClassifier,self).__init__()
        self.filters = filter_channels
        self.qfilters = []
        weight_shapes = {&quot;params&quot;: (kernal_params)}
        for i in range(filter_channels):
            self.qfilters.append(qml.qnn.KerasLayer(circuit, weight_shapes,output_dim=1, name='quantum_filter')) 
        self.hidden = tf.keras.layers.Dense(128, activation = 'relu')
        self.flatten = tf.keras.layers.Flatten()
        self.dense = tf.keras.layers.Dense(10, activation='softmax')
        print('INITILIZED')


    def call(self, inputs):
 
        width, length = inputs.shape[1], inputs.shape[2]
        batch_size = inputs.shape[0]

        total_out = tf.TensorArray(tf.float32, size=batch_size)
        count = 0
        #perform convolution with no padding and stride of 2
        for a in range(batch_size):
            
            out = np.zeros((width//2, length//2, self.filters))
            print(f&quot;Image: {a}&quot;)
            
            
            for i in range(0, width, 2):
                
                for j in range(0, length, 2):
                    
                    for f in range(self.filters):
                        
                        # convolution windows, now only applying to one channel image
                        sub_input =  inputs[a,i:i+q, j:j+q, :]
                        # flatten into 1-D
                        sub_input = tf.reshape(sub_input, [-1])
                        quantum_filter = self.qfilters[f]
                    
                        
                        out[i//2][j//2][f] = quantum_filter(sub_input)
                                

            total_out = total_out.write(count, out)
            count += 1
            
        total_out = total_out.stack()
        print(&quot;All input data for one batch have been convolved!&quot;)

        x = self.flatten(total_out)

        x = self.hidden(x)

        x = self.dense(x)
        return x
</code></pre>
<p>I created the model for 2 quantum filters where each one has 14 parameters:</p>
<pre><code>model = QuantumClassifier(2, 14)
model.compile(loss='sparse_categorical_crossentropy',
             optimizer='adam',
             metrics=['accuracy'])
r = model.fit(x_train_small, y_train, epochs=10, batch_size=16, validation_data=(x_test_small, y_test))
</code></pre>
<p>Here is the dataset I am using:</p>
<pre><code>mnist_dataset = keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist_dataset.load_data()
# Reduce dataset size
x_train = x_train[:n_train]
y_train = y_train[:n_train]
x_test = x_test[:n_test]
y_test = y_test[:n_test]
# Normalize pixel values within 0 and 1
x_train = x_train / 255
x_test = x_test / 255
# # Add extra dimension for &quot;color&quot; channels
x_train = np.array(x_train[..., tf.newaxis])
x_test = np.array(x_test[..., tf.newaxis])
print(f&quot;train_images_shape: {x_train.shape}&quot;)
# use Bilinear Interpolation for downscaling
x_train_small = tf.image.resize(x_train, (10,10)).numpy()
x_test_small = tf.image.resize(x_test, (10,10)).numpy()
print(f&quot;x_train_reshape: {x_train_small.shape}&quot;)
</code></pre>
<p>This is all in:
python==3.11.5
tensorflow==2.15.0
PennyLane==0.34.0</p>
<p>Any solutions (or ways to speed up my code) greatly appreciated!</p>
",Quantum Convolutional Neural Network not producing gradients,<programming><machine-learning><pennylane><neural-network><quantum-neural-network>,0,1,,,"Quantum Convolutional Neural Network not producing gradients <p>I am trying to bulid a quantum convolutional neural network for image classification with Pennylane and Keras but the model isn't training and I keep getting the warning:</p>
<blockquote>
<p>WARNING:tensorflow:Gradients do not exist for variables ['params:0',
'params:0'] when minimizing the loss. If you're using
<code>model.compile()</code>, did you forget to provide a <code>loss</code> argument?</p>
</blockquote>
<p>How do I fix this issue?</p>
<p>I have used code from <a href=""https://discuss.pennylane.ai/t/quantum-convolution-neural-network-using-keras/2905"" rel=""nofollow noreferrer"">Quantum Convolutional Neural Network using Keras</a> and <a href=""https://pennylane.ai/qml/demos/tutorial_quanvolution/"" rel=""nofollow noreferrer"">Quanvolutional Neural Network</a>.</p>
<p>Here are the relavent snippents of my code:</p>
<pre><code>import pennylane as qml
from pennylane import numpy as np
import tensorflow as tf
from tensorflow import keras
</code></pre>
<p>This code creates the quantum circuit to act as a filter:</p>
<pre><code>q = 4

layers=2

dev = qml.device(&quot;lightning.qubit&quot;, wires=q)

#params has dimension 2
def unit2(params, wires=[0, 1]):
    for j in range(2):
        qml.RY(params[j], wires=wires[j])
    qml.CNOT(wires=wires)

##### POOLING UNITS

#ZX pooling, params has dimensions 2
def pool1(params, wires=[0, 1]):
    qml.CRZ(params[0], wires=wires)
    qml.CRX(params[1], wires=wires)

@qml.qnode(dev, diff_method='parameter-shift')
def circuit(inputs, params):
    height = int(q/2)
    site = range(int(q))
    
    ##### ENCODING
    for i in range(q):
        qml.RX(inputs[i]*2*np.pi, wires=i)
    
    count = 0
    pdim = 2 #param dimension of unit
    for t in range(1, layers + 1):
        l = int(len(site)/2)
        
        ### CONVOLUTION
        for i in range(l):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i], site[2*i + 1]])
            count += pdim
        for i in range(l-1):
            ## Change unit here
            unit2(params[count:count + pdim], wires=[site[2*i + 1], site[2*i + 2]])
            count += pdim
        
        ### POOLING
        for i in range(l):
            ## Change unit here
            pool1(params[count:count + 2], wires=[site[2*i], site[2*i + 1]])
            count += 2
            
        trial = []
        for u in range(int(len(site)/2)):
            trial = trial + [site[2*u+1]]
        site = trial
    #print(count)
        
    return [qml.expval(qml.PauliZ(q-1))] #### Only measures off final qubit
</code></pre>
<p>which looks like this where I only read off the final qubit (numbers on gates are placeholders for the filters weights):
<a href=""https://i.sstatic.net/iQkMe.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/iQkMe.png"" alt=""graph of quantum circuit defined above"" /></a></p>
<p>I create the model here:</p>
<pre><code>class QuantumClassifier(tf.keras.Model):

    def __init__(self, filter_channels, kernal_params):
        super(QuantumClassifier,self).__init__()
        self.filters = filter_channels
        self.qfilters = []
        weight_shapes = {&quot;params&quot;: (kernal_params)}
        for i in range(filter_channels):
            self.qfilters.append(qml.qnn.KerasLayer(circuit, weight_shapes,output_dim=1, name='quantum_filter')) 
        self.hidden = tf.keras.layers.Dense(128, activation = 'relu')
        self.flatten = tf.keras.layers.Flatten()
        self.dense = tf.keras.layers.Dense(10, activation='softmax')
        print('INITILIZED')


    def call(self, inputs):
 
        width, length = inputs.shape[1], inputs.shape[2]
        batch_size = inputs.shape[0]

        total_out = tf.TensorArray(tf.float32, size=batch_size)
        count = 0
        #perform convolution with no padding and stride of 2
        for a in range(batch_size):
            
            out = np.zeros((width//2, length//2, self.filters))
            print(f&quot;Image: {a}&quot;)
            
            
            for i in range(0, width, 2):
                
                for j in range(0, length, 2):
                    
                    for f in range(self.filters):
                        
                        # convolution windows, now only applying to one channel image
                        sub_input =  inputs[a,i:i+q, j:j+q, :]
                        # flatten into 1-D
                        sub_input = tf.reshape(sub_input, [-1])
                        quantum_filter = self.qfilters[f]
                    
                        
                        out[i//2][j//2][f] = quantum_filter(sub_input)
                                

            total_out = total_out.write(count, out)
            count += 1
            
        total_out = total_out.stack()
        print(&quot;All input data for one batch have been convolved!&quot;)

        x = self.flatten(total_out)

        x = self.hidden(x)

        x = self.dense(x)
        return x
</code></pre>
<p>I created the model for 2 quantum filters where each one has 14 parameters:</p>
<pre><code>model = QuantumClassifier(2, 14)
model.compile(loss='sparse_categorical_crossentropy',
             optimizer='adam',
             metrics=['accuracy'])
r = model.fit(x_train_small, y_train, epochs=10, batch_size=16, validation_data=(x_test_small, y_test))
</code></pre>
<p>Here is the dataset I am using:</p>
<pre><code>mnist_dataset = keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist_dataset.load_data()
# Reduce dataset size
x_train = x_train[:n_train]
y_train = y_train[:n_train]
x_test = x_test[:n_test]
y_test = y_test[:n_test]
# Normalize pixel values within 0 and 1
x_train = x_train / 255
x_test = x_test / 255
# # Add extra dimension for &quot;color&quot; channels
x_train = np.array(x_train[..., tf.newaxis])
x_test = np.array(x_test[..., tf.newaxis])
print(f&quot;train_images_shape: {x_train.shape}&quot;)
# use Bilinear Interpolation for downscaling
x_train_small = tf.image.resize(x_train, (10,10)).numpy()
x_test_small = tf.image.resize(x_test, (10,10)).numpy()
print(f&quot;x_train_reshape: {x_train_small.shape}&quot;)
</code></pre>
<p>This is all in:
python==3.11.5
tensorflow==2.15.0
PennyLane==0.34.0</p>
<p>Any solutions (or ways to speed up my code) greatly appreciated!</p>
",qc,quantum convolutional neural network producing gradients p trying bulid quantum convolutional neural network image classification pennylane keras model training keep getting warning blockquote p warning tensorflow gradients exist variables minimizing loss using code forget provide code loss argument p fix issue p used code https nofollow noreferrer quantum convolutional neural network using keras https nofollow noreferrer quanvolutional neural network p relavent snippents code pre code import pennylane qml pennylane import numpy np import tensorflow tf tensorflow import keras p code creates quantum circuit act filter pre code q 4 dev quot quot params dimension 2 def unit2 params 0 1 j range 2 params j j pooling units zx pooling params dimensions 2 def pool1 params 0 1 params 0 params 1 dev def circuit inputs params height int site range int q encoding range q inputs 2 count 0 pdim 2 param dimension unit range 1 layers 1 l int len site convolution range l change unit unit2 params count count pdim site 2 site 2 1 count pdim range change unit unit2 params count count pdim site 2 1 site 2 2 count pdim pooling range l change unit pool1 params count count 2 site 2 site 2 1 count 2 trial u range int len site trial trial site 2 site trial print count return measures final qubit p looks like read final qubit numbers gates placeholders filters weights https nofollow noreferrer img https graph quantum circuit defined p create model pre code class quantumclassifier def self super quantumclassifier self quot params quot range circuit 128 activation 10 print def call self inputs width length 1 2 0 count 0 perform convolution padding stride 2 range print f quot image quot range 0 width 2 j range 0 length 2 f range convolution windows applying one channel image inputs j flatten f f count count 1 print quot input data one batch convolved quot x x x x x return x p created model 2 quantum filters one 14 parameters pre code model quantumclassifier 2 14 r p dataset using pre code reduce dataset size normalize pixel values within 0 1 255 255 add extra dimension quot color quot channels print f quot quot use bilinear interpolation downscaling print f quot quot p p solutions ways speed code greatly appreciated,"[(0, 0.3993897), (2, 0.102175035), (3, 0.014965662), (4, 0.05334218), (8, 0.1444807), (10, 0.07506502), (12, 0.07879626), (14, 0.03565863), (16, 0.01086846), (19, 0.0702024)]"
37207,,2024-03-12 02:14:27,2,66,"<p>I am currently studying the paper <a href=""http://www2.lns.mit.edu/%7Eavinatan/research/mpqc.pdf"" rel=""nofollow noreferrer"">Secure Multiparty Quantum Computation with (Only) a Strict Honest Majority</a> and had a really hard time understanding the Quantum Authentication Scheme provided by the authors. As far as classical polynomial error correction codes go, I have had some experience with <a href=""https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction"" rel=""nofollow noreferrer"">Reed-Solomon Code</a>, but this does not seam to follow the same structure.</p>
<p>First of all, in Reed-Solomon the message <span class=""math-container"">$m = (m_0,..,m_d)$</span> takes the role of the coefficients of the polynomial <span class=""math-container"">$p_m$</span>. However, in the above mentioned paper, the message seams to be just this <span class=""math-container"">$a \in F_p$</span> and the encoding to a polynomial <span class=""math-container"">$p_m$</span> has been replaced with the sum:
<span class=""math-container"">$$|S_a^r⟩ = \frac{1}{\sqrt{p^r}}\sum_{f(0)=a,\\  deg(f) \leq r} |f(a_1),...,f(a_m)⟩$$</span> where <span class=""math-container"">$a_1,...,a_m \in F_p-{0}$</span> are known to everyone.</p>
<p>I am having a lot of trouble understanding this sum. My first (maybe really naive) thought that I cannot get rid of is the following: isn't this an infinite sum? In Reed-Solomon Codes the coefficients of all polynomials are determined by the demand that the polynomial passes through specific points. I see no such constrain here. Since the only constrain is the degree and the constant of the polynomial, what is stopping us from picking all integers (or even real numbers) as our coefficients?</p>
<p>My other question is: why does this sum even exist? Why do we need a sum of all the polynomials with such properties in the quantum world and not in the classical world?</p>
<p>I would really appreciate some help and I am sorry in advance if these questions are very naive, as I am new to the field. I have also found <a href=""https://www.cs.huji.ac.il/w%7Edoria/Qcomp2005/week8.pdf"" rel=""nofollow noreferrer"">these lecture notes</a> discussing the same Polynomial Quantum Error Correcting Code. I am providing them because the classical polynomial code structure that they present is &quot;similarly different&quot; from Reed-Solomon, in the sense that the encoded message is not the coefficient of the polynomial.</p>
",Understanding Polynomial Quantum Error Correcting Codes,<error-correction>,0,4,,,"Understanding Polynomial Quantum Error Correcting Codes <p>I am currently studying the paper <a href=""http://www2.lns.mit.edu/%7Eavinatan/research/mpqc.pdf"" rel=""nofollow noreferrer"">Secure Multiparty Quantum Computation with (Only) a Strict Honest Majority</a> and had a really hard time understanding the Quantum Authentication Scheme provided by the authors. As far as classical polynomial error correction codes go, I have had some experience with <a href=""https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction"" rel=""nofollow noreferrer"">Reed-Solomon Code</a>, but this does not seam to follow the same structure.</p>
<p>First of all, in Reed-Solomon the message <span class=""math-container"">$m = (m_0,..,m_d)$</span> takes the role of the coefficients of the polynomial <span class=""math-container"">$p_m$</span>. However, in the above mentioned paper, the message seams to be just this <span class=""math-container"">$a \in F_p$</span> and the encoding to a polynomial <span class=""math-container"">$p_m$</span> has been replaced with the sum:
<span class=""math-container"">$$|S_a^r⟩ = \frac{1}{\sqrt{p^r}}\sum_{f(0)=a,\\  deg(f) \leq r} |f(a_1),...,f(a_m)⟩$$</span> where <span class=""math-container"">$a_1,...,a_m \in F_p-{0}$</span> are known to everyone.</p>
<p>I am having a lot of trouble understanding this sum. My first (maybe really naive) thought that I cannot get rid of is the following: isn't this an infinite sum? In Reed-Solomon Codes the coefficients of all polynomials are determined by the demand that the polynomial passes through specific points. I see no such constrain here. Since the only constrain is the degree and the constant of the polynomial, what is stopping us from picking all integers (or even real numbers) as our coefficients?</p>
<p>My other question is: why does this sum even exist? Why do we need a sum of all the polynomials with such properties in the quantum world and not in the classical world?</p>
<p>I would really appreciate some help and I am sorry in advance if these questions are very naive, as I am new to the field. I have also found <a href=""https://www.cs.huji.ac.il/w%7Edoria/Qcomp2005/week8.pdf"" rel=""nofollow noreferrer"">these lecture notes</a> discussing the same Polynomial Quantum Error Correcting Code. I am providing them because the classical polynomial code structure that they present is &quot;similarly different&quot; from Reed-Solomon, in the sense that the encoded message is not the coefficient of the polynomial.</p>
",qc,understanding polynomial quantum error correcting codes p currently studying paper http nofollow noreferrer secure multiparty quantum computation strict honest majority really hard time understanding quantum authentication scheme provided authors far classical polynomial error correction codes go experience https e2 80 nofollow noreferrer code seam follow p first message span takes role coefficients polynomial span however mentioned paper message seams span encoding polynomial span replaced sum span 1 f 0 deg f r f span 0 known p lot trouble understanding sum first maybe really naive thought get rid following infinite sum codes coefficients polynomials determined demand polynomial passes specific points see constrain since constrain degree constant polynomial stopping us picking integers even real numbers coefficients p question sum even exist need sum polynomials properties quantum world classical world p would really appreciate help sorry advance questions naive new field also found https nofollow noreferrer lecture notes discussing polynomial quantum error correcting code providing classical polynomial code structure present quot similarly different quot sense encoded message coefficient,"[(1, 0.13206641), (2, 0.023696309), (3, 0.229027), (5, 0.115575805), (7, 0.07010376), (8, 0.065670274), (9, 0.08834778), (10, 0.028723888), (12, 0.013024444), (13, 0.21386695), (19, 0.019348398)]"
37227,,2024-03-13 08:11:48,1,83,"<p>I am quite confused with the MatrixOp.to_pauli_op() API.</p>
<p>I have a hamiltonian, and it is given as input to a
API <code>MatrixOp</code>.</p>
<pre><code>import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.utils import QuantumInstance 
from qiskit import IBMQ, transpile
from qiskit import Aer

from qiskit.algorithms import VQE
    
# This Hamiltonian is not unitary.It is generated from matrix A and B (AX =B)
Hamiltonian =  np.array([[ 4.07981221, -3.6713615,   1.3943662,  -1.05164319], 
 [-3.6713615,   5.88262911, -4.14084507,  1.37558685],
 [ 1.3943662,  -4.14084507,  5.83098592, -3.54929577],
 [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
    

H_op = MatrixOp(Hamiltonian).to_pauli_op()
print(H_op)
print(type(H_op)) 
</code></pre>
<p>How can a non-unitary matrix be given as input to a qiskit API?</p>
",Usage of qiskit API MatrixOp.to_pauli_op(),<qiskit><programming><vqe>,0,3,,,"Usage of qiskit API MatrixOp.to_pauli_op() <p>I am quite confused with the MatrixOp.to_pauli_op() API.</p>
<p>I have a hamiltonian, and it is given as input to a
API <code>MatrixOp</code>.</p>
<pre><code>import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.utils import QuantumInstance 
from qiskit import IBMQ, transpile
from qiskit import Aer

from qiskit.algorithms import VQE
    
# This Hamiltonian is not unitary.It is generated from matrix A and B (AX =B)
Hamiltonian =  np.array([[ 4.07981221, -3.6713615,   1.3943662,  -1.05164319], 
 [-3.6713615,   5.88262911, -4.14084507,  1.37558685],
 [ 1.3943662,  -4.14084507,  5.83098592, -3.54929577],
 [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
    

H_op = MatrixOp(Hamiltonian).to_pauli_op()
print(H_op)
print(type(H_op)) 
</code></pre>
<p>How can a non-unitary matrix be given as input to a qiskit API?</p>
",qc,usage qiskit api p quite confused p hamiltonian given input api code matrixop pre code import numpy np import matrixop import efficientsu2 import cobyla import quantuminstance qiskit import ibmq transpile qiskit import aer import vqe hamiltonian generated matrix b ax hamiltonian matrixop hamiltonian print print type p matrix given input qiskit api,"[(0, 0.6238338), (1, 0.07392214), (11, 0.03843962), (12, 0.057908766), (14, 0.1462138), (16, 0.05699866)]"
37238,,2024-03-13 18:50:28,1,1146,"<p>I am Using Qiskit SDK 1.0. I have a problem with <code>get_statevector</code> in qiskit SDK 1.0 and using <code>BasicSimulator</code>. My code is attached below.</p>
<pre><code>simulator = BasicSimulator()#Aer.get_backend('statevector_simulator')
result = simulator.run(circ).result()#execute(circ,simulator).result()
sv = result.get_statevector(circ)
print(sv)
</code></pre>
",How to use get_statevector in Qiskit SDK 1.0?,<qiskit><quantum-state><qiskit-runtime>,2,0,,,"How to use get_statevector in Qiskit SDK 1.0? <p>I am Using Qiskit SDK 1.0. I have a problem with <code>get_statevector</code> in qiskit SDK 1.0 and using <code>BasicSimulator</code>. My code is attached below.</p>
<pre><code>simulator = BasicSimulator()#Aer.get_backend('statevector_simulator')
result = simulator.run(circ).result()#execute(circ,simulator).result()
sv = result.get_statevector(circ)
print(sv)
</code></pre>
",qc,use qiskit sdk p using qiskit sdk problem code qiskit sdk using code basicsimulator code attached pre code simulator basicsimulator result circ execute circ simulator sv circ print sv,"[(0, 0.46088946), (2, 0.070853785), (12, 0.0680075), (14, 0.39476088)]"
37246,,2024-03-14 05:36:59,1,128,"<p>I have a question about how to Add my own Noise like depolarising errors to Quantum gates like <span class=""math-container"">$H$</span> gate, <span class=""math-container"">$R_y$</span> gate and <span class=""math-container"">$R_{zz}$</span> gates in Qiskit SDK 1.0 and count it through <code>qiskit_ibm_runtime</code> and <code>BasicSimulator</code> in Qiskit SDK 1.0</p>
",How to add noise like depolarising errors in Qiskit SDK 1.0?,<qiskit><programming><qiskit-runtime>,1,1,,,"How to add noise like depolarising errors in Qiskit SDK 1.0? <p>I have a question about how to Add my own Noise like depolarising errors to Quantum gates like <span class=""math-container"">$H$</span> gate, <span class=""math-container"">$R_y$</span> gate and <span class=""math-container"">$R_{zz}$</span> gates in Qiskit SDK 1.0 and count it through <code>qiskit_ibm_runtime</code> and <code>BasicSimulator</code> in Qiskit SDK 1.0</p>
",qc,add noise like depolarising errors qiskit sdk p question add noise like depolarising errors quantum gates like span h gate span gate span zz gates qiskit sdk count code code basicsimulator qiskit sdk,"[(3, 0.14099067), (11, 0.030585863), (12, 0.029058378), (14, 0.7945361)]"
37324,,2024-03-18 10:35:07,0,55,"<p>I am trying to find any references to train PQCs to map any probability distribution to a Normal Distribution. Suppose I have MNIST dataset, I want to apply PQC and make the readout distribution to be close to a discrete Normal distribution. Is it possible ?</p>
",Can we train Parametric Quantum Circuits to map any probability distribution to Normal Distribution?,<programming><quantum-algorithms><random-quantum-circuit>,1,0,,,"Can we train Parametric Quantum Circuits to map any probability distribution to Normal Distribution? <p>I am trying to find any references to train PQCs to map any probability distribution to a Normal Distribution. Suppose I have MNIST dataset, I want to apply PQC and make the readout distribution to be close to a discrete Normal distribution. Is it possible ?</p>
",qc,train parametric quantum circuits map probability distribution normal distribution p trying find references train pqcs map probability distribution normal distribution suppose mnist dataset want apply pqc make readout distribution close discrete normal distribution possible,"[(7, 0.040609773), (8, 0.28968853), (11, 0.056713987), (12, 0.029316284), (14, 0.42465252), (15, 0.06067646), (18, 0.094537616)]"
37342,37344.0,2024-03-19 01:31:52,2,550,"<p>Hi Ive been trying to solve a custom PO problem using QAOA and I ran into this particular error. As per my understanding,this is due to the limitation of the simulation hardware. But as per the documentation the new QAOA package does not support to inject a quantum instance (<code>from qiskit_algorithms import  QAOA</code>) but the old implementation did. (<code>from qiskit.algorithms import  QAOA</code>). Given below is my code implementation. Can someone help me fix this issue.</p>
<pre><code>from qiskit_algorithms import  QAOA
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_algorithms.optimizers import COBYLA
from qiskit_aer.primitives import Sampler


qp = from_docplex_mp(mdl)
print(qp.export_as_lp_string())
cobyla = COBYLA()
cobyla.set_options(maxiter=250)
qaoa_mes = QAOA(sampler=Sampler(), optimizer=cobyla, reps=1)
qaoa = MinimumEigenOptimizer(qaoa_mes)
result = qaoa.solve(qp)
</code></pre>
<p>Ive tried getting the backend using</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=&quot;TOKEN&quot;)
backend = service.least_busy(operational=True, simulator=False)
</code></pre>
<p>but there isnt a specific method to provide that to the QAOA.</p>
",TranspilerError: 'Number of qubits (40) in QAOA is greater than maximum (30) in the coupling_map',<qiskit><programming><quantum-algorithms><qaoa><ibm-quantum-devices>,2,0,,,"TranspilerError: 'Number of qubits (40) in QAOA is greater than maximum (30) in the coupling_map' <p>Hi Ive been trying to solve a custom PO problem using QAOA and I ran into this particular error. As per my understanding,this is due to the limitation of the simulation hardware. But as per the documentation the new QAOA package does not support to inject a quantum instance (<code>from qiskit_algorithms import  QAOA</code>) but the old implementation did. (<code>from qiskit.algorithms import  QAOA</code>). Given below is my code implementation. Can someone help me fix this issue.</p>
<pre><code>from qiskit_algorithms import  QAOA
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_algorithms.optimizers import COBYLA
from qiskit_aer.primitives import Sampler


qp = from_docplex_mp(mdl)
print(qp.export_as_lp_string())
cobyla = COBYLA()
cobyla.set_options(maxiter=250)
qaoa_mes = QAOA(sampler=Sampler(), optimizer=cobyla, reps=1)
qaoa = MinimumEigenOptimizer(qaoa_mes)
result = qaoa.solve(qp)
</code></pre>
<p>Ive tried getting the backend using</p>
<pre><code>service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=&quot;TOKEN&quot;)
backend = service.least_busy(operational=True, simulator=False)
</code></pre>
<p>but there isnt a specific method to provide that to the QAOA.</p>
",qc,transpilererror qubits 40 qaoa greater maximum 30 p hi ive trying solve custom po problem using qaoa ran particular error per understanding due limitation simulation hardware per documentation new qaoa package support inject quantum instance code import qaoa old implementation code import qaoa given code implementation someone help fix pre code import qaoa import minimumeigenoptimizer import cobyla import sampler qp mdl print cobyla cobyla qaoa qaoa minimumeigenoptimizer result qp p ive tried getting backend using pre code service qiskitruntimeservice quot quot quot token quot backend p isnt specific method provide,"[(0, 0.56884366), (4, 0.015093379), (5, 0.020853693), (8, 0.14556098), (12, 0.03267824), (14, 0.1475087), (19, 0.06800051)]"
37351,,2024-03-19 09:47:19,2,52,"<p>I am working on a project to find a unitary gate that arrives at a specific density matrix at the end. The circuit construct is shown below:</p>
<pre><code>dev1 = qml.device(&quot;default.mixed&quot;, wires=2)
@qml.qnode(dev1)
def circuit(params_SU):
    qml.QubitDensityMatrix(identity_matrix/2, 0)
    qml.QubitDensityMatrix(rho, 1)
    qml.SpecialUnitary(params_SU, [0, 1])
    return qml.density_matrix([0, 1])
</code></pre>
<p>And the cost function is:</p>
<pre><code>expected_result = rho / 2 + identity_matrix / 4
def cost(params_SU):
    cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result)
    return cost_value
</code></pre>
<p>and</p>
<pre><code>def partial_trace_B(matrix):

    partial_trace_B = np.zeros([2, 2], dtype=complex)

    partial_trace_B[0][0] = matrix[0][0] + matrix[1][1]
    partial_trace_B[0][1] = matrix[0][2] + matrix[1][3]
    partial_trace_B[1][0] = matrix[2][0] + matrix[3][1]
    partial_trace_B[1][1] = matrix[2][2] + matrix[3][3]

    return partial_trace_B
</code></pre>
<p>However, when running the optimisation:</p>
<pre><code>n_steps = 1500
theta = np.random.rand(1, 15, requires_grad=True)
costs_list = []
opt = AdamOptimizer()

for i in range(1, n_steps+1):
    if i%100==0: print(&quot;Running... Current step: &quot;, i)
    theta = opt.step(cost, theta)
    costs_list.append(cost(theta))
</code></pre>
<p>I kept getting this Value Error:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
TypeError: float() argument must be a string or a real number, not 'ArrayBox'

The above exception was the direct cause of the following exception:

ValueError                                Traceback (most recent call last)
Cell In[6], line 8
      6 for i in range(1, n_steps+1):
      7     if i%100==0: print(&quot;Running... Current step: &quot;, i)
----&gt; 8     theta = opt.step(cost, theta)
      9     costs_list.append(cost(theta))

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\optimize\gradient_descent.py:88, in GradientDescentOptimizer.step(self, objective_fn, grad_fn, *args, **kwargs)
     70 def step(self, objective_fn, *args, grad_fn=None, **kwargs):
     71     &quot;&quot;&quot;Update trainable arguments with one step of the optimizer.
     72 
     73     Args:
   (...)
     85         If single arg is provided, list [array] is replaced by array.
     86     &quot;&quot;&quot;
---&gt; 88     g, _ = self.compute_grad(objective_fn, args, kwargs, grad_fn=grad_fn)
     89     new_args = self.apply_grad(g, args)
     91     # unwrap from list if one argument, cleaner return

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\optimize\gradient_descent.py:117, in GradientDescentOptimizer.compute_grad(objective_fn, args, kwargs, grad_fn)
     99 r&quot;&quot;&quot;Compute gradient of the objective function at the given point and return it along with
    100 the objective function forward pass (if available).
    101 
   (...)
    114     will not be evaluted and instead ``None`` will be returned.
    115 &quot;&quot;&quot;
    116 g = get_gradient(objective_fn) if grad_fn is None else grad_fn
--&gt; 117 grad = g(*args, **kwargs)
    118 forward = getattr(g, &quot;forward&quot;, None)
    120 num_trainable_args = sum(getattr(arg, &quot;requires_grad&quot;, False) for arg in args)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_grad.py:118, in grad.__call__(self, *args, **kwargs)
    115     self._forward = self._fun(*args, **kwargs)
    116     return ()
--&gt; 118 grad_value, ans = grad_fn(*args, **kwargs)  # pylint: disable=not-callable
    119 self._forward = ans
    121 return grad_value

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\wrap_util.py:20, in unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f(*args, **kwargs)
     18 else:
     19     x = tuple(args[i] for i in argnum)
---&gt; 20 return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_grad.py:136, in grad._grad_with_forward(fun, x)
    130 @staticmethod
    131 @unary_to_nary
    132 def _grad_with_forward(fun, x):
    133     &quot;&quot;&quot;This function is a replica of ``autograd.grad``, with the only
    134     difference being that it returns both the gradient *and* the forward pass
    135     value.&quot;&quot;&quot;
--&gt; 136     vjp, ans = _make_vjp(fun, x)
    138     if not vspace(ans).size == 1:
    139         raise TypeError(
    140             &quot;Grad only applies to real scalar-output functions. &quot;
    141             &quot;Try jacobian, elementwise_grad or holomorphic_grad.&quot;
    142         )

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\core.py:10, in make_vjp(fun, x)
      8 def make_vjp(fun, x):
      9     start_node = VJPNode.new_root()
---&gt; 10     end_value, end_node =  trace(start_node, fun, x)
     11     if end_node is None:
     12         def vjp(g): return vspace(x).zeros()

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\tracer.py:10, in trace(start_node, fun, x)
      8 with trace_stack.new_trace() as t:
      9     start_box = new_box(x, t, start_node)
---&gt; 10     end_box = fun(start_box)
     11     if isbox(end_box) and end_box._trace == start_box._trace:
     12         return end_box._value, end_box._node

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\wrap_util.py:15, in unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f.&lt;locals&gt;.unary_f(x)
     13 else:
     14     subargs = subvals(args, zip(argnum, x))
---&gt; 15 return fun(*subargs, **kwargs)

Cell In[5], line 4
      3 def cost(params_SU):
----&gt; 4     cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result)
      5     return cost_value

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\qnode.py:1027, in QNode.__call__(self, *args, **kwargs)
   1022         full_transform_program._set_all_argnums(
   1023             self, args, kwargs, argnums
   1024         )  # pylint: disable=protected-access
   1026 # pylint: disable=unexpected-keyword-arg
-&gt; 1027 res = qml.execute(
   1028     (self._tape,),
   1029     device=self.device,
   1030     gradient_fn=self.gradient_fn,
   1031     interface=self.interface,
   1032     transform_program=full_transform_program,
   1033     config=config,
   1034     gradient_kwargs=self.gradient_kwargs,
   1035     override_shots=override_shots,
   1036     **self.execute_kwargs,
   1037 )
   1039 res = res[0]
   1041 # convert result to the interface in case the qfunc has no parameters

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:616, in execute(tapes, device, gradient_fn, interface, transform_program, config, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)
    614 # Exiting early if we do not need to deal with an interface boundary
    615 if no_interface_boundary_required:
--&gt; 616     results = inner_execute(tapes)
    617     return post_processing(results)
    619 _grad_on_execution = False

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:249, in _make_inner_execute.&lt;locals&gt;.inner_execute(tapes, **_)
    247 if numpy_only:
    248     tapes = tuple(qml.transforms.convert_to_numpy_parameters(t) for t in tapes)
--&gt; 249 return cached_device_execution(tapes)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:371, in cache_execute.&lt;locals&gt;.wrapper(tapes, **kwargs)
    366         return (res, []) if return_tuple else res
    368 else:
    369     # execute all unique tapes that do not exist in the cache
    370     # convert to list as new device interface returns a tuple
--&gt; 371     res = list(fn(tuple(execution_tapes.values()), **kwargs))
    373 final_res = []
    375 for i, tape in enumerate(tapes):

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:81, in ContextDecorator.__call__.&lt;locals&gt;.inner(*args, **kwds)
     78 @wraps(func)
     79 def inner(*args, **kwds):
     80     with self._recreate_cm():
---&gt; 81         return func(*args, **kwds)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_qubit_device.py:460, in QubitDevice.batch_execute(self, circuits)
    455 for circuit in circuits:
    456     # we need to reset the device here, else it will
    457     # not start the next computation in the zero state
    458     self.reset()
--&gt; 460     res = self.execute(circuit)
    461     results.append(res)
    463 if self.tracker.active:

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:685, in DefaultMixed.execute(self, circuit, **kwargs)
    683         wires_list.append(m.wires)
    684     self.measured_wires = qml.wires.Wires.all_wires(wires_list)
--&gt; 685 return super().execute(circuit, **kwargs)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_qubit_device.py:279, in QubitDevice.execute(self, circuit, **kwargs)
    276 self.check_validity(circuit.operations, circuit.observables)
    278 # apply all circuit operations
--&gt; 279 self.apply(circuit.operations, rotations=self._get_diagonalizing_gates(circuit), **kwargs)
    281 # generate computational basis samples
    282 if self.shots is not None or circuit.is_sampled:

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:699, in DefaultMixed.apply(self, operations, rotations, **kwargs)
    693         raise DeviceError(
    694             f&quot;Operation {operation.name} cannot be used after other Operations have already been applied &quot;
    695             f&quot;on a {self.short_name} device.&quot;
    696         )
    698 for operation in operations:
--&gt; 699     self._apply_operation(operation)
    701 # store the pre-rotated state
    702 self._pre_rotated_state = self._state

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:617, in DefaultMixed._apply_operation(self, operation)
    614             self._debugger.snapshots[len(self._debugger.snapshots)] = density_matrix
    615     return
--&gt; 617 matrices = self._get_kraus(operation)
    619 if operation in diagonal_in_z_basis:
    620     self._apply_diagonal_unitary(matrices, wires)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:308, in DefaultMixed._get_kraus(self, operation)
    305 if isinstance(operation, Channel):
    306     return operation.kraus_matrices()
--&gt; 308 return [operation.matrix()]

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\operation.py:775, in Operator.matrix(self, wire_order)
    755 def matrix(self, wire_order=None):
    756     r&quot;&quot;&quot;Representation of the operator as a matrix in the computational basis.
    757 
    758     If ``wire_order`` is provided, the numerical representation considers the position of the
   (...)
    773         tensor_like: matrix representation
    774     &quot;&quot;&quot;
--&gt; 775     canonical_matrix = self.compute_matrix(*self.parameters, **self.hyperparameters)
    777     if wire_order is None or self.wires == Wires(wire_order):
    778         return canonical_matrix

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\ops\qubit\special_unitary.py:482, in SpecialUnitary.compute_matrix(theta, num_wires)
    479 if interface == &quot;jax&quot; and qml.math.ndim(theta) &gt; 1:
    480     # jax.numpy.expm does not support broadcasting
    481     return qml.math.stack([qml.math.expm(1j * _A) for _A in A])
--&gt; 482 return qml.math.expm(1j * A)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\math\multi_dispatch.py:151, in multi_dispatch.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
    148 interface = interface or get_interface(*dispatch_args)
    149 kwargs[&quot;like&quot;] = interface
--&gt; 151 return fn(*args, **kwargs)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\math\multi_dispatch.py:837, in expm(tensor, like)
    834     return tf.linalg.expm(tensor)
    835 from scipy.linalg import expm as scipy_expm
--&gt; 837 return scipy_expm(tensor)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\scipy\linalg\_matfuncs.py:299, in expm(A)
    296     return np.exp(a)
    298 if not np.issubdtype(a.dtype, np.inexact):
--&gt; 299     a = a.astype(float)
    300 elif a.dtype == np.float16:
    301     a = a.astype(np.float32)

ValueError: setting an array element with a sequence.
</code></pre>
<p>It would be very kind if someone can provide some resolutions. Thank you so much!!!
I believe the bug is due to the line in the cost function</p>
<pre><code>cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result)
</code></pre>
<p>But it seems completely fine with me, and I do not know how to solve it.</p>
",Value error in variational quantum circuits,<programming><optimization><pennylane>,0,3,,,"Value error in variational quantum circuits <p>I am working on a project to find a unitary gate that arrives at a specific density matrix at the end. The circuit construct is shown below:</p>
<pre><code>dev1 = qml.device(&quot;default.mixed&quot;, wires=2)
@qml.qnode(dev1)
def circuit(params_SU):
    qml.QubitDensityMatrix(identity_matrix/2, 0)
    qml.QubitDensityMatrix(rho, 1)
    qml.SpecialUnitary(params_SU, [0, 1])
    return qml.density_matrix([0, 1])
</code></pre>
<p>And the cost function is:</p>
<pre><code>expected_result = rho / 2 + identity_matrix / 4
def cost(params_SU):
    cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result)
    return cost_value
</code></pre>
<p>and</p>
<pre><code>def partial_trace_B(matrix):

    partial_trace_B = np.zeros([2, 2], dtype=complex)

    partial_trace_B[0][0] = matrix[0][0] + matrix[1][1]
    partial_trace_B[0][1] = matrix[0][2] + matrix[1][3]
    partial_trace_B[1][0] = matrix[2][0] + matrix[3][1]
    partial_trace_B[1][1] = matrix[2][2] + matrix[3][3]

    return partial_trace_B
</code></pre>
<p>However, when running the optimisation:</p>
<pre><code>n_steps = 1500
theta = np.random.rand(1, 15, requires_grad=True)
costs_list = []
opt = AdamOptimizer()

for i in range(1, n_steps+1):
    if i%100==0: print(&quot;Running... Current step: &quot;, i)
    theta = opt.step(cost, theta)
    costs_list.append(cost(theta))
</code></pre>
<p>I kept getting this Value Error:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
TypeError: float() argument must be a string or a real number, not 'ArrayBox'

The above exception was the direct cause of the following exception:

ValueError                                Traceback (most recent call last)
Cell In[6], line 8
      6 for i in range(1, n_steps+1):
      7     if i%100==0: print(&quot;Running... Current step: &quot;, i)
----&gt; 8     theta = opt.step(cost, theta)
      9     costs_list.append(cost(theta))

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\optimize\gradient_descent.py:88, in GradientDescentOptimizer.step(self, objective_fn, grad_fn, *args, **kwargs)
     70 def step(self, objective_fn, *args, grad_fn=None, **kwargs):
     71     &quot;&quot;&quot;Update trainable arguments with one step of the optimizer.
     72 
     73     Args:
   (...)
     85         If single arg is provided, list [array] is replaced by array.
     86     &quot;&quot;&quot;
---&gt; 88     g, _ = self.compute_grad(objective_fn, args, kwargs, grad_fn=grad_fn)
     89     new_args = self.apply_grad(g, args)
     91     # unwrap from list if one argument, cleaner return

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\optimize\gradient_descent.py:117, in GradientDescentOptimizer.compute_grad(objective_fn, args, kwargs, grad_fn)
     99 r&quot;&quot;&quot;Compute gradient of the objective function at the given point and return it along with
    100 the objective function forward pass (if available).
    101 
   (...)
    114     will not be evaluted and instead ``None`` will be returned.
    115 &quot;&quot;&quot;
    116 g = get_gradient(objective_fn) if grad_fn is None else grad_fn
--&gt; 117 grad = g(*args, **kwargs)
    118 forward = getattr(g, &quot;forward&quot;, None)
    120 num_trainable_args = sum(getattr(arg, &quot;requires_grad&quot;, False) for arg in args)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_grad.py:118, in grad.__call__(self, *args, **kwargs)
    115     self._forward = self._fun(*args, **kwargs)
    116     return ()
--&gt; 118 grad_value, ans = grad_fn(*args, **kwargs)  # pylint: disable=not-callable
    119 self._forward = ans
    121 return grad_value

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\wrap_util.py:20, in unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f(*args, **kwargs)
     18 else:
     19     x = tuple(args[i] for i in argnum)
---&gt; 20 return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_grad.py:136, in grad._grad_with_forward(fun, x)
    130 @staticmethod
    131 @unary_to_nary
    132 def _grad_with_forward(fun, x):
    133     &quot;&quot;&quot;This function is a replica of ``autograd.grad``, with the only
    134     difference being that it returns both the gradient *and* the forward pass
    135     value.&quot;&quot;&quot;
--&gt; 136     vjp, ans = _make_vjp(fun, x)
    138     if not vspace(ans).size == 1:
    139         raise TypeError(
    140             &quot;Grad only applies to real scalar-output functions. &quot;
    141             &quot;Try jacobian, elementwise_grad or holomorphic_grad.&quot;
    142         )

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\core.py:10, in make_vjp(fun, x)
      8 def make_vjp(fun, x):
      9     start_node = VJPNode.new_root()
---&gt; 10     end_value, end_node =  trace(start_node, fun, x)
     11     if end_node is None:
     12         def vjp(g): return vspace(x).zeros()

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\tracer.py:10, in trace(start_node, fun, x)
      8 with trace_stack.new_trace() as t:
      9     start_box = new_box(x, t, start_node)
---&gt; 10     end_box = fun(start_box)
     11     if isbox(end_box) and end_box._trace == start_box._trace:
     12         return end_box._value, end_box._node

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\autograd\wrap_util.py:15, in unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f.&lt;locals&gt;.unary_f(x)
     13 else:
     14     subargs = subvals(args, zip(argnum, x))
---&gt; 15 return fun(*subargs, **kwargs)

Cell In[5], line 4
      3 def cost(params_SU):
----&gt; 4     cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result)
      5     return cost_value

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\qnode.py:1027, in QNode.__call__(self, *args, **kwargs)
   1022         full_transform_program._set_all_argnums(
   1023             self, args, kwargs, argnums
   1024         )  # pylint: disable=protected-access
   1026 # pylint: disable=unexpected-keyword-arg
-&gt; 1027 res = qml.execute(
   1028     (self._tape,),
   1029     device=self.device,
   1030     gradient_fn=self.gradient_fn,
   1031     interface=self.interface,
   1032     transform_program=full_transform_program,
   1033     config=config,
   1034     gradient_kwargs=self.gradient_kwargs,
   1035     override_shots=override_shots,
   1036     **self.execute_kwargs,
   1037 )
   1039 res = res[0]
   1041 # convert result to the interface in case the qfunc has no parameters

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:616, in execute(tapes, device, gradient_fn, interface, transform_program, config, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)
    614 # Exiting early if we do not need to deal with an interface boundary
    615 if no_interface_boundary_required:
--&gt; 616     results = inner_execute(tapes)
    617     return post_processing(results)
    619 _grad_on_execution = False

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:249, in _make_inner_execute.&lt;locals&gt;.inner_execute(tapes, **_)
    247 if numpy_only:
    248     tapes = tuple(qml.transforms.convert_to_numpy_parameters(t) for t in tapes)
--&gt; 249 return cached_device_execution(tapes)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\interfaces\execution.py:371, in cache_execute.&lt;locals&gt;.wrapper(tapes, **kwargs)
    366         return (res, []) if return_tuple else res
    368 else:
    369     # execute all unique tapes that do not exist in the cache
    370     # convert to list as new device interface returns a tuple
--&gt; 371     res = list(fn(tuple(execution_tapes.values()), **kwargs))
    373 final_res = []
    375 for i, tape in enumerate(tapes):

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:81, in ContextDecorator.__call__.&lt;locals&gt;.inner(*args, **kwds)
     78 @wraps(func)
     79 def inner(*args, **kwds):
     80     with self._recreate_cm():
---&gt; 81         return func(*args, **kwds)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_qubit_device.py:460, in QubitDevice.batch_execute(self, circuits)
    455 for circuit in circuits:
    456     # we need to reset the device here, else it will
    457     # not start the next computation in the zero state
    458     self.reset()
--&gt; 460     res = self.execute(circuit)
    461     results.append(res)
    463 if self.tracker.active:

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:685, in DefaultMixed.execute(self, circuit, **kwargs)
    683         wires_list.append(m.wires)
    684     self.measured_wires = qml.wires.Wires.all_wires(wires_list)
--&gt; 685 return super().execute(circuit, **kwargs)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\_qubit_device.py:279, in QubitDevice.execute(self, circuit, **kwargs)
    276 self.check_validity(circuit.operations, circuit.observables)
    278 # apply all circuit operations
--&gt; 279 self.apply(circuit.operations, rotations=self._get_diagonalizing_gates(circuit), **kwargs)
    281 # generate computational basis samples
    282 if self.shots is not None or circuit.is_sampled:

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:699, in DefaultMixed.apply(self, operations, rotations, **kwargs)
    693         raise DeviceError(
    694             f&quot;Operation {operation.name} cannot be used after other Operations have already been applied &quot;
    695             f&quot;on a {self.short_name} device.&quot;
    696         )
    698 for operation in operations:
--&gt; 699     self._apply_operation(operation)
    701 # store the pre-rotated state
    702 self._pre_rotated_state = self._state

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:617, in DefaultMixed._apply_operation(self, operation)
    614             self._debugger.snapshots[len(self._debugger.snapshots)] = density_matrix
    615     return
--&gt; 617 matrices = self._get_kraus(operation)
    619 if operation in diagonal_in_z_basis:
    620     self._apply_diagonal_unitary(matrices, wires)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\devices\default_mixed.py:308, in DefaultMixed._get_kraus(self, operation)
    305 if isinstance(operation, Channel):
    306     return operation.kraus_matrices()
--&gt; 308 return [operation.matrix()]

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\operation.py:775, in Operator.matrix(self, wire_order)
    755 def matrix(self, wire_order=None):
    756     r&quot;&quot;&quot;Representation of the operator as a matrix in the computational basis.
    757 
    758     If ``wire_order`` is provided, the numerical representation considers the position of the
   (...)
    773         tensor_like: matrix representation
    774     &quot;&quot;&quot;
--&gt; 775     canonical_matrix = self.compute_matrix(*self.parameters, **self.hyperparameters)
    777     if wire_order is None or self.wires == Wires(wire_order):
    778         return canonical_matrix

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\ops\qubit\special_unitary.py:482, in SpecialUnitary.compute_matrix(theta, num_wires)
    479 if interface == &quot;jax&quot; and qml.math.ndim(theta) &gt; 1:
    480     # jax.numpy.expm does not support broadcasting
    481     return qml.math.stack([qml.math.expm(1j * _A) for _A in A])
--&gt; 482 return qml.math.expm(1j * A)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\math\multi_dispatch.py:151, in multi_dispatch.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
    148 interface = interface or get_interface(*dispatch_args)
    149 kwargs[&quot;like&quot;] = interface
--&gt; 151 return fn(*args, **kwargs)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\pennylane\math\multi_dispatch.py:837, in expm(tensor, like)
    834     return tf.linalg.expm(tensor)
    835 from scipy.linalg import expm as scipy_expm
--&gt; 837 return scipy_expm(tensor)

File c:\Users\86986\AppData\Local\Programs\Python\Python311\Lib\site-packages\scipy\linalg\_matfuncs.py:299, in expm(A)
    296     return np.exp(a)
    298 if not np.issubdtype(a.dtype, np.inexact):
--&gt; 299     a = a.astype(float)
    300 elif a.dtype == np.float16:
    301     a = a.astype(np.float32)

ValueError: setting an array element with a sequence.
</code></pre>
<p>It would be very kind if someone can provide some resolutions. Thank you so much!!!
I believe the bug is due to the line in the cost function</p>
<pre><code>cost_value = np.linalg.norm(partial_trace_B(circuit(params_SU)) - expected_result)
</code></pre>
<p>But it seems completely fine with me, and I do not know how to solve it.</p>
",qc,value error variational quantum circuits p working project find unitary gate arrives specific density matrix end circuit construct shown pre code dev1 quot quot dev1 def circuit 0 rho 1 0 1 return 0 1 p cost function pre code rho 2 4 def cost circuit return p pre code def matrix 2 2 0 0 matrix 0 0 matrix 1 1 0 1 matrix 0 2 matrix 1 3 1 0 matrix 2 0 matrix 3 1 1 1 matrix 2 2 matrix 3 3 return p however running optimisation pre code 1500 theta 1 15 opt adamoptimizer range 1 print quot running current step quot theta cost theta cost theta p kept getting value error pre code typeerror traceback recent call last typeerror float argument must string real number exception direct cause following exception valueerror traceback recent call last cell 6 line 8 6 range 1 7 print quot running current step quot gt 8 theta cost theta 9 cost theta file c self args kwargs 70 def step self args kwargs 71 quot quot quot update trainable arguments one step optimizer 72 73 args 85 single arg provided list array replaced array 86 quot quot quot gt 88 g args kwargs 89 g args 91 unwrap list one argument cleaner return file c args kwargs 99 r quot quot quot compute gradient objective function given point return along 100 objective function forward pass available 101 114 evaluted instead none returned 115 quot quot quot 116 g none else gt 117 grad g args kwargs 118 forward getattr g quot forward quot none 120 sum getattr arg quot quot false arg args file c self args kwargs 115 args kwargs 116 return gt 118 ans args kwargs pylint 119 ans 121 return file c lt locals gt lt locals gt args kwargs 18 else 19 x tuple args argnum gt 20 return x file c fun x 130 staticmethod 131 132 def fun x 133 quot quot quot function replica 134 difference returns gradient forward pass 135 quot quot quot gt 136 vjp ans fun x 138 vspace ans 1 139 raise typeerror 140 quot grad applies real functions quot 141 quot try jacobian quot 142 file c fun x 8 def fun x 9 gt 10 trace fun x 11 none 12 def vjp g return vspace x file c trace fun x 8 9 x gt 10 fun 11 isbox 12 return file c lt locals gt lt locals gt lt locals gt x 13 else 14 subargs subvals args zip argnum x gt 15 return fun subargs kwargs cell 5 line 4 3 def cost gt 4 circuit 5 return file c self args kwargs 1022 1023 self args kwargs argnums 1024 pylint 1026 pylint gt 1027 res 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1039 res res 0 1041 convert result interface case qfunc parameters file c execute tapes device interface config cache cachesize 614 exiting early need deal interface boundary 615 gt 616 results tapes 617 return results 619 false file c lt locals gt tapes 247 248 tapes tuple tapes gt 249 return tapes file c lt locals gt tapes kwargs 366 return res else res 368 else 369 execute unique tapes exist cache 370 convert list new device interface returns tuple gt 371 res list fn tuple kwargs 373 375 tape enumerate tapes file c lt locals gt args kwds 78 wraps func 79 def inner args kwds 80 gt 81 return func args kwds file c self circuits 455 circuit circuits 456 need reset device else 457 start next computation zero state 458 gt 460 res circuit 461 res 463 file c self circuit kwargs 683 684 gt 685 return super circuit kwargs file c self circuit kwargs 276 278 apply circuit operations gt 279 circuit kwargs 281 generate computational basis samples 282 none file c self operations rotations kwargs 693 raise deviceerror 694 f quot operation used operations already applied quot 695 f quot quot 696 698 operation operations gt 699 operation 701 store state 702 file c self operation 614 len 615 return gt 617 matrices operation 619 operation 620 matrices wires file c self operation 305 isinstance operation channel 306 return gt 308 return file c self 755 def matrix self 756 r quot quot quot representation operator matrix computational basis 757 758 provided numerical representation considers position 773 matrix representation 774 quot quot quot gt 775 777 none wires 778 return file c theta 479 interface quot jax quot theta gt 1 480 support broadcasting 481 return 1j gt 482 return 1j file c lt locals gt lt locals gt args kwargs 148 interface interface 149 kwargs quot like quot interface gt 151 return fn args kwargs file c expm tensor like 834 return tensor 835 import expm gt 837 return tensor file c expm 296 return 298 gt 299 float 300 elif 301 valueerror setting array element sequence p would kind someone provide resolutions thank much believe bug due line cost function pre code circuit p seems completely fine know solve,"[(0, 0.48331437), (2, 0.029030018), (6, 0.10982476), (8, 0.018097939), (10, 0.018203728), (11, 0.035956748), (12, 0.011655142), (13, 0.015636552), (14, 0.018555177), (19, 0.24713777)]"
37357,,2024-03-19 16:06:10,1,64,"<p>I am just trying to calculate the highest fidelity of preparing GHZ states on IBM quantum computers and I run my circuit on qubits with the lowest readout error. However, I just obtain fidelity of the state about 0.5 to 0.6. like the following:</p>
<p>state Fidelity = 0.5924363421816463</p>
<p>is it OK? or I am doing something wrong. Because I suppose it must be higher than this.</p>
<p>Here is my code:</p>
<pre><code>q1 = QuantumRegister(1)
q2 = QuantumRegister(1)
q3 = QuantumRegister(1)
c = ClassicalRegister(3)
qc = QuantumCircuit(q1, q2, q3, c)
qc.h(q1)
qc.cx(q1, q2)
qc.ccx(q1, q2, q3)
st = StateTomography(qc, physical_qubits=[85, 84, 83])
stdata = st.run(backend).block_for_results()
state_result = stdata.analysis_results(&quot;state&quot;)
array_to_latex(state_result.value)
fid_result = stdata.analysis_results(&quot;state_fidelity&quot;)
print(f&quot;state Fidelity = {fid_result.value}&quot;)
</code></pre>
",Low Fidelity In IBM Quantum Computers,<qiskit><ibm-q-experience><ibm-quantum-devices><qiskit-runtime>,0,3,,,"Low Fidelity In IBM Quantum Computers <p>I am just trying to calculate the highest fidelity of preparing GHZ states on IBM quantum computers and I run my circuit on qubits with the lowest readout error. However, I just obtain fidelity of the state about 0.5 to 0.6. like the following:</p>
<p>state Fidelity = 0.5924363421816463</p>
<p>is it OK? or I am doing something wrong. Because I suppose it must be higher than this.</p>
<p>Here is my code:</p>
<pre><code>q1 = QuantumRegister(1)
q2 = QuantumRegister(1)
q3 = QuantumRegister(1)
c = ClassicalRegister(3)
qc = QuantumCircuit(q1, q2, q3, c)
qc.h(q1)
qc.cx(q1, q2)
qc.ccx(q1, q2, q3)
st = StateTomography(qc, physical_qubits=[85, 84, 83])
stdata = st.run(backend).block_for_results()
state_result = stdata.analysis_results(&quot;state&quot;)
array_to_latex(state_result.value)
fid_result = stdata.analysis_results(&quot;state_fidelity&quot;)
print(f&quot;state Fidelity = {fid_result.value}&quot;)
</code></pre>
",qc,low fidelity ibm quantum computers p trying calculate highest fidelity preparing ghz states ibm quantum computers run circuit qubits lowest readout error however obtain fidelity state like following p state fidelity p ok something wrong suppose must higher p code pre code q1 quantumregister 1 q2 quantumregister 1 q3 quantumregister 1 c classicalregister 3 qc quantumcircuit q1 q2 q3 c q1 q1 q2 q1 q2 q3 st statetomography qc 85 84 83 stdata backend quot state quot quot quot print f quot state fidelity quot,"[(0, 0.17848317), (1, 0.029135553), (2, 0.03880416), (8, 0.0341112), (12, 0.011887171), (14, 0.4605806), (16, 0.06503208), (18, 0.08059653), (19, 0.100076094)]"
37365,37392.0,2024-03-19 23:14:39,4,93,"<p>Asking this question to an AI, I got the result that the relation between concurrence and purity of a single qubit in a mixed bipartite state, as follows:</p>
<p><span class=""math-container"">$$C^2 \le  4p(1-p)\,, $$</span></p>
<p>Where <span class=""math-container"">$C$</span> is concurrence, and <span class=""math-container"">$p$</span> is the purity of a single qubit.</p>
<p>Unfortunately, AI didn't give any resources. I want resources that refer to this inequality.</p>
",Are concurrence $C$ and purity of reduced state $p$ related by $C^2\le 4p(1-p)$?,<resource-request><concurrence>,1,2,,,"Are concurrence $C$ and purity of reduced state $p$ related by $C^2\le 4p(1-p)$? <p>Asking this question to an AI, I got the result that the relation between concurrence and purity of a single qubit in a mixed bipartite state, as follows:</p>
<p><span class=""math-container"">$$C^2 \le  4p(1-p)\,, $$</span></p>
<p>Where <span class=""math-container"">$C$</span> is concurrence, and <span class=""math-container"">$p$</span> is the purity of a single qubit.</p>
<p>Unfortunately, AI didn't give any resources. I want resources that refer to this inequality.</p>
",qc,concurrence c purity reduced state p related 4p p asking question ai got result relation concurrence purity single qubit mixed bipartite state follows p span 4p p span c concurrence span p purity single p unfortunately ai give resources want resources refer,"[(3, 0.74611133), (8, 0.07651136), (12, 0.048512693), (15, 0.05875176), (18, 0.06654129)]"
37433,,2024-03-24 06:54:46,1,99,"<p>As suggested in <a href=""https://quantumcomputing.stackexchange.com/questions/37342/transpilererror-number-of-qubits-40-in-qaoa-is-greater-than-maximum-30-in/37366#37366"">TranspilerError: 'Number of qubits (40) in QAOA is greater than maximum (30) in the coupling_map'</a> issue. I managed to submit the job to IBM quantum and the circuit runs successfully.</p>
<p>The code is as follows.</p>
<pre><code>import numpy as np
from docplex.mp.advmodel import AdvModel
from qiskit_optimization.translators import from_docplex_mp

mdl = AdvModel(name=&quot;Portfolio optimization&quot;)
</code></pre>
<pre><code>N = 10   # Number of assets
M = 4   # Number of levels

lambda_risk = 5
lambda_linking = 10
lambda_budget = 20
lambda_diversification = 15
lambda_cardinality = 10

R = 100   # Risk tolerance parameter
B = 50    # Total budget
D = 16    # Diversification requirement
K = 6     # Cardinality constraint


# Vector of mu_i values, expected returns for each asset 
mu = np.random.uniform(low=0.1, high=1.0, size=N)

# sigma_ij values, representing the covariance between assets i and j
sigma = np.random.uniform(low=0.01, high=0.1, size=(N, N))
# c_i values, representing the cost of each asset
c = np.random.uniform(low=1, high=10, size=N)
line_seperator = &quot;----------------------------------------&quot;
print(line_seperator)
print(&quot;N(Number of assets): &quot;, N)
print(&quot;M(Number of levels): &quot;, M)
print(line_seperator)
print(&quot;lambda_risk(Risk penalty coefficient): &quot;, lambda_risk)
print(&quot;lambda_linking(Linking penalty coefficient): &quot;, lambda_linking)
print(&quot;lambda_budget(Budget penalty coefficient): &quot;, lambda_budget)
print(&quot;lambda_diversification(Diversification penalty coefficient): &quot;, lambda_diversification)
print(&quot;lambda_cardinality(Cardinality penalty coefficient): &quot;, lambda_cardinality)
print(line_seperator)
print(&quot;R(Risk tolerance parameter): &quot;, R)
print(&quot;B(Total budget): &quot;, B)
print(&quot;D(Diversification requirement): &quot;, D)
print(&quot;K(Cardinality constraint): &quot;, K)
print(line_seperator)
print(&quot;mu(Expected returns for each asset): &quot;, mu)
print(&quot;sigma(Covariance between assets): &quot;, sigma)
print(&quot;c(Cost of each asset): &quot;, c)

</code></pre>
<pre><code>z = {(i, l): mdl.binary_var(name=f&quot;z_{i}_{l}&quot;) for i in range(N) for l in range(M)}
y = [mdl.binary_var(name=f&quot;y_{i}&quot;) for i in range(N)]

#objective function
obj = mdl.sum(mu[i] * mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N))

penalty_risk = mdl.sum(mdl.sum(2**l * z[i, l] for l in range(M)) * sigma[i][j] * mdl.sum(2**l * z[j, l] for l in range(M)) for i in range(N) for j in range(N)) - R
# risk_term = lambda_risk * penalty_risk ** 2
risk_term = lambda_risk * penalty_risk

penalty_budget = mdl.sum(c[i] * mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N)) - B
# budget_term = lambda_budget * penalty_budget ** 2
budget_term = lambda_budget * penalty_budget

penalty_diversification = mdl.sum(mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N)) - D
# diversification_term = lambda_diversification * penalty_diversification ** 2
diversification_term = lambda_diversification * penalty_diversification

penalty_cardinality = mdl.sum(y[i] for i in range(N)) - K
# cardinality_term = lambda_cardinality * penalty_cardinality ** 2
cardinality_term = lambda_cardinality * penalty_cardinality

penalty_linking = mdl.sum(mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N)) - D * mdl.sum(y[i] for i in range(N))
# linking_term = lambda_linking * penalty_linking ** 2
linking_term = lambda_linking * penalty_linking

mdl.minimize(risk_term + budget_term+ diversification_term + cardinality_term + linking_term - obj)
qp = from_docplex_mp(mdl)
print(qp.export_as_lp_string())
</code></pre>
<pre><code># General imports
import numpy as np
import warnings

warnings.filterwarnings(&quot;ignore&quot;)

# Pre-defined ansatz circuit, operator class and visualization tools
from qiskit.quantum_info import SparsePauliOp
from qiskit.visualization import plot_distribution

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, Session
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from qiskit_ibm_runtime import SamplerV2 as Sampler

# SciPy minimizer routine
from scipy.optimize import minimize

# rustworkx graph library
import rustworkx as rx
from rustworkx.visualization import mpl_draw


# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=&quot;Token&quot;)
backend = service.least_busy(min_num_qubits=40,operational=True, simulator=False)
backend.name
</code></pre>
<pre><code>op,offset = qp.to_ising()
print(&quot;offset: {}&quot;.format(offset))
print(&quot;operator:&quot;)
print(op)

from qiskit.circuit.library import QAOAAnsatz
ansatz = QAOAAnsatz(op, reps=2)

ansatz.decompose(reps=3).draw(output=&quot;mpl&quot;, style=&quot;iqp&quot;)

</code></pre>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

ansatz_isa = pm.run(ansatz)

hamiltonian_isa = op.apply_layout(ansatz_isa.layout)
hamiltonian_isa
</code></pre>
<pre><code>def cost_func(params, ansatz, hamiltonian, estimator):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters
        ansatz (QuantumCircuit): Parameterized ansatz circuit
        hamiltonian (SparsePauliOp): Operator representation of Hamiltonian
        estimator (EstimatorV2): Estimator primitive instance

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    pub = (ansatz, [hamiltonian], [params])
    result = estimator.run(pubs=[pub]).result()
    cost = result[0].data.evs[0]

    return cost
</code></pre>
<pre><code>session = Session(backend=backend)

# Configure estimator
estimator = Estimator(session=session)
estimator.options.default_shots = 10_000
estimator.options.dynamical_decoupling.enable = True

# Configure sampler
sampler = Sampler(session=session)
sampler.options.default_shots = 10_000
sampler.options.dynamical_decoupling.enable = True

x0 = 2 * np.pi * np.random.rand(ansatz_isa.num_parameters)
</code></pre>
<pre><code>res = minimize(cost_func, x0, args=(ansatz_isa, hamiltonian_isa, estimator), method=&quot;COBYLA&quot;)
</code></pre>
<p>But the Python interpreter runs into an error due to the long time it takes to solve this. But when I go to IBM Quantum platform the job has finished.<a href=""https://i.sstatic.net/IMjAu.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IMjAu.jpg"" alt=""enter image description here"" /></a></p>
<p>The suggested way to move forward acoording to <a href=""https://res%20=%20minimize(cost_func,%20x0,%20args=(ansatz_isa,%20hamiltonian_isa,%20estimator),%20method=%22COBYLA%22)"" rel=""nofollow noreferrer"">IBM QAOA</a> is in the link as follows.</p>
<pre><code># Assign solution parameters to ansatz
qc = ansatz.assign_parameters(res.x)
# Add measurements to our circuit
qc.measure_all()
qc_isa = pm.run(qc)
qc_isa.draw(output=&quot;mpl&quot;, idle_wires=False, style=&quot;iqp&quot;)

result = sampler.run([qc_isa]).result()
samp_dist = result[0].data.meas.get_counts()
# Close the session since we are now done with it
session.close()
</code></pre>
<p>But since my interpretter times out I don't get to use the <code>res.x</code> parameters.</p>
<p>But the IBM platforms provides a way to use the results of the job as follows.</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService(
    channel='ibm_quantum',
    instance='ibm-q/open/main',
    token=''
)
job = service.job('cqzvw6gktf3g00884pz0')
job_result = job.result()

for idx, pub_result in enumerate(job_result):
    print(f&quot;Expectation values for pub {idx}: {pub_result.data.evs}&quot;)
</code></pre>
<p>I want to know how I can use this results to carry forward with the calculation. I am new to QAOA so this might be straight forward. Any help is valued.</p>
",How to run the post processing and return results in QAOA?,<qiskit><programming><optimization><ibm-quantum-devices><qaoa>,0,0,,,"How to run the post processing and return results in QAOA? <p>As suggested in <a href=""https://quantumcomputing.stackexchange.com/questions/37342/transpilererror-number-of-qubits-40-in-qaoa-is-greater-than-maximum-30-in/37366#37366"">TranspilerError: 'Number of qubits (40) in QAOA is greater than maximum (30) in the coupling_map'</a> issue. I managed to submit the job to IBM quantum and the circuit runs successfully.</p>
<p>The code is as follows.</p>
<pre><code>import numpy as np
from docplex.mp.advmodel import AdvModel
from qiskit_optimization.translators import from_docplex_mp

mdl = AdvModel(name=&quot;Portfolio optimization&quot;)
</code></pre>
<pre><code>N = 10   # Number of assets
M = 4   # Number of levels

lambda_risk = 5
lambda_linking = 10
lambda_budget = 20
lambda_diversification = 15
lambda_cardinality = 10

R = 100   # Risk tolerance parameter
B = 50    # Total budget
D = 16    # Diversification requirement
K = 6     # Cardinality constraint


# Vector of mu_i values, expected returns for each asset 
mu = np.random.uniform(low=0.1, high=1.0, size=N)

# sigma_ij values, representing the covariance between assets i and j
sigma = np.random.uniform(low=0.01, high=0.1, size=(N, N))
# c_i values, representing the cost of each asset
c = np.random.uniform(low=1, high=10, size=N)
line_seperator = &quot;----------------------------------------&quot;
print(line_seperator)
print(&quot;N(Number of assets): &quot;, N)
print(&quot;M(Number of levels): &quot;, M)
print(line_seperator)
print(&quot;lambda_risk(Risk penalty coefficient): &quot;, lambda_risk)
print(&quot;lambda_linking(Linking penalty coefficient): &quot;, lambda_linking)
print(&quot;lambda_budget(Budget penalty coefficient): &quot;, lambda_budget)
print(&quot;lambda_diversification(Diversification penalty coefficient): &quot;, lambda_diversification)
print(&quot;lambda_cardinality(Cardinality penalty coefficient): &quot;, lambda_cardinality)
print(line_seperator)
print(&quot;R(Risk tolerance parameter): &quot;, R)
print(&quot;B(Total budget): &quot;, B)
print(&quot;D(Diversification requirement): &quot;, D)
print(&quot;K(Cardinality constraint): &quot;, K)
print(line_seperator)
print(&quot;mu(Expected returns for each asset): &quot;, mu)
print(&quot;sigma(Covariance between assets): &quot;, sigma)
print(&quot;c(Cost of each asset): &quot;, c)

</code></pre>
<pre><code>z = {(i, l): mdl.binary_var(name=f&quot;z_{i}_{l}&quot;) for i in range(N) for l in range(M)}
y = [mdl.binary_var(name=f&quot;y_{i}&quot;) for i in range(N)]

#objective function
obj = mdl.sum(mu[i] * mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N))

penalty_risk = mdl.sum(mdl.sum(2**l * z[i, l] for l in range(M)) * sigma[i][j] * mdl.sum(2**l * z[j, l] for l in range(M)) for i in range(N) for j in range(N)) - R
# risk_term = lambda_risk * penalty_risk ** 2
risk_term = lambda_risk * penalty_risk

penalty_budget = mdl.sum(c[i] * mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N)) - B
# budget_term = lambda_budget * penalty_budget ** 2
budget_term = lambda_budget * penalty_budget

penalty_diversification = mdl.sum(mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N)) - D
# diversification_term = lambda_diversification * penalty_diversification ** 2
diversification_term = lambda_diversification * penalty_diversification

penalty_cardinality = mdl.sum(y[i] for i in range(N)) - K
# cardinality_term = lambda_cardinality * penalty_cardinality ** 2
cardinality_term = lambda_cardinality * penalty_cardinality

penalty_linking = mdl.sum(mdl.sum(2**l * z[i, l] for l in range(M)) for i in range(N)) - D * mdl.sum(y[i] for i in range(N))
# linking_term = lambda_linking * penalty_linking ** 2
linking_term = lambda_linking * penalty_linking

mdl.minimize(risk_term + budget_term+ diversification_term + cardinality_term + linking_term - obj)
qp = from_docplex_mp(mdl)
print(qp.export_as_lp_string())
</code></pre>
<pre><code># General imports
import numpy as np
import warnings

warnings.filterwarnings(&quot;ignore&quot;)

# Pre-defined ansatz circuit, operator class and visualization tools
from qiskit.quantum_info import SparsePauliOp
from qiskit.visualization import plot_distribution

# Qiskit Runtime
from qiskit_ibm_runtime import QiskitRuntimeService, Session
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from qiskit_ibm_runtime import SamplerV2 as Sampler

# SciPy minimizer routine
from scipy.optimize import minimize

# rustworkx graph library
import rustworkx as rx
from rustworkx.visualization import mpl_draw


# To run on hardware, select the backend with the fewest number of jobs in the queue
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token=&quot;Token&quot;)
backend = service.least_busy(min_num_qubits=40,operational=True, simulator=False)
backend.name
</code></pre>
<pre><code>op,offset = qp.to_ising()
print(&quot;offset: {}&quot;.format(offset))
print(&quot;operator:&quot;)
print(op)

from qiskit.circuit.library import QAOAAnsatz
ansatz = QAOAAnsatz(op, reps=2)

ansatz.decompose(reps=3).draw(output=&quot;mpl&quot;, style=&quot;iqp&quot;)

</code></pre>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)

ansatz_isa = pm.run(ansatz)

hamiltonian_isa = op.apply_layout(ansatz_isa.layout)
hamiltonian_isa
</code></pre>
<pre><code>def cost_func(params, ansatz, hamiltonian, estimator):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters
        ansatz (QuantumCircuit): Parameterized ansatz circuit
        hamiltonian (SparsePauliOp): Operator representation of Hamiltonian
        estimator (EstimatorV2): Estimator primitive instance

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    pub = (ansatz, [hamiltonian], [params])
    result = estimator.run(pubs=[pub]).result()
    cost = result[0].data.evs[0]

    return cost
</code></pre>
<pre><code>session = Session(backend=backend)

# Configure estimator
estimator = Estimator(session=session)
estimator.options.default_shots = 10_000
estimator.options.dynamical_decoupling.enable = True

# Configure sampler
sampler = Sampler(session=session)
sampler.options.default_shots = 10_000
sampler.options.dynamical_decoupling.enable = True

x0 = 2 * np.pi * np.random.rand(ansatz_isa.num_parameters)
</code></pre>
<pre><code>res = minimize(cost_func, x0, args=(ansatz_isa, hamiltonian_isa, estimator), method=&quot;COBYLA&quot;)
</code></pre>
<p>But the Python interpreter runs into an error due to the long time it takes to solve this. But when I go to IBM Quantum platform the job has finished.<a href=""https://i.sstatic.net/IMjAu.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IMjAu.jpg"" alt=""enter image description here"" /></a></p>
<p>The suggested way to move forward acoording to <a href=""https://res%20=%20minimize(cost_func,%20x0,%20args=(ansatz_isa,%20hamiltonian_isa,%20estimator),%20method=%22COBYLA%22)"" rel=""nofollow noreferrer"">IBM QAOA</a> is in the link as follows.</p>
<pre><code># Assign solution parameters to ansatz
qc = ansatz.assign_parameters(res.x)
# Add measurements to our circuit
qc.measure_all()
qc_isa = pm.run(qc)
qc_isa.draw(output=&quot;mpl&quot;, idle_wires=False, style=&quot;iqp&quot;)

result = sampler.run([qc_isa]).result()
samp_dist = result[0].data.meas.get_counts()
# Close the session since we are now done with it
session.close()
</code></pre>
<p>But since my interpretter times out I don't get to use the <code>res.x</code> parameters.</p>
<p>But the IBM platforms provides a way to use the results of the job as follows.</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService(
    channel='ibm_quantum',
    instance='ibm-q/open/main',
    token=''
)
job = service.job('cqzvw6gktf3g00884pz0')
job_result = job.result()

for idx, pub_result in enumerate(job_result):
    print(f&quot;Expectation values for pub {idx}: {pub_result.data.evs}&quot;)
</code></pre>
<p>I want to know how I can use this results to carry forward with the calculation. I am new to QAOA so this might be straight forward. Any help is valued.</p>
",qc,run post processing return results qaoa p suggested https 37366 transpilererror qubits 40 qaoa greater maximum 30 issue managed submit job ibm quantum circuit runs p code pre code import numpy np import advmodel import mdl advmodel quot portfolio optimization quot pre code n 10 number assets 4 number levels 5 10 20 15 10 r 100 risk tolerance parameter b 50 total budget 16 diversification requirement k 6 cardinality constraint vector values expected returns asset mu values representing covariance assets j sigma n n values representing cost asset c quot quot print print quot n number assets quot n print quot number levels quot print print quot risk penalty coefficient quot print quot linking penalty coefficient quot print quot budget penalty coefficient quot print quot diversification penalty coefficient quot print quot cardinality penalty coefficient quot print print quot r risk tolerance parameter quot r print quot b total budget quot b print quot diversification requirement quot print quot k cardinality constraint quot k print print quot mu expected returns asset quot mu print quot sigma covariance assets quot sigma print quot c cost asset quot c pre code z l quot l quot range n l range quot quot range n objective function obj mu 2 l z l l range range n 2 l z l l range sigma j 2 l z j l l range range n j range n r 2 c 2 l z l l range range n b 2 2 l z l l range range n 2 range n k 2 2 l z l l range range n range n 2 obj qp mdl print pre code general imports import numpy np import warnings quot ignore quot ansatz circuit operator class visualization tools import sparsepauliop import qiskit runtime import qiskitruntimeservice session import estimatorv2 estimator import samplerv2 sampler scipy minimizer routine import minimize rustworkx graph library import rustworkx rx import run hardware select backend fewest number jobs queue service qiskitruntimeservice quot quot quot token quot backend pre code op offset print quot offset quot offset print quot operator quot print op import qaoaansatz ansatz qaoaansatz op quot mpl quot quot iqp quot pre code import target pm ansatz pre code def params ansatz hamiltonian estimator quot quot quot return estimate energy estimator parameters params ndarray array ansatz parameters ansatz quantumcircuit parameterized ansatz circuit hamiltonian sparsepauliop operator representation hamiltonian estimator estimatorv2 estimator primitive instance returns float energy estimate quot quot quot pub ansatz hamiltonian params result pub cost result 0 0 return cost pre code session session configure estimator estimator estimator true configure sampler sampler sampler true x0 2 pre code res minimize x0 estimator quot cobyla quot p python interpreter runs error due long time takes solve go ibm quantum platform job https nofollow noreferrer img https enter image description p suggested way move forward acoording https 20minimize 20x0 20estimator 22cobyla 22 nofollow noreferrer ibm qaoa link pre code assign solution parameters ansatz qc add measurements circuit qc quot mpl quot quot iqp quot result result 0 close session since done p since interpretter times get use code p ibm platforms provides way use results job pre code import qiskitruntimeservice service qiskitruntimeservice job idx enumerate print f quot expectation values pub idx quot p want know use results carry forward calculation new qaoa might straight forward help,"[(0, 0.68287134), (4, 0.029153133), (6, 0.011634398), (8, 0.029884996), (11, 0.012298706), (12, 0.04035726), (14, 0.01722291), (19, 0.17635769)]"
37505,,2024-03-28 10:45:03,2,168,"<p>I would like to study the effects of non-computational levels of two coupled qubits by a resonator using QuTiP. The idea is to consider the following Hamiltonians</p>
<p>Qubits Hamiltonian
<span class=""math-container"">$$
H_{q_i} = \sum_n 4E_C (n-n_g)^2|n\rangle\langle n| + \frac{E_J}{2}(|n+1\rangle\langle n|+|n\rangle\langle n+1|)
$$</span></p>
<p>Resonator Hamiltonian
<span class=""math-container"">$$
H_r = \omega_r a^\dagger a
$$</span></p>
<p>Free Hamiltonian
<span class=""math-container"">$$
H_0 = H_{q_1} \otimes H_{q_2} \otimes H_r
$$</span></p>
<p>Interacting Hamiltonian
<span class=""math-container"">$$
H_{1r} = Q_1\otimes \mathbb{I} \otimes Q_r/C = -2i\beta_1 e V_\text{rms} N_{q_1} \otimes \mathbb{I} \otimes (a - a^\dagger)
$$</span>
<span class=""math-container"">$$
H_{2r} = \mathbb{I} \otimes Q_2 \otimes Q_r/C = \mathbb{I} \otimes -2i\beta_2 e V_\text{rms} N_{q_2} \otimes (a - a^\dagger)
$$</span>
<span class=""math-container"">$$
H_\text{int} = H_{1r} + H_{2r}
$$</span></p>
<p>where <span class=""math-container"">$N_{q_i}$</span> is the number operator in the energy basis, <span class=""math-container"">$\beta_i = \frac{C_{g_i}}{C_{g_i} + C_{s_i}}$</span> which is proportional to the coupling capacitance between the qubit and the resonator, and the shunt capacitance.</p>
<p>Total Hamiltonian
<span class=""math-container"">$$
H = H_0 + H_\text{int}
$$</span></p>
<p>After instantiating these Hamiltonians I want to use the Schrieffer-Wolff Transformation to get an effective Hamiltonian limited to the computational levels and decoupled from the resonator.</p>
<p>The basic idea is to implement the <a href=""https://en.wikipedia.org/wiki/Schrieffer%E2%80%93Wolff_transformation"" rel=""nofollow noreferrer"">Schrieffer-Wolff transformation</a> to reduce the transmon Hamiltonian (multiple levels) to an effective Hamiltonian (two levels).</p>
<p><span class=""math-container"">$$ H = H_0 + \varepsilon V$$</span></p>
<p>introducing the unitary transformation</p>
<p><span class=""math-container"">$$ e^{\varepsilon S} H e^{-\varepsilon S}$$</span></p>
<p>where <span class=""math-container"">$\varepsilon$</span> is small, <span class=""math-container"">$\exp{(\varepsilon S)}$</span> is unitary and <span class=""math-container"">$S$</span> anti-hermitian. By expanding the expression using the <a href=""https://en.wikipedia.org/wiki/Baker%E2%80%93Campbell%E2%80%93Hausdorff_formula"" rel=""nofollow noreferrer"">Baker-Campbell-Hausdorff formula</a></p>
<p><span class=""math-container"">$$ e^{\varepsilon S} H e^{-\varepsilon S} = H + \varepsilon[S, H] + \frac{\varepsilon^2}{2}[S, [S, H]] + O(\varepsilon^2) = H_0 + \varepsilon(V + [S, H_0]) +  \frac{\varepsilon^2}{2}(2[S,V] + [S,[S,H_0]]) + O(\varepsilon^2)$$</span></p>
<p>The Schrieffer-Wolff transformation chooses <span class=""math-container"">$S$</span> such that</p>
<p><span class=""math-container"">$$V + [S, H_0] = 0$$</span></p>
<p>which is known as <a href=""https://en.wikipedia.org/wiki/Sylvester_equation"" rel=""nofollow noreferrer"">Sylvester equation</a>.
What remains is</p>
<p><span class=""math-container"">$$e^{\varepsilon S} H e^{-\varepsilon S} = H_0 + \frac{\varepsilon^2}{2}[S,V] + O(\varepsilon^2)$$</span></p>
<p>By defining the projectors <span class=""math-container"">$P$</span> on the low-energy space. The low-energy effective Hamiltonian becomes</p>
<p><span class=""math-container"">$$H_\text{eff} = P(H_0 + \frac{\varepsilon^2}{2}[S,V] )P$$</span></p>
<pre><code># Eigenvectors
_, eigenvectors_q1 = q1.h.eigenstates()
_, eigenvectors_q2 = q2.h.eigenstates()
_, eigenvectors_r = r.h.eigenstates()

# Projectors (|0&gt;&lt;0|+|1&gt;&lt;1|) ⊗ (|0&gt;&lt;0|+|1&gt;&lt;1|) ⊗ Identity
# Each tensor product is an energy eigenstate of qubits' Hamiltonian, for the resonator an identity is used
# Qubit 1 ⊗ Qubit 2 ⊗ Resonator
p = tensor(eigenvectors_q1[0] * eigenvectors_q1[0].dag() + eigenvectors_q1[1] * eigenvectors_q1[1].dag(), eigenvectors_q2[0] * eigenvectors_q2[0].dag() + eigenvectors_q2[1] * eigenvectors_q2[1].dag(), qeye(r.dim))

# S matrix from Sylvester equation (https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_sylvester.html)
s = Qobj(solve_sylvester(-h0.full(), h0.full(), -hint.full()))

# Effective Hamiltonian
heff = Qobj(h0.full() + 0.5 * commutator(s.full(), hint.full()))

# Reduced Hamiltonian
hred = Qobj(p * heff.full() * p)
</code></pre>
<p>When I use <code>hred</code> as the Hamiltonian for the Master Equation and I use <code>psi100</code> as the initial state</p>
<pre><code>psi100 = tensor(eigenvectors_q1[1], eigenvectors_q2[0], eigenvectors_r[0])
psi010 = tensor(eigenvectors_q1[1], eigenvectors_q2[0], eigenvectors_r[0])
t_list = np.linspace(0, 20, 1000)
result = mesolve(H=hred, rho0=psi[1,0,0], tlist=t_list, c_ops=[], e_ops=[], args={})
</code></pre>
<p>There is no exchange between states <code>psi100</code> and <code>psi010</code>, when I would expect, in an ideal two-level system an iSWAP implementation. Or at least some kind of interaction.</p>
<p>As for the Hamiltonian definitions, I am quite sure that they are okay. Where I have some doubts is about the Schrieffer-Wolff transformation, I might have wrong implemented some steps or I am missing some diagonalizations, wrong states, and wrong projector definition.</p>
",Effective Hamiltonian using Schrieffer-Wolff transformation and QuTiP,<qutip>,0,0,,,"Effective Hamiltonian using Schrieffer-Wolff transformation and QuTiP <p>I would like to study the effects of non-computational levels of two coupled qubits by a resonator using QuTiP. The idea is to consider the following Hamiltonians</p>
<p>Qubits Hamiltonian
<span class=""math-container"">$$
H_{q_i} = \sum_n 4E_C (n-n_g)^2|n\rangle\langle n| + \frac{E_J}{2}(|n+1\rangle\langle n|+|n\rangle\langle n+1|)
$$</span></p>
<p>Resonator Hamiltonian
<span class=""math-container"">$$
H_r = \omega_r a^\dagger a
$$</span></p>
<p>Free Hamiltonian
<span class=""math-container"">$$
H_0 = H_{q_1} \otimes H_{q_2} \otimes H_r
$$</span></p>
<p>Interacting Hamiltonian
<span class=""math-container"">$$
H_{1r} = Q_1\otimes \mathbb{I} \otimes Q_r/C = -2i\beta_1 e V_\text{rms} N_{q_1} \otimes \mathbb{I} \otimes (a - a^\dagger)
$$</span>
<span class=""math-container"">$$
H_{2r} = \mathbb{I} \otimes Q_2 \otimes Q_r/C = \mathbb{I} \otimes -2i\beta_2 e V_\text{rms} N_{q_2} \otimes (a - a^\dagger)
$$</span>
<span class=""math-container"">$$
H_\text{int} = H_{1r} + H_{2r}
$$</span></p>
<p>where <span class=""math-container"">$N_{q_i}$</span> is the number operator in the energy basis, <span class=""math-container"">$\beta_i = \frac{C_{g_i}}{C_{g_i} + C_{s_i}}$</span> which is proportional to the coupling capacitance between the qubit and the resonator, and the shunt capacitance.</p>
<p>Total Hamiltonian
<span class=""math-container"">$$
H = H_0 + H_\text{int}
$$</span></p>
<p>After instantiating these Hamiltonians I want to use the Schrieffer-Wolff Transformation to get an effective Hamiltonian limited to the computational levels and decoupled from the resonator.</p>
<p>The basic idea is to implement the <a href=""https://en.wikipedia.org/wiki/Schrieffer%E2%80%93Wolff_transformation"" rel=""nofollow noreferrer"">Schrieffer-Wolff transformation</a> to reduce the transmon Hamiltonian (multiple levels) to an effective Hamiltonian (two levels).</p>
<p><span class=""math-container"">$$ H = H_0 + \varepsilon V$$</span></p>
<p>introducing the unitary transformation</p>
<p><span class=""math-container"">$$ e^{\varepsilon S} H e^{-\varepsilon S}$$</span></p>
<p>where <span class=""math-container"">$\varepsilon$</span> is small, <span class=""math-container"">$\exp{(\varepsilon S)}$</span> is unitary and <span class=""math-container"">$S$</span> anti-hermitian. By expanding the expression using the <a href=""https://en.wikipedia.org/wiki/Baker%E2%80%93Campbell%E2%80%93Hausdorff_formula"" rel=""nofollow noreferrer"">Baker-Campbell-Hausdorff formula</a></p>
<p><span class=""math-container"">$$ e^{\varepsilon S} H e^{-\varepsilon S} = H + \varepsilon[S, H] + \frac{\varepsilon^2}{2}[S, [S, H]] + O(\varepsilon^2) = H_0 + \varepsilon(V + [S, H_0]) +  \frac{\varepsilon^2}{2}(2[S,V] + [S,[S,H_0]]) + O(\varepsilon^2)$$</span></p>
<p>The Schrieffer-Wolff transformation chooses <span class=""math-container"">$S$</span> such that</p>
<p><span class=""math-container"">$$V + [S, H_0] = 0$$</span></p>
<p>which is known as <a href=""https://en.wikipedia.org/wiki/Sylvester_equation"" rel=""nofollow noreferrer"">Sylvester equation</a>.
What remains is</p>
<p><span class=""math-container"">$$e^{\varepsilon S} H e^{-\varepsilon S} = H_0 + \frac{\varepsilon^2}{2}[S,V] + O(\varepsilon^2)$$</span></p>
<p>By defining the projectors <span class=""math-container"">$P$</span> on the low-energy space. The low-energy effective Hamiltonian becomes</p>
<p><span class=""math-container"">$$H_\text{eff} = P(H_0 + \frac{\varepsilon^2}{2}[S,V] )P$$</span></p>
<pre><code># Eigenvectors
_, eigenvectors_q1 = q1.h.eigenstates()
_, eigenvectors_q2 = q2.h.eigenstates()
_, eigenvectors_r = r.h.eigenstates()

# Projectors (|0&gt;&lt;0|+|1&gt;&lt;1|) ⊗ (|0&gt;&lt;0|+|1&gt;&lt;1|) ⊗ Identity
# Each tensor product is an energy eigenstate of qubits' Hamiltonian, for the resonator an identity is used
# Qubit 1 ⊗ Qubit 2 ⊗ Resonator
p = tensor(eigenvectors_q1[0] * eigenvectors_q1[0].dag() + eigenvectors_q1[1] * eigenvectors_q1[1].dag(), eigenvectors_q2[0] * eigenvectors_q2[0].dag() + eigenvectors_q2[1] * eigenvectors_q2[1].dag(), qeye(r.dim))

# S matrix from Sylvester equation (https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_sylvester.html)
s = Qobj(solve_sylvester(-h0.full(), h0.full(), -hint.full()))

# Effective Hamiltonian
heff = Qobj(h0.full() + 0.5 * commutator(s.full(), hint.full()))

# Reduced Hamiltonian
hred = Qobj(p * heff.full() * p)
</code></pre>
<p>When I use <code>hred</code> as the Hamiltonian for the Master Equation and I use <code>psi100</code> as the initial state</p>
<pre><code>psi100 = tensor(eigenvectors_q1[1], eigenvectors_q2[0], eigenvectors_r[0])
psi010 = tensor(eigenvectors_q1[1], eigenvectors_q2[0], eigenvectors_r[0])
t_list = np.linspace(0, 20, 1000)
result = mesolve(H=hred, rho0=psi[1,0,0], tlist=t_list, c_ops=[], e_ops=[], args={})
</code></pre>
<p>There is no exchange between states <code>psi100</code> and <code>psi010</code>, when I would expect, in an ideal two-level system an iSWAP implementation. Or at least some kind of interaction.</p>
<p>As for the Hamiltonian definitions, I am quite sure that they are okay. Where I have some doubts is about the Schrieffer-Wolff transformation, I might have wrong implemented some steps or I am missing some diagonalizations, wrong states, and wrong projector definition.</p>
",qc,effective hamiltonian using transformation qutip p would like study effects levels two coupled qubits resonator using qutip idea consider following hamiltonians p qubits hamiltonian span 2 p resonator hamiltonian span p free hamiltonian span p interacting hamiltonian span 1r e rms span 2r e rms span int 1r 2r p span number operator energy basis span proportional coupling capacitance qubit resonator shunt p total hamiltonian span h int p instantiating hamiltonians want use transformation get effective hamiltonian limited computational levels decoupled p basic idea implement https e2 80 nofollow noreferrer transformation reduce transmon hamiltonian multiple levels effective hamiltonian two levels p span h v p introducing unitary transformation p span h p span small span unitary span expanding expression using https e2 80 93campbell e2 80 nofollow noreferrer formula p span h h h 2 h v 2 2 v p transformation chooses span p span v 0 p known https nofollow noreferrer sylvester equation remains p span h 2 v p defining projectors span p space effective hamiltonian becomes p span eff p 2 v p pre code eigenvectors projectors gt lt gt lt gt lt gt lt identity tensor product energy eigenstate qubits hamiltonian resonator identity used qubit 1 qubit 2 resonator p tensor 0 0 1 1 0 0 1 1 qeye matrix sylvester equation https qobj effective hamiltonian heff qobj commutator reduced hamiltonian hred qobj p p p use code hred hamiltonian master equation use code psi100 initial state pre code psi100 tensor 1 0 0 psi010 tensor 1 0 0 0 20 1000 result mesolve p exchange states code psi100 code psi010 would expect ideal system iswap implementation least kind p hamiltonian definitions quite sure okay doubts transformation might wrong implemented steps missing diagonalizations wrong states wrong projector,"[(0, 0.11539002), (1, 0.08306149), (2, 0.08734338), (3, 0.3312651), (4, 0.028299313), (7, 0.03191856), (9, 0.2826407), (11, 0.017912427), (12, 0.021785028)]"
37513,37514.0,2024-03-28 15:29:17,1,245,"<p>I have these 2 quantum circuits:</p>
<p><a href=""https://i.sstatic.net/WZPPG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/WZPPG.png"" alt="""" /></a></p>
<p>Are they equivalent?I think they are but I cannot understand how this could be possible.Lets assume that the initial condition of the first circuit is:]</p>
<p>Lets assume that gate A transforms any qubit
<span class=""math-container"">$
\begin{pmatrix}
f\\ 
e 
\end{pmatrix}
$</span>
into:
<span class=""math-container"">$
\begin{pmatrix}
f'\\ 
e' 
\end{pmatrix}
$</span>
and gate B transforms any 2 qubit system from:
<span class=""math-container"">$
\begin{pmatrix}
gi\\ 
gj\\ 
hi\\ 
hj
\end{pmatrix}
$</span>
into:
<span class=""math-container"">$
\begin{pmatrix}
gi\\ 
gj\\ 
hi''\\ 
hj''
\end{pmatrix}
$</span></p>
<p>Lets take the first system.From a initial condition of:</p>
<p><span class=""math-container"">$
\begin{pmatrix}
ac\\ 
ad\\ 
bc\\ 
bd
\end{pmatrix}
$</span>
after gate A it becomes:
<span class=""math-container"">$
\begin{pmatrix}
a'c\\ 
a'd\\ 
b'c\\ 
b'd
\end{pmatrix}
$</span>
and after controlled gate B it becomes:
<span class=""math-container"">$
\begin{pmatrix}
a'c\\ 
a'd\\ 
b'c''\\ 
b'd''
\end{pmatrix}
$</span>
Now lets take the second system.From a initial condition of:
<span class=""math-container"">$
\begin{pmatrix}
ac\\ 
ad\\ 
bc\\ 
bd
\end{pmatrix}
$</span>
after gate B it becomes:</p>
<p><span class=""math-container"">$
\begin{pmatrix}
ac\\ 
ad\\ 
bc''\\ 
bd''
\end{pmatrix}
$</span>
and after gate A it becomes:
<span class=""math-container"">$
\begin{pmatrix}
a'c\\ 
a'd\\ 
b'c''\\ 
b'd''
\end{pmatrix}
$</span>
so the 2 are equivalent?But this cannot be correct , intuitively it is not correct.Where am I wrong here?</p>
",Equivalence of quantum circuits,<quantum-gate><quantum-state><logical-gates>,3,0,,,"Equivalence of quantum circuits <p>I have these 2 quantum circuits:</p>
<p><a href=""https://i.sstatic.net/WZPPG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/WZPPG.png"" alt="""" /></a></p>
<p>Are they equivalent?I think they are but I cannot understand how this could be possible.Lets assume that the initial condition of the first circuit is:]</p>
<p>Lets assume that gate A transforms any qubit
<span class=""math-container"">$
\begin{pmatrix}
f\\ 
e 
\end{pmatrix}
$</span>
into:
<span class=""math-container"">$
\begin{pmatrix}
f'\\ 
e' 
\end{pmatrix}
$</span>
and gate B transforms any 2 qubit system from:
<span class=""math-container"">$
\begin{pmatrix}
gi\\ 
gj\\ 
hi\\ 
hj
\end{pmatrix}
$</span>
into:
<span class=""math-container"">$
\begin{pmatrix}
gi\\ 
gj\\ 
hi''\\ 
hj''
\end{pmatrix}
$</span></p>
<p>Lets take the first system.From a initial condition of:</p>
<p><span class=""math-container"">$
\begin{pmatrix}
ac\\ 
ad\\ 
bc\\ 
bd
\end{pmatrix}
$</span>
after gate A it becomes:
<span class=""math-container"">$
\begin{pmatrix}
a'c\\ 
a'd\\ 
b'c\\ 
b'd
\end{pmatrix}
$</span>
and after controlled gate B it becomes:
<span class=""math-container"">$
\begin{pmatrix}
a'c\\ 
a'd\\ 
b'c''\\ 
b'd''
\end{pmatrix}
$</span>
Now lets take the second system.From a initial condition of:
<span class=""math-container"">$
\begin{pmatrix}
ac\\ 
ad\\ 
bc\\ 
bd
\end{pmatrix}
$</span>
after gate B it becomes:</p>
<p><span class=""math-container"">$
\begin{pmatrix}
ac\\ 
ad\\ 
bc''\\ 
bd''
\end{pmatrix}
$</span>
and after gate A it becomes:
<span class=""math-container"">$
\begin{pmatrix}
a'c\\ 
a'd\\ 
b'c''\\ 
b'd''
\end{pmatrix}
$</span>
so the 2 are equivalent?But this cannot be correct , intuitively it is not correct.Where am I wrong here?</p>
",qc,equivalence quantum circuits p 2 quantum circuits p https nofollow noreferrer img https p equivalent think understand could assume initial condition first circuit p lets assume gate transforms qubit span pmatrix e pmatrix span pmatrix e pmatrix gate b transforms 2 qubit system span pmatrix hj pmatrix span pmatrix hi hj pmatrix p lets take first initial condition p span pmatrix bd pmatrix gate becomes span pmatrix b b pmatrix controlled gate b becomes span pmatrix b c b pmatrix lets take second initial condition span pmatrix bd pmatrix gate b becomes p span pmatrix bc bd pmatrix gate becomes span pmatrix b c b pmatrix 2 equivalent correct intuitively wrong,"[(3, 0.31972384), (4, 0.15802875), (9, 0.0751846), (12, 0.028517548), (15, 0.3962035), (18, 0.02108221)]"
37563,,2024-04-01 12:14:03,7,175,"<p>It's known that any multi-qubit quantum gate can be represented as a product of a number of CNOT and single-qubit gates. The total number of these simple gates required is exponential (in the number of qubits) on average, and thus we can say that an average complexity for a random gate is exponential. Thus, there can be a big difference between some two multi-qubit gates. But this is just from one perspective.</p>
<p>In reality a quantum gate is a physical device. Why, from physics perspective, one quantum gate should be more complex than another one?</p>
<p>As an analogy, think of the distinction between classical CPU and specialized hardware, like FPGA, ASIC, GPU, TPU, LPU, etc. Specialized hardware is much faster for specific tasks, while they are not supposed to be universal computing devices like CPUs.</p>
<p>So, would it be possible for a random quantum gate to physically construct a device that will compute it with a speed comparable to, say, the computation of the Walsh-Hadamard gate?</p>
<p>Perhaps, this question sounds more reasonable when we have just one quantum system with <span class=""math-container"">$d$</span> degrees of freedom and look for a complexity of a random unitary acting on it.</p>
",Can we think that any multi-qubit quantum gate has a constant complexity from physics perspective?,<foundations>,2,4,,,"Can we think that any multi-qubit quantum gate has a constant complexity from physics perspective? <p>It's known that any multi-qubit quantum gate can be represented as a product of a number of CNOT and single-qubit gates. The total number of these simple gates required is exponential (in the number of qubits) on average, and thus we can say that an average complexity for a random gate is exponential. Thus, there can be a big difference between some two multi-qubit gates. But this is just from one perspective.</p>
<p>In reality a quantum gate is a physical device. Why, from physics perspective, one quantum gate should be more complex than another one?</p>
<p>As an analogy, think of the distinction between classical CPU and specialized hardware, like FPGA, ASIC, GPU, TPU, LPU, etc. Specialized hardware is much faster for specific tasks, while they are not supposed to be universal computing devices like CPUs.</p>
<p>So, would it be possible for a random quantum gate to physically construct a device that will compute it with a speed comparable to, say, the computation of the Walsh-Hadamard gate?</p>
<p>Perhaps, this question sounds more reasonable when we have just one quantum system with <span class=""math-container"">$d$</span> degrees of freedom and look for a complexity of a random unitary acting on it.</p>
",qc,think quantum gate constant complexity physics perspective p known quantum gate represented product number cnot gates total number simple gates required exponential number qubits average thus say average complexity random gate exponential thus big difference two gates one p reality quantum gate physical device physics perspective one quantum gate complex another one p analogy think distinction classical cpu specialized hardware like fpga asic gpu tpu lpu etc specialized hardware much faster specific tasks supposed universal computing devices like p would possible random quantum gate physically construct device compute speed comparable say computation gate p perhaps question sounds reasonable one quantum system span degrees freedom look complexity random unitary acting,"[(3, 0.07372467), (7, 0.11946296), (8, 0.4140638), (9, 0.297902), (12, 0.02860373), (14, 0.06491105)]"
78268696,,2024-04-03 15:18:00,1,71,"<p>I am trying to implement a quantum algorithm written in an research paper. The layout is a linear layer , followed by an quantum activation function layer and then a layer of softmax. This is my current code of the model and layer implementation</p>
<pre><code>`
</code></pre>
<pre><code>import numpy as np
    from qiskit import QuantumCircuit, transpile, assemble
    from qiskit_aer import Aer
    from tensorflow.keras.layers import Layer
    class QuantumActivationFunction(Layer):
        def __init__(self, num_features, output_size, **kwargs):
            super(QuantumActivationFunction, self).__init__(**kwargs)
            self.num_features =8
            self.output_size = 8
        
        def encode_data_to_qubits(self, data):
            # Implement the encoding of data to qubits
            num_samples, num_features = data.shape
            encoded_states = []

            for i in range(num_samples):
                x = data[i]
                qc = QuantumCircuit(num_features)
                for j in range(num_features):
                    angle_1 = np.arctan(x[j])
                    angle_2 = np.arctan(x[j] ** 2)
                    qc.h(j)
                    qc.ry(angle_1, j)
                    qc.rz(angle_2, j)
                encoded_states.append(qc)
            return encoded_states

        def entangle_qubits(self, qc):
            # Implement qubit entanglement
            num_qubits = qc.num_qubits
            for stride in range(1, num_qubits):
                for i in range(num_qubits):
                    control_qubit = qc.qubits[i]
                    target_qubit = qc.qubits[(i+stride)%8]
                    qc.cx(control_qubit, target_qubit)
            
        def compute_r(qc):
            r = [0] * 4
            for i in range(4):
                r[i] = qc.rz(np.pi,qc.qubits[i])
            return r
                
        # def build(self, input_shape):
        #     # Define any trainable parameters here
        #     self._input_shape = input_shape
        #     pass

        def call(self, data):
            # Implement the activation function logic here
            # For example, you can use the inputs to compute the quantum activation
            # return tf.nn.relu(inputs)  # Placeholder example, replace with your quantum activation function logi
            encoded_states = self.encode_data_to_qubits(data)
            for qc in encoded_states:
                self.entangle_qubits(qc)
                self.compute_r(qc)
            return encoded_states
                    

        # def compute_output_shape(self, input_shape):
        #      #Return the shape of the output tensor
        #      return (input_shape[0], self.output_size)

    from keras.layers import Activation
    from keras.activations import softmax

    def baseline_model():
        model = Sequential()
        model.add(Dense(8, input_dim=374, activation='linear'))  # Linear layer
        model.add(QuantumActivationFunction(8,8))  # Quantum Activation Function layer
        model.add(Dense(3, activation='softmax'))  # Output layer
        model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
        return model
</code></pre>
<pre><code>The code is returning error :
`TypeError                                 Traceback (most recent call last)
Cell In[105], line 1
----&gt; 1 model = baseline_model()
      2 first_linear_layer_output = model.layers[0](X_train).numpy()
      4 print(&quot;Output of the first linear layer:&quot;, first_linear_layer_output)

Cell In[104], line 7
      5 model = Sequential()
      6 model.add(Dense(8, input_dim=374, activation='linear'))  # Linear layer
----&gt; 7 model.add(QuantumActivationFunction(8,8))  # Quantum Activation Function layer
      8 model.add(Dense(3, activation='softmax'))  # Output layer
      9 model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

File ~\AppData\Roaming\Python\Python311\site-packages\tensorflow\python\trackable\base.py:205, in no_automatic_dependency_tracking.&lt;locals&gt;._method_wrapper(self, *args, **kwargs)
    203 self._self_setattr_tracking = False  # pylint: disable=protected-access
    204 try:
--&gt; 205   result = method(self, *args, **kwargs)
    206 finally:`your text`
    207   self._self_setattr_tracking = previous_value  # pylint: disable=protected-access

File c:\Python311\Lib\site-packages\keras\utils\traceback_utils.py:70, in filter_traceback.&lt;locals&gt;.error_handler(*args, **kwargs)
     67     filtered_tb = _process_traceback_frames(e.__traceback`
</code></pre>
<p>I have tried rechecking my code several times, I have even checked dimensions of my data but still the error persists. When I was running the functions of quantum layer separately , it was working fine but after integrating it into class , it showed again the same error.
Sincere request to everyone who can help</p>
",Quantum Computing implementation,<neural-network><quantum-computing><activation-function><qiskit>,0,2,,,"Quantum Computing implementation <p>I am trying to implement a quantum algorithm written in an research paper. The layout is a linear layer , followed by an quantum activation function layer and then a layer of softmax. This is my current code of the model and layer implementation</p>
<pre><code>`
</code></pre>
<pre><code>import numpy as np
    from qiskit import QuantumCircuit, transpile, assemble
    from qiskit_aer import Aer
    from tensorflow.keras.layers import Layer
    class QuantumActivationFunction(Layer):
        def __init__(self, num_features, output_size, **kwargs):
            super(QuantumActivationFunction, self).__init__(**kwargs)
            self.num_features =8
            self.output_size = 8
        
        def encode_data_to_qubits(self, data):
            # Implement the encoding of data to qubits
            num_samples, num_features = data.shape
            encoded_states = []

            for i in range(num_samples):
                x = data[i]
                qc = QuantumCircuit(num_features)
                for j in range(num_features):
                    angle_1 = np.arctan(x[j])
                    angle_2 = np.arctan(x[j] ** 2)
                    qc.h(j)
                    qc.ry(angle_1, j)
                    qc.rz(angle_2, j)
                encoded_states.append(qc)
            return encoded_states

        def entangle_qubits(self, qc):
            # Implement qubit entanglement
            num_qubits = qc.num_qubits
            for stride in range(1, num_qubits):
                for i in range(num_qubits):
                    control_qubit = qc.qubits[i]
                    target_qubit = qc.qubits[(i+stride)%8]
                    qc.cx(control_qubit, target_qubit)
            
        def compute_r(qc):
            r = [0] * 4
            for i in range(4):
                r[i] = qc.rz(np.pi,qc.qubits[i])
            return r
                
        # def build(self, input_shape):
        #     # Define any trainable parameters here
        #     self._input_shape = input_shape
        #     pass

        def call(self, data):
            # Implement the activation function logic here
            # For example, you can use the inputs to compute the quantum activation
            # return tf.nn.relu(inputs)  # Placeholder example, replace with your quantum activation function logi
            encoded_states = self.encode_data_to_qubits(data)
            for qc in encoded_states:
                self.entangle_qubits(qc)
                self.compute_r(qc)
            return encoded_states
                    

        # def compute_output_shape(self, input_shape):
        #      #Return the shape of the output tensor
        #      return (input_shape[0], self.output_size)

    from keras.layers import Activation
    from keras.activations import softmax

    def baseline_model():
        model = Sequential()
        model.add(Dense(8, input_dim=374, activation='linear'))  # Linear layer
        model.add(QuantumActivationFunction(8,8))  # Quantum Activation Function layer
        model.add(Dense(3, activation='softmax'))  # Output layer
        model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
        return model
</code></pre>
<pre><code>The code is returning error :
`TypeError                                 Traceback (most recent call last)
Cell In[105], line 1
----&gt; 1 model = baseline_model()
      2 first_linear_layer_output = model.layers[0](X_train).numpy()
      4 print(&quot;Output of the first linear layer:&quot;, first_linear_layer_output)

Cell In[104], line 7
      5 model = Sequential()
      6 model.add(Dense(8, input_dim=374, activation='linear'))  # Linear layer
----&gt; 7 model.add(QuantumActivationFunction(8,8))  # Quantum Activation Function layer
      8 model.add(Dense(3, activation='softmax'))  # Output layer
      9 model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

File ~\AppData\Roaming\Python\Python311\site-packages\tensorflow\python\trackable\base.py:205, in no_automatic_dependency_tracking.&lt;locals&gt;._method_wrapper(self, *args, **kwargs)
    203 self._self_setattr_tracking = False  # pylint: disable=protected-access
    204 try:
--&gt; 205   result = method(self, *args, **kwargs)
    206 finally:`your text`
    207   self._self_setattr_tracking = previous_value  # pylint: disable=protected-access

File c:\Python311\Lib\site-packages\keras\utils\traceback_utils.py:70, in filter_traceback.&lt;locals&gt;.error_handler(*args, **kwargs)
     67     filtered_tb = _process_traceback_frames(e.__traceback`
</code></pre>
<p>I have tried rechecking my code several times, I have even checked dimensions of my data but still the error persists. When I was running the functions of quantum layer separately , it was working fine but after integrating it into class , it showed again the same error.
Sincere request to everyone who can help</p>
",so_new,quantum computing implementation p trying implement quantum algorithm written research paper layout linear layer followed quantum activation function layer layer softmax current code model layer implementation pre code pre code import numpy np qiskit import quantumcircuit transpile assemble import aer import layer class quantumactivationfunction layer def self kwargs super quantumactivationfunction self kwargs 8 def self data implement encoding data qubits range x data qc quantumcircuit j range x j x j 2 j j j qc return def self qc implement qubit entanglement stride range 1 range 8 def qc r 0 4 range 4 r return r def build self define trainable parameters pass def call self data implement activation function logic example use inputs compute quantum activation return inputs placeholder example replace quantum activation function logi data qc qc qc return def self return shape output tensor return 0 import activation import softmax def model sequential dense 8 linear layer quantumactivationfunction quantum activation function layer dense 3 output layer return model pre code code returning error typeerror traceback recent call last cell 105 line 1 gt 1 model 2 0 4 print quot output first linear layer quot cell 104 line 7 5 model sequential 6 dense 8 linear layer gt 7 quantumactivationfunction quantum activation function layer 8 dense 3 output layer 9 file lt locals gt self args kwargs 203 false pylint 204 try gt 205 result method self args kwargs 206 finally text 207 pylint file c lt locals gt args kwargs 67 p tried rechecking code several times even checked dimensions data still error persists running functions quantum layer separately working fine integrating class showed error sincere request everyone help,"[(0, 0.49240428), (6, 0.0810177), (8, 0.2016923), (10, 0.015104804), (12, 0.04365481), (19, 0.16560912)]"
37651,,2024-04-05 20:06:09,3,40,"<p>Suppose we have a definite function of interest from numbers to numbers (from a finite set).</p>
<p>In general, we have a lot of options when we construct algorithms that compute it (with some errors, possibly). We can use classical processing, randomization, quantum tools such as oracles, measurements (in multiple rounds), quantum channels and any combinations of those.</p>
<p>But as an input for quantum algorithms we usually require oracles which are just quantum unitaries, i.e. purely quantum algorithms. So, can we assume that any hybrid algorithm can be transformed into an oracle with a comparable complexity?</p>
<p>If we have just a deterministic classical algorithm then the conversion is possible, this is well known. But I'm not sure about that if we're allowed to use multiple rounds of quantum measurements additionally.</p>
",Is it safe to assume that any hybrid algorithm can be transformed into a purely quantum form with comparable complexity?,<classical-computing><oracles>,0,5,,,"Is it safe to assume that any hybrid algorithm can be transformed into a purely quantum form with comparable complexity? <p>Suppose we have a definite function of interest from numbers to numbers (from a finite set).</p>
<p>In general, we have a lot of options when we construct algorithms that compute it (with some errors, possibly). We can use classical processing, randomization, quantum tools such as oracles, measurements (in multiple rounds), quantum channels and any combinations of those.</p>
<p>But as an input for quantum algorithms we usually require oracles which are just quantum unitaries, i.e. purely quantum algorithms. So, can we assume that any hybrid algorithm can be transformed into an oracle with a comparable complexity?</p>
<p>If we have just a deterministic classical algorithm then the conversion is possible, this is well known. But I'm not sure about that if we're allowed to use multiple rounds of quantum measurements additionally.</p>
",qc,safe assume hybrid algorithm transformed purely quantum form comparable complexity p suppose definite function interest numbers numbers finite set p general lot options construct algorithms compute errors possibly use classical processing randomization quantum tools oracles measurements multiple rounds quantum channels combinations p input quantum algorithms usually require oracles quantum unitaries purely quantum algorithms assume hybrid algorithm transformed oracle comparable complexity p deterministic classical algorithm conversion possible well known sure allowed use multiple rounds quantum measurements,"[(1, 0.15082946), (3, 0.13759542), (7, 0.08116956), (8, 0.36432603), (12, 0.029925598), (14, 0.14425446), (18, 0.090145625)]"
37858,37881.0,2024-04-18 11:17:33,0,129,"<p>A year ago, I registered in the IBM Quantum Computing app, which provides access to quantum computers and to simulators. I got an API key, and was able to run some programs.</p>
<p>However, lately, I try to log in in my account and the system answers me with the same page, and I am not able to get another/the same API key. In fact, when I run the programs I run a year ago, using the API key that I then got, the program replies with:</p>
<pre><code>qiskit_ibm_runtime.api.exceptions.RequestsApiError: '403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Your IBM Quantum account has been disabled. Learn more: https://ibm.biz/BdfaME., Error code: 3485.'
</code></pre>
<p>I tried to contact IBM, but they have not been replying...</p>
<p>Any idea?</p>
<p>By the way: I use python 3.11 and qiskit 0.43.0.</p>
<p>The program:</p>
<pre><code># Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile
#from qiskit.tools.jupyter import *
from IPython.display import display
from qiskit.visualization import *

# Loading your IBM Quantum account(s)
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;) # the error occurs here!

...

<span class=""math-container"">```</span>
</code></pre>
",Quantum Computing - via Qiskit - error 403,<qiskit><programming><ibm-quantum-devices>,2,2,,,"Quantum Computing - via Qiskit - error 403 <p>A year ago, I registered in the IBM Quantum Computing app, which provides access to quantum computers and to simulators. I got an API key, and was able to run some programs.</p>
<p>However, lately, I try to log in in my account and the system answers me with the same page, and I am not able to get another/the same API key. In fact, when I run the programs I run a year ago, using the API key that I then got, the program replies with:</p>
<pre><code>qiskit_ibm_runtime.api.exceptions.RequestsApiError: '403 Client Error: Forbidden for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Your IBM Quantum account has been disabled. Learn more: https://ibm.biz/BdfaME., Error code: 3485.'
</code></pre>
<p>I tried to contact IBM, but they have not been replying...</p>
<p>Any idea?</p>
<p>By the way: I use python 3.11 and qiskit 0.43.0.</p>
<p>The program:</p>
<pre><code># Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile
#from qiskit.tools.jupyter import *
from IPython.display import display
from qiskit.visualization import *

# Loading your IBM Quantum account(s)
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;) # the error occurs here!

...

<span class=""math-container"">```</span>
</code></pre>
",qc,quantum computing via qiskit error 403 p year ago registered ibm quantum computing app provides access quantum computers simulators got api key able run p however lately try log account system answers page able get api key fact run programs run year ago using api key got program replies pre code client error forbidden url https ibm quantum account disabled learn https error code 3485 p tried contact ibm replying p idea p way use python qiskit p program pre code importing standard qiskit libraries qiskit import quantumcircuit transpile import import display import loading ibm quantum account service qiskitruntimeservice quot quot error occurs span,"[(0, 0.36854059), (3, 0.015553128), (4, 0.027199626), (8, 0.25933376), (12, 0.030223006), (14, 0.20389079), (16, 0.035059277), (19, 0.059000086)]"
37863,,2024-04-18 14:10:07,3,3689,"<p>I am going to teach an introductory course on quantum information and I thought about this statement that I want to give at the very beginning.</p>
<p>Would you agree on that? From my perspective, every quantum notion has something to do with superposition at the end, right? Be it entanglement, computing, interference. Even exotic notions like the Aharonov-Bohm has in its heart something to do with superposition. If you are looking for quantum gravity, the notion of superposition is the first that raises a problem (a solvable problem, but still), because it is that elementary and different of classical physics.</p>
<p>Can I state superposition as the heart of all of quantum physics?</p>
",The heart of all of quantum physics is superposition,<superposition>,5,1,,,"The heart of all of quantum physics is superposition <p>I am going to teach an introductory course on quantum information and I thought about this statement that I want to give at the very beginning.</p>
<p>Would you agree on that? From my perspective, every quantum notion has something to do with superposition at the end, right? Be it entanglement, computing, interference. Even exotic notions like the Aharonov-Bohm has in its heart something to do with superposition. If you are looking for quantum gravity, the notion of superposition is the first that raises a problem (a solvable problem, but still), because it is that elementary and different of classical physics.</p>
<p>Can I state superposition as the heart of all of quantum physics?</p>
",qc,heart quantum physics superposition p going teach introductory course quantum information thought statement want give p would agree perspective every quantum notion something superposition end right entanglement computing interference even exotic notions like heart something superposition looking quantum gravity notion superposition first raises problem solvable problem still elementary different classical p state superposition heart quantum physics,"[(1, 0.104793094), (8, 0.3007764), (9, 0.114562534), (12, 0.05457386), (13, 0.23246284), (18, 0.19029263)]"
37901,,2024-04-21 11:16:59,3,47,"<p>Basically I want to build a gradient-free optimizer that classifies a very simple dataset (e.g. the <a href=""https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html"" rel=""nofollow noreferrer"">sklearn make_moons</a>) using <code>scipy.optimize</code> (<a href=""https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method"" rel=""nofollow noreferrer"">Nelder-Mead</a> or <a href=""https://en.wikipedia.org/wiki/Powell%27s_method"" rel=""nofollow noreferrer"">Powell method</a> or something similar).</p>
<p>I want to achieve this without using Qiskit's predefined classes, such as VQC, SamplerQNN and the likes of it, but only implementing the circuit in Qiskit and training it by passing the results to the optimizer &quot;by hand&quot;.</p>
<p>I'm achieving somewhat okay-ish results, but they are way worse than the ones I can achieve using the VQC class.</p>
<p>I was investigating the class a bit and found that they are using a NN to compute the gradients of the circuit, and then pass them to the optimizer. This would mean that the Nelder-Mead method in Qiskit is no longer gradient-free?</p>
<p>Do you have any ideas on how to approach this issue and what other steps have to be taken, in order to achieve similar results as in the VQC class?</p>
",Gradient-free optimization in Qiskit without using pre-defined classes,<qiskit><optimization><machine-learning><variational-quantum-algorithms>,0,0,,,"Gradient-free optimization in Qiskit without using pre-defined classes <p>Basically I want to build a gradient-free optimizer that classifies a very simple dataset (e.g. the <a href=""https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html"" rel=""nofollow noreferrer"">sklearn make_moons</a>) using <code>scipy.optimize</code> (<a href=""https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method"" rel=""nofollow noreferrer"">Nelder-Mead</a> or <a href=""https://en.wikipedia.org/wiki/Powell%27s_method"" rel=""nofollow noreferrer"">Powell method</a> or something similar).</p>
<p>I want to achieve this without using Qiskit's predefined classes, such as VQC, SamplerQNN and the likes of it, but only implementing the circuit in Qiskit and training it by passing the results to the optimizer &quot;by hand&quot;.</p>
<p>I'm achieving somewhat okay-ish results, but they are way worse than the ones I can achieve using the VQC class.</p>
<p>I was investigating the class a bit and found that they are using a NN to compute the gradients of the circuit, and then pass them to the optimizer. This would mean that the Nelder-Mead method in Qiskit is no longer gradient-free?</p>
<p>Do you have any ideas on how to approach this issue and what other steps have to be taken, in order to achieve similar results as in the VQC class?</p>
",qc,optimization qiskit without using classes p basically want build optimizer classifies simple dataset https nofollow noreferrer sklearn using code https e2 80 nofollow noreferrer https nofollow noreferrer powell method something similar p want achieve without using qiskit predefined classes vqc samplerqnn likes implementing circuit qiskit training passing results optimizer quot hand quot p achieving somewhat results way worse ones achieve using vqc p investigating class bit found using nn compute gradients circuit pass optimizer would mean method qiskit longer p ideas approach issue steps taken order achieve similar results vqc class,"[(4, 0.14344949), (8, 0.21267386), (9, 0.08219878), (12, 0.022797588), (14, 0.44070232), (15, 0.011803678), (19, 0.08493012)]"
38034,,2024-04-29 12:10:43,0,132,"<p>I've received the following error on one of the circuits I'm running on IBM Quantum devices (on IBM Brisbane) using <code>EstimatorV2</code> primitive.</p>
<pre><code>Failed - Too large of job payload being loaded. Reduce the length of the program data being loaded.
</code></pre>
<p>I am unclear what <code>program data</code> this error message is referring to. The circuit I'm running has around 600 ECR gates, and the Hamiltonian has around 5000 Pauli strings. Am I reaching a hard coded bound on the circuit depth, or is there a way to get around this error?</p>
",IBM Quantum payload error,<qiskit><ibm-quantum-devices><qiskit-runtime>,1,0,,,"IBM Quantum payload error <p>I've received the following error on one of the circuits I'm running on IBM Quantum devices (on IBM Brisbane) using <code>EstimatorV2</code> primitive.</p>
<pre><code>Failed - Too large of job payload being loaded. Reduce the length of the program data being loaded.
</code></pre>
<p>I am unclear what <code>program data</code> this error message is referring to. The circuit I'm running has around 600 ECR gates, and the Hamiltonian has around 5000 Pauli strings. Am I reaching a hard coded bound on the circuit depth, or is there a way to get around this error?</p>
",qc,ibm quantum payload error p received following error one circuits running ibm quantum devices ibm brisbane using code estimatorv2 pre code failed large job payload loaded reduce length program data loaded p unclear code program data error message referring circuit running around 600 ecr gates hamiltonian around 5000 pauli strings reaching hard coded bound circuit depth way get around error,"[(1, 0.03823553), (5, 0.039888714), (7, 0.03007627), (8, 0.13158968), (12, 0.09785822), (14, 0.6600174)]"
38054,38055.0,2024-04-30 11:50:35,5,269,"<p>Obviously, positive semi-definite operators always admit a positive trace as <span class=""math-container"">${\rm tr}(A)=\|A\|_1\geq 0$</span> whenever <span class=""math-container"">$A\geq 0$</span>. This motivates the following &quot;lifted&quot; question:</p>
<blockquote>
<p>Given any positive, linear map <span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> is it true that <span class=""math-container"">${\rm tr}(\Phi)\geq 0$</span>?</p>
</blockquote>
<p>For this recall that the trace of a linear map <span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> is defined to be <span class=""math-container"">${\rm tr}(\Phi)=\sum_j{\rm tr}(G_j^\dagger\Phi(G_j))$</span> where <span class=""math-container"">$\{G_j\}_j$</span> is any orthonormal basis of <span class=""math-container"">$\mathbb C^{n\times n}$</span> (equipped with the <a href=""https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator#Space_of_Hilbert%E2%80%93Schmidt_operators"" rel=""nofollow noreferrer"">Hilbert-Schmidt inner product</a>). As an example one could choose the standard/computational basis <span class=""math-container"">$\{|j\rangle\langle k|\}_{j,k}$</span> and obtain the explicit expression <span class=""math-container"">${\rm tr}(\Phi)=\sum_{j,k}\langle j|\Phi(|j\rangle\langle k|)|k\rangle$</span>. Equivalently, the trace of <span class=""math-container"">$\Phi$</span> is of course equal to the trace of any matrix representation of <span class=""math-container"">$\Phi$</span>—such as the <a href=""https://quantumcomputing.stackexchange.com/a/37795"">natural representation</a> or the <a href=""https://quantumcomputing.stackexchange.com/q/38099"">Pauli transfer matrix</a>—and the trace is also equal to the <a href=""https://math.stackexchange.com/q/546155"">sum of all eigenvalues</a> of <span class=""math-container"">$\Phi$</span>.
To give an example the transposition map <span class=""math-container"">$T$</span>—the <a href=""https://quantumcomputing.stackexchange.com/a/38013"">prime example of a positive but not completely positive map</a>—has trace zero which is in agreement with the above question.</p>
<p>For the special case where <span class=""math-container"">$\Phi$</span> is completely positive the above statement holds <a href=""https://quantumcomputing.stackexchange.com/q/33684"">as a consequence of</a> the <a href=""https://quantumcomputing.stackexchange.com/a/5816"">Kraus representation</a> <span class=""math-container"">$\Phi=\sum_lK_l(\cdot)K_l^\dagger$</span>:
<span class=""math-container"">\begin{align*}
{\rm tr}(\Phi)&amp;=\sum_{j,k}\langle j|\Phi(|j\rangle\langle k|)|k\rangle\\
&amp;=\sum_{l,j,k}\langle j|K_l|j\rangle\langle k|K_l^\dagger|k\rangle\\
&amp;=\sum_l|{\rm tr}(K_l)|^2\geq 0
\end{align*}</span>
As an aside the trace of a channel also represents the mean operation fidelity (cf. Chapter 10.5 in <a href=""https://doi.org/10.1017/CBO9780511535048"" rel=""nofollow noreferrer"">Bengtsson &amp; Zyczkowski's book &quot;Geometry of Quantum States&quot;</a> / <a href=""https://chaos.if.uj.edu.pl/%7Ekarol/pdf/BZ06CUP.pdf"" rel=""nofollow noreferrer"">alt link</a>)
and it can be recovered as an expectation value via <span class=""math-container"">${\rm tr}(\Phi)=\langle \eta|\mathsf C(\Phi)|\eta\rangle$</span> where <span class=""math-container"">$|\eta\rangle:=\sum_j|j\rangle\otimes|j\rangle$</span> is the (unnormalized) maximally entangled state and <span class=""math-container"">$\mathsf C(\Phi)$</span> is the (unnormalized) Choi matrix of <span class=""math-container"">$\Phi$</span>, cf. Lemma 2 in <a href=""https://doi.org/10.48550/arXiv.2310.04037"" rel=""nofollow noreferrer"">this paper</a> for a slightly more general statement. However, this proof technique doesn't really help us as it does not generalize to arbitrary positive maps.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",Is the trace of a positive map always positive?,<quantum-operation><kraus-representation>,1,2,,,"Is the trace of a positive map always positive? <p>Obviously, positive semi-definite operators always admit a positive trace as <span class=""math-container"">${\rm tr}(A)=\|A\|_1\geq 0$</span> whenever <span class=""math-container"">$A\geq 0$</span>. This motivates the following &quot;lifted&quot; question:</p>
<blockquote>
<p>Given any positive, linear map <span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> is it true that <span class=""math-container"">${\rm tr}(\Phi)\geq 0$</span>?</p>
</blockquote>
<p>For this recall that the trace of a linear map <span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> is defined to be <span class=""math-container"">${\rm tr}(\Phi)=\sum_j{\rm tr}(G_j^\dagger\Phi(G_j))$</span> where <span class=""math-container"">$\{G_j\}_j$</span> is any orthonormal basis of <span class=""math-container"">$\mathbb C^{n\times n}$</span> (equipped with the <a href=""https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator#Space_of_Hilbert%E2%80%93Schmidt_operators"" rel=""nofollow noreferrer"">Hilbert-Schmidt inner product</a>). As an example one could choose the standard/computational basis <span class=""math-container"">$\{|j\rangle\langle k|\}_{j,k}$</span> and obtain the explicit expression <span class=""math-container"">${\rm tr}(\Phi)=\sum_{j,k}\langle j|\Phi(|j\rangle\langle k|)|k\rangle$</span>. Equivalently, the trace of <span class=""math-container"">$\Phi$</span> is of course equal to the trace of any matrix representation of <span class=""math-container"">$\Phi$</span>—such as the <a href=""https://quantumcomputing.stackexchange.com/a/37795"">natural representation</a> or the <a href=""https://quantumcomputing.stackexchange.com/q/38099"">Pauli transfer matrix</a>—and the trace is also equal to the <a href=""https://math.stackexchange.com/q/546155"">sum of all eigenvalues</a> of <span class=""math-container"">$\Phi$</span>.
To give an example the transposition map <span class=""math-container"">$T$</span>—the <a href=""https://quantumcomputing.stackexchange.com/a/38013"">prime example of a positive but not completely positive map</a>—has trace zero which is in agreement with the above question.</p>
<p>For the special case where <span class=""math-container"">$\Phi$</span> is completely positive the above statement holds <a href=""https://quantumcomputing.stackexchange.com/q/33684"">as a consequence of</a> the <a href=""https://quantumcomputing.stackexchange.com/a/5816"">Kraus representation</a> <span class=""math-container"">$\Phi=\sum_lK_l(\cdot)K_l^\dagger$</span>:
<span class=""math-container"">\begin{align*}
{\rm tr}(\Phi)&amp;=\sum_{j,k}\langle j|\Phi(|j\rangle\langle k|)|k\rangle\\
&amp;=\sum_{l,j,k}\langle j|K_l|j\rangle\langle k|K_l^\dagger|k\rangle\\
&amp;=\sum_l|{\rm tr}(K_l)|^2\geq 0
\end{align*}</span>
As an aside the trace of a channel also represents the mean operation fidelity (cf. Chapter 10.5 in <a href=""https://doi.org/10.1017/CBO9780511535048"" rel=""nofollow noreferrer"">Bengtsson &amp; Zyczkowski's book &quot;Geometry of Quantum States&quot;</a> / <a href=""https://chaos.if.uj.edu.pl/%7Ekarol/pdf/BZ06CUP.pdf"" rel=""nofollow noreferrer"">alt link</a>)
and it can be recovered as an expectation value via <span class=""math-container"">${\rm tr}(\Phi)=\langle \eta|\mathsf C(\Phi)|\eta\rangle$</span> where <span class=""math-container"">$|\eta\rangle:=\sum_j|j\rangle\otimes|j\rangle$</span> is the (unnormalized) maximally entangled state and <span class=""math-container"">$\mathsf C(\Phi)$</span> is the (unnormalized) Choi matrix of <span class=""math-container"">$\Phi$</span>, cf. Lemma 2 in <a href=""https://doi.org/10.48550/arXiv.2310.04037"" rel=""nofollow noreferrer"">this paper</a> for a slightly more general statement. However, this proof technique doesn't really help us as it does not generalize to arbitrary positive maps.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",qc,trace positive map always positive p obviously positive operators always admit positive trace span tr 0 whenever span 0 motivates following quot lifted quot question blockquote p given positive linear map span n n true span tr 0 p recall trace linear map span n n defined span tr tr span orthonormal basis span n equipped https e2 80 e2 80 nofollow noreferrer inner product example one could choose basis span j k obtain explicit expression span tr j k equivalently trace span course equal trace matrix representation span https natural representation https pauli transfer matrix trace also equal https sum eigenvalues span give example transposition map span https prime example positive completely positive map trace zero agreement p special case span completely positive statement holds https consequence https kraus representation span span align tr amp j k amp l j k amp tr 0 align aside trace channel also represents mean operation fidelity cf chapter https nofollow noreferrer bengtsson amp zyczkowski book quot geometry quantum states quot https nofollow noreferrer alt link recovered expectation value via span tr c span unnormalized maximally entangled state span c unnormalized choi matrix span cf lemma 2 https nofollow noreferrer paper slightly general statement however proof technique really help us generalize arbitrary positive hr p em q amp style question meant contribution https list counterexamples quantum information,"[(2, 0.01652023), (3, 0.6581537), (4, 0.098164536), (11, 0.12565902), (12, 0.02210131), (15, 0.04812795), (19, 0.02085916)]"
38093,38094.0,2024-05-02 01:39:54,3,467,"<p>I am trying to run below code in PyCharm:</p>
<pre><code>from qiskit.circuit.library import MCXGate, HGate 
from qiskit import QuantumCircuit

circuit = QuantumCircuit(4)

circuit.append(HGate(), [0]) 
circuit.append(MCXGate(3), [0,1,2,3])

circuit.draw('mpl')
</code></pre>
<p>But I don't see any output circuit. The plot window flashes for a bit but it immediately closes itself. If I use inline figures then I can get the circuit diagram but I want the interactive version. Can someone please help me with this issue. I have always used PyCharm for my other projects so I don't really want to change to another IDE.</p>
",Quantum circuit not showing when using qiskit with pycharm,<qiskit><programming>,1,0,,,"Quantum circuit not showing when using qiskit with pycharm <p>I am trying to run below code in PyCharm:</p>
<pre><code>from qiskit.circuit.library import MCXGate, HGate 
from qiskit import QuantumCircuit

circuit = QuantumCircuit(4)

circuit.append(HGate(), [0]) 
circuit.append(MCXGate(3), [0,1,2,3])

circuit.draw('mpl')
</code></pre>
<p>But I don't see any output circuit. The plot window flashes for a bit but it immediately closes itself. If I use inline figures then I can get the circuit diagram but I want the interactive version. Can someone please help me with this issue. I have always used PyCharm for my other projects so I don't really want to change to another IDE.</p>
",qc,quantum circuit showing using qiskit pycharm p trying run code pycharm pre code import mcxgate hgate qiskit import quantumcircuit circuit quantumcircuit 4 hgate 0 mcxgate 3 p see output circuit plot window flashes bit immediately closes use inline figures get circuit diagram want interactive version someone please help issue always used pycharm projects really want change another,"[(0, 0.19386865), (2, 0.030434672), (4, 0.12833266), (12, 0.17601676), (13, 0.04768868), (14, 0.42120534)]"
38099,38100.0,2024-05-02 12:01:51,1,99,"<p>In order to properly state the question let me be precise about the object at the core of this question's title.
First, given any orthonormal basis of <span class=""math-container"">$G:=\{G_j\}_{j=1}^{n^2}$</span> of <span class=""math-container"">$\mathbb C^{n\times n}$</span> (equipped with the <a href=""https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator#Space_of_Hilbert%E2%80%93Schmidt_operators"" rel=""nofollow noreferrer"">Hilbert-Schmidt inner product</a>) the corresponding matrix representation of a linear map <span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> with respect to <span class=""math-container"">$G$</span> is given by <span class=""math-container"">$$\sum_{j,k=1}^{n^2}{\rm tr}(G_j^\dagger\Phi(G_k))|j\rangle\langle k|\in\mathbb C^{n^2\times n^2}\,.$$</span>
Important special cases for this are the <a href=""https://quantumcomputing.stackexchange.com/a/37795"">natural representation</a> <span class=""math-container"">$K(\Phi)$</span> or <span class=""math-container"">$\widehat\Phi$</span>—which comes from choosing <span class=""math-container"">$G$</span> to be the computational basis <span class=""math-container"">$\{|j\rangle\langle k|\}_{j,k=1}^n$</span>—or, in case <span class=""math-container"">$n=2^d$</span> for some <span class=""math-container"">$d$</span>, the <a href=""https://quantumcomputing.stackexchange.com/q/30045"">Pauli transfer matrix</a> <span class=""math-container"">$\mathcal P(\Phi)$</span>—for which one chooses <span class=""math-container"">$G$</span> to be all elementary tensor products of single Paulis <span class=""math-container"">$\frac1{\sqrt2}\sigma_j$</span>, <span class=""math-container"">$j=0,\ldots,3$</span> (where <span class=""math-container"">$\sigma_0={\bf1}$</span>).</p>
<p>Of course this concept makes sense for linear maps between matrices of any size but for the sake of this question we restrict ourselves to the simplest case of one qubit, i.e. <span class=""math-container"">$n=2$</span>. In this case it is easy to see that if <span class=""math-container"">$\Phi$</span> is Hermitian preserving (i.e. <span class=""math-container"">$\Phi(X^\dagger)=\Phi(X)^\dagger$</span> for all <span class=""math-container"">$X$</span>) and trace preserving, then there exists <span class=""math-container"">$v\in\mathbb R^3$</span> and <span class=""math-container"">$\Lambda\in\mathbb R^{3\times 3}$</span> such that
<span class=""math-container"">$$
\mathcal P(\Phi)=\begin{pmatrix}1&amp;0\\v&amp;\Lambda\end{pmatrix}\,.
$$</span>
While, at this stage, the question of uniqueness does not really make sense yet it will once we ge to the so-called normal form. For this observe that the Pauli transfer matrix of a unitary channel <span class=""math-container"">$X\mapsto UXU^\dagger$</span> is of the block-diagonal form <span class=""math-container"">${\rm diag}(1,R)$</span> with <span class=""math-container"">$R\in\mathsf{SO}(3)$</span>. In fact, this gives rise to an isomorphism between the group <span class=""math-container"">${\rm Ad}_{\mathsf{SU}(2)}$</span> and <span class=""math-container"">$\mathsf{SO}(3)$</span> (cf. Appendix B in <a href=""https://doi.org/10.1103/PhysRevA.52.4396"" rel=""nofollow noreferrer"">J. Schlienz and G. Mahler, Description of Entanglement, Phys. Rev. A, 52 (1995)</a>), that is, for every <span class=""math-container"">$R\in\mathsf{SO}(3)$</span> there even exists (basically unique) <span class=""math-container"">$U\in\mathsf{SU}(2)$</span> such that <span class=""math-container"">$\mathcal P(U(\cdot)U^\dagger)={\rm diag}(1,R)$</span>. This gives rise to the</p>
<blockquote>
<p><strong>Normal form.</strong> For every linear, Hermitian-preserving, and trace-preserving map <span class=""math-container"">$\Phi:\mathbb C^{2\times 2}\to\mathbb C^{2\times 2}$</span> there exist <span class=""math-container"">$U,V\in\mathsf{SU}(2)$</span> and <span class=""math-container"">$v,\lambda\in\mathbb R^3$</span> with <span class=""math-container"">$v_1,v_2\geq 0$</span> and <span class=""math-container"">$\lambda_1\geq\lambda_2\geq|\lambda_3|$</span> such that
<span class=""math-container"">$$
\mathcal P(V^\dagger\Phi(U(\cdot)U^\dagger)V)=\begin{pmatrix}1&amp;0&amp;0&amp;0\\v_1&amp;\lambda_1&amp;0&amp;0\\v_2&amp;0&amp;\lambda_2&amp;0\\v_3&amp;0&amp;0&amp;\lambda_3\end{pmatrix}\,,\tag{1}
$$</span></p>
</blockquote>
<p>cf., e.g., <a href=""https://doi.org/10.48550/arXiv.quant-ph/0202124"" rel=""nofollow noreferrer"">F. Verstraete and H. Verschelde, On Quantum Channels, 2002</a> and <a href=""https://doi.org/10.1007/s00220-008-0411-y"" rel=""nofollow noreferrer"">M. Wolf and J. Cirac, Dividing Quantum Channels, Commun. Math. Phys., 279 (2008)</a> <a href=""https://doi.org/10.48550/arXiv.math-ph/0611057"" rel=""nofollow noreferrer"">(arXiv)</a>. This raises the following</p>
<blockquote>
<p><strong>Question:</strong> Is this normal form unique, that is, given some <span class=""math-container"">$\Phi$</span> as well as two pairs <span class=""math-container"">$(v^1,\lambda^1), (v^2,\lambda^2)$</span> which both satisfy the previously stated constraints and which both constitute a normal form (1) of <span class=""math-container"">$\Phi$</span> does this imply <span class=""math-container"">$v^1=v^2$</span>, <span class=""math-container"">$\lambda^1=\lambda^2$</span>?</p>
</blockquote>
<p>What is easy to see is that <span class=""math-container"">$\lambda^1=\lambda^2$</span> as they are (basically) the singular values of <span class=""math-container"">$\Lambda$</span>. However, it is not immediately clear whether the <span class=""math-container"">$v^j$</span> admit an additional degree of freedom. While the previously quoted paper of Verstraete &amp; Verschelde claims uniqueness (p.9 therein) they do not give a proof which is what motivated this question.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",To what extent is the normal form of the Pauli transfer matrix unique?,<linear-algebra><quantum-operation>,1,0,,,"To what extent is the normal form of the Pauli transfer matrix unique? <p>In order to properly state the question let me be precise about the object at the core of this question's title.
First, given any orthonormal basis of <span class=""math-container"">$G:=\{G_j\}_{j=1}^{n^2}$</span> of <span class=""math-container"">$\mathbb C^{n\times n}$</span> (equipped with the <a href=""https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator#Space_of_Hilbert%E2%80%93Schmidt_operators"" rel=""nofollow noreferrer"">Hilbert-Schmidt inner product</a>) the corresponding matrix representation of a linear map <span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> with respect to <span class=""math-container"">$G$</span> is given by <span class=""math-container"">$$\sum_{j,k=1}^{n^2}{\rm tr}(G_j^\dagger\Phi(G_k))|j\rangle\langle k|\in\mathbb C^{n^2\times n^2}\,.$$</span>
Important special cases for this are the <a href=""https://quantumcomputing.stackexchange.com/a/37795"">natural representation</a> <span class=""math-container"">$K(\Phi)$</span> or <span class=""math-container"">$\widehat\Phi$</span>—which comes from choosing <span class=""math-container"">$G$</span> to be the computational basis <span class=""math-container"">$\{|j\rangle\langle k|\}_{j,k=1}^n$</span>—or, in case <span class=""math-container"">$n=2^d$</span> for some <span class=""math-container"">$d$</span>, the <a href=""https://quantumcomputing.stackexchange.com/q/30045"">Pauli transfer matrix</a> <span class=""math-container"">$\mathcal P(\Phi)$</span>—for which one chooses <span class=""math-container"">$G$</span> to be all elementary tensor products of single Paulis <span class=""math-container"">$\frac1{\sqrt2}\sigma_j$</span>, <span class=""math-container"">$j=0,\ldots,3$</span> (where <span class=""math-container"">$\sigma_0={\bf1}$</span>).</p>
<p>Of course this concept makes sense for linear maps between matrices of any size but for the sake of this question we restrict ourselves to the simplest case of one qubit, i.e. <span class=""math-container"">$n=2$</span>. In this case it is easy to see that if <span class=""math-container"">$\Phi$</span> is Hermitian preserving (i.e. <span class=""math-container"">$\Phi(X^\dagger)=\Phi(X)^\dagger$</span> for all <span class=""math-container"">$X$</span>) and trace preserving, then there exists <span class=""math-container"">$v\in\mathbb R^3$</span> and <span class=""math-container"">$\Lambda\in\mathbb R^{3\times 3}$</span> such that
<span class=""math-container"">$$
\mathcal P(\Phi)=\begin{pmatrix}1&amp;0\\v&amp;\Lambda\end{pmatrix}\,.
$$</span>
While, at this stage, the question of uniqueness does not really make sense yet it will once we ge to the so-called normal form. For this observe that the Pauli transfer matrix of a unitary channel <span class=""math-container"">$X\mapsto UXU^\dagger$</span> is of the block-diagonal form <span class=""math-container"">${\rm diag}(1,R)$</span> with <span class=""math-container"">$R\in\mathsf{SO}(3)$</span>. In fact, this gives rise to an isomorphism between the group <span class=""math-container"">${\rm Ad}_{\mathsf{SU}(2)}$</span> and <span class=""math-container"">$\mathsf{SO}(3)$</span> (cf. Appendix B in <a href=""https://doi.org/10.1103/PhysRevA.52.4396"" rel=""nofollow noreferrer"">J. Schlienz and G. Mahler, Description of Entanglement, Phys. Rev. A, 52 (1995)</a>), that is, for every <span class=""math-container"">$R\in\mathsf{SO}(3)$</span> there even exists (basically unique) <span class=""math-container"">$U\in\mathsf{SU}(2)$</span> such that <span class=""math-container"">$\mathcal P(U(\cdot)U^\dagger)={\rm diag}(1,R)$</span>. This gives rise to the</p>
<blockquote>
<p><strong>Normal form.</strong> For every linear, Hermitian-preserving, and trace-preserving map <span class=""math-container"">$\Phi:\mathbb C^{2\times 2}\to\mathbb C^{2\times 2}$</span> there exist <span class=""math-container"">$U,V\in\mathsf{SU}(2)$</span> and <span class=""math-container"">$v,\lambda\in\mathbb R^3$</span> with <span class=""math-container"">$v_1,v_2\geq 0$</span> and <span class=""math-container"">$\lambda_1\geq\lambda_2\geq|\lambda_3|$</span> such that
<span class=""math-container"">$$
\mathcal P(V^\dagger\Phi(U(\cdot)U^\dagger)V)=\begin{pmatrix}1&amp;0&amp;0&amp;0\\v_1&amp;\lambda_1&amp;0&amp;0\\v_2&amp;0&amp;\lambda_2&amp;0\\v_3&amp;0&amp;0&amp;\lambda_3\end{pmatrix}\,,\tag{1}
$$</span></p>
</blockquote>
<p>cf., e.g., <a href=""https://doi.org/10.48550/arXiv.quant-ph/0202124"" rel=""nofollow noreferrer"">F. Verstraete and H. Verschelde, On Quantum Channels, 2002</a> and <a href=""https://doi.org/10.1007/s00220-008-0411-y"" rel=""nofollow noreferrer"">M. Wolf and J. Cirac, Dividing Quantum Channels, Commun. Math. Phys., 279 (2008)</a> <a href=""https://doi.org/10.48550/arXiv.math-ph/0611057"" rel=""nofollow noreferrer"">(arXiv)</a>. This raises the following</p>
<blockquote>
<p><strong>Question:</strong> Is this normal form unique, that is, given some <span class=""math-container"">$\Phi$</span> as well as two pairs <span class=""math-container"">$(v^1,\lambda^1), (v^2,\lambda^2)$</span> which both satisfy the previously stated constraints and which both constitute a normal form (1) of <span class=""math-container"">$\Phi$</span> does this imply <span class=""math-container"">$v^1=v^2$</span>, <span class=""math-container"">$\lambda^1=\lambda^2$</span>?</p>
</blockquote>
<p>What is easy to see is that <span class=""math-container"">$\lambda^1=\lambda^2$</span> as they are (basically) the singular values of <span class=""math-container"">$\Lambda$</span>. However, it is not immediately clear whether the <span class=""math-container"">$v^j$</span> admit an additional degree of freedom. While the previously quoted paper of Verstraete &amp; Verschelde claims uniqueness (p.9 therein) they do not give a proof which is what motivated this question.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",qc,extent normal form pauli transfer matrix unique p order properly state question let precise object core question title first given orthonormal basis span g span n equipped https e2 80 e2 80 nofollow noreferrer inner product corresponding matrix representation linear map span n n respect span g given span j tr important special cases https natural representation span k span comes choosing span g computational basis span j case span span https pauli transfer matrix span p one chooses span g elementary tensor products single paulis span span span p course concept makes sense linear maps matrices size sake question restrict simplest case one qubit span case easy see span hermitian preserving span x span x trace preserving exists span span 3 span p pmatrix 1 amp amp pmatrix stage question uniqueness really make sense yet ge normal form observe pauli transfer matrix unitary channel span form span diag 1 r span 3 fact gives rise isomorphism group span ad su 2 span 3 cf appendix b https nofollow noreferrer j schlienz mahler description entanglement phys rev 52 1995 every span 3 even exists basically unique span su 2 span p u diag 1 r gives rise blockquote p strong normal every linear map span 2 2 exist span u su 2 span v span 0 span span p u v pmatrix 1 amp 0 amp 0 amp amp amp 0 amp amp 0 amp amp amp 0 amp 0 amp pmatrix 1 p https nofollow noreferrer f verstraete verschelde quantum channels 2002 https nofollow noreferrer wolf cirac dividing quantum channels commun math 279 2008 https nofollow noreferrer arxiv raises following blockquote p strong question normal form unique given span well two pairs span satisfy previously stated constraints constitute normal form 1 span imply span span p easy see span basically singular values span however immediately clear whether span admit additional degree freedom previously quoted paper verstraete amp verschelde claims uniqueness therein give proof motivated hr p em q amp style question meant contribution https list counterexamples quantum information,"[(2, 0.05064959), (3, 0.6680565), (4, 0.056012847), (9, 0.070909806), (10, 0.012586715), (11, 0.03623501), (12, 0.012338528), (15, 0.08991614)]"
38154,38157.0,2024-05-05 21:08:49,5,611,"<p>I found many circuits for the Shor algorithm for N=15, but i don't understand how to read the result 3 or 5.
Where can i find the result e.g. <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22%5D,%5B1,1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,1,%22X%5E%C2%BD%22,1,%22%E2%80%A2%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22X%5E%C2%BD%22,1,%22%E2%80%A2%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,%22X%5E%C2%BD%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,1,1,%22X%22,1,%22%E2%80%A2%22%5D,%5B1,1,1,1,%22%E2%80%A2%22,1,%22X%5E%C2%BD%22%5D,%5B1,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,1,1,1,%22%E2%80%A2%22,1,%22X%5E%C2%BD%22%5D,%5B1,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,1,%22X%5E%C2%BD%22%5D,%5B1,1,1,1,%22X%22,1,%22%E2%80%A2%22%5D,%5B%22H%22%5D,%5B%22%E2%80%A2%22,%22Z%5E%C2%BD%22%5D,%5B1,%22H%22%5D,%5B%22%E2%80%A2%22,1,%22Z%5E%C2%BC%22%5D,%5B1,%22%E2%80%A2%22,%22Z%5E%C2%BD%22%5D,%5B1,1,%22H%22%5D%5D,%22init%22:%5B0,0,0,0,0,0,1%5D%7D"" rel=""noreferrer"">for this circuit</a>
I found it <a href=""https://www.researchgate.net/publication/327882177_Expected_Optimal_Time_for_the_NMR_Implementation_of_Shor%27s_Algorithm_for_Factorising_15"" rel=""noreferrer"">here</a></p>
",How to read the result of quantum shor circuit for N=15,<quantum-algorithms><shors-algorithm><quirk>,1,0,,,"How to read the result of quantum shor circuit for N=15 <p>I found many circuits for the Shor algorithm for N=15, but i don't understand how to read the result 3 or 5.
Where can i find the result e.g. <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22%5D,%5B1,1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,1,%22X%5E%C2%BD%22,1,%22%E2%80%A2%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22X%5E%C2%BD%22,1,%22%E2%80%A2%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,%22X%5E%C2%BD%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,%22X%22%5D,%5B1,1,1,1,%22X%22,1,%22%E2%80%A2%22%5D,%5B1,1,1,1,%22%E2%80%A2%22,1,%22X%5E%C2%BD%22%5D,%5B1,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,1,1,1,%22%E2%80%A2%22,1,%22X%5E%C2%BD%22%5D,%5B1,%22%E2%80%A2%22,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,1,%22X%5E%C2%BD%22%5D,%5B1,1,1,1,%22X%22,1,%22%E2%80%A2%22%5D,%5B%22H%22%5D,%5B%22%E2%80%A2%22,%22Z%5E%C2%BD%22%5D,%5B1,%22H%22%5D,%5B%22%E2%80%A2%22,1,%22Z%5E%C2%BC%22%5D,%5B1,%22%E2%80%A2%22,%22Z%5E%C2%BD%22%5D,%5B1,1,%22H%22%5D%5D,%22init%22:%5B0,0,0,0,0,0,1%5D%7D"" rel=""noreferrer"">for this circuit</a>
I found it <a href=""https://www.researchgate.net/publication/327882177_Expected_Optimal_Time_for_the_NMR_Implementation_of_Shor%27s_Algorithm_for_Factorising_15"" rel=""noreferrer"">here</a></p>
",qc,read result quantum shor circuit p found many circuits shor algorithm understand read result 3 find result https 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 5d 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 22x 5e c2 bd 22 e2 80 a2 22 5d 5b1 22 e2 80 a2 22x 22 5d 22x 5e c2 bd 22 e2 80 a2 22 5d 5b1 22 e2 80 a2 22x 22 5d 5b1 22 e2 80 a2 22x 5e c2 bd 22 5d 22 e2 80 a2 22x 22 5d 22x 22 e2 80 a2 22 5d 22 e2 80 a2 22x 5e c2 bd 22 5d 5b1 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 5e c2 bd 22 5d 5b1 22 e2 80 a2 22x 22 5d 5b1 22 e2 80 a2 22x 5e c2 bd 22 5d 22x 22 e2 80 a2 22 5d 5b 22h 22 5d 5b 22 e2 80 a2 22 22z 5e c2 bd 22 5d 5b1 22h 22 5d 5b 22 e2 80 a2 22z 5e c2 bc 22 5d 5b1 22 e2 80 a2 22 22z 5e c2 bd 22 5d 22h 22 5d 5d 22init 22 5d 7d noreferrer circuit found https noreferrer,"[(4, 0.044259086), (7, 0.041065935), (12, 0.9139064)]"
78449203,78449252.0,2024-05-08 14:16:45,1,259,"<p>I am trying to run BB84 protocol code on latest Qiskit version 1.0.2 and getting this error.</p>
<blockquote>
<p>ModuleNotFoundError: No module named 'qiskit.monitor'</p>
</blockquote>
<pre class=""lang-py prettyprint-override""><code>from qiskit import *
import numpy as np
from qiskit.visualization import plot_histogram
from qiskit.monitor import job_monitor
%matplotlib inline
from tabulate import tabulate
</code></pre>
",ModuleNotFoundError: No module named 'qiskit.monitor',<python><jupyter><quantum-computing><qiskit>,1,1,,,"ModuleNotFoundError: No module named 'qiskit.monitor' <p>I am trying to run BB84 protocol code on latest Qiskit version 1.0.2 and getting this error.</p>
<blockquote>
<p>ModuleNotFoundError: No module named 'qiskit.monitor'</p>
</blockquote>
<pre class=""lang-py prettyprint-override""><code>from qiskit import *
import numpy as np
from qiskit.visualization import plot_histogram
from qiskit.monitor import job_monitor
%matplotlib inline
from tabulate import tabulate
</code></pre>
",so_new,modulenotfounderror module named p trying run bb84 protocol code latest qiskit version getting blockquote p modulenotfounderror module named pre code qiskit import import numpy np import import matplotlib inline tabulate import tabulate,"[(0, 0.76980865), (4, 0.09199142), (12, 0.06219118), (18, 0.07103362)]"
38229,,2024-05-09 17:56:00,1,44,"<p>I am trying to implement the method in the following paper: <a href=""https://arxiv.org/abs/2303.13012"" rel=""nofollow noreferrer"">Exponential Quantum Speedup in Simulating Coupled Classical Oscillators</a> using Qiskit.</p>
<p>All is good until I call evolve on <code>TrotterQRTE</code>. It is expecting a <code>(Sparse)PauliOp</code> but I want top use an <code>Operator</code> as this can be created from a matrix much more generically.</p>
<p>Is there a way to convert an <code>Operator</code> to a <code>(Sparse)PauliOp</code>, or use <code>TrotterQRTE</code> in a different way?</p>
<p>For simplicity I am currently using the following Hamiltonian:
<span class=""math-container"">$$
\mathcal{H}=
\begin{pmatrix}
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}
$$</span>
But it is not necessarily this simple.</p>
",Qiskit: Evolve TrotterQRTE from Operator,<qiskit><programming><hamiltonian-simulation><trotterization>,1,0,,,"Qiskit: Evolve TrotterQRTE from Operator <p>I am trying to implement the method in the following paper: <a href=""https://arxiv.org/abs/2303.13012"" rel=""nofollow noreferrer"">Exponential Quantum Speedup in Simulating Coupled Classical Oscillators</a> using Qiskit.</p>
<p>All is good until I call evolve on <code>TrotterQRTE</code>. It is expecting a <code>(Sparse)PauliOp</code> but I want top use an <code>Operator</code> as this can be created from a matrix much more generically.</p>
<p>Is there a way to convert an <code>Operator</code> to a <code>(Sparse)PauliOp</code>, or use <code>TrotterQRTE</code> in a different way?</p>
<p>For simplicity I am currently using the following Hamiltonian:
<span class=""math-container"">$$
\mathcal{H}=
\begin{pmatrix}
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0
\end{pmatrix}
$$</span>
But it is not necessarily this simple.</p>
",qc,qiskit evolve trotterqrte operator p trying implement method following paper https nofollow noreferrer exponential quantum speedup simulating coupled classical oscillators using p good call evolve code trotterqrte expecting code sparse pauliop want top use code operator created matrix much p way convert code operator code sparse pauliop use code trotterqrte different way p simplicity currently using following hamiltonian span h pmatrix 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 amp 0 amp 1 amp 0 amp 0 pmatrix necessarily,"[(1, 0.056559853), (2, 0.14072627), (3, 0.0623519), (4, 0.05097412), (7, 0.065770574), (9, 0.046068955), (12, 0.023170738), (14, 0.25896844), (15, 0.24400537), (19, 0.050268516)]"
38249,38253.0,2024-05-11 19:09:34,0,193,"<p>After upgrading to qiskit 1.0.0, I tried using different estimators: estimatorv2, qiskit-aer estimator and default primitive estimator. But I get different expectation values with each of them?  Am I doing something wrong? Below is the code that I am using.</p>
<pre><code>import numpy as np
from qiskit.circuit.library import TwoLocal
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import Estimator as AerEstimator
from qiskit_ibm_runtime import EstimatorV2

seed = 20
n_qubits = 2

obs = SparsePauliOp(['ZY', 'YI', 'IY', 'II', 'YY', 'ZY', 'XI', 'YZ', 'ZZ', 'IX'],
              coeffs=[0.64414354+0.j, 0.38074849+0.j, 0.66304791+0.j, 0.16365073+0.j,
 0.96260781+0.j, 0.34666184+0.j, 0.99175099+0.j, 0.2350579 +0.j,
 0.58569427+0.j, 0.4066901 +0.j])

# Ansatz
circuit = TwoLocal(
    n_qubits,
    [&quot;rx&quot;, &quot;ry&quot;, &quot;rz&quot;],
    [&quot;cx&quot;],
    &quot;linear&quot;,
    reps=3,
)

params = np.random.uniform(low=0, high=2 * np.pi, size=circuit.num_parameters)

# Estimator V2
aer_sim = AerSimulator(method=&quot;automatic&quot;)

pm = generate_preset_pass_manager(backend=aer_sim, optimization_level=1)
isa_qc = pm.run(circuit)
est = EstimatorV2(backend=aer_sim)
pub = (isa_qc, obs, params)
result = est.run([pub]).result()
print(f&quot;Expectation value from Estimatorv2: {result[0].data.evs}&quot;)

# Aer Estimator
est = AerEstimator(run_options={&quot;seed&quot;: seed}, approximation=False)
result = est.run([isa_qc], [obs], [params]).result()
print(f&quot;Expectation value from AerEstimator: {result.values[0]}&quot;)

# Primitive Estimator
est = Estimator(options={&quot;seed&quot;: seed})
result = est.run([isa_qc], [obs], [params]).result()
print(f&quot;Expectation value from qiskit.primitve Estimator: {result.values[0]}&quot;)
</code></pre>
<p>This gives me different result:</p>
<pre><code>Expectation value from Estimatorv2: 0.4890561498339845
Expectation value from AerEstimator: 0.40740949503906254
Expectation value from qiskit.primitve Estimator: 0.4549841069144796
</code></pre>
<p>I would expect all of them to be very close to each other.</p>
",Discrepancy between answers from different Estimators in qiskit,<qiskit><qiskit-runtime>,1,0,,,"Discrepancy between answers from different Estimators in qiskit <p>After upgrading to qiskit 1.0.0, I tried using different estimators: estimatorv2, qiskit-aer estimator and default primitive estimator. But I get different expectation values with each of them?  Am I doing something wrong? Below is the code that I am using.</p>
<pre><code>import numpy as np
from qiskit.circuit.library import TwoLocal
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import Estimator as AerEstimator
from qiskit_ibm_runtime import EstimatorV2

seed = 20
n_qubits = 2

obs = SparsePauliOp(['ZY', 'YI', 'IY', 'II', 'YY', 'ZY', 'XI', 'YZ', 'ZZ', 'IX'],
              coeffs=[0.64414354+0.j, 0.38074849+0.j, 0.66304791+0.j, 0.16365073+0.j,
 0.96260781+0.j, 0.34666184+0.j, 0.99175099+0.j, 0.2350579 +0.j,
 0.58569427+0.j, 0.4066901 +0.j])

# Ansatz
circuit = TwoLocal(
    n_qubits,
    [&quot;rx&quot;, &quot;ry&quot;, &quot;rz&quot;],
    [&quot;cx&quot;],
    &quot;linear&quot;,
    reps=3,
)

params = np.random.uniform(low=0, high=2 * np.pi, size=circuit.num_parameters)

# Estimator V2
aer_sim = AerSimulator(method=&quot;automatic&quot;)

pm = generate_preset_pass_manager(backend=aer_sim, optimization_level=1)
isa_qc = pm.run(circuit)
est = EstimatorV2(backend=aer_sim)
pub = (isa_qc, obs, params)
result = est.run([pub]).result()
print(f&quot;Expectation value from Estimatorv2: {result[0].data.evs}&quot;)

# Aer Estimator
est = AerEstimator(run_options={&quot;seed&quot;: seed}, approximation=False)
result = est.run([isa_qc], [obs], [params]).result()
print(f&quot;Expectation value from AerEstimator: {result.values[0]}&quot;)

# Primitive Estimator
est = Estimator(options={&quot;seed&quot;: seed})
result = est.run([isa_qc], [obs], [params]).result()
print(f&quot;Expectation value from qiskit.primitve Estimator: {result.values[0]}&quot;)
</code></pre>
<p>This gives me different result:</p>
<pre><code>Expectation value from Estimatorv2: 0.4890561498339845
Expectation value from AerEstimator: 0.40740949503906254
Expectation value from qiskit.primitve Estimator: 0.4549841069144796
</code></pre>
<p>I would expect all of them to be very close to each other.</p>
",qc,discrepancy answers different estimators qiskit p upgrading qiskit tried using different estimators estimatorv2 estimator default primitive estimator get different expectation values something wrong code pre code import numpy np import twolocal import estimator import sparsepauliop import import aersimulator import estimator aerestimator import estimatorv2 seed 20 2 obs sparsepauliop ansatz circuit twolocal quot rx quot quot ry quot quot rz quot quot cx quot quot linear quot params estimator v2 aersimulator quot automatic quot pm circuit est estimatorv2 pub obs params result pub print f quot expectation value estimatorv2 result 0 quot aer estimator est aerestimator quot seed quot seed result obs params print f quot expectation value aerestimator 0 quot primitive estimator est estimator quot seed quot seed result obs params print f quot expectation value estimator 0 quot p gives different result pre code expectation value estimatorv2 expectation value aerestimator expectation value estimator p would expect close,"[(0, 0.6727694), (6, 0.011273601), (9, 0.016967274), (12, 0.047858875), (19, 0.2501174)]"
38286,,2024-05-14 09:10:15,1,20,"<p>I'm reading this paper: On the construction of quantum circuits for
S-boxes with different criteria based on the SAT
solver. Here's the link: <a href=""https://eprint.iacr.org/2024/565.pdf#page=29&amp;zoom=100,133,636"" rel=""nofollow noreferrer"">https://eprint.iacr.org/2024/565.pdf#page=29&amp;zoom=100,133,636</a>
I understand how to encoded the problem. But how do we use this in a SAT Solver, for example, Z3 model. In other word, how can i write a program to actually solve this problem? Thank you.</p>
",On the construction of quantum circuits for S-boxes with different criteria based on the SAT solver,<quantum-gate><programming><cryptography>,0,0,,,"On the construction of quantum circuits for S-boxes with different criteria based on the SAT solver <p>I'm reading this paper: On the construction of quantum circuits for
S-boxes with different criteria based on the SAT
solver. Here's the link: <a href=""https://eprint.iacr.org/2024/565.pdf#page=29&amp;zoom=100,133,636"" rel=""nofollow noreferrer"">https://eprint.iacr.org/2024/565.pdf#page=29&amp;zoom=100,133,636</a>
I understand how to encoded the problem. But how do we use this in a SAT Solver, for example, Z3 model. In other word, how can i write a program to actually solve this problem? Thank you.</p>
",qc,construction quantum circuits different criteria based sat solver p reading paper construction quantum circuits different criteria based sat solver link https amp nofollow noreferrer https amp understand encoded problem use sat solver example z3 model word write program actually solve problem thank,"[(1, 0.13476068), (4, 0.09871061), (12, 0.024046), (13, 0.6115289), (14, 0.0748267), (15, 0.052807994)]"
38327,,2024-05-16 06:09:33,0,56,"<p>I solved &quot;01 KnapSack problem&quot; in Qiskit optimization module. Though the iterations doesn't gets converged but I got an answer (may be infeasible). But my question is that how to interpret the given result because my problem has 10 variable but the result it shows has only 4 variable and an improper vaule of objective function.</p>
<p>This is the code - <a href=""https://github.com/imAshish28/Quantum_OR/blob/main/Untitled24.ipynb"" rel=""nofollow noreferrer"">https://github.com/imAshish28/Quantum_OR/blob/main/Untitled24.ipynb</a></p>
<pre><code>filename = 'binary_knapsack_10.lp'
qp = QuadraticProgram()
qp.read_from_lp_file(filename)
print(qp.prettyprint())
</code></pre>
<p>'''
Problem name: binary_knapsack_10</p>
<p>Minimize
-135<em>x_0 - 42</em>x_1 - 677<em>x_2 - 773</em>x_3 - 333<em>x_4 - 24</em>x_5 - 819<em>x_6 - 184</em>x_7</p>
<ul>
<li>683<em>x_8 - 895</em>x_9</li>
</ul>
<p>Subject to
Linear constraints (1)
291<em>x_0 + 80</em>x_1 + 76<em>x_2 + 111</em>x_3 + 687<em>x_4 + 87</em>x_5 + 567<em>x_6 + 969</em>x_7
+ 967<em>x_8 + 392</em>x_9 &lt;= 2114  'capacity'</p>
<p>Binary variables (10)
x_0 x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9
'''</p>
<pre><code>from qiskit_optimization.converters import QuadraticProgramToQubo

qp2qubo = QuadraticProgramToQubo()
qubo = qp2qubo.convert(qp)
qubitOp, offset = qubo.to_ising()
print(&quot;Offset:&quot;, offset)
print(&quot;Ising Hamiltonian:&quot;)
print(str(qubitOp))

from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Options, Session

# loading the IBM Acoount with the Backend
QiskitRuntimeService.save_account(channel=&quot;ibm_quantum&quot;, token=&quot;API TOKEN&quot;,overwrite=True)
service = QiskitRuntimeService(channel='ibm_quantum')
backend = service.least_busy(operational=True, simulator=False)

from qiskit.circuit.library import QAOAAnsatz
hamiltonian = qubitOp
# QAOA ansatz circuit
ansatz = QAOAAnsatz(hamiltonian, reps=2)

from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)
ansatz_isa = pm.run(ansatz)

hamiltonian_isa = hamiltonian.apply_layout(ansatz_isa.layout)
hamiltonian_isa

def cost_func(params, ansatz, hamiltonian, estimator):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters
        ansatz (QuantumCircuit): Parameterized ansatz circuit
        hamiltonian (SparsePauliOp): Operator representation of Hamiltonian
        estimator (Estimator): Estimator primitive instance

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    energy = estimator.run(ansatz, hamiltonian, parameter_values=params).result().values[0]
    return energy

session = Session(backend=backend)

# Configure estimator
estimator = Estimator(session=session)
estimator.options.default_shots = 100


# Configure sampler
sampler = Sampler(session=session)
sampler.options.default_shots = 100


x0 = 2 * np.pi * np.random.rand(ansatz_isa.num_parameters)

from scipy.optimize import minimize
res = minimize(cost_func, x0, args=(ansatz_isa, hamiltonian_isa, estimator), method=&quot;COBYLA&quot; , options= {'maxiter' : 5})
res
</code></pre>
<p>'''
And this is the result which I get:
message: Maximum number of function evaluations has been exceeded.
success: False
status: 2
fun: -464074414.1873996
x: [ 1.743e+00  3.937e+00  3.707e+00  4.516e+00]
nfev: 5
maxcv: 0.0
'''</p>
",How to interpret result for an OR problem solved in Qiskit,<quantum-gate><quantum-operation><optimization><qaoa><qiskit-runtime>,0,6,,,"How to interpret result for an OR problem solved in Qiskit <p>I solved &quot;01 KnapSack problem&quot; in Qiskit optimization module. Though the iterations doesn't gets converged but I got an answer (may be infeasible). But my question is that how to interpret the given result because my problem has 10 variable but the result it shows has only 4 variable and an improper vaule of objective function.</p>
<p>This is the code - <a href=""https://github.com/imAshish28/Quantum_OR/blob/main/Untitled24.ipynb"" rel=""nofollow noreferrer"">https://github.com/imAshish28/Quantum_OR/blob/main/Untitled24.ipynb</a></p>
<pre><code>filename = 'binary_knapsack_10.lp'
qp = QuadraticProgram()
qp.read_from_lp_file(filename)
print(qp.prettyprint())
</code></pre>
<p>'''
Problem name: binary_knapsack_10</p>
<p>Minimize
-135<em>x_0 - 42</em>x_1 - 677<em>x_2 - 773</em>x_3 - 333<em>x_4 - 24</em>x_5 - 819<em>x_6 - 184</em>x_7</p>
<ul>
<li>683<em>x_8 - 895</em>x_9</li>
</ul>
<p>Subject to
Linear constraints (1)
291<em>x_0 + 80</em>x_1 + 76<em>x_2 + 111</em>x_3 + 687<em>x_4 + 87</em>x_5 + 567<em>x_6 + 969</em>x_7
+ 967<em>x_8 + 392</em>x_9 &lt;= 2114  'capacity'</p>
<p>Binary variables (10)
x_0 x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9
'''</p>
<pre><code>from qiskit_optimization.converters import QuadraticProgramToQubo

qp2qubo = QuadraticProgramToQubo()
qubo = qp2qubo.convert(qp)
qubitOp, offset = qubo.to_ising()
print(&quot;Offset:&quot;, offset)
print(&quot;Ising Hamiltonian:&quot;)
print(str(qubitOp))

from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Options, Session

# loading the IBM Acoount with the Backend
QiskitRuntimeService.save_account(channel=&quot;ibm_quantum&quot;, token=&quot;API TOKEN&quot;,overwrite=True)
service = QiskitRuntimeService(channel='ibm_quantum')
backend = service.least_busy(operational=True, simulator=False)

from qiskit.circuit.library import QAOAAnsatz
hamiltonian = qubitOp
# QAOA ansatz circuit
ansatz = QAOAAnsatz(hamiltonian, reps=2)

from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=3)
ansatz_isa = pm.run(ansatz)

hamiltonian_isa = hamiltonian.apply_layout(ansatz_isa.layout)
hamiltonian_isa

def cost_func(params, ansatz, hamiltonian, estimator):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters
        ansatz (QuantumCircuit): Parameterized ansatz circuit
        hamiltonian (SparsePauliOp): Operator representation of Hamiltonian
        estimator (Estimator): Estimator primitive instance

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    energy = estimator.run(ansatz, hamiltonian, parameter_values=params).result().values[0]
    return energy

session = Session(backend=backend)

# Configure estimator
estimator = Estimator(session=session)
estimator.options.default_shots = 100


# Configure sampler
sampler = Sampler(session=session)
sampler.options.default_shots = 100


x0 = 2 * np.pi * np.random.rand(ansatz_isa.num_parameters)

from scipy.optimize import minimize
res = minimize(cost_func, x0, args=(ansatz_isa, hamiltonian_isa, estimator), method=&quot;COBYLA&quot; , options= {'maxiter' : 5})
res
</code></pre>
<p>'''
And this is the result which I get:
message: Maximum number of function evaluations has been exceeded.
success: False
status: 2
fun: -464074414.1873996
x: [ 1.743e+00  3.937e+00  3.707e+00  4.516e+00]
nfev: 5
maxcv: 0.0
'''</p>
",qc,interpret result problem solved qiskit p solved quot 01 knapsack problem quot qiskit optimization module though iterations gets converged got answer may infeasible question interpret given result problem 10 variable result shows 4 variable improper vaule objective p code https nofollow noreferrer https pre code filename qp quadraticprogram filename print p problem name p minimize em 42 677 em 773 333 em 24 819 em 184 ul li 683 em 895 p subject linear constraints 1 291 em 80 76 em 111 687 em 87 567 em 969 967 em 392 lt 2114 p binary variables 10 pre code import quadraticprogramtoqubo qp2qubo quadraticprogramtoqubo qubo qp qubitop offset print quot offset quot offset print quot ising hamiltonian quot print str qubitop import qiskitruntimeservice sampler estimator options session loading ibm acoount backend quot quot quot api token quot service qiskitruntimeservice backend import qaoaansatz hamiltonian qubitop qaoa ansatz circuit ansatz qaoaansatz hamiltonian import target pm ansatz def params ansatz hamiltonian estimator quot quot quot return estimate energy estimator parameters params ndarray array ansatz parameters ansatz quantumcircuit parameterized ansatz circuit hamiltonian sparsepauliop operator representation hamiltonian estimator estimator estimator primitive instance returns float energy estimate quot quot quot energy ansatz hamiltonian 0 return energy session session configure estimator estimator estimator 100 configure sampler sampler sampler 100 x0 2 import minimize res minimize x0 estimator quot cobyla quot 5 res p result get message maximum number function evaluations exceeded success false status 2 fun x nfev 5 maxcv,"[(0, 0.42034423), (1, 0.123904), (4, 0.03423749), (6, 0.034239445), (7, 0.045544818), (12, 0.062607154), (19, 0.27855512)]"
38378,,2024-05-20 04:43:11,2,34,"<p>I am solving 01 KnapSack problem for 500k items with the help of hybrid CQM solver of D Wave. And for comparison I solved same problem with CPLEX. Solution quality of CPLEX solver is better than D-Wave (Not Surprising) but what is surprising for me is that the Run_Time for D-Wave CQM solver (default 85 sec) is also higher than CPLEX solver (16 sec).</p>
<p>I know CQM solver have to sample the problem many times. But my question is Whats the point of using quantum computer to solve optimization problem if they give inferior solution in more run_time than Classical Solver.</p>
<p>If anyone knows how can I reduce the run_time for D-Wave then please suggest some.</p>
",Solving KnapSack problem on D Wave hybrid CQM,<quantum-algorithms><quantum-operation><optimization><d-wave>,0,0,,,"Solving KnapSack problem on D Wave hybrid CQM <p>I am solving 01 KnapSack problem for 500k items with the help of hybrid CQM solver of D Wave. And for comparison I solved same problem with CPLEX. Solution quality of CPLEX solver is better than D-Wave (Not Surprising) but what is surprising for me is that the Run_Time for D-Wave CQM solver (default 85 sec) is also higher than CPLEX solver (16 sec).</p>
<p>I know CQM solver have to sample the problem many times. But my question is Whats the point of using quantum computer to solve optimization problem if they give inferior solution in more run_time than Classical Solver.</p>
<p>If anyone knows how can I reduce the run_time for D-Wave then please suggest some.</p>
",qc,solving knapsack problem wave hybrid cqm p solving 01 knapsack problem 500k items help hybrid cqm solver wave comparison solved problem cplex solution quality cplex solver better surprising surprising cqm solver default 85 sec also higher cplex solver 16 sec p know cqm solver sample problem many times question whats point using quantum computer solve optimization problem give inferior solution classical p anyone knows reduce please suggest,"[(1, 0.25355512), (6, 0.046210516), (7, 0.10125173), (8, 0.077101156), (12, 0.015550883), (13, 0.3781979), (19, 0.12613642)]"
38379,38380.0,2024-05-20 05:04:25,0,822,"<p>I want to get the result of this code:</p>
<pre><code>qreg_a = QuantumRegister (2)
qreg_b = QuantumRegister (2)
creg = ClassicalRegister (4)
qc = QuantumCircuit(qreg_a,qreg_b,creg)
qc.x(qreg_a[0])
qc.measure(qreg_a,creg[0:2])
qc.measure(qreg_b,creg[2:4])
simulator= BasicAer.get_backend('qasm_simulator')
result = execute(qc, simulator).result()
counts - result.get_counts(qc)
</code></pre>
<p>Quantum Lab has been discontinued. Where do I code this?</p>
",Where do I create my first circuit?,<programming><quantum-circuit>,2,0,,,"Where do I create my first circuit? <p>I want to get the result of this code:</p>
<pre><code>qreg_a = QuantumRegister (2)
qreg_b = QuantumRegister (2)
creg = ClassicalRegister (4)
qc = QuantumCircuit(qreg_a,qreg_b,creg)
qc.x(qreg_a[0])
qc.measure(qreg_a,creg[0:2])
qc.measure(qreg_b,creg[2:4])
simulator= BasicAer.get_backend('qasm_simulator')
result = execute(qc, simulator).result()
counts - result.get_counts(qc)
</code></pre>
<p>Quantum Lab has been discontinued. Where do I code this?</p>
",qc,create first circuit p want get result code pre code quantumregister 2 quantumregister 2 creg classicalregister 4 qc quantumcircuit creg 0 creg creg result execute qc simulator counts qc p quantum lab discontinued code,"[(0, 0.51427346), (2, 0.25584024), (12, 0.02830975), (14, 0.19689114)]"
38383,38491.0,2024-05-20 07:01:04,0,96,"<p>I'm trying to simulate a circuit in stim and I get the following error in my stack trace.</p>
<pre><code>ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D1368, D1369, D1424'.

In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to `stim.Circuit.detector_error_model(...)`.
From the command line, you can ignore this error by passing the flag `--ignore_decomposition_failures` to `stim analyze_errors`.

Circuit stack trace:
    during TICK layer #773 of 931
    at instruction #1156 [which is a REPEAT 11 block]
</code></pre>
<p>What is the <code>TICK layer</code> referring to here? Also, could someone explain to me what the ValueError message is saying? Thank you!</p>
",What is TICK layer in stim,<programming><stim>,1,0,,,"What is TICK layer in stim <p>I'm trying to simulate a circuit in stim and I get the following error in my stack trace.</p>
<pre><code>ValueError: Failed to decompose errors into graphlike components with at most two symptoms.
The error component that failed to decompose is 'D1368, D1369, D1424'.

In Python, you can ignore this error by passing `ignore_decomposition_failures=True` to `stim.Circuit.detector_error_model(...)`.
From the command line, you can ignore this error by passing the flag `--ignore_decomposition_failures` to `stim analyze_errors`.

Circuit stack trace:
    during TICK layer #773 of 931
    at instruction #1156 [which is a REPEAT 11 block]
</code></pre>
<p>What is the <code>TICK layer</code> referring to here? Also, could someone explain to me what the ValueError message is saying? Thank you!</p>
",qc,tick layer stim p trying simulate circuit stim get following error stack pre code valueerror failed decompose errors graphlike components two symptoms error component failed decompose d1369 d1424 python ignore error passing command line ignore error passing flag stim circuit stack trace tick layer 773 931 instruction 1156 repeat 11 block p code tick layer referring also could someone explain valueerror message saying thank,"[(4, 0.028801763), (5, 0.106602654), (6, 0.15521486), (12, 0.08906964), (13, 0.076909624), (14, 0.41312015), (19, 0.12824333)]"
38459,,2024-05-23 17:47:01,1,127,"<p>I'm working on a portfolio optimization problem using Qiskit and I'm encountering an error when trying to solve a quadratic program using MinimumEigenOptimizer with SamplingVQE. Any insights on what might be causing this error or how to fix it would be greatly appreciated!</p>
<p>Here's the code I'm using:</p>
<pre><code>from qiskit_algorithms import SamplingVQE
from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2 as Sampler
from qiskit.circuit.library import RealAmplitudes
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_algorithms.optimizers import SLSQP
import numpy as np
import datetime

num_assets = 30
seed = 123

# Generate expected return and covariance matrix from (random) time-series
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()

q = 0.5  # set risk factor
budget = num_assets // 2  # set budget
penalty = num_assets  # set parameter to scale the budget penalty term

portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()

service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(operational=True, simulator=False)
session = Session(service=service, backend=backend)

ansatz = RealAmplitudes(qp.get_num_binary_vars(), reps=3)
pm = generate_preset_pass_manager(backend=backend, optimization_level=2)
isa_circuit = pm.run(ansatz)

vqe = SamplingVQE(sampler=Sampler(session=session), ansatz= isa_circuit, optimizer=SLSQP())  
optimizer = MinimumEigenOptimizer(vqe)
result = optimizer.solve(qp)
print(result)
</code></pre>
<p>When I run this code, I get the following error:</p>
<pre><code>TypeError: run() takes 2 positional arguments but 3 were given
</code></pre>
<p>Here's the full traceback:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/sampling_vqe.py:318, in SamplingVQE._get_evaluate_energy.&lt;locals&gt;.evaluate_energy(parameters)
    315 parameters = np.reshape(parameters, (-1, num_parameters)).tolist()
    316 batch_size = len(parameters)
--&gt; 318 estimator_result = estimator.run(
    319     batch_size * [ansatz], batch_size * [operator], parameters
    320 ).result()
    321 values = estimator_result.values
    323 if self.callback is not None:

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/primitives/primitive_job.py:51, in PrimitiveJob.result(self)
     49 def result(self) -&gt; ResultT:
     50     self._check_submitted()
---&gt; 51     return self._future.result()

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:437, in Future.result(self, timeout)
    435     raise CancelledError()
    436 elif self._state == FINISHED:
--&gt; 437     return self.__get_result()
    439 self._condition.wait(timeout)
    441 if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:389, in Future.__get_result(self)
    387 if self._exception:
    388     try:
--&gt; 389         raise self._exception
    390     finally:
    391         # Break a reference cycle with the exception in self._exception
    392         self = None

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/thread.py:57, in _WorkItem.run(self)
     54     return
     56 try:
---&gt; 57     result = self.fn(*self.args, **self.kwargs)
     58 except BaseException as exc:
     59     self.future.set_exception(exc)

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/diagonal_estimator.py:117, in _DiagonalEstimator._call(self, circuits, observables, parameter_values, **run_options)
    110 def _call(
    111     self,
    112     circuits: Sequence[int],
   ...
    115     **run_options,
    116 ) -&gt; _DiagonalEstimatorResult:
--&gt; 117     job = self.sampler.run(
    118         [self._circuits[i] for i in circuits],
    119         parameter_values,
    120         **run_options,
    121     )
    122     sampler_result = job.result()
    123     samples = sampler_result.quasi_dists

TypeError: run() takes 2 positional arguments but 3 were given
<span class=""math-container"">```</span>
</code></pre>
",Portfolio Optimization with VQE,<qiskit><vqe><optimization><qiskit-runtime>,1,1,,,"Portfolio Optimization with VQE <p>I'm working on a portfolio optimization problem using Qiskit and I'm encountering an error when trying to solve a quadratic program using MinimumEigenOptimizer with SamplingVQE. Any insights on what might be causing this error or how to fix it would be greatly appreciated!</p>
<p>Here's the code I'm using:</p>
<pre><code>from qiskit_algorithms import SamplingVQE
from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2 as Sampler
from qiskit.circuit.library import RealAmplitudes
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_algorithms.optimizers import SLSQP
import numpy as np
import datetime

num_assets = 30
seed = 123

# Generate expected return and covariance matrix from (random) time-series
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()

q = 0.5  # set risk factor
budget = num_assets // 2  # set budget
penalty = num_assets  # set parameter to scale the budget penalty term

portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()

service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(operational=True, simulator=False)
session = Session(service=service, backend=backend)

ansatz = RealAmplitudes(qp.get_num_binary_vars(), reps=3)
pm = generate_preset_pass_manager(backend=backend, optimization_level=2)
isa_circuit = pm.run(ansatz)

vqe = SamplingVQE(sampler=Sampler(session=session), ansatz= isa_circuit, optimizer=SLSQP())  
optimizer = MinimumEigenOptimizer(vqe)
result = optimizer.solve(qp)
print(result)
</code></pre>
<p>When I run this code, I get the following error:</p>
<pre><code>TypeError: run() takes 2 positional arguments but 3 were given
</code></pre>
<p>Here's the full traceback:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/sampling_vqe.py:318, in SamplingVQE._get_evaluate_energy.&lt;locals&gt;.evaluate_energy(parameters)
    315 parameters = np.reshape(parameters, (-1, num_parameters)).tolist()
    316 batch_size = len(parameters)
--&gt; 318 estimator_result = estimator.run(
    319     batch_size * [ansatz], batch_size * [operator], parameters
    320 ).result()
    321 values = estimator_result.values
    323 if self.callback is not None:

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/primitives/primitive_job.py:51, in PrimitiveJob.result(self)
     49 def result(self) -&gt; ResultT:
     50     self._check_submitted()
---&gt; 51     return self._future.result()

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:437, in Future.result(self, timeout)
    435     raise CancelledError()
    436 elif self._state == FINISHED:
--&gt; 437     return self.__get_result()
    439 self._condition.wait(timeout)
    441 if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:389, in Future.__get_result(self)
    387 if self._exception:
    388     try:
--&gt; 389         raise self._exception
    390     finally:
    391         # Break a reference cycle with the exception in self._exception
    392         self = None

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/thread.py:57, in _WorkItem.run(self)
     54     return
     56 try:
---&gt; 57     result = self.fn(*self.args, **self.kwargs)
     58 except BaseException as exc:
     59     self.future.set_exception(exc)

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/diagonal_estimator.py:117, in _DiagonalEstimator._call(self, circuits, observables, parameter_values, **run_options)
    110 def _call(
    111     self,
    112     circuits: Sequence[int],
   ...
    115     **run_options,
    116 ) -&gt; _DiagonalEstimatorResult:
--&gt; 117     job = self.sampler.run(
    118         [self._circuits[i] for i in circuits],
    119         parameter_values,
    120         **run_options,
    121     )
    122     sampler_result = job.result()
    123     samples = sampler_result.quasi_dists

TypeError: run() takes 2 positional arguments but 3 were given
<span class=""math-container"">```</span>
</code></pre>
",qc,portfolio optimization vqe p working portfolio optimization problem using qiskit encountering error trying solve quadratic program using minimumeigenoptimizer samplingvqe insights might causing error fix would greatly appreciated p code using pre code import samplingvqe import portfoliooptimization import randomdataprovider import minimumeigenoptimizer import qiskitruntimeservice session samplerv2 sampler import realamplitudes import import slsqp import numpy np import datetime 30 seed 123 generate expected return covariance matrix random stocks quot ticker quot range data randomdataprovider 2016 1 1 2016 1 30 mu sigma q set risk factor budget 2 set budget penalty set parameter scale budget penalty term portfolio portfoliooptimization qp service qiskitruntimeservice quot quot backend session session ansatz realamplitudes pm ansatz vqe samplingvqe optimizer minimumeigenoptimizer vqe result qp print result p run code get following error pre code typeerror run takes 2 positional arguments 3 given p full traceback pre code typeerror traceback recent call last file lt locals gt parameters 315 parameters parameters 316 len parameters gt 318 319 ansatz operator parameters 320 321 values 323 none file self 49 def result self gt resultt 50 gt 51 return file self timeout 435 raise cancellederror 436 elif finished gt 437 return 439 timeout 441 cancelled file self 387 388 try gt 389 raise 390 finally 391 break reference cycle exception 392 self none file self 54 return 56 try gt 57 result 58 except baseexception exc 59 exc file self circuits observables 110 def 111 self 112 circuits sequence int 115 116 gt gt 117 job 118 circuits 119 120 121 122 123 samples typeerror run takes 2 positional arguments 3 given span,"[(0, 0.8240581), (6, 0.018979724), (12, 0.01128227), (14, 0.014120455), (17, 0.08726437), (19, 0.03423403)]"
38477,38478.0,2024-05-24 17:05:01,1,173,"<p>The <code>PauliEvolutionGate</code> <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.PauliEvolutionGate"" rel=""nofollow noreferrer"">implements</a> <span class=""math-container"">$ U = exp(-itH)$</span> for an operator <span class=""math-container"">$H$</span> consisting of Pauli terms. Since qiskit 1.0 there is also <code>HamiltonianGate</code> <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.HamiltonianGate"" rel=""nofollow noreferrer"">which</a> implements <span class=""math-container"">$U = exp(-itH)$</span>. What is the difference (if <span class=""math-container"">$H$</span> consists of Pauli terms)?</p>
<p>More concretely, why does <code>HamiltonianGate</code>implement the gate directly corresponding to the Hadamard gate, while <code>PauliEvolutionGate</code>seems to result in a different operator in the following example:</p>
<pre><code>import qiskit
print('Qiskit Version: ', qiskit.__version__)
from qiskit.circuit.library import HGate, PauliEvolutionGate, HamiltonianGate
from qiskit.quantum_info import SparsePauliOp, Operator

h = SparsePauliOp(['I', 'X', 'Z'], coeffs=[ 1.57079633+0.j, -1.11072073+0.j, -1.11072073+0.j])

u_pauli = Operator(PauliEvolutionGate(h, time=1))
print(u_pauli)

u_hamil = Operator(HamiltonianGate(h, time=1))
print(u_hamil)

u_hadamard = Operator(HGate())

print('Equivalence:')
print('Pauli and Hamiltonian evolution:')
print(u_pauli.equiv(u_hamil, atol=1e-2))
print('Pauli evolution and Hadamard gate:')
print(u_pauli.equiv(u_hadamard, atol=1e-2))
print('Hamiltonian evolution and Hadamard gate:')
print(u_hamil.equiv(u_hadamard, atol=1e-2))
</code></pre>
<pre><code>-&gt;
Qiskit Version:  1.1.0
Operator([[ 0.3978466 -0.19715007j,  0.39784661+0.80284993j],
          [ 0.3978466 -0.80284993j, -0.3978466 -0.19715007j]],
         input_dims=(2,), output_dims=(2,))
Operator([[ 0.70710678-8.68630257e-09j,  0.70710678-2.26635039e-09j],
          [ 0.70710678-2.26635039e-09j, -0.70710678-4.15360180e-09j]],
         input_dims=(2,), output_dims=(2,))
Equivalence:
Pauli and Hamiltonian evolution:
False
Pauli evolution and Hadamard gate:
False
Hamiltonian evolution and Hadamard gate:
True
<span class=""math-container"">```</span>
</code></pre>
",What is the difference between HamiltonianGate and PauliEvolutionGate in qiskit?,<qiskit>,1,0,,,"What is the difference between HamiltonianGate and PauliEvolutionGate in qiskit? <p>The <code>PauliEvolutionGate</code> <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.PauliEvolutionGate"" rel=""nofollow noreferrer"">implements</a> <span class=""math-container"">$ U = exp(-itH)$</span> for an operator <span class=""math-container"">$H$</span> consisting of Pauli terms. Since qiskit 1.0 there is also <code>HamiltonianGate</code> <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.HamiltonianGate"" rel=""nofollow noreferrer"">which</a> implements <span class=""math-container"">$U = exp(-itH)$</span>. What is the difference (if <span class=""math-container"">$H$</span> consists of Pauli terms)?</p>
<p>More concretely, why does <code>HamiltonianGate</code>implement the gate directly corresponding to the Hadamard gate, while <code>PauliEvolutionGate</code>seems to result in a different operator in the following example:</p>
<pre><code>import qiskit
print('Qiskit Version: ', qiskit.__version__)
from qiskit.circuit.library import HGate, PauliEvolutionGate, HamiltonianGate
from qiskit.quantum_info import SparsePauliOp, Operator

h = SparsePauliOp(['I', 'X', 'Z'], coeffs=[ 1.57079633+0.j, -1.11072073+0.j, -1.11072073+0.j])

u_pauli = Operator(PauliEvolutionGate(h, time=1))
print(u_pauli)

u_hamil = Operator(HamiltonianGate(h, time=1))
print(u_hamil)

u_hadamard = Operator(HGate())

print('Equivalence:')
print('Pauli and Hamiltonian evolution:')
print(u_pauli.equiv(u_hamil, atol=1e-2))
print('Pauli evolution and Hadamard gate:')
print(u_pauli.equiv(u_hadamard, atol=1e-2))
print('Hamiltonian evolution and Hadamard gate:')
print(u_hamil.equiv(u_hadamard, atol=1e-2))
</code></pre>
<pre><code>-&gt;
Qiskit Version:  1.1.0
Operator([[ 0.3978466 -0.19715007j,  0.39784661+0.80284993j],
          [ 0.3978466 -0.80284993j, -0.3978466 -0.19715007j]],
         input_dims=(2,), output_dims=(2,))
Operator([[ 0.70710678-8.68630257e-09j,  0.70710678-2.26635039e-09j],
          [ 0.70710678-2.26635039e-09j, -0.70710678-4.15360180e-09j]],
         input_dims=(2,), output_dims=(2,))
Equivalence:
Pauli and Hamiltonian evolution:
False
Pauli evolution and Hadamard gate:
False
Hamiltonian evolution and Hadamard gate:
True
<span class=""math-container"">```</span>
</code></pre>
",qc,difference hamiltoniangate paulievolutiongate qiskit p code paulievolutiongate https nofollow noreferrer implements span u exp operator span h consisting pauli terms since qiskit also code hamiltoniangate https nofollow noreferrer implements span u exp difference span h consists pauli terms p concretely code hamiltoniangate implement gate directly corresponding hadamard gate code paulievolutiongate seems result different operator following example pre code import qiskit print version import hgate paulievolutiongate hamiltoniangate import sparsepauliop operator h sparsepauliop x z operator paulievolutiongate h print operator hamiltoniangate h print operator hgate print print hamiltonian evolution print print evolution hadamard gate print print evolution hadamard gate print pre code gt qiskit version operator 2 2 operator 2 2 equivalence pauli hamiltonian evolution false pauli evolution hadamard gate false hamiltonian evolution hadamard gate true span,"[(0, 0.39295578), (1, 0.082626216), (3, 0.16130896), (6, 0.024776297), (9, 0.2533892), (12, 0.08382479)]"
38505,38506.0,2024-05-27 16:14:32,0,38,"<p>In quantum information it occasionally happens that one ends up with a completely positive but <strong>not</strong> yet trace-preserving map <span class=""math-container"">$\Psi$</span> which one wants to make trace preserving somehow; this often comes up in corresponding numerical considerations. A simple and well-known way of turning such maps into trace-preserving ones is to &quot;skew&quot; the input using the value of the <a href=""https://quantumcomputing.stackexchange.com/q/12917"">adjoint map</a> <span class=""math-container"">$\Psi^\dagger$</span> applied to the identity, i.e.
<span class=""math-container"">$$
\tilde\Psi:=\Psi((\Psi^\dagger ({\bf1}))^{-1/2}(\cdot)(\Psi^\dagger ({\bf1}))^{-1/2})
\tag1
$$</span>
is (still completely positive and) readily verified to be trace preserving, hence a channel.
When doing numerics this is all one needs because <span class=""math-container"">$\Psi^\dagger({\bf1})$</span> is generically invertible so (1) always works. However, in other situations it may happen that the operator <span class=""math-container"">$\Psi^\dagger({\bf1})$</span> has non-trivial kernel in which case (1) is of course ill defined. The most obvious idea to fix this would be to replace the main operator <span class=""math-container"">$(\Psi^\dagger ({\bf1}))^{-1}$</span> (resp. its square root) by its <a href=""https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse"" rel=""nofollow noreferrer"">Moore-Penrose inverse</a> <span class=""math-container"">$(\Psi^\dagger ({\bf1}))^+$</span>; however it is not clear whether the resulting map (1) is still trace preserving in this case.</p>
<p>But this procedure may be too restrictive altogether. Thus, given <span class=""math-container"">$\Psi$</span> completely positive one may ask whether there always exist completely positive maps <span class=""math-container"">$\Phi_1,\Phi_2$</span> <strong>with completely positive inverse</strong> (as we do not want to lose any information on <span class=""math-container"">$\Psi$</span>, i.e. whatever we do to make <span class=""math-container"">$\Psi$</span> trace preserving we want to be able to undo in a &quot;physical&quot; manner) such that <span class=""math-container"">$\Phi_1\circ\Psi\circ\Phi_2$</span> is trace preserving? Recalling that <a href=""https://quantumcomputing.stackexchange.com/a/37694"">a CP map has CP inverse only if its Kraus rank is 1</a> this is equivalent to the following</p>
<blockquote>
<p><strong>Question.</strong> Given <span class=""math-container"">$\Psi$</span> completely positive do there always exist <span class=""math-container"">$K_1,K_2$</span> such that <span class=""math-container"">$$\tilde\Psi:=K_2\Psi(K_1^\dagger(\cdot)K_1)K_2^\dagger$$</span> is also trace preserving?</p>
</blockquote>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
","Given $\Psi$ completely positive when do there exist $K_1,K_2$ such that $K_2\Psi(K_1^\dagger(\cdot)K_1)K_2^\dagger$ is also trace preserving?",<quantum-operation><kraus-representation>,1,0,,,"Given $\Psi$ completely positive when do there exist $K_1,K_2$ such that $K_2\Psi(K_1^\dagger(\cdot)K_1)K_2^\dagger$ is also trace preserving? <p>In quantum information it occasionally happens that one ends up with a completely positive but <strong>not</strong> yet trace-preserving map <span class=""math-container"">$\Psi$</span> which one wants to make trace preserving somehow; this often comes up in corresponding numerical considerations. A simple and well-known way of turning such maps into trace-preserving ones is to &quot;skew&quot; the input using the value of the <a href=""https://quantumcomputing.stackexchange.com/q/12917"">adjoint map</a> <span class=""math-container"">$\Psi^\dagger$</span> applied to the identity, i.e.
<span class=""math-container"">$$
\tilde\Psi:=\Psi((\Psi^\dagger ({\bf1}))^{-1/2}(\cdot)(\Psi^\dagger ({\bf1}))^{-1/2})
\tag1
$$</span>
is (still completely positive and) readily verified to be trace preserving, hence a channel.
When doing numerics this is all one needs because <span class=""math-container"">$\Psi^\dagger({\bf1})$</span> is generically invertible so (1) always works. However, in other situations it may happen that the operator <span class=""math-container"">$\Psi^\dagger({\bf1})$</span> has non-trivial kernel in which case (1) is of course ill defined. The most obvious idea to fix this would be to replace the main operator <span class=""math-container"">$(\Psi^\dagger ({\bf1}))^{-1}$</span> (resp. its square root) by its <a href=""https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse"" rel=""nofollow noreferrer"">Moore-Penrose inverse</a> <span class=""math-container"">$(\Psi^\dagger ({\bf1}))^+$</span>; however it is not clear whether the resulting map (1) is still trace preserving in this case.</p>
<p>But this procedure may be too restrictive altogether. Thus, given <span class=""math-container"">$\Psi$</span> completely positive one may ask whether there always exist completely positive maps <span class=""math-container"">$\Phi_1,\Phi_2$</span> <strong>with completely positive inverse</strong> (as we do not want to lose any information on <span class=""math-container"">$\Psi$</span>, i.e. whatever we do to make <span class=""math-container"">$\Psi$</span> trace preserving we want to be able to undo in a &quot;physical&quot; manner) such that <span class=""math-container"">$\Phi_1\circ\Psi\circ\Phi_2$</span> is trace preserving? Recalling that <a href=""https://quantumcomputing.stackexchange.com/a/37694"">a CP map has CP inverse only if its Kraus rank is 1</a> this is equivalent to the following</p>
<blockquote>
<p><strong>Question.</strong> Given <span class=""math-container"">$\Psi$</span> completely positive do there always exist <span class=""math-container"">$K_1,K_2$</span> such that <span class=""math-container"">$$\tilde\Psi:=K_2\Psi(K_1^\dagger(\cdot)K_1)K_2^\dagger$$</span> is also trace preserving?</p>
</blockquote>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",qc,given completely positive exist also trace preserving p quantum information occasionally happens one ends completely positive strong yet map span one wants make trace preserving somehow often comes corresponding numerical considerations simple way turning maps ones quot skew quot input using value https adjoint map span applied identity span still completely positive readily verified trace preserving hence channel numerics one needs span generically invertible 1 always works however situations may happen operator span kernel case 1 course ill defined obvious idea fix would replace main operator span resp square root https e2 80 nofollow noreferrer inverse span however clear whether resulting map 1 still trace preserving p procedure may restrictive altogether thus given span completely positive one may ask whether always exist completely positive maps span strong completely positive inverse want lose information span whatever make span trace preserving want able undo quot physical quot manner span trace preserving recalling https cp map cp inverse kraus rank 1 equivalent following blockquote p strong given span completely positive always exist span span also trace preserving hr p em q amp style question meant contribution https list counterexamples quantum information,"[(3, 0.5772674), (4, 0.03238954), (8, 0.114669755), (11, 0.23266728), (12, 0.0110900905), (19, 0.02492053)]"
38568,38607.0,2024-05-31 10:05:06,2,203,"<p>I've implemented a quantum counting algorithm for a sudoku example by following
the amplitude estimation algorithm introduced in Mosca's textbook (An Introduction to Quantum Computing, page#172):
<a href=""https://i.sstatic.net/JpcGprK2.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JpcGprK2.png"" alt=""enter image description here"" /></a></p>
<p>However, when I ran my code I got an incorrect counting 13, while the right count is 2 (this sudoku has 2 answers).</p>
<p>I've verified the grover's operator(oracle+diffuser) gives a right answer for the sudoku, thus I believe something should be wrong with other parts of the circuit other than Grover's operator itself but don't now where.</p>
<p>I would appreciate any hints from you on my implementation. I've attached a diagram of my circuit.</p>
<p><a href=""https://i.sstatic.net/fGyckC6t.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fGyckC6t.png"" alt=""enter image description here"" /></a></p>
",Cannot get a correct quantum count for a sudoku example,<qiskit><grovers-algorithm><quantum-phase-estimation><amplitude-amplification>,1,0,,,"Cannot get a correct quantum count for a sudoku example <p>I've implemented a quantum counting algorithm for a sudoku example by following
the amplitude estimation algorithm introduced in Mosca's textbook (An Introduction to Quantum Computing, page#172):
<a href=""https://i.sstatic.net/JpcGprK2.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JpcGprK2.png"" alt=""enter image description here"" /></a></p>
<p>However, when I ran my code I got an incorrect counting 13, while the right count is 2 (this sudoku has 2 answers).</p>
<p>I've verified the grover's operator(oracle+diffuser) gives a right answer for the sudoku, thus I believe something should be wrong with other parts of the circuit other than Grover's operator itself but don't now where.</p>
<p>I would appreciate any hints from you on my implementation. I've attached a diagram of my circuit.</p>
<p><a href=""https://i.sstatic.net/fGyckC6t.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fGyckC6t.png"" alt=""enter image description here"" /></a></p>
",qc,get correct quantum count sudoku example p implemented quantum counting algorithm sudoku example following amplitude estimation algorithm introduced mosca textbook introduction quantum computing page 172 https nofollow noreferrer img https enter image description p however ran code got incorrect counting 13 right count 2 sudoku 2 answers p verified grover operator gives right answer sudoku thus believe something wrong parts circuit grover operator p would appreciate hints implementation attached diagram p https nofollow noreferrer img https enter image description,"[(0, 0.07214871), (3, 0.026584644), (4, 0.48902008), (6, 0.016091533), (7, 0.27377376), (11, 0.012679777), (12, 0.05129027), (13, 0.044590715), (19, 0.012428364)]"
38640,38643.0,2024-06-05 08:59:43,1,99,"<p>In the <a href=""https://en.wikipedia.org/wiki/CHSH_inequality"" rel=""nofollow noreferrer"">CHSH game</a> , the optimal quantum winning rate should be approximately 85% when Alice and Bob share the EPR states and this winning rate holds the same when they share arbitrarily many EPR states. The optimal strategy is (locally  isomorphic to) acting on only one EPR.  I write a mathematica program searching for the best winning rate when sharing two EPR pairs, the code is</p>
<pre><code>matrixA = {{1}, {0}, {0}, {1}};
matrixB = KroneckerProduct[matrixA, matrixA];
rho = (1/4)* matrixB . Transpose[matrixB];
A0 = Array[a0, {4, 4}];
B0 = Array[b0, {4, 4}];
A1 = Array[a1, {4, 4}];
B1 = Array[b1, {4, 4}];
D00 = KroneckerProduct[A0, B0];
D01 = KroneckerProduct[A0, B1];
D10 = KroneckerProduct[A1, B0];
D11 = KroneckerProduct[A1, B1];
constraints = {VectorGreaterEqual[{A0 + IdentityMatrix[4], 
     0}, {&quot;SemidefiniteCone&quot;, 4}], 
   VectorGreaterEqual[{IdentityMatrix[4] - A0, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] + B0, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] - B0, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] + A1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] - A1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] + B1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] - B1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}]};
objective = 0.5 + 1/8*(Tr[rho . (D00 + D01 + D10 - D11)]);
maximizeResult = 
     NMaximize[{objective, constraints}, Flatten[{A0, B0, A1, B1}], 
     WorkingPrecision -&gt; 10, Method -&gt; &quot;DifferentialEvolution&quot;] // 
    Chop;;
maximizeResult
</code></pre>
<p>For <span class=""math-container"">$-I \preceq A_0,B_0,A_1,B_1\preceq I$</span>, the winning rate is <span class=""math-container"">$0.5+1/8Tr((A_0\otimes B_0+ A_0\otimes B_1+A_1\otimes B_0-A_1\otimes B_1)\rho)$</span>. But the above program gives an output of 0.7500005245, which is the best winning value for classical case.</p>
<p>I also tried the case Alice and Bob share one EPR, the code is</p>
<pre><code>A0 = Array[a0, {2, 2}];
B0 = Array[b0, {2, 2}];
A1 = Array[a1, {2, 2}];
B1 = Array[b1, {2, 2}];
rho = {{1/2, 0, 0, 1/2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {1/2, 0, 0, 1/2}};

D00 = KroneckerProduct[A0, B0];
D01 = KroneckerProduct[A0, B1];
D10 = KroneckerProduct[A1, B0];
D11 = KroneckerProduct[A1, B1];
constraints = {VectorGreaterEqual[{A0 + IdentityMatrix[2], 
     0}, {&quot;SemidefiniteCone&quot;, 2}], 
   VectorGreaterEqual[{IdentityMatrix[2] - A0, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] + B0, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] - B0, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] + A1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] - A1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] + B1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] - B1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}]};
objective = 0.5 + 1/8*(Tr[rho . (D00 + D01 + D10 - D11)]);
maximizeResult = 
    NMaximize[{objective, constraints}, Flatten[{A0, B0, A1, B1}], 
   Method -&gt; &quot;DifferentialEvolution&quot;, WorkingPrecision -&gt; 10];
maximizeResult
</code></pre>
<p>This time the code output 0.8535490666 which is the known best winning rate. So why it is failed when Alice and Bob share 2 EPR states?</p>
","For CHSH game, why does the mathematica program gives 75% as the best winning rate when sharing 2 EPR pairs?",<programming><non-locality><bell-experiment>,1,1,,,"For CHSH game, why does the mathematica program gives 75% as the best winning rate when sharing 2 EPR pairs? <p>In the <a href=""https://en.wikipedia.org/wiki/CHSH_inequality"" rel=""nofollow noreferrer"">CHSH game</a> , the optimal quantum winning rate should be approximately 85% when Alice and Bob share the EPR states and this winning rate holds the same when they share arbitrarily many EPR states. The optimal strategy is (locally  isomorphic to) acting on only one EPR.  I write a mathematica program searching for the best winning rate when sharing two EPR pairs, the code is</p>
<pre><code>matrixA = {{1}, {0}, {0}, {1}};
matrixB = KroneckerProduct[matrixA, matrixA];
rho = (1/4)* matrixB . Transpose[matrixB];
A0 = Array[a0, {4, 4}];
B0 = Array[b0, {4, 4}];
A1 = Array[a1, {4, 4}];
B1 = Array[b1, {4, 4}];
D00 = KroneckerProduct[A0, B0];
D01 = KroneckerProduct[A0, B1];
D10 = KroneckerProduct[A1, B0];
D11 = KroneckerProduct[A1, B1];
constraints = {VectorGreaterEqual[{A0 + IdentityMatrix[4], 
     0}, {&quot;SemidefiniteCone&quot;, 4}], 
   VectorGreaterEqual[{IdentityMatrix[4] - A0, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] + B0, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] - B0, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] + A1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] - A1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] + B1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}],
   VectorGreaterEqual[{IdentityMatrix[4] - B1, 
     0}, {&quot;SemidefiniteCone&quot;, 4}]};
objective = 0.5 + 1/8*(Tr[rho . (D00 + D01 + D10 - D11)]);
maximizeResult = 
     NMaximize[{objective, constraints}, Flatten[{A0, B0, A1, B1}], 
     WorkingPrecision -&gt; 10, Method -&gt; &quot;DifferentialEvolution&quot;] // 
    Chop;;
maximizeResult
</code></pre>
<p>For <span class=""math-container"">$-I \preceq A_0,B_0,A_1,B_1\preceq I$</span>, the winning rate is <span class=""math-container"">$0.5+1/8Tr((A_0\otimes B_0+ A_0\otimes B_1+A_1\otimes B_0-A_1\otimes B_1)\rho)$</span>. But the above program gives an output of 0.7500005245, which is the best winning value for classical case.</p>
<p>I also tried the case Alice and Bob share one EPR, the code is</p>
<pre><code>A0 = Array[a0, {2, 2}];
B0 = Array[b0, {2, 2}];
A1 = Array[a1, {2, 2}];
B1 = Array[b1, {2, 2}];
rho = {{1/2, 0, 0, 1/2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {1/2, 0, 0, 1/2}};

D00 = KroneckerProduct[A0, B0];
D01 = KroneckerProduct[A0, B1];
D10 = KroneckerProduct[A1, B0];
D11 = KroneckerProduct[A1, B1];
constraints = {VectorGreaterEqual[{A0 + IdentityMatrix[2], 
     0}, {&quot;SemidefiniteCone&quot;, 2}], 
   VectorGreaterEqual[{IdentityMatrix[2] - A0, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] + B0, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] - B0, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] + A1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] - A1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] + B1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}],
   VectorGreaterEqual[{IdentityMatrix[2] - B1, 
     0}, {&quot;SemidefiniteCone&quot;, 2}]};
objective = 0.5 + 1/8*(Tr[rho . (D00 + D01 + D10 - D11)]);
maximizeResult = 
    NMaximize[{objective, constraints}, Flatten[{A0, B0, A1, B1}], 
   Method -&gt; &quot;DifferentialEvolution&quot;, WorkingPrecision -&gt; 10];
maximizeResult
</code></pre>
<p>This time the code output 0.8535490666 which is the known best winning rate. So why it is failed when Alice and Bob share 2 EPR states?</p>
",qc,chsh game mathematica program gives 75 best winning rate sharing 2 epr pairs p https nofollow noreferrer chsh game optimal quantum winning rate approximately 85 alice bob share epr states winning rate holds share arbitrarily many epr states optimal strategy locally isomorphic acting one epr write mathematica program searching best winning rate sharing two epr pairs code pre code matrixa 1 0 0 1 matrixb kroneckerproduct matrixa matrixa rho matrixb transpose matrixb a0 array a0 4 4 b0 array b0 4 4 a1 array a1 4 4 b1 array b1 4 4 d00 kroneckerproduct a0 b0 d01 kroneckerproduct a0 b1 d10 kroneckerproduct a1 b0 d11 kroneckerproduct a1 b1 constraints vectorgreaterequal a0 identitymatrix 4 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 a0 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 b0 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 b0 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 a1 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 a1 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 b1 0 quot semidefinitecone quot 4 vectorgreaterequal identitymatrix 4 b1 0 quot semidefinitecone quot 4 objective tr rho d00 d01 d10 d11 maximizeresult nmaximize objective constraints flatten a0 b0 a1 b1 workingprecision gt 10 method gt quot differentialevolution quot chop maximizeresult p span winning rate span program gives output best winning value classical p also tried case alice bob share one epr code pre code a0 array a0 2 2 b0 array b0 2 2 a1 array a1 2 2 b1 array b1 2 2 rho 0 0 0 0 0 0 0 0 0 0 0 0 d00 kroneckerproduct a0 b0 d01 kroneckerproduct a0 b1 d10 kroneckerproduct a1 b0 d11 kroneckerproduct a1 b1 constraints vectorgreaterequal a0 identitymatrix 2 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 a0 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 b0 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 b0 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 a1 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 a1 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 b1 0 quot semidefinitecone quot 2 vectorgreaterequal identitymatrix 2 b1 0 quot semidefinitecone quot 2 objective tr rho d00 d01 d10 d11 maximizeresult nmaximize objective constraints flatten a0 b0 a1 b1 method gt quot differentialevolution quot workingprecision gt 10 maximizeresult p time code output known best winning rate failed alice bob share 2 epr states,"[(0, 0.034250244), (2, 0.1491827), (3, 0.03419992), (5, 0.023836982), (6, 0.12405504), (11, 0.35208228), (12, 0.020834124), (18, 0.14177258), (19, 0.1157849)]"
38673,38680.0,2024-06-07 14:17:49,1,74,"<p>In the <a href=""https://en.wikipedia.org/wiki/CHSH_inequality"" rel=""nofollow noreferrer"">CHSH game</a>, when the players share EPR states they can achieve best the winning rate of approximately 85% which can be proved through the <a href=""https://en.wikipedia.org/wiki/Tsirelson%27s_bound"" rel=""nofollow noreferrer"">Tsirelson's bound</a>. I wonder what the best winning rate will be if the players share more general states. In a previous question <a href=""https://quantumcomputing.stackexchange.com/questions/31710/"">Worst Bell inequality violation with non-maximally entangled state?</a> it was mentioned that if the players share state <span class=""math-container"">$c_0|00\rangle+c_1|11\rangle$</span>, the maximal violation will be <span class=""math-container"">$2\sqrt{1+4|c_0c_1|^2)}$</span>. Are there any more results like sharing a mixed state?</p>
",CHSH game sharing more general states,<entanglement><non-locality><nonlocal-games>,1,0,,,"CHSH game sharing more general states <p>In the <a href=""https://en.wikipedia.org/wiki/CHSH_inequality"" rel=""nofollow noreferrer"">CHSH game</a>, when the players share EPR states they can achieve best the winning rate of approximately 85% which can be proved through the <a href=""https://en.wikipedia.org/wiki/Tsirelson%27s_bound"" rel=""nofollow noreferrer"">Tsirelson's bound</a>. I wonder what the best winning rate will be if the players share more general states. In a previous question <a href=""https://quantumcomputing.stackexchange.com/questions/31710/"">Worst Bell inequality violation with non-maximally entangled state?</a> it was mentioned that if the players share state <span class=""math-container"">$c_0|00\rangle+c_1|11\rangle$</span>, the maximal violation will be <span class=""math-container"">$2\sqrt{1+4|c_0c_1|^2)}$</span>. Are there any more results like sharing a mixed state?</p>
",qc,chsh game sharing general states p https nofollow noreferrer chsh game players share epr states achieve best winning rate approximately 85 proved https nofollow noreferrer tsirelson bound wonder best winning rate players share general states previous question https worst bell inequality violation entangled state mentioned players share state span maximal violation span results like sharing mixed state,"[(3, 0.291262), (4, 0.13103664), (5, 0.038979802), (12, 0.017892722), (18, 0.51820236)]"
38713,38714.0,2024-06-11 06:41:25,2,236,"<p>In the CHSH game where Alice and Bob share one EPR the optimal strategy is to measure the following observables <span class=""math-container"">$A_0=Z,A_1=X,B_0=1/\sqrt{2}(X+Z),B_1=1/\sqrt{2}(X-Z)$</span> depending on their question. We can see that the optimal strategy is projective measurement instead of general measurement. For other nonlocal games does it suffice to consider only projective measurement to get a optimal strategy?</p>
<p>For example in <a href=""https://doi.org/10.1016/0375-9601(95)00214-n"" rel=""nofollow noreferrer"">this paper</a> equation (3) only the projective measurement of dimension 4 is considered for CHSH games sharing a general state.</p>
<p>In the QCQI section 2.2.8 it is proved that any general measurement can be changed into a projective measurement where an auxiliary bit is introduced, so the dimension of the operator is enlarged. To get an optimal strategy, do we need to search the projective measurement in the enlarged Hilbert space?</p>
",Why are only projective measurements considered in nonlocal games to get optimal strategy?,<measurement><projection-operator><non-locality><nonlocal-games>,1,0,,,"Why are only projective measurements considered in nonlocal games to get optimal strategy? <p>In the CHSH game where Alice and Bob share one EPR the optimal strategy is to measure the following observables <span class=""math-container"">$A_0=Z,A_1=X,B_0=1/\sqrt{2}(X+Z),B_1=1/\sqrt{2}(X-Z)$</span> depending on their question. We can see that the optimal strategy is projective measurement instead of general measurement. For other nonlocal games does it suffice to consider only projective measurement to get a optimal strategy?</p>
<p>For example in <a href=""https://doi.org/10.1016/0375-9601(95)00214-n"" rel=""nofollow noreferrer"">this paper</a> equation (3) only the projective measurement of dimension 4 is considered for CHSH games sharing a general state.</p>
<p>In the QCQI section 2.2.8 it is proved that any general measurement can be changed into a projective measurement where an auxiliary bit is introduced, so the dimension of the operator is enlarged. To get an optimal strategy, do we need to search the projective measurement in the enlarged Hilbert space?</p>
",qc,projective measurements considered nonlocal games get optimal strategy p chsh game alice bob share one epr optimal strategy measure following observables span 2 2 depending question see optimal strategy projective measurement instead general measurement nonlocal games suffice consider projective measurement get optimal strategy p example https 95 nofollow noreferrer paper equation 3 projective measurement dimension 4 considered chsh games sharing general p qcqi section proved general measurement changed projective measurement auxiliary bit introduced dimension operator enlarged get optimal strategy need search projective measurement enlarged hilbert space,"[(2, 0.089731485), (3, 0.40647793), (4, 0.046326376), (12, 0.011776299), (17, 0.0327422), (18, 0.41132015)]"
38731,38732.0,2024-06-12 14:27:25,1,45,"<p>It is known that all peripheral eigenvalues (i.e. all eigenvalues <span class=""math-container"">$\lambda\in\mathbb C$</span> such that <span class=""math-container"">$|\lambda|$</span> equals the <a href=""https://en.wikipedia.org/wiki/Spectral_radius"" rel=""nofollow noreferrer"">spectral radius</a>) of positive <em>trace-preserving</em> or positive <em>unital</em> maps are always <a href=""https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Algebraic_multiplicity"" rel=""nofollow noreferrer"">semisimple</a> (=no non-trivial Jordan blocks), cf. Proposition 6.2 in the <a href=""https://mediatum.ub.tum.de/node?id=1701036&amp;change_language=en"" rel=""nofollow noreferrer"">lecture notes of Michael Wolf</a>.</p>
<p>In some sense this is a generalization of the fact that the <a href=""https://math.stackexchange.com/a/4831252"">peripheral eigenvalues of any stochastic matrix are always semisimple</a>, as well as the <a href=""https://en.wikipedia.org/wiki/Perron%E2%80%93Frobenius_theorem"" rel=""nofollow noreferrer"">Perron-Frobenius theorem</a> which states that for positive matrices the leading eigenvalue is always simple.
Now, motivated by the latter result the following question arises:</p>
<blockquote>
<p>Given <span class=""math-container"">$\Phi\in\mathcal L(\mathbb C^{n\times n})$</span> completely positive (but not necessarily trace preserving) are the peripheral eigenvalues of <span class=""math-container"">$\Phi$</span> always semisimple? Or if complete positivity is not enough, maybe <a href=""https://quantumcomputing.stackexchange.com/q/38407"">strict positivity</a>—as an analogue of the requirement for Perron-Frobenius—guarantees such a result, maybe even just for the leading eigenvalue?</p>
</blockquote>
<p>In other words the question is whether trace-preservation, resp. unitality was a <em>necessary</em> assumption in the original result on peripheral eigenvalues of positive, trace-preserving maps, or whether (complete, strict, or just usual) positivity is all one needs.
As a side note this question is of course related to the fact that <a href=""https://math.stackexchange.com/q/4528769"">not every quantum channel is diagonalizable</a>: in the diagonalizable case <a href=""https://en.wikipedia.org/wiki/Semi-simplicity#Semi-simple_matrices"" rel=""nofollow noreferrer"">all eigenvalues are semisimple</a> so any possible counterexample to the above question has to be a non-diagonalizable map.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",Are peripheral eigenvalues of a completely positive map always semisimple?,<linear-algebra><quantum-operation><kraus-representation>,1,0,,,"Are peripheral eigenvalues of a completely positive map always semisimple? <p>It is known that all peripheral eigenvalues (i.e. all eigenvalues <span class=""math-container"">$\lambda\in\mathbb C$</span> such that <span class=""math-container"">$|\lambda|$</span> equals the <a href=""https://en.wikipedia.org/wiki/Spectral_radius"" rel=""nofollow noreferrer"">spectral radius</a>) of positive <em>trace-preserving</em> or positive <em>unital</em> maps are always <a href=""https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Algebraic_multiplicity"" rel=""nofollow noreferrer"">semisimple</a> (=no non-trivial Jordan blocks), cf. Proposition 6.2 in the <a href=""https://mediatum.ub.tum.de/node?id=1701036&amp;change_language=en"" rel=""nofollow noreferrer"">lecture notes of Michael Wolf</a>.</p>
<p>In some sense this is a generalization of the fact that the <a href=""https://math.stackexchange.com/a/4831252"">peripheral eigenvalues of any stochastic matrix are always semisimple</a>, as well as the <a href=""https://en.wikipedia.org/wiki/Perron%E2%80%93Frobenius_theorem"" rel=""nofollow noreferrer"">Perron-Frobenius theorem</a> which states that for positive matrices the leading eigenvalue is always simple.
Now, motivated by the latter result the following question arises:</p>
<blockquote>
<p>Given <span class=""math-container"">$\Phi\in\mathcal L(\mathbb C^{n\times n})$</span> completely positive (but not necessarily trace preserving) are the peripheral eigenvalues of <span class=""math-container"">$\Phi$</span> always semisimple? Or if complete positivity is not enough, maybe <a href=""https://quantumcomputing.stackexchange.com/q/38407"">strict positivity</a>—as an analogue of the requirement for Perron-Frobenius—guarantees such a result, maybe even just for the leading eigenvalue?</p>
</blockquote>
<p>In other words the question is whether trace-preservation, resp. unitality was a <em>necessary</em> assumption in the original result on peripheral eigenvalues of positive, trace-preserving maps, or whether (complete, strict, or just usual) positivity is all one needs.
As a side note this question is of course related to the fact that <a href=""https://math.stackexchange.com/q/4528769"">not every quantum channel is diagonalizable</a>: in the diagonalizable case <a href=""https://en.wikipedia.org/wiki/Semi-simplicity#Semi-simple_matrices"" rel=""nofollow noreferrer"">all eigenvalues are semisimple</a> so any possible counterexample to the above question has to be a non-diagonalizable map.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",qc,peripheral eigenvalues completely positive map always semisimple p known peripheral eigenvalues eigenvalues span c span equals https nofollow noreferrer spectral radius positive em positive em unital maps always https nofollow noreferrer semisimple jordan blocks cf proposition https amp nofollow noreferrer lecture notes michael wolf p sense generalization fact https peripheral eigenvalues stochastic matrix always semisimple well https e2 80 nofollow noreferrer theorem states positive matrices leading eigenvalue always simple motivated latter result following question arises blockquote p given span l n completely positive necessarily trace preserving peripheral eigenvalues span always semisimple complete positivity enough maybe https strict positivity analogue requirement result maybe even leading eigenvalue p words question whether resp unitality em necessary assumption original result peripheral eigenvalues positive maps whether complete strict usual positivity one needs side note question course related fact https every quantum channel diagonalizable diagonalizable case https nofollow noreferrer eigenvalues semisimple possible counterexample question hr p em q amp style question meant contribution https list counterexamples quantum information,"[(3, 0.41544694), (4, 0.07908054), (9, 0.3542176), (11, 0.12376575), (12, 0.012766164), (15, 0.013859044)]"
78628261,,2024-06-16 04:26:59,1,44,"<p>In paper <a href=""https://arxiv.org/abs/2001.00550"" rel=""nofollow noreferrer"">Cost function dependent barren plateaus in shallow
parametrized quantum circuits</a>, the author exhibit an warm-up example in page 2 to show the barren plateau phenomenon. In this example, the author presented cost function and global cost function. Then the variance of global gradient is <img src=""https://latex.codecogs.com/svg.image?Var%5B%5Cfrac%7B%5Cpartial&amp;space;C_%7Bg%7D%7D%7B%5Cpartial%5Ctheta%5E%7Bj%7D%7D%5D=%5Cfrac%7B1%7D%7B8%7D*%5Cfrac%7B3%7D%7B8%7D%5E%7Bn-1%7D"" alt=""image"" />. It is pretty confusing to me about getting the result of this variance, can someone please help me with this calculation?</p>
<p>I have assumed that the variance should be <img src=""https://latex.codecogs.com/svg.image?Var(%5Ctheta)=E(%5Ctheta%5E%7B2%7D)-E%5E%7B2%7D(%5Ctheta)"" alt=""image"" />, and the estimation of x should be <img src=""https://latex.codecogs.com/svg.image?E(x)=%5Cint_%7Ba%7D%5E%7Bb%7Dx*f(x)%5Cmathrm%7Bd%7Dx"" alt=""image"" />, but it is not correct for me to imply these equitions.</p>
",Calculating variance of gradient of barren plateau problem in quantum variational circuit,<gradient><gradient-descent><variance><quantum-computing>,0,0,,,"Calculating variance of gradient of barren plateau problem in quantum variational circuit <p>In paper <a href=""https://arxiv.org/abs/2001.00550"" rel=""nofollow noreferrer"">Cost function dependent barren plateaus in shallow
parametrized quantum circuits</a>, the author exhibit an warm-up example in page 2 to show the barren plateau phenomenon. In this example, the author presented cost function and global cost function. Then the variance of global gradient is <img src=""https://latex.codecogs.com/svg.image?Var%5B%5Cfrac%7B%5Cpartial&amp;space;C_%7Bg%7D%7D%7B%5Cpartial%5Ctheta%5E%7Bj%7D%7D%5D=%5Cfrac%7B1%7D%7B8%7D*%5Cfrac%7B3%7D%7B8%7D%5E%7Bn-1%7D"" alt=""image"" />. It is pretty confusing to me about getting the result of this variance, can someone please help me with this calculation?</p>
<p>I have assumed that the variance should be <img src=""https://latex.codecogs.com/svg.image?Var(%5Ctheta)=E(%5Ctheta%5E%7B2%7D)-E%5E%7B2%7D(%5Ctheta)"" alt=""image"" />, and the estimation of x should be <img src=""https://latex.codecogs.com/svg.image?E(x)=%5Cint_%7Ba%7D%5E%7Bb%7Dx*f(x)%5Cmathrm%7Bd%7Dx"" alt=""image"" />, but it is not correct for me to imply these equitions.</p>
",so_new,calculating variance gradient barren plateau problem quantum variational circuit p paper https nofollow noreferrer cost function dependent barren plateaus shallow parametrized quantum circuits author exhibit example page 2 show barren plateau phenomenon example author presented cost function global cost function variance global gradient img https var 5b 5cfrac 7b 5cpartial amp space 7bg 7d 7d 7b 5cpartial 5ctheta 5e 7bj 7d 7d 5cfrac 7b1 7d 7b8 7d 5cfrac 7b3 7d 7b8 7d 5e 7d image pretty confusing getting result variance someone please help calculation p assumed variance img https var 5ctheta 5ctheta 5e 7b2 7d 5e 7b2 7d 5ctheta image estimation x img https e x 7ba 7d 5e 7bb 7dx f x 5cmathrm 7bd 7dx image correct imply,"[(3, 0.09413031), (4, 0.18503614), (5, 0.1883263), (8, 0.10940755), (10, 0.07216939), (12, 0.18381298), (14, 0.12153201), (15, 0.012726208), (19, 0.031874824)]"
38857,,2024-06-20 19:14:18,2,61,"<p>Hi I have read this <a href=""https://github.com/derek-wang-ibm/coding-with-qiskit/blob/main/episode-5-dynamic-circuits.ipynb"" rel=""nofollow noreferrer"">tutorial</a>, where it used <code>expr</code> to customize classical control for long-range CNOT:</p>
<pre class=""lang-python prettyprint-override""><code>for i in range(num_ancilla_pair):
    qc.measure(2*i + 2, cr1[i])
    if i == 0:
        parity_target = expr.lift(cr1[i])
    else:
        parity_target = expr.bit_xor(cr1[i], parity_target)

with qc.if_test(parity_target):
    qc.x(-1)
</code></pre>
<p>Basically what it does: XOR all the measurement results stored in <code>cr1</code>, and apply X gates based on the XOR result <code>parity_target</code>.</p>
<p>I had checked the <a href=""https://docs.quantum.ibm.com/api/qiskit/circuit_classical"" rel=""nofollow noreferrer"">document</a> of <code>expr</code>, and it seems that currently it only supports simple computation like XOR, NOT, OR, shift, etc.</p>
<p>Now I have more complex classical control, e.g.: <code>cr1[0:2] + 2 * cr2[0:2] &gt;= 3</code>, where <code>+,*</code> is integer addition and multiplication, and <code>cr1[0:2]</code> represents an integer. Can we achieve that by <code>expr</code>?</p>
<p>One way out I think is to convert the inequality over integer field into binary field s.t. we can use <code>expr</code> to implement the expression. E.g. <code>cr1[0:2] = (cr1[0] &lt;&lt; 1) XOR cr1[1]</code>. Theoretically with these operations we can do any dynamic classical controls, but it is tedious.</p>
<p>Do we have simple ways to implement it, or existing tools to do such conversion? How do you deal with similar complex dynamic classical controls? Thanks very much for your reply!</p>
",Complex dynamic classical control over integer field with Qiskit's Expr,<qiskit><measurement>,1,0,,,"Complex dynamic classical control over integer field with Qiskit's Expr <p>Hi I have read this <a href=""https://github.com/derek-wang-ibm/coding-with-qiskit/blob/main/episode-5-dynamic-circuits.ipynb"" rel=""nofollow noreferrer"">tutorial</a>, where it used <code>expr</code> to customize classical control for long-range CNOT:</p>
<pre class=""lang-python prettyprint-override""><code>for i in range(num_ancilla_pair):
    qc.measure(2*i + 2, cr1[i])
    if i == 0:
        parity_target = expr.lift(cr1[i])
    else:
        parity_target = expr.bit_xor(cr1[i], parity_target)

with qc.if_test(parity_target):
    qc.x(-1)
</code></pre>
<p>Basically what it does: XOR all the measurement results stored in <code>cr1</code>, and apply X gates based on the XOR result <code>parity_target</code>.</p>
<p>I had checked the <a href=""https://docs.quantum.ibm.com/api/qiskit/circuit_classical"" rel=""nofollow noreferrer"">document</a> of <code>expr</code>, and it seems that currently it only supports simple computation like XOR, NOT, OR, shift, etc.</p>
<p>Now I have more complex classical control, e.g.: <code>cr1[0:2] + 2 * cr2[0:2] &gt;= 3</code>, where <code>+,*</code> is integer addition and multiplication, and <code>cr1[0:2]</code> represents an integer. Can we achieve that by <code>expr</code>?</p>
<p>One way out I think is to convert the inequality over integer field into binary field s.t. we can use <code>expr</code> to implement the expression. E.g. <code>cr1[0:2] = (cr1[0] &lt;&lt; 1) XOR cr1[1]</code>. Theoretically with these operations we can do any dynamic classical controls, but it is tedious.</p>
<p>Do we have simple ways to implement it, or existing tools to do such conversion? How do you deal with similar complex dynamic classical controls? Thanks very much for your reply!</p>
",qc,complex dynamic classical control integer field qiskit expr p hi read https nofollow noreferrer tutorial used code expr customize classical control cnot pre code range 2 2 cr1 0 cr1 else cr1 p basically xor measurement results stored code cr1 apply x gates based xor result code p checked https nofollow noreferrer document code expr seems currently supports simple computation like xor shift p complex classical control code cr1 2 cr2 gt 3 code integer addition multiplication code cr1 represents integer achieve code expr p one way think convert inequality integer field binary field use code expr implement expression code cr1 cr1 0 lt lt 1 xor cr1 1 theoretically operations dynamic classical controls p simple ways implement existing tools conversion deal similar complex dynamic classical controls thanks much reply,"[(0, 0.112092264), (1, 0.091992795), (2, 0.067027755), (3, 0.020362915), (4, 0.120261535), (7, 0.10380065), (10, 0.010094914), (12, 0.11610042), (14, 0.35741454)]"
38939,,2024-06-27 12:57:07,1,28,"<p>In this simple example I took the Qiskit CX gate, obtained the pulses' schedule and then tried to do Tomography on that. In theory, everything should run smoothly (I think) but I get this &quot;error&quot; message. Does anybody know why / a possible solution to this problem?</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit
from qiskit_ibm_runtime.fake_provider import FakeValencia
from qiskit.circuit import Gate
from qiskit_experiments.library import StateTomography

from qiskit import pulse
from qiskit.pulse import Play, drive_channel, control_channels
from qiskit.pulse.library import GaussianSquare

backend = FakeValencia()

control_qubit = 0 
target_qubit = 1 

# Get the backend defaults which include instruction schedules
backend_defaults = backend.defaults()
inst_sched_map = backend_defaults.instruction_schedule_map

# I want to know the pulse schedule for a CNOT gate
cx_schedule = inst_sched_map.get('cx', (control_qubit, target_qubit))

# Draw the pulse schedule
cx_schedule.draw(backend=backend)

qc = QuantumCircuit(2)

cr_gate = Gate('cr_gate', num_qubits=2, params=[]) # Here we prepare a custom made circuit that does not do anything.

qc.append(cr_gate, [control_qubit, target_qubit])

qc.add_calibration( 'cr_gate', [0,1], cx_schedule ) # Here I added the pulse schedule to characterized the custom gate.

qc.draw()

qst_exp = StateTomography(qc) 
qst_data = qst_exp.run(backend=backend).block_for_results()
</code></pre>
<p>Here's the error message:</p>
<pre><code>Adding a job from a backend (AerSimulator('aer_simulator'
             noise_model=&lt;NoiseModel on ['sx', 'measure', 'x', 'id', 'cx']&gt;)) that is different than the current backend (fake_valencia). The new backend will be used, but service is not changed if one already exists.
jobs and analysis raised exceptions [Experiment ID: 22a13973-b7cd-4fac-9f4c-a011c99651a0]:Traceback (most recent call last):
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/site-packages/qiskit_experiments/framework/experiment_data.py&quot;, line 852, in _add_job_data
    job_result = job.result()
                 ^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/site-packages/qiskit_aer/jobs/utils.py&quot;, line 42, in _wrapper
    return func(self, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/site-packages/qiskit_aer/jobs/aerjob.py&quot;, line 114, in result
    return self._future.result(timeout=timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/concurrent/futures/_base.py&quot;, line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/concurrent/futures/_base.py&quot;, line 401, in __get_result
    raise self._exception
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/concurrent/futures/thread.py&quot;, line 58, in run
    result = self.fn(*self.args, **self.kwargs)
...
    ^^^^^^^^^^^^^^^^^
AttributeError: 'AerJob' object has no attribute 'error_message'&quot;
</code></pre>
",Doing Quantum State Tomography on a custom-made gate with Qiskit Pulse,<qiskit><quantum-gate><state-tomography>,0,0,,,"Doing Quantum State Tomography on a custom-made gate with Qiskit Pulse <p>In this simple example I took the Qiskit CX gate, obtained the pulses' schedule and then tried to do Tomography on that. In theory, everything should run smoothly (I think) but I get this &quot;error&quot; message. Does anybody know why / a possible solution to this problem?</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit
from qiskit_ibm_runtime.fake_provider import FakeValencia
from qiskit.circuit import Gate
from qiskit_experiments.library import StateTomography

from qiskit import pulse
from qiskit.pulse import Play, drive_channel, control_channels
from qiskit.pulse.library import GaussianSquare

backend = FakeValencia()

control_qubit = 0 
target_qubit = 1 

# Get the backend defaults which include instruction schedules
backend_defaults = backend.defaults()
inst_sched_map = backend_defaults.instruction_schedule_map

# I want to know the pulse schedule for a CNOT gate
cx_schedule = inst_sched_map.get('cx', (control_qubit, target_qubit))

# Draw the pulse schedule
cx_schedule.draw(backend=backend)

qc = QuantumCircuit(2)

cr_gate = Gate('cr_gate', num_qubits=2, params=[]) # Here we prepare a custom made circuit that does not do anything.

qc.append(cr_gate, [control_qubit, target_qubit])

qc.add_calibration( 'cr_gate', [0,1], cx_schedule ) # Here I added the pulse schedule to characterized the custom gate.

qc.draw()

qst_exp = StateTomography(qc) 
qst_data = qst_exp.run(backend=backend).block_for_results()
</code></pre>
<p>Here's the error message:</p>
<pre><code>Adding a job from a backend (AerSimulator('aer_simulator'
             noise_model=&lt;NoiseModel on ['sx', 'measure', 'x', 'id', 'cx']&gt;)) that is different than the current backend (fake_valencia). The new backend will be used, but service is not changed if one already exists.
jobs and analysis raised exceptions [Experiment ID: 22a13973-b7cd-4fac-9f4c-a011c99651a0]:Traceback (most recent call last):
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/site-packages/qiskit_experiments/framework/experiment_data.py&quot;, line 852, in _add_job_data
    job_result = job.result()
                 ^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/site-packages/qiskit_aer/jobs/utils.py&quot;, line 42, in _wrapper
    return func(self, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/site-packages/qiskit_aer/jobs/aerjob.py&quot;, line 114, in result
    return self._future.result(timeout=timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/concurrent/futures/_base.py&quot;, line 449, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/concurrent/futures/_base.py&quot;, line 401, in __get_result
    raise self._exception
  File &quot;/opt/anaconda3/envs/cwd/lib/python3.12/concurrent/futures/thread.py&quot;, line 58, in run
    result = self.fn(*self.args, **self.kwargs)
...
    ^^^^^^^^^^^^^^^^^
AttributeError: 'AerJob' object has no attribute 'error_message'&quot;
</code></pre>
",qc,quantum state tomography gate qiskit pulse p simple example took qiskit cx gate obtained pulses schedule tried tomography theory everything run smoothly think get quot error quot message anybody know possible solution problem pre code import qiskit qiskit import quantumcircuit import fakevalencia import gate import statetomography qiskit import pulse import play import gaussiansquare backend fakevalencia 0 1 get backend defaults include instruction schedules want know pulse schedule cnot gate draw pulse schedule qc quantumcircuit 2 gate prepare custom made circuit anything added pulse schedule characterized custom gate statetomography qc p error message pre code adding job backend aersimulator lt noisemodel x gt different current backend new backend used service changed one already exists jobs analysis raised exceptions experiment id traceback recent call last file quot quot line 852 file quot quot line 42 return func self args kwargs file quot quot line 114 result return file quot quot line 449 result return file quot quot line 401 raise file quot quot line 58 run result attributeerror object attribute quot,"[(0, 0.49313763), (9, 0.0434161), (12, 0.02426833), (14, 0.24497987), (19, 0.18672712)]"
38970,,2024-07-01 09:38:34,0,35,"<p>Parameterized quantum circuits (PQCs) are a key component in many quantum machine learning (QML) and variational quantum algorithms, such as the Variational Quantum Eigensolver (VQE) and quantum neural networks.</p>
<p>I have heard that PQCs can be viewed as highly expressive machine learning models, with the ability to represent a wide range of functions. And this stems from the exponential size of the Hilbert space, which allows PQCs to potentially capture complex patterns in data more efficiently than classical models. Could someone give references for such statements?</p>
<p>I know that there are no provable advantages(w.r.t the classical counterparts) to using PQCs in NISQ era. But what exactly is the thinking behind what could be the possible advantage? Looking for mathematical reasons for the same.</p>
",motivation behind using PQCs in QML and Variational Algorithms,<quantum-enhanced-machine-learning><variational-quantum-algorithms>,0,1,,,"motivation behind using PQCs in QML and Variational Algorithms <p>Parameterized quantum circuits (PQCs) are a key component in many quantum machine learning (QML) and variational quantum algorithms, such as the Variational Quantum Eigensolver (VQE) and quantum neural networks.</p>
<p>I have heard that PQCs can be viewed as highly expressive machine learning models, with the ability to represent a wide range of functions. And this stems from the exponential size of the Hilbert space, which allows PQCs to potentially capture complex patterns in data more efficiently than classical models. Could someone give references for such statements?</p>
<p>I know that there are no provable advantages(w.r.t the classical counterparts) to using PQCs in NISQ era. But what exactly is the thinking behind what could be the possible advantage? Looking for mathematical reasons for the same.</p>
",qc,motivation behind using pqcs qml variational algorithms p parameterized quantum circuits pqcs key component many quantum machine learning qml variational quantum algorithms variational quantum eigensolver vqe quantum neural p heard pqcs viewed highly expressive machine learning models ability represent wide range functions stems exponential size hilbert space allows pqcs potentially capture complex patterns data efficiently classical models could someone give references statements p know provable advantages classical counterparts using pqcs nisq era exactly thinking behind could possible advantage looking mathematical reasons,"[(1, 0.092992276), (3, 0.046839148), (6, 0.011686984), (7, 0.088107), (8, 0.53822035), (9, 0.0949305), (12, 0.06395552), (14, 0.061764996)]"
39021,,2024-07-04 19:50:48,3,60,"<p>A gate <span class=""math-container"">$U= (u_{ij})_{i,j= 1}^4$</span> is symmetric if the action of the gate is the same as the action of <span class=""math-container"">$Swap\ U\ Swap$</span> where the swap gate is <span class=""math-container"">$$Swap= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}$$</span></p>
<p>Then computing gives <span class=""math-container"">$Swap\ U\ Swap= Swap\ \begin{pmatrix} u_{11} &amp; u_{13} &amp; u_{12} &amp; u_{14} \\
u_{21} &amp; u_{23} &amp; u_{22} &amp; u_{24} \\
u_{31} &amp; u_{33} &amp; u_{32} &amp; u_{34} \\
u_{41} &amp; u_{43} &amp; u_{42} &amp; u_{44} \end{pmatrix}= \begin{pmatrix} u_{11} &amp; u_{13} &amp; u_{12} &amp; u_{14} \\
u_{31} &amp; u_{33} &amp; u_{32} &amp; u_{34} \\
u_{21} &amp; u_{23} &amp; u_{22} &amp; u_{24} \\
u_{41} &amp; u_{43} &amp; u_{42} &amp; u_{44} \end{pmatrix}$</span></p>
<p>and the two matrices are equal exactly when <span class=""math-container"">$u_{13}= u_{12},\ u_{43}= u_{42},\ u_{31}= u_{21},\ u_{33}= u_{22},\ u_{32}= u_{23},\ u_{34}= u_{24}$</span>, which completely characterizes symmetric gates to be of the form <span class=""math-container"">$$\begin{pmatrix} u_{11} &amp; a &amp; a &amp; u_{14}\\
d &amp; b &amp; c &amp; e\\
d &amp; c &amp; b &amp; e\\
u_{41} &amp; f &amp; f &amp; u_{44} \end{pmatrix}$$</span></p>
<p>This also tells us that a controlled-U is symmetric exactly when that <span class=""math-container"">$U$</span> is a Phase gate <span class=""math-container"">$P=\begin{pmatrix} 1 &amp; 0\\
0 &amp; e^{i\lambda}\end{pmatrix}$</span></p>
<p>Is this correct or am I missing something?</p>
<p>I wonder if there are known symmetric gates which are implemented in the existing hardware (in IBM Qiskit) besides the controlled-P (CZ being under this case).</p>
",What do symmetric 2-qubits gates look like?,<quantum-gate>,0,6,,,"What do symmetric 2-qubits gates look like? <p>A gate <span class=""math-container"">$U= (u_{ij})_{i,j= 1}^4$</span> is symmetric if the action of the gate is the same as the action of <span class=""math-container"">$Swap\ U\ Swap$</span> where the swap gate is <span class=""math-container"">$$Swap= \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix}$$</span></p>
<p>Then computing gives <span class=""math-container"">$Swap\ U\ Swap= Swap\ \begin{pmatrix} u_{11} &amp; u_{13} &amp; u_{12} &amp; u_{14} \\
u_{21} &amp; u_{23} &amp; u_{22} &amp; u_{24} \\
u_{31} &amp; u_{33} &amp; u_{32} &amp; u_{34} \\
u_{41} &amp; u_{43} &amp; u_{42} &amp; u_{44} \end{pmatrix}= \begin{pmatrix} u_{11} &amp; u_{13} &amp; u_{12} &amp; u_{14} \\
u_{31} &amp; u_{33} &amp; u_{32} &amp; u_{34} \\
u_{21} &amp; u_{23} &amp; u_{22} &amp; u_{24} \\
u_{41} &amp; u_{43} &amp; u_{42} &amp; u_{44} \end{pmatrix}$</span></p>
<p>and the two matrices are equal exactly when <span class=""math-container"">$u_{13}= u_{12},\ u_{43}= u_{42},\ u_{31}= u_{21},\ u_{33}= u_{22},\ u_{32}= u_{23},\ u_{34}= u_{24}$</span>, which completely characterizes symmetric gates to be of the form <span class=""math-container"">$$\begin{pmatrix} u_{11} &amp; a &amp; a &amp; u_{14}\\
d &amp; b &amp; c &amp; e\\
d &amp; c &amp; b &amp; e\\
u_{41} &amp; f &amp; f &amp; u_{44} \end{pmatrix}$$</span></p>
<p>This also tells us that a controlled-U is symmetric exactly when that <span class=""math-container"">$U$</span> is a Phase gate <span class=""math-container"">$P=\begin{pmatrix} 1 &amp; 0\\
0 &amp; e^{i\lambda}\end{pmatrix}$</span></p>
<p>Is this correct or am I missing something?</p>
<p>I wonder if there are known symmetric gates which are implemented in the existing hardware (in IBM Qiskit) besides the controlled-P (CZ being under this case).</p>
",qc,symmetric gates look like p gate span ij 1 symmetric action gate action span swap swap gate span pmatrix 1 amp 0 amp 0 amp 0 0 amp 0 amp 1 amp 0 0 amp 1 amp 0 amp 0 0 amp 0 amp 0 amp 1 pmatrix p computing gives span pmatrix 11 amp 13 amp 12 amp 14 21 amp 23 amp 22 amp 24 31 amp 33 amp 32 amp 34 41 amp 43 amp 42 amp 44 pmatrix pmatrix 11 amp 13 amp 12 amp 14 31 amp 33 amp 32 amp 34 21 amp 23 amp 22 amp 24 41 amp 43 amp 42 amp 44 pmatrix p two matrices equal exactly span 13 12 43 42 31 21 33 22 32 23 34 24 completely characterizes symmetric gates form span pmatrix 11 amp amp amp 14 amp b amp c amp amp c amp b amp 41 amp f amp f amp 44 pmatrix p also tells us symmetric exactly span u phase gate span pmatrix 1 amp 0 amp pmatrix p correct missing something p wonder known symmetric gates implemented existing hardware ibm qiskit besides cz case,"[(2, 0.07277967), (6, 0.12661593), (9, 0.0383512), (10, 0.011157849), (12, 0.017080152), (14, 0.034863655), (15, 0.69848186)]"
39090,,2024-07-10 12:40:21,1,73,"<p>I am using Qiskit to implement QAOA for a max-cut problem. I am using inbuilt qiskit implemetation of QAOA and, the MinimuEigenOptimizer. The MinimuEigenOptimizer.solve() throws the warning.</p>
<p>AttributeError: 'SparsePauliOp' object has no attribute 'primitive_strings'</p>
<p>I am new to Qiskit, any help will be appreciated!</p>
<p>Below is the code:</p>
<pre><code>from qiskit.algorithms import QAOA
from qiskit_optimization.algorithms import MinimumEigenOptimizer
backend = Aer.get_backend('statevector_simulator')
qaoa = QAOA(optimizer = ADAM(), quantum_instance = backend, reps=1, initial_point=[0.1,0.1])
eigen_optimizer = MinimumEigenOptimizer(min_eigen_solver = qaoa)
quadratic_program = quadratic_program_from_graph(graphs['custom'])
result = eigen_optimizer.solve(quadratic_program)
print(result)
</code></pre>
<p>the deprecation warning:
The class <code>qiskit.algorithms.minimum_eigen_solvers.qaoa.QAOA</code> is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class <code>qiskit.algorithms.minimum_eigensolvers.QAOA</code>. See <a href=""https://qisk.it/algo_migration"" rel=""nofollow noreferrer"">https://qisk.it/algo_migration</a> for a migration guide.</p>
<p>and the warning:</p>
<pre><code>AttributeError                            Traceback (most recent call last) 
Cell In[59], line 7
      5 eigen_optimizer = MinimumEigenOptimizer(min_eigen_solver = qaoa)
      6 quadratic_program = quadratic_program_from_graph(graphs['custom'])
----&gt; 7 result = eigen_optimizer.solve(quadratic_program)
      8 print(result)

File ~\anaconda3\envs\QAlgobase\Lib\site-  packages\qiskit_optimization\algorithms\minimum_eigen_optimizer.py:205, in     MinimumEigenOptimizer.solve(self, problem)
    202 # construct operator and offset
    203 operator, offset = problem_.to_ising()
--&gt; 205 return self._solve_internal(operator, offset, problem_, problem)

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit_optimization\algorithms\minimum_eigen_optimizer.py:218, in MinimumEigenOptimizer._solve_internal(self, operator, offset, converted_problem, original_problem)
    215 eigen_result: Optional[MinimumEigensolverResult] = None
    216 if operator.num_qubits &gt; 0:
    217     # approximate ground state of operator using min eigen solver
--&gt; 218     eigen_result = self._min_eigen_solver.compute_minimum_eigenvalue(operator)
    219     # analyze results
    220     raw_samples = None

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py:536, in VQE.compute_minimum_eigenvalue(self, operator, aux_operators)
    533     gradient = self._gradient
    535 self._eval_count = 0
--&gt; 536 energy_evaluation, expectation = self.get_energy_evaluation(
    537     operator, return_expectation=True
    538 )
    540 start_time = time()
    542 if callable(self.optimizer):

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py:613, in VQE.get_energy_evaluation(self, operator, return_expectation)
    610     raise RuntimeError(&quot;The ansatz must be parameterized, but has 0 free parameters.&quot;)
    612 ansatz_params = self.ansatz.parameters
--&gt; 613 expect_op, expectation = self.construct_expectation(
    614     ansatz_params, operator, return_expectation=True
    615 )
    617 def energy_evaluation(parameters):
    618     parameter_sets = np.reshape(parameters, (-1, num_parameters))

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py:431, in VQE.construct_expectation(self, parameter, operator, return_expectation)
    429 # if expectation was never created, try to create one
    430 if self.expectation is None:
--&gt; 431     expectation = ExpectationFactory.build(
    432         operator=operator,
    433         backend=self.quantum_instance,
    434         include_custom=self._include_custom,
    435     )
    436 else:
    437     expectation = self.expectation

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\utils\deprecation.py:96, in deprecate_func.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
     93 @functools.wraps(func)
     94 def wrapper(*args, **kwargs):
     95     warnings.warn(msg, category=category, stacklevel=2)
---&gt; 96     return func(*args, **kwargs)

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\opflow\expectations\expectation_factory.py:74, in ExpectationFactory.build(operator, backend, include_custom)
     71 backend_to_check = backend.backend if isinstance(backend, QuantumInstance) else backend
     73 # pylint: disable=cyclic-import
---&gt; 74 primitives = operator.primitive_strings()
     75 if primitives in ({&quot;Pauli&quot;}, {&quot;SparsePauliOp&quot;}):
     77     if backend_to_check is None:
     78         # If user has Aer but didn't specify a backend, use the Aer fast expectation

AttributeError: 'SparsePauliOp' object has no attribute 'primitive_strings' '''
</code></pre>
",SparsePauliOp' object has no attribute 'primitive_strings' warning for a max-cut problem using QAOA and MinimuEigenOptimizer,<qiskit><programming><vqe><qaoa>,0,0,,,"SparsePauliOp' object has no attribute 'primitive_strings' warning for a max-cut problem using QAOA and MinimuEigenOptimizer <p>I am using Qiskit to implement QAOA for a max-cut problem. I am using inbuilt qiskit implemetation of QAOA and, the MinimuEigenOptimizer. The MinimuEigenOptimizer.solve() throws the warning.</p>
<p>AttributeError: 'SparsePauliOp' object has no attribute 'primitive_strings'</p>
<p>I am new to Qiskit, any help will be appreciated!</p>
<p>Below is the code:</p>
<pre><code>from qiskit.algorithms import QAOA
from qiskit_optimization.algorithms import MinimumEigenOptimizer
backend = Aer.get_backend('statevector_simulator')
qaoa = QAOA(optimizer = ADAM(), quantum_instance = backend, reps=1, initial_point=[0.1,0.1])
eigen_optimizer = MinimumEigenOptimizer(min_eigen_solver = qaoa)
quadratic_program = quadratic_program_from_graph(graphs['custom'])
result = eigen_optimizer.solve(quadratic_program)
print(result)
</code></pre>
<p>the deprecation warning:
The class <code>qiskit.algorithms.minimum_eigen_solvers.qaoa.QAOA</code> is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class <code>qiskit.algorithms.minimum_eigensolvers.QAOA</code>. See <a href=""https://qisk.it/algo_migration"" rel=""nofollow noreferrer"">https://qisk.it/algo_migration</a> for a migration guide.</p>
<p>and the warning:</p>
<pre><code>AttributeError                            Traceback (most recent call last) 
Cell In[59], line 7
      5 eigen_optimizer = MinimumEigenOptimizer(min_eigen_solver = qaoa)
      6 quadratic_program = quadratic_program_from_graph(graphs['custom'])
----&gt; 7 result = eigen_optimizer.solve(quadratic_program)
      8 print(result)

File ~\anaconda3\envs\QAlgobase\Lib\site-  packages\qiskit_optimization\algorithms\minimum_eigen_optimizer.py:205, in     MinimumEigenOptimizer.solve(self, problem)
    202 # construct operator and offset
    203 operator, offset = problem_.to_ising()
--&gt; 205 return self._solve_internal(operator, offset, problem_, problem)

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit_optimization\algorithms\minimum_eigen_optimizer.py:218, in MinimumEigenOptimizer._solve_internal(self, operator, offset, converted_problem, original_problem)
    215 eigen_result: Optional[MinimumEigensolverResult] = None
    216 if operator.num_qubits &gt; 0:
    217     # approximate ground state of operator using min eigen solver
--&gt; 218     eigen_result = self._min_eigen_solver.compute_minimum_eigenvalue(operator)
    219     # analyze results
    220     raw_samples = None

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py:536, in VQE.compute_minimum_eigenvalue(self, operator, aux_operators)
    533     gradient = self._gradient
    535 self._eval_count = 0
--&gt; 536 energy_evaluation, expectation = self.get_energy_evaluation(
    537     operator, return_expectation=True
    538 )
    540 start_time = time()
    542 if callable(self.optimizer):

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py:613, in VQE.get_energy_evaluation(self, operator, return_expectation)
    610     raise RuntimeError(&quot;The ansatz must be parameterized, but has 0 free parameters.&quot;)
    612 ansatz_params = self.ansatz.parameters
--&gt; 613 expect_op, expectation = self.construct_expectation(
    614     ansatz_params, operator, return_expectation=True
    615 )
    617 def energy_evaluation(parameters):
    618     parameter_sets = np.reshape(parameters, (-1, num_parameters))

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\algorithms\minimum_eigen_solvers\vqe.py:431, in VQE.construct_expectation(self, parameter, operator, return_expectation)
    429 # if expectation was never created, try to create one
    430 if self.expectation is None:
--&gt; 431     expectation = ExpectationFactory.build(
    432         operator=operator,
    433         backend=self.quantum_instance,
    434         include_custom=self._include_custom,
    435     )
    436 else:
    437     expectation = self.expectation

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\utils\deprecation.py:96, in deprecate_func.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
     93 @functools.wraps(func)
     94 def wrapper(*args, **kwargs):
     95     warnings.warn(msg, category=category, stacklevel=2)
---&gt; 96     return func(*args, **kwargs)

File ~\anaconda3\envs\QAlgobase\Lib\site-packages\qiskit\opflow\expectations\expectation_factory.py:74, in ExpectationFactory.build(operator, backend, include_custom)
     71 backend_to_check = backend.backend if isinstance(backend, QuantumInstance) else backend
     73 # pylint: disable=cyclic-import
---&gt; 74 primitives = operator.primitive_strings()
     75 if primitives in ({&quot;Pauli&quot;}, {&quot;SparsePauliOp&quot;}):
     77     if backend_to_check is None:
     78         # If user has Aer but didn't specify a backend, use the Aer fast expectation

AttributeError: 'SparsePauliOp' object has no attribute 'primitive_strings' '''
</code></pre>
",qc,sparsepauliop object attribute warning problem using qaoa minimueigenoptimizer p using qiskit implement qaoa problem using inbuilt qiskit implemetation qaoa minimueigenoptimizer throws p attributeerror object attribute p new qiskit help appreciated p code pre code import qaoa import minimumeigenoptimizer backend qaoa qaoa optimizer adam backend minimumeigenoptimizer qaoa graphs result print result p deprecation warning class code deprecated removed earlier 3 months release date instead use class code see https nofollow noreferrer https migration p warning pre code attributeerror traceback recent call last cell 59 line 7 5 minimumeigenoptimizer qaoa 6 graphs gt 7 result 8 print result file self problem 202 construct operator offset 203 operator offset gt 205 return operator offset problem file self operator offset 215 optional minimumeigensolverresult none 216 gt 0 217 approximate ground state operator using min eigen solver gt 218 operator 219 analyze results 220 none file self operator 533 gradient 535 0 gt 536 expectation 537 operator 538 540 time 542 callable file self operator 610 raise runtimeerror quot ansatz must parameterized 0 free quot 612 gt 613 expectation 614 operator 615 617 def parameters 618 parameters file self parameter operator 429 expectation never created try create one 430 none gt 431 expectation 432 433 434 435 436 else 437 expectation file lt locals gt lt locals gt args kwargs 93 func 94 def wrapper args kwargs 95 msg gt 96 return func args kwargs file operator backend 71 isinstance backend quantuminstance else backend 73 pylint gt 74 primitives 75 primitives quot pauli quot quot sparsepauliop quot 77 none 78 user aer specify backend use aer fast expectation attributeerror object attribute,"[(0, 0.8191933), (4, 0.01429311), (5, 0.014101111), (6, 0.022180995), (8, 0.0142811835), (12, 0.022302495), (14, 0.042084858), (19, 0.051087573)]"
39099,39100.0,2024-07-11 10:44:10,0,58,"<p>I'm learning Stim with <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">the official tutorial</a> and have a question.
I made a small program:</p>
<pre><code>for rounds in range(1, 20):
    p = 0.001
    circuit = stim.Circuit.generated(
        'surface_code:rotated_memory_z',
        rounds=rounds,
        distance=5,
        after_clifford_depolarization=p,
        before_round_data_depolarization=p,
        before_measure_flip_probability=p,
        after_reset_flip_probability=p)
    num_shots = 1_000_000
    num_logical_errors = count_logical_errors(circuit, num_shots)
    print(&quot;there were {} wrong predictions (logical errors) out of {} shots with {} rounds&quot;.format(num_logical_errors, num_shots, rounds))
</code></pre>
<p>I copied <code>count_logical_errors</code> from <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">the tutorial</a>.
I expected that the number of logical errors with <code>rounds=2</code> is less than that with <code>rounds=1</code>, but the execution result said otherwise:</p>
<pre><code>there were 18 wrong predictions (logical errors) out of 1000000 shots with 1 rounds
there were 49 wrong predictions (logical errors) out of 1000000 shots with 2 rounds
there were 75 wrong predictions (logical errors) out of 1000000 shots with 3 rounds
there were 94 wrong predictions (logical errors) out of 1000000 shots with 4 rounds
there were 127 wrong predictions (logical errors) out of 1000000 shots with 5 rounds
there were 168 wrong predictions (logical errors) out of 1000000 shots with 6 rounds
there were 179 wrong predictions (logical errors) out of 1000000 shots with 7 rounds
there were 221 wrong predictions (logical errors) out of 1000000 shots with 8 rounds
there were 235 wrong predictions (logical errors) out of 1000000 shots with 9 rounds
there were 248 wrong predictions (logical errors) out of 1000000 shots with 10 rounds
there were 299 wrong predictions (logical errors) out of 1000000 shots with 11 rounds
there were 344 wrong predictions (logical errors) out of 1000000 shots with 12 rounds
there were 386 wrong predictions (logical errors) out of 1000000 shots with 13 rounds
there were 382 wrong predictions (logical errors) out of 1000000 shots with 14 rounds
there were 400 wrong predictions (logical errors) out of 1000000 shots with 15 rounds
there were 448 wrong predictions (logical errors) out of 1000000 shots with 16 rounds
there were 471 wrong predictions (logical errors) out of 1000000 shots with 17 rounds
there were 541 wrong predictions (logical errors) out of 1000000 shots with 18 rounds
there were 557 wrong predictions (logical errors) out of 1000000 shots with 19 rounds
</code></pre>
<p>Is my expectation wrong, or is there anything wrong with the above code?</p>
<p>Thanks,</p>
",Effect of rounds in surface-code simulation with Stim,<error-correction><stim>,1,0,,,"Effect of rounds in surface-code simulation with Stim <p>I'm learning Stim with <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">the official tutorial</a> and have a question.
I made a small program:</p>
<pre><code>for rounds in range(1, 20):
    p = 0.001
    circuit = stim.Circuit.generated(
        'surface_code:rotated_memory_z',
        rounds=rounds,
        distance=5,
        after_clifford_depolarization=p,
        before_round_data_depolarization=p,
        before_measure_flip_probability=p,
        after_reset_flip_probability=p)
    num_shots = 1_000_000
    num_logical_errors = count_logical_errors(circuit, num_shots)
    print(&quot;there were {} wrong predictions (logical errors) out of {} shots with {} rounds&quot;.format(num_logical_errors, num_shots, rounds))
</code></pre>
<p>I copied <code>count_logical_errors</code> from <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">the tutorial</a>.
I expected that the number of logical errors with <code>rounds=2</code> is less than that with <code>rounds=1</code>, but the execution result said otherwise:</p>
<pre><code>there were 18 wrong predictions (logical errors) out of 1000000 shots with 1 rounds
there were 49 wrong predictions (logical errors) out of 1000000 shots with 2 rounds
there were 75 wrong predictions (logical errors) out of 1000000 shots with 3 rounds
there were 94 wrong predictions (logical errors) out of 1000000 shots with 4 rounds
there were 127 wrong predictions (logical errors) out of 1000000 shots with 5 rounds
there were 168 wrong predictions (logical errors) out of 1000000 shots with 6 rounds
there were 179 wrong predictions (logical errors) out of 1000000 shots with 7 rounds
there were 221 wrong predictions (logical errors) out of 1000000 shots with 8 rounds
there were 235 wrong predictions (logical errors) out of 1000000 shots with 9 rounds
there were 248 wrong predictions (logical errors) out of 1000000 shots with 10 rounds
there were 299 wrong predictions (logical errors) out of 1000000 shots with 11 rounds
there were 344 wrong predictions (logical errors) out of 1000000 shots with 12 rounds
there were 386 wrong predictions (logical errors) out of 1000000 shots with 13 rounds
there were 382 wrong predictions (logical errors) out of 1000000 shots with 14 rounds
there were 400 wrong predictions (logical errors) out of 1000000 shots with 15 rounds
there were 448 wrong predictions (logical errors) out of 1000000 shots with 16 rounds
there were 471 wrong predictions (logical errors) out of 1000000 shots with 17 rounds
there were 541 wrong predictions (logical errors) out of 1000000 shots with 18 rounds
there were 557 wrong predictions (logical errors) out of 1000000 shots with 19 rounds
</code></pre>
<p>Is my expectation wrong, or is there anything wrong with the above code?</p>
<p>Thanks,</p>
",qc,effect rounds simulation stim p learning stim https nofollow noreferrer official tutorial question made small program pre code rounds range 1 20 p circuit circuit print quot wrong predictions logical errors shots rounds quot rounds p copied code https nofollow noreferrer tutorial expected number logical errors code less code execution result said otherwise pre code 18 wrong predictions logical errors 1000000 shots 1 rounds 49 wrong predictions logical errors 1000000 shots 2 rounds 75 wrong predictions logical errors 1000000 shots 3 rounds 94 wrong predictions logical errors 1000000 shots 4 rounds 127 wrong predictions logical errors 1000000 shots 5 rounds 168 wrong predictions logical errors 1000000 shots 6 rounds 179 wrong predictions logical errors 1000000 shots 7 rounds 221 wrong predictions logical errors 1000000 shots 8 rounds 235 wrong predictions logical errors 1000000 shots 9 rounds 248 wrong predictions logical errors 1000000 shots 10 rounds 299 wrong predictions logical errors 1000000 shots 11 rounds 344 wrong predictions logical errors 1000000 shots 12 rounds 386 wrong predictions logical errors 1000000 shots 13 rounds 382 wrong predictions logical errors 1000000 shots 14 rounds 400 wrong predictions logical errors 1000000 shots 15 rounds 448 wrong predictions logical errors 1000000 shots 16 rounds 471 wrong predictions logical errors 1000000 shots 17 rounds 541 wrong predictions logical errors 1000000 shots 18 rounds 557 wrong predictions logical errors 1000000 shots 19 rounds p expectation wrong anything wrong code p thanks,"[(0, 0.07420562), (4, 0.046125036), (5, 0.24850285), (6, 0.40048784), (12, 0.012751519), (14, 0.19615433), (19, 0.021207381)]"
39126,,2024-07-12 17:18:46,3,53,"<p>In Nielsen Chuang section 2.2.6 as they are introducing POVMs they write “The acronym POVM stands for ‘Positive Operator-Valued Measure’, a technical term whose historical origins we won’t worry about.” I was curious and tried to google the origin of the term and got absolutely nothing. Understanding the origins of terms tends to help me keep them all straight. Does anyone know where the term came from?</p>
",What is the origin of the term POVM?,<measurement><nielsen-and-chuang><terminology-and-notation><povm><history>,0,2,,,"What is the origin of the term POVM? <p>In Nielsen Chuang section 2.2.6 as they are introducing POVMs they write “The acronym POVM stands for ‘Positive Operator-Valued Measure’, a technical term whose historical origins we won’t worry about.” I was curious and tried to google the origin of the term and got absolutely nothing. Understanding the origins of terms tends to help me keep them all straight. Does anyone know where the term came from?</p>
",qc,origin term povm p nielsen chuang section introducing povms write acronym povm stands positive measure technical term whose historical origins worry curious tried google origin term got absolutely nothing understanding origins terms tends help keep straight anyone know term came,"[(3, 0.46845677), (8, 0.067797735), (9, 0.21598387), (12, 0.07590404), (13, 0.14322329), (16, 0.025145078)]"
39337,39339.0,2024-07-27 15:30:50,0,68,"<p>I have some old version <code>qiskit==0.46</code> code which uses an API as below:</p>
<pre><code>from qiskit.opflow import MatrixOp
H_op = MatrixOp(Hamiltonian).to_pauli_op() 
</code></pre>
<p>After much study, I tried to replace it latest <code>qiskit==1.0</code> API, which has the below syntax:</p>
<pre><code>from qiskit.quantum_info import SparsePauliOp
 H_op = SparsePauliOp(Hamiltonian).to_operator()
</code></pre>
<p>But this is not correct. It gives me some error : <code>qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.'</code>
It would be great if I can be helped on this.</p>
<p><strong>Edit1</strong>
Question updated with the Hamiltonian.</p>
<pre><code>(Pdb) Hamiltonian
array([[ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
       [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
       [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
       [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
</code></pre>
",qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.',<qiskit><programming>,2,3,,,"qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.' <p>I have some old version <code>qiskit==0.46</code> code which uses an API as below:</p>
<pre><code>from qiskit.opflow import MatrixOp
H_op = MatrixOp(Hamiltonian).to_pauli_op() 
</code></pre>
<p>After much study, I tried to replace it latest <code>qiskit==1.0</code> API, which has the below syntax:</p>
<pre><code>from qiskit.quantum_info import SparsePauliOp
 H_op = SparsePauliOp(Hamiltonian).to_operator()
</code></pre>
<p>But this is not correct. It gives me some error : <code>qiskit.exceptions.QiskitError: 'Invalid input data for Pauli.'</code>
It would be great if I can be helped on this.</p>
<p><strong>Edit1</strong>
Question updated with the Hamiltonian.</p>
<pre><code>(Pdb) Hamiltonian
array([[ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
       [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
       [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
       [-1.05164319,  1.37558685, -3.54929577,  3.79812207]])
</code></pre>
",qc,input data pauli p old version code code uses api pre code import matrixop matrixop hamiltonian p much study tried replace latest code api syntax pre code import sparsepauliop sparsepauliop hamiltonian p correct gives error code input data pauli would great helped p strong edit1 question updated pre code pdb hamiltonian array,"[(0, 0.49805862), (1, 0.10923549), (2, 0.018287396), (5, 0.2534775), (12, 0.058251847), (16, 0.059999246)]"
39344,39345.0,2024-07-27 21:41:32,2,460,"<p>I have a old version of <code>qiskit==0.46</code> code which uses the below syntax:</p>
<pre><code>quantum_instance = QuantumInstance(backend= backend,
                                                shots= self.shots_done,   
                                                seed_simulator= 28,   
                                                seed_transpiler= 28,
                                                basis_gates= None,
                                                optimization_level=self.optimization_level_used)
</code></pre>
<p>This API no longer works in the latest version of <code>qiskit==1.0</code>.
Please suggest me a API which exactly do this function in the latest <code>qiskit==1.0</code>?</p>
<p><strong>Edit1</strong>
Explaining the problem more clearly. Below is the complete code:</p>
<pre><code>from qiskit_aer import AerSimulator
import numpy as np
from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2
# from qiskit.utils import QuantumInstance # Need to replace it with something else
from qiskit_algorithms import VQE



 Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = SparsePauliOp.from_operator(Hamiltonian)
ansatz = EfficientSU2(num_qubits=num_qubits,
                                entanglement= 'linear',
                                reps= depth,
                                skip_final_rotation_layer= True)
    
backend = AerSimulator()

ansatz_opt = transpile(circuits=ansatz,
                         backend = backend,
                          optimization_level =self.optimization_level_used)
            
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                    shots= 1000,                                                   
                                   seed_simulator= 28,  
                                   seed_transpiler= 28,
                                   basis_gates= None,
                                   optimization_level=1)
    
           
           
initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
          optimizer= optimizer,
          quantum_instance=quantum_instance,
           initial_point=initial_point_values
          )
</code></pre>
<p>This code fails at <code>QuantumInstance</code> when I use the <code>qiskit==1.0</code>? Need some substitute for <code>QuantumInstance</code>?</p>
<p><strong>Edit2</strong>
This code works on <code>qiskit==0.46</code>. Just to be sure I am not missing anything,the other qiskit related packages in my conda env are :<br />
<code>qiskit-aer==0.13.3</code> , <code>qiskit-ibmq-provider==0.20.2</code>, <code>qiskit-terra==0.46.0</code></p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA

from qiskit.utils import QuantumInstance
from qiskit.algorithms import VQE
backend = Aer.get_backend('qasm_simulator')
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)

(VQE_backup) m2c693@alveo:~/RESEARCH_WORK$ python TESTING_VQE_CODE.py 
: DeprecationWarning: The ``qiskit.opflow`` module is deprecated as of qiskit-terra 0.24.0. It will be removed in Qiskit 1.0. For code migration guidelines, visit https://qisk.it/opflow_migration.
  from qiskit.opflow import MatrixOp
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:10: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed in Qiskit 1.0. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.
  from qiskit.algorithms.optimizers import COBYLA
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:14: DeprecationWarning: The 'qiskit.Aer' entry point is deprecated and will be removed in Qiskit 1.0. You should use 'qiskit_aer.Aer' directly instead.
  backend = Aer.get_backend('qasm_simulator')
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:21: DeprecationWarning: The class ``qiskit.opflow.primitive_ops.matrix_op.MatrixOp`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow_migration.
  H_op = MatrixOp(Hamiltonian).to_pauli_op()
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:30: DeprecationWarning: The class ``qiskit.utils.quantum_instance.QuantumInstance`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/qi_migration.
  quantum_instance = QuantumInstance(backend= backend,
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:39: DeprecationWarning: The class ``qiskit.algorithms.minimum_eigen_solvers.vqe.VQE`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class ``qiskit.algorithms.minimum_eigensolvers.VQE``. See https://qisk.it/algo_migration for a migration guide.
  vqe = VQE(ansatz=ansatz_opt,
{   'aux_operator_eigenvalues': None,
    'cost_function_evals': 204,
    'eigenstate': {   '00': 0.44743190822738604,
                      '01': 0.46351240544347894,
                      '10': 0.5321683239352001,
                      '11': 0.5493248697264671},
    'eigenvalue': (0.4073778676855462+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): 3.413149701335303,
                              ParameterVectorElement(θ[1]): 6.122673310049739,
                              ParameterVectorElement(θ[2]): 5.007510090575305,
                              ParameterVectorElement(θ[3]): 6.471417603085951,
                              ParameterVectorElement(θ[4]): 5.5825713635512635,
                              ParameterVectorElement(θ[5]): 3.612049649783617,
                              ParameterVectorElement(θ[6]): 1.1964266917131818,
                              ParameterVectorElement(θ[7]): 1.2636714562893496,
                              ParameterVectorElement(θ[8]): 2.7107242130163205,
                              ParameterVectorElement(θ[9]): 1.4162337151620497,
                              ParameterVectorElement(θ[10]): 3.4685412184905724,
                              ParameterVectorElement(θ[11]): 7.0531779235955145,
                              ParameterVectorElement(θ[12]): 4.759785290450675,
                              ParameterVectorElement(θ[13]): 7.005034463907616,
                              ParameterVectorElement(θ[14]): 3.0544374104242245,
                              ParameterVectorElement(θ[15]): 3.6712390616198993,
                              ParameterVectorElement(θ[16]): 0.8180247608411803,
                              ParameterVectorElement(θ[17]): 2.890632566254878,
                              ParameterVectorElement(θ[18]): 3.2114389132830734,
                              ParameterVectorElement(θ[19]): 1.1110070869050546},
    'optimal_point': array([3.4131497 , 6.12267331, 5.00751009, 6.4714176 , 5.58257136,
       3.61204965, 1.19642669, 1.26367146, 2.71072421, 1.41623372,
       3.46854122, 7.05317792, 4.75978529, 7.00503446, 3.05443741,
       3.67123906, 0.81802476, 2.89063257, 3.21143891, 1.11100709]),
    'optimal_value': 0.4073778676855462,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 4.511643648147583}
</code></pre>
",Substitute for QuantumInstance in latest qiskit==1.0,<qiskit><programming>,1,0,,,"Substitute for QuantumInstance in latest qiskit==1.0 <p>I have a old version of <code>qiskit==0.46</code> code which uses the below syntax:</p>
<pre><code>quantum_instance = QuantumInstance(backend= backend,
                                                shots= self.shots_done,   
                                                seed_simulator= 28,   
                                                seed_transpiler= 28,
                                                basis_gates= None,
                                                optimization_level=self.optimization_level_used)
</code></pre>
<p>This API no longer works in the latest version of <code>qiskit==1.0</code>.
Please suggest me a API which exactly do this function in the latest <code>qiskit==1.0</code>?</p>
<p><strong>Edit1</strong>
Explaining the problem more clearly. Below is the complete code:</p>
<pre><code>from qiskit_aer import AerSimulator
import numpy as np
from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2
# from qiskit.utils import QuantumInstance # Need to replace it with something else
from qiskit_algorithms import VQE



 Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = SparsePauliOp.from_operator(Hamiltonian)
ansatz = EfficientSU2(num_qubits=num_qubits,
                                entanglement= 'linear',
                                reps= depth,
                                skip_final_rotation_layer= True)
    
backend = AerSimulator()

ansatz_opt = transpile(circuits=ansatz,
                         backend = backend,
                          optimization_level =self.optimization_level_used)
            
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                    shots= 1000,                                                   
                                   seed_simulator= 28,  
                                   seed_transpiler= 28,
                                   basis_gates= None,
                                   optimization_level=1)
    
           
           
initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
          optimizer= optimizer,
          quantum_instance=quantum_instance,
           initial_point=initial_point_values
          )
</code></pre>
<p>This code fails at <code>QuantumInstance</code> when I use the <code>qiskit==1.0</code>? Need some substitute for <code>QuantumInstance</code>?</p>
<p><strong>Edit2</strong>
This code works on <code>qiskit==0.46</code>. Just to be sure I am not missing anything,the other qiskit related packages in my conda env are :<br />
<code>qiskit-aer==0.13.3</code> , <code>qiskit-ibmq-provider==0.20.2</code>, <code>qiskit-terra==0.46.0</code></p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA

from qiskit.utils import QuantumInstance
from qiskit.algorithms import VQE
backend = Aer.get_backend('qasm_simulator')
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)

(VQE_backup) m2c693@alveo:~/RESEARCH_WORK$ python TESTING_VQE_CODE.py 
: DeprecationWarning: The ``qiskit.opflow`` module is deprecated as of qiskit-terra 0.24.0. It will be removed in Qiskit 1.0. For code migration guidelines, visit https://qisk.it/opflow_migration.
  from qiskit.opflow import MatrixOp
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:10: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed in Qiskit 1.0. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.
  from qiskit.algorithms.optimizers import COBYLA
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:14: DeprecationWarning: The 'qiskit.Aer' entry point is deprecated and will be removed in Qiskit 1.0. You should use 'qiskit_aer.Aer' directly instead.
  backend = Aer.get_backend('qasm_simulator')
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:21: DeprecationWarning: The class ``qiskit.opflow.primitive_ops.matrix_op.MatrixOp`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/opflow_migration.
  H_op = MatrixOp(Hamiltonian).to_pauli_op()
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:30: DeprecationWarning: The class ``qiskit.utils.quantum_instance.QuantumInstance`` is deprecated as of qiskit-terra 0.24.0. It will be removed in the Qiskit 1.0 release. For code migration guidelines, visit https://qisk.it/qi_migration.
  quantum_instance = QuantumInstance(backend= backend,
/home/m2c693/RESEARCH_WORK/TESTING_VQE_CODE.py:39: DeprecationWarning: The class ``qiskit.algorithms.minimum_eigen_solvers.vqe.VQE`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. Instead, use the class ``qiskit.algorithms.minimum_eigensolvers.VQE``. See https://qisk.it/algo_migration for a migration guide.
  vqe = VQE(ansatz=ansatz_opt,
{   'aux_operator_eigenvalues': None,
    'cost_function_evals': 204,
    'eigenstate': {   '00': 0.44743190822738604,
                      '01': 0.46351240544347894,
                      '10': 0.5321683239352001,
                      '11': 0.5493248697264671},
    'eigenvalue': (0.4073778676855462+0j),
    'optimal_circuit': None,
    'optimal_parameters': {   ParameterVectorElement(θ[0]): 3.413149701335303,
                              ParameterVectorElement(θ[1]): 6.122673310049739,
                              ParameterVectorElement(θ[2]): 5.007510090575305,
                              ParameterVectorElement(θ[3]): 6.471417603085951,
                              ParameterVectorElement(θ[4]): 5.5825713635512635,
                              ParameterVectorElement(θ[5]): 3.612049649783617,
                              ParameterVectorElement(θ[6]): 1.1964266917131818,
                              ParameterVectorElement(θ[7]): 1.2636714562893496,
                              ParameterVectorElement(θ[8]): 2.7107242130163205,
                              ParameterVectorElement(θ[9]): 1.4162337151620497,
                              ParameterVectorElement(θ[10]): 3.4685412184905724,
                              ParameterVectorElement(θ[11]): 7.0531779235955145,
                              ParameterVectorElement(θ[12]): 4.759785290450675,
                              ParameterVectorElement(θ[13]): 7.005034463907616,
                              ParameterVectorElement(θ[14]): 3.0544374104242245,
                              ParameterVectorElement(θ[15]): 3.6712390616198993,
                              ParameterVectorElement(θ[16]): 0.8180247608411803,
                              ParameterVectorElement(θ[17]): 2.890632566254878,
                              ParameterVectorElement(θ[18]): 3.2114389132830734,
                              ParameterVectorElement(θ[19]): 1.1110070869050546},
    'optimal_point': array([3.4131497 , 6.12267331, 5.00751009, 6.4714176 , 5.58257136,
       3.61204965, 1.19642669, 1.26367146, 2.71072421, 1.41623372,
       3.46854122, 7.05317792, 4.75978529, 7.00503446, 3.05443741,
       3.67123906, 0.81802476, 2.89063257, 3.21143891, 1.11100709]),
    'optimal_value': 0.4073778676855462,
    'optimizer_evals': None,
    'optimizer_result': None,
    'optimizer_time': 4.511643648147583}
</code></pre>
",qc,substitute quantuminstance latest p old version code code uses syntax pre code quantuminstance backend 28 28 none p api longer works latest version code please suggest api exactly function latest code p strong edit1 explaining problem clearly complete code pre code import aersimulator import numpy np import sparsepauliop import efficientsu2 import quantuminstance need replace something else import vqe hamiltonian hamiltonian ansatz efficientsu2 depth true backend aersimulator transpile backend backend optimizer cobyla 1500 quantuminstance backend 1000 28 28 none 2 vqe vqe optimizer p code fails code quantuminstance use code need substitute code quantuminstance p strong edit2 code works code sure missing anything qiskit related packages conda env br code code code pre code qiskit import transpile qiskit import aer import numpy np import matrixop import efficientsu2 import cobyla import quantuminstance import vqe backend hamiltonian matrixop hamiltonian ansatz efficientsu2 5 true transpile backend backend optimizer cobyla 1500 quantuminstance backend 1024 default 1024 changing number shots 32m 28 28 none 2 vqe vqe optimizer result print result m2c693 alveo python deprecationwarning module deprecated removed qiskit code migration guidelines visit https import matrixop deprecationwarning migrated independent package https import path deprecated removed qiskit please run pip install use import instead import cobyla deprecationwarning entry point deprecated removed qiskit use directly instead backend deprecationwarning class deprecated removed qiskit release code migration guidelines visit https matrixop hamiltonian deprecationwarning class deprecated removed qiskit release code migration guidelines visit https quantuminstance backend deprecationwarning class deprecated removed earlier 3 months release date instead use class see https migration guide vqe vqe none 204 none parametervectorelement θ 0 parametervectorelement θ 1 parametervectorelement θ 2 parametervectorelement θ 3 parametervectorelement θ 4 parametervectorelement θ 5 parametervectorelement θ 6 parametervectorelement θ 7 parametervectorelement θ 8 parametervectorelement θ 9 parametervectorelement θ 10 parametervectorelement θ 11 parametervectorelement θ 12 parametervectorelement θ 13 parametervectorelement θ 14 parametervectorelement θ 15 parametervectorelement θ 16 parametervectorelement θ 17 parametervectorelement θ 18 parametervectorelement θ 19 array none none,"[(0, 0.56065696), (4, 0.015355201), (6, 0.06708356), (8, 0.033823024), (12, 0.05121839), (14, 0.062352546), (16, 0.2020387)]"
39346,39403.0,2024-07-27 23:19:35,1,105,"<p>I am trying to understand the paper: <strong>Quantum circuits for isometries</strong> (<a href=""https://doi.org/10.1103/PhysRevA.93.032318"" rel=""nofollow noreferrer"">PRA 93, 032318</a>, <a href=""https://arxiv.org/abs/1501.06911"" rel=""nofollow noreferrer"">arXiv:1501.06911</a>).</p>
<p>This paper basically proposes an algorithm called as column column decomposition (CCD), which is basically used in qiskit API: <code>qc.unitary</code> (but I am not sure, if someone can confirm this that would be great). <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary</a></p>
<p>It would be great help if someone can explain a little about are Isometries and what exact is the name of the algorithm used in <code>qc.unitary</code>?</p>
<p><strong>Edit1</strong>
Perhaps, this question is too difficult. Just the name of algorithm used in <code>qc.unitary</code> would also be a great help.</p>
",What is the name of the algorithm used in the qc.unitary API?,<qiskit><quantum-algorithms>,2,4,,,"What is the name of the algorithm used in the qc.unitary API? <p>I am trying to understand the paper: <strong>Quantum circuits for isometries</strong> (<a href=""https://doi.org/10.1103/PhysRevA.93.032318"" rel=""nofollow noreferrer"">PRA 93, 032318</a>, <a href=""https://arxiv.org/abs/1501.06911"" rel=""nofollow noreferrer"">arXiv:1501.06911</a>).</p>
<p>This paper basically proposes an algorithm called as column column decomposition (CCD), which is basically used in qiskit API: <code>qc.unitary</code> (but I am not sure, if someone can confirm this that would be great). <a href=""https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary"" rel=""nofollow noreferrer"">https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#unitary</a></p>
<p>It would be great help if someone can explain a little about are Isometries and what exact is the name of the algorithm used in <code>qc.unitary</code>?</p>
<p><strong>Edit1</strong>
Perhaps, this question is too difficult. Just the name of algorithm used in <code>qc.unitary</code> would also be a great help.</p>
",qc,name algorithm used api p trying understand paper strong quantum circuits isometries https nofollow noreferrer pra 93 032318 https nofollow noreferrer p paper basically proposes algorithm called column column decomposition ccd basically used qiskit api code sure someone confirm would great https unitary nofollow noreferrer https unitary p would great help someone explain little isometries exact name algorithm used code p strong edit1 perhaps question difficult name algorithm used code would also great,"[(4, 0.24891298), (7, 0.46491235), (12, 0.026990704), (13, 0.11159469), (14, 0.11878355), (16, 0.02688772)]"
39579,39581.0,2024-08-16 19:49:51,2,111,"<p>The following stim circuit is equivalent to <code>SQRT_ZZ 0 1</code>, up to pauli feedback, while using only gates from the set <code>MX</code>, <code>MY</code>, <code>MZ</code>, <code>MXX</code>, <code>MYY</code>, <code>MZZ</code>:</p>
<pre><code>MZ 2
MYY 1 2  # this is effectively doing H 1
MX 2
MZZ 0 2  # this is effectively doing CX 0 1
MXX 1 2
MZ 2
MYY 1 2  # this is effectively doing H 1
MX 2
MZZ 1 2  # this is effectively doing S 1
MY 2
MZZ 0 2  # this is effectively doing S 0
MX 2
</code></pre>
<p>Let's arbitrarily say that single qubit dissipative gates are free. Then the cost of this circuit is <strong>six</strong> two-qubit dissipative gates.</p>
<p>Is it possible to decompose <code>SQRT_ZZ</code> into fewer than six two-qubit dissipative gates, in this gate set?</p>
<hr />
<p>Here is a method you can use to verify that a circuit implements another, up to Pauli feedback:</p>
<pre class=""lang-python prettyprint-override""><code>import stim  # ~=1.14.dev

def implements_flows_up_to_pauli_feedback_of(implemented_circuit: stim.Circuit, target_circuit: stim.Circuit) -&gt; bool:

    def flow_to_key_ignoring_pauli_feedback(flow: stim.Flow) -&gt; tuple[str, str]:
        inp = flow.input_copy()
        out = flow.output_copy()
        while len(inp) &gt; 0 and inp[-1] == 0:
            inp = inp[:-1]
        while len(out) &gt; 0 and out[-1] == 0:
            out = out[:-1]
        inp.sign = +1
        out.sign = +1
        return str(inp), str(out)

    if implemented_circuit.num_qubits &lt; target_circuit.num_qubits:
        # Expand the size of the circuit to get the relevant doing-nothing flows it implements.
        implemented_circuit = implemented_circuit + stim.Circuit(f&quot;I {target_circuit.num_qubits - 1}&quot;)

    implemented_generators = implemented_circuit.flow_generators()
    target_generators = target_circuit.flow_generators()
    implemented_keys = {flow_to_key_ignoring_pauli_feedback(flow) for flow in implemented_generators}
    for flow in target_generators:
        if not flow_to_key_ignoring_pauli_feedback(flow) in implemented_keys:
            return False

    return True
</code></pre>
",Efficiently decomposing `SQRT_ZZ` into dissipative gates,<measurement><stim><gate-synthesis>,2,2,,,"Efficiently decomposing `SQRT_ZZ` into dissipative gates <p>The following stim circuit is equivalent to <code>SQRT_ZZ 0 1</code>, up to pauli feedback, while using only gates from the set <code>MX</code>, <code>MY</code>, <code>MZ</code>, <code>MXX</code>, <code>MYY</code>, <code>MZZ</code>:</p>
<pre><code>MZ 2
MYY 1 2  # this is effectively doing H 1
MX 2
MZZ 0 2  # this is effectively doing CX 0 1
MXX 1 2
MZ 2
MYY 1 2  # this is effectively doing H 1
MX 2
MZZ 1 2  # this is effectively doing S 1
MY 2
MZZ 0 2  # this is effectively doing S 0
MX 2
</code></pre>
<p>Let's arbitrarily say that single qubit dissipative gates are free. Then the cost of this circuit is <strong>six</strong> two-qubit dissipative gates.</p>
<p>Is it possible to decompose <code>SQRT_ZZ</code> into fewer than six two-qubit dissipative gates, in this gate set?</p>
<hr />
<p>Here is a method you can use to verify that a circuit implements another, up to Pauli feedback:</p>
<pre class=""lang-python prettyprint-override""><code>import stim  # ~=1.14.dev

def implements_flows_up_to_pauli_feedback_of(implemented_circuit: stim.Circuit, target_circuit: stim.Circuit) -&gt; bool:

    def flow_to_key_ignoring_pauli_feedback(flow: stim.Flow) -&gt; tuple[str, str]:
        inp = flow.input_copy()
        out = flow.output_copy()
        while len(inp) &gt; 0 and inp[-1] == 0:
            inp = inp[:-1]
        while len(out) &gt; 0 and out[-1] == 0:
            out = out[:-1]
        inp.sign = +1
        out.sign = +1
        return str(inp), str(out)

    if implemented_circuit.num_qubits &lt; target_circuit.num_qubits:
        # Expand the size of the circuit to get the relevant doing-nothing flows it implements.
        implemented_circuit = implemented_circuit + stim.Circuit(f&quot;I {target_circuit.num_qubits - 1}&quot;)

    implemented_generators = implemented_circuit.flow_generators()
    target_generators = target_circuit.flow_generators()
    implemented_keys = {flow_to_key_ignoring_pauli_feedback(flow) for flow in implemented_generators}
    for flow in target_generators:
        if not flow_to_key_ignoring_pauli_feedback(flow) in implemented_keys:
            return False

    return True
</code></pre>
",qc,efficiently decomposing dissipative gates p following stim circuit equivalent code 0 1 pauli feedback using gates set code mx code code mz code mxx code myy code mzz pre code mz 2 myy 1 2 effectively h 1 mx 2 mzz 0 2 effectively cx 0 1 mxx 1 2 mz 2 myy 1 2 effectively h 1 mx 2 mzz 1 2 effectively 1 2 mzz 0 2 effectively 0 mx 2 p let arbitrarily say single qubit dissipative gates free cost circuit strong six dissipative p possible decompose code fewer six dissipative gates gate set hr p method use verify circuit implements another pauli feedback pre code import stim def gt bool def flow gt tuple str str inp len inp gt 0 inp 0 inp inp len gt 0 0 return str inp str lt expand size circuit get relevant flows implements f quot 1 quot flow flow flow flow return false return true,"[(0, 0.2151332), (2, 0.20600067), (6, 0.013371038), (9, 0.14516297), (12, 0.093963504), (14, 0.3013909), (19, 0.024149578)]"
78912366,78933884.0,2024-08-25 22:05:58,2,109,"<p>I want to use AES-256 with python's cryptography.fernet.Fernet class. I have generated two keys with Fernet.generate_key() and tried to run the version of the following code (where instead of key1 and key2 there are actual keys):</p>
<pre class=""lang-py prettyprint-override""><code>import base64
from cryptography.fernet import Fernet

f = Fernet(Fernet.generate_key())

f._signing_key = base64.urlsafe_b64decode(key1)
f._encryption_key = base64.urlsafe_b64decode(key2)

token = f.encrypt(b'Secret message!')
print(f'{token}')

print(f.decrypt(token).decode())
</code></pre>
<p>It worked, but does this use AES-256 instead of AES-128?</p>
<p>Also, is this code quantum computers resistant? If this is not the case, how can I use Fernet class to do post-quantum cryptography?</p>
",Use AES-256 with python's cryptography.fernet.Fernet by changing values of _signing_key and _encryption_key fields,<python><cryptography><aes><quantum-computing><python-cryptography>,1,1,,,"Use AES-256 with python's cryptography.fernet.Fernet by changing values of _signing_key and _encryption_key fields <p>I want to use AES-256 with python's cryptography.fernet.Fernet class. I have generated two keys with Fernet.generate_key() and tried to run the version of the following code (where instead of key1 and key2 there are actual keys):</p>
<pre class=""lang-py prettyprint-override""><code>import base64
from cryptography.fernet import Fernet

f = Fernet(Fernet.generate_key())

f._signing_key = base64.urlsafe_b64decode(key1)
f._encryption_key = base64.urlsafe_b64decode(key2)

token = f.encrypt(b'Secret message!')
print(f'{token}')

print(f.decrypt(token).decode())
</code></pre>
<p>It worked, but does this use AES-256 instead of AES-128?</p>
<p>Also, is this code quantum computers resistant? If this is not the case, how can I use Fernet class to do post-quantum cryptography?</p>
",so_new,use python changing values fields p want use python class generated two keys tried run version following code instead key1 key2 actual keys pre code import base64 import fernet f fernet key1 key2 token message print f token print token p worked use instead p also code quantum computers resistant case use fernet class cryptography,"[(0, 0.18230528), (8, 0.15752843), (10, 0.04063615), (12, 0.16775012), (14, 0.44905522)]"
39691,39697.0,2024-08-27 23:07:59,3,51,"<p>In <a href=""https://doi.org/10.48550/arXiv.quant-ph/9605034"" rel=""nofollow noreferrer"">&quot;tight bounds on quantum searching&quot; by Boyer et al.</a>, an exponential scaling for the upper limit of the interval is presented, that is some number <span class=""math-container"">$\lambda^s$</span>. This number is the upper bound for the interval from which we choose our number of iterations.</p>
<p>I am preparing a small review (more for myself and peers, but who knows) and want to avoid the proof proposed by Boyer and would love to provide a visual intuition why exponential scaling is used. One could, for example, imagine a quadratic function as well. (I am aware that there are recursive sequences out there that fulfil a similar purpose as the exponential scaling).</p>
<p>I already tried around plotting <span class=""math-container"">$P_m$</span> from the original paper and log scaling the x axis (i used this axis for the amount of iterations) but I arrived at nothing useful which gives a good intuition.</p>
",Why is an exponential scaling chosen in the Grover Algorithm for an unknown amount of solutions?,<grovers-algorithm>,1,0,,,"Why is an exponential scaling chosen in the Grover Algorithm for an unknown amount of solutions? <p>In <a href=""https://doi.org/10.48550/arXiv.quant-ph/9605034"" rel=""nofollow noreferrer"">&quot;tight bounds on quantum searching&quot; by Boyer et al.</a>, an exponential scaling for the upper limit of the interval is presented, that is some number <span class=""math-container"">$\lambda^s$</span>. This number is the upper bound for the interval from which we choose our number of iterations.</p>
<p>I am preparing a small review (more for myself and peers, but who knows) and want to avoid the proof proposed by Boyer and would love to provide a visual intuition why exponential scaling is used. One could, for example, imagine a quadratic function as well. (I am aware that there are recursive sequences out there that fulfil a similar purpose as the exponential scaling).</p>
<p>I already tried around plotting <span class=""math-container"">$P_m$</span> from the original paper and log scaling the x axis (i used this axis for the amount of iterations) but I arrived at nothing useful which gives a good intuition.</p>
",qc,exponential scaling chosen grover algorithm unknown amount solutions p https nofollow noreferrer quot tight bounds quantum searching quot boyer et exponential scaling upper limit interval presented number span number upper bound interval choose number p preparing small review peers knows want avoid proof proposed boyer would love provide visual intuition exponential scaling used one could example imagine quadratic function well aware recursive sequences fulfil similar purpose exponential scaling p already tried around plotting span original paper log scaling x axis used axis amount iterations arrived nothing useful gives good,"[(3, 0.042142566), (4, 0.03286895), (5, 0.13099645), (7, 0.35087496), (8, 0.2534142), (9, 0.109361954), (10, 0.03929173), (12, 0.011703285), (19, 0.028096223)]"
39698,39699.0,2024-08-28 19:59:19,0,84,"<p>They tell us that eventually quantum computers will break all current encryption methods. On the other hand, current quantum computers are programmed at a very low, mathematical level and for very small problems.</p>
<p>Will quantum computers in the foreseeable future be programmable via more conventional means, using their &quot;all results at the same time&quot; capability as just a kind of Super-Multi-Threading? Like</p>
<pre><code>public String GetPasswordFromHash(String sha512hash) {
 foreach_quantum_parallel_at_once(String passwd in String.all() )
   if (Calcsha512Hash(passwd)==sha512hash)
     return(passwd);
  return(null);
}
</code></pre>
<p>If yes, how far away from that point are we? Do we just need more and more reliable QBits or fundamental improvements?</p>
","Can quantum computers eventually be programmed ""normally""?",<programming><quantum-algorithms><classical-computing>,1,3,,,"Can quantum computers eventually be programmed ""normally""? <p>They tell us that eventually quantum computers will break all current encryption methods. On the other hand, current quantum computers are programmed at a very low, mathematical level and for very small problems.</p>
<p>Will quantum computers in the foreseeable future be programmable via more conventional means, using their &quot;all results at the same time&quot; capability as just a kind of Super-Multi-Threading? Like</p>
<pre><code>public String GetPasswordFromHash(String sha512hash) {
 foreach_quantum_parallel_at_once(String passwd in String.all() )
   if (Calcsha512Hash(passwd)==sha512hash)
     return(passwd);
  return(null);
}
</code></pre>
<p>If yes, how far away from that point are we? Do we just need more and more reliable QBits or fundamental improvements?</p>
",qc,quantum computers eventually programmed normally p tell us eventually quantum computers break current encryption methods hand current quantum computers programmed low mathematical level small p quantum computers foreseeable future programmable via conventional means using quot results time quot capability kind like pre code public string getpasswordfromhash string sha512hash string passwd calcsha512hash passwd return passwd return null p yes far away point need reliable qbits fundamental improvements,"[(0, 0.11028334), (1, 0.12021438), (7, 0.1052312), (8, 0.29467556), (9, 0.14755267), (12, 0.15017807), (13, 0.033104766), (19, 0.036940213)]"
39725,,2024-09-02 09:52:08,0,64,"<p>I am currently trying to recreate a quantum error correction circuit as said in this paper.</p>
<p>Aliferis, Panos; Preskill, John . (2009). <a href=""https://arxiv.org/abs/0809.5063"" rel=""nofollow noreferrer"">Fibonacci scheme for fault-tolerant quantum computation</a>. Physical Review A, 79(1), 012332–. <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.79.012332"" rel=""nofollow noreferrer"">doi:10.1103/PhysRevA.79.012332</a></p>
<p>However, I am stuck at the recursive nature of the encoded bell pair (mentioned in the paper). Does anyone know how to do this? I know it has to do with constructing a circuit with a formula but I am not sue how.</p>
",How to Implement a Recursive Circuit into Qiskit?,<qiskit><error-correction><fault-tolerance>,0,3,,,"How to Implement a Recursive Circuit into Qiskit? <p>I am currently trying to recreate a quantum error correction circuit as said in this paper.</p>
<p>Aliferis, Panos; Preskill, John . (2009). <a href=""https://arxiv.org/abs/0809.5063"" rel=""nofollow noreferrer"">Fibonacci scheme for fault-tolerant quantum computation</a>. Physical Review A, 79(1), 012332–. <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.79.012332"" rel=""nofollow noreferrer"">doi:10.1103/PhysRevA.79.012332</a></p>
<p>However, I am stuck at the recursive nature of the encoded bell pair (mentioned in the paper). Does anyone know how to do this? I know it has to do with constructing a circuit with a formula but I am not sue how.</p>
",qc,implement recursive circuit qiskit p currently trying recreate quantum error correction circuit said p aliferis panos preskill john 2009 https nofollow noreferrer fibonacci scheme quantum computation physical review 79 1 https nofollow noreferrer p however stuck recursive nature encoded bell pair mentioned paper anyone know know constructing circuit formula sue,"[(0, 0.03277598), (4, 0.34397948), (5, 0.07942771), (8, 0.187893), (9, 0.23723933), (12, 0.020921055), (13, 0.030316535), (18, 0.06489703)]"
39848,39849.0,2024-09-14 22:58:46,0,39,"<p>There are circuits in which <code>PAULI_CHANNEL_1</code> doesn't require approximation given certain probabilities (seems like probabilities below <code>0.24</code> for some reason), but then the same circuit with higher probabilities does require approximating:</p>
<pre class=""lang-python prettyprint-override""><code>y_prob = 0.23
c = stim.Circuit(f&quot;&quot;&quot;
H 0
PAULI_CHANNEL_1(0.4, {y_prob}, 0.23) 0 1 2 3
H 0
M 0 1 2
DETECTOR rec[-1] rec[-2] rec[-3]
DETECTOR rec[-2]
DETECTOR rec[-3]
&quot;&quot;&quot;)
c.detector_error_model(approximate_disjoint_errors=False)
</code></pre>
<pre><code>stim.DetectorErrorModel('''
    error(0.63) D0
    error(0.63) D0 D1
    error(0.46) D0 D2
''')
</code></pre>
<p>but then the same circuit just with an increased probability raises an error because approximations are not allowed:</p>
<pre class=""lang-python prettyprint-override""><code>y_prob = 0.24
c = stim.Circuit(f&quot;&quot;&quot;
H 0
PAULI_CHANNEL_1(0.4, {y_prob}, 0.23) 0 1 2 3
H 0
M 0 1 2
DETECTOR rec[-1] rec[-2] rec[-3]
DETECTOR rec[-2]
DETECTOR rec[-3]
&quot;&quot;&quot;)
c.detector_error_model(approximate_disjoint_errors=False)
</code></pre>
<pre><code>ValueError: Encountered the operation PAULI_CHANNEL_1 during error analysis, but this operation requires the `approximate_disjoint_errors` option to be enabled.
</code></pre>
",Why doesn't `PAULI_CHANNEL_1` require approximation in Stim sometimes?,<error-correction><stim>,1,0,,,"Why doesn't `PAULI_CHANNEL_1` require approximation in Stim sometimes? <p>There are circuits in which <code>PAULI_CHANNEL_1</code> doesn't require approximation given certain probabilities (seems like probabilities below <code>0.24</code> for some reason), but then the same circuit with higher probabilities does require approximating:</p>
<pre class=""lang-python prettyprint-override""><code>y_prob = 0.23
c = stim.Circuit(f&quot;&quot;&quot;
H 0
PAULI_CHANNEL_1(0.4, {y_prob}, 0.23) 0 1 2 3
H 0
M 0 1 2
DETECTOR rec[-1] rec[-2] rec[-3]
DETECTOR rec[-2]
DETECTOR rec[-3]
&quot;&quot;&quot;)
c.detector_error_model(approximate_disjoint_errors=False)
</code></pre>
<pre><code>stim.DetectorErrorModel('''
    error(0.63) D0
    error(0.63) D0 D1
    error(0.46) D0 D2
''')
</code></pre>
<p>but then the same circuit just with an increased probability raises an error because approximations are not allowed:</p>
<pre class=""lang-python prettyprint-override""><code>y_prob = 0.24
c = stim.Circuit(f&quot;&quot;&quot;
H 0
PAULI_CHANNEL_1(0.4, {y_prob}, 0.23) 0 1 2 3
H 0
M 0 1 2
DETECTOR rec[-1] rec[-2] rec[-3]
DETECTOR rec[-2]
DETECTOR rec[-3]
&quot;&quot;&quot;)
c.detector_error_model(approximate_disjoint_errors=False)
</code></pre>
<pre><code>ValueError: Encountered the operation PAULI_CHANNEL_1 during error analysis, but this operation requires the `approximate_disjoint_errors` option to be enabled.
</code></pre>
",qc,require approximation stim sometimes p circuits code require approximation given certain probabilities seems like probabilities code reason circuit higher probabilities require approximating pre code c f quot quot quot h 0 0 1 2 3 h 0 0 1 2 detector rec rec rec detector rec detector rec quot quot quot pre code error d0 error d0 d1 error d0 d2 p circuit increased probability raises error approximations allowed pre code c f quot quot quot h 0 0 1 2 3 h 0 0 1 2 detector rec rec rec detector rec detector rec quot quot quot pre code valueerror encountered operation error analysis operation requires option enabled,"[(2, 0.12892985), (5, 0.059246454), (6, 0.3231991), (7, 0.045781277), (12, 0.018260485), (14, 0.22954413), (19, 0.19384725)]"
39905,,2024-09-19 11:04:57,1,36,"<p>I'm working on a project involving quantum support vector machines using the method from the <strong><a href=""https://qiskit-community.github.io/qiskit-machine-learning/tutorials/03_quantum_kernel.html"" rel=""nofollow noreferrer"">Quantum Kernel Machine Learning Tutorial</a></strong> by the Qiskit community. While implementing the code on a real IBM quantum machine, I encountered CircuitError: <code>&quot;name conflict adding parameter 'x[1]'&quot;</code> error.</p>
<p>Has anyone faced this issue, or does anyone know how to resolve it? Any insights would be appreciated!</p>
<p>Code:</p>
<pre><code>    from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Session
    from qiskit_machine_learning.datasets import ad_hoc_data
    from qiskit import transpile
    from qiskit.circuit.library import ZZFeatureMap
    from qiskit_algorithms.state_fidelities import ComputeUncompute
    from qiskit_machine_learning.kernels import FidelityQuantumKernel
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    
    
    # Load Dataset
    adhoc_dimension = 2
    train_features, train_labels, test_features, test_labels, adhoc_total = ad_hoc_data(
        training_size=20,
        test_size=5,
        n=adhoc_dimension,
        gap=0.3,
        plot_data=False,
        one_hot=False,
        include_sample_total=True,
    )
    
    # initialize backend service
    service = QiskitRuntimeService()
    n_qubits=2
    backend = service.least_busy(operational=True, simulator=False, min_num_qubits=n_qubits)
    
    
    adhoc_feature_map = ZZFeatureMap(feature_dimension=adhoc_dimension, reps=2, entanglement=&quot;linear&quot;)
    
    #transpile circuit
    pass_manager = generate_preset_pass_manager(optimization_level=1, backend=backend)
    isa_circuit = pass_manager.run(adhoc_feature_map)
    
    # calculate kernel matrices
    with Session(service= service, backend=backend) as session:
        sampler = Sampler(backend)
        fidelity = ComputeUncompute(sampler=sampler)
        adhoc_kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=isa_circuit)
        adhoc_matrix_train = adhoc_kernel.evaluate(x_vec=train_features,y_vec=train_features)
        adhoc_matrix_test = adhoc_kernel.evaluate(x_vec=test_features, y_vec=train_features)
</code></pre>
<p>Got following error:</p>
<pre><code>---------------------------------------------------------------------------
CircuitError                              Traceback (most recent call last)
Cell In[51], line 7
      4 fidelity = ComputeUncompute(sampler=sampler)
      6 adhoc_kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=isa_circuit)
----&gt; 7 adhoc_matrix_train = adhoc_kernel.evaluate(x_vec=train_features,y_vec=train_features)
      8 adhoc_matrix_test = adhoc_kernel.evaluate(x_vec=test_features, y_vec=train_features)

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_machine_learning/kernels/fidelity_quantum_kernel.py:114, in FidelityQuantumKernel.evaluate(self, x_vec, y_vec)
    112 if is_symmetric:
    113     left_parameters, right_parameters, indices = self._get_symmetric_parameterization(x_vec)
--&gt; 114     kernel_matrix = self._get_symmetric_kernel_matrix(
    115         kernel_shape, left_parameters, right_parameters, indices
    116     )
    117 else:
    118     left_parameters, right_parameters, indices = self._get_parameterization(x_vec, y_vec)

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_machine_learning/kernels/fidelity_quantum_kernel.py:202, in FidelityQuantumKernel._get_symmetric_kernel_matrix(self, kernel_shape, left_parameters, right_parameters, indices)
    192 def _get_symmetric_kernel_matrix(
    193     self,
    194     kernel_shape: tuple[int, int],
   (...)
    197     indices: KernelIndices,
    198 ) -&gt; np.ndarray:
    199     &quot;&quot;&quot;
    200     Given a set of parameterization, this computes the kernel matrix.
    201     &quot;&quot;&quot;
--&gt; 202     kernel_entries = self._get_kernel_entries(left_parameters, right_parameters)
    203     kernel_matrix = np.ones(kernel_shape)
    205     for i, (col, row) in enumerate(indices):

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_machine_learning/kernels/fidelity_quantum_kernel.py:223, in FidelityQuantumKernel._get_kernel_entries(self, left_parameters, right_parameters)
    221 if num_circuits != 0:
    222     if self.max_circuits_per_job is None:
--&gt; 223         job = self._fidelity.run(
    224             [self._feature_map] * num_circuits,
    225             [self._feature_map] * num_circuits,
    226             left_parameters,
    227             right_parameters,
    228         )
    229         kernel_entries = job.result().fidelities
    230     else:
    231         # Determine the number of chunks needed

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_algorithms/state_fidelities/base_state_fidelity.py:298, in BaseStateFidelity.run(self, circuits_1, circuits_2, values_1, values_2, **options)
    270 def run(
    271     self,
    272     circuits_1: QuantumCircuit | Sequence[QuantumCircuit],
   (...)
    276     **options,
    277 ) -&gt; AlgorithmJob:
    278     r&quot;&quot;&quot;
    279     Runs asynchronously the state overlap (fidelity) calculation between two
    280     (parametrized) circuits (first and second) for a specific set of parameter
   (...)
    296         The job's result is an instance of :class:`.StateFidelityResult`.
    297     &quot;&quot;&quot;
--&gt; 298     job = self._run(circuits_1, circuits_2, values_1, values_2, **options)
    300     job.submit()
    301     return job

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_algorithms/state_fidelities/compute_uncompute.py:147, in ComputeUncompute._run(self, circuits_1, circuits_2, values_1, values_2, **options)
    116 def _run(
    117     self,
    118     circuits_1: QuantumCircuit | Sequence[QuantumCircuit],
   (...)
    122     **options,
    123 ) -&gt; AlgorithmJob:
    124     r&quot;&quot;&quot;
    125     Computes the state overlap (fidelity) calculation between two
    126     (parametrized) circuits (first and second) for a specific set of parameter
   (...)
    144         AlgorithmError: If the sampler job is not completed successfully.
    145     &quot;&quot;&quot;
--&gt; 147     circuits = self._construct_circuits(circuits_1, circuits_2)
    148     if len(circuits) == 0:
    149         raise ValueError(
    150             &quot;At least one pair of circuits must be defined to calculate the state overlap.&quot;
    151         )

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_algorithms/state_fidelities/base_state_fidelity.py:187, in BaseStateFidelity._construct_circuits(self, circuits_1, circuits_2)
    184 # re-parametrize input circuits
    185 # TODO: make smarter checks to avoid unnecessary re-parametrizations
    186 parameters_1 = ParameterVector(&quot;x&quot;, circuit_1.num_parameters)
--&gt; 187 parametrized_circuit_1 = circuit_1.assign_parameters(parameters_1)
    188 parameters_2 = ParameterVector(&quot;y&quot;, circuit_2.num_parameters)
    189 parametrized_circuit_2 = circuit_2.assign_parameters(parameters_2)

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit/circuit/quantumcircuit.py:4345, in QuantumCircuit.assign_parameters(self, parameters, inplace, flat_input, strict)
   4343 else:
   4344     parameter_binds = _ParameterBindsSequence(target._data.parameters, parameters)
-&gt; 4345     target._data.assign_parameters_iterable(parameters)
   4347 # Finally, assign the parameters inside any of the calibrations.  We don't track these in
   4348 # the `ParameterTable`, so we manually reconstruct things.
   4349 def map_calibration(qubits, parameters, schedule):

CircuitError: &quot;name conflict adding parameter 'x[1]'&quot;
<span class=""math-container"">```</span>
</code></pre>
",Quantum SVM Implementation Error on IBM Quantum Machine: ‘CircuitError: Name Conflict,<qiskit><qiskit-runtime>,0,0,,,"Quantum SVM Implementation Error on IBM Quantum Machine: ‘CircuitError: Name Conflict <p>I'm working on a project involving quantum support vector machines using the method from the <strong><a href=""https://qiskit-community.github.io/qiskit-machine-learning/tutorials/03_quantum_kernel.html"" rel=""nofollow noreferrer"">Quantum Kernel Machine Learning Tutorial</a></strong> by the Qiskit community. While implementing the code on a real IBM quantum machine, I encountered CircuitError: <code>&quot;name conflict adding parameter 'x[1]'&quot;</code> error.</p>
<p>Has anyone faced this issue, or does anyone know how to resolve it? Any insights would be appreciated!</p>
<p>Code:</p>
<pre><code>    from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Session
    from qiskit_machine_learning.datasets import ad_hoc_data
    from qiskit import transpile
    from qiskit.circuit.library import ZZFeatureMap
    from qiskit_algorithms.state_fidelities import ComputeUncompute
    from qiskit_machine_learning.kernels import FidelityQuantumKernel
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    
    
    # Load Dataset
    adhoc_dimension = 2
    train_features, train_labels, test_features, test_labels, adhoc_total = ad_hoc_data(
        training_size=20,
        test_size=5,
        n=adhoc_dimension,
        gap=0.3,
        plot_data=False,
        one_hot=False,
        include_sample_total=True,
    )
    
    # initialize backend service
    service = QiskitRuntimeService()
    n_qubits=2
    backend = service.least_busy(operational=True, simulator=False, min_num_qubits=n_qubits)
    
    
    adhoc_feature_map = ZZFeatureMap(feature_dimension=adhoc_dimension, reps=2, entanglement=&quot;linear&quot;)
    
    #transpile circuit
    pass_manager = generate_preset_pass_manager(optimization_level=1, backend=backend)
    isa_circuit = pass_manager.run(adhoc_feature_map)
    
    # calculate kernel matrices
    with Session(service= service, backend=backend) as session:
        sampler = Sampler(backend)
        fidelity = ComputeUncompute(sampler=sampler)
        adhoc_kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=isa_circuit)
        adhoc_matrix_train = adhoc_kernel.evaluate(x_vec=train_features,y_vec=train_features)
        adhoc_matrix_test = adhoc_kernel.evaluate(x_vec=test_features, y_vec=train_features)
</code></pre>
<p>Got following error:</p>
<pre><code>---------------------------------------------------------------------------
CircuitError                              Traceback (most recent call last)
Cell In[51], line 7
      4 fidelity = ComputeUncompute(sampler=sampler)
      6 adhoc_kernel = FidelityQuantumKernel(fidelity=fidelity, feature_map=isa_circuit)
----&gt; 7 adhoc_matrix_train = adhoc_kernel.evaluate(x_vec=train_features,y_vec=train_features)
      8 adhoc_matrix_test = adhoc_kernel.evaluate(x_vec=test_features, y_vec=train_features)

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_machine_learning/kernels/fidelity_quantum_kernel.py:114, in FidelityQuantumKernel.evaluate(self, x_vec, y_vec)
    112 if is_symmetric:
    113     left_parameters, right_parameters, indices = self._get_symmetric_parameterization(x_vec)
--&gt; 114     kernel_matrix = self._get_symmetric_kernel_matrix(
    115         kernel_shape, left_parameters, right_parameters, indices
    116     )
    117 else:
    118     left_parameters, right_parameters, indices = self._get_parameterization(x_vec, y_vec)

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_machine_learning/kernels/fidelity_quantum_kernel.py:202, in FidelityQuantumKernel._get_symmetric_kernel_matrix(self, kernel_shape, left_parameters, right_parameters, indices)
    192 def _get_symmetric_kernel_matrix(
    193     self,
    194     kernel_shape: tuple[int, int],
   (...)
    197     indices: KernelIndices,
    198 ) -&gt; np.ndarray:
    199     &quot;&quot;&quot;
    200     Given a set of parameterization, this computes the kernel matrix.
    201     &quot;&quot;&quot;
--&gt; 202     kernel_entries = self._get_kernel_entries(left_parameters, right_parameters)
    203     kernel_matrix = np.ones(kernel_shape)
    205     for i, (col, row) in enumerate(indices):

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_machine_learning/kernels/fidelity_quantum_kernel.py:223, in FidelityQuantumKernel._get_kernel_entries(self, left_parameters, right_parameters)
    221 if num_circuits != 0:
    222     if self.max_circuits_per_job is None:
--&gt; 223         job = self._fidelity.run(
    224             [self._feature_map] * num_circuits,
    225             [self._feature_map] * num_circuits,
    226             left_parameters,
    227             right_parameters,
    228         )
    229         kernel_entries = job.result().fidelities
    230     else:
    231         # Determine the number of chunks needed

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_algorithms/state_fidelities/base_state_fidelity.py:298, in BaseStateFidelity.run(self, circuits_1, circuits_2, values_1, values_2, **options)
    270 def run(
    271     self,
    272     circuits_1: QuantumCircuit | Sequence[QuantumCircuit],
   (...)
    276     **options,
    277 ) -&gt; AlgorithmJob:
    278     r&quot;&quot;&quot;
    279     Runs asynchronously the state overlap (fidelity) calculation between two
    280     (parametrized) circuits (first and second) for a specific set of parameter
   (...)
    296         The job's result is an instance of :class:`.StateFidelityResult`.
    297     &quot;&quot;&quot;
--&gt; 298     job = self._run(circuits_1, circuits_2, values_1, values_2, **options)
    300     job.submit()
    301     return job

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_algorithms/state_fidelities/compute_uncompute.py:147, in ComputeUncompute._run(self, circuits_1, circuits_2, values_1, values_2, **options)
    116 def _run(
    117     self,
    118     circuits_1: QuantumCircuit | Sequence[QuantumCircuit],
   (...)
    122     **options,
    123 ) -&gt; AlgorithmJob:
    124     r&quot;&quot;&quot;
    125     Computes the state overlap (fidelity) calculation between two
    126     (parametrized) circuits (first and second) for a specific set of parameter
   (...)
    144         AlgorithmError: If the sampler job is not completed successfully.
    145     &quot;&quot;&quot;
--&gt; 147     circuits = self._construct_circuits(circuits_1, circuits_2)
    148     if len(circuits) == 0:
    149         raise ValueError(
    150             &quot;At least one pair of circuits must be defined to calculate the state overlap.&quot;
    151         )

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit_algorithms/state_fidelities/base_state_fidelity.py:187, in BaseStateFidelity._construct_circuits(self, circuits_1, circuits_2)
    184 # re-parametrize input circuits
    185 # TODO: make smarter checks to avoid unnecessary re-parametrizations
    186 parameters_1 = ParameterVector(&quot;x&quot;, circuit_1.num_parameters)
--&gt; 187 parametrized_circuit_1 = circuit_1.assign_parameters(parameters_1)
    188 parameters_2 = ParameterVector(&quot;y&quot;, circuit_2.num_parameters)
    189 parametrized_circuit_2 = circuit_2.assign_parameters(parameters_2)

File ~/Desktop/IMB/machine/lib/python3.11/site-packages/qiskit/circuit/quantumcircuit.py:4345, in QuantumCircuit.assign_parameters(self, parameters, inplace, flat_input, strict)
   4343 else:
   4344     parameter_binds = _ParameterBindsSequence(target._data.parameters, parameters)
-&gt; 4345     target._data.assign_parameters_iterable(parameters)
   4347 # Finally, assign the parameters inside any of the calibrations.  We don't track these in
   4348 # the `ParameterTable`, so we manually reconstruct things.
   4349 def map_calibration(qubits, parameters, schedule):

CircuitError: &quot;name conflict adding parameter 'x[1]'&quot;
<span class=""math-container"">```</span>
</code></pre>
",qc,quantum svm implementation error ibm quantum machine circuiterror name conflict p working project involving quantum support vector machines using method strong https nofollow noreferrer quantum kernel machine learning tutorial qiskit community implementing code real ibm quantum machine encountered circuiterror code quot name conflict adding parameter x 1 quot p anyone faced issue anyone know resolve insights would appreciated p code pre code import qiskitruntimeservice sampler session import qiskit import transpile import zzfeaturemap import computeuncompute import fidelityquantumkernel import load dataset 2 initialize backend service service qiskitruntimeservice backend zzfeaturemap quot linear quot transpile circuit calculate kernel matrices session service session sampler sampler backend fidelity computeuncompute fidelityquantumkernel p got following error pre code circuiterror traceback recent call last cell 51 line 7 4 fidelity computeuncompute 6 fidelityquantumkernel gt 7 8 file self 112 113 indices gt 114 115 indices 116 117 else 118 indices file self indices 192 def 193 self 194 tuple int int 197 indices kernelindices 198 gt 199 quot quot quot 200 given set parameterization computes kernel matrix 201 quot quot quot gt 202 203 205 col row enumerate indices file self 221 0 222 none gt 223 job 224 225 226 227 228 229 230 else 231 determine number chunks needed file self options 270 def run 271 self 272 quantumcircuit sequence quantumcircuit 276 options 277 gt algorithmjob 278 r quot quot quot 279 runs asynchronously state overlap fidelity calculation two 280 parametrized circuits first second specific set parameter 296 job result instance class 297 quot quot quot gt 298 job options 300 301 return job file self options 116 def 117 self 118 quantumcircuit sequence quantumcircuit 122 options 123 gt algorithmjob 124 r quot quot quot 125 computes state overlap fidelity calculation two 126 parametrized circuits first second specific set parameter 144 algorithmerror sampler job completed successfully 145 quot quot quot gt 147 circuits 148 len circuits 0 149 raise valueerror 150 quot least one pair circuits must defined calculate state quot 151 file self 184 input circuits 185 todo make smarter checks avoid unnecessary 186 parametervector quot x quot gt 187 188 parametervector quot quot 189 file self parameters inplace strict 4343 else 4344 parameters gt 4345 parameters 4347 finally assign parameters inside calibrations track 4348 parametertable manually reconstruct things 4349 def qubits parameters schedule circuiterror quot name conflict adding parameter x 1 quot span,"[(0, 0.4457252), (6, 0.020188425), (8, 0.028420663), (9, 0.015655015), (12, 0.011131213), (14, 0.2171334), (15, 0.04951362), (19, 0.19950959)]"
39912,39914.0,2024-09-19 16:20:45,2,82,"<p>I'm performing some quantum experiments with Qiskit and I want to use a simulator that mimics a real quantum computer with recent calibration results, like so:</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_aer import AerSimulator
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;MY_TOKEN&quot;)
backend = service.backend(&quot;ibm_brisbane&quot;)
simulator = AerSimulator.from_backend(backend)
</code></pre>
<p>My problem is that I want my experiments to be reproducible in the future, and I believe that the above code snippet pulls the latest calibration results that are updated every 24 hours. Therefore, I wanted to somehow save the backend object to disk (which I would include in my publicly available replication package) and have my script load it instead of pulling it from the IBM Quantum service. Initially, I tried using the <code>pickle</code> module, but the backend object contains many attributes that don't seem relevant and some that should not be made publicly available (such as my token).</p>
<p>I am aware of <code>qiskit_ibm_runtime.fake_provider</code>, but the system snapshots here are too old.</p>
<p>To summarize my question: what is the best way to persist and reuse a Qiskit backend object?</p>
",What is the best way to save and load a Qiskit backend?,<qiskit><simulation>,1,0,,,"What is the best way to save and load a Qiskit backend? <p>I'm performing some quantum experiments with Qiskit and I want to use a simulator that mimics a real quantum computer with recent calibration results, like so:</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_aer import AerSimulator
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token=&quot;MY_TOKEN&quot;)
backend = service.backend(&quot;ibm_brisbane&quot;)
simulator = AerSimulator.from_backend(backend)
</code></pre>
<p>My problem is that I want my experiments to be reproducible in the future, and I believe that the above code snippet pulls the latest calibration results that are updated every 24 hours. Therefore, I wanted to somehow save the backend object to disk (which I would include in my publicly available replication package) and have my script load it instead of pulling it from the IBM Quantum service. Initially, I tried using the <code>pickle</code> module, but the backend object contains many attributes that don't seem relevant and some that should not be made publicly available (such as my token).</p>
<p>I am aware of <code>qiskit_ibm_runtime.fake_provider</code>, but the system snapshots here are too old.</p>
<p>To summarize my question: what is the best way to persist and reuse a Qiskit backend object?</p>
",qc,best way save load qiskit backend p performing quantum experiments qiskit want use simulator mimics real quantum computer recent calibration results like pre code import qiskitruntimeservice import aersimulator service qiskitruntimeservice quot quot quot quot backend quot quot simulator backend p problem want experiments reproducible future believe code snippet pulls latest calibration results updated every 24 hours therefore wanted somehow save backend object disk would include publicly available replication package script load instead pulling ibm quantum service initially tried using code pickle module backend object contains many attributes seem relevant made publicly available token p aware code system snapshots p summarize question best way persist reuse qiskit backend object,"[(0, 0.24567689), (1, 0.038992424), (4, 0.03533215), (12, 0.04584499), (14, 0.54024416), (16, 0.024278607), (19, 0.06838931)]"
39994,39995.0,2024-09-29 14:48:00,2,57,"<p>This is kind of a follow-up to a <a href=""https://quantumcomputing.stackexchange.com/questions/39741/how-to-realize-the-index-shift-operation-in-quantum-circuit"">prior question</a> on cyclic rotations of the qubits in an <span class=""math-container"">$n$</span>-qubit register - the key to that question includes judiciously applying a number of SWAP gates.  I'm interested in a small-sized reversible circuit to cyclically rotate the <span class=""math-container"">$n$</span> qubits, but to do so <em>iff</em> one of the qubits is <span class=""math-container"">$|0\rangle$</span> before the SWAPping.</p>
<p>I know I can copy the test qubit into an ancilla, and perform the rotation conditioned on this ancilla. But I have yet to find a way to assuredly uncompute this ancilla back to <span class=""math-container"">$|0\rangle$</span>.</p>
<p>For <span class=""math-container"">$n=6$</span> <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,1,%22%E2%97%A6%22,1,1,%22X%22%5D,%5B%22%3C%3C6%22,1,1,1,1,1,%22%E2%80%A2%22%5D,%5B1,1,1,1,%22%E2%97%A6%22,1,%22X%22%5D%5D,%22init%22:%5B0,1,0,0,0,1%5D%7D"" rel=""nofollow noreferrer"">here</a> is an example Quirk circuit on a six-qubit register.</p>
<p><a href=""https://i.sstatic.net/CbP4J7br.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CbP4J7br.png"" alt=""Controlled rotation"" /></a></p>
<p>The bottom qubit is the ancilla, and the right-rotation is controlled on the third least significant qubit in the register being <span class=""math-container"">$|0\rangle$</span>.  In the left image, the rotation of the register occurs and the ancilla is properly uncomputed back to <span class=""math-container"">$|0\rangle$</span> when the third qubit is <span class=""math-container"">$|0\rangle$</span>; in the right image, rotation does not occur when the third qubit is <span class=""math-container"">$|1\rangle$</span>, but the ancilla stays as <span class=""math-container"">$|1\rangle$</span> when the third qubit is <span class=""math-container"">$|1\rangle$</span>.</p>
<p><strong>Is there a small reversible circuit that can unconditionally uncompute the ancilla (preferably growing polynomially with <span class=""math-container"">$n$</span>)?</strong></p>
<hr />
<p>I'm motivated by considering a quantum walk on an old sliding puzzle I played with in the early 90's called &quot;Spin-Out,&quot; which is <a href=""https://puzzles.schwandtner.info/compendium/definition.html"" rel=""nofollow noreferrer"">isomorphic</a> to the older &quot;Chinese Rings&quot; puzzle.   In the image below, we can't slide to the left, because the spinner in the arrowed position is vertical, blocking the shift.  And with some analogy to a CNOT gate, the spinner to the right of the arrowed spinner can spin because the arrowed spinner is vertical.  A quantum walk with controlled-root-of-nots and controlled-root-of-shifts could be fun.</p>
<p><a href=""https://i.sstatic.net/JknymS2C.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JknymS2C.png"" alt=""Spin-Out puzzle"" /></a></p>
",On cyclically shifting an $n$-qubit register conditioned on one of the qubits being $|0\rangle$,<circuit-construction><reversible-computation>,1,2,,,"On cyclically shifting an $n$-qubit register conditioned on one of the qubits being $|0\rangle$ <p>This is kind of a follow-up to a <a href=""https://quantumcomputing.stackexchange.com/questions/39741/how-to-realize-the-index-shift-operation-in-quantum-circuit"">prior question</a> on cyclic rotations of the qubits in an <span class=""math-container"">$n$</span>-qubit register - the key to that question includes judiciously applying a number of SWAP gates.  I'm interested in a small-sized reversible circuit to cyclically rotate the <span class=""math-container"">$n$</span> qubits, but to do so <em>iff</em> one of the qubits is <span class=""math-container"">$|0\rangle$</span> before the SWAPping.</p>
<p>I know I can copy the test qubit into an ancilla, and perform the rotation conditioned on this ancilla. But I have yet to find a way to assuredly uncompute this ancilla back to <span class=""math-container"">$|0\rangle$</span>.</p>
<p>For <span class=""math-container"">$n=6$</span> <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B1,1,1,%22%E2%97%A6%22,1,1,%22X%22%5D,%5B%22%3C%3C6%22,1,1,1,1,1,%22%E2%80%A2%22%5D,%5B1,1,1,1,%22%E2%97%A6%22,1,%22X%22%5D%5D,%22init%22:%5B0,1,0,0,0,1%5D%7D"" rel=""nofollow noreferrer"">here</a> is an example Quirk circuit on a six-qubit register.</p>
<p><a href=""https://i.sstatic.net/CbP4J7br.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CbP4J7br.png"" alt=""Controlled rotation"" /></a></p>
<p>The bottom qubit is the ancilla, and the right-rotation is controlled on the third least significant qubit in the register being <span class=""math-container"">$|0\rangle$</span>.  In the left image, the rotation of the register occurs and the ancilla is properly uncomputed back to <span class=""math-container"">$|0\rangle$</span> when the third qubit is <span class=""math-container"">$|0\rangle$</span>; in the right image, rotation does not occur when the third qubit is <span class=""math-container"">$|1\rangle$</span>, but the ancilla stays as <span class=""math-container"">$|1\rangle$</span> when the third qubit is <span class=""math-container"">$|1\rangle$</span>.</p>
<p><strong>Is there a small reversible circuit that can unconditionally uncompute the ancilla (preferably growing polynomially with <span class=""math-container"">$n$</span>)?</strong></p>
<hr />
<p>I'm motivated by considering a quantum walk on an old sliding puzzle I played with in the early 90's called &quot;Spin-Out,&quot; which is <a href=""https://puzzles.schwandtner.info/compendium/definition.html"" rel=""nofollow noreferrer"">isomorphic</a> to the older &quot;Chinese Rings&quot; puzzle.   In the image below, we can't slide to the left, because the spinner in the arrowed position is vertical, blocking the shift.  And with some analogy to a CNOT gate, the spinner to the right of the arrowed spinner can spin because the arrowed spinner is vertical.  A quantum walk with controlled-root-of-nots and controlled-root-of-shifts could be fun.</p>
<p><a href=""https://i.sstatic.net/JknymS2C.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JknymS2C.png"" alt=""Spin-Out puzzle"" /></a></p>
",qc,cyclically shifting n register conditioned one qubits p kind https prior question cyclic rotations qubits span n register key question includes judiciously applying number swap gates interested reversible circuit cyclically rotate span n qubits em iff one qubits span p know copy test qubit ancilla perform rotation conditioned ancilla yet find way assuredly uncompute ancilla back span p span https 7b 22cols 22 5b 22 e2 97 a6 22x 22 5d 5b 22 3c 3c6 22 e2 80 a2 22 5d 22 e2 97 a6 22x 22 5d 5d 22init 22 5d 7d nofollow noreferrer example quirk circuit p https nofollow noreferrer img https controlled rotation p bottom qubit ancilla controlled third least significant qubit register span left image rotation register occurs ancilla properly uncomputed back span third qubit span right image rotation occur third qubit span ancilla stays span third qubit span p strong small reversible circuit unconditionally uncompute ancilla preferably growing polynomially span n hr p motivated considering quantum walk old sliding puzzle played early 90 called quot quot https nofollow noreferrer isomorphic older quot chinese rings quot puzzle image ca slide left spinner arrowed position vertical blocking shift analogy cnot gate spinner right arrowed spinner spin arrowed spinner vertical quantum walk could p https nofollow noreferrer img https puzzle,"[(3, 0.09740634), (4, 0.09482152), (9, 0.3542712), (12, 0.16968447), (13, 0.127888), (18, 0.1339787), (19, 0.021318393)]"
40033,40034.0,2024-10-04 10:46:54,1,70,"<p>I'd like to check if my understanding is correct.</p>
<p>Given <span class=""math-container"">$n$</span> rounds of some syndrome extraction circuit that are performed consecutively, building a decoder for circuit-level noise involves the following steps:</p>
<p>Offline phase:</p>
<ol>
<li>Independently inserting a Pauli X or Z error on each register (data and ancilla) between any two gates of that full syndrome extraction circuit</li>
<li>Propagating that error through the circuit and checking what syndromes they trigger and storing this information somewhere</li>
</ol>
<p>Online phase:</p>
<ol>
<li>Upon seeing an actual syndrome, the decoder decides which was the most likely subset of events from 1. that caused that syndrome</li>
<li>Apply the relevant correction to the circuit</li>
</ol>
<p>If the above is correct, isn't step 2 of the offline phase extremely inefficient for larger circuits?</p>
<p>In the case of an <a href=""https://algassert.com/crumble#circuit=Q(0,2)0;Q(0,4)1;Q(0.5,0.5)2;Q(0.5,1.5)3;Q(0.5,2.5)4;Q(0.5,3.5)5;Q(0.5,4.5)6;Q(1,0)7;Q(1,1)8;Q(1,2)9;Q(1,3)10;Q(1,4)11;Q(1.5,0.5)12;Q(1.5,1.5)13;Q(1.5,2.5)14;Q(1.5,3.5)15;Q(1.5,4.5)16;Q(2,1)17;Q(2,2)18;Q(2,3)19;Q(2,4)20;Q(2,5)21;Q(2.5,0.5)22;Q(2.5,1.5)23;Q(2.5,2.5)24;Q(2.5,3.5)25;Q(2.5,4.5)26;Q(3,0)27;Q(3,1)28;Q(3,2)29;Q(3,3)30;Q(3,4)31;Q(3.5,0.5)32;Q(3.5,1.5)33;Q(3.5,2.5)34;Q(3.5,3.5)35;Q(3.5,4.5)36;Q(4,1)37;Q(4,2)38;Q(4,3)39;Q(4,4)40;Q(4,5)41;Q(4.5,0.5)42;Q(4.5,1.5)43;Q(4.5,2.5)44;Q(4.5,3.5)45;Q(4.5,4.5)46;Q(5,1)47;Q(5,3)48;POLYGON(0,0,1,0.25)12_22_23_13;POLYGON(0,0,1,0.25)3_13_14_4;POLYGON(0,0,1,0.25)14_24_25_15;POLYGON(0,0,1,0.25)5_15_16_6;POLYGON(0,0,1,0.25)34_44_45_35;POLYGON(0,0,1,0.25)25_35_36_26;POLYGON(0,0,1,0.25)32_42_43_33;POLYGON(0,0,1,0.25)23_33_34_24;POLYGON(0,0,1,0.25)12_2;POLYGON(0,0,1,0.25)32_22;POLYGON(0,0,1,0.25)46_36;POLYGON(0,0,1,0.25)26_16;POLYGON(1,0,0,0.25)2_12_13_3;POLYGON(1,0,0,0.25)13_23_24_14;POLYGON(1,0,0,0.25)4_14_15_5;POLYGON(1,0,0,0.25)15_25_26_16;POLYGON(1,0,0,0.25)24_34_35_25;POLYGON(1,0,0,0.25)35_45_46_36;POLYGON(1,0,0,0.25)22_32_33_23;POLYGON(1,0,0,0.25)33_43_44_34;POLYGON(1,0,0,0.25)42_43;POLYGON(1,0,0,0.25)44_45;POLYGON(1,0,0,0.25)5_6;POLYGON(1,0,0,0.25)3_4;TICK;R_2_3_4_5_6_12_13_14_15_16_22_23_24_25_26_32_33_34_35_36_42_43_44_45_46;MARKZ(0)2_3_4_5_6;TICK;R_9_11_17_19_21_29_31_37_39_41_27_7;RX_8_10_18_20_28_30_38_40_47_48_0_1;MARKX(1)28;TICK;CX_8_2_3_9_10_4_5_11_12_17_18_13_14_19_20_15_16_21_28_22_23_29_30_24_25_31_32_37_38_33_34_39_40_35_36_41_47_42_48_44;TICK;CX_13_9_15_11_22_17_24_19_26_21_33_29_35_31_42_37_44_39_46_41_8_3_10_5_18_14_20_16_28_23_30_25_38_34_40_36_47_43_48_45;TICK;CX_4_9_6_11_13_17_15_19_24_29_26_31_33_37_35_39_2_7_22_27_8_12_10_14_1_5_0_3_18_23_20_25_28_32_30_34_38_43_40_45;TICK;CX_8_13_14_9_10_15_16_11_23_17_18_24_25_19_20_26_28_33_34_29_30_35_36_31_43_37_38_44_45_39_40_46_0_4_1_6_12_7_32_27;TICK;M_9_11_17_19_21_29_31_37_39_41_27_7;MX_8_10_18_20_28_30_38_40_47_48_0_1;MARKX(1)28;DT(1,2,0)rec%5B-24%5D;DT(1,4,0)rec%5B-23%5D;DT(2,1,0)rec%5B-22%5D;DT(2,3,0)rec%5B-21%5D;DT(2,5,0)rec%5B-20%5D;DT(3,2,0)rec%5B-19%5D;DT(3,4,0)rec%5B-18%5D;DT(4,1,0)rec%5B-17%5D;DT(4,3,0)rec%5B-16%5D;DT(4,5,0)rec%5B-15%5D;DT(3,0,0)rec%5B-14%5D;DT(1,0,0)rec%5B-13%5D;TICK;R_9_11_17_19_21_29_31_37_39_41_7_27;RX_8_10_18_20_28_30_38_40_47_48_1_0;MARKX(1)28;MARKZ(2)29;TICK;CX_8_2_3_9_10_4_5_11_12_17_18_13_14_19_20_15_16_21_28_22_23_29_30_24_25_31_32_37_38_33_34_39_40_35_36_41_47_42_48_44;TICK;CX_13_9_15_11_22_17_24_19_26_21_33_29_35_31_42_37_44_39_46_41_8_3_10_5_18_14_20_16_28_23_30_25_38_34_40_36_47_43_48_45;TICK;CX_4_9_6_11_13_17_15_19_24_29_26_31_33_37_35_39_2_7_22_27_8_12_10_14_1_5_0_3_18_23_20_25_28_32_30_34_38_43_40_45;TICK;CX_8_13_14_9_10_15_16_11_23_17_18_24_25_19_20_26_28_33_34_29_30_35_36_31_43_37_38_44_45_39_40_46_0_4_1_6_12_7_32_27;TICK;M_9_11_17_19_21_29_31_37_39_41_7_27;MX_8_10_18_20_28_30_38_40_47_48_0_1;MARKX(1)28;MARKZ(2)29;DT(1,2,1)rec%5B-24%5D_rec%5B-48%5D;DT(1,4,1)rec%5B-23%5D_rec%5B-47%5D;DT(2,1,1)rec%5B-22%5D_rec%5B-46%5D;DT(2,3,1)rec%5B-21%5D_rec%5B-45%5D;DT(2,5,1)rec%5B-20%5D_rec%5B-44%5D;DT(3,2,1)rec%5B-19%5D_rec%5B-43%5D;DT(3,4,1)rec%5B-18%5D_rec%5B-42%5D;DT(4,1,1)rec%5B-17%5D_rec%5B-41%5D;DT(4,3,1)rec%5B-16%5D_rec%5B-40%5D;DT(4,5,1)rec%5B-15%5D_rec%5B-39%5D;DT(1,0,1)rec%5B-14%5D_rec%5B-37%5D;DT(3,0,1)rec%5B-13%5D_rec%5B-38%5D;DT(1,1,1)rec%5B-12%5D_rec%5B-36%5D;DT(1,3,1)rec%5B-11%5D_rec%5B-35%5D;DT(2,2,1)rec%5B-10%5D_rec%5B-34%5D;DT(2,4,1)rec%5B-9%5D_rec%5B-33%5D;DT(3,1,1)rec%5B-8%5D_rec%5B-32%5D;DT(3,3,1)rec%5B-7%5D_rec%5B-31%5D;DT(4,2,1)rec%5B-6%5D_rec%5B-30%5D;DT(4,4,1)rec%5B-5%5D_rec%5B-29%5D;DT(5,1,1)rec%5B-4%5D_rec%5B-28%5D;DT(5,3,1)rec%5B-3%5D_rec%5B-27%5D;DT(0,2,1)rec%5B-2%5D_rec%5B-26%5D;DT(0,4,1)rec%5B-1%5D_rec%5B-25%5D;TICK;R_9_11_17_19_21_29_31_37_39_41_7_27;RX_8_10_18_20_28_30_38_40_47_48_0_1;MARKZ(2)29;TICK;CX_8_2_3_9_10_4_5_11_12_17_18_13_14_19_20_15_16_21_28_22_23_29_30_24_25_31_32_37_38_33_34_39_40_35_36_41_47_42_48_44;TICK;CX_13_9_15_11_22_17_24_19_26_21_33_29_35_31_42_37_44_39_46_41_8_3_10_5_18_14_20_16_28_23_30_25_38_34_40_36_47_43_48_45;TICK;CX_4_9_6_11_13_17_15_19_24_29_26_31_33_37_35_39_2_7_22_27_8_12_10_14_1_5_0_3_18_23_20_25_28_32_30_34_38_43_40_45;TICK;CX_8_13_14_9_10_15_16_11_23_17_18_24_25_19_20_26_28_33_34_29_30_35_36_31_43_37_38_44_45_39_40_46_0_4_1_6_12_7_32_27;TICK;M_9_11_17_19_21_29_31_37_39_41_7_27;MX_8_10_18_20_28_30_38_40_47_48_0_1;MARKZ(2)29;DT(1,2,2)rec%5B-24%5D_rec%5B-48%5D;DT(1,4,2)rec%5B-23%5D_rec%5B-47%5D;DT(2,1,2)rec%5B-22%5D_rec%5B-46%5D;DT(2,3,2)rec%5B-21%5D_rec%5B-45%5D;DT(2,5,2)rec%5B-20%5D_rec%5B-44%5D;DT(3,2,2)rec%5B-19%5D_rec%5B-43%5D;DT(3,4,2)rec%5B-18%5D_rec%5B-42%5D;DT(4,1,2)rec%5B-17%5D_rec%5B-41%5D;DT(4,3,2)rec%5B-16%5D_rec%5B-40%5D;DT(4,5,2)rec%5B-15%5D_rec%5B-39%5D;DT(1,0,2)rec%5B-14%5D_rec%5B-38%5D;DT(3,0,2)rec%5B-13%5D_rec%5B-37%5D;DT(1,1,2)rec%5B-12%5D_rec%5B-36%5D;DT(1,3,2)rec%5B-11%5D_rec%5B-35%5D;DT(2,2,2)rec%5B-10%5D_rec%5B-34%5D;DT(2,4,2)rec%5B-9%5D_rec%5B-33%5D;DT(3,1,2)rec%5B-8%5D_rec%5B-32%5D;DT(3,3,2)rec%5B-7%5D_rec%5B-31%5D;DT(4,2,2)rec%5B-6%5D_rec%5B-30%5D;DT(4,4,2)rec%5B-5%5D_rec%5B-29%5D;DT(5,1,2)rec%5B-4%5D_rec%5B-28%5D;DT(5,3,2)rec%5B-3%5D_rec%5B-27%5D;DT(0,2,2)rec%5B-2%5D_rec%5B-26%5D;DT(0,4,2)rec%5B-1%5D_rec%5B-25%5D;TICK;M_2_3_4_5_6_12_13_14_15_16_22_23_24_25_26_32_33_34_35_36_42_43_44_45_46;MARKZ(0)2_3_4_5_6;DT(1,0,3)rec%5B-20%5D_rec%5B-25%5D_rec%5B-39%5D;DT(1,2,3)rec%5B-18%5D_rec%5B-19%5D_rec%5B-23%5D_rec%5B-24%5D_rec%5B-49%5D;DT(1,4,3)rec%5B-16%5D_rec%5B-17%5D_rec%5B-21%5D_rec%5B-22%5D_rec%5B-48%5D;DT(2,1,3)rec%5B-14%5D_rec%5B-15%5D_rec%5B-19%5D_rec%5B-20%5D_rec%5B-47%5D;DT(2,3,3)rec%5B-12%5D_rec%5B-13%5D_rec%5B-17%5D_rec%5B-18%5D_rec%5B-46%5D;DT(2,5,3)rec%5B-11%5D_rec%5B-16%5D_rec%5B-45%5D;DT(3,0,3)rec%5B-10%5D_rec%5B-15%5D_rec%5B-38%5D;DT(3,2,3)rec%5B-8%5D_rec%5B-9%5D_rec%5B-13%5D_rec%5B-14%5D_rec%5B-44%5D;DT(3,4,3)rec%5B-6%5D_rec%5B-7%5D_rec%5B-11%5D_rec%5B-12%5D_rec%5B-43%5D;DT(4,1,3)rec%5B-4%5D_rec%5B-5%5D_rec%5B-9%5D_rec%5B-10%5D_rec%5B-42%5D;DT(4,3,3)rec%5B-2%5D_rec%5B-3%5D_rec%5B-7%5D_rec%5B-8%5D_rec%5B-41%5D;DT(4,5,3)rec%5B-1%5D_rec%5B-6%5D_rec%5B-40%5D;OI(0)rec%5B-21%5D_rec%5B-22%5D_rec%5B-23%5D_rec%5B-24%5D_rec%5B-25%5D"" rel=""nofollow noreferrer"">example Stim circuit for the surface code</a>, does it actually carry out these steps in the process of building detectors or is something different being done?</p>
",Circuit-level noise and decoding graphs,<error-correction><quantum-circuit><stim><noise>,1,0,,,"Circuit-level noise and decoding graphs <p>I'd like to check if my understanding is correct.</p>
<p>Given <span class=""math-container"">$n$</span> rounds of some syndrome extraction circuit that are performed consecutively, building a decoder for circuit-level noise involves the following steps:</p>
<p>Offline phase:</p>
<ol>
<li>Independently inserting a Pauli X or Z error on each register (data and ancilla) between any two gates of that full syndrome extraction circuit</li>
<li>Propagating that error through the circuit and checking what syndromes they trigger and storing this information somewhere</li>
</ol>
<p>Online phase:</p>
<ol>
<li>Upon seeing an actual syndrome, the decoder decides which was the most likely subset of events from 1. that caused that syndrome</li>
<li>Apply the relevant correction to the circuit</li>
</ol>
<p>If the above is correct, isn't step 2 of the offline phase extremely inefficient for larger circuits?</p>
<p>In the case of an <a href=""https://algassert.com/crumble#circuit=Q(0,2)0;Q(0,4)1;Q(0.5,0.5)2;Q(0.5,1.5)3;Q(0.5,2.5)4;Q(0.5,3.5)5;Q(0.5,4.5)6;Q(1,0)7;Q(1,1)8;Q(1,2)9;Q(1,3)10;Q(1,4)11;Q(1.5,0.5)12;Q(1.5,1.5)13;Q(1.5,2.5)14;Q(1.5,3.5)15;Q(1.5,4.5)16;Q(2,1)17;Q(2,2)18;Q(2,3)19;Q(2,4)20;Q(2,5)21;Q(2.5,0.5)22;Q(2.5,1.5)23;Q(2.5,2.5)24;Q(2.5,3.5)25;Q(2.5,4.5)26;Q(3,0)27;Q(3,1)28;Q(3,2)29;Q(3,3)30;Q(3,4)31;Q(3.5,0.5)32;Q(3.5,1.5)33;Q(3.5,2.5)34;Q(3.5,3.5)35;Q(3.5,4.5)36;Q(4,1)37;Q(4,2)38;Q(4,3)39;Q(4,4)40;Q(4,5)41;Q(4.5,0.5)42;Q(4.5,1.5)43;Q(4.5,2.5)44;Q(4.5,3.5)45;Q(4.5,4.5)46;Q(5,1)47;Q(5,3)48;POLYGON(0,0,1,0.25)12_22_23_13;POLYGON(0,0,1,0.25)3_13_14_4;POLYGON(0,0,1,0.25)14_24_25_15;POLYGON(0,0,1,0.25)5_15_16_6;POLYGON(0,0,1,0.25)34_44_45_35;POLYGON(0,0,1,0.25)25_35_36_26;POLYGON(0,0,1,0.25)32_42_43_33;POLYGON(0,0,1,0.25)23_33_34_24;POLYGON(0,0,1,0.25)12_2;POLYGON(0,0,1,0.25)32_22;POLYGON(0,0,1,0.25)46_36;POLYGON(0,0,1,0.25)26_16;POLYGON(1,0,0,0.25)2_12_13_3;POLYGON(1,0,0,0.25)13_23_24_14;POLYGON(1,0,0,0.25)4_14_15_5;POLYGON(1,0,0,0.25)15_25_26_16;POLYGON(1,0,0,0.25)24_34_35_25;POLYGON(1,0,0,0.25)35_45_46_36;POLYGON(1,0,0,0.25)22_32_33_23;POLYGON(1,0,0,0.25)33_43_44_34;POLYGON(1,0,0,0.25)42_43;POLYGON(1,0,0,0.25)44_45;POLYGON(1,0,0,0.25)5_6;POLYGON(1,0,0,0.25)3_4;TICK;R_2_3_4_5_6_12_13_14_15_16_22_23_24_25_26_32_33_34_35_36_42_43_44_45_46;MARKZ(0)2_3_4_5_6;TICK;R_9_11_17_19_21_29_31_37_39_41_27_7;RX_8_10_18_20_28_30_38_40_47_48_0_1;MARKX(1)28;TICK;CX_8_2_3_9_10_4_5_11_12_17_18_13_14_19_20_15_16_21_28_22_23_29_30_24_25_31_32_37_38_33_34_39_40_35_36_41_47_42_48_44;TICK;CX_13_9_15_11_22_17_24_19_26_21_33_29_35_31_42_37_44_39_46_41_8_3_10_5_18_14_20_16_28_23_30_25_38_34_40_36_47_43_48_45;TICK;CX_4_9_6_11_13_17_15_19_24_29_26_31_33_37_35_39_2_7_22_27_8_12_10_14_1_5_0_3_18_23_20_25_28_32_30_34_38_43_40_45;TICK;CX_8_13_14_9_10_15_16_11_23_17_18_24_25_19_20_26_28_33_34_29_30_35_36_31_43_37_38_44_45_39_40_46_0_4_1_6_12_7_32_27;TICK;M_9_11_17_19_21_29_31_37_39_41_27_7;MX_8_10_18_20_28_30_38_40_47_48_0_1;MARKX(1)28;DT(1,2,0)rec%5B-24%5D;DT(1,4,0)rec%5B-23%5D;DT(2,1,0)rec%5B-22%5D;DT(2,3,0)rec%5B-21%5D;DT(2,5,0)rec%5B-20%5D;DT(3,2,0)rec%5B-19%5D;DT(3,4,0)rec%5B-18%5D;DT(4,1,0)rec%5B-17%5D;DT(4,3,0)rec%5B-16%5D;DT(4,5,0)rec%5B-15%5D;DT(3,0,0)rec%5B-14%5D;DT(1,0,0)rec%5B-13%5D;TICK;R_9_11_17_19_21_29_31_37_39_41_7_27;RX_8_10_18_20_28_30_38_40_47_48_1_0;MARKX(1)28;MARKZ(2)29;TICK;CX_8_2_3_9_10_4_5_11_12_17_18_13_14_19_20_15_16_21_28_22_23_29_30_24_25_31_32_37_38_33_34_39_40_35_36_41_47_42_48_44;TICK;CX_13_9_15_11_22_17_24_19_26_21_33_29_35_31_42_37_44_39_46_41_8_3_10_5_18_14_20_16_28_23_30_25_38_34_40_36_47_43_48_45;TICK;CX_4_9_6_11_13_17_15_19_24_29_26_31_33_37_35_39_2_7_22_27_8_12_10_14_1_5_0_3_18_23_20_25_28_32_30_34_38_43_40_45;TICK;CX_8_13_14_9_10_15_16_11_23_17_18_24_25_19_20_26_28_33_34_29_30_35_36_31_43_37_38_44_45_39_40_46_0_4_1_6_12_7_32_27;TICK;M_9_11_17_19_21_29_31_37_39_41_7_27;MX_8_10_18_20_28_30_38_40_47_48_0_1;MARKX(1)28;MARKZ(2)29;DT(1,2,1)rec%5B-24%5D_rec%5B-48%5D;DT(1,4,1)rec%5B-23%5D_rec%5B-47%5D;DT(2,1,1)rec%5B-22%5D_rec%5B-46%5D;DT(2,3,1)rec%5B-21%5D_rec%5B-45%5D;DT(2,5,1)rec%5B-20%5D_rec%5B-44%5D;DT(3,2,1)rec%5B-19%5D_rec%5B-43%5D;DT(3,4,1)rec%5B-18%5D_rec%5B-42%5D;DT(4,1,1)rec%5B-17%5D_rec%5B-41%5D;DT(4,3,1)rec%5B-16%5D_rec%5B-40%5D;DT(4,5,1)rec%5B-15%5D_rec%5B-39%5D;DT(1,0,1)rec%5B-14%5D_rec%5B-37%5D;DT(3,0,1)rec%5B-13%5D_rec%5B-38%5D;DT(1,1,1)rec%5B-12%5D_rec%5B-36%5D;DT(1,3,1)rec%5B-11%5D_rec%5B-35%5D;DT(2,2,1)rec%5B-10%5D_rec%5B-34%5D;DT(2,4,1)rec%5B-9%5D_rec%5B-33%5D;DT(3,1,1)rec%5B-8%5D_rec%5B-32%5D;DT(3,3,1)rec%5B-7%5D_rec%5B-31%5D;DT(4,2,1)rec%5B-6%5D_rec%5B-30%5D;DT(4,4,1)rec%5B-5%5D_rec%5B-29%5D;DT(5,1,1)rec%5B-4%5D_rec%5B-28%5D;DT(5,3,1)rec%5B-3%5D_rec%5B-27%5D;DT(0,2,1)rec%5B-2%5D_rec%5B-26%5D;DT(0,4,1)rec%5B-1%5D_rec%5B-25%5D;TICK;R_9_11_17_19_21_29_31_37_39_41_7_27;RX_8_10_18_20_28_30_38_40_47_48_0_1;MARKZ(2)29;TICK;CX_8_2_3_9_10_4_5_11_12_17_18_13_14_19_20_15_16_21_28_22_23_29_30_24_25_31_32_37_38_33_34_39_40_35_36_41_47_42_48_44;TICK;CX_13_9_15_11_22_17_24_19_26_21_33_29_35_31_42_37_44_39_46_41_8_3_10_5_18_14_20_16_28_23_30_25_38_34_40_36_47_43_48_45;TICK;CX_4_9_6_11_13_17_15_19_24_29_26_31_33_37_35_39_2_7_22_27_8_12_10_14_1_5_0_3_18_23_20_25_28_32_30_34_38_43_40_45;TICK;CX_8_13_14_9_10_15_16_11_23_17_18_24_25_19_20_26_28_33_34_29_30_35_36_31_43_37_38_44_45_39_40_46_0_4_1_6_12_7_32_27;TICK;M_9_11_17_19_21_29_31_37_39_41_7_27;MX_8_10_18_20_28_30_38_40_47_48_0_1;MARKZ(2)29;DT(1,2,2)rec%5B-24%5D_rec%5B-48%5D;DT(1,4,2)rec%5B-23%5D_rec%5B-47%5D;DT(2,1,2)rec%5B-22%5D_rec%5B-46%5D;DT(2,3,2)rec%5B-21%5D_rec%5B-45%5D;DT(2,5,2)rec%5B-20%5D_rec%5B-44%5D;DT(3,2,2)rec%5B-19%5D_rec%5B-43%5D;DT(3,4,2)rec%5B-18%5D_rec%5B-42%5D;DT(4,1,2)rec%5B-17%5D_rec%5B-41%5D;DT(4,3,2)rec%5B-16%5D_rec%5B-40%5D;DT(4,5,2)rec%5B-15%5D_rec%5B-39%5D;DT(1,0,2)rec%5B-14%5D_rec%5B-38%5D;DT(3,0,2)rec%5B-13%5D_rec%5B-37%5D;DT(1,1,2)rec%5B-12%5D_rec%5B-36%5D;DT(1,3,2)rec%5B-11%5D_rec%5B-35%5D;DT(2,2,2)rec%5B-10%5D_rec%5B-34%5D;DT(2,4,2)rec%5B-9%5D_rec%5B-33%5D;DT(3,1,2)rec%5B-8%5D_rec%5B-32%5D;DT(3,3,2)rec%5B-7%5D_rec%5B-31%5D;DT(4,2,2)rec%5B-6%5D_rec%5B-30%5D;DT(4,4,2)rec%5B-5%5D_rec%5B-29%5D;DT(5,1,2)rec%5B-4%5D_rec%5B-28%5D;DT(5,3,2)rec%5B-3%5D_rec%5B-27%5D;DT(0,2,2)rec%5B-2%5D_rec%5B-26%5D;DT(0,4,2)rec%5B-1%5D_rec%5B-25%5D;TICK;M_2_3_4_5_6_12_13_14_15_16_22_23_24_25_26_32_33_34_35_36_42_43_44_45_46;MARKZ(0)2_3_4_5_6;DT(1,0,3)rec%5B-20%5D_rec%5B-25%5D_rec%5B-39%5D;DT(1,2,3)rec%5B-18%5D_rec%5B-19%5D_rec%5B-23%5D_rec%5B-24%5D_rec%5B-49%5D;DT(1,4,3)rec%5B-16%5D_rec%5B-17%5D_rec%5B-21%5D_rec%5B-22%5D_rec%5B-48%5D;DT(2,1,3)rec%5B-14%5D_rec%5B-15%5D_rec%5B-19%5D_rec%5B-20%5D_rec%5B-47%5D;DT(2,3,3)rec%5B-12%5D_rec%5B-13%5D_rec%5B-17%5D_rec%5B-18%5D_rec%5B-46%5D;DT(2,5,3)rec%5B-11%5D_rec%5B-16%5D_rec%5B-45%5D;DT(3,0,3)rec%5B-10%5D_rec%5B-15%5D_rec%5B-38%5D;DT(3,2,3)rec%5B-8%5D_rec%5B-9%5D_rec%5B-13%5D_rec%5B-14%5D_rec%5B-44%5D;DT(3,4,3)rec%5B-6%5D_rec%5B-7%5D_rec%5B-11%5D_rec%5B-12%5D_rec%5B-43%5D;DT(4,1,3)rec%5B-4%5D_rec%5B-5%5D_rec%5B-9%5D_rec%5B-10%5D_rec%5B-42%5D;DT(4,3,3)rec%5B-2%5D_rec%5B-3%5D_rec%5B-7%5D_rec%5B-8%5D_rec%5B-41%5D;DT(4,5,3)rec%5B-1%5D_rec%5B-6%5D_rec%5B-40%5D;OI(0)rec%5B-21%5D_rec%5B-22%5D_rec%5B-23%5D_rec%5B-24%5D_rec%5B-25%5D"" rel=""nofollow noreferrer"">example Stim circuit for the surface code</a>, does it actually carry out these steps in the process of building detectors or is something different being done?</p>
",qc,noise decoding graphs p like check understanding p given span n rounds syndrome extraction circuit performed consecutively building decoder noise involves following steps p offline phase ol li independently inserting pauli x z error register data ancilla two gates full syndrome extraction circuit li propagating error circuit checking syndromes trigger storing information somewhere p online phase ol li upon seeing actual syndrome decoder decides likely subset events caused syndrome li apply relevant correction circuit p correct step 2 offline phase extremely inefficient larger circuits p case https 0 q 1 q 2 q 3 q 4 q 5 q 6 q 7 q 8 q 9 q 10 q 11 q 12 q 13 q 14 q 15 q 16 q 17 q 18 q 19 q 20 q 21 q 22 q 23 q 24 q 25 q 26 q 27 q 28 q 29 q 30 q 31 q 32 q 33 q 34 q 35 q 36 q 37 q 38 q 39 q 40 q 41 q 42 q 43 q 44 q 45 q 46 q 47 q 48 polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon polygon tick markz 0 tick markx 1 28 tick tick tick tick tick markx 1 28 dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d tick markx 1 28 markz 2 29 tick tick tick tick tick markx 1 28 markz 2 29 dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d tick markz 2 29 tick tick tick tick tick markz 2 29 dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d tick markz 0 dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d dt rec 5d oi 0 rec 5d nofollow noreferrer example stim circuit surface code actually carry steps process building detectors something different done,"[(5, 0.051128976), (6, 0.39833084), (8, 0.010398473), (9, 0.19714001), (10, 0.08582605), (12, 0.23034228), (13, 0.012767999)]"
40042,40078.0,2024-10-06 09:54:22,3,133,"<p>The below figure from page 486 of Nielsen and Chuang, 10th edition shows how a logical gate can be performed on the Steane code. Curiously, to implement the necessary ancilla state, it seems like one needs to apply a <span class=""math-container"">$T$</span> gate transversally, that is, <span class=""math-container"">$T$</span> gates on each of the physical qubits of the ancilla.</p>
<p><a href=""https://i.sstatic.net/82Z2gjvT.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/82Z2gjvT.png"" alt=""enter image description here"" /></a></p>
<p>How is this possible when the <a href=""https://en.wikipedia.org/wiki/Eastin%E2%80%93Knill_theorem"" rel=""nofollow noreferrer"">Eastin–Knill theorem</a> says that no code has a transversal universal gateset? I can only think of 2 possible explanations.</p>
<ol>
<li>The ancilla, <span class=""math-container"">$|0\rangle$</span>, is not encoded in the Steane code but <span class=""math-container"">$|\psi\rangle$</span> is. When the protocol is completed after the classically controlled operation, the logical <span class=""math-container"">$T$</span> gate is applied to a Steane encoded <span class=""math-container"">$|\psi\rangle$</span>.</li>
</ol>
<p>The problem with this explanation is that the textbook explicitly says that the ancilla is encoded into the Steane code at the beginning of the protocol. The book says</p>
<blockquote>
<p>The circuit starts with <em>two</em> encoded qubits</p>
</blockquote>
<ol start=""2"">
<li>I misunderstand the Eastin–Knill theorem and one can indeed do Transversal <span class=""math-container"">$T$</span> gates on the Steane code, they just can't do it fault tolerantly, hence the need for the gate teleportation protocol. This tracks with an explanation of how to create the ancillary state via a <a href=""https://en.wikipedia.org/wiki/Parity_measurement"" rel=""nofollow noreferrer"">parity measurement</a> of an operator <span class=""math-container"">$M$</span> later in the book on page 491, that moves the transversal <span class=""math-container"">$T$</span> gates to qubits that are not encoded in the Steane code.</li>
</ol>
<blockquote>
<p>To perform the controlled-<span class=""math-container"">$M$</span> operation on the Steane code for the choice of <span class=""math-container"">$M$</span> we apply controlled-<span class=""math-container"">$ZSX$</span> gates transversally for each pair of qubits in the ancilla and the code, followed by seven <span class=""math-container"">$T$</span> gates applied transversally to the ancilla qubits.</p>
</blockquote>
<p>So, which one is the answer, and if I didn't list a possible answer, what is it?</p>
",How does Nielsen and Chuang's logical T gate circumvent the Eastin-Knill theorem?,<error-correction><nielsen-and-chuang><teleportation><fault-tolerance><magic-states>,1,10,,,"How does Nielsen and Chuang's logical T gate circumvent the Eastin-Knill theorem? <p>The below figure from page 486 of Nielsen and Chuang, 10th edition shows how a logical gate can be performed on the Steane code. Curiously, to implement the necessary ancilla state, it seems like one needs to apply a <span class=""math-container"">$T$</span> gate transversally, that is, <span class=""math-container"">$T$</span> gates on each of the physical qubits of the ancilla.</p>
<p><a href=""https://i.sstatic.net/82Z2gjvT.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/82Z2gjvT.png"" alt=""enter image description here"" /></a></p>
<p>How is this possible when the <a href=""https://en.wikipedia.org/wiki/Eastin%E2%80%93Knill_theorem"" rel=""nofollow noreferrer"">Eastin–Knill theorem</a> says that no code has a transversal universal gateset? I can only think of 2 possible explanations.</p>
<ol>
<li>The ancilla, <span class=""math-container"">$|0\rangle$</span>, is not encoded in the Steane code but <span class=""math-container"">$|\psi\rangle$</span> is. When the protocol is completed after the classically controlled operation, the logical <span class=""math-container"">$T$</span> gate is applied to a Steane encoded <span class=""math-container"">$|\psi\rangle$</span>.</li>
</ol>
<p>The problem with this explanation is that the textbook explicitly says that the ancilla is encoded into the Steane code at the beginning of the protocol. The book says</p>
<blockquote>
<p>The circuit starts with <em>two</em> encoded qubits</p>
</blockquote>
<ol start=""2"">
<li>I misunderstand the Eastin–Knill theorem and one can indeed do Transversal <span class=""math-container"">$T$</span> gates on the Steane code, they just can't do it fault tolerantly, hence the need for the gate teleportation protocol. This tracks with an explanation of how to create the ancillary state via a <a href=""https://en.wikipedia.org/wiki/Parity_measurement"" rel=""nofollow noreferrer"">parity measurement</a> of an operator <span class=""math-container"">$M$</span> later in the book on page 491, that moves the transversal <span class=""math-container"">$T$</span> gates to qubits that are not encoded in the Steane code.</li>
</ol>
<blockquote>
<p>To perform the controlled-<span class=""math-container"">$M$</span> operation on the Steane code for the choice of <span class=""math-container"">$M$</span> we apply controlled-<span class=""math-container"">$ZSX$</span> gates transversally for each pair of qubits in the ancilla and the code, followed by seven <span class=""math-container"">$T$</span> gates applied transversally to the ancilla qubits.</p>
</blockquote>
<p>So, which one is the answer, and if I didn't list a possible answer, what is it?</p>
",qc,nielsen chuang logical gate circumvent theorem p figure page 486 nielsen chuang 10th edition shows logical gate performed steane code curiously implement necessary ancilla state seems like one needs apply span gate transversally span gates physical qubits p https nofollow noreferrer img https enter image description p possible https e2 80 nofollow noreferrer theorem says code transversal universal gateset think 2 possible ol li ancilla span encoded steane code span protocol completed classically controlled operation logical span gate applied steane encoded span p problem explanation textbook explicitly says ancilla encoded steane code beginning protocol book says blockquote p circuit starts em two encoded qubits ol 2 li misunderstand theorem one indeed transversal span gates steane code ca fault tolerantly hence need gate teleportation protocol tracks explanation create ancillary state via https nofollow noreferrer parity measurement operator span later book page 491 moves transversal span gates qubits encoded steane blockquote p perform span operation steane code choice span apply span zsx gates transversally pair qubits ancilla code followed seven span gates applied transversally ancilla p one answer list possible answer,"[(3, 0.16117062), (4, 0.11183719), (5, 0.24442239), (9, 0.23268853), (12, 0.011846126), (14, 0.03541636), (18, 0.20186757)]"
79060676,79072024.0,2024-10-07 05:26:33,1,126,"<p>A couple of years ago, the Microsoft Quantum Development Kit was introduced for Visual Studio 2022.  However, the <a href=""https://marketplace.visualstudio.com/items?itemName=quantum.DevKit"" rel=""nofollow noreferrer"">published link</a> now returns a Page Not Found message, and searching through the Visual Studio Marketplace does not bring up any relevant tools.</p>
<p>Doing a Google search for the QDK returns results only for the VS Code extension/tools.</p>
<p>Has Microsoft discontinued QDK and Q# support for the full version of Visual Studio?  Is VS Code the only option now?</p>
",Are Q# and the Microsoft Quantum Development Kit available for Visual Studio 2022?,<visual-studio><quantum-computing><q#><qdk>,1,0,,,"Are Q# and the Microsoft Quantum Development Kit available for Visual Studio 2022? <p>A couple of years ago, the Microsoft Quantum Development Kit was introduced for Visual Studio 2022.  However, the <a href=""https://marketplace.visualstudio.com/items?itemName=quantum.DevKit"" rel=""nofollow noreferrer"">published link</a> now returns a Page Not Found message, and searching through the Visual Studio Marketplace does not bring up any relevant tools.</p>
<p>Doing a Google search for the QDK returns results only for the VS Code extension/tools.</p>
<p>Has Microsoft discontinued QDK and Q# support for the full version of Visual Studio?  Is VS Code the only option now?</p>
",so_new,q microsoft quantum development kit available visual studio 2022 p couple years ago microsoft quantum development kit introduced visual studio however https nofollow noreferrer published link returns page found message searching visual studio marketplace bring relevant p google search qdk returns results vs code p microsoft discontinued qdk q support full version visual studio vs code option,"[(4, 0.12556131), (7, 0.12032303), (8, 0.26050004), (10, 0.04106736), (12, 0.24792719), (13, 0.035539385), (14, 0.10785057), (17, 0.0591306)]"
40088,,2024-10-10 17:15:43,1,38,"<p>I am new to quantum computing, though I am by now familiar with certain jargon but have miles to go before I gain a foothold on the subject. I have been trying very hard to understand and interpret the output for portfolio optimization of VQE.</p>
<p>To begin with, I am comfortable executing program of Qiskit. I specifically require help with interpreting the output of VQE and QAOA in the following program (<a href=""https://qiskit-community.github.io/qiskit-finance/tutorials/01_portfolio_optimization.html"" rel=""nofollow noreferrer"">Qiskit PO</a>)
Optimal: selection [1. 0. 0. 1.], value -0.0149</p>
<p><a href=""https://i.sstatic.net/oTBm0tJA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/oTBm0tJA.png"" alt=""The image contains the output displayed from the link for the program from IMB's official site"" /></a></p>
<p>I believe the first column is the asset combination that should be present in the portfolio, the decimal values that we see in the middle column are the energy values, and we are looking at the lowest energy level as the answer. I am not able to understand the third column. <strong>Could someone help?</strong></p>
",Interpretation of output for Portfolio optimization program,<vqe><optimization><qaoa><quantum-computing-for-finance>,1,0,,,"Interpretation of output for Portfolio optimization program <p>I am new to quantum computing, though I am by now familiar with certain jargon but have miles to go before I gain a foothold on the subject. I have been trying very hard to understand and interpret the output for portfolio optimization of VQE.</p>
<p>To begin with, I am comfortable executing program of Qiskit. I specifically require help with interpreting the output of VQE and QAOA in the following program (<a href=""https://qiskit-community.github.io/qiskit-finance/tutorials/01_portfolio_optimization.html"" rel=""nofollow noreferrer"">Qiskit PO</a>)
Optimal: selection [1. 0. 0. 1.], value -0.0149</p>
<p><a href=""https://i.sstatic.net/oTBm0tJA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/oTBm0tJA.png"" alt=""The image contains the output displayed from the link for the program from IMB's official site"" /></a></p>
<p>I believe the first column is the asset combination that should be present in the portfolio, the decimal values that we see in the middle column are the energy values, and we are looking at the lowest energy level as the answer. I am not able to understand the third column. <strong>Could someone help?</strong></p>
",qc,interpretation output portfolio optimization program p new quantum computing though familiar certain jargon miles go gain foothold subject trying hard understand interpret output portfolio optimization p begin comfortable executing program qiskit specifically require help interpreting output vqe qaoa following program https nofollow noreferrer qiskit po optimal selection 1 0 0 1 value p https nofollow noreferrer img https image contains output displayed link program imb official site p believe first column asset combination present portfolio decimal values see middle column energy values looking lowest energy level answer able understand third column strong could someone help,"[(2, 0.045289233), (4, 0.22630474), (8, 0.41381878), (12, 0.011043606), (13, 0.121032886), (14, 0.082528725), (17, 0.098555386)]"
40105,,2024-10-13 13:49:50,0,57,"<p>I'm running a simple Bell's inequality example on Amazon Braket, using QuEra's Aquila.  The code below is taken almost exactly from their public textbook:  <code>Braket algorithms -&gt; textbook</code>.</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np
from braket.devices import LocalSimulator
from braket.tracking import Tracker
from braket.experimental.algorithms.bells_inequality import (
    create_bell_inequality_circuits,
    get_bell_inequality_results,
    run_bell_inequality,
)
from braket.aws import AwsDevice

aquila = AwsDevice(&quot;arn:aws:braket:us-east-1::device/qpu/quera/Aquila&quot;)
tasks = run_bell_inequality([circAB, circAC, circBC], aquila, shots=1000) 
results, pAB, pAC, pBC = get_bell_inequality_results(tasks)

</code></pre>
<p>However, I'm unable to find any information at all on the following exception returned:</p>
<pre><code>ValidationException: An error occurred (ValidationException) when calling the CreateQuantumTask operation: Device arn:aws:braket:us-east-1::device/qpu/quera/Aquila supports ['braket.ir.ahs.program'] action type, but the supplied action type is braket.ir.openqasm.program
</code></pre>
<p>I tried looking at the documentation on <code>OpenQasm</code>: <a href=""https://docs.aws.amazon.com/braket/latest/developerguide/braket-openqasm-supported-features.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/braket/latest/developerguide/braket-openqasm-supported-features.html</a>. But I can't find anything that would cause this to fail.  Is there a better way to troubleshoot this?</p>
",What action types are supported by QuEra's Aquila on Amazon Braket?,<qasm><amazon-braket>,1,0,,,"What action types are supported by QuEra's Aquila on Amazon Braket? <p>I'm running a simple Bell's inequality example on Amazon Braket, using QuEra's Aquila.  The code below is taken almost exactly from their public textbook:  <code>Braket algorithms -&gt; textbook</code>.</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np
from braket.devices import LocalSimulator
from braket.tracking import Tracker
from braket.experimental.algorithms.bells_inequality import (
    create_bell_inequality_circuits,
    get_bell_inequality_results,
    run_bell_inequality,
)
from braket.aws import AwsDevice

aquila = AwsDevice(&quot;arn:aws:braket:us-east-1::device/qpu/quera/Aquila&quot;)
tasks = run_bell_inequality([circAB, circAC, circBC], aquila, shots=1000) 
results, pAB, pAC, pBC = get_bell_inequality_results(tasks)

</code></pre>
<p>However, I'm unable to find any information at all on the following exception returned:</p>
<pre><code>ValidationException: An error occurred (ValidationException) when calling the CreateQuantumTask operation: Device arn:aws:braket:us-east-1::device/qpu/quera/Aquila supports ['braket.ir.ahs.program'] action type, but the supplied action type is braket.ir.openqasm.program
</code></pre>
<p>I tried looking at the documentation on <code>OpenQasm</code>: <a href=""https://docs.aws.amazon.com/braket/latest/developerguide/braket-openqasm-supported-features.html"" rel=""nofollow noreferrer"">https://docs.aws.amazon.com/braket/latest/developerguide/braket-openqasm-supported-features.html</a>. But I can't find anything that would cause this to fail.  Is there a better way to troubleshoot this?</p>
",qc,action types supported quera aquila amazon braket p running simple bell inequality example amazon braket using quera aquila code taken almost exactly public textbook code braket algorithms gt textbook pre code import numpy np import localsimulator import tracker import import awsdevice aquila awsdevice quot arn aws braket quot tasks circab circac circbc aquila results pab pac pbc tasks p however unable find information following exception returned pre code validationexception error occurred validationexception calling createquantumtask operation device arn aws braket supports action type supplied action type p tried looking documentation code openqasm https nofollow noreferrer https ca find anything would cause fail better way troubleshoot,"[(0, 0.14105605), (3, 0.031424787), (4, 0.11094892), (8, 0.023392195), (12, 0.15497081), (14, 0.51626104), (19, 0.020694789)]"
40140,,2024-10-18 05:46:12,1,44,"<p>I am trying to learn QAOA algorithm, and trying to code by reading the content at <a href=""https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm"" rel=""nofollow noreferrer"">https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm</a></p>
<p>The code I am writing to simulate on my local machine:</p>
<pre><code>    import numpy as np
    from qiskit_aer import Aer
    from qiskit_aer.primitives import sampler
    from qiskit_algorithms import QAOA, NumPyMinimumEigensolver
    from qiskit_algorithms.optimizers import optimizer
    from qiskit_optimization.algorithms import MinimumEigenOptimizer
    from qiskit_optimization.applications import Tsp
    from qiskit_optimization.converters import QuadraticProgramToQubo
    from qiskit.circuit.library.n_local.qaoa_ansatz import QAOAAnsatz
    from qiskit_ibm_runtime import Session

     n = 3
     num_qubits = n ** 2
     distance_matrix = np.array([
     [0, 48, 91],
     [48,  0, 63],
     [91, 63,  0],])
     tsp=Tsp(distance_matrix)
     qp = tsp.to_quadratic_program()
     print(qp.prettyprint())
     qp2qubo = QuadraticProgramToQubo()
     qubo = qp2qubo.convert(qp)
     print(qubo.prettyprint())

     cost_hamiltonian, offset = qubo.to_ising()
     print(offset)
     print(cost_hamiltonian)

     circuit = QAOAAnsatz(cost_operator=cost_hamiltonian, reps=2)
     circuit.measure_all()
     circuit.parameters
     from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
     backend = Aer.get_backend('aer_simulator_statevector')
     print(backend)
     pm = generate_preset_pass_manager(optimization_level=3,backend=backend)
     candidate_circuit = pm.run(circuit)
     candidate_circuit.draw('mpl', fold=False, idle_wires=False)
     initial_gamma = np.pi
     initial_beta = np.pi/2
     init_params = [initial_gamma, initial_beta, initial_gamma, initial_beta]

     def cost_func_estimator(params, ansatz, hamiltonian, estimator):

    # transform the observable defined on virtual qubits to
    # an observable defined on all physical qubits
    isa_hamiltonian = hamiltonian.apply_layout(ansatz.layout)

    pub = (ansatz, isa_hamiltonian, params)
    job = estimator.run([pub])

    results = job.result()[0]
    cost = results.data.evs
    print(cost)

    objective_func_vals.append(cost)

    return cost

    from qiskit_ibm_runtime import Session, EstimatorV2 as Estimator  
    from scipy.optimize import minimize  
    from qiskit_ibm_runtime import SamplerV2 as Sampler  

    objective_func_vals = [] # Global variable  
    with Session(backend=backend) as session:  
    # If using qiskit-ibm-runtime&lt;0.24.0, change `mode=` to `session=`  
    estimator = Estimator(mode=session)  
    estimator.options.default_shots = 1000  

    # Set simple error suppression/mitigation options
        result = minimize(
        cost_func_estimator,
        init_params,
        args=(candidate_circuit, cost_hamiltonian, estimator),
        method=&quot;COBYLA&quot;,
        tol=1e-6,
    )
    print(result)
    optimized_circuit = candidate_circuit.assign_parameters(result.x)
    sampler = Sampler(mode=session)
    sampler.options.default_shots = 10000

    pub= (optimized_circuit, )
    job = sampler.run([pub], shots=int(1e4))
    counts_int = job.result()[0].data.meas.get_int_counts()
    counts_bin = job.result()[0].data.meas.get_counts()
    shots = sum(counts_int.values())
    final_distribution_int = {key: val/shots for key, val in counts_int.items()}
    final_distribution_bin = {key: val/shots for key, val in counts_bin.items()}
    print(final_distribution_int)

    # Find the bitstring with the highest probability
    most_likely_bitstring_int = max(final_distribution_int, key=final_distribution_int.get)
    most_likely_bitstring_bin = max(final_distribution_bin, key=final_distribution_bin.get)
    print(f&quot;Most likely bitstring (int): {most_likely_bitstring_int}&quot;)
    print(f&quot;Most likely bitstring (binary): {most_likely_bitstring_bin}&quot;)
</code></pre>
<h1>The result I am getting:</h1>
<pre><code>      message: Optimization terminated successfully.
      success: True
      status: 1
      fun: -1304.0579420579418
      x: [ 2.521e+00  1.384e+00  2.585e+00  1.050e+00]
      nfev: 58
      maxcv: 0.0

      Most likely bitstring (int): 393
      Most likely bitstring (binary): 110001001
</code></pre>
<p>Where is the issue? Can somebody explain? I get the feeling it has something to do with the session, estimator and sampler commands.</p>
",QAOA for 3 cities TSP not working,<qiskit><qaoa><ibm-quantum-devices>,1,1,,,"QAOA for 3 cities TSP not working <p>I am trying to learn QAOA algorithm, and trying to code by reading the content at <a href=""https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm"" rel=""nofollow noreferrer"">https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm</a></p>
<p>The code I am writing to simulate on my local machine:</p>
<pre><code>    import numpy as np
    from qiskit_aer import Aer
    from qiskit_aer.primitives import sampler
    from qiskit_algorithms import QAOA, NumPyMinimumEigensolver
    from qiskit_algorithms.optimizers import optimizer
    from qiskit_optimization.algorithms import MinimumEigenOptimizer
    from qiskit_optimization.applications import Tsp
    from qiskit_optimization.converters import QuadraticProgramToQubo
    from qiskit.circuit.library.n_local.qaoa_ansatz import QAOAAnsatz
    from qiskit_ibm_runtime import Session

     n = 3
     num_qubits = n ** 2
     distance_matrix = np.array([
     [0, 48, 91],
     [48,  0, 63],
     [91, 63,  0],])
     tsp=Tsp(distance_matrix)
     qp = tsp.to_quadratic_program()
     print(qp.prettyprint())
     qp2qubo = QuadraticProgramToQubo()
     qubo = qp2qubo.convert(qp)
     print(qubo.prettyprint())

     cost_hamiltonian, offset = qubo.to_ising()
     print(offset)
     print(cost_hamiltonian)

     circuit = QAOAAnsatz(cost_operator=cost_hamiltonian, reps=2)
     circuit.measure_all()
     circuit.parameters
     from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
     backend = Aer.get_backend('aer_simulator_statevector')
     print(backend)
     pm = generate_preset_pass_manager(optimization_level=3,backend=backend)
     candidate_circuit = pm.run(circuit)
     candidate_circuit.draw('mpl', fold=False, idle_wires=False)
     initial_gamma = np.pi
     initial_beta = np.pi/2
     init_params = [initial_gamma, initial_beta, initial_gamma, initial_beta]

     def cost_func_estimator(params, ansatz, hamiltonian, estimator):

    # transform the observable defined on virtual qubits to
    # an observable defined on all physical qubits
    isa_hamiltonian = hamiltonian.apply_layout(ansatz.layout)

    pub = (ansatz, isa_hamiltonian, params)
    job = estimator.run([pub])

    results = job.result()[0]
    cost = results.data.evs
    print(cost)

    objective_func_vals.append(cost)

    return cost

    from qiskit_ibm_runtime import Session, EstimatorV2 as Estimator  
    from scipy.optimize import minimize  
    from qiskit_ibm_runtime import SamplerV2 as Sampler  

    objective_func_vals = [] # Global variable  
    with Session(backend=backend) as session:  
    # If using qiskit-ibm-runtime&lt;0.24.0, change `mode=` to `session=`  
    estimator = Estimator(mode=session)  
    estimator.options.default_shots = 1000  

    # Set simple error suppression/mitigation options
        result = minimize(
        cost_func_estimator,
        init_params,
        args=(candidate_circuit, cost_hamiltonian, estimator),
        method=&quot;COBYLA&quot;,
        tol=1e-6,
    )
    print(result)
    optimized_circuit = candidate_circuit.assign_parameters(result.x)
    sampler = Sampler(mode=session)
    sampler.options.default_shots = 10000

    pub= (optimized_circuit, )
    job = sampler.run([pub], shots=int(1e4))
    counts_int = job.result()[0].data.meas.get_int_counts()
    counts_bin = job.result()[0].data.meas.get_counts()
    shots = sum(counts_int.values())
    final_distribution_int = {key: val/shots for key, val in counts_int.items()}
    final_distribution_bin = {key: val/shots for key, val in counts_bin.items()}
    print(final_distribution_int)

    # Find the bitstring with the highest probability
    most_likely_bitstring_int = max(final_distribution_int, key=final_distribution_int.get)
    most_likely_bitstring_bin = max(final_distribution_bin, key=final_distribution_bin.get)
    print(f&quot;Most likely bitstring (int): {most_likely_bitstring_int}&quot;)
    print(f&quot;Most likely bitstring (binary): {most_likely_bitstring_bin}&quot;)
</code></pre>
<h1>The result I am getting:</h1>
<pre><code>      message: Optimization terminated successfully.
      success: True
      status: 1
      fun: -1304.0579420579418
      x: [ 2.521e+00  1.384e+00  2.585e+00  1.050e+00]
      nfev: 58
      maxcv: 0.0

      Most likely bitstring (int): 393
      Most likely bitstring (binary): 110001001
</code></pre>
<p>Where is the issue? Can somebody explain? I get the feeling it has something to do with the session, estimator and sampler commands.</p>
",qc,qaoa 3 cities tsp working p trying learn qaoa algorithm trying code reading content https nofollow noreferrer https p code writing simulate local machine pre code import numpy np import aer import sampler import qaoa numpyminimumeigensolver import optimizer import minimumeigenoptimizer import tsp import quadraticprogramtoqubo import qaoaansatz import session n 3 n 2 0 48 91 48 0 63 91 63 0 qp print qp2qubo quadraticprogramtoqubo qubo qp print offset print offset print circuit qaoaansatz import backend print backend pm circuit def params ansatz hamiltonian estimator transform observable defined virtual qubits observable defined physical qubits pub ansatz params job pub results 0 cost print cost cost return cost import session estimatorv2 estimator import minimize import samplerv2 sampler global variable session session using lt change estimator estimator 1000 set simple error options result minimize estimator quot cobyla quot print result sampler sampler 10000 job pub 1e4 0 0 shots sum key key val key key val print find bitstring highest probability max max print f quot likely bitstring int quot print f quot likely bitstring binary quot h1 result getting pre code message optimization terminated successfully success true status 1 fun x nfev 58 maxcv likely bitstring int 393 likely bitstring binary 110001001 p issue somebody explain get feeling something session estimator sampler,"[(0, 0.686253), (1, 0.01279159), (2, 0.036965128), (4, 0.023017652), (8, 0.04942808), (10, 0.014688966), (12, 0.029277435), (14, 0.064497), (19, 0.08255719)]"
40171,40172.0,2024-10-21 20:21:31,1,44,"<p>I'm trying to implement a circuit for QPE, i start with 4 qubits but the results are incorrect (even for 3 or 5 qubits).<br/>
the used unitary gate is : <code>U = UnitaryGate(Operator([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,np.exp(pi*2j*(10/16))]]), label=&quot;U&quot;)</code><br>
and this my impolementation<br>
<code>size_eig = 4</code><br>
<code>size_phi = 2</code><br>
<code>eig = QuantumRegister(size_eig, name=&quot;eig&quot;)</code><br>
<code>phi = QuantumRegister(size_phi, name=&quot;phi&quot;)</code><br>
<code>ceig = ClassicalRegister(size_eig, name=&quot;ceig&quot;)</code><br>
<code>qc = QuantumCircuit(eig,phi,ceig)</code><br>
<code>qc.x(phi)</code><br>
<code>qc.h(eig)</code><br>
<code>qc.append(U.power(1).control(), [eig[3]] + list(phi))</code><br>
<code>qc.append(U.power(2).control(), [eig[2]] + list(phi))</code> <br>
<code>qc.append(U.power(4).control(), [eig[1]] + list(phi))</code> <br>
<code>qc.append(U.power(8).control(), [eig[0]] + list(phi))</code> <br>
<code>qc.append(QFT(size_eig).inverse(), eig)</code> <br>
<code>qc.measure(eig,ceig)</code> <br>
<code>qc.draw()</code> <br>
<a href=""https://i.sstatic.net/654oW19B.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/654oW19B.png"" alt=""enter image description here"" /></a></p>
<p>for example, for the value 10/16 in the unitary gate, the output is supposed to be a bit string around the value 1010 but i get 1101 with a frequency 512 but i get 0101 (the wanted value but reversed) with a frequency of 237. What is the problem ?
<a href=""https://i.sstatic.net/JpyXfr12.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JpyXfr12.png"" alt=""enter image description here"" /></a></p>
",QPE implementation with 4 qubits,<qiskit><quantum-gate><programming><quantum-algorithms>,1,0,,,"QPE implementation with 4 qubits <p>I'm trying to implement a circuit for QPE, i start with 4 qubits but the results are incorrect (even for 3 or 5 qubits).<br/>
the used unitary gate is : <code>U = UnitaryGate(Operator([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,np.exp(pi*2j*(10/16))]]), label=&quot;U&quot;)</code><br>
and this my impolementation<br>
<code>size_eig = 4</code><br>
<code>size_phi = 2</code><br>
<code>eig = QuantumRegister(size_eig, name=&quot;eig&quot;)</code><br>
<code>phi = QuantumRegister(size_phi, name=&quot;phi&quot;)</code><br>
<code>ceig = ClassicalRegister(size_eig, name=&quot;ceig&quot;)</code><br>
<code>qc = QuantumCircuit(eig,phi,ceig)</code><br>
<code>qc.x(phi)</code><br>
<code>qc.h(eig)</code><br>
<code>qc.append(U.power(1).control(), [eig[3]] + list(phi))</code><br>
<code>qc.append(U.power(2).control(), [eig[2]] + list(phi))</code> <br>
<code>qc.append(U.power(4).control(), [eig[1]] + list(phi))</code> <br>
<code>qc.append(U.power(8).control(), [eig[0]] + list(phi))</code> <br>
<code>qc.append(QFT(size_eig).inverse(), eig)</code> <br>
<code>qc.measure(eig,ceig)</code> <br>
<code>qc.draw()</code> <br>
<a href=""https://i.sstatic.net/654oW19B.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/654oW19B.png"" alt=""enter image description here"" /></a></p>
<p>for example, for the value 10/16 in the unitary gate, the output is supposed to be a bit string around the value 1010 but i get 1101 with a frequency 512 but i get 0101 (the wanted value but reversed) with a frequency of 237. What is the problem ?
<a href=""https://i.sstatic.net/JpyXfr12.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/JpyXfr12.png"" alt=""enter image description here"" /></a></p>
",qc,qpe implementation 4 qubits p trying implement circuit qpe start 4 qubits results incorrect even 3 5 qubits used unitary gate code u unitarygate operator pi 2j quot u quot br impolementation br code 4 br code 2 br code eig quantumregister quot eig quot br code phi quantumregister quot phi quot br code ceig classicalregister quot ceig quot br code qc quantumcircuit eig phi ceig br code phi br code eig br code 1 eig 3 list phi br code 2 eig 2 list phi br code 4 eig 1 list phi br code 8 eig 0 list phi br code qft eig br code eig ceig br code br https nofollow noreferrer img https enter image description p example value unitary gate output supposed bit string around value 1010 get 1101 frequency 512 get 0101 wanted value reversed frequency problem https nofollow noreferrer img https enter image description,"[(0, 0.38991702), (2, 0.05957263), (4, 0.16005573), (6, 0.023799209), (12, 0.12921572), (13, 0.18133405), (19, 0.055239547)]"
40207,40208.0,2024-10-24 19:23:00,2,133,"<p>I am trying to run my below code on FakeSherbrooke() system, but I am getting an error as shown below:
<code>The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits</code>.</p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.providers.aer import AerSimulator

from qiskit.utils import QuantumInstance
from qiskit.providers.fake_provider import FakeSherbrooke
from qiskit.algorithms import VQE
# backend = Aer.get_backend('qasm_simulator')
# backend = AerSimulator()
backend = FakeSherbrooke()
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Really not sure why I am getting this error and how to resolve it. This code is using <code>qiskit== 0.46</code>.
I also tested the <code>qiskit==1.0</code> version of the above code and I still get this error.</p>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_aer import AerSimulator

import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2

from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aer.primitives import Estimator as Estimator
from qiskit_ibm_runtime.fake_provider import  FakeSherbrooke

backend = AerSimulator()
# backend = FakeSherbrooke()

Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]

H_op = SparsePauliOp.from_operator(Hamiltonian)

ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)

pm = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    basis_gates=None,
    seed_transpiler=28
)
ansatz_opt = pm.run(ansatz)

optimizer = COBYLA(maxiter= 1500)

estimator = Estimator(
    run_options = {&quot;shots&quot;: 1024, &quot;seed&quot;: 28},
)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)

vqe = VQE(
    estimator=estimator,
    ansatz=ansatz_opt,
    optimizer=optimizer,
    initial_point=initial_point_values
)

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Any way to correct this error?</p>
",The number of qubits of the ansatz does not match the operator,<qiskit><programming><vqe>,1,0,,,"The number of qubits of the ansatz does not match the operator <p>I am trying to run my below code on FakeSherbrooke() system, but I am getting an error as shown below:
<code>The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits</code>.</p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.providers.aer import AerSimulator

from qiskit.utils import QuantumInstance
from qiskit.providers.fake_provider import FakeSherbrooke
from qiskit.algorithms import VQE
# backend = Aer.get_backend('qasm_simulator')
# backend = AerSimulator()
backend = FakeSherbrooke()
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Really not sure why I am getting this error and how to resolve it. This code is using <code>qiskit== 0.46</code>.
I also tested the <code>qiskit==1.0</code> version of the above code and I still get this error.</p>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_aer import AerSimulator

import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2

from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aer.primitives import Estimator as Estimator
from qiskit_ibm_runtime.fake_provider import  FakeSherbrooke

backend = AerSimulator()
# backend = FakeSherbrooke()

Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]

H_op = SparsePauliOp.from_operator(Hamiltonian)

ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)

pm = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    basis_gates=None,
    seed_transpiler=28
)
ansatz_opt = pm.run(ansatz)

optimizer = COBYLA(maxiter= 1500)

estimator = Estimator(
    run_options = {&quot;shots&quot;: 1024, &quot;seed&quot;: 28},
)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)

vqe = VQE(
    estimator=estimator,
    ansatz=ansatz_opt,
    optimizer=optimizer,
    initial_point=initial_point_values
)

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Any way to correct this error?</p>
",qc,number qubits ansatz match operator p trying run code fakesherbrooke system getting error shown code number qubits ansatz match operator ansatz allow setting number qubits using pre code qiskit import transpile qiskit import aer import numpy np import matrixop import efficientsu2 import cobyla import aersimulator import quantuminstance import fakesherbrooke import vqe backend backend aersimulator backend fakesherbrooke hamiltonian matrixop hamiltonian ansatz efficientsu2 5 true transpile backend backend optimizer cobyla 1500 quantuminstance backend 1024 default 1024 changing number shots 32m 28 28 none 2 vqe vqe optimizer result print result p really sure getting error resolve code using code also tested code version code still get pre code import import aersimulator import numpy np import sparsepauliop import efficientsu2 import vqe import cobyla import estimator estimator import fakesherbrooke backend aersimulator backend fakesherbrooke hamiltonian hamiltonian ansatz efficientsu2 5 true pm ansatz optimizer cobyla 1500 estimator estimator quot shots quot 1024 quot seed quot 28 2 vqe vqe result print result p way correct error,"[(0, 0.84651834), (1, 0.022624645), (12, 0.025401415), (16, 0.027052997), (17, 0.056164283), (19, 0.021358494)]"
40243,40245.0,2024-10-29 15:55:43,0,58,"<p>From the &quot;<a href=""https://github.com/Strilanc/Quirk/wiki/How-to-use-Quirk"" rel=""nofollow noreferrer"">How to use Quirk</a>&quot; document, the equation for the <span class=""math-container"">$+A$</span> function is given by <span class=""math-container"">$|A⟩|E⟩ \mapsto |A⟩|E+A \; (\text{mod} \;2^{\text{len}(E)})⟩$</span>. However, I am specifically interested in the <span class=""math-container"">$+A \; (\text{mod} \; R)$</span> and <span class=""math-container"">$\times A \;(\text{mod} \; R)$</span> functions. For example, I understand that <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,1,1,1,%7B%22id%22:%22setA%22,%22arg%22:1%7D%5D,%5B%5D,%5B1,1,1,1,1,1,%22setR%22%5D,%5B%5D,%5B%22+AmodR1%22%5D%5D%7D"" rel=""nofollow noreferrer"">this circuit</a> which adds <span class=""math-container"">$+1$</span> to the least significant qubit but does not allow carry-over. However, if I resize the <span class=""math-container"">$+A \; (\text{mod} \; R)$</span> function to act on the two least significant qubits I get <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,1,1,1,%7B%22id%22:%22setA%22,%22arg%22:1%7D%5D,%5B%5D,%5B1,1,1,1,1,1,%22setR%22%5D,%5B%5D,%5B%22+AmodR2%22%5D%5D%7D"" rel=""nofollow noreferrer"">this circuit</a>, which has the same results for the first two rows of the amplitude display, but the following two rows are left unaffected. Similarly, if I expand the addition to the 3 least significant qubits I get <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,1,1,1,%7B%22id%22:%22setA%22,%22arg%22:1%7D%5D,%5B%5D,%5B1,1,1,1,1,1,%22setR%22%5D,%5B%5D,%5B%22+AmodR3%22%5D%5D%7D"" rel=""nofollow noreferrer"">this circuit</a>, which once again adds 1 to the first two rows, but now does nothing to the following 6 rows.</p>
<p>My question is, what is the explicit equation used here? There is clearly a <span class=""math-container"">$+A \; (\text{mod} \; R)$</span> operation being implemented, but it somehow depends upon how many qubits that function is acting on.</p>
",How does modular arithmetic work in quirk?,<quirk><arithmetic>,1,0,,,"How does modular arithmetic work in quirk? <p>From the &quot;<a href=""https://github.com/Strilanc/Quirk/wiki/How-to-use-Quirk"" rel=""nofollow noreferrer"">How to use Quirk</a>&quot; document, the equation for the <span class=""math-container"">$+A$</span> function is given by <span class=""math-container"">$|A⟩|E⟩ \mapsto |A⟩|E+A \; (\text{mod} \;2^{\text{len}(E)})⟩$</span>. However, I am specifically interested in the <span class=""math-container"">$+A \; (\text{mod} \; R)$</span> and <span class=""math-container"">$\times A \;(\text{mod} \; R)$</span> functions. For example, I understand that <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,1,1,1,%7B%22id%22:%22setA%22,%22arg%22:1%7D%5D,%5B%5D,%5B1,1,1,1,1,1,%22setR%22%5D,%5B%5D,%5B%22+AmodR1%22%5D%5D%7D"" rel=""nofollow noreferrer"">this circuit</a> which adds <span class=""math-container"">$+1$</span> to the least significant qubit but does not allow carry-over. However, if I resize the <span class=""math-container"">$+A \; (\text{mod} \; R)$</span> function to act on the two least significant qubits I get <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,1,1,1,%7B%22id%22:%22setA%22,%22arg%22:1%7D%5D,%5B%5D,%5B1,1,1,1,1,1,%22setR%22%5D,%5B%5D,%5B%22+AmodR2%22%5D%5D%7D"" rel=""nofollow noreferrer"">this circuit</a>, which has the same results for the first two rows of the amplitude display, but the following two rows are left unaffected. Similarly, if I expand the addition to the 3 least significant qubits I get <a href=""https://algassert.com/quirk#circuit=%7B%22cols%22:%5B%5B%22H%22,%22H%22,%22H%22,%22H%22%5D,%5B%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,%22%E2%80%A2%22,1,1,1,%22X%22%5D,%5B1,1,1,1,1,1,%7B%22id%22:%22setA%22,%22arg%22:1%7D%5D,%5B%5D,%5B1,1,1,1,1,1,%22setR%22%5D,%5B%5D,%5B%22+AmodR3%22%5D%5D%7D"" rel=""nofollow noreferrer"">this circuit</a>, which once again adds 1 to the first two rows, but now does nothing to the following 6 rows.</p>
<p>My question is, what is the explicit equation used here? There is clearly a <span class=""math-container"">$+A \; (\text{mod} \; R)$</span> operation being implemented, but it somehow depends upon how many qubits that function is acting on.</p>
",qc,modular arithmetic work quirk p quot https nofollow noreferrer use quirk quot document equation span function given span mod len e however specifically interested span mod r span mod r functions example understand https 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 5d 5b 22 e2 80 a2 22x 22 5d 5b1 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 7b 22id 22 22seta 22 22arg 7d 5d 5b 5d 22setr 22 5d 5b 5d 5b 22 5d 5d 7d nofollow noreferrer circuit adds span least significant qubit allow however resize span mod r function act two least significant qubits get https 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 5d 5b 22 e2 80 a2 22x 22 5d 5b1 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 7b 22id 22 22seta 22 22arg 7d 5d 5b 5d 22setr 22 5d 5b 5d 5b 22 5d 5d 7d nofollow noreferrer circuit results first two rows amplitude display following two rows left unaffected similarly expand addition 3 least significant qubits get https 7b 22cols 22 5b 5b 22h 22 22h 22 22h 22 22h 22 5d 5b 22 e2 80 a2 22x 22 5d 5b1 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 22 e2 80 a2 22x 22 5d 7b 22id 22 22seta 22 22arg 7d 5d 5b 5d 22setr 22 5d 5b 5d 5b 22 5d 5d 7d nofollow noreferrer circuit adds 1 first two rows nothing following 6 p question explicit equation used clearly span mod r operation implemented somehow depends upon many qubits function acting,"[(3, 0.11216051), (4, 0.0942789), (12, 0.67706156), (18, 0.087703325), (19, 0.023293462)]"
40291,,2024-11-03 08:44:53,1,42,"<p>I am reading the QAOA applications and trying the tutorial <a href=""https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm"" rel=""nofollow noreferrer"">https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm</a>. I want to just share what I have learnt about QAOA. We have a (say) optimization problem. We have to convert that Problem into a QUBO. We find the cost Hamiltonian of that objective function. Next step is to construct a mixer Hamiltonian. The parameters of that operator are what we are looking for. Once we set up this parametrized circuit. We send it to the estimator which takes as argument, the parametrized circuit. The estimator runs this circuit for a several times, and then calculates the expected value of the cost Hamiltonian. Now these expected values are sent to the classical optimizer with the parameters. The classical optimizer iterates and find the optimal (near optimal) parameters. Finally, the optimized circuit is run a final time on the sampler, which samples the bit strings. The optimum bit string should be seen with high probability.
Now I have a few questions. The tutorial does not make the mixer hamiltonian? Does the QAOA ansatz by default makes the mixer  with this command</p>
<pre><code> circuit = QAOAAnsatz(cost_operator=cost_hamiltonian, reps=2)
</code></pre>
<p>When I run the exact same code with the TSP Hamiltonian</p>
<pre><code>  n = 3
  num_qubits = n**2
  tsp = Tsp.create_random_instance(n, seed=123)
  adj_matrix = nx.to_numpy_array(tsp.graph)
  qp = tsp.to_quadratic_program()
  from qiskit_optimization.converters import QuadraticProgramToQubo
  qp2qubo = QuadraticProgramToQubo()
  qubo = qp2qubo.convert(qp)
  cost_hamiltonian, offset = qubo.to_ising()
</code></pre>
<p>So I have my cost Hamiltonian for my TSP on 2 cities only.
The optimizer ran with the parameters</p>
<pre><code>         result = minimize(
         cost_func_estimator,
         init_params,
         args=(candidate_circuit, cost_hamiltonian, estimator),
         method=&quot;COBYLA&quot;,
         tol=1e-12,
)
  The optimizer ran and stopped with the outcome  

           message: Optimization terminated successfully.
           success: True
           status: 1
           fun: 20.84815184815175
           x: [ 4.142e+00  1.570e+00  3.146e+00  1.568e+00  3.137e+00
            1.568e+00]
           nfev: 150
           maxcv: 0.0
</code></pre>
<p>I ran the code for the final time on the sampler as given in the above tutorial, however the results that I am getting, are everytime changing and not even once giving the right answer. I mean what is wrong with this approach.  Is this something to do with my approach or the QAOA has this limitation. So what class of problems will the QAOA solve efficiently.
How do interpret the results from the QAOA into classical. I am genuinely in need of help.</p>
",Solving a TSP using QAOA,<qiskit><optimization><qaoa><quantum-computing-for-finance>,1,0,,,"Solving a TSP using QAOA <p>I am reading the QAOA applications and trying the tutorial <a href=""https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm"" rel=""nofollow noreferrer"">https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm</a>. I want to just share what I have learnt about QAOA. We have a (say) optimization problem. We have to convert that Problem into a QUBO. We find the cost Hamiltonian of that objective function. Next step is to construct a mixer Hamiltonian. The parameters of that operator are what we are looking for. Once we set up this parametrized circuit. We send it to the estimator which takes as argument, the parametrized circuit. The estimator runs this circuit for a several times, and then calculates the expected value of the cost Hamiltonian. Now these expected values are sent to the classical optimizer with the parameters. The classical optimizer iterates and find the optimal (near optimal) parameters. Finally, the optimized circuit is run a final time on the sampler, which samples the bit strings. The optimum bit string should be seen with high probability.
Now I have a few questions. The tutorial does not make the mixer hamiltonian? Does the QAOA ansatz by default makes the mixer  with this command</p>
<pre><code> circuit = QAOAAnsatz(cost_operator=cost_hamiltonian, reps=2)
</code></pre>
<p>When I run the exact same code with the TSP Hamiltonian</p>
<pre><code>  n = 3
  num_qubits = n**2
  tsp = Tsp.create_random_instance(n, seed=123)
  adj_matrix = nx.to_numpy_array(tsp.graph)
  qp = tsp.to_quadratic_program()
  from qiskit_optimization.converters import QuadraticProgramToQubo
  qp2qubo = QuadraticProgramToQubo()
  qubo = qp2qubo.convert(qp)
  cost_hamiltonian, offset = qubo.to_ising()
</code></pre>
<p>So I have my cost Hamiltonian for my TSP on 2 cities only.
The optimizer ran with the parameters</p>
<pre><code>         result = minimize(
         cost_func_estimator,
         init_params,
         args=(candidate_circuit, cost_hamiltonian, estimator),
         method=&quot;COBYLA&quot;,
         tol=1e-12,
)
  The optimizer ran and stopped with the outcome  

           message: Optimization terminated successfully.
           success: True
           status: 1
           fun: 20.84815184815175
           x: [ 4.142e+00  1.570e+00  3.146e+00  1.568e+00  3.137e+00
            1.568e+00]
           nfev: 150
           maxcv: 0.0
</code></pre>
<p>I ran the code for the final time on the sampler as given in the above tutorial, however the results that I am getting, are everytime changing and not even once giving the right answer. I mean what is wrong with this approach.  Is this something to do with my approach or the QAOA has this limitation. So what class of problems will the QAOA solve efficiently.
How do interpret the results from the QAOA into classical. I am genuinely in need of help.</p>
",qc,solving tsp using qaoa p reading qaoa applications trying tutorial https nofollow noreferrer https want share learnt qaoa say optimization problem convert problem qubo find cost hamiltonian objective function next step construct mixer hamiltonian parameters operator looking set parametrized circuit send estimator takes argument parametrized circuit estimator runs circuit several times calculates expected value cost hamiltonian expected values sent classical optimizer parameters classical optimizer iterates find optimal near optimal parameters finally optimized circuit run final time sampler samples bit strings optimum bit string seen high probability questions tutorial make mixer hamiltonian qaoa ansatz default makes mixer command pre code circuit qaoaansatz p run exact code tsp hamiltonian pre code n 3 n 2 tsp n qp import quadraticprogramtoqubo qp2qubo quadraticprogramtoqubo qubo qp offset p cost hamiltonian tsp 2 cities optimizer ran parameters pre code result minimize estimator quot cobyla quot optimizer ran stopped outcome message optimization terminated successfully success true status 1 fun x nfev 150 maxcv p ran code final time sampler given tutorial however results getting everytime changing even giving right answer mean wrong approach something approach qaoa limitation class problems qaoa solve efficiently interpret results qaoa classical genuinely need,"[(0, 0.4948202), (1, 0.1287016), (4, 0.030741373), (7, 0.026121244), (8, 0.07743224), (11, 0.019859806), (12, 0.015381372), (14, 0.14657103), (18, 0.03668752), (19, 0.02315961)]"
40363,,2024-11-10 10:25:41,1,23,"<p>Excuse me for the basic question.</p>
<p>pennylane tutorial includes the following
「Since we are not going to train the quantum convolution layer, it is more efficient to apply it as a “pre-processing”」
It is my understanding that quantum machine learning generally involves adjusting and learning the amount of rotation of the rotation gate of a quantum circuit.
What is the reason for not train the quantum convolution layer and not adjusted rotation gate this time?</p>
<p><a href=""https://pennylane.ai/qml/demos/tutorial_quanvolution/"" rel=""nofollow noreferrer"">https://pennylane.ai/qml/demos/tutorial_quanvolution/</a></p>
",About Pennylane's QCNN Tutorial,<pennylane>,1,0,,,"About Pennylane's QCNN Tutorial <p>Excuse me for the basic question.</p>
<p>pennylane tutorial includes the following
「Since we are not going to train the quantum convolution layer, it is more efficient to apply it as a “pre-processing”」
It is my understanding that quantum machine learning generally involves adjusting and learning the amount of rotation of the rotation gate of a quantum circuit.
What is the reason for not train the quantum convolution layer and not adjusted rotation gate this time?</p>
<p><a href=""https://pennylane.ai/qml/demos/tutorial_quanvolution/"" rel=""nofollow noreferrer"">https://pennylane.ai/qml/demos/tutorial_quanvolution/</a></p>
",qc,pennylane qcnn tutorial p excuse basic p pennylane tutorial includes following going train quantum convolution layer efficient apply understanding quantum machine learning generally involves adjusting learning amount rotation rotation gate quantum circuit reason train quantum convolution layer adjusted rotation gate time p https nofollow noreferrer https,"[(4, 0.20023417), (6, 0.022157373), (8, 0.49602282), (9, 0.18136285), (12, 0.06779567), (13, 0.029390838)]"
40373,40374.0,2024-11-10 23:58:38,3,214,"<p>The provocatively titled <a href=""https://www.technologyreview.com/2024/11/07/1106730/why-ai-could-eat-quantum-computings-lunch/"" rel=""nofollow noreferrer"">Why AI could eat quantum computing’s lunch</a> provides an overview about what kinds of quantum systems that AI can tackle. The most interesting part of this article is that, apparently, AI can come up with &quot;good enough&quot; solutions to strongly correlated systems. This is surprising because strongly correlated systems are the types of systems that we lean on quantum computers to help with. There is a silver lining. The article says:</p>
<blockquote>
<p>One area where quantum computers look likely to have a clear advantage is in simulating how complex quantum systems evolve over time, says EPFL’s Carleo. This could provide invaluable insights for scientists in fields like statistical mechanics and high-energy physics, but it seems unlikely to lead to practical uses in the near term. “These are more niche applications that, in my opinion, do not justify the massive investments and the massive hype,” Carleo adds.</p>
</blockquote>
<p>My question is, what are these niche applications that quantum computers have a clear advantage in simulating?</p>
",What are the quantum simulation problems where AI doesn't eat quantum computing's lunch?,<hamiltonian-simulation><machine-learning><chemistry><dynamics>,2,3,,,"What are the quantum simulation problems where AI doesn't eat quantum computing's lunch? <p>The provocatively titled <a href=""https://www.technologyreview.com/2024/11/07/1106730/why-ai-could-eat-quantum-computings-lunch/"" rel=""nofollow noreferrer"">Why AI could eat quantum computing’s lunch</a> provides an overview about what kinds of quantum systems that AI can tackle. The most interesting part of this article is that, apparently, AI can come up with &quot;good enough&quot; solutions to strongly correlated systems. This is surprising because strongly correlated systems are the types of systems that we lean on quantum computers to help with. There is a silver lining. The article says:</p>
<blockquote>
<p>One area where quantum computers look likely to have a clear advantage is in simulating how complex quantum systems evolve over time, says EPFL’s Carleo. This could provide invaluable insights for scientists in fields like statistical mechanics and high-energy physics, but it seems unlikely to lead to practical uses in the near term. “These are more niche applications that, in my opinion, do not justify the massive investments and the massive hype,” Carleo adds.</p>
</blockquote>
<p>My question is, what are these niche applications that quantum computers have a clear advantage in simulating?</p>
",qc,quantum simulation problems ai eat quantum computing lunch p provocatively titled https nofollow noreferrer ai could eat quantum computing lunch provides overview kinds quantum systems ai tackle interesting part article apparently ai come quot good enough quot solutions strongly correlated systems surprising strongly correlated systems types systems lean quantum computers help silver lining article says blockquote p one area quantum computers look likely clear advantage simulating complex quantum systems evolve time says epfl carleo could provide invaluable insights scientists fields like statistical mechanics physics seems unlikely lead practical uses near term niche applications opinion justify massive investments massive hype carleo p question niche applications quantum computers clear advantage simulating,"[(1, 0.16994067), (7, 0.037942648), (8, 0.37825802), (9, 0.18272282), (12, 0.21244162), (19, 0.017407613)]"
40457,,2024-11-18 22:02:14,3,54,"<p>In <code>stim</code>, I normally define detectors as <code>DETECTOR rec[-1] rec[-2]</code>. In the <code>timeline</code> plot, detectors are written in explicit forms like <code>D1=rec[2]*rec[3]</code>, and each measurement is labelled with <code>rec</code> indices.</p>
<p>I wonder if there is a way to get this info in my code so I don't have to zoom in on the plot and try to find all the labels. I tried some compile functions, but they still show negative indices.</p>
",Understand which measurements is a detector looking at in Stim,<stim>,1,0,,,"Understand which measurements is a detector looking at in Stim <p>In <code>stim</code>, I normally define detectors as <code>DETECTOR rec[-1] rec[-2]</code>. In the <code>timeline</code> plot, detectors are written in explicit forms like <code>D1=rec[2]*rec[3]</code>, and each measurement is labelled with <code>rec</code> indices.</p>
<p>I wonder if there is a way to get this info in my code so I don't have to zoom in on the plot and try to find all the labels. I tried some compile functions, but they still show negative indices.</p>
",qc,understand measurements detector looking stim p code stim normally define detectors code detector rec rec code timeline plot detectors written explicit forms like code 2 rec 3 measurement labelled code rec p wonder way get info code zoom plot try find labels tried compile functions still show negative,"[(4, 0.056855436), (6, 0.24439824), (9, 0.05201311), (12, 0.021016622), (14, 0.6225348)]"
