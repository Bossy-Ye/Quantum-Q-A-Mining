Id,AcceptedAnswerId,CreationDate,Score,ViewCount,Body,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,text,From,processed_text,topics
93334,93346.0,2011-07-16 11:10:39,0,414,"<p>Is there some kind of generalization to the effect called Heisenbug? Because I would like to describe in my documentation how instrumenting a program changes the execution no matter what.</p>

<p>In <a href=""http://www.outpost9.com/reference/jargon/jargon_23.html#SEC30"" rel=""nofollow"">The New Hacker's Dictionary</a> it is defined as following:</p>

<blockquote>
  <p><strong>heisenbug</strong> /hi:'zen-buhg/ /n./ [from Heisenberg's Uncertainty Principle in quantum physics]</p>
  
  <p><strong>A bug that disappears or alters its behavior when one attempts to probe or
  isolate it.</strong> (This usage is not even particularly fanciful; the use of
  a debugger sometimes alters a program's operating environment
  significantly enough that buggy code, such as that which relies on the
  values of uninitialized memory, behaves quite differently.) Antonym of
  Bohr bug; see also mandelbug, schroedinbug. In C, nine out of ten
  heisenbugs result from uninitialized auto variables, fandango on core
  phenomena (esp. lossage related to corruption of the malloc arena) or
  errors that smash the stack.</p>
</blockquote>

<p>Actually this is a general problem, when trying to observe the programs state by instrumentatation (tracing, debugging, etc.) the program execution is changed no matter what. But the definition for Heisenbug clearly says, it is a bug which is masked due to debugging and which disappears. What about bugs, which appear due to debugging - there is no word for that.</p>

<p>Is there some kind of generalization, like <em>Heisenbug principle</em>?</p>
",Terminology question: Generalize Heisenbug,<terminology><debugging>,2,6,,,"Terminology question: Generalize Heisenbug <p>Is there some kind of generalization to the effect called Heisenbug? Because I would like to describe in my documentation how instrumenting a program changes the execution no matter what.</p>

<p>In <a href=""http://www.outpost9.com/reference/jargon/jargon_23.html#SEC30"" rel=""nofollow"">The New Hacker's Dictionary</a> it is defined as following:</p>

<blockquote>
  <p><strong>heisenbug</strong> /hi:'zen-buhg/ /n./ [from Heisenberg's Uncertainty Principle in quantum physics]</p>
  
  <p><strong>A bug that disappears or alters its behavior when one attempts to probe or
  isolate it.</strong> (This usage is not even particularly fanciful; the use of
  a debugger sometimes alters a program's operating environment
  significantly enough that buggy code, such as that which relies on the
  values of uninitialized memory, behaves quite differently.) Antonym of
  Bohr bug; see also mandelbug, schroedinbug. In C, nine out of ten
  heisenbugs result from uninitialized auto variables, fandango on core
  phenomena (esp. lossage related to corruption of the malloc arena) or
  errors that smash the stack.</p>
</blockquote>

<p>Actually this is a general problem, when trying to observe the programs state by instrumentatation (tracing, debugging, etc.) the program execution is changed no matter what. But the definition for Heisenbug clearly says, it is a bug which is masked due to debugging and which disappears. What about bugs, which appear due to debugging - there is no word for that.</p>

<p>Is there some kind of generalization, like <em>Heisenbug principle</em>?</p>
",se,terminology question generalize heisenbug p kind generalization effect called heisenbug would like describe documentation instrumenting program changes execution matter p http sec30 nofollow new hacker dictionary defined following blockquote p strong heisenbug heisenberg uncertainty principle quantum physics p strong bug disappears alters behavior one attempts probe isolate usage even particularly fanciful use debugger sometimes alters program operating environment significantly enough buggy code relies values uninitialized memory behaves quite differently antonym bohr bug see also mandelbug schroedinbug c nine ten heisenbugs result uninitialized auto variables fandango core phenomena esp lossage related corruption malloc arena errors smash p actually general problem trying observe programs state instrumentatation tracing debugging etc program execution changed matter definition heisenbug clearly says bug masked due debugging disappears bugs appear due debugging word p kind generalization like em heisenbug principle,"[(3, 0.088029355), (4, 0.05212427), (5, 0.036114585), (8, 0.3700111), (9, 0.1281254), (14, 0.26565927), (17, 0.011058896), (18, 0.017837381), (19, 0.029991923)]"
93334,93346.0,2011-07-16 11:10:39,0,414,"<p>Is there some kind of generalization to the effect called Heisenbug? Because I would like to describe in my documentation how instrumenting a program changes the execution no matter what.</p>

<p>In <a href=""http://www.outpost9.com/reference/jargon/jargon_23.html#SEC30"" rel=""nofollow"">The New Hacker's Dictionary</a> it is defined as following:</p>

<blockquote>
  <p><strong>heisenbug</strong> /hi:'zen-buhg/ /n./ [from Heisenberg's Uncertainty Principle in quantum physics]</p>
  
  <p><strong>A bug that disappears or alters its behavior when one attempts to probe or
  isolate it.</strong> (This usage is not even particularly fanciful; the use of
  a debugger sometimes alters a program's operating environment
  significantly enough that buggy code, such as that which relies on the
  values of uninitialized memory, behaves quite differently.) Antonym of
  Bohr bug; see also mandelbug, schroedinbug. In C, nine out of ten
  heisenbugs result from uninitialized auto variables, fandango on core
  phenomena (esp. lossage related to corruption of the malloc arena) or
  errors that smash the stack.</p>
</blockquote>

<p>Actually this is a general problem, when trying to observe the programs state by instrumentatation (tracing, debugging, etc.) the program execution is changed no matter what. But the definition for Heisenbug clearly says, it is a bug which is masked due to debugging and which disappears. What about bugs, which appear due to debugging - there is no word for that.</p>

<p>Is there some kind of generalization, like <em>Heisenbug principle</em>?</p>
",Terminology question: Generalize Heisenbug,<terminology><debugging>,2,6,,,"Terminology question: Generalize Heisenbug <p>Is there some kind of generalization to the effect called Heisenbug? Because I would like to describe in my documentation how instrumenting a program changes the execution no matter what.</p>

<p>In <a href=""http://www.outpost9.com/reference/jargon/jargon_23.html#SEC30"" rel=""nofollow"">The New Hacker's Dictionary</a> it is defined as following:</p>

<blockquote>
  <p><strong>heisenbug</strong> /hi:'zen-buhg/ /n./ [from Heisenberg's Uncertainty Principle in quantum physics]</p>
  
  <p><strong>A bug that disappears or alters its behavior when one attempts to probe or
  isolate it.</strong> (This usage is not even particularly fanciful; the use of
  a debugger sometimes alters a program's operating environment
  significantly enough that buggy code, such as that which relies on the
  values of uninitialized memory, behaves quite differently.) Antonym of
  Bohr bug; see also mandelbug, schroedinbug. In C, nine out of ten
  heisenbugs result from uninitialized auto variables, fandango on core
  phenomena (esp. lossage related to corruption of the malloc arena) or
  errors that smash the stack.</p>
</blockquote>

<p>Actually this is a general problem, when trying to observe the programs state by instrumentatation (tracing, debugging, etc.) the program execution is changed no matter what. But the definition for Heisenbug clearly says, it is a bug which is masked due to debugging and which disappears. What about bugs, which appear due to debugging - there is no word for that.</p>

<p>Is there some kind of generalization, like <em>Heisenbug principle</em>?</p>
",cr,terminology question generalize heisenbug p kind generalization effect called heisenbug would like describe documentation instrumenting program changes execution matter p http sec30 nofollow new hacker dictionary defined following blockquote p strong heisenbug heisenberg uncertainty principle quantum physics p strong bug disappears alters behavior one attempts probe isolate usage even particularly fanciful use debugger sometimes alters program operating environment significantly enough buggy code relies values uninitialized memory behaves quite differently antonym bohr bug see also mandelbug schroedinbug c nine ten heisenbugs result uninitialized auto variables fandango core phenomena esp lossage related corruption malloc arena errors smash p actually general problem trying observe programs state instrumentatation tracing debugging etc program execution changed matter definition heisenbug clearly says bug masked due debugging disappears bugs appear due debugging word p kind generalization like em heisenbug principle,"[(3, 0.088004306), (4, 0.052128963), (5, 0.036114477), (8, 0.37000865), (9, 0.12814827), (14, 0.2656538), (17, 0.011059128), (18, 0.017841212), (19, 0.029993404)]"
184936,,2013-01-26 14:52:17,1,3286,"<p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",Round Robin - how to determine the optimal quantum of time?,<unix><scheduling><process>,1,1,,,"Round Robin - how to determine the optimal quantum of time? <p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",se,round robin determine optimal quantum time p calculate proper quantum time http nofollow round robin process scheduling algorithm read http nofollow tanenbaum book quantum time cover like 80 running time p formula find optimal quantum time,"[(1, 0.34386572), (7, 0.18423218), (12, 0.031376757), (13, 0.22428213), (14, 0.088578686), (17, 0.1234467)]"
184936,,2013-01-26 14:52:17,1,3286,"<p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",Round Robin - how to determine the optimal quantum of time?,<unix><scheduling><process>,1,1,,,"Round Robin - how to determine the optimal quantum of time? <p>I have to calculate the proper quantum of time for <a href=""http://en.wikipedia.org/wiki/Round-robin_scheduling"" rel=""nofollow"">Round Robin process scheduling</a> algorithm. As I read in <a href=""http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"" rel=""nofollow"">Tanenbaum's</a> book, the quantum of time should cover like 80% of the running time of all processes.</p>

<p>Is there a formula how to find the optimal quantum of time?</p>
",cr,round robin determine optimal quantum time p calculate proper quantum time http nofollow round robin process scheduling algorithm read http nofollow tanenbaum book quantum time cover like 80 running time p formula find optimal quantum time,"[(1, 0.34389785), (7, 0.18422356), (12, 0.031377062), (13, 0.22424658), (14, 0.08858592), (17, 0.123451225)]"
242657,242660.0,2014-06-01 14:51:17,23,4258,"<p>Say Alice and Peter each have a 4GB USB flash memory stick. They meet and save on both sticks two files named <code>alice_to_peter.key</code> (2GB) and <code>peter_to_alice.key</code> (2GB) which contain randomly generated bits. They never meet again, but communicate electronically. Alice also maintains a variable called <code>alice_pointer</code> and Peter maintains variable called <code>peter_pointer</code>, both of which are initially set to zero.</p>

<p>When Alice needs to send a message to Peter, she does (where <code>n</code> is the nth byte of the message):</p>

<pre><code>encrypted_message_to_peter[n] = message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
encrypted_payload_to_peter = alice_pointer + encrypted_message_to_peter
alice_pointer += length(encrypted_message_to_peter)
</code></pre>

<p><del>(and for maximum security, the used part of the key can be erased)</del></p>

<p>Peter receives <code>encrypted_payload_to_peter</code>, reads <code>alice_pointer</code> stored at the beginning of message and does:</p>

<pre><code>message_to_peter[n] = encrypted_message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
</code></pre>

<p><del>And for maximum security, after reading of message also erase the used part of the key.</del>
- EDIT: In fact this step with this simple algorithm (without integrity check and authentication) decreases security, see Paŭlo Ebermann post below.</p>

<p>When Peter needs to send a message to Alice they do the reverse, this time with <code>peter_to_alice.key</code> and <code>peter_pointer</code>.</p>

<p>With this trivial schema they can send each day for the next 50 years 2GB / (50 * 365) = ~115kB of encrypted data in both directions. If they need more data to send, they could use larger keys, for example with today's 2TB HDs (1TB keys) it would be possible to exchange 60MB/day for the next 50 years! That's a lot of data in practice; for example, using compression it's more than hour of high quality voice communication.</p>

<p>It seems to me that there is no way for an attacker to read the encrypted messages without the keys, because even if they have an infinitely fast computer, with brute force they can get every possible message under the limit, but this is an astronomical number of messages and the attacker doesn't know which of them is the actual message.</p>

<p>Am I right? Is this communication scheme really absolutely secure? And if it is secure, does it have its own name? XOR encryption is well-known, but I'm looking for the name of this concrete practical application using large keys on both sides? I am humbly expecting that this application has been invented someone before me. :-)</p>

<p><del>Note: If it's absolutely secure then it's amazing, because with today's low cost large storage devices, it would be much cheaper to do secure communication than with expensive quantum cryptography, and this has equivalent security!</del></p>

<p><strong>EDIT:</strong>
I think this will be more practical in the future as storage costs decrease. <del>It can solve secure communication forever.</del> Today you have no certainty if someone successfully attacks existing ciphers even a year later and makes its often expensive implementations insecure. In many cases before communication occurs, when both sides meet personally, that's the time to generate the keys. I think it's perfect for military communication, for example between submarines which can have HDs with large keys, and military central can have a HD for each submarine. It could also be practical in everyday life, for example to control your bank account, because when you create your account you meet with the bank etc.</p>
",Is this simple XOR encrypted communication absolutely secure?,<communication><encryption>,4,10,,,"Is this simple XOR encrypted communication absolutely secure? <p>Say Alice and Peter each have a 4GB USB flash memory stick. They meet and save on both sticks two files named <code>alice_to_peter.key</code> (2GB) and <code>peter_to_alice.key</code> (2GB) which contain randomly generated bits. They never meet again, but communicate electronically. Alice also maintains a variable called <code>alice_pointer</code> and Peter maintains variable called <code>peter_pointer</code>, both of which are initially set to zero.</p>

<p>When Alice needs to send a message to Peter, she does (where <code>n</code> is the nth byte of the message):</p>

<pre><code>encrypted_message_to_peter[n] = message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
encrypted_payload_to_peter = alice_pointer + encrypted_message_to_peter
alice_pointer += length(encrypted_message_to_peter)
</code></pre>

<p><del>(and for maximum security, the used part of the key can be erased)</del></p>

<p>Peter receives <code>encrypted_payload_to_peter</code>, reads <code>alice_pointer</code> stored at the beginning of message and does:</p>

<pre><code>message_to_peter[n] = encrypted_message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
</code></pre>

<p><del>And for maximum security, after reading of message also erase the used part of the key.</del>
- EDIT: In fact this step with this simple algorithm (without integrity check and authentication) decreases security, see Paŭlo Ebermann post below.</p>

<p>When Peter needs to send a message to Alice they do the reverse, this time with <code>peter_to_alice.key</code> and <code>peter_pointer</code>.</p>

<p>With this trivial schema they can send each day for the next 50 years 2GB / (50 * 365) = ~115kB of encrypted data in both directions. If they need more data to send, they could use larger keys, for example with today's 2TB HDs (1TB keys) it would be possible to exchange 60MB/day for the next 50 years! That's a lot of data in practice; for example, using compression it's more than hour of high quality voice communication.</p>

<p>It seems to me that there is no way for an attacker to read the encrypted messages without the keys, because even if they have an infinitely fast computer, with brute force they can get every possible message under the limit, but this is an astronomical number of messages and the attacker doesn't know which of them is the actual message.</p>

<p>Am I right? Is this communication scheme really absolutely secure? And if it is secure, does it have its own name? XOR encryption is well-known, but I'm looking for the name of this concrete practical application using large keys on both sides? I am humbly expecting that this application has been invented someone before me. :-)</p>

<p><del>Note: If it's absolutely secure then it's amazing, because with today's low cost large storage devices, it would be much cheaper to do secure communication than with expensive quantum cryptography, and this has equivalent security!</del></p>

<p><strong>EDIT:</strong>
I think this will be more practical in the future as storage costs decrease. <del>It can solve secure communication forever.</del> Today you have no certainty if someone successfully attacks existing ciphers even a year later and makes its often expensive implementations insecure. In many cases before communication occurs, when both sides meet personally, that's the time to generate the keys. I think it's perfect for military communication, for example between submarines which can have HDs with large keys, and military central can have a HD for each submarine. It could also be practical in everyday life, for example to control your bank account, because when you create your account you meet with the bank etc.</p>
",se,simple xor encrypted communication absolutely secure p say alice peter 4gb usb flash memory stick meet save sticks two files named code 2gb code 2gb contain randomly generated bits never meet communicate electronically alice also maintains variable called code peter maintains variable called code initially set p alice needs send message peter code n nth byte message pre code n n xor n length p del maximum security used part key erased p peter receives code reads code stored beginning message pre code n n xor n p del maximum security reading message also erase used part edit fact step simple algorithm without integrity check authentication decreases security see paŭlo ebermann post p peter needs send message alice reverse time code code p trivial schema send day next 50 years 2gb 50 365 encrypted data directions need data send could use larger keys example today 2tb hds 1tb keys would possible exchange next 50 years lot data practice example using compression hour high quality voice p seems way attacker read encrypted messages without keys even infinitely fast computer brute force get every possible message limit astronomical number messages attacker know actual p right communication scheme really absolutely secure secure name xor encryption looking name concrete practical application using large keys sides humbly expecting application invented someone p del note absolutely secure amazing today low cost large storage devices would much cheaper secure communication expensive quantum cryptography equivalent security p strong edit think practical future storage costs decrease del solve secure communication today certainty someone successfully attacks existing ciphers even year later makes often expensive implementations insecure many cases communication occurs sides meet personally time generate keys think perfect military communication example submarines hds large keys military central hd submarine could also practical everyday life example control bank account create account meet bank,"[(0, 0.039646257), (3, 0.054387726), (5, 0.04410587), (7, 0.33312857), (8, 0.2572115), (9, 0.029026326), (13, 0.016324803), (14, 0.11707681), (17, 0.010042647), (18, 0.09867874)]"
242657,242660.0,2014-06-01 14:51:17,23,4258,"<p>Say Alice and Peter each have a 4GB USB flash memory stick. They meet and save on both sticks two files named <code>alice_to_peter.key</code> (2GB) and <code>peter_to_alice.key</code> (2GB) which contain randomly generated bits. They never meet again, but communicate electronically. Alice also maintains a variable called <code>alice_pointer</code> and Peter maintains variable called <code>peter_pointer</code>, both of which are initially set to zero.</p>

<p>When Alice needs to send a message to Peter, she does (where <code>n</code> is the nth byte of the message):</p>

<pre><code>encrypted_message_to_peter[n] = message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
encrypted_payload_to_peter = alice_pointer + encrypted_message_to_peter
alice_pointer += length(encrypted_message_to_peter)
</code></pre>

<p><del>(and for maximum security, the used part of the key can be erased)</del></p>

<p>Peter receives <code>encrypted_payload_to_peter</code>, reads <code>alice_pointer</code> stored at the beginning of message and does:</p>

<pre><code>message_to_peter[n] = encrypted_message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
</code></pre>

<p><del>And for maximum security, after reading of message also erase the used part of the key.</del>
- EDIT: In fact this step with this simple algorithm (without integrity check and authentication) decreases security, see Paŭlo Ebermann post below.</p>

<p>When Peter needs to send a message to Alice they do the reverse, this time with <code>peter_to_alice.key</code> and <code>peter_pointer</code>.</p>

<p>With this trivial schema they can send each day for the next 50 years 2GB / (50 * 365) = ~115kB of encrypted data in both directions. If they need more data to send, they could use larger keys, for example with today's 2TB HDs (1TB keys) it would be possible to exchange 60MB/day for the next 50 years! That's a lot of data in practice; for example, using compression it's more than hour of high quality voice communication.</p>

<p>It seems to me that there is no way for an attacker to read the encrypted messages without the keys, because even if they have an infinitely fast computer, with brute force they can get every possible message under the limit, but this is an astronomical number of messages and the attacker doesn't know which of them is the actual message.</p>

<p>Am I right? Is this communication scheme really absolutely secure? And if it is secure, does it have its own name? XOR encryption is well-known, but I'm looking for the name of this concrete practical application using large keys on both sides? I am humbly expecting that this application has been invented someone before me. :-)</p>

<p><del>Note: If it's absolutely secure then it's amazing, because with today's low cost large storage devices, it would be much cheaper to do secure communication than with expensive quantum cryptography, and this has equivalent security!</del></p>

<p><strong>EDIT:</strong>
I think this will be more practical in the future as storage costs decrease. <del>It can solve secure communication forever.</del> Today you have no certainty if someone successfully attacks existing ciphers even a year later and makes its often expensive implementations insecure. In many cases before communication occurs, when both sides meet personally, that's the time to generate the keys. I think it's perfect for military communication, for example between submarines which can have HDs with large keys, and military central can have a HD for each submarine. It could also be practical in everyday life, for example to control your bank account, because when you create your account you meet with the bank etc.</p>
",Is this simple XOR encrypted communication absolutely secure?,<communication><encryption>,4,10,,,"Is this simple XOR encrypted communication absolutely secure? <p>Say Alice and Peter each have a 4GB USB flash memory stick. They meet and save on both sticks two files named <code>alice_to_peter.key</code> (2GB) and <code>peter_to_alice.key</code> (2GB) which contain randomly generated bits. They never meet again, but communicate electronically. Alice also maintains a variable called <code>alice_pointer</code> and Peter maintains variable called <code>peter_pointer</code>, both of which are initially set to zero.</p>

<p>When Alice needs to send a message to Peter, she does (where <code>n</code> is the nth byte of the message):</p>

<pre><code>encrypted_message_to_peter[n] = message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
encrypted_payload_to_peter = alice_pointer + encrypted_message_to_peter
alice_pointer += length(encrypted_message_to_peter)
</code></pre>

<p><del>(and for maximum security, the used part of the key can be erased)</del></p>

<p>Peter receives <code>encrypted_payload_to_peter</code>, reads <code>alice_pointer</code> stored at the beginning of message and does:</p>

<pre><code>message_to_peter[n] = encrypted_message_to_peter[n] XOR alice_to_peter.key[alice_pointer + n]
</code></pre>

<p><del>And for maximum security, after reading of message also erase the used part of the key.</del>
- EDIT: In fact this step with this simple algorithm (without integrity check and authentication) decreases security, see Paŭlo Ebermann post below.</p>

<p>When Peter needs to send a message to Alice they do the reverse, this time with <code>peter_to_alice.key</code> and <code>peter_pointer</code>.</p>

<p>With this trivial schema they can send each day for the next 50 years 2GB / (50 * 365) = ~115kB of encrypted data in both directions. If they need more data to send, they could use larger keys, for example with today's 2TB HDs (1TB keys) it would be possible to exchange 60MB/day for the next 50 years! That's a lot of data in practice; for example, using compression it's more than hour of high quality voice communication.</p>

<p>It seems to me that there is no way for an attacker to read the encrypted messages without the keys, because even if they have an infinitely fast computer, with brute force they can get every possible message under the limit, but this is an astronomical number of messages and the attacker doesn't know which of them is the actual message.</p>

<p>Am I right? Is this communication scheme really absolutely secure? And if it is secure, does it have its own name? XOR encryption is well-known, but I'm looking for the name of this concrete practical application using large keys on both sides? I am humbly expecting that this application has been invented someone before me. :-)</p>

<p><del>Note: If it's absolutely secure then it's amazing, because with today's low cost large storage devices, it would be much cheaper to do secure communication than with expensive quantum cryptography, and this has equivalent security!</del></p>

<p><strong>EDIT:</strong>
I think this will be more practical in the future as storage costs decrease. <del>It can solve secure communication forever.</del> Today you have no certainty if someone successfully attacks existing ciphers even a year later and makes its often expensive implementations insecure. In many cases before communication occurs, when both sides meet personally, that's the time to generate the keys. I think it's perfect for military communication, for example between submarines which can have HDs with large keys, and military central can have a HD for each submarine. It could also be practical in everyday life, for example to control your bank account, because when you create your account you meet with the bank etc.</p>
",cr,simple xor encrypted communication absolutely secure p say alice peter 4gb usb flash memory stick meet save sticks two files named code 2gb code 2gb contain randomly generated bits never meet communicate electronically alice also maintains variable called code peter maintains variable called code initially set p alice needs send message peter code n nth byte message pre code n n xor n length p del maximum security used part key erased p peter receives code reads code stored beginning message pre code n n xor n p del maximum security reading message also erase used part edit fact step simple algorithm without integrity check authentication decreases security see paŭlo ebermann post p peter needs send message alice reverse time code code p trivial schema send day next 50 years 2gb 50 365 encrypted data directions need data send could use larger keys example today 2tb hds 1tb keys would possible exchange next 50 years lot data practice example using compression hour high quality voice p seems way attacker read encrypted messages without keys even infinitely fast computer brute force get every possible message limit astronomical number messages attacker know actual p right communication scheme really absolutely secure secure name xor encryption looking name concrete practical application using large keys sides humbly expecting application invented someone p del note absolutely secure amazing today low cost large storage devices would much cheaper secure communication expensive quantum cryptography equivalent security p strong edit think practical future storage costs decrease del solve secure communication today certainty someone successfully attacks existing ciphers even year later makes often expensive implementations insecure many cases communication occurs sides meet personally time generate keys think perfect military communication example submarines hds large keys military central hd submarine could also practical everyday life example control bank account create account meet bank,"[(0, 0.039643824), (3, 0.054387514), (5, 0.044107202), (7, 0.3331307), (8, 0.25720572), (9, 0.029025953), (13, 0.016327431), (14, 0.117081165), (17, 0.010042684), (18, 0.09867709)]"
339048,339082.0,2016-12-29 02:55:39,1,183,"<p>(For more backstory/explanation, see <a href=""https://softwareengineering.stackexchange.com/questions/339028/creating-a-good-problem-statement"">my previous question</a>.)</p>

<p>I'm a middle school student working on a very, very informal project; my problem statement is as follows:</p>

<blockquote>
  <p>There is no way for theoreticians, researchers, and students in the field of quantum computing to simulate and test complex, large quantum circuits in an intuitive, efficient way without creating the code for the application themselves. A web application that works in popular browsers with an simple interface that could accurately produce results on the outcomes of quantum algorithms, error correction codes, entanglement, decoherence, and the other aspects of both an ideal and realistic interface would allow professionals and students alike to test their ideas and get a better understanding of the field of quantum computing.</p>
</blockquote>

<p>So, as I am working through the book Code Complete, the next step was to list requirements. As I've never done this before and it is such an informal project, I am unsure if the requirements list I came up with is any good, or if there are improvements that should be made to it. So here's the list:</p>

<ol>
<li>Takes in as input starting state of the qubits, each gate to be applied to which qubit, how many qubits should be used, and what implementation of quantum computing they'd like to test in (for decoherence time estimates).</li>
<li>Outputs should be current state of every qubit and probability of |0> and |1> state for every qubit.</li>
<li>Outputs should be given on the website and downloadable along with inputs in a text file. </li>
<li>State of qubits should be a vector, probability should be a number from 0 to 1, gates should be one of several commonly used gates or the custom gate option.</li>
<li>Inputs for gates should be one of several buttons (pressed).</li>
<li>Inputs for state and number of qubits should be integer input.</li>
<li>Once user inputs data and presses the button to compute, it should not take very long to produce the answer (e.g., one minute <em>max</em> for 5 qubit calculations is one benchmark).</li>
<li>Should be a website interface, with input blanks based on previous user input, i.e., create an account to save your simulations (takes in email and password), then a tab to look at previous text files from simulations and a tab to create a new simulation. Then, the user would input the number of qubits and starting state of qubits, click next and it will have you list gates for 1st qubit, click done, 2nd qubit, etc. If the option inputted is custom gate, a blank pops up where you can fill in the necessary data for the gate. When done, it transitions to a ""calculating"" style screen, and then gives the result and text file to download, with an option to save and an option to start over (last option available throughout).</li>
<li>The safety of the user's email, password, and text files must be high, as there could be important/confidential research-related information stored there.</li>
<li>Place on site to report bugs and request improvements.</li>
<li>Has common quantum gates available <em>and</em> a custom gate option.</li>
<li>Simulates decoherence, entanglement, and other common features of quantum computing.</li>
<li>Allows choice between ideal (no decoherence) and non-ideal (decoherence) quantum computer.</li>
<li>Generalizable to large numbers of qubits (runs as efficiently as possible). </li>
<li>Documentation on-site for users.</li>
<li>Accurate results (basic cases, at minimum, checked against accepted results.</li>
<li>Option to make text files public/private and a location to access public simulations?</li>
</ol>
","One-person, informal project - creating good requirements",<design><requirements><software><code-complete>,1,5,,,"One-person, informal project - creating good requirements <p>(For more backstory/explanation, see <a href=""https://softwareengineering.stackexchange.com/questions/339028/creating-a-good-problem-statement"">my previous question</a>.)</p>

<p>I'm a middle school student working on a very, very informal project; my problem statement is as follows:</p>

<blockquote>
  <p>There is no way for theoreticians, researchers, and students in the field of quantum computing to simulate and test complex, large quantum circuits in an intuitive, efficient way without creating the code for the application themselves. A web application that works in popular browsers with an simple interface that could accurately produce results on the outcomes of quantum algorithms, error correction codes, entanglement, decoherence, and the other aspects of both an ideal and realistic interface would allow professionals and students alike to test their ideas and get a better understanding of the field of quantum computing.</p>
</blockquote>

<p>So, as I am working through the book Code Complete, the next step was to list requirements. As I've never done this before and it is such an informal project, I am unsure if the requirements list I came up with is any good, or if there are improvements that should be made to it. So here's the list:</p>

<ol>
<li>Takes in as input starting state of the qubits, each gate to be applied to which qubit, how many qubits should be used, and what implementation of quantum computing they'd like to test in (for decoherence time estimates).</li>
<li>Outputs should be current state of every qubit and probability of |0> and |1> state for every qubit.</li>
<li>Outputs should be given on the website and downloadable along with inputs in a text file. </li>
<li>State of qubits should be a vector, probability should be a number from 0 to 1, gates should be one of several commonly used gates or the custom gate option.</li>
<li>Inputs for gates should be one of several buttons (pressed).</li>
<li>Inputs for state and number of qubits should be integer input.</li>
<li>Once user inputs data and presses the button to compute, it should not take very long to produce the answer (e.g., one minute <em>max</em> for 5 qubit calculations is one benchmark).</li>
<li>Should be a website interface, with input blanks based on previous user input, i.e., create an account to save your simulations (takes in email and password), then a tab to look at previous text files from simulations and a tab to create a new simulation. Then, the user would input the number of qubits and starting state of qubits, click next and it will have you list gates for 1st qubit, click done, 2nd qubit, etc. If the option inputted is custom gate, a blank pops up where you can fill in the necessary data for the gate. When done, it transitions to a ""calculating"" style screen, and then gives the result and text file to download, with an option to save and an option to start over (last option available throughout).</li>
<li>The safety of the user's email, password, and text files must be high, as there could be important/confidential research-related information stored there.</li>
<li>Place on site to report bugs and request improvements.</li>
<li>Has common quantum gates available <em>and</em> a custom gate option.</li>
<li>Simulates decoherence, entanglement, and other common features of quantum computing.</li>
<li>Allows choice between ideal (no decoherence) and non-ideal (decoherence) quantum computer.</li>
<li>Generalizable to large numbers of qubits (runs as efficiently as possible). </li>
<li>Documentation on-site for users.</li>
<li>Accurate results (basic cases, at minimum, checked against accepted results.</li>
<li>Option to make text files public/private and a location to access public simulations?</li>
</ol>
",cr,informal project creating good requirements p see https previous question p middle school student working informal project problem statement follows blockquote p way theoreticians researchers students field quantum computing simulate test complex large quantum circuits intuitive efficient way without creating code application web application works popular browsers simple interface could accurately produce results outcomes quantum algorithms error correction codes entanglement decoherence aspects ideal realistic interface would allow professionals students alike test ideas get better understanding field quantum p working book code complete next step list requirements never done informal project unsure requirements list came good improvements made list ol li takes input starting state qubits gate applied qubit many qubits used implementation quantum computing like test decoherence time estimates li outputs current state every qubit probability state every li outputs given website downloadable along inputs text file li state qubits vector probability number 0 1 gates one several commonly used gates custom gate li inputs gates one several buttons pressed li inputs state number qubits integer li user inputs data presses button compute take long produce answer one minute em max 5 qubit calculations one benchmark li website interface input blanks based previous user input create account save simulations takes email password tab look previous text files simulations tab create new simulation user would input number qubits starting state qubits click next list gates 1st qubit click done 2nd qubit etc option inputted custom gate blank pops fill necessary data gate done transitions calculating style screen gives result text file download option save option start last option available throughout li safety user email password text files must high could information stored li place site report bugs request li common quantum gates available em custom gate li simulates decoherence entanglement common features quantum li allows choice ideal decoherence decoherence quantum li generalizable large numbers qubits runs efficiently possible li documentation li accurate results basic cases minimum checked accepted li option make text files location access public simulations,"[(1, 0.04887813), (2, 0.01674648), (5, 0.01084638), (7, 0.16981284), (8, 0.09002817), (9, 0.087463915), (13, 0.054009084), (14, 0.4027717), (17, 0.011400535), (18, 0.079530984), (19, 0.016040038)]"
339048,339082.0,2016-12-29 02:55:39,1,183,"<p>(For more backstory/explanation, see <a href=""https://softwareengineering.stackexchange.com/questions/339028/creating-a-good-problem-statement"">my previous question</a>.)</p>

<p>I'm a middle school student working on a very, very informal project; my problem statement is as follows:</p>

<blockquote>
  <p>There is no way for theoreticians, researchers, and students in the field of quantum computing to simulate and test complex, large quantum circuits in an intuitive, efficient way without creating the code for the application themselves. A web application that works in popular browsers with an simple interface that could accurately produce results on the outcomes of quantum algorithms, error correction codes, entanglement, decoherence, and the other aspects of both an ideal and realistic interface would allow professionals and students alike to test their ideas and get a better understanding of the field of quantum computing.</p>
</blockquote>

<p>So, as I am working through the book Code Complete, the next step was to list requirements. As I've never done this before and it is such an informal project, I am unsure if the requirements list I came up with is any good, or if there are improvements that should be made to it. So here's the list:</p>

<ol>
<li>Takes in as input starting state of the qubits, each gate to be applied to which qubit, how many qubits should be used, and what implementation of quantum computing they'd like to test in (for decoherence time estimates).</li>
<li>Outputs should be current state of every qubit and probability of |0> and |1> state for every qubit.</li>
<li>Outputs should be given on the website and downloadable along with inputs in a text file. </li>
<li>State of qubits should be a vector, probability should be a number from 0 to 1, gates should be one of several commonly used gates or the custom gate option.</li>
<li>Inputs for gates should be one of several buttons (pressed).</li>
<li>Inputs for state and number of qubits should be integer input.</li>
<li>Once user inputs data and presses the button to compute, it should not take very long to produce the answer (e.g., one minute <em>max</em> for 5 qubit calculations is one benchmark).</li>
<li>Should be a website interface, with input blanks based on previous user input, i.e., create an account to save your simulations (takes in email and password), then a tab to look at previous text files from simulations and a tab to create a new simulation. Then, the user would input the number of qubits and starting state of qubits, click next and it will have you list gates for 1st qubit, click done, 2nd qubit, etc. If the option inputted is custom gate, a blank pops up where you can fill in the necessary data for the gate. When done, it transitions to a ""calculating"" style screen, and then gives the result and text file to download, with an option to save and an option to start over (last option available throughout).</li>
<li>The safety of the user's email, password, and text files must be high, as there could be important/confidential research-related information stored there.</li>
<li>Place on site to report bugs and request improvements.</li>
<li>Has common quantum gates available <em>and</em> a custom gate option.</li>
<li>Simulates decoherence, entanglement, and other common features of quantum computing.</li>
<li>Allows choice between ideal (no decoherence) and non-ideal (decoherence) quantum computer.</li>
<li>Generalizable to large numbers of qubits (runs as efficiently as possible). </li>
<li>Documentation on-site for users.</li>
<li>Accurate results (basic cases, at minimum, checked against accepted results.</li>
<li>Option to make text files public/private and a location to access public simulations?</li>
</ol>
","One-person, informal project - creating good requirements",<design><requirements><software><code-complete>,1,5,,,"One-person, informal project - creating good requirements <p>(For more backstory/explanation, see <a href=""https://softwareengineering.stackexchange.com/questions/339028/creating-a-good-problem-statement"">my previous question</a>.)</p>

<p>I'm a middle school student working on a very, very informal project; my problem statement is as follows:</p>

<blockquote>
  <p>There is no way for theoreticians, researchers, and students in the field of quantum computing to simulate and test complex, large quantum circuits in an intuitive, efficient way without creating the code for the application themselves. A web application that works in popular browsers with an simple interface that could accurately produce results on the outcomes of quantum algorithms, error correction codes, entanglement, decoherence, and the other aspects of both an ideal and realistic interface would allow professionals and students alike to test their ideas and get a better understanding of the field of quantum computing.</p>
</blockquote>

<p>So, as I am working through the book Code Complete, the next step was to list requirements. As I've never done this before and it is such an informal project, I am unsure if the requirements list I came up with is any good, or if there are improvements that should be made to it. So here's the list:</p>

<ol>
<li>Takes in as input starting state of the qubits, each gate to be applied to which qubit, how many qubits should be used, and what implementation of quantum computing they'd like to test in (for decoherence time estimates).</li>
<li>Outputs should be current state of every qubit and probability of |0> and |1> state for every qubit.</li>
<li>Outputs should be given on the website and downloadable along with inputs in a text file. </li>
<li>State of qubits should be a vector, probability should be a number from 0 to 1, gates should be one of several commonly used gates or the custom gate option.</li>
<li>Inputs for gates should be one of several buttons (pressed).</li>
<li>Inputs for state and number of qubits should be integer input.</li>
<li>Once user inputs data and presses the button to compute, it should not take very long to produce the answer (e.g., one minute <em>max</em> for 5 qubit calculations is one benchmark).</li>
<li>Should be a website interface, with input blanks based on previous user input, i.e., create an account to save your simulations (takes in email and password), then a tab to look at previous text files from simulations and a tab to create a new simulation. Then, the user would input the number of qubits and starting state of qubits, click next and it will have you list gates for 1st qubit, click done, 2nd qubit, etc. If the option inputted is custom gate, a blank pops up where you can fill in the necessary data for the gate. When done, it transitions to a ""calculating"" style screen, and then gives the result and text file to download, with an option to save and an option to start over (last option available throughout).</li>
<li>The safety of the user's email, password, and text files must be high, as there could be important/confidential research-related information stored there.</li>
<li>Place on site to report bugs and request improvements.</li>
<li>Has common quantum gates available <em>and</em> a custom gate option.</li>
<li>Simulates decoherence, entanglement, and other common features of quantum computing.</li>
<li>Allows choice between ideal (no decoherence) and non-ideal (decoherence) quantum computer.</li>
<li>Generalizable to large numbers of qubits (runs as efficiently as possible). </li>
<li>Documentation on-site for users.</li>
<li>Accurate results (basic cases, at minimum, checked against accepted results.</li>
<li>Option to make text files public/private and a location to access public simulations?</li>
</ol>
",se,informal project creating good requirements p see https previous question p middle school student working informal project problem statement follows blockquote p way theoreticians researchers students field quantum computing simulate test complex large quantum circuits intuitive efficient way without creating code application web application works popular browsers simple interface could accurately produce results outcomes quantum algorithms error correction codes entanglement decoherence aspects ideal realistic interface would allow professionals students alike test ideas get better understanding field quantum p working book code complete next step list requirements never done informal project unsure requirements list came good improvements made list ol li takes input starting state qubits gate applied qubit many qubits used implementation quantum computing like test decoherence time estimates li outputs current state every qubit probability state every li outputs given website downloadable along inputs text file li state qubits vector probability number 0 1 gates one several commonly used gates custom gate li inputs gates one several buttons pressed li inputs state number qubits integer li user inputs data presses button compute take long produce answer one minute em max 5 qubit calculations one benchmark li website interface input blanks based previous user input create account save simulations takes email password tab look previous text files simulations tab create new simulation user would input number qubits starting state qubits click next list gates 1st qubit click done 2nd qubit etc option inputted custom gate blank pops fill necessary data gate done transitions calculating style screen gives result text file download option save option start last option available throughout li safety user email password text files must high could information stored li place site report bugs request li common quantum gates available em custom gate li simulates decoherence entanglement common features quantum li allows choice ideal decoherence decoherence quantum li generalizable large numbers qubits runs efficiently possible li documentation li accurate results basic cases minimum checked accepted li option make text files location access public simulations,"[(1, 0.04888137), (2, 0.016746499), (5, 0.010846318), (7, 0.1698139), (8, 0.09002795), (9, 0.08746182), (13, 0.053992294), (14, 0.40278128), (17, 0.0114005115), (18, 0.079535685), (19, 0.0160406)]"
17680,17853.0,2021-05-27 18:25:17,1,63,"<p>I am trying to create a portfolio optimization with the DWave Quantum Computer. I wrote some code trying to somehow reconstruct the following Ising model <a href=""https://www.osti.gov/servlets/purl/1423041"" rel=""nofollow noreferrer"">paper</a>:
<a href=""https://i.sstatic.net/LRYMK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LRYMK.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/Nni1A.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Nni1A.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/V0bKC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/V0bKC.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/xzYas.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xzYas.png"" alt=""enter image description here"" /></a></p>
<p><code>Ai</code> is the maximum amount of money that can be invested in the i-th asset.
<code>B</code> is the total budget.
<code>Ri</code> denote the random variable representing the return from asset i.</p>
<p>This is how I tried to code it:</p>
<pre><code>    import datetime
    import pandas as pd
    import fix_yahoo_finance as yf
    import pandas_datareader.data as web
    import numpy as np
    import neal
    import dimod
    from dwave.system import DWaveSampler
    import random
    import hybrid
    
    def cov(a,b):
        return a.cov(b)
    
    def hi(price, returns, cov):
        #mean price
        Ai = np.mean(price)
    
        #mean expected return
        E = np.mean(returns)
    
        # hi = -(1/2)((1/3)*cov(Ri,Rj) + (1/3)Ai^2 - (1/3)E(Ri) - 2B(1/3)*Ai)
        h = (-(1/2)*((1/3)*cov + (1/3)* (Ai ** 2) - (1/3)* E - 2*100*(1/3)*Ai))
        return h
    
    yf.pdr_override()
    
    start = datetime.datetime(2018,1,3)       
    end = datetime.datetime(2021,1,1)
    all_data = {ticker: web.get_data_yahoo(ticker,start,end)
              for ticker in ['AAPL','IBM','MSFT','GOOGL']}    #Note: GOOG has become GOOGL
    price = pd.DataFrame({ticker:data['Adj Close']
                        for ticker,data in all_data.items()})
    volume = pd.DataFrame({ticker:data['Volume']
                         for ticker,data in all_data.items()})
    returns = price.pct_change()      #calculate the percentage of the price
    
    returns = returns.dropna()
    
    print(returns.tail())
        
    a = cov(returns['AAPL'], returns['IBM'])
    b = cov(returns['IBM'], returns['MSFT'])
    c = cov(returns['MSFT'], returns['GOOGL'])
    d = cov(returns['GOOGL'], returns['AAPL'])
    
    apple = hi(price['AAPL'],returns['AAPL'], a)
    ibm = hi(price['IBM'],returns['IBM'], b)
    microsoft = hi(price['MSFT'],returns['MSFT'], c)
    google = hi(price['GOOGL'],returns['GOOGL'], d)
    
    
    sampler = neal.SimulatedAnnealingSampler()
    
    #qpu = DWaveSampler()
    
    h = {apple: 0.0, ibm: 0.0, microsoft: 0.0, google: 0.0}
    #energy changes when bias value changes
    J = {(apple, ibm): 0.0, (ibm, microsoft): 0.0, (google, apple): 0.0, (apple, microsoft): 0.0, (ibm, google): 0.0}
    sampleset = sampler.sample_ising(h, J, num_reads=10, annealing_time=2000)
    print(sampleset)
</code></pre>
<p>And this is the output sampleset:</p>
<p><a href=""https://i.sstatic.net/IDV4l.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IDV4l.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering what the numbers on top meant, so the <code>-224463.77916595488 1414.5773363996423</code> etc. and if this is correct</p>
",What do the numbers in the Ising sampleset mean?,<hamiltonian-simulation><d-wave><annealing>,1,0,,,"What do the numbers in the Ising sampleset mean? <p>I am trying to create a portfolio optimization with the DWave Quantum Computer. I wrote some code trying to somehow reconstruct the following Ising model <a href=""https://www.osti.gov/servlets/purl/1423041"" rel=""nofollow noreferrer"">paper</a>:
<a href=""https://i.sstatic.net/LRYMK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/LRYMK.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/Nni1A.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Nni1A.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/V0bKC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/V0bKC.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/xzYas.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xzYas.png"" alt=""enter image description here"" /></a></p>
<p><code>Ai</code> is the maximum amount of money that can be invested in the i-th asset.
<code>B</code> is the total budget.
<code>Ri</code> denote the random variable representing the return from asset i.</p>
<p>This is how I tried to code it:</p>
<pre><code>    import datetime
    import pandas as pd
    import fix_yahoo_finance as yf
    import pandas_datareader.data as web
    import numpy as np
    import neal
    import dimod
    from dwave.system import DWaveSampler
    import random
    import hybrid
    
    def cov(a,b):
        return a.cov(b)
    
    def hi(price, returns, cov):
        #mean price
        Ai = np.mean(price)
    
        #mean expected return
        E = np.mean(returns)
    
        # hi = -(1/2)((1/3)*cov(Ri,Rj) + (1/3)Ai^2 - (1/3)E(Ri) - 2B(1/3)*Ai)
        h = (-(1/2)*((1/3)*cov + (1/3)* (Ai ** 2) - (1/3)* E - 2*100*(1/3)*Ai))
        return h
    
    yf.pdr_override()
    
    start = datetime.datetime(2018,1,3)       
    end = datetime.datetime(2021,1,1)
    all_data = {ticker: web.get_data_yahoo(ticker,start,end)
              for ticker in ['AAPL','IBM','MSFT','GOOGL']}    #Note: GOOG has become GOOGL
    price = pd.DataFrame({ticker:data['Adj Close']
                        for ticker,data in all_data.items()})
    volume = pd.DataFrame({ticker:data['Volume']
                         for ticker,data in all_data.items()})
    returns = price.pct_change()      #calculate the percentage of the price
    
    returns = returns.dropna()
    
    print(returns.tail())
        
    a = cov(returns['AAPL'], returns['IBM'])
    b = cov(returns['IBM'], returns['MSFT'])
    c = cov(returns['MSFT'], returns['GOOGL'])
    d = cov(returns['GOOGL'], returns['AAPL'])
    
    apple = hi(price['AAPL'],returns['AAPL'], a)
    ibm = hi(price['IBM'],returns['IBM'], b)
    microsoft = hi(price['MSFT'],returns['MSFT'], c)
    google = hi(price['GOOGL'],returns['GOOGL'], d)
    
    
    sampler = neal.SimulatedAnnealingSampler()
    
    #qpu = DWaveSampler()
    
    h = {apple: 0.0, ibm: 0.0, microsoft: 0.0, google: 0.0}
    #energy changes when bias value changes
    J = {(apple, ibm): 0.0, (ibm, microsoft): 0.0, (google, apple): 0.0, (apple, microsoft): 0.0, (ibm, google): 0.0}
    sampleset = sampler.sample_ising(h, J, num_reads=10, annealing_time=2000)
    print(sampleset)
</code></pre>
<p>And this is the output sampleset:</p>
<p><a href=""https://i.sstatic.net/IDV4l.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IDV4l.png"" alt=""enter image description here"" /></a></p>
<p>I was wondering what the numbers on top meant, so the <code>-224463.77916595488 1414.5773363996423</code> etc. and if this is correct</p>
",qc,numbers ising sampleset mean p trying create portfolio optimization dwave quantum computer wrote code trying somehow reconstruct following ising model https nofollow noreferrer paper https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description p code ai maximum amount money invested asset code b total budget code ri denote random variable representing return asset p tried code pre code import datetime import pandas pd import yf import web import numpy np import neal import dimod import dwavesampler import random import hybrid def cov b return b def hi price returns cov mean price ai price mean expected return e returns hi cov ri rj e ri 2b ai h cov ai 2 e 2 100 ai return h start end ticker ticker start end ticker note goog become googl price ticker data close ticker data volume ticker data ticker data returns calculate percentage price returns print cov returns returns b cov returns returns c cov returns returns cov returns returns apple hi price returns ibm hi price returns b microsoft hi price returns c google hi price returns sampler qpu dwavesampler h apple ibm microsoft google energy changes bias value changes j apple ibm ibm microsoft google apple apple microsoft ibm google sampleset h j print sampleset p output sampleset p https nofollow noreferrer img https enter image description p wondering numbers top meant code etc correct,"[(0, 0.2533653), (1, 0.020991035), (3, 0.077732936), (4, 0.38276458), (8, 0.081743), (12, 0.03694445), (17, 0.13893211)]"
17707,,2021-05-29 10:36:32,6,168,"<p>Could you please help me in finding some research paper references on the impact of Quantum algorithms on symmetric and asymmetric cryptography ?</p>
<p>Also, I request if I can get some references or notes demonstrating the impact on cryptography with particular algorithms as shown below:</p>
<ul>
<li>Bernstein–Vazirani algorithm</li>
<li>Simon's algorithm</li>
<li>Quantum phase estimation algorithm</li>
<li>Shor's algorithm Hidden subgroup problem</li>
<li>Grover's algorithm Quantum counting</li>
</ul>
",Paper references on how quantum algorithms have an impact on cryptography?,<quantum-algorithms><resource-request><cryptography>,1,1,,,"Paper references on how quantum algorithms have an impact on cryptography? <p>Could you please help me in finding some research paper references on the impact of Quantum algorithms on symmetric and asymmetric cryptography ?</p>
<p>Also, I request if I can get some references or notes demonstrating the impact on cryptography with particular algorithms as shown below:</p>
<ul>
<li>Bernstein–Vazirani algorithm</li>
<li>Simon's algorithm</li>
<li>Quantum phase estimation algorithm</li>
<li>Shor's algorithm Hidden subgroup problem</li>
<li>Grover's algorithm Quantum counting</li>
</ul>
",qc,paper references quantum algorithms impact cryptography p could please help finding research paper references impact quantum algorithms symmetric asymmetric cryptography p also request get references notes demonstrating impact cryptography particular algorithms shown ul li algorithm li simon algorithm li quantum phase estimation algorithm li shor algorithm hidden subgroup problem li grover algorithm quantum counting,"[(7, 0.5441369), (8, 0.4133932), (10, 0.020669661), (17, 0.018847074)]"
17720,24323.0,2021-05-29 22:23:33,4,477,"<p>I think I understand circuit based QC (CBQC) well enough; I know very little about MBQC. From what I read it seems that they are somehow &quot;equivalent&quot;. I'd like to check this with a concrete example from QECC. I can find circuits to encode/decode a stabilizer code; we can take the perfect <span class=""math-container"">$[[5,1,3]]$</span> code as an example <a href=""https://www.cgranade.com/python-quaec/"" rel=""nofollow noreferrer"">https://www.cgranade.com/python-quaec/</a>. How would I translate these circuits to MBQC counterparts?</p>
",translating between measurement based and circuit based quantum computation,<measurement><error-correction><quantum-circuit><stabilizer-code>,1,0,,,"translating between measurement based and circuit based quantum computation <p>I think I understand circuit based QC (CBQC) well enough; I know very little about MBQC. From what I read it seems that they are somehow &quot;equivalent&quot;. I'd like to check this with a concrete example from QECC. I can find circuits to encode/decode a stabilizer code; we can take the perfect <span class=""math-container"">$[[5,1,3]]$</span> code as an example <a href=""https://www.cgranade.com/python-quaec/"" rel=""nofollow noreferrer"">https://www.cgranade.com/python-quaec/</a>. How would I translate these circuits to MBQC counterparts?</p>
",qc,translating measurement based circuit based quantum computation p think understand circuit based qc cbqc well enough know little mbqc read seems somehow quot equivalent quot like check concrete example qecc find circuits stabilizer code take perfect span code example https nofollow noreferrer https would translate circuits mbqc counterparts,"[(1, 0.08009404), (4, 0.079407535), (5, 0.1518963), (9, 0.43891555), (14, 0.18145601), (17, 0.02255702), (19, 0.042918608)]"
17729,17732.0,2021-05-30 14:25:12,2,448,"<p>There are several Tutorials from Qiskit demonstrating the use of PySCF driver. Usually, it takes as input the geometric structure of the molecule -&gt; second quantised-operators -&gt; JW or Parity mapping -&gt; VQE.</p>
<p>However, I do not want to input a molecule but other Fermionic based operators, e.g. Fermi-Hubbard model. How do I do that?</p>
",How to map an arbitrary Fermionic operator to Spins (Qubits)?,<programming><qiskit>,1,0,,,"How to map an arbitrary Fermionic operator to Spins (Qubits)? <p>There are several Tutorials from Qiskit demonstrating the use of PySCF driver. Usually, it takes as input the geometric structure of the molecule -&gt; second quantised-operators -&gt; JW or Parity mapping -&gt; VQE.</p>
<p>However, I do not want to input a molecule but other Fermionic based operators, e.g. Fermi-Hubbard model. How do I do that?</p>
",qc,map arbitrary fermionic operator spins qubits p several tutorials qiskit demonstrating use pyscf driver usually takes input geometric structure molecule gt second gt jw parity mapping gt p however want input molecule fermionic based operators model,"[(0, 0.14246383), (5, 0.12647301), (7, 0.034866624), (8, 0.35854876), (11, 0.024024915), (14, 0.21542601), (17, 0.09450225)]"
17847,17851.0,2021-06-06 14:58:53,2,306,"<p>I am generating points for classification. Some will be above the main diagonal, while others will be below (blue or red).</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score
import random

m, b = 1, 0

lower, upper = -40, 40
num_points = 80
x1 = [random.randrange(start=-40, stop=40) for i in range(num_points)]
x2 = [random.randrange(start=-40, stop=40) for i in range(num_points)]

y1 = [random.randrange(start=lower, stop=m*x+b) for x in x1]
y2 = [random.randrange(start=m*x+b, stop=upper) for x in x2]


plt.plot(np.arange(-40,40), m*np.arange(-40,40)+b)
plt.scatter(x1, y1, c='red')
plt.scatter(x2, y2, c='blue')
plt.show()

x1, x2, y1, y2 = np.array(x1).reshape(-1,1), np.array(x2).reshape(-1,1), np.array(y1).reshape(-1,1), np.array(y2).reshape(-1,1)

x_upper = np.concatenate((x2, y2), axis=1)
x_lower = np.concatenate((x1, y1), axis=1)

X = np.concatenate((x_upper, x_lower), axis=0)

res1 = np.array([-1]*len(x1))
res2 = np.array([1]*len(x2))

y = np.concatenate((res1, res2), axis=0)
</code></pre>
<p>Next, I split the data into a training and test dataset.</p>
<pre><code>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)
</code></pre>
<p>The next step is to apply the quantum classification algorithm to all test points, in which I calculate the value for the first qubit. With respect to this result, I label the test points. I get the following:</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import Aer
from qiskit import execute
import numpy as np
%matplotlib inline
backend_sim = Aer.get_backend('qasm_simulator')

def quant_state(x1, x2, backend_sim = backend_sim):
    x1 = x1
    x2  = x2
    r = x1 * x1 + x2 * x2
    a = np.sqrt(1 + 2*r)
    psi = [0, 0, 0.5, 0, 0, -0.5, 0, 0, 1/(np.sqrt(2)*a), 0, x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), 0, 0]
    qc = QuantumCircuit(4)
    qc.initialize(psi, [0,1,2,3])
    qc.h(0)
    qc.measure_all()
    job_sim = execute(qc, backend_sim, shots=1000)
    result_sim = job_sim.result()
    counts = result_sim.get_counts(qc)

    quantumState_1 = 0
    for i in counts.keys():
        list_i = list(i)
        if list_i[len(list_i) - 1] == '1':
            quantumState_1 += counts[i]

    return quantumState_1

quant_res = []

for i,j in zip(X_test[:, 0], X_test[:, 1]):
    qs = quant_state(i, j, backend_sim = backend_sim)
    if qs &gt;= 500:
        quant_res.append(1)
    else:
        quant_res.append(-1)

def get_color(y,zn):
    colors = []

    for i in range(len(y)):
        if y[i] == zn:
            colors.append('red')
        else:
            colors.append('blue')

    return(colors)

quantColors = get_color(quant_res, 1)
plt.scatter(X_train[:, 0], X_train[:, 1], c = colors)
plt.scatter(X_test[:, 0], X_test[:, 1], c = quantColors, marker = &quot;x&quot;)
plt.plot(np.arange(-40,40), m*np.arange(-40,40)+b)
plt.show()
</code></pre>
<p>In the end I get this result:</p>
<pre><code>from sklearn.metrics import f1_score
f1_score(y_test, quant_res)
</code></pre>
<p>0.2162162162162162</p>
<p><a href=""https://i.sstatic.net/9ERzL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9ERzL.png"" alt=""results"" /></a></p>
<p>where the crosses are predicted results.
Can someone explain, why this classification is working wrong?</p>
",quantum label classification using qiskit,<programming><qiskit><quantum-state>,1,1,,,"quantum label classification using qiskit <p>I am generating points for classification. Some will be above the main diagonal, while others will be below (blue or red).</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score
import random

m, b = 1, 0

lower, upper = -40, 40
num_points = 80
x1 = [random.randrange(start=-40, stop=40) for i in range(num_points)]
x2 = [random.randrange(start=-40, stop=40) for i in range(num_points)]

y1 = [random.randrange(start=lower, stop=m*x+b) for x in x1]
y2 = [random.randrange(start=m*x+b, stop=upper) for x in x2]


plt.plot(np.arange(-40,40), m*np.arange(-40,40)+b)
plt.scatter(x1, y1, c='red')
plt.scatter(x2, y2, c='blue')
plt.show()

x1, x2, y1, y2 = np.array(x1).reshape(-1,1), np.array(x2).reshape(-1,1), np.array(y1).reshape(-1,1), np.array(y2).reshape(-1,1)

x_upper = np.concatenate((x2, y2), axis=1)
x_lower = np.concatenate((x1, y1), axis=1)

X = np.concatenate((x_upper, x_lower), axis=0)

res1 = np.array([-1]*len(x1))
res2 = np.array([1]*len(x2))

y = np.concatenate((res1, res2), axis=0)
</code></pre>
<p>Next, I split the data into a training and test dataset.</p>
<pre><code>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)
</code></pre>
<p>The next step is to apply the quantum classification algorithm to all test points, in which I calculate the value for the first qubit. With respect to this result, I label the test points. I get the following:</p>
<pre><code>import qiskit
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import Aer
from qiskit import execute
import numpy as np
%matplotlib inline
backend_sim = Aer.get_backend('qasm_simulator')

def quant_state(x1, x2, backend_sim = backend_sim):
    x1 = x1
    x2  = x2
    r = x1 * x1 + x2 * x2
    a = np.sqrt(1 + 2*r)
    psi = [0, 0, 0.5, 0, 0, -0.5, 0, 0, 1/(np.sqrt(2)*a), 0, x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), x1/(np.sqrt(2)*a), x2/(np.sqrt(2)*a), 0, 0]
    qc = QuantumCircuit(4)
    qc.initialize(psi, [0,1,2,3])
    qc.h(0)
    qc.measure_all()
    job_sim = execute(qc, backend_sim, shots=1000)
    result_sim = job_sim.result()
    counts = result_sim.get_counts(qc)

    quantumState_1 = 0
    for i in counts.keys():
        list_i = list(i)
        if list_i[len(list_i) - 1] == '1':
            quantumState_1 += counts[i]

    return quantumState_1

quant_res = []

for i,j in zip(X_test[:, 0], X_test[:, 1]):
    qs = quant_state(i, j, backend_sim = backend_sim)
    if qs &gt;= 500:
        quant_res.append(1)
    else:
        quant_res.append(-1)

def get_color(y,zn):
    colors = []

    for i in range(len(y)):
        if y[i] == zn:
            colors.append('red')
        else:
            colors.append('blue')

    return(colors)

quantColors = get_color(quant_res, 1)
plt.scatter(X_train[:, 0], X_train[:, 1], c = colors)
plt.scatter(X_test[:, 0], X_test[:, 1], c = quantColors, marker = &quot;x&quot;)
plt.plot(np.arange(-40,40), m*np.arange(-40,40)+b)
plt.show()
</code></pre>
<p>In the end I get this result:</p>
<pre><code>from sklearn.metrics import f1_score
f1_score(y_test, quant_res)
</code></pre>
<p>0.2162162162162162</p>
<p><a href=""https://i.sstatic.net/9ERzL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9ERzL.png"" alt=""results"" /></a></p>
<p>where the crosses are predicted results.
Can someone explain, why this classification is working wrong?</p>
",qc,quantum label classification using qiskit p generating points classification main diagonal others blue red pre code import numpy np import plt import import import random b 1 0 lower upper 40 80 x1 range x2 range y1 x x1 y2 x x2 x1 y1 x2 y2 x1 x2 y1 y2 x1 x2 y1 y2 x2 y2 x1 y1 x res1 len x1 res2 1 len x2 res1 res2 p next split data training test pre code x p next step apply quantum classification algorithm test points calculate value first qubit respect result label test points get following pre code import qiskit qiskit import quantumcircuit classicalregister quantumregister qiskit import aer qiskit import execute import numpy np matplotlib inline def x1 x2 x1 x1 x2 x2 r x1 x1 x2 x2 1 2 r psi 0 0 0 0 0 0 2 0 2 2 2 2 0 0 qc quantumcircuit 4 psi 0 execute qc counts qc 0 list len 1 1 counts return j zip 0 1 qs j qs gt 500 1 else def zn colors range len zn else return colors quantcolors 1 0 1 c colors 0 1 c quantcolors marker quot x quot p end get result pre code import p p https nofollow noreferrer img https results p crosses predicted results someone explain classification working wrong,"[(0, 0.4425171), (2, 0.19112158), (4, 0.04657939), (8, 0.07750247), (10, 0.034374554), (17, 0.2024526)]"
17852,17855.0,2021-06-07 02:25:04,6,390,"<p>In exercise 5 of the this year's IBM Quantum Challenge, you need to use the <code>FreezeCoreTransformer</code> (along <code>two_qubit_reduction</code> and <code>z2symmetry_reduction</code>) to reduce the number of qubits to 4 and achieve a cost of 3. I managed to figure out that the optimal array to pass to the <code>remove_orbitals</code> parameter was <code>[3,4]</code>; however, I did this by experimenting with different arrays.</p>
<p>In the Qiskit slack, I saw that the one body integrals of the <code>QMolecule</code> are supposed to give you an insight on which orbitals to freeze. However, they didn't explain how to use it to figure this out.</p>
<p>The molecule and one body integrals I am working with is the following.</p>
<pre><code>molecule = 'Li 0.0 0.0 0.0; H 0.0 0.0 1.5474'
driver = PySCFDriver(atom=molecule)
qmolecule = driver.run()
Matrix(np.round(qmolecule.one_body_integrals, 10))
</code></pre>
<p><span class=""math-container"">$$
\displaystyle \left[\begin{array}{cccccccccccc}-4.7385372413 &amp; 0.1075391382 &amp; 0.1675852953 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.1075391382 &amp; -1.5131757719 &amp; 0.0343466943 &amp; 0.0 &amp; 0.0 &amp; -0.0680291694 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.1675852953 &amp; 0.0343466943 &amp; -1.1291622926 &amp; 0.0 &amp; 0.0 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\-0.0302628413 &amp; -0.0680291694 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; -0.9418187042 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -4.7385372413 &amp; 0.1075391382 &amp; 0.1675852953 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.1075391382 &amp; -1.5131757719 &amp; 0.0343466943 &amp; 0.0 &amp; 0.0 &amp; -0.0680291694\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.1675852953 &amp; 0.0343466943 &amp; -1.1291622926 &amp; 0.0 &amp; 0.0 &amp; 0.031432226\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413 &amp; -0.0680291694 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; -0.9418187042\end{array}\right]
$$</span></p>
<p>How am I supposed to interpret this matrix to know which orbitals to freeze?</p>
",Use one_body_integrals to know which orbitals to freeze in ElectronicStructureProblem,<programming><qiskit><vqe><chemistry>,1,0,,,"Use one_body_integrals to know which orbitals to freeze in ElectronicStructureProblem <p>In exercise 5 of the this year's IBM Quantum Challenge, you need to use the <code>FreezeCoreTransformer</code> (along <code>two_qubit_reduction</code> and <code>z2symmetry_reduction</code>) to reduce the number of qubits to 4 and achieve a cost of 3. I managed to figure out that the optimal array to pass to the <code>remove_orbitals</code> parameter was <code>[3,4]</code>; however, I did this by experimenting with different arrays.</p>
<p>In the Qiskit slack, I saw that the one body integrals of the <code>QMolecule</code> are supposed to give you an insight on which orbitals to freeze. However, they didn't explain how to use it to figure this out.</p>
<p>The molecule and one body integrals I am working with is the following.</p>
<pre><code>molecule = 'Li 0.0 0.0 0.0; H 0.0 0.0 1.5474'
driver = PySCFDriver(atom=molecule)
qmolecule = driver.run()
Matrix(np.round(qmolecule.one_body_integrals, 10))
</code></pre>
<p><span class=""math-container"">$$
\displaystyle \left[\begin{array}{cccccccccccc}-4.7385372413 &amp; 0.1075391382 &amp; 0.1675852953 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.1075391382 &amp; -1.5131757719 &amp; 0.0343466943 &amp; 0.0 &amp; 0.0 &amp; -0.0680291694 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.1675852953 &amp; 0.0343466943 &amp; -1.1291622926 &amp; 0.0 &amp; 0.0 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\-0.0302628413 &amp; -0.0680291694 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; -0.9418187042 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -4.7385372413 &amp; 0.1075391382 &amp; 0.1675852953 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.1075391382 &amp; -1.5131757719 &amp; 0.0343466943 &amp; 0.0 &amp; 0.0 &amp; -0.0680291694\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.1675852953 &amp; 0.0343466943 &amp; -1.1291622926 &amp; 0.0 &amp; 0.0 &amp; 0.031432226\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -1.1407709359 &amp; 0.0\\0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; -0.0302628413 &amp; -0.0680291694 &amp; 0.031432226 &amp; 0.0 &amp; 0.0 &amp; -0.9418187042\end{array}\right]
$$</span></p>
<p>How am I supposed to interpret this matrix to know which orbitals to freeze?</p>
",qc,use know orbitals freeze electronicstructureproblem p exercise 5 year ibm quantum challenge need use code freezecoretransformer along code code reduce number qubits 4 achieve cost managed figure optimal array pass code parameter code however experimenting different p qiskit slack saw one body integrals code qmolecule supposed give insight orbitals freeze however explain use figure p molecule one body integrals working pre code molecule h driver pyscfdriver qmolecule matrix 10 p span array cccccccccccc amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp amp array p supposed interpret matrix know orbitals freeze,"[(6, 0.0110738175), (8, 0.030405156), (14, 0.11311682), (15, 0.80122316), (17, 0.0434569)]"
17868,17872.0,2021-06-08 18:39:12,2,1727,"<p>Havlicek et al. propose a feature map for embedding <span class=""math-container"">$n$</span>-dimensional classical data on <span class=""math-container"">$n$</span> qubits: <span class=""math-container"">$U_{\phi(x)}H^{\otimes n}$</span>, where
<span class=""math-container"">$$
U_{\phi(x)} = \exp (i \sum_{S \subseteq [n]} \phi_S(x) \prod_{i \in S} Z_i) \\
\phi_i(x) = x_i, \; \phi_{\{i, j\}}(x) = (\pi - x_0)(\pi - x_1)
$$</span>
and <span class=""math-container"">$Z_i$</span> is a <span class=""math-container"">$Z$</span>-gate on the <span class=""math-container"">$i$</span>-th qubit.</p>
<p>I'm currently considering the 2-dimensional, 2-qubit case,
<span class=""math-container"">$$
U_{\phi(x)} = \exp(i x_0 Z_0 + i x_1 Z_1 + i (\pi - x_0) (\pi - x_1) Z_0 Z_1),
$$</span>
and trying to find out, how do I get from the above definition to the circuit, as it is implemented in Qiskit:</p>
<pre><code>     ┌───┐┌──────────────┐                                           
q_0: ┤ H ├┤ U1(2.0*x[0]) ├──■─────────────────────────────────────■──
     ├───┤├──────────────┤┌─┴─┐┌───────────────────────────────┐┌─┴─┐
q_1: ┤ H ├┤ U1(2.0*x[1]) ├┤ X ├┤ U1(2.0*(π - x[0])*(π - x[1])) ├┤ X ├
     └───┘└──────────────┘└───┘└───────────────────────────────┘└───┘
</code></pre>
<p>My reasoning for the first 2 <span class=""math-container"">$U1$</span> rotations is that since <span class=""math-container"">$\exp(i \theta Z) = RZ(2 \theta)$</span> up to global phase and <span class=""math-container"">$RZ$</span> is equivalent to <span class=""math-container"">$U1$</span> up to global phase, we might as well use <span class=""math-container"">$U1(2 \phi_i(x))$</span>. Is that correct?</p>
<p>And if so, how do we then get <span class=""math-container"">$CX \; U1(2 \phi_{\{0, 1\}}(x)) \; CX$</span> from <span class=""math-container"">$\exp(i \phi_{\{0, 1\}}(x) Z_0 Z_1)$</span>?</p>
",Quantum circuit for the ZZ feature map,<qiskit><quantum-circuit><quantum-enhanced-machine-learning><embedding>,1,0,,,"Quantum circuit for the ZZ feature map <p>Havlicek et al. propose a feature map for embedding <span class=""math-container"">$n$</span>-dimensional classical data on <span class=""math-container"">$n$</span> qubits: <span class=""math-container"">$U_{\phi(x)}H^{\otimes n}$</span>, where
<span class=""math-container"">$$
U_{\phi(x)} = \exp (i \sum_{S \subseteq [n]} \phi_S(x) \prod_{i \in S} Z_i) \\
\phi_i(x) = x_i, \; \phi_{\{i, j\}}(x) = (\pi - x_0)(\pi - x_1)
$$</span>
and <span class=""math-container"">$Z_i$</span> is a <span class=""math-container"">$Z$</span>-gate on the <span class=""math-container"">$i$</span>-th qubit.</p>
<p>I'm currently considering the 2-dimensional, 2-qubit case,
<span class=""math-container"">$$
U_{\phi(x)} = \exp(i x_0 Z_0 + i x_1 Z_1 + i (\pi - x_0) (\pi - x_1) Z_0 Z_1),
$$</span>
and trying to find out, how do I get from the above definition to the circuit, as it is implemented in Qiskit:</p>
<pre><code>     ┌───┐┌──────────────┐                                           
q_0: ┤ H ├┤ U1(2.0*x[0]) ├──■─────────────────────────────────────■──
     ├───┤├──────────────┤┌─┴─┐┌───────────────────────────────┐┌─┴─┐
q_1: ┤ H ├┤ U1(2.0*x[1]) ├┤ X ├┤ U1(2.0*(π - x[0])*(π - x[1])) ├┤ X ├
     └───┘└──────────────┘└───┘└───────────────────────────────┘└───┘
</code></pre>
<p>My reasoning for the first 2 <span class=""math-container"">$U1$</span> rotations is that since <span class=""math-container"">$\exp(i \theta Z) = RZ(2 \theta)$</span> up to global phase and <span class=""math-container"">$RZ$</span> is equivalent to <span class=""math-container"">$U1$</span> up to global phase, we might as well use <span class=""math-container"">$U1(2 \phi_i(x))$</span>. Is that correct?</p>
<p>And if so, how do we then get <span class=""math-container"">$CX \; U1(2 \phi_{\{0, 1\}}(x)) \; CX$</span> from <span class=""math-container"">$\exp(i \phi_{\{0, 1\}}(x) Z_0 Z_1)$</span>?</p>
",qc,quantum circuit zz feature map p havlicek et al propose feature map embedding span n classical data span n qubits span x n span x n x x x span span z span p currently considering case span x trying find get definition circuit implemented qiskit pre code h u1 x 0 h u1 x 1 x u1 π x 0 π x 1 x p reasoning first 2 span u1 rotations since span z rz 2 global phase span rz equivalent span u1 global phase might well use span u1 2 x correct p get span cx u1 2 0 x cx span 0 x,"[(2, 0.11256803), (3, 0.28496847), (6, 0.023324069), (9, 0.12350959), (10, 0.19824913), (11, 0.02357826), (13, 0.0173815), (14, 0.117761046), (17, 0.0975938)]"
17884,,2021-06-09 15:22:42,1,109,"<p>I'm new to Quantum Computing. I came across solving the Max-cut problem using QAOA. For example, if I have a <span class=""math-container"">$U3$</span> gate with parameters <span class=""math-container"">$U3(0,0, \gamma_{XYZ})$</span> gamma parameter at <span class=""math-container"">$p=X$</span> between logical qubit Y and Z; and <span class=""math-container"">$Rz(\beta_X)$</span> beta parameter at <span class=""math-container"">$p=X$</span>, how do I calculate the values of <span class=""math-container"">$\gamma$</span> and <span class=""math-container"">$\beta$</span>?</p>
",How to calculate Alpha and Beta values for QAOA Max-cut problem manually?,<programming><quantum-algorithms><qaoa>,0,2,,,"How to calculate Alpha and Beta values for QAOA Max-cut problem manually? <p>I'm new to Quantum Computing. I came across solving the Max-cut problem using QAOA. For example, if I have a <span class=""math-container"">$U3$</span> gate with parameters <span class=""math-container"">$U3(0,0, \gamma_{XYZ})$</span> gamma parameter at <span class=""math-container"">$p=X$</span> between logical qubit Y and Z; and <span class=""math-container"">$Rz(\beta_X)$</span> beta parameter at <span class=""math-container"">$p=X$</span>, how do I calculate the values of <span class=""math-container"">$\gamma$</span> and <span class=""math-container"">$\beta$</span>?</p>
",qc,calculate alpha beta values qaoa problem manually p new quantum computing came across solving problem using qaoa example span u3 gate parameters span u3 xyz gamma parameter span logical qubit z span rz beta parameter span calculate values span span,"[(0, 0.39599836), (1, 0.09126673), (3, 0.2535066), (5, 0.040934954), (8, 0.10422448), (9, 0.047298897), (17, 0.063534744)]"
17895,,2021-06-10 04:57:14,4,88,"<p>In this paper, <a href=""http://users.cms.caltech.edu/%7Evidick/teaching/fsmp/fsmp.pdf"" rel=""nofollow noreferrer"">http://users.cms.caltech.edu/~vidick/teaching/fsmp/fsmp.pdf</a>, it gives the definition of a qubit as follows:</p>
<p>A qubit is a triple <span class=""math-container"">$(H, X, Z)$</span> consisting of a separable Hilbert space H and
a pair of Hermitian operators <span class=""math-container"">$X, Z$</span> acting on a H such that <span class=""math-container"">$X^2 = Z^2 = Id$</span> and <span class=""math-container"">${X, Z} = XZ + ZX = 0$</span>.</p>
<p>What does this mean and why does this work? Can I choose any two pauli observables?</p>
","What does it mean that a qubit is a triple $(H,X,Z)$ with $H$ Hilbert space and $X,Z$ Pauli operators?",<quantum-state><pauli-gates>,0,11,,,"What does it mean that a qubit is a triple $(H,X,Z)$ with $H$ Hilbert space and $X,Z$ Pauli operators? <p>In this paper, <a href=""http://users.cms.caltech.edu/%7Evidick/teaching/fsmp/fsmp.pdf"" rel=""nofollow noreferrer"">http://users.cms.caltech.edu/~vidick/teaching/fsmp/fsmp.pdf</a>, it gives the definition of a qubit as follows:</p>
<p>A qubit is a triple <span class=""math-container"">$(H, X, Z)$</span> consisting of a separable Hilbert space H and
a pair of Hermitian operators <span class=""math-container"">$X, Z$</span> acting on a H such that <span class=""math-container"">$X^2 = Z^2 = Id$</span> and <span class=""math-container"">${X, Z} = XZ + ZX = 0$</span>.</p>
<p>What does this mean and why does this work? Can I choose any two pauli observables?</p>
",qc,mean qubit triple h x z h hilbert space x z pauli operators p paper http nofollow noreferrer http gives definition qubit follows p qubit triple span h x z consisting separable hilbert space h pair hermitian operators span x z acting h span id span x z xz zx 0 p mean work choose two pauli observables,"[(2, 0.019664299), (3, 0.7420843), (4, 0.036295652), (10, 0.11267227), (17, 0.022373393), (18, 0.06450411)]"
17897,,2021-06-10 09:10:35,4,343,"<p>I am running a VQEUCCFactory for H2 on a real hardware device.</p>
<pre><code>res=VQEUCCFactory(quantum_instance=QuantumInstance(provider.get_backend('ibmq_athens'),
    shots=8000)
    optimizer=optimizer,
    initial_state=initial_state)
</code></pre>
<p>I left it running offline and when I go to check the results I get more than one job_id. So when I want to simulate another molecule, I obtain more jobs_id. Therefore at the end I cannot identify which jobs_id belongs to each molecules.</p>
<p>Is there any way to add a tag or name to my jobs to identify which molecule corresponds to each group of jobs? I have seen that it can be done (<a href=""https://quantum-computing.ibm.com/lab/docs/iql/manage/account/ibmq"" rel=""nofollow noreferrer"">https://quantum-computing.ibm.com/lab/docs/iql/manage/account/ibmq</a>) but I don't know how to implement the job_name of job_tag parameters to my code above.</p>
<p>Thank you very much in advance for the help!</p>
",How do I identify a VQE job run in real hardware?,<programming><qiskit><ibm-q-experience><vqe><chemistry>,2,2,,,"How do I identify a VQE job run in real hardware? <p>I am running a VQEUCCFactory for H2 on a real hardware device.</p>
<pre><code>res=VQEUCCFactory(quantum_instance=QuantumInstance(provider.get_backend('ibmq_athens'),
    shots=8000)
    optimizer=optimizer,
    initial_state=initial_state)
</code></pre>
<p>I left it running offline and when I go to check the results I get more than one job_id. So when I want to simulate another molecule, I obtain more jobs_id. Therefore at the end I cannot identify which jobs_id belongs to each molecules.</p>
<p>Is there any way to add a tag or name to my jobs to identify which molecule corresponds to each group of jobs? I have seen that it can be done (<a href=""https://quantum-computing.ibm.com/lab/docs/iql/manage/account/ibmq"" rel=""nofollow noreferrer"">https://quantum-computing.ibm.com/lab/docs/iql/manage/account/ibmq</a>) but I don't know how to implement the job_name of job_tag parameters to my code above.</p>
<p>Thank you very much in advance for the help!</p>
",qc,identify vqe job run real hardware p running vqeuccfactory h2 real hardware pre code p left running offline go check results get one want simulate another molecule obtain therefore end identify belongs p way add tag name jobs identify molecule corresponds group jobs seen done https nofollow noreferrer https know implement parameters code p thank much advance help,"[(4, 0.056131594), (9, 0.10463608), (13, 0.1614599), (14, 0.5822767), (17, 0.092872)]"
17904,18065.0,2021-06-10 14:24:26,2,283,"<p>I am trying to run exercise 4 from the recent IBM Quantum Challenge using a PulseSimulator since the device used in the challenge is not available for public use. A snippet of what I am trying to run is the following:</p>
<pre><code>from qiskit import pulse, IBMQ, assemble
from qiskit.pulse import Play, Schedule, DriveChannel, Gaussian, AcquireChannel
from qiskit.providers.aer import PulseSimulator
from qiskit.tools.monitor import job_monitor
import numpy as np

# Constants and units

job_params = {
    'meas_level': 1,
    'meas_return': 'avg',
    'shots': 512
}

spec_range = 0.300 # GHz
num_spec01_freqs = 71
GHz = 1.0e9 # Gigahertz

# Helper functions

def get_exc_chans(gv):
    return [AcquireChannel(i) for i in range(gv['backend_config'].n_qubits)]

def get_spec01_freqs(center_freqs, qubit):
    center_freq = round(center_freqs[qubit], -8) # 2 significant digits
    return np.linspace(center_freq/GHz - spec_range/2,
        center_freq/GHz + spec_range/2, num_spec01_freqs)

# Set up backend and config

provider = IBMQ.load_account()
backend_name = 'ibmq_armonk'
backend_real = provider.get_backend(backend_name)
backend = PulseSimulator.from_backend(backend_real)

qubit = 0

backend_config = backend.configuration()
exc_chans = get_exc_chans(globals())
dt = backend_config.dt

backend_defaults = backend.defaults()
center_frequency = backend_defaults.qubit_freq_est
inst_sched_map = backend_defaults.instruction_schedule_map 

# |0⟩ -&gt; |1⟩  pulse

# Retrieve calibrated measurement pulse from backend
meas = inst_sched_map.get('measure', qubits=[qubit])

# The same spec pulse for both 01 and 12 spec
drive_amp = 0.25
drive_duration = inst_sched_map.get('x', qubits=[qubit]).duration

# Calibrated backend pulse use advanced DRAG pulse to reduce leakage to the |2&gt; state.
# Here we will use simple Gaussian pulse
drive_sigma = drive_duration // 4 # DRAG pulses typically 4*sigma long. 
spec_pulse = Gaussian(duration=drive_duration, amp=drive_amp, 
                        sigma=drive_sigma, name=f&quot;Spec drive amplitude = {drive_amp}&quot;)

# Construct an np array of the frequencies for our experiment
spec_freqs_GHz = get_spec01_freqs(center_frequency, qubit)

# Create the base schedule
# Start with drive pulse acting on the drive channel
spec01_scheds = []
for freq in spec_freqs_GHz:
    with pulse.build(name=&quot;Spec Pulse at %.3f GHz&quot; % freq) as spec01_sched:
        with pulse.align_sequential():
            # Pay close attention to this part to solve the problem at the end
            pulse.set_frequency(freq*GHz, DriveChannel(qubit))
            pulse.play(spec_pulse, DriveChannel(qubit))
            pulse.call(meas)
            
    spec01_scheds.append(spec01_sched)

qobj = assemble(spec01_scheds, backend=backend, **job_params)
spec01_job = backend.run(qobj)
job_monitor(spec01_job)
</code></pre>
<p>However, everytime I run this I get the following (not very helpful) error message:</p>
<pre><code>Job Status: job incurred error
</code></pre>
<p>I opened an issue about this in the Qiskit Aer GitHub repository (issue <a href=""https://github.com/Qiskit/qiskit-aer/issues/1264"" rel=""nofollow noreferrer"">#1264</a>) and got a response. They told me that &quot;the set/shift frequency instructions are not supported by the pulse simulator&quot;. And they suggested the following workaround:</p>
<blockquote>
<p>A way to bypass this issue as a user is to manually add an oscillation to the pulse envelopes. E.g. if the channel's LO frequency is <span class=""math-container"">$w$</span>, but you want to set it to <span class=""math-container"">$v$</span> for a given pulse (or pulses), convert the pulse to an explicit WaveForm specified in terms of a sample list, then multiply the sample array <span class=""math-container"">$exp(i(v-w)t)$</span>, where <span class=""math-container"">$t$</span> is the array of associated times. I may be missing some book keeping here but some version of this should work.</p>
</blockquote>
<p>As simple as this sounds, I don't quite understand how to do this. Can anyone explain to me, with code, how to do this? Or point me to somewhere where this is done?</p>
",Qiskit: set_frequency workaround in PulseSimulator,<programming><qiskit>,1,0,,,"Qiskit: set_frequency workaround in PulseSimulator <p>I am trying to run exercise 4 from the recent IBM Quantum Challenge using a PulseSimulator since the device used in the challenge is not available for public use. A snippet of what I am trying to run is the following:</p>
<pre><code>from qiskit import pulse, IBMQ, assemble
from qiskit.pulse import Play, Schedule, DriveChannel, Gaussian, AcquireChannel
from qiskit.providers.aer import PulseSimulator
from qiskit.tools.monitor import job_monitor
import numpy as np

# Constants and units

job_params = {
    'meas_level': 1,
    'meas_return': 'avg',
    'shots': 512
}

spec_range = 0.300 # GHz
num_spec01_freqs = 71
GHz = 1.0e9 # Gigahertz

# Helper functions

def get_exc_chans(gv):
    return [AcquireChannel(i) for i in range(gv['backend_config'].n_qubits)]

def get_spec01_freqs(center_freqs, qubit):
    center_freq = round(center_freqs[qubit], -8) # 2 significant digits
    return np.linspace(center_freq/GHz - spec_range/2,
        center_freq/GHz + spec_range/2, num_spec01_freqs)

# Set up backend and config

provider = IBMQ.load_account()
backend_name = 'ibmq_armonk'
backend_real = provider.get_backend(backend_name)
backend = PulseSimulator.from_backend(backend_real)

qubit = 0

backend_config = backend.configuration()
exc_chans = get_exc_chans(globals())
dt = backend_config.dt

backend_defaults = backend.defaults()
center_frequency = backend_defaults.qubit_freq_est
inst_sched_map = backend_defaults.instruction_schedule_map 

# |0⟩ -&gt; |1⟩  pulse

# Retrieve calibrated measurement pulse from backend
meas = inst_sched_map.get('measure', qubits=[qubit])

# The same spec pulse for both 01 and 12 spec
drive_amp = 0.25
drive_duration = inst_sched_map.get('x', qubits=[qubit]).duration

# Calibrated backend pulse use advanced DRAG pulse to reduce leakage to the |2&gt; state.
# Here we will use simple Gaussian pulse
drive_sigma = drive_duration // 4 # DRAG pulses typically 4*sigma long. 
spec_pulse = Gaussian(duration=drive_duration, amp=drive_amp, 
                        sigma=drive_sigma, name=f&quot;Spec drive amplitude = {drive_amp}&quot;)

# Construct an np array of the frequencies for our experiment
spec_freqs_GHz = get_spec01_freqs(center_frequency, qubit)

# Create the base schedule
# Start with drive pulse acting on the drive channel
spec01_scheds = []
for freq in spec_freqs_GHz:
    with pulse.build(name=&quot;Spec Pulse at %.3f GHz&quot; % freq) as spec01_sched:
        with pulse.align_sequential():
            # Pay close attention to this part to solve the problem at the end
            pulse.set_frequency(freq*GHz, DriveChannel(qubit))
            pulse.play(spec_pulse, DriveChannel(qubit))
            pulse.call(meas)
            
    spec01_scheds.append(spec01_sched)

qobj = assemble(spec01_scheds, backend=backend, **job_params)
spec01_job = backend.run(qobj)
job_monitor(spec01_job)
</code></pre>
<p>However, everytime I run this I get the following (not very helpful) error message:</p>
<pre><code>Job Status: job incurred error
</code></pre>
<p>I opened an issue about this in the Qiskit Aer GitHub repository (issue <a href=""https://github.com/Qiskit/qiskit-aer/issues/1264"" rel=""nofollow noreferrer"">#1264</a>) and got a response. They told me that &quot;the set/shift frequency instructions are not supported by the pulse simulator&quot;. And they suggested the following workaround:</p>
<blockquote>
<p>A way to bypass this issue as a user is to manually add an oscillation to the pulse envelopes. E.g. if the channel's LO frequency is <span class=""math-container"">$w$</span>, but you want to set it to <span class=""math-container"">$v$</span> for a given pulse (or pulses), convert the pulse to an explicit WaveForm specified in terms of a sample list, then multiply the sample array <span class=""math-container"">$exp(i(v-w)t)$</span>, where <span class=""math-container"">$t$</span> is the array of associated times. I may be missing some book keeping here but some version of this should work.</p>
</blockquote>
<p>As simple as this sounds, I don't quite understand how to do this. Can anyone explain to me, with code, how to do this? Or point me to somewhere where this is done?</p>
",qc,qiskit workaround pulsesimulator p trying run exercise 4 recent ibm quantum challenge using pulsesimulator since device used challenge available public use snippet trying run following pre code qiskit import pulse ibmq assemble import play schedule drivechannel gaussian acquirechannel import pulsesimulator import import numpy np constants units 1 512 ghz 71 ghz gigahertz helper functions def gv return acquirechannel range gv def qubit round qubit 2 significant digits return set backend config provider backend qubit 0 globals dt gt pulse retrieve calibrated measurement pulse backend meas qubit spec pulse 01 12 spec x qubit calibrated backend pulse use advanced drag pulse reduce leakage gt state use simple gaussian pulse 4 drag pulses typically 4 sigma long gaussian quot spec drive amplitude quot construct np array frequencies experiment qubit create base schedule start drive pulse acting drive channel freq quot spec pulse ghz quot freq pay close attention part solve problem end freq ghz drivechannel qubit drivechannel qubit meas qobj assemble qobj p however everytime run get following helpful error message pre code job status job incurred error p opened issue qiskit aer github repository issue https nofollow noreferrer 1264 got response told quot frequency instructions supported pulse simulator quot suggested following workaround blockquote p way bypass issue user manually add oscillation pulse envelopes channel lo frequency span w want set span v given pulse pulses convert pulse explicit waveform specified terms sample list multiply sample array span exp span array associated times may missing book keeping version p simple sounds quite understand anyone explain code point somewhere done,"[(0, 0.5499026), (3, 0.03477668), (6, 0.010366797), (8, 0.040857676), (9, 0.065575235), (14, 0.12019287), (17, 0.04925113), (18, 0.07022931), (19, 0.0583894)]"
17910,23422.0,2021-06-10 20:34:51,5,203,"<p>IBM's <a href=""https://research.ibm.com/blog/120x-quantum-speedup"" rel=""nofollow noreferrer"">Qiskit Runtime</a> was recently made available to a select group of users. Have they announced when it will be available to all users or when they might open it back up to a second round of new users?</p>
",When will Qiskit Runtime be available to all users?,<qiskit><ibm-q-experience><ibm-quantum-devices>,3,2,,,"When will Qiskit Runtime be available to all users? <p>IBM's <a href=""https://research.ibm.com/blog/120x-quantum-speedup"" rel=""nofollow noreferrer"">Qiskit Runtime</a> was recently made available to a select group of users. Have they announced when it will be available to all users or when they might open it back up to a second round of new users?</p>
",qc,qiskit runtime available users p ibm https nofollow noreferrer qiskit runtime recently made available select group users announced available users might open back second round new users,"[(4, 0.1610437), (9, 0.16135919), (14, 0.3552768), (17, 0.31643593)]"
18061,,2021-06-21 06:47:58,4,65,"<p>I am trying to understand the complexity of the <a href=""https://arxiv.org/abs/quant-ph/0508237"" rel=""nofollow noreferrer"">Mateus and Omar algorithm for quantum pattern matching</a>, it is clear to me from the pseudocode that the query complexity is <span class=""math-container"">$O(\sqrt{N})$</span>, apart from the cost of setting up the initial state:
<span class=""math-container"">$$
\frac{1}{\sqrt{N-M+1}}\sum_{k=1}^{N-M+1}|k,k+1,...,k+M-1⟩
$$</span></p>
<p>After that, they conclude that the algorithm has an efficient compile time of <span class=""math-container"">$O(N\log^{2}(N)\times |\Sigma|)$</span> and a total runtime of <span class=""math-container"">$O(M\log^{3}(N)+N^{3/2}\log^{2}\log(M))$</span>, but query complexity <span class=""math-container"">$O(\sqrt{N})$</span>.</p>
<p>My question is, if I devise an algorithm with, for example, a processing step of  <span class=""math-container"">$O(N^{2})$</span> circuit complexity but <span class=""math-container"">$O(\sqrt{N})$</span> query complexity. Is it completely fine to say that it is faster than a classical equivalent with, for example <span class=""math-container"">$O(N)$</span> complexity? I'm a bit stuck trying to figure this out.</p>
",Query complexity on Quantum Pattern Matching of Mateus Algorithm,<grovers-algorithm><complexity-theory><quantum-circuit>,0,2,,,"Query complexity on Quantum Pattern Matching of Mateus Algorithm <p>I am trying to understand the complexity of the <a href=""https://arxiv.org/abs/quant-ph/0508237"" rel=""nofollow noreferrer"">Mateus and Omar algorithm for quantum pattern matching</a>, it is clear to me from the pseudocode that the query complexity is <span class=""math-container"">$O(\sqrt{N})$</span>, apart from the cost of setting up the initial state:
<span class=""math-container"">$$
\frac{1}{\sqrt{N-M+1}}\sum_{k=1}^{N-M+1}|k,k+1,...,k+M-1⟩
$$</span></p>
<p>After that, they conclude that the algorithm has an efficient compile time of <span class=""math-container"">$O(N\log^{2}(N)\times |\Sigma|)$</span> and a total runtime of <span class=""math-container"">$O(M\log^{3}(N)+N^{3/2}\log^{2}\log(M))$</span>, but query complexity <span class=""math-container"">$O(\sqrt{N})$</span>.</p>
<p>My question is, if I devise an algorithm with, for example, a processing step of  <span class=""math-container"">$O(N^{2})$</span> circuit complexity but <span class=""math-container"">$O(\sqrt{N})$</span> query complexity. Is it completely fine to say that it is faster than a classical equivalent with, for example <span class=""math-container"">$O(N)$</span> complexity? I'm a bit stuck trying to figure this out.</p>
",qc,query complexity quantum pattern matching mateus algorithm p trying understand complexity https nofollow noreferrer mateus omar algorithm quantum pattern matching clear pseudocode query complexity span n apart cost setting initial state span 1 p conclude algorithm efficient compile time span 2 n total runtime span 3 n 2 query complexity span n p question devise algorithm example processing step span 2 circuit complexity span n query complexity completely fine say faster classical equivalent example span n complexity bit stuck trying figure,"[(2, 0.049382024), (3, 0.3664448), (4, 0.04794566), (7, 0.41008902), (14, 0.09836237), (17, 0.026007254)]"
18087,18095.0,2021-06-22 12:07:18,3,115,"<p>Are job IDs unique across backends, or is it possible that two jobs on two different backends have the same job ID? I'd like to use the job ID as primary key in a database.</p>
<p>Thanks in advance!</p>
",Are job IDs unique across backends?,<programming><qiskit>,2,0,,,"Are job IDs unique across backends? <p>Are job IDs unique across backends, or is it possible that two jobs on two different backends have the same job ID? I'd like to use the job ID as primary key in a database.</p>
<p>Thanks in advance!</p>
",qc,job ids unique across backends p job ids unique across backends possible two jobs two different backends job id like use job id primary key p thanks advance,"[(14, 0.7172512), (17, 0.07020903), (19, 0.20650962)]"
18188,18189.0,2021-06-29 19:17:21,5,337,"<p>I want to find a basis of maximally entangled states <span class=""math-container"">$|\Psi_i\rangle$</span>, for <span class=""math-container"">$\mathcal{H}^{2} \otimes \mathcal{H}^{2}$</span> and, <span class=""math-container"">$\mathcal{H}^{3} \otimes \mathcal{H}^{3}$</span> such that the density matrices of those states don't commute with each other.</p>
<p>If <span class=""math-container"">$\rho_{i} = |\Psi_i\rangle \langle\Psi_i|$</span></p>
<p>I need the following condition to be met:
<span class=""math-container"">$[\rho_{i},\rho_{j}] \ne 0$</span> for at least one pair of indices <span class=""math-container"">$i, j$</span>.</p>
<p>I have tried using quasi Bell states, and Bell states in <span class=""math-container"">$|+\rangle, |-\rangle$</span> basis etc. but haven't succeeded yet.</p>
<p>If one or more such bases exist, how should I go about constructing one? If such a basis doesn't exist, what would be the next best basis in terms of entanglement, given that non-commutativity and entangled states are my priority. The orthogonality requirement can be discarded if necessary.</p>
",Does a basis of maximally entangled states exist for two-qubit or two-qutrit system so that the density matrices of the basis states don't commute?,<entanglement><linear-algebra><bell-basis><povm>,1,0,,,"Does a basis of maximally entangled states exist for two-qubit or two-qutrit system so that the density matrices of the basis states don't commute? <p>I want to find a basis of maximally entangled states <span class=""math-container"">$|\Psi_i\rangle$</span>, for <span class=""math-container"">$\mathcal{H}^{2} \otimes \mathcal{H}^{2}$</span> and, <span class=""math-container"">$\mathcal{H}^{3} \otimes \mathcal{H}^{3}$</span> such that the density matrices of those states don't commute with each other.</p>
<p>If <span class=""math-container"">$\rho_{i} = |\Psi_i\rangle \langle\Psi_i|$</span></p>
<p>I need the following condition to be met:
<span class=""math-container"">$[\rho_{i},\rho_{j}] \ne 0$</span> for at least one pair of indices <span class=""math-container"">$i, j$</span>.</p>
<p>I have tried using quasi Bell states, and Bell states in <span class=""math-container"">$|+\rangle, |-\rangle$</span> basis etc. but haven't succeeded yet.</p>
<p>If one or more such bases exist, how should I go about constructing one? If such a basis doesn't exist, what would be the next best basis in terms of entanglement, given that non-commutativity and entangled states are my priority. The orthogonality requirement can be discarded if necessary.</p>
",qc,basis maximally entangled states exist system density matrices basis states commute p want find basis maximally entangled states span span h 2 h 2 span h 3 h 3 density matrices states commute p span p need following condition met span j 0 least one pair indices span j p tried using quasi bell states bell states span basis etc succeeded p one bases exist go constructing one basis exist would next best basis terms entanglement given entangled states priority orthogonality requirement discarded,"[(0, 0.014591419), (2, 0.04940309), (3, 0.4855049), (11, 0.045346968), (14, 0.01868498), (17, 0.014784317), (18, 0.370077)]"
18241,18242.0,2021-07-01 17:15:25,3,303,"<p>I'm experimenting with some small quantum error correcting codes (QECC). For example
<span class=""math-container"">$[[5,1,3]]$</span>, <span class=""math-container"">$[[8,3,3]]$</span> or toric codes <span class=""math-container"">$[[2d^2,2,d]]$</span> (<span class=""math-container"">$d=2,3,\cdots$</span>). The last one
being defined by redundant stabilizers. What packages can take in a set of <span class=""math-container"">$m'$</span> stabilizers
and produce the tableau? (<span class=""math-container"">$m'$</span> could be larger than <span class=""math-container"">$m=n-k$</span> in case stabilizers are not independent).</p>
<p>Here are the details for the <span class=""math-container"">$[[8,3,3]]$</span> code : the code is in standard form; <span class=""math-container"">$1=X$</span>, <span class=""math-container"">$2=Z$</span>, <span class=""math-container"">$3=XZ$</span>;</p>
<pre><code>[[3,0,2,2,1,1,3,0],
[2,3,0,2,1,3,0,1],
[2,0,3,0,1,2,1,3],
[2,2,0,1,0,1,3,3],
[2,2,2,2,2,2,2,2],
[2,2,0,2,0,2,0,0],
[2,0,2,2,0,0,2,0],
[0,2,2,2,0,0,0,2],
[2,0,0,0,0,0,0,0],
[0,2,0,0,0,0,0,0],
[0,0,2,0,0,0,0,0],
[0,0,0,2,0,0,0,0],
[0,0,0,0,1,0,0,0],
[0,2,2,0,1,1,0,0],
[2,0,0,2,1,0,1,0],
[0,0,2,2,1,0,0,1]]
</code></pre>
<p>first 5 rows of the matrix above are stabilizers; next 3 are logical Z; next 5 are destabilizers; last 3 logical X.</p>
",Are there any packages that can calculate stabilizer tableau of a QECC,<programming><error-correction><stabilizer-code><stabilizer-state>,1,3,,,"Are there any packages that can calculate stabilizer tableau of a QECC <p>I'm experimenting with some small quantum error correcting codes (QECC). For example
<span class=""math-container"">$[[5,1,3]]$</span>, <span class=""math-container"">$[[8,3,3]]$</span> or toric codes <span class=""math-container"">$[[2d^2,2,d]]$</span> (<span class=""math-container"">$d=2,3,\cdots$</span>). The last one
being defined by redundant stabilizers. What packages can take in a set of <span class=""math-container"">$m'$</span> stabilizers
and produce the tableau? (<span class=""math-container"">$m'$</span> could be larger than <span class=""math-container"">$m=n-k$</span> in case stabilizers are not independent).</p>
<p>Here are the details for the <span class=""math-container"">$[[8,3,3]]$</span> code : the code is in standard form; <span class=""math-container"">$1=X$</span>, <span class=""math-container"">$2=Z$</span>, <span class=""math-container"">$3=XZ$</span>;</p>
<pre><code>[[3,0,2,2,1,1,3,0],
[2,3,0,2,1,3,0,1],
[2,0,3,0,1,2,1,3],
[2,2,0,1,0,1,3,3],
[2,2,2,2,2,2,2,2],
[2,2,0,2,0,2,0,0],
[2,0,2,2,0,0,2,0],
[0,2,2,2,0,0,0,2],
[2,0,0,0,0,0,0,0],
[0,2,0,0,0,0,0,0],
[0,0,2,0,0,0,0,0],
[0,0,0,2,0,0,0,0],
[0,0,0,0,1,0,0,0],
[0,2,2,0,1,1,0,0],
[2,0,0,2,1,0,1,0],
[0,0,2,2,1,0,0,1]]
</code></pre>
<p>first 5 rows of the matrix above are stabilizers; next 3 are logical Z; next 5 are destabilizers; last 3 logical X.</p>
",qc,packages calculate stabilizer tableau qecc p experimenting small quantum error correcting codes qecc example span span toric codes span span last one defined redundant stabilizers packages take set span stabilizers produce tableau span could larger span case stabilizers independent p details span code code standard form span span span pre code p first 5 rows matrix stabilizers next 3 logical z next 5 destabilizers last 3 logical,"[(3, 0.33214486), (5, 0.35297304), (6, 0.05470615), (14, 0.2000411), (17, 0.057902023)]"
18262,18274.0,2021-07-03 07:45:24,0,218,"<p>In paper <a href=""https://arxiv.org/abs/1805.10928"" rel=""nofollow noreferrer"">Efficient quantum algorithm for solving travelling salesman problem: An IBM quantum experience</a>, the authors use gate <span class=""math-container"">$U_j$</span> and its decomposition
<span class=""math-container"">$$
U_j = 
\begin{pmatrix}
\mathrm{e}^{ia} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \mathrm{e}^{ib} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \mathrm{e}^{ic} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \mathrm{e}^{id} \\
\end{pmatrix}=
\begin{pmatrix}
1 &amp; 0 \\
0 &amp; \mathrm{e}^{i(c-a)}
\end{pmatrix}
\otimes
\begin{pmatrix}
\mathrm{e}^{ia} &amp; 0 \\
0 &amp; \mathrm{e}^{ib}
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \mathrm{e}^{i(d+c-a-b)} \\
\end{pmatrix}.
$$</span>
Note that they denote exponent <span class=""math-container"">$d+c-a-b$</span> by <span class=""math-container"">$x$</span> in the paper.</p>
<p>Then they present implementation of controlled version of <span class=""math-container"">$U_j$</span> with this circuit:</p>
<p><a href=""https://i.sstatic.net/TKl3D.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/TKl3D.jpg"" alt=""enter image description here"" /></a></p>
<p>and also provide QASM code</p>
<pre><code>cu1 ( c−a ) x , y ;
u1 ( a ) x ;
cu1 ( b−a ) x , z ;
ccx x , y , z ;
cu1 ( ( d−c+a−b ) / 2 ) x , z ;
ccx x , y , z ;
cu1 ( ( d−c+a−b ) / 2 ) x , y ;
cu1 ( ( d−c+a−b ) / 2 ) x , z ;
</code></pre>
<p>I am so confused about this. Can someone explain how the matrix, the image and the code connect to each other? It seems that each describe different circuit.</p>
",How to build and visualize circuit from matrix?,<ibm-q-experience><circuit-construction><qasm><quantum-computing-for-finance>,1,3,,,"How to build and visualize circuit from matrix? <p>In paper <a href=""https://arxiv.org/abs/1805.10928"" rel=""nofollow noreferrer"">Efficient quantum algorithm for solving travelling salesman problem: An IBM quantum experience</a>, the authors use gate <span class=""math-container"">$U_j$</span> and its decomposition
<span class=""math-container"">$$
U_j = 
\begin{pmatrix}
\mathrm{e}^{ia} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \mathrm{e}^{ib} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \mathrm{e}^{ic} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \mathrm{e}^{id} \\
\end{pmatrix}=
\begin{pmatrix}
1 &amp; 0 \\
0 &amp; \mathrm{e}^{i(c-a)}
\end{pmatrix}
\otimes
\begin{pmatrix}
\mathrm{e}^{ia} &amp; 0 \\
0 &amp; \mathrm{e}^{ib}
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \mathrm{e}^{i(d+c-a-b)} \\
\end{pmatrix}.
$$</span>
Note that they denote exponent <span class=""math-container"">$d+c-a-b$</span> by <span class=""math-container"">$x$</span> in the paper.</p>
<p>Then they present implementation of controlled version of <span class=""math-container"">$U_j$</span> with this circuit:</p>
<p><a href=""https://i.sstatic.net/TKl3D.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/TKl3D.jpg"" alt=""enter image description here"" /></a></p>
<p>and also provide QASM code</p>
<pre><code>cu1 ( c−a ) x , y ;
u1 ( a ) x ;
cu1 ( b−a ) x , z ;
ccx x , y , z ;
cu1 ( ( d−c+a−b ) / 2 ) x , z ;
ccx x , y , z ;
cu1 ( ( d−c+a−b ) / 2 ) x , y ;
cu1 ( ( d−c+a−b ) / 2 ) x , z ;
</code></pre>
<p>I am so confused about this. Can someone explain how the matrix, the image and the code connect to each other? It seems that each describe different circuit.</p>
",qc,build visualize circuit matrix p paper https nofollow noreferrer efficient quantum algorithm solving travelling salesman problem ibm quantum experience authors use gate span decomposition span pmatrix e ia amp 0 amp 0 amp 0 0 amp e ib amp 0 amp 0 0 amp 0 amp e ic amp 0 0 amp 0 amp 0 amp e id pmatrix pmatrix 1 amp 0 0 amp e pmatrix pmatrix e ia amp 0 0 amp e ib pmatrix pmatrix 1 amp 0 amp 0 amp 0 0 amp 1 amp 0 amp 0 0 amp 0 amp 1 amp 0 0 amp 0 amp 0 amp e pmatrix note denote exponent span span x p present implementation controlled version span circuit p https nofollow noreferrer img https enter image description p also provide qasm code pre code cu1 x u1 x cu1 x z ccx x z cu1 2 x z ccx x z cu1 2 x cu1 2 x z p confused someone explain matrix image code connect seems describe different,"[(0, 0.02526164), (2, 0.18832345), (4, 0.142274), (7, 0.05653651), (10, 0.08253926), (14, 0.05346617), (15, 0.4354643), (17, 0.015407843)]"
18283,,2021-07-05 05:01:03,2,270,"<p>Consider a Haar random quantum state of depth <span class=""math-container"">$d$</span>. Consider any bipartition of this state. According to <a href=""https://arxiv.org/abs/2001.00021"" rel=""nofollow noreferrer"">this</a> paper (page <span class=""math-container"">$2$</span>):</p>
<blockquote>
<p>Haar-random states on <span class=""math-container"">$n$</span> qudits are nearly maximally entangled across
all cuts simultaneously. Random quantum circuits on <span class=""math-container"">$L \times L \times
 \cdots L$</span> arrays of qudits achieve similar near-maximal entanglement
across all possible cuts once the depth is <span class=""math-container"">$\Omega(L)$</span>, and before
this time, the entanglement often spreads “ballistically.&quot;</p>
</blockquote>
<p>The comment indicates that the entanglement entropy is near maximal for linear depths. But, how much entanglement entropy is there for logarithmic and constant depths, and what is meant by &quot;ballistic spreading&quot;?</p>
",Spreading of entanglement with depth for Haar random states,<entanglement><quantum-advantage><random-quantum-circuit><haar-distribution>,0,2,,,"Spreading of entanglement with depth for Haar random states <p>Consider a Haar random quantum state of depth <span class=""math-container"">$d$</span>. Consider any bipartition of this state. According to <a href=""https://arxiv.org/abs/2001.00021"" rel=""nofollow noreferrer"">this</a> paper (page <span class=""math-container"">$2$</span>):</p>
<blockquote>
<p>Haar-random states on <span class=""math-container"">$n$</span> qudits are nearly maximally entangled across
all cuts simultaneously. Random quantum circuits on <span class=""math-container"">$L \times L \times
 \cdots L$</span> arrays of qudits achieve similar near-maximal entanglement
across all possible cuts once the depth is <span class=""math-container"">$\Omega(L)$</span>, and before
this time, the entanglement often spreads “ballistically.&quot;</p>
</blockquote>
<p>The comment indicates that the entanglement entropy is near maximal for linear depths. But, how much entanglement entropy is there for logarithmic and constant depths, and what is meant by &quot;ballistic spreading&quot;?</p>
",qc,spreading entanglement depth haar random states p consider haar random quantum state depth span consider bipartition state according https nofollow noreferrer paper page span 2 blockquote p states span n qudits nearly maximally entangled across cuts simultaneously random quantum circuits span l l l arrays qudits achieve similar entanglement across possible cuts depth span l time entanglement often spreads quot p comment indicates entanglement entropy near maximal linear depths much entanglement entropy logarithmic constant depths meant quot ballistic spreading quot,"[(3, 0.41195554), (5, 0.015341857), (9, 0.19728556), (10, 0.038287524), (14, 0.10345199), (17, 0.025485624), (18, 0.16535446), (19, 0.041320678)]"
18318,18319.0,2021-07-06 21:19:39,1,60,"<p>Is there any difference in effect between a quantum circuit and a carefully constructed analogue one relying on interference? For example, why couldn't I take a series of <span class=""math-container"">$N$</span> carefully shaped pipes, split a sound source between them, and build, say, a quantum Fourier transform circuit with classical versions of Hadamard and phase shift gates? For example, it would be easy to shift phase by extending the length of a pipe with a sufficiently smooth spiral. I recall that you can invert the phase with a reflection or a phase shift set to 1/2 the wavelength of the sound in the pipe. You could split and combine outputs by splitting and combining pipes. Then, instead of tallying up clicks on different channels (as in a quantum computer), you could just measure the power coming through each of the output channels.</p>
<p>I'm not saying this is necessarily practical--if nothing else you'd obviously have better bandwidth at higher frequencies than sound could propagate through most media. I got the sense there had to be some difference in effect between this hypothetical scenario and a real quantum computer. Could anyone help identify it or else confirm the effect is, in fact, the same?</p>
",Quantum fourier transform with classical vibrations,<quantum-gate><quantum-fourier-transform><quantum-circuit><nonclassicality>,1,0,,,"Quantum fourier transform with classical vibrations <p>Is there any difference in effect between a quantum circuit and a carefully constructed analogue one relying on interference? For example, why couldn't I take a series of <span class=""math-container"">$N$</span> carefully shaped pipes, split a sound source between them, and build, say, a quantum Fourier transform circuit with classical versions of Hadamard and phase shift gates? For example, it would be easy to shift phase by extending the length of a pipe with a sufficiently smooth spiral. I recall that you can invert the phase with a reflection or a phase shift set to 1/2 the wavelength of the sound in the pipe. You could split and combine outputs by splitting and combining pipes. Then, instead of tallying up clicks on different channels (as in a quantum computer), you could just measure the power coming through each of the output channels.</p>
<p>I'm not saying this is necessarily practical--if nothing else you'd obviously have better bandwidth at higher frequencies than sound could propagate through most media. I got the sense there had to be some difference in effect between this hypothetical scenario and a real quantum computer. Could anyone help identify it or else confirm the effect is, in fact, the same?</p>
",qc,quantum fourier transform classical vibrations p difference effect quantum circuit carefully constructed analogue one relying interference example could take series span n carefully shaped pipes split sound source build say quantum fourier transform circuit classical versions hadamard phase shift gates example would easy shift phase extending length pipe sufficiently smooth spiral recall invert phase reflection phase shift set wavelength sound pipe could split combine outputs splitting combining pipes instead tallying clicks different channels quantum computer could measure power coming output p saying necessarily practical nothing else obviously better bandwidth higher frequencies sound could propagate media got sense difference effect hypothetical scenario real quantum computer could anyone help identify else confirm effect fact,"[(1, 0.09356073), (4, 0.014656223), (5, 0.011774521), (7, 0.10322035), (8, 0.104039155), (9, 0.4349675), (13, 0.085053116), (14, 0.10203177), (17, 0.023584116), (18, 0.026151)]"
18345,18347.0,2021-07-08 09:35:03,1,285,"<p>A circular reference is when a certain value either refers to itself or a value refers to a value that refers to it.  An example of a circular reference problem would be <span class=""math-container"">$x=f(x)$</span>.  One way to solve such a circular reference problem would be to start with a random guess for x, find the value of f(x), and then have <span class=""math-container"">$x_{n+1}=f(x_n)$</span> until a certain numerical condition is met.  Using this method it's possible that the first guess for x would satisfy the given numerical condition and going onto another iteration would be unnecessary.</p>
<p>I understand that quantum computers could solve some problems more efficiently than classical computers as they can perform multiple calculations at the same time, but in order for that to be useful the wrong answers need to destructively interfere with each other.</p>
<p>Would circular reference problems be something that quantum computers could solve more efficiently than classical computers?</p>
",Would quantum computers be more efficient at solving circular reference problems than classical computers?,<quantum-algorithms><complexity-theory><quantum-advantage><applications>,1,0,,,"Would quantum computers be more efficient at solving circular reference problems than classical computers? <p>A circular reference is when a certain value either refers to itself or a value refers to a value that refers to it.  An example of a circular reference problem would be <span class=""math-container"">$x=f(x)$</span>.  One way to solve such a circular reference problem would be to start with a random guess for x, find the value of f(x), and then have <span class=""math-container"">$x_{n+1}=f(x_n)$</span> until a certain numerical condition is met.  Using this method it's possible that the first guess for x would satisfy the given numerical condition and going onto another iteration would be unnecessary.</p>
<p>I understand that quantum computers could solve some problems more efficiently than classical computers as they can perform multiple calculations at the same time, but in order for that to be useful the wrong answers need to destructively interfere with each other.</p>
<p>Would circular reference problems be something that quantum computers could solve more efficiently than classical computers?</p>
",qc,would quantum computers efficient solving circular reference problems classical computers p circular reference certain value either refers value refers value refers example circular reference problem would span x one way solve circular reference problem would start random guess x find value f x span certain numerical condition met using method possible first guess x would satisfy given numerical condition going onto another iteration would p understand quantum computers could solve problems efficiently classical computers perform multiple calculations time order useful wrong answers need destructively interfere p would circular reference problems something quantum computers could solve efficiently classical computers,"[(1, 0.362468), (7, 0.42058706), (10, 0.064398855), (17, 0.010952285), (18, 0.14003403)]"
18350,18351.0,2021-07-08 11:33:22,3,1353,"<p>How do I apply the Choi matrix on a Density matrix.</p>
<p>Say my process is a Hadamard gate, and my input state is the ground state on 1 qubit (qubit id 0).</p>
<p><span class=""math-container"">$U = H = \dfrac{1}{\sqrt{2}} \begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}$</span></p>
<p>Thus, to do ancilla assisted QPT, I need 1 ancilla qubit (I took it as the MSB, qubit id 1).</p>
<p>So,:</p>
<p><span class=""math-container"">$\rho_{in} = |0\rangle \langle 0| = \begin{bmatrix}1&amp;0\\0&amp;0\end{bmatrix}$</span></p>
<p>Considering the full system (along with ancilla), the:</p>
<p><span class=""math-container"">$\rho_{in}^{sys} = |00\rangle \langle 00| = \begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\end{bmatrix}$</span></p>
<p>The (normalized) Choi matrix for the quantum circuit with Hadamard of Qubit 0, is:</p>
<p><span class=""math-container"">$\rho_{choi}^{sys} = \begin{bmatrix}0.25&amp;0.25&amp;0.25&amp;-0.25\\0.25&amp;0.25&amp;0.25&amp;-0.25\\0.25&amp;0.25&amp;0.25&amp;-0.25\\-0.25&amp;-0.25&amp;-0.25&amp;0.25\end{bmatrix}$</span></p>
<p>This can be found either using Qiskit, or solving <span class=""math-container"">$(I \otimes H)(|\Omega \rangle \langle \Omega |)(I \otimes H)^\dagger$</span>, where <span class=""math-container"">$|\Omega \rangle$</span> is the Bell pair <span class=""math-container"">$\dfrac{1}{\sqrt{2}} (|00\rangle +|11\rangle )$</span></p>
<p>Considering I am applying a Hadamard on the <span class=""math-container"">$\rho_{in}$</span>, the output density matrix:</p>
<p><span class=""math-container"">$\rho_{out} = H|0\rangle \langle 0|H^{\dagger} = \begin{bmatrix}0.5&amp;0.5\\0.5&amp;0.5\end{bmatrix}$</span></p>
<p>How exactly do I recover this back from the <span class=""math-container"">$\rho_{choi}^{sys}, \rho_{in}^{sys}$</span> and partial trace as given in the Qiskit link <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Choi.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.Choi.html</a>?</p>
",How to describe the evolution of a density matrix using the Choi matrix?,<qiskit><quantum-operation><density-matrix><quantum-process-tomography>,3,0,,,"How to describe the evolution of a density matrix using the Choi matrix? <p>How do I apply the Choi matrix on a Density matrix.</p>
<p>Say my process is a Hadamard gate, and my input state is the ground state on 1 qubit (qubit id 0).</p>
<p><span class=""math-container"">$U = H = \dfrac{1}{\sqrt{2}} \begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}$</span></p>
<p>Thus, to do ancilla assisted QPT, I need 1 ancilla qubit (I took it as the MSB, qubit id 1).</p>
<p>So,:</p>
<p><span class=""math-container"">$\rho_{in} = |0\rangle \langle 0| = \begin{bmatrix}1&amp;0\\0&amp;0\end{bmatrix}$</span></p>
<p>Considering the full system (along with ancilla), the:</p>
<p><span class=""math-container"">$\rho_{in}^{sys} = |00\rangle \langle 00| = \begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0\end{bmatrix}$</span></p>
<p>The (normalized) Choi matrix for the quantum circuit with Hadamard of Qubit 0, is:</p>
<p><span class=""math-container"">$\rho_{choi}^{sys} = \begin{bmatrix}0.25&amp;0.25&amp;0.25&amp;-0.25\\0.25&amp;0.25&amp;0.25&amp;-0.25\\0.25&amp;0.25&amp;0.25&amp;-0.25\\-0.25&amp;-0.25&amp;-0.25&amp;0.25\end{bmatrix}$</span></p>
<p>This can be found either using Qiskit, or solving <span class=""math-container"">$(I \otimes H)(|\Omega \rangle \langle \Omega |)(I \otimes H)^\dagger$</span>, where <span class=""math-container"">$|\Omega \rangle$</span> is the Bell pair <span class=""math-container"">$\dfrac{1}{\sqrt{2}} (|00\rangle +|11\rangle )$</span></p>
<p>Considering I am applying a Hadamard on the <span class=""math-container"">$\rho_{in}$</span>, the output density matrix:</p>
<p><span class=""math-container"">$\rho_{out} = H|0\rangle \langle 0|H^{\dagger} = \begin{bmatrix}0.5&amp;0.5\\0.5&amp;0.5\end{bmatrix}$</span></p>
<p>How exactly do I recover this back from the <span class=""math-container"">$\rho_{choi}^{sys}, \rho_{in}^{sys}$</span> and partial trace as given in the Qiskit link <a href=""https://qiskit.org/documentation/stubs/qiskit.quantum_info.Choi.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/stubs/qiskit.quantum_info.Choi.html</a>?</p>
",qc,describe evolution density matrix using choi matrix p apply choi matrix density p say process hadamard gate input state ground state 1 qubit qubit id 0 p span u h 1 2 bmatrix 1 amp amp bmatrix p thus ancilla assisted qpt need 1 ancilla qubit took msb qubit id 1 p p span bmatrix 1 amp amp bmatrix p considering full system along ancilla p span sys bmatrix 1 amp 0 amp 0 amp amp 0 amp 0 amp amp 0 amp 0 amp amp 0 amp 0 amp bmatrix p normalized choi matrix quantum circuit hadamard qubit 0 p span choi sys bmatrix amp amp amp amp amp amp amp amp amp amp amp amp bmatrix p found either using qiskit solving span h h span bell pair span 1 2 p considering applying hadamard span output density matrix p span bmatrix amp amp bmatrix p exactly recover back span choi sys sys partial trace given qiskit link https nofollow noreferrer https,"[(1, 0.014724883), (2, 0.099719085), (3, 0.027643478), (4, 0.065738514), (11, 0.051791303), (14, 0.045064855), (15, 0.51101744), (17, 0.015788788), (18, 0.16782038)]"
18381,,2021-07-10 00:15:54,2,508,"<p>I have a script in the IBM Quantum lab which runs several jobs and stores the result of each job as a .txt file in a results folder. All I want to do is to download the folder of files. I cannot figure out how to do this and so at the moment I have to open the folder in the Quantum Lab and then select each file and individually download it. This is getting very tiresome.</p>
<p>I feel like I must be missing something really simple that would enable me to just download the folder, but when I click on the dropdown menu for the folder, all it allows me to do is to rename or delete it.</p>
<p>Sorry for the stupid question!</p>
",How to download from IBM Quantum lab folder of data .txt files all at once?,<programming><ibm-q-experience>,1,3,,,"How to download from IBM Quantum lab folder of data .txt files all at once? <p>I have a script in the IBM Quantum lab which runs several jobs and stores the result of each job as a .txt file in a results folder. All I want to do is to download the folder of files. I cannot figure out how to do this and so at the moment I have to open the folder in the Quantum Lab and then select each file and individually download it. This is getting very tiresome.</p>
<p>I feel like I must be missing something really simple that would enable me to just download the folder, but when I click on the dropdown menu for the folder, all it allows me to do is to rename or delete it.</p>
<p>Sorry for the stupid question!</p>
",qc,download ibm quantum lab folder data files p script ibm quantum lab runs several jobs stores result job file results folder want download folder files figure moment open folder quantum lab select file individually download getting p feel like must missing something really simple would enable download folder click dropdown menu folder allows rename delete p sorry stupid question,"[(7, 0.07371896), (9, 0.02685556), (14, 0.73094314), (16, 0.12140808), (17, 0.044022497)]"
18402,,2021-07-12 08:11:29,1,88,"<p>I am running a VQE over the H2 molecule on ibmq_quito and I set a callback function to save all jobs id's of all iterations. When I check the penultimate job (and the previous ones), I have 2 circuits or experiments (one for Z basis and one for X basis). But when I check the last job, I just obtain one circuit. Does anyone know why on the last job of the VQE I have one circuit while I still have to measure in different basis to get the expectation value of the energy?
Thank you very much in advance!</p>
",Why the last IBMQ job of my VQE have just one circuit?,<ibm-q-experience><vqe><chemistry>,1,0,,,"Why the last IBMQ job of my VQE have just one circuit? <p>I am running a VQE over the H2 molecule on ibmq_quito and I set a callback function to save all jobs id's of all iterations. When I check the penultimate job (and the previous ones), I have 2 circuits or experiments (one for Z basis and one for X basis). But when I check the last job, I just obtain one circuit. Does anyone know why on the last job of the VQE I have one circuit while I still have to measure in different basis to get the expectation value of the energy?
Thank you very much in advance!</p>
",qc,last ibmq job vqe one circuit p running vqe h2 molecule set callback function save jobs id iterations check penultimate job previous ones 2 circuits experiments one z basis one x basis check last job obtain one circuit anyone know last job vqe one circuit still measure different basis get expectation value energy thank much advance,"[(10, 0.021967238), (14, 0.5931011), (17, 0.14833052), (18, 0.124220625), (19, 0.109662846)]"
18417,,2021-07-12 21:40:05,2,66,"<p>I'm using a research account and I have a question about running circuits with (dedicated/priority mode) and without reservation (fair-share mode). From the documentation of dedicated mode,</p>
<blockquote>
<p>This (The dedicated mode) allows users to implement algorithms where input circuits are conditioned on previous results, such as iterative and near-time compute methods, without having to wait for other users’ results to process.</p>
</blockquote>
<p>My quantum circuits involve mid-circuit measurements without resetting the qubit after it is measured each time, so each measurement is (kind of) dependent on the previous results. I wonder if I run them using the fair-share mode (without reservation), will that still give me the results I'm supposed to have from the dedicated mode? I have run some experiments and it looks like there aren't too many differences, but I'm not sure if there should or should not be. Thanks!</p>
",Does dedicated mode provide better results than fairshare in mid-circuit measurement?,<ibm-q-experience>,0,2,,,"Does dedicated mode provide better results than fairshare in mid-circuit measurement? <p>I'm using a research account and I have a question about running circuits with (dedicated/priority mode) and without reservation (fair-share mode). From the documentation of dedicated mode,</p>
<blockquote>
<p>This (The dedicated mode) allows users to implement algorithms where input circuits are conditioned on previous results, such as iterative and near-time compute methods, without having to wait for other users’ results to process.</p>
</blockquote>
<p>My quantum circuits involve mid-circuit measurements without resetting the qubit after it is measured each time, so each measurement is (kind of) dependent on the previous results. I wonder if I run them using the fair-share mode (without reservation), will that still give me the results I'm supposed to have from the dedicated mode? I have run some experiments and it looks like there aren't too many differences, but I'm not sure if there should or should not be. Thanks!</p>
",qc,dedicated mode provide better results fairshare measurement p using research account question running circuits mode without reservation mode documentation dedicated mode blockquote p dedicated mode allows users implement algorithms input circuits conditioned previous results iterative compute methods without wait users results p quantum circuits involve measurements without resetting qubit measured time measurement kind dependent previous results wonder run using mode without reservation still give results supposed dedicated mode run experiments looks like many differences sure thanks,"[(3, 0.01419536), (8, 0.26907396), (14, 0.68214464), (17, 0.0323938)]"
18493,18496.0,2021-07-19 08:52:13,1,343,"<p>I encountered a problem when learning from the <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html#varforms"" rel=""nofollow noreferrer"">qiskit tutorial</a> about solving electronic structure problem with VQE. Under the &quot;Running VQE on a Statevector Simulator&quot; part, the code provided for leveraging active space of LiH to reduce the qubit requirement seems quite confusing. The <code>freeze_list</code> in the code is interpreted as the core space in my opinion. However, what confuse me is that why to choose the [-3, -2] orbitals as virtual space to be removed (<code>remove_list</code>). Or the problem can be stated as why to choose [-3, -2] as the virtual space of the LiH molecule? The corresponding code of the tutorial is provide as below:</p>
<pre><code>def get_qubit_op(dist):
    driver = PySCFDriver(atom=&quot;Li .0 .0 .0; H .0 .0 &quot; + str(dist), unit=UnitsType.ANGSTROM, 
                         charge=0, spin=0, basis='sto3g')
    molecule = driver.run()
    freeze_list = [0]
    remove_list = [-3, -2]
    repulsion_energy = molecule.nuclear_repulsion_energy
    num_particles = molecule.num_alpha + molecule.num_beta
    num_spin_orbitals = molecule.num_orbitals * 2
    remove_list = [x % molecule.num_orbitals for x in remove_list]
    freeze_list = [x % molecule.num_orbitals for x in freeze_list]
    remove_list = [x - len(freeze_list) for x in remove_list]
    remove_list += [x + molecule.num_orbitals - len(freeze_list)  for x in remove_list]
    freeze_list += [x + molecule.num_orbitals for x in freeze_list]
    ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)
    ferOp, energy_shift = ferOp.fermion_mode_freezing(freeze_list)
    num_spin_orbitals -= len(freeze_list)
    num_particles -= len(freeze_list)
    ferOp = ferOp.fermion_mode_elimination(remove_list)
    num_spin_orbitals -= len(remove_list)
    qubitOp = ferOp.mapping(map_type='parity', threshold=0.00000001)
    qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
    shift = energy_shift + repulsion_energy
    return qubitOp, num_particles, num_spin_orbitals, shift
</code></pre>
",Active space chosen for VQE in qiskit,<qiskit><vqe>,1,0,,,"Active space chosen for VQE in qiskit <p>I encountered a problem when learning from the <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html#varforms"" rel=""nofollow noreferrer"">qiskit tutorial</a> about solving electronic structure problem with VQE. Under the &quot;Running VQE on a Statevector Simulator&quot; part, the code provided for leveraging active space of LiH to reduce the qubit requirement seems quite confusing. The <code>freeze_list</code> in the code is interpreted as the core space in my opinion. However, what confuse me is that why to choose the [-3, -2] orbitals as virtual space to be removed (<code>remove_list</code>). Or the problem can be stated as why to choose [-3, -2] as the virtual space of the LiH molecule? The corresponding code of the tutorial is provide as below:</p>
<pre><code>def get_qubit_op(dist):
    driver = PySCFDriver(atom=&quot;Li .0 .0 .0; H .0 .0 &quot; + str(dist), unit=UnitsType.ANGSTROM, 
                         charge=0, spin=0, basis='sto3g')
    molecule = driver.run()
    freeze_list = [0]
    remove_list = [-3, -2]
    repulsion_energy = molecule.nuclear_repulsion_energy
    num_particles = molecule.num_alpha + molecule.num_beta
    num_spin_orbitals = molecule.num_orbitals * 2
    remove_list = [x % molecule.num_orbitals for x in remove_list]
    freeze_list = [x % molecule.num_orbitals for x in freeze_list]
    remove_list = [x - len(freeze_list) for x in remove_list]
    remove_list += [x + molecule.num_orbitals - len(freeze_list)  for x in remove_list]
    freeze_list += [x + molecule.num_orbitals for x in freeze_list]
    ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)
    ferOp, energy_shift = ferOp.fermion_mode_freezing(freeze_list)
    num_spin_orbitals -= len(freeze_list)
    num_particles -= len(freeze_list)
    ferOp = ferOp.fermion_mode_elimination(remove_list)
    num_spin_orbitals -= len(remove_list)
    qubitOp = ferOp.mapping(map_type='parity', threshold=0.00000001)
    qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)
    shift = energy_shift + repulsion_energy
    return qubitOp, num_particles, num_spin_orbitals, shift
</code></pre>
",qc,active space chosen vqe qiskit p encountered problem learning https varforms nofollow noreferrer qiskit tutorial solving electronic structure problem vqe quot running vqe statevector simulator quot part code provided leveraging active space lih reduce qubit requirement seems quite confusing code code interpreted core space opinion however confuse choose orbitals virtual space removed code problem stated choose virtual space lih molecule corresponding code tutorial provide pre code def dist driver pyscfdriver quot li h quot str dist molecule 0 2 x x x x x len x x len x x x ferop fermionicoperator ferop len len ferop len qubitop qubitop qubitop shift return qubitop shift,"[(0, 0.2996226), (3, 0.04462585), (4, 0.061425835), (7, 0.02853797), (8, 0.22263952), (10, 0.11948645), (12, 0.043047417), (17, 0.12628585), (19, 0.05322823)]"
18502,,2021-07-19 19:49:32,2,126,"<p>In the paper <a href=""https://doi.org/10.1080/00107514.2019.1667078"" rel=""nofollow noreferrer""><em>Quantum Error Correction: An Introductory Guide</em></a> (<a href=""https://doi.org/10.48550/arXiv.1907.11157"" rel=""nofollow noreferrer"">arXiv</a>), the author gives the following formula for a simple two qubit code (Eq. 19 in the paper).</p>
<p><span class=""math-container"">$$
E|\psi\rangle_L|0\rangle_A \xrightarrow{\text{syndrome extraction}} \frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 + Z_1Z_2) E|\psi\rangle_L|0\rangle_A + \frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 - Z_1Z_2) E|\psi\rangle_L|1\rangle_A
$$</span></p>
<p>For reference, the circuit corresponding to this code is:</p>
<p><a href=""https://i.sstatic.net/wsWi1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wsWi1.png"" alt=""enter image description here"" /></a></p>
<p>Here <span class=""math-container"">$E \in \{\mathbb{I}, X_1, X_2, X_1X_2\}$</span> is an error gate. Now, after giving that equation, the paper says</p>
<blockquote>
<p>Now, consider the case where <span class=""math-container"">$E = X_1$</span> so that the logical state occupies the error space <span class=""math-container"">$E|\psi\rangle_L \in \mathcal{F}$</span>. In this scenario, it can be seen that the first term in equation (19) goes to zero. [...] Considering the other error patterns, we see that if the logical state is in the codespace (i.e., if <span class=""math-container"">$E = \{\mathbb{I}, X_1X_2\}$</span>) then the ancilla is measured as ‘0’.</p>
</blockquote>
<p><span class=""math-container"">$\mathcal{F}$</span> is the error space, which contains the states <span class=""math-container"">$|01\rangle$</span> and <span class=""math-container"">$|10\rangle$</span>. By making <span class=""math-container"">$|\psi\rangle_L = \alpha|0\rangle_L + \beta|1\rangle_L$</span> and working out the equation with <span class=""math-container"">$E = X_1$</span> and <span class=""math-container"">$E = X_2$</span> I can see how the first term cancels and we are left with <span class=""math-container"">$|1\rangle_A$</span> in the ancilla qubit. Similarly with <span class=""math-container"">$E = X_1X_2$</span> and <span class=""math-container"">$E = \mathbb{I}$</span> I can see how we are left with <span class=""math-container"">$|0\rangle_A$</span> in the ancilla qubit.</p>
<p>As you can see, I needed to expand the logical qubit to see how the code is able to measure the error. However, I feel like it is implied in the paper that you can figure this out by just substituting <span class=""math-container"">$E$</span> and leaving <span class=""math-container"">$|\psi\rangle_L$</span> as it is. How can I show this? For example, in the case that <span class=""math-container"">$E=X_1$</span>, how does the expression</p>
<p><span class=""math-container"">$$
\frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 + Z_1Z_2) X_1|\psi\rangle_L|0\rangle_A + \frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 - Z_1Z_2) X_1|\psi\rangle_L|1\rangle_A
$$</span></p>
<p>simplify such that the first term disappears, without making <span class=""math-container"">$|\psi\rangle_L = \alpha|0\rangle_L + \beta|1\rangle_L$</span>? I tried doing it with matrix multiplication but the term didn't disappear.</p>
",Simplifying equation for two qubit syndrome extraction code,<error-correction>,1,0,,,"Simplifying equation for two qubit syndrome extraction code <p>In the paper <a href=""https://doi.org/10.1080/00107514.2019.1667078"" rel=""nofollow noreferrer""><em>Quantum Error Correction: An Introductory Guide</em></a> (<a href=""https://doi.org/10.48550/arXiv.1907.11157"" rel=""nofollow noreferrer"">arXiv</a>), the author gives the following formula for a simple two qubit code (Eq. 19 in the paper).</p>
<p><span class=""math-container"">$$
E|\psi\rangle_L|0\rangle_A \xrightarrow{\text{syndrome extraction}} \frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 + Z_1Z_2) E|\psi\rangle_L|0\rangle_A + \frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 - Z_1Z_2) E|\psi\rangle_L|1\rangle_A
$$</span></p>
<p>For reference, the circuit corresponding to this code is:</p>
<p><a href=""https://i.sstatic.net/wsWi1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wsWi1.png"" alt=""enter image description here"" /></a></p>
<p>Here <span class=""math-container"">$E \in \{\mathbb{I}, X_1, X_2, X_1X_2\}$</span> is an error gate. Now, after giving that equation, the paper says</p>
<blockquote>
<p>Now, consider the case where <span class=""math-container"">$E = X_1$</span> so that the logical state occupies the error space <span class=""math-container"">$E|\psi\rangle_L \in \mathcal{F}$</span>. In this scenario, it can be seen that the first term in equation (19) goes to zero. [...] Considering the other error patterns, we see that if the logical state is in the codespace (i.e., if <span class=""math-container"">$E = \{\mathbb{I}, X_1X_2\}$</span>) then the ancilla is measured as ‘0’.</p>
</blockquote>
<p><span class=""math-container"">$\mathcal{F}$</span> is the error space, which contains the states <span class=""math-container"">$|01\rangle$</span> and <span class=""math-container"">$|10\rangle$</span>. By making <span class=""math-container"">$|\psi\rangle_L = \alpha|0\rangle_L + \beta|1\rangle_L$</span> and working out the equation with <span class=""math-container"">$E = X_1$</span> and <span class=""math-container"">$E = X_2$</span> I can see how the first term cancels and we are left with <span class=""math-container"">$|1\rangle_A$</span> in the ancilla qubit. Similarly with <span class=""math-container"">$E = X_1X_2$</span> and <span class=""math-container"">$E = \mathbb{I}$</span> I can see how we are left with <span class=""math-container"">$|0\rangle_A$</span> in the ancilla qubit.</p>
<p>As you can see, I needed to expand the logical qubit to see how the code is able to measure the error. However, I feel like it is implied in the paper that you can figure this out by just substituting <span class=""math-container"">$E$</span> and leaving <span class=""math-container"">$|\psi\rangle_L$</span> as it is. How can I show this? For example, in the case that <span class=""math-container"">$E=X_1$</span>, how does the expression</p>
<p><span class=""math-container"">$$
\frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 + Z_1Z_2) X_1|\psi\rangle_L|0\rangle_A + \frac{1}{2}(\mathbb{I}_1\mathbb{I}_2 - Z_1Z_2) X_1|\psi\rangle_L|1\rangle_A
$$</span></p>
<p>simplify such that the first term disappears, without making <span class=""math-container"">$|\psi\rangle_L = \alpha|0\rangle_L + \beta|1\rangle_L$</span>? I tried doing it with matrix multiplication but the term didn't disappear.</p>
",qc,simplifying equation two qubit syndrome extraction code p paper https nofollow noreferrer em quantum error correction introductory guide https nofollow noreferrer arxiv author gives following formula simple two qubit code eq 19 paper p span syndrome extraction 1 2 1 2 p reference circuit corresponding code p https nofollow noreferrer img https enter image description p span e error gate giving equation paper says blockquote p consider case span e logical state occupies error space span f scenario seen first term equation 19 goes zero considering error patterns see logical state codespace span e ancilla measured 0 p span f error space contains states span span making span working equation span e span e see first term cancels left span ancilla qubit similarly span e span e see left span ancilla p see needed expand logical qubit see code able measure error however feel like implied paper figure substituting span e leaving span show example case span expression p span 1 2 1 2 p simplify first term disappears without making span tried matrix multiplication term,"[(2, 0.030782277), (3, 0.48750797), (4, 0.17891735), (5, 0.18381532), (6, 0.014941867), (10, 0.014146497), (17, 0.026525222), (18, 0.06267837)]"
18521,18527.0,2021-07-20 22:16:54,5,915,"<p>I just came across <a href=""https://en.wikipedia.org/wiki/Bennett%27s_laws"" rel=""noreferrer"">Bennett's laws</a> and I wonder what the second law mean. It states that 1 qubit &quot;can do the job&quot; of 1 ebit. However, the definition of ebit (entanglement bit, wiki just refers it to the Bell state) and the notion of &quot;can do the job&quot; are unclear. Can you clarify more rigorously what the second Bennett's law says?</p>
",What does it mean that 1 qubit can do the job of 1 ebit (entanglement bit)? (second Bennett's law),<terminology-and-notation>,2,0,,,"What does it mean that 1 qubit can do the job of 1 ebit (entanglement bit)? (second Bennett's law) <p>I just came across <a href=""https://en.wikipedia.org/wiki/Bennett%27s_laws"" rel=""noreferrer"">Bennett's laws</a> and I wonder what the second law mean. It states that 1 qubit &quot;can do the job&quot; of 1 ebit. However, the definition of ebit (entanglement bit, wiki just refers it to the Bell state) and the notion of &quot;can do the job&quot; are unclear. Can you clarify more rigorously what the second Bennett's law says?</p>
",qc,mean 1 qubit job 1 ebit entanglement bit second bennett law p came across https noreferrer bennett laws wonder second law mean states 1 qubit quot job quot 1 ebit however definition ebit entanglement bit wiki refers bell state notion quot job quot unclear clarify rigorously second bennett law says,"[(2, 0.080626465), (8, 0.031650342), (9, 0.40511063), (17, 0.02149121), (18, 0.29955602), (19, 0.1585965)]"
18524,18525.0,2021-07-21 00:25:45,1,71,"<p>For the following Bloch sphere representation of a qubit, what does the highlighted symbol mean? I'm not sure if it means anything or it's just for showing that it's a sphere, not a circle.
<a href=""https://i.sstatic.net/xYZbI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xYZbI.png"" alt=""enter image description here"" /></a></p>
",Meaning of a pound sign (#) on a Bloch sphere,<quantum-state><bloch-sphere>,1,0,,,"Meaning of a pound sign (#) on a Bloch sphere <p>For the following Bloch sphere representation of a qubit, what does the highlighted symbol mean? I'm not sure if it means anything or it's just for showing that it's a sphere, not a circle.
<a href=""https://i.sstatic.net/xYZbI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xYZbI.png"" alt=""enter image description here"" /></a></p>
",qc,meaning pound sign bloch sphere p following bloch sphere representation qubit highlighted symbol mean sure means anything showing sphere circle https nofollow noreferrer img https enter image description,"[(4, 0.5886799), (5, 0.08735674), (13, 0.28085008), (17, 0.03722841)]"
18536,,2021-07-21 14:28:19,5,302,"<p>If you want to check if a pair of unknown qubits are the same, a standard test is the controlled SWAP test. This gives a result of 0 with certainty if the states are the same and 1 with a 50% chance if the states are orthogonal. The resulting probability distribution can also be used to approximate fidelity, etc.</p>
<p>Is there a/what is the equivalent test to determine orthogonality with certainty, i.e. giving a result of 0 with certainty if the states are orthogonal and 1 with some probability if the states are identical?</p>
<p>Alternatively, is there a more balanced test, which gives the same (lower than 50%) error in detecting either orthogonality or similarity?</p>
<p>Obviously, one opton is to carry out state tomography on each qubit to get their mathematical descriptions and calculate the orthogonality/fidelity accordingly, but this may not be the best solution in terms of copies required for a given accuracy.</p>
",How do you test a pair of unknown qubits for orthogonality with certainty?,<quantum-algorithms><swap-test><state-discrimination>,2,0,,,"How do you test a pair of unknown qubits for orthogonality with certainty? <p>If you want to check if a pair of unknown qubits are the same, a standard test is the controlled SWAP test. This gives a result of 0 with certainty if the states are the same and 1 with a 50% chance if the states are orthogonal. The resulting probability distribution can also be used to approximate fidelity, etc.</p>
<p>Is there a/what is the equivalent test to determine orthogonality with certainty, i.e. giving a result of 0 with certainty if the states are orthogonal and 1 with some probability if the states are identical?</p>
<p>Alternatively, is there a more balanced test, which gives the same (lower than 50%) error in detecting either orthogonality or similarity?</p>
<p>Obviously, one opton is to carry out state tomography on each qubit to get their mathematical descriptions and calculate the orthogonality/fidelity accordingly, but this may not be the best solution in terms of copies required for a given accuracy.</p>
",qc,test pair unknown qubits orthogonality certainty p want check pair unknown qubits standard test controlled swap test gives result 0 certainty states 1 50 chance states orthogonal resulting probability distribution also used approximate fidelity p equivalent test determine orthogonality certainty giving result 0 certainty states orthogonal 1 probability states identical p alternatively balanced test gives lower 50 error detecting either orthogonality similarity p obviously one opton carry state tomography qubit get mathematical descriptions calculate accordingly may best solution terms copies required given,"[(2, 0.04945864), (3, 0.21546574), (13, 0.1613739), (14, 0.1468401), (17, 0.09883137), (18, 0.32630506)]"
18566,18567.0,2021-07-22 14:29:38,2,99,"<p>I'm in the need of running a lot of jobs in the IBM backends. If one likes to run in parallel two jobs (say, with two different parameters), I have seen in the <code>Jobs</code> webpage that sometimes the jobs are mixed. What I mean with this is that e.g. in the downloadable cvs file, row 3 belongs to job 1 and row 4 to job 2. To filter out every single cell in the cvs does not appear feasible.</p>
<p>Now, in qiskit, if I send a big job, this is partitioned into several chunks, something that <code>job_set_foo.report(detailed=True)</code> returns is:</p>
<pre><code>Job set name: 2021-07-22T14:09:01.003237
      ID: XXXX-YYYY
    tags: []
...
Detail report:
  experiments: 0-74
    job index: 0
    job ID: ZZZ1
...
</code></pre>
<p>So suppose that my ID <code>XXX-YYY</code> contains 20 jobs ids <code>ZZZx</code>. Is there a way to, from directly the ID, retrieve as a list all the <code>ZZZx</code>'s jobs ids?</p>
<p>*<code>job_set_foo = job_manager.run(circuits, backend=backend, shots=2**13)</code></p>
",Job ids retrieval from ID. Big set of jobs,<programming><ibm-q-experience>,1,0,,,"Job ids retrieval from ID. Big set of jobs <p>I'm in the need of running a lot of jobs in the IBM backends. If one likes to run in parallel two jobs (say, with two different parameters), I have seen in the <code>Jobs</code> webpage that sometimes the jobs are mixed. What I mean with this is that e.g. in the downloadable cvs file, row 3 belongs to job 1 and row 4 to job 2. To filter out every single cell in the cvs does not appear feasible.</p>
<p>Now, in qiskit, if I send a big job, this is partitioned into several chunks, something that <code>job_set_foo.report(detailed=True)</code> returns is:</p>
<pre><code>Job set name: 2021-07-22T14:09:01.003237
      ID: XXXX-YYYY
    tags: []
...
Detail report:
  experiments: 0-74
    job index: 0
    job ID: ZZZ1
...
</code></pre>
<p>So suppose that my ID <code>XXX-YYY</code> contains 20 jobs ids <code>ZZZx</code>. Is there a way to, from directly the ID, retrieve as a list all the <code>ZZZx</code>'s jobs ids?</p>
<p>*<code>job_set_foo = job_manager.run(circuits, backend=backend, shots=2**13)</code></p>
",qc,job ids retrieval id big set jobs p need running lot jobs ibm backends one likes run parallel two jobs say two different parameters seen code jobs webpage sometimes jobs mixed mean downloadable cvs file row 3 belongs job 1 row 4 job filter every single cell cvs appear p qiskit send big job partitioned several chunks something code returns pre code job set name id tags detail report experiments job index 0 job id zzz1 p suppose id code contains 20 jobs ids code zzzx way directly id retrieve list code zzzx jobs ids p code circuits 13,"[(0, 0.06447892), (3, 0.050098307), (6, 0.059237614), (9, 0.03983464), (13, 0.040793326), (14, 0.68150246), (17, 0.0626105)]"
18572,,2021-07-23 01:56:36,8,170,"<p>Let <span class=""math-container"">$\mu:\Sigma\to\mathrm{Pos}(\mathbb{C}^d)$</span> be some POVM, with <span class=""math-container"">$\Sigma$</span> the finite set of possible outcomes, and <span class=""math-container"">$\mathrm{Pos}(\mathbb{C}^d)$</span> the set of <span class=""math-container"">$d$</span>-dimensional positive semidefinite operators. Write the components of the POVM with <span class=""math-container"">$\mu_b, b\in\Sigma$</span>.</p>
<p>From Naimark's dilation theorem, we know that <span class=""math-container"">$\mu$</span> can be understood as a <em>projective measurement</em> on an isometrically enlarged space. More precisely, that there is an isometry <span class=""math-container"">$U_\mu:\mathbb{C}^d\to\mathbb{C}^d\otimes\mathbb{C}^{d'}$</span>, for some <span class=""math-container"">$d'$</span>, such that <span class=""math-container"">$\mu_a=U_\mu^\dagger (I\otimes P_a) U_\mu$</span> for all <span class=""math-container"">$a\in\Sigma$</span>, with <span class=""math-container"">$P_a\equiv |a\rangle\!\langle a|$</span>. Explicitly, we can write this isometry as
<span class=""math-container"">$$U_\mu =\sum_{a\in\Sigma}\sqrt{\mu_a}\otimes |a\rangle
=\begin{pmatrix}\sqrt{\mu_1}\\ \vdots \\ \sqrt{\mu_{|\Sigma|}}\end{pmatrix}.$$</span></p>
<p>Consider now the notion of <em>extremality</em> of a POVM <span class=""math-container"">$\mu$</span>. We say that <span class=""math-container"">$\mu$</span> is extremal if it cannot be written as a (nontrivial) convex combination of other POVMs. Physically, this is interesting because a non-extremal POVM amounts to some degree of &quot;classical uncertainty&quot; added on top of whatever is being measured about the state.</p>
<p>How does the extremality of a POVM <span class=""math-container"">$\mu$</span> reflect on its &quot;Naimark isometry&quot; <span class=""math-container"">$U_\mu$</span>? If <span class=""math-container"">$\mu$</span> is extremal, that would mean that <span class=""math-container"">$U_\mu$</span> is an isometry such that each of its <span class=""math-container"">$d\times d$</span> blocks, call these <span class=""math-container"">$U_\mu(a)\equiv\sqrt{\mu_a}$</span>, cannot be written as <span class=""math-container"">$$U_\mu(a)^2=\frac12(U_{\mu_1}(a)^2+U_{\mu_2}(a)^2).$$</span>
In other words, convex combinations of measurements, in terms of the associated isometries, translate into these weird sums taken after squaring the different blocks building the individual isometries.
What kind of structure is this? Is there some known notion for isometries/unitaries corresponding to the impossibility of performing such a type of decomposition?</p>
",How does the extremality of a POVM reflect on its Naimark dilation isometry?,<measurement><quantum-operation><povm>,0,3,,,"How does the extremality of a POVM reflect on its Naimark dilation isometry? <p>Let <span class=""math-container"">$\mu:\Sigma\to\mathrm{Pos}(\mathbb{C}^d)$</span> be some POVM, with <span class=""math-container"">$\Sigma$</span> the finite set of possible outcomes, and <span class=""math-container"">$\mathrm{Pos}(\mathbb{C}^d)$</span> the set of <span class=""math-container"">$d$</span>-dimensional positive semidefinite operators. Write the components of the POVM with <span class=""math-container"">$\mu_b, b\in\Sigma$</span>.</p>
<p>From Naimark's dilation theorem, we know that <span class=""math-container"">$\mu$</span> can be understood as a <em>projective measurement</em> on an isometrically enlarged space. More precisely, that there is an isometry <span class=""math-container"">$U_\mu:\mathbb{C}^d\to\mathbb{C}^d\otimes\mathbb{C}^{d'}$</span>, for some <span class=""math-container"">$d'$</span>, such that <span class=""math-container"">$\mu_a=U_\mu^\dagger (I\otimes P_a) U_\mu$</span> for all <span class=""math-container"">$a\in\Sigma$</span>, with <span class=""math-container"">$P_a\equiv |a\rangle\!\langle a|$</span>. Explicitly, we can write this isometry as
<span class=""math-container"">$$U_\mu =\sum_{a\in\Sigma}\sqrt{\mu_a}\otimes |a\rangle
=\begin{pmatrix}\sqrt{\mu_1}\\ \vdots \\ \sqrt{\mu_{|\Sigma|}}\end{pmatrix}.$$</span></p>
<p>Consider now the notion of <em>extremality</em> of a POVM <span class=""math-container"">$\mu$</span>. We say that <span class=""math-container"">$\mu$</span> is extremal if it cannot be written as a (nontrivial) convex combination of other POVMs. Physically, this is interesting because a non-extremal POVM amounts to some degree of &quot;classical uncertainty&quot; added on top of whatever is being measured about the state.</p>
<p>How does the extremality of a POVM <span class=""math-container"">$\mu$</span> reflect on its &quot;Naimark isometry&quot; <span class=""math-container"">$U_\mu$</span>? If <span class=""math-container"">$\mu$</span> is extremal, that would mean that <span class=""math-container"">$U_\mu$</span> is an isometry such that each of its <span class=""math-container"">$d\times d$</span> blocks, call these <span class=""math-container"">$U_\mu(a)\equiv\sqrt{\mu_a}$</span>, cannot be written as <span class=""math-container"">$$U_\mu(a)^2=\frac12(U_{\mu_1}(a)^2+U_{\mu_2}(a)^2).$$</span>
In other words, convex combinations of measurements, in terms of the associated isometries, translate into these weird sums taken after squaring the different blocks building the individual isometries.
What kind of structure is this? Is there some known notion for isometries/unitaries corresponding to the impossibility of performing such a type of decomposition?</p>
",qc,extremality povm reflect naimark dilation isometry p let span pos c povm span finite set possible outcomes span pos c set span positive semidefinite operators write components povm span p naimark dilation theorem know span understood em projective measurement isometrically enlarged space precisely isometry span c c c span span span span explicitly write isometry span pmatrix pmatrix p consider notion em extremality povm span say span extremal written nontrivial convex combination povms physically interesting povm amounts degree quot classical uncertainty quot added top whatever measured p extremality povm span reflect quot naimark isometry quot span span extremal would mean span isometry span blocks call span written span words convex combinations measurements terms associated isometries translate weird sums taken squaring different blocks building individual isometries kind structure known notion corresponding impossibility performing type decomposition,"[(1, 0.02956861), (3, 0.7068197), (9, 0.1371359), (11, 0.012968792), (15, 0.027956933), (17, 0.016882652), (19, 0.06766802)]"
18613,,2021-07-26 12:06:02,1,94,"<p>Is there a way to implement a projector gate in a middle of a circuit?. For instance, assuming I have a Bell state <span class=""math-container"">$|00\rangle+|11\rangle$</span>, I'd like to apply a projector on the first qubit onto state <span class=""math-container"">$|1\rangle$</span> (operator <span class=""math-container"">$|1\rangle\langle 1|$</span>). Meaning that I will be left with <span class=""math-container"">$|1\rangle|1\rangle$</span>.Is it possible to do such thing in the middle, and then apply the rest circuit? Also, is there a way to apply a general nonunitary gate without performing real measurements or qasm, only statevector.</p>
",Applying a projector or a general nonunitary gate in the middle of a circuit using qiskit,<qiskit><quantum-circuit>,0,1,,,"Applying a projector or a general nonunitary gate in the middle of a circuit using qiskit <p>Is there a way to implement a projector gate in a middle of a circuit?. For instance, assuming I have a Bell state <span class=""math-container"">$|00\rangle+|11\rangle$</span>, I'd like to apply a projector on the first qubit onto state <span class=""math-container"">$|1\rangle$</span> (operator <span class=""math-container"">$|1\rangle\langle 1|$</span>). Meaning that I will be left with <span class=""math-container"">$|1\rangle|1\rangle$</span>.Is it possible to do such thing in the middle, and then apply the rest circuit? Also, is there a way to apply a general nonunitary gate without performing real measurements or qasm, only statevector.</p>
",qc,applying projector general nonunitary gate middle circuit using qiskit p way implement projector gate middle circuit instance assuming bell state span like apply projector first qubit onto state span operator span meaning left span possible thing middle apply rest circuit also way apply general nonunitary gate without performing real measurements qasm,"[(3, 0.12045508), (14, 0.24267034), (17, 0.069698654), (18, 0.5639234)]"
18620,18622.0,2021-07-26 17:57:06,3,186,"<p>Given a fermionic Hamiltonian in a matrix form, we can write it as a sum over Kronecker products of Pauli matrices using the Hilbert-Schmidt inner product. However if the same Hamiltonian is given in a operator form, we can use the Jordan-Wigner transformation to write it as a sum over Kronecker products of Pauli operators.</p>
<p>How can one show that both the methods will give the same result, or if that is not the case then how does one show that the two results are related in some way?</p>
<p>Any material that discusses this is also appreciated.</p>
",Relation between Jordan-Wigner transformation and Hilbert-Schmidt inner product,<hamiltonian-simulation><linear-algebra>,1,0,,,"Relation between Jordan-Wigner transformation and Hilbert-Schmidt inner product <p>Given a fermionic Hamiltonian in a matrix form, we can write it as a sum over Kronecker products of Pauli matrices using the Hilbert-Schmidt inner product. However if the same Hamiltonian is given in a operator form, we can use the Jordan-Wigner transformation to write it as a sum over Kronecker products of Pauli operators.</p>
<p>How can one show that both the methods will give the same result, or if that is not the case then how does one show that the two results are related in some way?</p>
<p>Any material that discusses this is also appreciated.</p>
",qc,relation transformation inner product p given fermionic hamiltonian matrix form write sum kronecker products pauli matrices using inner product however hamiltonian given operator form use transformation write sum kronecker products pauli p one show methods give result case one show two results related way p material discusses also,"[(1, 0.074894786), (3, 0.8102495), (7, 0.0308867), (13, 0.035419174), (17, 0.045435928)]"
18635,18638.0,2021-07-27 16:25:27,3,503,"<p>I have been trying to understand this heralded CNOT gate on photons but I have some questions regarding polarizing beam splitters:</p>
<p><a href=""https://i.sstatic.net/nHx8j.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nHx8j.png"" alt=""circuit"" /></a></p>
<p>The way I understand it, a PBS lets the photon through if the photon is polarized a certain direction, but as I understand it this would squeeze the photon back into a distinct polarization (H/V in the case of the top PBS and D/A in the case of the bottom PBS).  This of course is wrong, but I don't understand how the photon passes through without destroying the superposition. This part is the most confusing part of the circuit but even if the PBS doesn't destroy the superposition how does the PBS2 create the superposition from the target.  What does the operation matrix for a PBS filter look like?  What is a good way to understand them?</p>
",Understanding polarizing beam splitters,<photonics>,1,0,,,"Understanding polarizing beam splitters <p>I have been trying to understand this heralded CNOT gate on photons but I have some questions regarding polarizing beam splitters:</p>
<p><a href=""https://i.sstatic.net/nHx8j.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nHx8j.png"" alt=""circuit"" /></a></p>
<p>The way I understand it, a PBS lets the photon through if the photon is polarized a certain direction, but as I understand it this would squeeze the photon back into a distinct polarization (H/V in the case of the top PBS and D/A in the case of the bottom PBS).  This of course is wrong, but I don't understand how the photon passes through without destroying the superposition. This part is the most confusing part of the circuit but even if the PBS doesn't destroy the superposition how does the PBS2 create the superposition from the target.  What does the operation matrix for a PBS filter look like?  What is a good way to understand them?</p>
",qc,understanding polarizing beam splitters p trying understand heralded cnot gate photons questions regarding polarizing beam splitters p https nofollow noreferrer img https circuit p way understand pbs lets photon photon polarized certain direction understand would squeeze photon back distinct polarization case top pbs case bottom pbs course wrong understand photon passes without destroying superposition part confusing part circuit even pbs destroy superposition pbs2 create superposition target operation matrix pbs filter look like good way understand,"[(3, 0.07783329), (4, 0.1507332), (5, 0.11299326), (8, 0.21166776), (11, 0.012876837), (13, 0.20448804), (14, 0.036713373), (17, 0.013832526), (18, 0.12292878), (19, 0.05456285)]"
20749,20754.0,2021-08-06 04:12:30,2,193,"<p>I encountered the issue that when defining my customized excitation list in the UCC  algorithm, there was only one parameter. How to fix this so that the algorithm assign one parameter for each excitation defined? The code is as follow:</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.drivers import PySCFDriver, UnitsType, QMolecule, FermionicDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock, UCCSD, UCC
from qiskit_nature.transformers import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms.optimizers import L_BFGS_B, SPSA, AQGD, CG, ADAM, P_BFGS, SLSQP, NELDER_MEAD
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.circuit.library import TwoLocal, EfficientSU2
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
matplotlib.use('Agg')


driver = PySCFDriver(atom='H -1.9767, .0, 1.53054; \
                        O  .0, .0, .0; \
                        H 1.9767, .0, 1.53054;',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

at = ActiveSpaceTransformer(8, 5)
ft = FreezeCoreTransformer()

problem = ElectronicStructureProblem(driver, q_molecule_transformers=[ft, at])

# generate the second-quantized operators
second_q_ops = problem.second_q_ops()
main_op = second_q_ops[0]

num_particles = (problem.molecule_data_transformed.num_alpha,
                 problem.molecule_data_transformed.num_beta)

num_spin_orbitals = 2 * problem.molecule_data.num_molecular_orbitals
mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=True)
qubit_op = converter.convert(main_op, num_particles=num_particles)
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
# print(main_op)

def custom_excitation_list(num_spin_orbitals, num_particles):
   my_excitation_list = [((0, 2, 4, 6), (0 ,2, 4, 7), (0,2,5,6))]

   return my_excitation_list

circ = UCC(qubit_converter=converter, num_particles=num_particles, num_spin_orbitals=num_spin_orbitals, excitations=custom_excitation_list,  reps=1, initial_state=init_state)

print(circ.parameters)
<span class=""math-container"">```</span>
</code></pre>
",Define customized excitation for the unitary coupled-cluster (UCC) algorithm in qiskit,<programming><qiskit>,1,0,,,"Define customized excitation for the unitary coupled-cluster (UCC) algorithm in qiskit <p>I encountered the issue that when defining my customized excitation list in the UCC  algorithm, there was only one parameter. How to fix this so that the algorithm assign one parameter for each excitation defined? The code is as follow:</p>
<pre><code>from qiskit import *
import numpy as np

#Operator Imports
from qiskit.opflow import Z, X, I

#Circuit imports
from qiskit_nature.drivers import PySCFDriver, UnitsType, QMolecule, FermionicDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock, UCCSD, UCC
from qiskit_nature.transformers import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms.optimizers import L_BFGS_B, SPSA, AQGD, CG, ADAM, P_BFGS, SLSQP, NELDER_MEAD
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.circuit.library import TwoLocal, EfficientSU2
import matplotlib.pyplot as plt
import matplotlib
from qiskit.tools.visualization import circuit_drawer
matplotlib.use('Agg')


driver = PySCFDriver(atom='H -1.9767, .0, 1.53054; \
                        O  .0, .0, .0; \
                        H 1.9767, .0, 1.53054;',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

at = ActiveSpaceTransformer(8, 5)
ft = FreezeCoreTransformer()

problem = ElectronicStructureProblem(driver, q_molecule_transformers=[ft, at])

# generate the second-quantized operators
second_q_ops = problem.second_q_ops()
main_op = second_q_ops[0]

num_particles = (problem.molecule_data_transformed.num_alpha,
                 problem.molecule_data_transformed.num_beta)

num_spin_orbitals = 2 * problem.molecule_data.num_molecular_orbitals
mapper = JordanWignerMapper()
converter = QubitConverter(mapper=mapper, two_qubit_reduction=True)
qubit_op = converter.convert(main_op, num_particles=num_particles)
init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
# print(main_op)

def custom_excitation_list(num_spin_orbitals, num_particles):
   my_excitation_list = [((0, 2, 4, 6), (0 ,2, 4, 7), (0,2,5,6))]

   return my_excitation_list

circ = UCC(qubit_converter=converter, num_particles=num_particles, num_spin_orbitals=num_spin_orbitals, excitations=custom_excitation_list,  reps=1, initial_state=init_state)

print(circ.parameters)
<span class=""math-container"">```</span>
</code></pre>
",qc,define customized excitation unitary ucc algorithm qiskit p encountered issue defining customized excitation list ucc algorithm one parameter fix algorithm assign one parameter excitation defined code follow pre code qiskit import import numpy np operator imports import z x circuit imports import pyscfdriver unitstype qmolecule fermionicdriver import electronicstructureproblem import hartreefock uccsd ucc import freezecoretransformer activespacetransformer import groundstateeigensolver import eigenstateresult qiskit import aer import paritymapper jordanwignermapper import qubitconverter import spsa aqgd cg adam slsqp import vqe numpyminimumeigensolver import twolocal efficientsu2 import plt import matplotlib import driver pyscfdriver h h activespacetransformer 8 5 ft freezecoretransformer problem electronicstructureproblem driver ft generate operators 0 2 mapper jordanwignermapper converter qubitconverter hartreefock converter print def 0 2 4 6 0 4 7 return circ ucc print span,"[(0, 0.5968216), (2, 0.035492174), (3, 0.01869915), (6, 0.06287249), (8, 0.089778304), (10, 0.018089714), (12, 0.019856391), (14, 0.093794815), (17, 0.06351819)]"
20766,20776.0,2021-08-07 03:54:14,5,1099,"<p>When using <code>numpy</code> or <code>tensorflow</code> in Python, we can simply write</p>
<pre><code>C = A @ B
</code></pre>
<p>for matrix multiplication <code>C = np.matmul(A,B)</code>. I wonder if there is a shorthand for tensor product (Kronecker product), <span class=""math-container"">$C=A\otimes B$</span> . Now I can only do this by using <code>np.kron(A, B)</code>  or using qutip <code>qutip.tensor(A, B)</code></p>
",Python shorthand for tensor product (Kronecker product),<programming><linear-algebra><qutip>,1,0,,,"Python shorthand for tensor product (Kronecker product) <p>When using <code>numpy</code> or <code>tensorflow</code> in Python, we can simply write</p>
<pre><code>C = A @ B
</code></pre>
<p>for matrix multiplication <code>C = np.matmul(A,B)</code>. I wonder if there is a shorthand for tensor product (Kronecker product), <span class=""math-container"">$C=A\otimes B$</span> . Now I can only do this by using <code>np.kron(A, B)</code>  or using qutip <code>qutip.tensor(A, B)</code></p>
",qc,python shorthand tensor product kronecker product p using code numpy code tensorflow python simply write pre code c b p matrix multiplication code c b wonder shorthand tensor product kronecker product span b using code b using qutip code b,"[(0, 0.17649046), (3, 0.30089763), (11, 0.10760782), (14, 0.21838619), (17, 0.13407136), (19, 0.05906268)]"
20782,20847.0,2021-08-08 14:56:39,5,886,"<p>During the same minute as asking this question, I also asked <a href=""https://mattermodeling.stackexchange.com/q/6538/5"">this</a> at Matter Modeling SE.</p>
<p>In Qiskit, each qubit corrrespond to one spin orbital. For example, the <span class=""math-container"">$\text{N}_2$</span> molecule have 10 molecular orbitals, which correspond to 20 spin orbitals for <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> spins in <code>sto-3g</code> basis set. In my opinion, this is the case because the for each atom contained in the molecule, we need to account for the orbitals included, which are <code>1s</code>, <code>2s</code>, <code>2p</code> for the nitrogen atom. However, in this case, how could one deal with the molecular orbitals when one is in the situation as choosing the active space for the molecule?</p>
<p>Take the H2O molecule as an excample, according to the MO diagram <a href=""https://commons.wikimedia.org/wiki/File:H2O-MO-Diagram.svg"" rel=""nofollow noreferrer"">here</a>,  I would like to choose the 3a1 &amp; 1b1 orbital to be not in the active space. In this case, is the qiskit pakage (more specifically the PySCF driver) arrange the orbitals according to the MO orbitals so that I can just specify a list like [0,1,4,5] to be the active MO space assume that the organization is from down to up in this case?</p>
",Molecular orbitals in Qiskit,<qiskit><chemistry>,1,1,,,"Molecular orbitals in Qiskit <p>During the same minute as asking this question, I also asked <a href=""https://mattermodeling.stackexchange.com/q/6538/5"">this</a> at Matter Modeling SE.</p>
<p>In Qiskit, each qubit corrrespond to one spin orbital. For example, the <span class=""math-container"">$\text{N}_2$</span> molecule have 10 molecular orbitals, which correspond to 20 spin orbitals for <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> spins in <code>sto-3g</code> basis set. In my opinion, this is the case because the for each atom contained in the molecule, we need to account for the orbitals included, which are <code>1s</code>, <code>2s</code>, <code>2p</code> for the nitrogen atom. However, in this case, how could one deal with the molecular orbitals when one is in the situation as choosing the active space for the molecule?</p>
<p>Take the H2O molecule as an excample, according to the MO diagram <a href=""https://commons.wikimedia.org/wiki/File:H2O-MO-Diagram.svg"" rel=""nofollow noreferrer"">here</a>,  I would like to choose the 3a1 &amp; 1b1 orbital to be not in the active space. In this case, is the qiskit pakage (more specifically the PySCF driver) arrange the orbitals according to the MO orbitals so that I can just specify a list like [0,1,4,5] to be the active MO space assume that the organization is from down to up in this case?</p>
",qc,molecular orbitals qiskit p minute asking question also asked https matter modeling p qiskit qubit corrrespond one spin orbital example span n molecule 10 molecular orbitals correspond 20 spin orbitals span span spins code basis set opinion case atom contained molecule need account orbitals included code 1s code 2s code 2p nitrogen atom however case could one deal molecular orbitals one situation choosing active space molecule p take h2o molecule excample according mo diagram https nofollow noreferrer would like choose 3a1 amp 1b1 orbital active space case qiskit pakage specifically pyscf driver arrange orbitals according mo orbitals specify list like active mo space assume organization case,"[(3, 0.16744918), (4, 0.20008607), (7, 0.030957077), (8, 0.34356356), (12, 0.010207802), (14, 0.13577732), (15, 0.013627889), (17, 0.09706891)]"
20796,,2021-08-09 12:06:49,0,262,"<p>I want to use historical data for 5 stocks from YahooFinance and then calculate mean vector and covariance matrice, so I can optimize them with QAOA. Anyone know what is wrong with this code:
<a href=""https://i.sstatic.net/IFarj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IFarj.png"" alt=""enter image description here"" /></a></p>
","How to use historical data from YahooFinance, calculate mean vector and covariance matrices, so I can optimize them with QAOA?",<programming><qaoa>,1,2,,,"How to use historical data from YahooFinance, calculate mean vector and covariance matrices, so I can optimize them with QAOA? <p>I want to use historical data for 5 stocks from YahooFinance and then calculate mean vector and covariance matrice, so I can optimize them with QAOA. Anyone know what is wrong with this code:
<a href=""https://i.sstatic.net/IFarj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IFarj.png"" alt=""enter image description here"" /></a></p>
",qc,use historical data yahoofinance calculate mean vector covariance matrices optimize qaoa p want use historical data 5 stocks yahoofinance calculate mean vector covariance matrice optimize qaoa anyone know wrong code https nofollow noreferrer img https enter image description,"[(0, 0.34078994), (4, 0.49543077), (11, 0.0352473), (16, 0.09062503), (17, 0.03364384)]"
20814,,2021-08-11 12:47:08,2,168,"<p>As a computer memory is finite, it seems reasonable to assume that a rotational angle of gates <span class=""math-container"">$Rx$</span>, <span class=""math-container"">$Ry$</span> and <span class=""math-container"">$Rz$</span> (and <span class=""math-container"">$U1$</span>, <span class=""math-container"">$U2$</span> and <span class=""math-container"">$U3$</span> gates as well) has some smallest step which can be distinguished (e.g. in change of an outcome probability distribution). I would also expect that on a simulator, the step is smaller than on a real quantum processor because the processors are still far from an ideal.</p>
<p>So, my question is what is the minimum step in the rotational angle which can be distinguished on IBM Quantum processors? Is the step on simulator smaller than on a real quantum processor?</p>
<p>Any reference do paper or link is appreciated.</p>
",Accuracy of rotational gates on IBM Quantum,<quantum-gate><simulation>,0,4,,,"Accuracy of rotational gates on IBM Quantum <p>As a computer memory is finite, it seems reasonable to assume that a rotational angle of gates <span class=""math-container"">$Rx$</span>, <span class=""math-container"">$Ry$</span> and <span class=""math-container"">$Rz$</span> (and <span class=""math-container"">$U1$</span>, <span class=""math-container"">$U2$</span> and <span class=""math-container"">$U3$</span> gates as well) has some smallest step which can be distinguished (e.g. in change of an outcome probability distribution). I would also expect that on a simulator, the step is smaller than on a real quantum processor because the processors are still far from an ideal.</p>
<p>So, my question is what is the minimum step in the rotational angle which can be distinguished on IBM Quantum processors? Is the step on simulator smaller than on a real quantum processor?</p>
<p>Any reference do paper or link is appreciated.</p>
",qc,accuracy rotational gates ibm quantum p computer memory finite seems reasonable assume rotational angle gates span rx span ry span rz span u1 span u2 span u3 gates well smallest step distinguished change outcome probability distribution would also expect simulator step smaller real quantum processor processors still far p question minimum step rotational angle distinguished ibm quantum processors step simulator smaller real quantum processor p reference paper link,"[(3, 0.20531799), (8, 0.4006425), (9, 0.2041555), (11, 0.0128036775), (14, 0.13104615), (17, 0.043980226)]"
20844,,2021-08-15 18:31:15,4,85,"<p>I have a database of classical codes with simulation results in binary symmetric channel (BSC).</p>
<p>The codes are defined by their parity check matrices <span class=""math-container"">$H$</span>. I can pick pairs of codes and call them <span class=""math-container"">$H_x$</span> and <span class=""math-container"">$H_z$</span>; if <span class=""math-container"">$H_x H_z^T=0$</span> then these two classical codes define a quantum CSS code.</p>
<p>I already have the simulation results in this form : for every BSC crossover probability <span class=""math-container"">$p_{\text{BSC}}$</span> I have the probability that the decoded codeword is in the classical codespace or not; this is just checking the decoded word syndrome : if <span class=""math-container"">$r$</span>=decoded(codeword + BSC noise) then I have the probability of <span class=""math-container"">$P_x = P(r H_x^T \neq 0)$</span> and <span class=""math-container"">$P_z=P(r H_z^T \neq 0)$</span>.</p>
<p>So now I have two functions <span class=""math-container"">$P_x(p_{BSC})$</span> and <span class=""math-container"">$P_z(p_{BSC})$</span>. I should be able to translate these two curves to the performance of the quantum CSS code but I'm finding it much harder than it should be. A lot of papers are not precise enough about what they mean by &quot;physical failure rate&quot; <span class=""math-container"">$p_{fail}$</span> or &quot;logical error rate&quot; <span class=""math-container"">$p_L$</span>; so it's hard to compare against published results. We can pick the depolarizing channel for the quantum code to make things more concrete. If I can translate <span class=""math-container"">$p_{BSC}, P_x, P_z$</span> to <span class=""math-container"">$p_{fail}, p_L$</span> then I can calculate the quantum code threshold by solving for <span class=""math-container"">$p_{fail}=p_L$</span>.</p>
",How to translate performance of two classical codes to a quantum CSS code?,<error-correction><information-theory><stabilizer-code>,0,0,,,"How to translate performance of two classical codes to a quantum CSS code? <p>I have a database of classical codes with simulation results in binary symmetric channel (BSC).</p>
<p>The codes are defined by their parity check matrices <span class=""math-container"">$H$</span>. I can pick pairs of codes and call them <span class=""math-container"">$H_x$</span> and <span class=""math-container"">$H_z$</span>; if <span class=""math-container"">$H_x H_z^T=0$</span> then these two classical codes define a quantum CSS code.</p>
<p>I already have the simulation results in this form : for every BSC crossover probability <span class=""math-container"">$p_{\text{BSC}}$</span> I have the probability that the decoded codeword is in the classical codespace or not; this is just checking the decoded word syndrome : if <span class=""math-container"">$r$</span>=decoded(codeword + BSC noise) then I have the probability of <span class=""math-container"">$P_x = P(r H_x^T \neq 0)$</span> and <span class=""math-container"">$P_z=P(r H_z^T \neq 0)$</span>.</p>
<p>So now I have two functions <span class=""math-container"">$P_x(p_{BSC})$</span> and <span class=""math-container"">$P_z(p_{BSC})$</span>. I should be able to translate these two curves to the performance of the quantum CSS code but I'm finding it much harder than it should be. A lot of papers are not precise enough about what they mean by &quot;physical failure rate&quot; <span class=""math-container"">$p_{fail}$</span> or &quot;logical error rate&quot; <span class=""math-container"">$p_L$</span>; so it's hard to compare against published results. We can pick the depolarizing channel for the quantum code to make things more concrete. If I can translate <span class=""math-container"">$p_{BSC}, P_x, P_z$</span> to <span class=""math-container"">$p_{fail}, p_L$</span> then I can calculate the quantum code threshold by solving for <span class=""math-container"">$p_{fail}=p_L$</span>.</p>
",qc,translate performance two classical codes quantum css code p database classical codes simulation results binary symmetric channel bsc p codes defined parity check matrices span h pick pairs codes call span span span two classical codes define quantum css p already simulation results form every bsc crossover probability span bsc probability decoded codeword classical codespace checking decoded word syndrome span r codeword bsc noise probability span p r 0 span r 0 p two functions span bsc span bsc able translate two curves performance quantum css code finding much harder lot papers precise enough mean quot physical failure rate quot span fail quot logical error rate quot span hard compare published results pick depolarizing channel quantum code make things concrete translate span bsc span fail calculate quantum code threshold solving span fail,"[(1, 0.108027734), (2, 0.01690428), (3, 0.34788284), (5, 0.3221811), (7, 0.022267634), (8, 0.10203663), (13, 0.024711352), (17, 0.013473806), (19, 0.041635573)]"
20871,,2021-08-18 16:58:49,12,1296,"<p>Consider a quantum map <span class=""math-container"">$\Phi\in\mathrm T(\mathcal X)$</span>, that is, a linear operator <span class=""math-container"">$\Phi:\mathrm{Lin}(\mathcal X)\to\mathrm{Lin}(\mathcal X)$</span> for some finite-dimensional complex vector spaces <span class=""math-container"">$\mathcal X$</span>.</p>
<p>In the specific case in which <span class=""math-container"">$\Phi$</span> is also completely positive and trace-preserving, we call it a <em>quantum channel</em>. One can show that a quantum channel is <em>reversible</em>, in the sense of there being another quantum channel <span class=""math-container"">$\Psi\in\mathrm T(\mathcal X)$</span> such that <span class=""math-container"">$\Phi\circ\Psi=\Psi\circ\Phi=\mathrm{Id}_{\cal X}$</span>, <em>iff</em> it is a unitary/isometric channel, meaning <span class=""math-container"">$\Phi(X)=UXU^\dagger$</span> for some isometry <span class=""math-container"">$U:\mathcal X\to\mathcal X$</span>.</p>
<p>More generally, I'll call a quantum map <em>invertible</em> if there is some other map <span class=""math-container"">$\Psi$</span> such that <span class=""math-container"">$\Phi\circ\Psi=\Psi\circ\Phi=\mathrm{Id}_{\cal X}$</span>. The difference compared to the previous definition is that we don't impose further constraints on the inverse. In particular, <span class=""math-container"">$\Phi$</span> might be invertible, but its inverse not be a channel.
Consider for example channels of the form
<span class=""math-container"">$$\Phi_p(X)=p X + (1-p) \operatorname{Tr}(X)\frac{I_{\cal X}}{\dim\mathcal X}.$$</span>
These can be written, with respect to an arbitrary orthogonal basis <span class=""math-container"">$\{\sigma_j\}_j\subset\mathrm{Herm}(\mathcal X)$</span> with <span class=""math-container"">$\operatorname{Tr}(\sigma_i\sigma_j)=\dim(\mathcal X)\delta_{ij}$</span>,
<span class=""math-container"">$$\langle\sigma_i,\Phi_p(\sigma_j)\rangle = p \delta_{ij} + (1-p).$$</span>
One can thus see that <span class=""math-container"">$\Phi_p$</span>, as a linear map, has <span class=""math-container"">$\det(\Phi_p)=p^{d-1}(d-(d-1)p)$</span>, with <span class=""math-container"">$d\equiv \dim(\mathcal X)$</span>, and is thus invertible for all <span class=""math-container"">$p\neq0,\frac{d}{d-1}$</span> (although it is obviously not a channel unless <span class=""math-container"">$0\le p\le 1$</span>).
Its inverse is
<span class=""math-container"">$$\Phi_p^{-1}(Y) = \left(\frac{p-1}{p}\right)\operatorname{Tr}(Y) \frac{I_{\mathcal X}}{\dim(\mathcal X)} + \frac{Y}{p}.$$</span>
However, <span class=""math-container"">$\Phi_p^{-1}$</span> is not a channel for <span class=""math-container"">$p\in(0,1]$</span>.</p>
<p>Is there a general way to predict the invertibility of a quantum map, for example based on its Kraus or Choi representations? Clearly, a naive way is to just write the linear map as a matrix in some basis and compute its determinant, but does this somehow translate nicely into some property in Choi or Kraus (or other) representations?
For a general (not CPTP) map, by &quot;Kraus representation&quot; I mean a decomposition of the form <span class=""math-container"">$\Phi(X)=\sum_a A_a X B_a^\dagger$</span> for some linear operators <span class=""math-container"">$A_a:\mathcal X\to\mathcal X$</span> and <span class=""math-container"">$B_a:\mathcal X\to\mathcal X$</span>.</p>
<p>I suppose the question thus boils down to the following: given <span class=""math-container"">$\Phi(X)=\sum_a A_a X B_a^\dagger$</span>, is there a nice enough way to write <span class=""math-container"">$\det(K(\Phi))$</span>? Here <span class=""math-container"">$K(\Phi):\mathcal X\otimes\mathcal X\to\mathcal X\otimes\mathcal X$</span> is the <em>natural representation</em> of the channel, which can be seen to be writable as
<span class=""math-container"">$$K(\Phi) = \sum_a A_a\otimes \bar B_a.$$</span></p>
",How does the invertibility of a quantum map reflect on its Kraus operators?,<quantum-operation><kraus-representation>,1,13,,,"How does the invertibility of a quantum map reflect on its Kraus operators? <p>Consider a quantum map <span class=""math-container"">$\Phi\in\mathrm T(\mathcal X)$</span>, that is, a linear operator <span class=""math-container"">$\Phi:\mathrm{Lin}(\mathcal X)\to\mathrm{Lin}(\mathcal X)$</span> for some finite-dimensional complex vector spaces <span class=""math-container"">$\mathcal X$</span>.</p>
<p>In the specific case in which <span class=""math-container"">$\Phi$</span> is also completely positive and trace-preserving, we call it a <em>quantum channel</em>. One can show that a quantum channel is <em>reversible</em>, in the sense of there being another quantum channel <span class=""math-container"">$\Psi\in\mathrm T(\mathcal X)$</span> such that <span class=""math-container"">$\Phi\circ\Psi=\Psi\circ\Phi=\mathrm{Id}_{\cal X}$</span>, <em>iff</em> it is a unitary/isometric channel, meaning <span class=""math-container"">$\Phi(X)=UXU^\dagger$</span> for some isometry <span class=""math-container"">$U:\mathcal X\to\mathcal X$</span>.</p>
<p>More generally, I'll call a quantum map <em>invertible</em> if there is some other map <span class=""math-container"">$\Psi$</span> such that <span class=""math-container"">$\Phi\circ\Psi=\Psi\circ\Phi=\mathrm{Id}_{\cal X}$</span>. The difference compared to the previous definition is that we don't impose further constraints on the inverse. In particular, <span class=""math-container"">$\Phi$</span> might be invertible, but its inverse not be a channel.
Consider for example channels of the form
<span class=""math-container"">$$\Phi_p(X)=p X + (1-p) \operatorname{Tr}(X)\frac{I_{\cal X}}{\dim\mathcal X}.$$</span>
These can be written, with respect to an arbitrary orthogonal basis <span class=""math-container"">$\{\sigma_j\}_j\subset\mathrm{Herm}(\mathcal X)$</span> with <span class=""math-container"">$\operatorname{Tr}(\sigma_i\sigma_j)=\dim(\mathcal X)\delta_{ij}$</span>,
<span class=""math-container"">$$\langle\sigma_i,\Phi_p(\sigma_j)\rangle = p \delta_{ij} + (1-p).$$</span>
One can thus see that <span class=""math-container"">$\Phi_p$</span>, as a linear map, has <span class=""math-container"">$\det(\Phi_p)=p^{d-1}(d-(d-1)p)$</span>, with <span class=""math-container"">$d\equiv \dim(\mathcal X)$</span>, and is thus invertible for all <span class=""math-container"">$p\neq0,\frac{d}{d-1}$</span> (although it is obviously not a channel unless <span class=""math-container"">$0\le p\le 1$</span>).
Its inverse is
<span class=""math-container"">$$\Phi_p^{-1}(Y) = \left(\frac{p-1}{p}\right)\operatorname{Tr}(Y) \frac{I_{\mathcal X}}{\dim(\mathcal X)} + \frac{Y}{p}.$$</span>
However, <span class=""math-container"">$\Phi_p^{-1}$</span> is not a channel for <span class=""math-container"">$p\in(0,1]$</span>.</p>
<p>Is there a general way to predict the invertibility of a quantum map, for example based on its Kraus or Choi representations? Clearly, a naive way is to just write the linear map as a matrix in some basis and compute its determinant, but does this somehow translate nicely into some property in Choi or Kraus (or other) representations?
For a general (not CPTP) map, by &quot;Kraus representation&quot; I mean a decomposition of the form <span class=""math-container"">$\Phi(X)=\sum_a A_a X B_a^\dagger$</span> for some linear operators <span class=""math-container"">$A_a:\mathcal X\to\mathcal X$</span> and <span class=""math-container"">$B_a:\mathcal X\to\mathcal X$</span>.</p>
<p>I suppose the question thus boils down to the following: given <span class=""math-container"">$\Phi(X)=\sum_a A_a X B_a^\dagger$</span>, is there a nice enough way to write <span class=""math-container"">$\det(K(\Phi))$</span>? Here <span class=""math-container"">$K(\Phi):\mathcal X\otimes\mathcal X\to\mathcal X\otimes\mathcal X$</span> is the <em>natural representation</em> of the channel, which can be seen to be writable as
<span class=""math-container"">$$K(\Phi) = \sum_a A_a\otimes \bar B_a.$$</span></p>
",qc,invertibility quantum map reflect kraus operators p consider quantum map span x linear operator span lin x lin x complex vector spaces span x p specific case span also completely positive call em quantum channel one show quantum channel em reversible sense another quantum channel span x span id x em iff channel meaning span x isometry span u x p generally call quantum map em invertible map span span id x difference compared previous definition impose constraints inverse particular span might invertible inverse channel consider example channels form span x x tr x x x written respect arbitrary orthogonal basis span herm x span tr x ij span p ij one thus see span linear map span p span x thus invertible span although obviously channel unless span 1 inverse span p tr x x p however span channel span p general way predict invertibility quantum map example based kraus choi representations clearly naive way write linear map matrix basis compute determinant somehow translate nicely property choi kraus representations general cptp map quot kraus representation quot mean decomposition form span x x linear operators span x span x p suppose question thus boils following given span x x nice enough way write span k span k x em natural representation channel seen writable span k,"[(3, 0.7796849), (10, 0.13965845), (11, 0.049291), (17, 0.017094221), (19, 0.01356435)]"
20896,20905.0,2021-08-20 15:56:45,6,180,"<p>The Weyl basis (also known as Weyl-Heisenberg) is an orthonormal, unitary, and non-Hermitian basis for the Hilbert space of dimension <span class=""math-container"">$d$</span>. The basis elements are given by
<span class=""math-container"">$$ U_{ab} = \sqrt{\omega^{ab}}X^aZ^b, $$</span>
where <span class=""math-container"">$X,Z$</span> are the shift and clock matrices and <span class=""math-container"">$\omega = e^{i2\pi/d}$</span>. I'm wondering whether for all <span class=""math-container"">$d$</span> there exists a pure state <span class=""math-container"">$|\psi\rangle$</span> such that <span class=""math-container"">$|\langle\psi| U_{ab}|\psi\rangle|$</span> is constant (except of course for <span class=""math-container"">$U_{00}$</span>).</p>
<p>Expanding the hypothetical state in this basis,
<span class=""math-container"">$$|\psi\rangle\langle\psi| = \frac1d \sum_{ab} \alpha_{a,b} U_{ab},$$</span>
we see that demanding it to be Hermitian translates to <span class=""math-container"">$\alpha_{a,b}\alpha_{-a,-b} = 1$</span> (note that these coefficients are in general complex), have trace one results in <span class=""math-container"">$\alpha_{0,0} = 1$</span>, and have trace squared equal one results in <span class=""math-container"">$|\alpha_{a,b}| = 1/\sqrt{d+1}$</span> for all other <span class=""math-container"">$a,b$</span>.</p>
<p>Simply setting <span class=""math-container"">$\alpha_{a,b} = 1/\sqrt{d+1}$</span> does give me the desired state for <span class=""math-container"">$d=2$</span> and <span class=""math-container"">$d=3$</span>, but doesn't work for higher dimensions, negative eigenvalues show up. It's easy enough to find the state numerically for higher <span class=""math-container"">$d$</span>, so I guess it always exists, but I can't find a good method to calculate the coefficients analytically. Also, it seems a natural question to ask, but I couldn't find anything about it in the literature.</p>
",Uniformly distributed state in the Weyl basis,<quantum-state>,1,2,,,"Uniformly distributed state in the Weyl basis <p>The Weyl basis (also known as Weyl-Heisenberg) is an orthonormal, unitary, and non-Hermitian basis for the Hilbert space of dimension <span class=""math-container"">$d$</span>. The basis elements are given by
<span class=""math-container"">$$ U_{ab} = \sqrt{\omega^{ab}}X^aZ^b, $$</span>
where <span class=""math-container"">$X,Z$</span> are the shift and clock matrices and <span class=""math-container"">$\omega = e^{i2\pi/d}$</span>. I'm wondering whether for all <span class=""math-container"">$d$</span> there exists a pure state <span class=""math-container"">$|\psi\rangle$</span> such that <span class=""math-container"">$|\langle\psi| U_{ab}|\psi\rangle|$</span> is constant (except of course for <span class=""math-container"">$U_{00}$</span>).</p>
<p>Expanding the hypothetical state in this basis,
<span class=""math-container"">$$|\psi\rangle\langle\psi| = \frac1d \sum_{ab} \alpha_{a,b} U_{ab},$$</span>
we see that demanding it to be Hermitian translates to <span class=""math-container"">$\alpha_{a,b}\alpha_{-a,-b} = 1$</span> (note that these coefficients are in general complex), have trace one results in <span class=""math-container"">$\alpha_{0,0} = 1$</span>, and have trace squared equal one results in <span class=""math-container"">$|\alpha_{a,b}| = 1/\sqrt{d+1}$</span> for all other <span class=""math-container"">$a,b$</span>.</p>
<p>Simply setting <span class=""math-container"">$\alpha_{a,b} = 1/\sqrt{d+1}$</span> does give me the desired state for <span class=""math-container"">$d=2$</span> and <span class=""math-container"">$d=3$</span>, but doesn't work for higher dimensions, negative eigenvalues show up. It's easy enough to find the state numerically for higher <span class=""math-container"">$d$</span>, so I guess it always exists, but I can't find a good method to calculate the coefficients analytically. Also, it seems a natural question to ask, but I couldn't find anything about it in the literature.</p>
",qc,uniformly distributed state weyl basis p weyl basis also known orthonormal unitary basis hilbert space dimension span basis elements given span ab ab span x z shift clock matrices span wondering whether span exists pure state span span ab constant except course span 00 p expanding hypothetical state basis span ab b ab see demanding hermitian translates span b 1 note coefficients general complex trace one results span 1 trace squared equal one results span b span b p simply setting span b give desired state span span work higher dimensions negative eigenvalues show easy enough find state numerically higher span guess always exists ca find good method calculate coefficients analytically also seems natural question ask could find anything,"[(3, 0.9465266), (10, 0.014719364), (17, 0.037290562)]"
20904,20938.0,2021-08-21 15:38:39,0,132,"<p>I have followed the instructions to install Q# using conda as recommended, and given by MS. When I try to import <code>qsharp</code> from my virtual env within a Python program, I get the following error:</p>
<pre><code>Microsoft.Quantum.IQSharp.Workspace[0] QS5022: No identifier with the name “v” exists.
</code></pre>
<p>Does any one have experience of this issue please?  I have googled it but to no avail.</p>
<p>I use .NET run perfectly with <code>example.qs</code> and <code>example.csproj</code> files, but I would like to work within VSCode.
(Ubuntu v. 20.04, .NET SDK v. 3.1, Python v. 3.7 + latest Miniconda)</p>
",Q# install issue,<programming><q#>,1,0,,,"Q# install issue <p>I have followed the instructions to install Q# using conda as recommended, and given by MS. When I try to import <code>qsharp</code> from my virtual env within a Python program, I get the following error:</p>
<pre><code>Microsoft.Quantum.IQSharp.Workspace[0] QS5022: No identifier with the name “v” exists.
</code></pre>
<p>Does any one have experience of this issue please?  I have googled it but to no avail.</p>
<p>I use .NET run perfectly with <code>example.qs</code> and <code>example.csproj</code> files, but I would like to work within VSCode.
(Ubuntu v. 20.04, .NET SDK v. 3.1, Python v. 3.7 + latest Miniconda)</p>
",qc,q install issue p followed instructions install q using conda recommended given try import code qsharp virtual env within python program get following error pre code 0 qs5022 identifier name v exists p one experience issue please googled p use run perfectly code code files would like work within vscode ubuntu sdk python latest miniconda,"[(0, 0.31241533), (8, 0.047957618), (10, 0.031744406), (13, 0.030073375), (14, 0.55479443), (17, 0.020276949)]"
20970,,2021-08-25 16:42:37,1,254,"<p>As the name suggests, an <a href=""https://arxiv.org/pdf/quant-ph/0302031.pdf"" rel=""nofollow noreferrer"">entanglement breaking channel</a> <span class=""math-container"">$\Phi$</span> is such that <span class=""math-container"">$(Id \otimes \Phi)[\rho]$</span> is always separable, even when <span class=""math-container"">$\rho$</span> is entangled. Won't such channels be useless, as they destroy entanglement? Does it make sense to say a channel that is more &quot;entanglement breaking&quot; is more useless?</p>
",Are entanglement breaking channels of any use?,<entanglement-breaking-channels>,1,1,,,"Are entanglement breaking channels of any use? <p>As the name suggests, an <a href=""https://arxiv.org/pdf/quant-ph/0302031.pdf"" rel=""nofollow noreferrer"">entanglement breaking channel</a> <span class=""math-container"">$\Phi$</span> is such that <span class=""math-container"">$(Id \otimes \Phi)[\rho]$</span> is always separable, even when <span class=""math-container"">$\rho$</span> is entangled. Won't such channels be useless, as they destroy entanglement? Does it make sense to say a channel that is more &quot;entanglement breaking&quot; is more useless?</p>
",qc,entanglement breaking channels use p name suggests https nofollow noreferrer entanglement breaking channel span span id always separable even span entangled wo channels useless destroy entanglement make sense say channel quot entanglement breaking quot useless,"[(3, 0.34974793), (4, 0.10332058), (14, 0.12688941), (17, 0.033931535), (18, 0.2960127), (19, 0.08611722)]"
21004,21005.0,2021-08-29 05:05:11,2,93,"<p>I was hoping someone can explain to me how to get -1 and 1 for a 2-qubit VQE with <span class=""math-container"">$\langle XY\rangle$</span>, since we have 4 states <span class=""math-container"">$|00\rangle,|01\rangle,|10\rangle,|11\rangle$</span>? For the case of 1 qubit, it is straightforward that <span class=""math-container"">$|0\rangle$</span> is 1, and <span class=""math-container"">$|1\rangle$</span> is -1.</p>
",How to know state corresponding to -1 or 1 for multi qubits VQE?,<vqe>,1,2,,,"How to know state corresponding to -1 or 1 for multi qubits VQE? <p>I was hoping someone can explain to me how to get -1 and 1 for a 2-qubit VQE with <span class=""math-container"">$\langle XY\rangle$</span>, since we have 4 states <span class=""math-container"">$|00\rangle,|01\rangle,|10\rangle,|11\rangle$</span>? For the case of 1 qubit, it is straightforward that <span class=""math-container"">$|0\rangle$</span> is 1, and <span class=""math-container"">$|1\rangle$</span> is -1.</p>
",qc,know state corresponding 1 multi qubits vqe p hoping someone explain get 1 vqe span since 4 states span case 1 qubit straightforward span 1 span,"[(2, 0.1858185), (3, 0.47205546), (17, 0.09194895), (18, 0.2440683)]"
21007,,2021-08-29 07:18:50,2,107,"<p>I am going through LiH ground state energy calculation. I would like to know how to save the output file in Qiskit as one would do in classical computing using software like Gaussian or Psi4.</p>
<p>Can someone please help?</p>
","Save output, wavefunction file and orbital information in Qiskit",<qiskit><vqe><optimization><chemistry>,0,0,,,"Save output, wavefunction file and orbital information in Qiskit <p>I am going through LiH ground state energy calculation. I would like to know how to save the output file in Qiskit as one would do in classical computing using software like Gaussian or Psi4.</p>
<p>Can someone please help?</p>
",qc,save output wavefunction file orbital information qiskit p going lih ground state energy calculation would like know save output file qiskit one would classical computing using software like gaussian p someone please help,"[(1, 0.17589377), (8, 0.23691767), (14, 0.53810006), (17, 0.04426806)]"
21105,,2021-09-07 19:49:36,1,55,"<p>The number of T-gates in quantum search reaches <span class=""math-container"">$O(2^{m/2} \cdot\text{poly}(m))$</span>, which is beyond the capability of CHE-based QHE schemes.</p>
<p>But is it the same case for other bilnd QC protocols?  and What is the computational complexity limitation of the remote state preparation protocols that enable a fully classical client to delegate a computation to an untrusted quantum server securely?</p>
",What is the computational complexity limitation of classical client delegated quantum computing CCDQC protocols?,<cryptography><blind-quantum-computing>,0,0,,,"What is the computational complexity limitation of classical client delegated quantum computing CCDQC protocols? <p>The number of T-gates in quantum search reaches <span class=""math-container"">$O(2^{m/2} \cdot\text{poly}(m))$</span>, which is beyond the capability of CHE-based QHE schemes.</p>
<p>But is it the same case for other bilnd QC protocols?  and What is the computational complexity limitation of the remote state preparation protocols that enable a fully classical client to delegate a computation to an untrusted quantum server securely?</p>
",qc,computational complexity limitation classical client delegated quantum computing ccdqc protocols p number quantum search reaches span poly beyond capability qhe p case bilnd qc protocols computational complexity limitation remote state preparation protocols enable fully classical client delegate computation untrusted quantum server securely,"[(1, 0.13999784), (3, 0.048385326), (7, 0.15720505), (8, 0.42086375), (13, 0.17019556), (17, 0.059256263)]"
21111,21125.0,2021-09-08 14:55:31,2,135,"<p>Is it correct to say that for an <span class=""math-container"">$n$</span>-qubit system,  we can clone all kinds of pure non-entangled states, without violating the no-cloning theorem?</p>
<p>That is, is the correct interpretation for the proof of cloning theorem shown <a href=""https://en.wikipedia.org/wiki/No-cloning_theorem"" rel=""nofollow noreferrer"">here</a>, to be that if such a cloning operator <span class=""math-container"">$U$</span> exists, such an operator <span class=""math-container"">$U$</span> would not be a linear operator, but nonetheless <span class=""math-container"">$U$</span> can still act on only non-entangled, mutually orthogonal states?</p>
<p>Entangled linear superpositions of those states in the set are not included instead, because then <span class=""math-container"">$U$</span> would not be a linear operator.</p>
<p>Thank you for your help!</p>
",Can all kinds of pure non-entangled states be cloned?,<no-cloning-theorem>,1,6,,,"Can all kinds of pure non-entangled states be cloned? <p>Is it correct to say that for an <span class=""math-container"">$n$</span>-qubit system,  we can clone all kinds of pure non-entangled states, without violating the no-cloning theorem?</p>
<p>That is, is the correct interpretation for the proof of cloning theorem shown <a href=""https://en.wikipedia.org/wiki/No-cloning_theorem"" rel=""nofollow noreferrer"">here</a>, to be that if such a cloning operator <span class=""math-container"">$U$</span> exists, such an operator <span class=""math-container"">$U$</span> would not be a linear operator, but nonetheless <span class=""math-container"">$U$</span> can still act on only non-entangled, mutually orthogonal states?</p>
<p>Entangled linear superpositions of those states in the set are not included instead, because then <span class=""math-container"">$U$</span> would not be a linear operator.</p>
<p>Thank you for your help!</p>
",qc,kinds pure states cloned p correct say span n system clone kinds pure states without violating theorem p correct interpretation proof cloning theorem shown https nofollow noreferrer cloning operator span u exists operator span u would linear operator nonetheless span u still act mutually orthogonal states p entangled linear superpositions states set included instead span u would linear p thank help,"[(3, 0.72968215), (9, 0.16814356), (17, 0.06404602), (18, 0.035512734)]"
21118,21120.0,2021-09-09 04:07:34,3,194,"<p><strong>Definition of distance <span class=""math-container"">$d$</span>:</strong></p>
<p><span class=""math-container"">$d$</span> of <span class=""math-container"">$T(S)$</span> is the weight of the smallest Pauli operator <span class=""math-container"">$N$</span> in <span class=""math-container"">$N(S)$</span> \ <span class=""math-container"">$S$</span>.
<span class=""math-container"">$S$</span> is the stabilizer, <span class=""math-container"">$T(S)$</span> is the corresponding QECC, and <span class=""math-container"">$N(S)$</span> are all errors commute with elements in S.</p>
<p><strong>I am confused about this definition, especially about the &quot;weight&quot;.</strong></p>
<p>I'd really appreciate it if someone could help clarify it!</p>
",Definition of distance d of the QECC $T(S)$,<error-correction>,1,0,,,"Definition of distance d of the QECC $T(S)$ <p><strong>Definition of distance <span class=""math-container"">$d$</span>:</strong></p>
<p><span class=""math-container"">$d$</span> of <span class=""math-container"">$T(S)$</span> is the weight of the smallest Pauli operator <span class=""math-container"">$N$</span> in <span class=""math-container"">$N(S)$</span> \ <span class=""math-container"">$S$</span>.
<span class=""math-container"">$S$</span> is the stabilizer, <span class=""math-container"">$T(S)$</span> is the corresponding QECC, and <span class=""math-container"">$N(S)$</span> are all errors commute with elements in S.</p>
<p><strong>I am confused about this definition, especially about the &quot;weight&quot;.</strong></p>
<p>I'd really appreciate it if someone could help clarify it!</p>
",qc,definition distance qecc p strong definition distance span p span span weight smallest pauli operator span n span n span span stabilizer span corresponding qecc span n errors commute elements p strong confused definition especially quot weight quot p really appreciate someone could help clarify,"[(3, 0.70710456), (5, 0.1882672), (17, 0.05315599), (19, 0.047931783)]"
21157,,2021-09-11 16:20:11,6,130,"<p>Is there a way in Qiskit to write my circuit using only Clifford and T gates (CX, S, H, T and I think also <span class=""math-container"">$S^\dagger$</span> and <span class=""math-container"">$T^\dagger$</span>)? With the function compile (with aer simulator) it gives me some errors using that one as a basis. I found the function <code>SolovayKitaevDecomposition</code> that seems to work only if there is a compile with u1, u2, u3, and CX beforehand. However, I can't find any documentation about it so I'm not sure how to use it, and compile and SKD take a lot of time.</p>

",Writing circuits in Qiskit using only Clifford and T gates,<qiskit><quantum-gate><quantum-circuit><clifford-group><transpile>,0,5,,,"Writing circuits in Qiskit using only Clifford and T gates <p>Is there a way in Qiskit to write my circuit using only Clifford and T gates (CX, S, H, T and I think also <span class=""math-container"">$S^\dagger$</span> and <span class=""math-container"">$T^\dagger$</span>)? With the function compile (with aer simulator) it gives me some errors using that one as a basis. I found the function <code>SolovayKitaevDecomposition</code> that seems to work only if there is a compile with u1, u2, u3, and CX beforehand. However, I can't find any documentation about it so I'm not sure how to use it, and compile and SKD take a lot of time.</p>

",qc,writing circuits qiskit using clifford gates p way qiskit write circuit using clifford gates cx h think also span span function compile aer simulator gives errors using one basis found function code solovaykitaevdecomposition seems work compile u1 u2 u3 cx beforehand however ca find documentation sure use compile skd take lot,"[(3, 0.07850602), (6, 0.026434395), (14, 0.82534754), (17, 0.06645949)]"
21221,,2021-09-16 11:46:29,1,262,"<p><strong>1.</strong>  On page 73 of <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/TQI.pdf"" rel=""nofollow noreferrer"">John Watrous' famous book</a>, a quantum channel is defined as a linear map</p>
<p><span class=""math-container"">$$\Phi: L(\mathcal{X})\rightarrow L(\mathcal{Y})$$</span></p>
<p>Now <span class=""math-container"">$L(\mathcal{X})$</span> stands for <span class=""math-container"">$L(\mathcal{X},\mathcal{X})$</span>, which is itself a collection of all linear mappings <span class=""math-container"">$\mathcal{A}: \mathcal{X}\rightarrow \mathcal{X}$</span> (page-8).</p>
<p><strong>2.</strong> As a physics student, when I look at some simple examples of a quantum channel, say a phase damping channel <span class=""math-container"">$\Phi_{PD}$</span>, the way I look at it is that <em>it takes my initial state <span class=""math-container"">$\rho_i$</span> at time <span class=""math-container"">$t_i$</span> to a final state <span class=""math-container"">$\rho_f$</span> at time <span class=""math-container"">$t_f$</span></em>.</p>
<p><span class=""math-container"">$$\Phi_{PD} [\rho_i] \rightarrow \rho_f$$</span></p>
<p>Trying to compare these two scenarios, it seems <span class=""math-container"">$\rho_i \in L(\mathcal{X})$</span> and <span class=""math-container"">$\rho_f \in L(\mathcal{Y})$</span>. What happens to  <span class=""math-container"">$\mathcal{A}$</span> here? What is exactly the one-to-one correspondence between <strong>1</strong> and <strong>2</strong>?</p>
<p>Edit: I have tried to convey my query by a diagram in which the job of <span class=""math-container"">$\Phi$</span> is illustrated. I want to understand what is <span class=""math-container"">$\mathcal{A}$</span> in the following diagram:</p>
<p><a href=""https://i.sstatic.net/RCnBZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RCnBZ.png"" alt=""enter image description here"" /></a></p>
","If density matrices are linear operators, what vectors do they operate on?",<textbook-and-exercises><quantum-operation><terminology-and-notation>,1,10,,,"If density matrices are linear operators, what vectors do they operate on? <p><strong>1.</strong>  On page 73 of <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/TQI.pdf"" rel=""nofollow noreferrer"">John Watrous' famous book</a>, a quantum channel is defined as a linear map</p>
<p><span class=""math-container"">$$\Phi: L(\mathcal{X})\rightarrow L(\mathcal{Y})$$</span></p>
<p>Now <span class=""math-container"">$L(\mathcal{X})$</span> stands for <span class=""math-container"">$L(\mathcal{X},\mathcal{X})$</span>, which is itself a collection of all linear mappings <span class=""math-container"">$\mathcal{A}: \mathcal{X}\rightarrow \mathcal{X}$</span> (page-8).</p>
<p><strong>2.</strong> As a physics student, when I look at some simple examples of a quantum channel, say a phase damping channel <span class=""math-container"">$\Phi_{PD}$</span>, the way I look at it is that <em>it takes my initial state <span class=""math-container"">$\rho_i$</span> at time <span class=""math-container"">$t_i$</span> to a final state <span class=""math-container"">$\rho_f$</span> at time <span class=""math-container"">$t_f$</span></em>.</p>
<p><span class=""math-container"">$$\Phi_{PD} [\rho_i] \rightarrow \rho_f$$</span></p>
<p>Trying to compare these two scenarios, it seems <span class=""math-container"">$\rho_i \in L(\mathcal{X})$</span> and <span class=""math-container"">$\rho_f \in L(\mathcal{Y})$</span>. What happens to  <span class=""math-container"">$\mathcal{A}$</span> here? What is exactly the one-to-one correspondence between <strong>1</strong> and <strong>2</strong>?</p>
<p>Edit: I have tried to convey my query by a diagram in which the job of <span class=""math-container"">$\Phi$</span> is illustrated. I want to understand what is <span class=""math-container"">$\mathcal{A}$</span> in the following diagram:</p>
<p><a href=""https://i.sstatic.net/RCnBZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RCnBZ.png"" alt=""enter image description here"" /></a></p>
",qc,density matrices linear operators vectors operate p strong page 73 https nofollow noreferrer john watrous famous book quantum channel defined linear map p span l x l p span l x stands span l x x collection linear mappings span x x p strong physics student look simple examples quantum channel say phase damping channel span pd way look em takes initial state span time span final state span time span p span pd p trying compare two scenarios seems span l x span l happens span exactly correspondence strong 1 strong 2 p edit tried convey query diagram job span illustrated want understand span following diagram p https nofollow noreferrer img https enter image description,"[(0, 0.022273248), (3, 0.55366844), (4, 0.20185626), (8, 0.11091569), (10, 0.08387127), (17, 0.026198998)]"
21250,,2021-09-17 18:02:25,3,438,"<p>In many papers, the QAOA is shown to be intimately related to Quantum Annealing/Quantum Adiabatic Algorithm/Adiabatic Quantum Optimization.</p>
<p>The mixing operator in the QAOA is described by Hadfield as one that transfers probability amplitudes between states. <a href=""https://quantumcomputing.stackexchange.com/questions/17555/whats-the-role-of-mixer-in-qaoa"">Another post</a> shows it also helps change the probability distribution, as evolving only under the cost Hamiltonian has no effect on the probabilities. It also prevents the possibility of being stuck in an eigenstate of the problem Hamiltonian. In Quantum Annealing, the driver is chosen such that it doesn't commute with the problem Hamiltonian and that it has an easy to construct ground state, after which the system is evolved adiabatically to find the ground state of the problem Hamiltonian. I also see how the QAOA is a discrete trotterization of Quantum Annealing.</p>
<p>I used Qiskit to implement the QAOA and tested them on a simple 3 node graph with 2 edges, a 4-regular 6 node graph and an 8 node 4-regular graph. In each case, I tried a variety of depths (p=3,6,12,24), the standard equal superposition initial state as well as random states.
In all initial states I tried, I was able to find the MAXCUT solution. This to me seems strange, since the initial state is crucial to Quantum Annealing. In which case, how is the driver and the mixer related?</p>
<p>I also inspected the relationships between the optimized <span class=""math-container"">$\beta$</span>s and <span class=""math-container"">$\gamma$</span>s. Given that the QAOA is a trotterization of Quantum Annealing, and that we can think of these angles as the length of time the system is evolving under the operator, I expected to find an inverse relationship such that the values of the angles used for the Mixer unitary decrease in magnitude and the values of the angles used for the Phase unitary increase in magnitude as we move from the leftmost part of the circuit to the right. But this was not the case and no discernible pattern could be seen. Shouldn't there be a correlation to a progression in time? Or perhaps the progression is not linear?</p>
",What is the relationship between the mixing operators and initial states found in QAOA and Quantum Annealing?,<quantum-algorithms><qaoa><annealing>,1,1,,,"What is the relationship between the mixing operators and initial states found in QAOA and Quantum Annealing? <p>In many papers, the QAOA is shown to be intimately related to Quantum Annealing/Quantum Adiabatic Algorithm/Adiabatic Quantum Optimization.</p>
<p>The mixing operator in the QAOA is described by Hadfield as one that transfers probability amplitudes between states. <a href=""https://quantumcomputing.stackexchange.com/questions/17555/whats-the-role-of-mixer-in-qaoa"">Another post</a> shows it also helps change the probability distribution, as evolving only under the cost Hamiltonian has no effect on the probabilities. It also prevents the possibility of being stuck in an eigenstate of the problem Hamiltonian. In Quantum Annealing, the driver is chosen such that it doesn't commute with the problem Hamiltonian and that it has an easy to construct ground state, after which the system is evolved adiabatically to find the ground state of the problem Hamiltonian. I also see how the QAOA is a discrete trotterization of Quantum Annealing.</p>
<p>I used Qiskit to implement the QAOA and tested them on a simple 3 node graph with 2 edges, a 4-regular 6 node graph and an 8 node 4-regular graph. In each case, I tried a variety of depths (p=3,6,12,24), the standard equal superposition initial state as well as random states.
In all initial states I tried, I was able to find the MAXCUT solution. This to me seems strange, since the initial state is crucial to Quantum Annealing. In which case, how is the driver and the mixer related?</p>
<p>I also inspected the relationships between the optimized <span class=""math-container"">$\beta$</span>s and <span class=""math-container"">$\gamma$</span>s. Given that the QAOA is a trotterization of Quantum Annealing, and that we can think of these angles as the length of time the system is evolving under the operator, I expected to find an inverse relationship such that the values of the angles used for the Mixer unitary decrease in magnitude and the values of the angles used for the Phase unitary increase in magnitude as we move from the leftmost part of the circuit to the right. But this was not the case and no discernible pattern could be seen. Shouldn't there be a correlation to a progression in time? Or perhaps the progression is not linear?</p>
",qc,relationship mixing operators initial states found qaoa quantum annealing p many papers qaoa shown intimately related quantum adiabatic quantum p mixing operator qaoa described hadfield one transfers probability amplitudes states https another post shows also helps change probability distribution evolving cost hamiltonian effect probabilities also prevents possibility stuck eigenstate problem hamiltonian quantum annealing driver chosen commute problem hamiltonian easy construct ground state system evolved adiabatically find ground state problem hamiltonian also see qaoa discrete trotterization quantum p used qiskit implement qaoa tested simple 3 node graph 2 edges 6 node graph 8 node graph case tried variety depths standard equal superposition initial state well random states initial states tried able find maxcut solution seems strange since initial state crucial quantum annealing case driver mixer related p also inspected relationships optimized span span given qaoa trotterization quantum annealing think angles length time system evolving operator expected find inverse relationship values angles used mixer unitary decrease magnitude values angles used phase unitary increase magnitude move leftmost part circuit right case discernible pattern could seen correlation progression time perhaps progression linear,"[(1, 0.18084383), (3, 0.20472346), (5, 0.017201176), (6, 0.015319999), (7, 0.01331746), (8, 0.14989497), (9, 0.0783698), (13, 0.16124855), (14, 0.09593076), (17, 0.018605953), (18, 0.06402675)]"
21298,,2021-09-22 16:06:57,2,703,"<p>I want to encode two vectors into qubits and compute a distance between them that corresponds/is proportional to the euclidian distance of the real vectors.</p>
<p>The encoding I use is</p>
<ul>
<li>A) qiskit <code>initialize</code> method</li>
</ul>
<pre><code>def get_encoding_circuit(*vv): 
    
    sz = int(np.log2(len(vv[0])))
    
    qc = QuantumCircuit(len(vv)*sz)

    for i, v in enumerate(vv):
        qc.initialize(v, range(i*sz, (i+1)*sz))
    
    return qc
</code></pre>
<p>and</p>
<ul>
<li>B) amplitude encoding as shown <a href=""https://www.nature.com/articles/s41598-021-85474-1.pdf"" rel=""nofollow noreferrer"">here</a></li>
</ul>
<p>The distance metric I use is given by the overlap from</p>
<ul>
<li>I) qiskit's <code>state_fidelity</code> method and</li>
<li>II) a Swap Test circuit.</li>
</ul>
<p>For example in <span class=""math-container"">$\mathbb{R^2}$</span>, <span class=""math-container"">$u$</span> and <span class=""math-container"">$v$</span> given as</p>
<p><span class=""math-container"">$$
u = \begin{bmatrix} 1 \\ 1 \end{bmatrix} \quad
v = \begin{bmatrix} -1 \\ -1 \end{bmatrix}
$$</span></p>
<p>are encoded as</p>
<p><span class=""math-container"">$$
|u\rangle = \begin{bmatrix} 0.70711 \\  0.70711 \end{bmatrix} \quad
|v\rangle = \begin{bmatrix} - 0.70711 \\ - 0.70711 \end{bmatrix}
$$</span></p>
<p>The problem I have (with any combination of A), B) I), II)) is that <span class=""math-container"">$|u\rangle$</span> and <span class=""math-container"">$|v\rangle$</span> have an overlap of 1, so are equivalent. The reason is that the encoding of <span class=""math-container"">$v$</span> is equal to the encoding of <span class=""math-container"">$u$</span>, just with a global phase added,</p>
<p>s.t. the fidelity (as computed by qiskit) for example is</p>
<p><span class=""math-container"">$$
| \langle u|v\rangle |^2 = 1.0
$$</span></p>
<p>but
<span class=""math-container"">$\text{dist_eucl}(u,v)$</span> is far from 0.</p>
<p>What encoding can I use that will produce distinct qubits for positive and negative real inputs?</p>
<p>Edit/Followup:</p>
<p>I finally used the statepreparation described <a href=""https://arxiv.org/abs/1307.0411"" rel=""nofollow noreferrer"">here</a>
For real vectors in the range <span class=""math-container"">$[-1,1]$</span> I obtain quantum distances corresponding to euclidian distances:
<a href=""https://i.sstatic.net/yjjGq.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yjjGq.png"" alt=""quantum distance"" /></a></p>
",Amplitude encoding: distinction between negative and positive real values,<qiskit><fidelity><swap-test>,1,2,,,"Amplitude encoding: distinction between negative and positive real values <p>I want to encode two vectors into qubits and compute a distance between them that corresponds/is proportional to the euclidian distance of the real vectors.</p>
<p>The encoding I use is</p>
<ul>
<li>A) qiskit <code>initialize</code> method</li>
</ul>
<pre><code>def get_encoding_circuit(*vv): 
    
    sz = int(np.log2(len(vv[0])))
    
    qc = QuantumCircuit(len(vv)*sz)

    for i, v in enumerate(vv):
        qc.initialize(v, range(i*sz, (i+1)*sz))
    
    return qc
</code></pre>
<p>and</p>
<ul>
<li>B) amplitude encoding as shown <a href=""https://www.nature.com/articles/s41598-021-85474-1.pdf"" rel=""nofollow noreferrer"">here</a></li>
</ul>
<p>The distance metric I use is given by the overlap from</p>
<ul>
<li>I) qiskit's <code>state_fidelity</code> method and</li>
<li>II) a Swap Test circuit.</li>
</ul>
<p>For example in <span class=""math-container"">$\mathbb{R^2}$</span>, <span class=""math-container"">$u$</span> and <span class=""math-container"">$v$</span> given as</p>
<p><span class=""math-container"">$$
u = \begin{bmatrix} 1 \\ 1 \end{bmatrix} \quad
v = \begin{bmatrix} -1 \\ -1 \end{bmatrix}
$$</span></p>
<p>are encoded as</p>
<p><span class=""math-container"">$$
|u\rangle = \begin{bmatrix} 0.70711 \\  0.70711 \end{bmatrix} \quad
|v\rangle = \begin{bmatrix} - 0.70711 \\ - 0.70711 \end{bmatrix}
$$</span></p>
<p>The problem I have (with any combination of A), B) I), II)) is that <span class=""math-container"">$|u\rangle$</span> and <span class=""math-container"">$|v\rangle$</span> have an overlap of 1, so are equivalent. The reason is that the encoding of <span class=""math-container"">$v$</span> is equal to the encoding of <span class=""math-container"">$u$</span>, just with a global phase added,</p>
<p>s.t. the fidelity (as computed by qiskit) for example is</p>
<p><span class=""math-container"">$$
| \langle u|v\rangle |^2 = 1.0
$$</span></p>
<p>but
<span class=""math-container"">$\text{dist_eucl}(u,v)$</span> is far from 0.</p>
<p>What encoding can I use that will produce distinct qubits for positive and negative real inputs?</p>
<p>Edit/Followup:</p>
<p>I finally used the statepreparation described <a href=""https://arxiv.org/abs/1307.0411"" rel=""nofollow noreferrer"">here</a>
For real vectors in the range <span class=""math-container"">$[-1,1]$</span> I obtain quantum distances corresponding to euclidian distances:
<a href=""https://i.sstatic.net/yjjGq.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yjjGq.png"" alt=""quantum distance"" /></a></p>
",qc,amplitude encoding distinction negative positive real values p want encode two vectors qubits compute distance proportional euclidian distance real p encoding use ul li qiskit code initialize method pre code def vv sz int len vv 0 qc quantumcircuit len vv sz v enumerate vv v range sz sz return qc p ul li b amplitude encoding shown https nofollow noreferrer p distance metric use given overlap ul li qiskit code method li ii swap test p example span span u span v given p span u bmatrix 1 1 bmatrix v bmatrix bmatrix p encoded p span bmatrix bmatrix bmatrix bmatrix p problem combination b ii span span overlap 1 equivalent reason encoding span v equal encoding span u global phase added p fidelity computed qiskit example p span p span u v far p encoding use produce distinct qubits positive negative real inputs p p finally used statepreparation described https nofollow noreferrer real vectors range span obtain quantum distances corresponding euclidian distances https nofollow noreferrer img https quantum distance,"[(0, 0.16158524), (3, 0.35690787), (4, 0.09198553), (5, 0.068436645), (7, 0.14835507), (11, 0.010007873), (14, 0.0548077), (15, 0.09043286), (17, 0.016838366)]"
21311,21318.0,2021-09-23 13:35:06,7,961,"<p>I'm trying to reproduce the basic method of <a href=""https://arxiv.org/abs/2002.08953"" rel=""noreferrer"">classical shadow</a>, which is based on the <a href=""https://pennylane.ai/qml/demos/tutorial_classical_shadows.html#classical-shadows"" rel=""noreferrer"">tutorial of pennylane</a>. However, I've met some realization problems here when I finish reading the tutorial of pennylane, and trying to finish the method myself, just to check if my understanding is correct, because I'm not sure if my understanding about the inverse of the map <span class=""math-container"">$M$</span> mentioned in the paper is correct.</p>
<p>I will describe the method shortly first, and then showing my code with <em>qiskit</em>, <em>pennylane</em>, and <em>matlab</em>. But all of them failed to have the same effect as the <em>tutorial of pennylane</em> does(increasing the number of measurements, the distance between the state I want to reconstruct and the original state should be more and more close).</p>
<p>The idea of classical shadow(or the process of the algorithm) is kind of simple while the math behind it might be complicated. The process states that for any density matrix <span class=""math-container"">$\rho$</span>, we act some unitary matrix <span class=""math-container"">$U$</span> which are chosen <em>randomly</em> from a specific set of the unitary matrix <span class=""math-container"">$\mathcal{U}$</span> on it, i.e., <span class=""math-container"">$U\rho U^\dagger$</span>. Then we do one-shot measurement based on the computational basis on <span class=""math-container"">$U\rho U^\dagger$</span>. Then the state will collapse into some state <span class=""math-container"">$|\hat{b}\rangle$</span>. And then we do the rest of the work in classical data analysis style. First we undo the unitary matrix, i.e., <span class=""math-container"">$U^\dagger |\hat{b}\rangle\langle \hat{b}| U$</span> . Then we do the inverse of the map <span class=""math-container"">$\hat{\rho}\equiv M^{-1}(U^\dagger |\hat{b}\rangle\langle \hat{b}| U)$</span> which can be defined as <span class=""math-container"">$M(\rho)\equiv E(U^\dagger |\hat{b}\rangle\langle \hat{b}| U)$</span>, where the <span class=""math-container"">$E$</span> stands for expectation over both unitary matrix and measurement result <span class=""math-container"">$|\hat{b}\rangle$</span>.  And for a specific choice of unitary set(seems Clifford group, not very clear here), we have a form of the inverse of <span class=""math-container"">$M$</span> states as
<span class=""math-container"">$$
\hat{\rho} = \bigotimes_{j=1}^n(3U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j-\mathbb{I})\tag{1}
$$</span>
Then I will introduce my code first. We specify the unitary group into Hadamard gate, phase gate, and identity. Then we do the computational basis measurement and rebuild the classical shadow <span class=""math-container"">$\hat{\rho}$</span> with the help of eq.(1), and then calculate the expectation value of <span class=""math-container"">$\hat{\rho}$</span> by directly divide measurement times.</p>
<p>Following the codes(pennylane, qiskit, Matlab), aiming at construct the classical shadow of bell state:</p>
<pre><code>from networkx.algorithms.centrality import harmonic
from networkx.exception import HasACycle
from networkx.readwrite.sparse6 import write_sparse6
from numpy import dtype
from numpy.random.mtrand import rand
import pennylane as qml
from pennylane import wires
import pennylane.numpy as np
import matplotlib.pyplot as plt
import time

def distance(rho):
    return np.sqrt(np.trace(rho.conjugate().transpose() @ rho))

def my_quantum_function(x, y):
    unitary = [qml.Hadamard, qml.S, qml.Identity]
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0,1])
        
    unitary[y[0]](wires=0)
    unitary[y[1]](wires=1)

    # all measure in computational basis, i.e., mean value of pauliz, one-shot case
    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]

# one-shot case shots = 1 to simulate the measure in computational basis requirement
dev = qml.device('default.qubit', wires=2, shots=1)
circuit = qml.QNode(my_quantum_function, dev)

# generate random number seed for easy replicate the experiment
np.random.seed(666)

# init
phase_z = np.array([[1, 0], [0, 1j]], dtype=complex)
hadamard = qml.Hadamard(0).matrix
identity = qml.Identity(0).matrix

unitary = [hadamard, phase_z, identity]

snapshot = 1000
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
record_rho = np.zeros([4,4])

for i in range(snapshot):
    randnum = np.random.randint(0,3,size=2)
    [res0, res1] = circuit(0,randnum)
    # print(circuit.draw())
    if res0 == 1:
        rho1 = 3*(unitary[randnum[0]].conj().T @ state0 @ unitary[randnum[0]]) - identity
    else:
        rho1 = 3*(unitary[randnum[0]].conj().T @ state1 @ unitary[randnum[0]]) - identity

    if res0 == 1:
        rho2 = 3*(unitary[randnum[1]].conj().T @ state0 @ unitary[randnum[1]]) - identity
    else:
        rho2 = 3*(unitary[randnum[1]].conj().T @ state1 @ unitary[randnum[1]]) - identity

    record_rho = record_rho + np.kron(rho1,rho2)

record_rho = record_rho/snapshot
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])
print(record_rho)

print(distance(record_rho - bell_state))

</code></pre>
<pre><code>from math import exp
from qiskit import *
from qiskit import Aer
import numpy as np
import matplotlib.pyplot as plt
from random import randrange

np.random.seed(222)
def one_shot(operator):
    
    sim = Aer.get_backend('aer_simulator')
    qc = QuantumCircuit(2)
    unitary = [qc.h, qc.sdg, qc.id]
    qc.h(0)
    qc.cx(0,1)
    unitary[operator[0]](0)
    unitary[operator[1]](1)
    qc.measure_all()

    qobj = assemble(qc,shots=1)
    result = sim.run(qobj).result().get_counts()
    return result

def distance(rho):
    '''
    calculate distance of two density matrix
    '''
    return np.sqrt(np.trace(rho.conjugate().transpose().dot(rho)))

hadamard = 1/np.sqrt(2)*np.array([[1,1],[1,-1]])
s_gate = np.array([[1,0],[0,-1j]],dtype=complex)
id = np.identity(2)
unitary = [hadamard,np.dot(hadamard,s_gate),id]

snapshot_num = 1000
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
record_rho = np.zeros([4,4])
for i in range(snapshot_num):
    randnum = np.random.randint(0,3,size=2)
    result = one_shot(randnum)
    if result.get('00') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)
    elif result.get('01') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state1).dot(unitary[randnum[1]]) - id)
    elif result.get('10') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state1).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)
    else:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state1).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state1).dot(unitary[randnum[1]]) - id)

    record_rho = record_rho + rho
record_rho = record_rho/snapshot_num
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])
print(record_rho)
print(distance(record_rho - bell_state))

</code></pre>
<pre><code>% Pauli matrix as random unitary
pauli = eye(2);
pauli(:,:,2) = [1 0;0 -1j]; pauli(:,:,3) = 1/sqrt(2)*pauli(:,:,2)'*[1 1;1 -1];
% two computational basis |0) and |1)
state = eye(4);
state0 = [1;0];
state1 = [0;1];

psi = 1/sqrt(2)*[1;0;0;1];
rho = psi*psi';
record_rho = zeros(4);
n = 6000;
for i = 1:n
    randnum = randi([1 3],[1 2]);
    rhot = kron(pauli(:,:,randnum(1)),pauli(:,:,randnum(2)))*rho*kron(pauli(:,:,randnum(1)),pauli(:,:,randnum(2)))';
    prob1 = state(:,1)'*rhot*state(:,1);
    prob2 = state(:,2)'*rhot*state(:,2);
    prob3 = state(:,3)'*rhot*state(:,3);
    prob4 = state(:,4)'*rhot*state(:,4);
    
    % Utilizing if to simulate the quantum measurement
    % The inverse process is using the formula of eq(S44) in supplemental
    % material of the original paper
    if rand &lt; prob1
        rhot = 3*pauli(:,:,randnum(1))'*(state0*state0')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state0*state0')*pauli(:,:,randnum(2)) - eye(2));
    elseif rand &lt; prob1 + prob2
        rhot = 3*pauli(:,:,randnum(1))'*(state0*state0')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state1*state1')*pauli(:,:,randnum(2)) - eye(2));
    elseif rand &lt; prob1 + prob2 + prob3
        rhot = 3*pauli(:,:,randnum(1))'*(state1*state1')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state0*state0')*pauli(:,:,randnum(2)) - eye(2));
    else
        rhot = 3*pauli(:,:,randnum(1))'*(state1*state1')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state1*state1')*pauli(:,:,randnum(2)) - eye(2));
    end
    record_rho = record_rho + rhot;
end
record_rho = record_rho/n;
sqrt(trace((rho - record_rho)'*(rho - record_rho)))
Fidelity(rho,record_rho)
</code></pre>
",Implement the classical shadow coding error?,<qiskit><programming><quantum-algorithms><state-tomography><shadow-tomography>,1,0,,,"Implement the classical shadow coding error? <p>I'm trying to reproduce the basic method of <a href=""https://arxiv.org/abs/2002.08953"" rel=""noreferrer"">classical shadow</a>, which is based on the <a href=""https://pennylane.ai/qml/demos/tutorial_classical_shadows.html#classical-shadows"" rel=""noreferrer"">tutorial of pennylane</a>. However, I've met some realization problems here when I finish reading the tutorial of pennylane, and trying to finish the method myself, just to check if my understanding is correct, because I'm not sure if my understanding about the inverse of the map <span class=""math-container"">$M$</span> mentioned in the paper is correct.</p>
<p>I will describe the method shortly first, and then showing my code with <em>qiskit</em>, <em>pennylane</em>, and <em>matlab</em>. But all of them failed to have the same effect as the <em>tutorial of pennylane</em> does(increasing the number of measurements, the distance between the state I want to reconstruct and the original state should be more and more close).</p>
<p>The idea of classical shadow(or the process of the algorithm) is kind of simple while the math behind it might be complicated. The process states that for any density matrix <span class=""math-container"">$\rho$</span>, we act some unitary matrix <span class=""math-container"">$U$</span> which are chosen <em>randomly</em> from a specific set of the unitary matrix <span class=""math-container"">$\mathcal{U}$</span> on it, i.e., <span class=""math-container"">$U\rho U^\dagger$</span>. Then we do one-shot measurement based on the computational basis on <span class=""math-container"">$U\rho U^\dagger$</span>. Then the state will collapse into some state <span class=""math-container"">$|\hat{b}\rangle$</span>. And then we do the rest of the work in classical data analysis style. First we undo the unitary matrix, i.e., <span class=""math-container"">$U^\dagger |\hat{b}\rangle\langle \hat{b}| U$</span> . Then we do the inverse of the map <span class=""math-container"">$\hat{\rho}\equiv M^{-1}(U^\dagger |\hat{b}\rangle\langle \hat{b}| U)$</span> which can be defined as <span class=""math-container"">$M(\rho)\equiv E(U^\dagger |\hat{b}\rangle\langle \hat{b}| U)$</span>, where the <span class=""math-container"">$E$</span> stands for expectation over both unitary matrix and measurement result <span class=""math-container"">$|\hat{b}\rangle$</span>.  And for a specific choice of unitary set(seems Clifford group, not very clear here), we have a form of the inverse of <span class=""math-container"">$M$</span> states as
<span class=""math-container"">$$
\hat{\rho} = \bigotimes_{j=1}^n(3U^{\dagger}_j|\hat{b}_j\rangle\langle\hat{b}_j|U_j-\mathbb{I})\tag{1}
$$</span>
Then I will introduce my code first. We specify the unitary group into Hadamard gate, phase gate, and identity. Then we do the computational basis measurement and rebuild the classical shadow <span class=""math-container"">$\hat{\rho}$</span> with the help of eq.(1), and then calculate the expectation value of <span class=""math-container"">$\hat{\rho}$</span> by directly divide measurement times.</p>
<p>Following the codes(pennylane, qiskit, Matlab), aiming at construct the classical shadow of bell state:</p>
<pre><code>from networkx.algorithms.centrality import harmonic
from networkx.exception import HasACycle
from networkx.readwrite.sparse6 import write_sparse6
from numpy import dtype
from numpy.random.mtrand import rand
import pennylane as qml
from pennylane import wires
import pennylane.numpy as np
import matplotlib.pyplot as plt
import time

def distance(rho):
    return np.sqrt(np.trace(rho.conjugate().transpose() @ rho))

def my_quantum_function(x, y):
    unitary = [qml.Hadamard, qml.S, qml.Identity]
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0,1])
        
    unitary[y[0]](wires=0)
    unitary[y[1]](wires=1)

    # all measure in computational basis, i.e., mean value of pauliz, one-shot case
    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]

# one-shot case shots = 1 to simulate the measure in computational basis requirement
dev = qml.device('default.qubit', wires=2, shots=1)
circuit = qml.QNode(my_quantum_function, dev)

# generate random number seed for easy replicate the experiment
np.random.seed(666)

# init
phase_z = np.array([[1, 0], [0, 1j]], dtype=complex)
hadamard = qml.Hadamard(0).matrix
identity = qml.Identity(0).matrix

unitary = [hadamard, phase_z, identity]

snapshot = 1000
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
record_rho = np.zeros([4,4])

for i in range(snapshot):
    randnum = np.random.randint(0,3,size=2)
    [res0, res1] = circuit(0,randnum)
    # print(circuit.draw())
    if res0 == 1:
        rho1 = 3*(unitary[randnum[0]].conj().T @ state0 @ unitary[randnum[0]]) - identity
    else:
        rho1 = 3*(unitary[randnum[0]].conj().T @ state1 @ unitary[randnum[0]]) - identity

    if res0 == 1:
        rho2 = 3*(unitary[randnum[1]].conj().T @ state0 @ unitary[randnum[1]]) - identity
    else:
        rho2 = 3*(unitary[randnum[1]].conj().T @ state1 @ unitary[randnum[1]]) - identity

    record_rho = record_rho + np.kron(rho1,rho2)

record_rho = record_rho/snapshot
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])
print(record_rho)

print(distance(record_rho - bell_state))

</code></pre>
<pre><code>from math import exp
from qiskit import *
from qiskit import Aer
import numpy as np
import matplotlib.pyplot as plt
from random import randrange

np.random.seed(222)
def one_shot(operator):
    
    sim = Aer.get_backend('aer_simulator')
    qc = QuantumCircuit(2)
    unitary = [qc.h, qc.sdg, qc.id]
    qc.h(0)
    qc.cx(0,1)
    unitary[operator[0]](0)
    unitary[operator[1]](1)
    qc.measure_all()

    qobj = assemble(qc,shots=1)
    result = sim.run(qobj).result().get_counts()
    return result

def distance(rho):
    '''
    calculate distance of two density matrix
    '''
    return np.sqrt(np.trace(rho.conjugate().transpose().dot(rho)))

hadamard = 1/np.sqrt(2)*np.array([[1,1],[1,-1]])
s_gate = np.array([[1,0],[0,-1j]],dtype=complex)
id = np.identity(2)
unitary = [hadamard,np.dot(hadamard,s_gate),id]

snapshot_num = 1000
state0 = np.array([[1,0],[0,0]])
state1 = np.array([[0,0],[0,1]])
record_rho = np.zeros([4,4])
for i in range(snapshot_num):
    randnum = np.random.randint(0,3,size=2)
    result = one_shot(randnum)
    if result.get('00') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)
    elif result.get('01') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state0).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state1).dot(unitary[randnum[1]]) - id)
    elif result.get('10') == 1:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state1).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state0).dot(unitary[randnum[1]]) - id)
    else:
        rho = np.kron(3*np.dot(unitary[randnum[0]].conj().T,state1).dot(unitary[randnum[0]] - id),3*np.dot(unitary[randnum[1]].conj().T,state1).dot(unitary[randnum[1]]) - id)

    record_rho = record_rho + rho
record_rho = record_rho/snapshot_num
bell_state = np.array([[0.5, 0, 0, 0.5], [0, 0, 0, 0], [0, 0, 0, 0], [0.5, 0, 0, 0.5]])
print(record_rho)
print(distance(record_rho - bell_state))

</code></pre>
<pre><code>% Pauli matrix as random unitary
pauli = eye(2);
pauli(:,:,2) = [1 0;0 -1j]; pauli(:,:,3) = 1/sqrt(2)*pauli(:,:,2)'*[1 1;1 -1];
% two computational basis |0) and |1)
state = eye(4);
state0 = [1;0];
state1 = [0;1];

psi = 1/sqrt(2)*[1;0;0;1];
rho = psi*psi';
record_rho = zeros(4);
n = 6000;
for i = 1:n
    randnum = randi([1 3],[1 2]);
    rhot = kron(pauli(:,:,randnum(1)),pauli(:,:,randnum(2)))*rho*kron(pauli(:,:,randnum(1)),pauli(:,:,randnum(2)))';
    prob1 = state(:,1)'*rhot*state(:,1);
    prob2 = state(:,2)'*rhot*state(:,2);
    prob3 = state(:,3)'*rhot*state(:,3);
    prob4 = state(:,4)'*rhot*state(:,4);
    
    % Utilizing if to simulate the quantum measurement
    % The inverse process is using the formula of eq(S44) in supplemental
    % material of the original paper
    if rand &lt; prob1
        rhot = 3*pauli(:,:,randnum(1))'*(state0*state0')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state0*state0')*pauli(:,:,randnum(2)) - eye(2));
    elseif rand &lt; prob1 + prob2
        rhot = 3*pauli(:,:,randnum(1))'*(state0*state0')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state1*state1')*pauli(:,:,randnum(2)) - eye(2));
    elseif rand &lt; prob1 + prob2 + prob3
        rhot = 3*pauli(:,:,randnum(1))'*(state1*state1')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state0*state0')*pauli(:,:,randnum(2)) - eye(2));
    else
        rhot = 3*pauli(:,:,randnum(1))'*(state1*state1')*pauli(:,:,randnum(1)) - eye(2);
        rhot = kron(rhot,3*pauli(:,:,randnum(2))'*(state1*state1')*pauli(:,:,randnum(2)) - eye(2));
    end
    record_rho = record_rho + rhot;
end
record_rho = record_rho/n;
sqrt(trace((rho - record_rho)'*(rho - record_rho)))
Fidelity(rho,record_rho)
</code></pre>
",qc,implement classical shadow coding error p trying reproduce basic method https noreferrer classical shadow based https noreferrer tutorial pennylane however met realization problems finish reading tutorial pennylane trying finish method check understanding correct sure understanding inverse map span mentioned paper p describe method shortly first showing code em qiskit em pennylane em matlab failed effect em tutorial pennylane increasing number measurements distance state want reconstruct original state close p idea classical shadow process algorithm kind simple math behind might complicated process states density matrix span act unitary matrix span u chosen em randomly specific set unitary matrix span u span measurement based computational basis span state collapse state span b rest work classical data analysis style first undo unitary matrix span b b u inverse map span b b u defined span e b b u span e stands expectation unitary matrix measurement result span b specific choice unitary set seems clifford group clear form inverse span states span b b 1 introduce code first specify unitary group hadamard gate phase gate identity computational basis measurement rebuild classical shadow span help eq 1 calculate expectation value span directly divide measurement p following codes pennylane qiskit matlab aiming construct classical shadow bell state pre code import harmonic import hasacycle import numpy import dtype import rand import pennylane qml pennylane import wires import np import plt import time def distance rho return rho def x unitary unitary 0 unitary 1 measure computational basis mean value pauliz case return 0 1 case shots 1 simulate measure computational basis requirement dev circuit dev generate random number seed easy replicate experiment 666 init 1 0 0 1j hadamard 0 identity 0 unitary hadamard identity snapshot 1000 state0 state1 range snapshot randnum res0 res1 circuit 0 randnum print res0 1 rho1 3 unitary randnum 0 state0 unitary randnum 0 identity else rho1 3 unitary randnum 0 state1 unitary randnum 0 identity res0 1 rho2 3 unitary randnum 1 state0 unitary randnum 1 identity else rho2 3 unitary randnum 1 state1 unitary randnum 1 identity rho1 rho2 0 0 0 0 0 0 0 0 0 0 0 0 print print distance pre code math import exp qiskit import qiskit import aer import numpy np import plt random import randrange 222 def operator sim qc quantumcircuit 2 unitary 0 unitary operator 0 0 unitary operator 1 1 qobj assemble qc result qobj return result def distance rho calculate distance two density matrix return rho hadamard 2 1 0 id 2 unitary hadamard hadamard id 1000 state0 state1 range randnum result randnum 1 rho 3 unitary randnum 0 state0 unitary randnum 0 id unitary randnum 1 state0 unitary randnum 1 id elif 1 rho 3 unitary randnum 0 state0 unitary randnum 0 id unitary randnum 1 state1 unitary randnum 1 id elif 1 rho 3 unitary randnum 0 state1 unitary randnum 0 id unitary randnum 1 state0 unitary randnum 1 id else rho 3 unitary randnum 0 state1 unitary randnum 0 id unitary randnum 1 state1 unitary randnum 1 id rho 0 0 0 0 0 0 0 0 0 0 0 0 print print distance pre code pauli matrix random unitary pauli eye 2 pauli 1 0 0 pauli 2 pauli 1 1 1 two computational basis state eye 4 state0 1 0 state1 0 1 psi 2 1 0 0 1 rho psi psi zeros 4 n 6000 1 n randnum randi 1 3 1 2 rhot kron pauli 1 pauli 2 rho kron pauli 1 pauli 2 prob1 state rhot state prob2 state rhot state prob3 state rhot state prob4 state rhot state utilizing simulate quantum measurement inverse process using formula eq s44 supplemental material original paper rand lt prob1 rhot 3 pauli 1 state0 state0 pauli 1 eye 2 rhot kron pauli 2 state0 state0 pauli 2 eye 2 elseif rand lt prob1 prob2 rhot 3 pauli 1 state0 state0 pauli 1 eye 2 rhot kron pauli 2 state1 state1 pauli 2 eye 2 elseif rand lt prob1 prob2 prob3 rhot 3 pauli 1 state1 state1 pauli 1 eye 2 rhot kron pauli 2 state0 state0 pauli 2 eye 2 else rhot 3 pauli 1 state1 state1 pauli 1 eye 2 rhot kron pauli 2 state1 state1 pauli 2 eye 2 end rhot end sqrt trace rho rho fidelity rho,"[(0, 0.20984451), (1, 0.010143942), (2, 0.3229683), (3, 0.2124515), (5, 0.010481197), (11, 0.06652459), (17, 0.053915083), (18, 0.07487642), (19, 0.016387189)]"
21325,,2021-09-24 14:41:36,4,226,"<p>In its report <a href=""https://www.ibm.com/thought-leadership/institute-business-value/report/quantum-decade"" rel=""nofollow noreferrer"">Quantum Decade</a>, IBM claims that we need 512 classical bits to represent two-qubits entangled state (see graphic on pg. 2 in the report). This seems a little bit odd to me.
Lets have a general two-qubits quantum state <span class=""math-container"">$|\psi\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle$</span> where probability amplitudes are complex numbers. Assume that the amplitudes are expressed with two real values each, i.e. 8 real numbers in total. The only way how to come to 512 bits is using 64 bits real numbers (double precission) on a classical computer.</p>
<p>I understand that the report is intended for managers rather than experts in computers sciences and quantum computing but still this seems a little bit misleading as the number of classical bits required depends on a precission of a quantum computer simulation (for single precission we would need only 256 bits), moreover, the memory requirements hold for any two-qubits state, not only entangled ones.</p>
<p>On top of that, IBM also claims in the report that</p>
<blockquote>
<p>Entanglement means the combined state of the qubits contains more information than the qubits do independently.</p>
</blockquote>
<p>If we have for example Bell state and measure both qubits, we are left with two classical bits. So, there is the same amount of information as in two classical bits. Only difference is that in entangled state we can infer state of other qubits from measuring only few in the state but in the end we have same amount of information.</p>
<p>Is my understanding right and the report is more marketing material or am I missing something important?</p>
",How much information is stored in entangled states (IBM report Quantum Decade)?,<entanglement><ibm-quantum-devices>,0,4,,,"How much information is stored in entangled states (IBM report Quantum Decade)? <p>In its report <a href=""https://www.ibm.com/thought-leadership/institute-business-value/report/quantum-decade"" rel=""nofollow noreferrer"">Quantum Decade</a>, IBM claims that we need 512 classical bits to represent two-qubits entangled state (see graphic on pg. 2 in the report). This seems a little bit odd to me.
Lets have a general two-qubits quantum state <span class=""math-container"">$|\psi\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle$</span> where probability amplitudes are complex numbers. Assume that the amplitudes are expressed with two real values each, i.e. 8 real numbers in total. The only way how to come to 512 bits is using 64 bits real numbers (double precission) on a classical computer.</p>
<p>I understand that the report is intended for managers rather than experts in computers sciences and quantum computing but still this seems a little bit misleading as the number of classical bits required depends on a precission of a quantum computer simulation (for single precission we would need only 256 bits), moreover, the memory requirements hold for any two-qubits state, not only entangled ones.</p>
<p>On top of that, IBM also claims in the report that</p>
<blockquote>
<p>Entanglement means the combined state of the qubits contains more information than the qubits do independently.</p>
</blockquote>
<p>If we have for example Bell state and measure both qubits, we are left with two classical bits. So, there is the same amount of information as in two classical bits. Only difference is that in entangled state we can infer state of other qubits from measuring only few in the state but in the end we have same amount of information.</p>
<p>Is my understanding right and the report is more marketing material or am I missing something important?</p>
",qc,much information stored entangled states ibm report quantum decade p report https nofollow noreferrer quantum decade ibm claims need 512 classical bits represent entangled state see graphic pg 2 report seems little bit odd lets general quantum state span probability amplitudes complex numbers assume amplitudes expressed two real values 8 real numbers total way come 512 bits using 64 bits real numbers double precission classical p understand report intended managers rather experts computers sciences quantum computing still seems little bit misleading number classical bits required depends precission quantum computer simulation single precission would need 256 bits moreover memory requirements hold state entangled p top ibm also claims report blockquote p entanglement means combined state qubits contains information qubits p example bell state measure qubits left two classical bits amount information two classical bits difference entangled state infer state qubits measuring state end amount p understanding right report marketing material missing something important,"[(1, 0.12103289), (3, 0.120710336), (8, 0.15419991), (13, 0.17277956), (14, 0.059640344), (17, 0.021312742), (18, 0.3405775)]"
21381,,2021-10-01 12:20:46,4,120,"<p>I'm reading this paper : <a href=""https://arxiv.org/abs/1806.06472"" rel=""nofollow noreferrer"">Holographic Quantum Error Correcting Codes</a> and on page 3 they describe an optimal decoder for erasure channel.</p>
<p>The
description is for CSS codes but they claim that &quot;it is straightforwardly adapted to any stabiliser
code&quot;. I couldn't figure out how to do that.</p>
<p>Is anyone familiar with or has a reference for the algorithm for the optimal decoder in quantum erasure channel? Also is there any software/package that has it implemented?</p>
",What is the algorithm for the optimal decoder in a quantum erasure channel?,<quantum-algorithms><error-correction><quantum-operation><stabilizer-code>,0,0,,,"What is the algorithm for the optimal decoder in a quantum erasure channel? <p>I'm reading this paper : <a href=""https://arxiv.org/abs/1806.06472"" rel=""nofollow noreferrer"">Holographic Quantum Error Correcting Codes</a> and on page 3 they describe an optimal decoder for erasure channel.</p>
<p>The
description is for CSS codes but they claim that &quot;it is straightforwardly adapted to any stabiliser
code&quot;. I couldn't figure out how to do that.</p>
<p>Is anyone familiar with or has a reference for the algorithm for the optimal decoder in quantum erasure channel? Also is there any software/package that has it implemented?</p>
",qc,algorithm optimal decoder quantum erasure channel p reading paper https nofollow noreferrer holographic quantum error correcting codes page 3 describe optimal decoder erasure p description css codes claim quot straightforwardly adapted stabiliser code quot could figure p anyone familiar reference algorithm optimal decoder quantum erasure channel also implemented,"[(4, 0.20822433), (5, 0.23854154), (8, 0.20956229), (9, 0.08386939), (17, 0.21357015), (19, 0.04326446)]"
21395,21396.0,2021-10-02 17:32:39,4,219,"<p>The <a href=""https://en.wikipedia.org/wiki/Quantum_depolarizing_channel"" rel=""nofollow noreferrer"">Qunatum Depolarizing Channel</a> is parametrized by a single real variable <span class=""math-container"">$\lambda, 0 \leq \lambda \leq 1$</span>.</p>
<p>I have a system of <span class=""math-container"">$n$</span> qubits. I'd like to generate random errors from that channel. These would be strings of length <span class=""math-container"">$n$</span> with entries from <span class=""math-container"">$(0,1,2,3)$</span> with the right distribution. <span class=""math-container"">$(0,1,2,3)$</span> correspond to <span class=""math-container"">$(I,X,Z,Y)$</span> errors; <span class=""math-container"">$I$</span> error actually means no error applied to that qubit; the others mean <span class=""math-container"">$X,Z$</span> or <span class=""math-container"">$Y$</span> operators applied. For example <span class=""math-container"">$n=7$</span>, error <span class=""math-container"">$e=(0,1,0,0,3,0,2)$</span> means <span class=""math-container"">$X$</span> is applied to qubit 2, <span class=""math-container"">$Y$</span> to qubit 5, <span class=""math-container"">$Z$</span> to qubit 7.</p>
<p>Does anyone know of a tried and tested method for doing that. Python or any other language (or even pseudo-code) are fine.</p>
",What is an algorithm to generate random error in depolarizing channel,<error-correction><quantum-operation><depolarizing-channel>,1,0,,,"What is an algorithm to generate random error in depolarizing channel <p>The <a href=""https://en.wikipedia.org/wiki/Quantum_depolarizing_channel"" rel=""nofollow noreferrer"">Qunatum Depolarizing Channel</a> is parametrized by a single real variable <span class=""math-container"">$\lambda, 0 \leq \lambda \leq 1$</span>.</p>
<p>I have a system of <span class=""math-container"">$n$</span> qubits. I'd like to generate random errors from that channel. These would be strings of length <span class=""math-container"">$n$</span> with entries from <span class=""math-container"">$(0,1,2,3)$</span> with the right distribution. <span class=""math-container"">$(0,1,2,3)$</span> correspond to <span class=""math-container"">$(I,X,Z,Y)$</span> errors; <span class=""math-container"">$I$</span> error actually means no error applied to that qubit; the others mean <span class=""math-container"">$X,Z$</span> or <span class=""math-container"">$Y$</span> operators applied. For example <span class=""math-container"">$n=7$</span>, error <span class=""math-container"">$e=(0,1,0,0,3,0,2)$</span> means <span class=""math-container"">$X$</span> is applied to qubit 2, <span class=""math-container"">$Y$</span> to qubit 5, <span class=""math-container"">$Z$</span> to qubit 7.</p>
<p>Does anyone know of a tried and tested method for doing that. Python or any other language (or even pseudo-code) are fine.</p>
",qc,algorithm generate random error depolarizing channel p https nofollow noreferrer qunatum depolarizing channel parametrized single real variable span 0 1 p system span n qubits like generate random errors channel would strings length span n entries span right distribution span correspond span x z errors span error actually means error applied qubit others mean span x z span operators applied example span error span means span x applied qubit 2 span qubit 5 span z qubit p anyone know tried tested method python language even,"[(2, 0.02499681), (3, 0.46118772), (4, 0.053915724), (5, 0.20018259), (10, 0.056896564), (14, 0.17895885), (17, 0.02231754)]"
21400,,2021-10-04 01:52:00,3,776,"<p>Consider the following problem from Nielsen and Chuang's <em>Quantum Computation and Quantum Information</em>:</p>
<blockquote>
<p>Explain how a device which, upon input of one of two non-orthogonal quantum states <span class=""math-container"">$\left|\psi\right&gt;$</span> or <span class=""math-container"">$\left|\phi\right&gt;$</span> correctly identified the state, could be used to build a device which cloned the states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>, in violation of the no-cloning theorem. Conversely, explain how a device for cloning could be used to distinguish non-orthogonal quantum states.</p>
</blockquote>
<p>I know that this problem has already been posted at least two times <a href=""https://quantumcomputing.stackexchange.com/questions/2255/no-cloning-theorem-and-distinguishing-between-two-non-orthogonal-quantum-states?newreg=3a9bbf46be5e465189d256a01fc3f21e"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/6538/cloning-quantum-states-with-a-device-that-distinguishes-between-two-non-orthogon"">here</a>, but I am not satisfied with the answers to the first part given there. As you can see, all answers to the first part basically tell you to use the device to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span> and then just prepare an identical state. However, nowhere does this exercise say that we know how to prepare states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. Moreover, preparing an identical state is not the same as cloning. A cloning device has to be able to replicate a state without having any prior knowledge about its &quot;internal&quot; structure. With this in mind, I am posting this problem once again.</p>
<p>Here is my attempt to address this problem. Let us say that we have two non-orthogonal states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. We can measure <span class=""math-container"">$\left|\phi\right&gt;$</span> in the basis of <span class=""math-container"">$\left|\psi\right&gt;$</span>, and feed the result to our magical device. Since <span class=""math-container"">$\left|\phi\right&gt;$</span> is non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, there is non-zero probability that measurement will give us another <span class=""math-container"">$\left|\psi\right&gt;$</span>. In this case the device will identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, which means we have created a clone. If the measurement projects <span class=""math-container"">$\left|\phi\right&gt;$</span> to some other state <span class=""math-container"">$\left|\psi'\right&gt;$</span>, orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, then the device will not identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, and we can repeat the process by measuring <span class=""math-container"">$\left|\psi'\right&gt;$</span> again in the basis of <span class=""math-container"">$\left|\phi\right&gt;$</span>, which will create another state non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>.</p>
<p>This solution is also quite flimsy for the following reasons. First, I am not sure if an arbitrary unknown state can be used as a basis for measurement. Second, this solution never actually used the device to distinguish between <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span>. It only used it to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and not <span class=""math-container"">$\left|\psi\right&gt;$</span>, but it is unclear what happens if we try to feed a state other than <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span> to the device, so this way was probably not implied by the authors of the exercise.</p>
<p>Any ideas?</p>
",Using distinguishability of non-orthogonal states to create a cloning device,<textbook-and-exercises><no-cloning-theorem>,2,0,,,"Using distinguishability of non-orthogonal states to create a cloning device <p>Consider the following problem from Nielsen and Chuang's <em>Quantum Computation and Quantum Information</em>:</p>
<blockquote>
<p>Explain how a device which, upon input of one of two non-orthogonal quantum states <span class=""math-container"">$\left|\psi\right&gt;$</span> or <span class=""math-container"">$\left|\phi\right&gt;$</span> correctly identified the state, could be used to build a device which cloned the states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>, in violation of the no-cloning theorem. Conversely, explain how a device for cloning could be used to distinguish non-orthogonal quantum states.</p>
</blockquote>
<p>I know that this problem has already been posted at least two times <a href=""https://quantumcomputing.stackexchange.com/questions/2255/no-cloning-theorem-and-distinguishing-between-two-non-orthogonal-quantum-states?newreg=3a9bbf46be5e465189d256a01fc3f21e"">here</a> and <a href=""https://quantumcomputing.stackexchange.com/questions/6538/cloning-quantum-states-with-a-device-that-distinguishes-between-two-non-orthogon"">here</a>, but I am not satisfied with the answers to the first part given there. As you can see, all answers to the first part basically tell you to use the device to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span> and then just prepare an identical state. However, nowhere does this exercise say that we know how to prepare states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. Moreover, preparing an identical state is not the same as cloning. A cloning device has to be able to replicate a state without having any prior knowledge about its &quot;internal&quot; structure. With this in mind, I am posting this problem once again.</p>
<p>Here is my attempt to address this problem. Let us say that we have two non-orthogonal states <span class=""math-container"">$\left|\psi\right&gt;$</span> and <span class=""math-container"">$\left|\phi\right&gt;$</span>. We can measure <span class=""math-container"">$\left|\phi\right&gt;$</span> in the basis of <span class=""math-container"">$\left|\psi\right&gt;$</span>, and feed the result to our magical device. Since <span class=""math-container"">$\left|\phi\right&gt;$</span> is non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, there is non-zero probability that measurement will give us another <span class=""math-container"">$\left|\psi\right&gt;$</span>. In this case the device will identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, which means we have created a clone. If the measurement projects <span class=""math-container"">$\left|\phi\right&gt;$</span> to some other state <span class=""math-container"">$\left|\psi'\right&gt;$</span>, orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>, then the device will not identify it as <span class=""math-container"">$\left|\psi\right&gt;$</span>, and we can repeat the process by measuring <span class=""math-container"">$\left|\psi'\right&gt;$</span> again in the basis of <span class=""math-container"">$\left|\phi\right&gt;$</span>, which will create another state non-orthogonal to <span class=""math-container"">$\left|\psi\right&gt;$</span>.</p>
<p>This solution is also quite flimsy for the following reasons. First, I am not sure if an arbitrary unknown state can be used as a basis for measurement. Second, this solution never actually used the device to distinguish between <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span>. It only used it to distinguish between <span class=""math-container"">$\left|\psi\right&gt;$</span> and not <span class=""math-container"">$\left|\psi\right&gt;$</span>, but it is unclear what happens if we try to feed a state other than <span class=""math-container"">$\left|\phi\right&gt;$</span> and <span class=""math-container"">$\left|\psi\right&gt;$</span> to the device, so this way was probably not implied by the authors of the exercise.</p>
<p>Any ideas?</p>
",qc,using distinguishability states create cloning device p consider following problem nielsen chuang em quantum computation quantum information blockquote p explain device upon input one two quantum states span gt span gt correctly identified state could used build device cloned states span gt span gt violation theorem conversely explain device cloning could used distinguish quantum p know problem already posted least two times https https satisfied answers first part given see answers first part basically tell use device distinguish span gt span gt prepare identical state however nowhere exercise say know prepare states span gt span gt moreover preparing identical state cloning cloning device able replicate state without prior knowledge quot internal quot structure mind posting problem p attempt address problem let us say two states span gt span gt measure span gt basis span gt feed result magical device since span gt span gt probability measurement give us another span gt case device identify span gt means created clone measurement projects span gt state span gt orthogonal span gt device identify span gt repeat process measuring span gt basis span gt create another state span gt p solution also quite flimsy following reasons first sure arbitrary unknown state used basis measurement second solution never actually used device distinguish span gt span gt used distinguish span gt span gt unclear happens try feed state span gt span gt device way probably implied authors p ideas,"[(0, 0.11069025), (3, 0.30719745), (7, 0.029707717), (13, 0.15161131), (14, 0.0245048), (16, 0.044966776), (17, 0.032038674), (18, 0.2912226)]"
21425,21426.0,2021-10-06 01:53:57,3,93,"<p>p.281 of Nielsen and Chuang's book says that</p>
<blockquote>
<p>A single spin might evolve under the Hamiltonian <span class=""math-container"">$H = P_x(t)X + P_y(t)Y$</span>, where <span class=""math-container"">$P_{\{xy\}}$</span> are classically controllable parameters. From Exercise 4.10, we know that by manipulating <span class=""math-container"">$P_x$</span> and <span class=""math-container"">$P_y$</span> are appropriately, one can perform arbitrary single spin rotations.</p>
</blockquote>
<p>And Exercise 4.10 is that an arbitrary 2X2 unitary operator can be decomposed into <span class=""math-container"">$e^{ia}R_x(b)R_y(c)R_x(d)$</span>.</p>
<p>I can't understand why the Hamiltonian <span class=""math-container"">$H = P_x(t)X + P_y(t)Y$</span> can make an arbitrary unitary <span class=""math-container"">$U = R_x(b)R_y(c)R_x(d)$</span>.</p>
<p><span class=""math-container"">$H = P_x(t)X + P_y(t)Y$</span> makes an unitary <span class=""math-container"">$U^{-i(P_x(t)X + P_y(t)Y)/\hbar}$</span>.</p>
<p>And it can be <span class=""math-container"">$U^{-i(P_{x1}(t)X + P_y(t)Y+P_{x2}(t)X)/\hbar}$</span>.</p>
<p>But I think it cannot be decomposed into <span class=""math-container"">$U = R_x(P_{x1})R_y(P_y)R_x(P_{x2})$</span>, since X and Y don't commute.</p>
<p>Can you tell me how the proposition above in Nielsen and Chuang's book is correct?</p>
<p>Thanks in advance.</p>
",Why can the Hamiltonian $H=P_x(t)X+P_y(t)Y$ make an arbitrary unitary $U=R_x(b)R_y(c)R_x(d)$?,<quantum-gate><textbook-and-exercises><nielsen-and-chuang><matrix-representation><pauli-gates>,1,0,,,"Why can the Hamiltonian $H=P_x(t)X+P_y(t)Y$ make an arbitrary unitary $U=R_x(b)R_y(c)R_x(d)$? <p>p.281 of Nielsen and Chuang's book says that</p>
<blockquote>
<p>A single spin might evolve under the Hamiltonian <span class=""math-container"">$H = P_x(t)X + P_y(t)Y$</span>, where <span class=""math-container"">$P_{\{xy\}}$</span> are classically controllable parameters. From Exercise 4.10, we know that by manipulating <span class=""math-container"">$P_x$</span> and <span class=""math-container"">$P_y$</span> are appropriately, one can perform arbitrary single spin rotations.</p>
</blockquote>
<p>And Exercise 4.10 is that an arbitrary 2X2 unitary operator can be decomposed into <span class=""math-container"">$e^{ia}R_x(b)R_y(c)R_x(d)$</span>.</p>
<p>I can't understand why the Hamiltonian <span class=""math-container"">$H = P_x(t)X + P_y(t)Y$</span> can make an arbitrary unitary <span class=""math-container"">$U = R_x(b)R_y(c)R_x(d)$</span>.</p>
<p><span class=""math-container"">$H = P_x(t)X + P_y(t)Y$</span> makes an unitary <span class=""math-container"">$U^{-i(P_x(t)X + P_y(t)Y)/\hbar}$</span>.</p>
<p>And it can be <span class=""math-container"">$U^{-i(P_{x1}(t)X + P_y(t)Y+P_{x2}(t)X)/\hbar}$</span>.</p>
<p>But I think it cannot be decomposed into <span class=""math-container"">$U = R_x(P_{x1})R_y(P_y)R_x(P_{x2})$</span>, since X and Y don't commute.</p>
<p>Can you tell me how the proposition above in Nielsen and Chuang's book is correct?</p>
<p>Thanks in advance.</p>
",qc,hamiltonian make arbitrary unitary b c p nielsen chuang book says blockquote p single spin might evolve hamiltonian span h x span classically controllable parameters exercise know manipulating span span appropriately one perform arbitrary single spin p exercise arbitrary 2x2 unitary operator decomposed span ia b c p ca understand hamiltonian span h x make arbitrary unitary span u b c p span h x makes unitary span x p span x1 x x2 x p think decomposed span u x1 x2 since x p tell proposition nielsen chuang book correct p thanks,"[(1, 0.091766335), (3, 0.7191034), (7, 0.04012929), (10, 0.0912803), (17, 0.056093123)]"
21497,,2021-10-11 00:33:28,1,100,"<p>I'm looking at the source code for the Qiskit Experiments module and see that the EFRabi class subclasses the Rabi class with the intent of calibrating rotations between the 1 and 2 states instead of between 0 and 1. The only change I see in the circuit is the addition of an X gate at the beginning. How could this be done for other calibration experiments, e.g. one of the FineAmplitude experiments? Why does the X gate allow us to calibrate on higher energy states?</p>
",Working with higher energy states in Qiskit Experiments,<qiskit><programming><quantum-state><quantum-circuit><experimental-realization>,0,0,,,"Working with higher energy states in Qiskit Experiments <p>I'm looking at the source code for the Qiskit Experiments module and see that the EFRabi class subclasses the Rabi class with the intent of calibrating rotations between the 1 and 2 states instead of between 0 and 1. The only change I see in the circuit is the addition of an X gate at the beginning. How could this be done for other calibration experiments, e.g. one of the FineAmplitude experiments? Why does the X gate allow us to calibrate on higher energy states?</p>
",qc,working higher energy states qiskit experiments p looking source code qiskit experiments module see efrabi class subclasses rabi class intent calibrating rotations 1 2 states instead 0 change see circuit addition x gate beginning could done calibration experiments one fineamplitude experiments x gate allow us calibrate higher energy states,"[(0, 0.07695067), (2, 0.06713051), (10, 0.045319412), (14, 0.5479013), (16, 0.021940146), (17, 0.08671597), (18, 0.15122512)]"
21510,21511.0,2021-10-11 18:25:25,1,275,"<p>I am trying to run a simple &quot;Hello World&quot; project in Q#, following <a href=""https://www.c-sharpcorner.com/article/getting-started-with-q-programming/"" rel=""nofollow noreferrer"">this tutorial</a>. I have completed the following steps (Step #s from tutorial link):</p>
<ul>
<li>Step 1: Installed the latest version of Visual Studio 2019 (16.11.4 Preview 1.0)</li>
<li>Step 2: Installed Microsoft Quantum Development Kit</li>
<li>Step 3: Created a Q# Project using the Q# Application Template</li>
</ul>
<p>The resulting <code>Program.qs</code> file appears in vs:</p>
<pre><code>namespace Quantum.QSharpHelloWorld {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    
    @EntryPoint()
    operation HelloQ () : Unit {
        Message(&quot;Hello quantum world!&quot;);
    }
}
</code></pre>
<p>The two namespaces I am trying to <code>open</code> show the red squiggly line, with the errors</p>
<blockquote>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Canon&quot; exists.</p>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Intrinsic&quot; exists.</p>
</blockquote>
<p>Additionally and likely the same root cause, the <code>@EntryPoint</code> annotation and <code>Message()</code> call fail:</p>
<blockquote>
<p>QS6005: No type with the name &quot;EntryPoint&quot; exists in any of the open namespaces.</p>
<p>QS5022: No identifier with the name &quot;Message&quot; exists.</p>
</blockquote>
<p>In the solution explorer for my projet <code>QSharpHelloWorld</code>, the Dependencies, Packages, and each of five packages (Microsoft.Quantum.CSharpGeneration, .EntryPointDriver, .QSharp.Core, .Runtime.Core, and .Standard) all have the yellow triangle warning indicating a problem.</p>
<p>The error is similar to the one in <a href=""https://quantumcomputing.stackexchange.com/questions/12520/q-error-no-namespace-with-the-name-microsoft-quantum-machinelearning-exists"">this question</a>, except I'm not using Python so the accepted answer is irrelevant.  I attempted to use the command suggested in <a href=""https://quantumcomputing.stackexchange.com/a/12573/13421"">another answer</a>:</p>
<pre><code>dotnet add QSharpHelloWorld.csproj package Microsoft.Quantum.CSharpGeneration
</code></pre>
<p>However, this failed with the following error, suggesting this is the wrong solution:</p>
<pre><code>error: Error while performing Update for package 'Microsoft.Quantum.CSharpGeneration'. Cannot edit items in imported files -
error:   Item 'PackageReference' for 'Microsoft.Quantum.CSharpGeneration' in Imported file 'C:\[...]\.nuget\packages\microsoft.quantum.sdk\0.19.2109165653\Sdk\Sdk.props'.
</code></pre>
<p>I can't find any other obvious/easy menu options or fixes for this.  Other questions I've found here on SE all seem to be related to Python integration, not using Visual Studio.  I have the feeling I'm missing something trivial and obvious. Can anyone suggest additional steps I can take?</p>
","Q#/VS: No namespace with the name ""Microsoft.Quantum.Canon"" exists",<programming><q#>,1,1,,,"Q#/VS: No namespace with the name ""Microsoft.Quantum.Canon"" exists <p>I am trying to run a simple &quot;Hello World&quot; project in Q#, following <a href=""https://www.c-sharpcorner.com/article/getting-started-with-q-programming/"" rel=""nofollow noreferrer"">this tutorial</a>. I have completed the following steps (Step #s from tutorial link):</p>
<ul>
<li>Step 1: Installed the latest version of Visual Studio 2019 (16.11.4 Preview 1.0)</li>
<li>Step 2: Installed Microsoft Quantum Development Kit</li>
<li>Step 3: Created a Q# Project using the Q# Application Template</li>
</ul>
<p>The resulting <code>Program.qs</code> file appears in vs:</p>
<pre><code>namespace Quantum.QSharpHelloWorld {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    
    @EntryPoint()
    operation HelloQ () : Unit {
        Message(&quot;Hello quantum world!&quot;);
    }
}
</code></pre>
<p>The two namespaces I am trying to <code>open</code> show the red squiggly line, with the errors</p>
<blockquote>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Canon&quot; exists.</p>
<p>QS6104: No namespace with the name &quot;Microsoft.Quantum.Intrinsic&quot; exists.</p>
</blockquote>
<p>Additionally and likely the same root cause, the <code>@EntryPoint</code> annotation and <code>Message()</code> call fail:</p>
<blockquote>
<p>QS6005: No type with the name &quot;EntryPoint&quot; exists in any of the open namespaces.</p>
<p>QS5022: No identifier with the name &quot;Message&quot; exists.</p>
</blockquote>
<p>In the solution explorer for my projet <code>QSharpHelloWorld</code>, the Dependencies, Packages, and each of five packages (Microsoft.Quantum.CSharpGeneration, .EntryPointDriver, .QSharp.Core, .Runtime.Core, and .Standard) all have the yellow triangle warning indicating a problem.</p>
<p>The error is similar to the one in <a href=""https://quantumcomputing.stackexchange.com/questions/12520/q-error-no-namespace-with-the-name-microsoft-quantum-machinelearning-exists"">this question</a>, except I'm not using Python so the accepted answer is irrelevant.  I attempted to use the command suggested in <a href=""https://quantumcomputing.stackexchange.com/a/12573/13421"">another answer</a>:</p>
<pre><code>dotnet add QSharpHelloWorld.csproj package Microsoft.Quantum.CSharpGeneration
</code></pre>
<p>However, this failed with the following error, suggesting this is the wrong solution:</p>
<pre><code>error: Error while performing Update for package 'Microsoft.Quantum.CSharpGeneration'. Cannot edit items in imported files -
error:   Item 'PackageReference' for 'Microsoft.Quantum.CSharpGeneration' in Imported file 'C:\[...]\.nuget\packages\microsoft.quantum.sdk\0.19.2109165653\Sdk\Sdk.props'.
</code></pre>
<p>I can't find any other obvious/easy menu options or fixes for this.  Other questions I've found here on SE all seem to be related to Python integration, not using Visual Studio.  I have the feeling I'm missing something trivial and obvious. Can anyone suggest additional steps I can take?</p>
",qc,q namespace name exists p trying run simple quot hello world quot project q following https nofollow noreferrer tutorial completed following steps step tutorial link ul li step 1 installed latest version visual studio 2019 preview li step 2 installed microsoft quantum development kit li step 3 created q project using q application template p resulting code file appears vs pre code namespace open open entrypoint operation helloq unit message quot hello quantum world quot p two namespaces trying code open show red squiggly line errors blockquote p qs6104 namespace name quot quot p qs6104 namespace name quot quot p additionally likely root cause code entrypoint annotation code message call fail blockquote p qs6005 type name quot entrypoint quot exists open p qs5022 identifier name quot message quot p solution explorer projet code qsharphelloworld dependencies packages five packages yellow triangle warning indicating p error similar one https question except using python accepted answer irrelevant attempted use command suggested https another answer pre code dotnet add package p however failed following error suggesting wrong solution pre code error error performing update package edit items imported files error item imported file c p ca find menu options fixes questions found se seem related python integration using visual studio feeling missing something trivial obvious anyone suggest additional steps take,"[(0, 0.06695284), (3, 0.020705469), (4, 0.05422052), (5, 0.029492702), (7, 0.05720205), (8, 0.067060895), (9, 0.016463803), (10, 0.021450121), (12, 0.03833159), (13, 0.22956379), (14, 0.23150653), (17, 0.013334691), (19, 0.15337464)]"
21560,21569.0,2021-10-16 01:57:45,2,1094,"<p>According to <a href=""https://github.com/oscarhiggott/PyMatching"" rel=""nofollow noreferrer"">PyMatching's github page</a> the package can be decode toric and surface codes. <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">Stim's example</a>
uses stim + PyMatching combination to get logical error rate vs physical error rate curves for the repetition code. An encoding circuit is needed for this and it looks like stim has one built in for the repetition code. Is there an equivalent circuit for toric and surface codes somewhere already? It would be nice to generate similar curves for these codes and compare to published results.</p>
",how to simulate toric and surface codes with stim + PyMatching,<error-correction><stabilizer-code><surface-code><stim><toric-code>,1,0,,,"how to simulate toric and surface codes with stim + PyMatching <p>According to <a href=""https://github.com/oscarhiggott/PyMatching"" rel=""nofollow noreferrer"">PyMatching's github page</a> the package can be decode toric and surface codes. <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">Stim's example</a>
uses stim + PyMatching combination to get logical error rate vs physical error rate curves for the repetition code. An encoding circuit is needed for this and it looks like stim has one built in for the repetition code. Is there an equivalent circuit for toric and surface codes somewhere already? It would be nice to generate similar curves for these codes and compare to published results.</p>
",qc,simulate toric surface codes stim pymatching p according https nofollow noreferrer pymatching github page package decode toric surface codes https nofollow noreferrer stim example uses stim pymatching combination get logical error rate vs physical error rate curves repetition code encoding circuit needed looks like stim one built repetition code equivalent circuit toric surface codes somewhere already would nice generate similar curves codes compare published,"[(4, 0.26910153), (5, 0.50873077), (7, 0.07394569), (17, 0.14572915)]"
21579,,2021-10-18 10:43:46,4,95,"<p>Assume <span class=""math-container"">$|i\rangle,i\in[1,m]$</span> is a set of states, like the Fock states for Fermions. The question is how to compute the quantity,<span class=""math-container"">$\langle i |H|j\rangle,i,j\in[1,m]$</span>, in qiskit. The <span class=""math-container"">$H$</span> here is the qubit form Hamiltonian of some molecule obtained by the Jordan-Wigner transformation.</p>
",unsymmetric observable estimation by Qiskit,<qiskit>,1,1,,,"unsymmetric observable estimation by Qiskit <p>Assume <span class=""math-container"">$|i\rangle,i\in[1,m]$</span> is a set of states, like the Fock states for Fermions. The question is how to compute the quantity,<span class=""math-container"">$\langle i |H|j\rangle,i,j\in[1,m]$</span>, in qiskit. The <span class=""math-container"">$H$</span> here is the qubit form Hamiltonian of some molecule obtained by the Jordan-Wigner transformation.</p>
",qc,unsymmetric observable estimation qiskit p assume span 1 set states like fock states fermions question compute quantity span 1 qiskit span h qubit form hamiltonian molecule obtained,"[(1, 0.046396863), (3, 0.77665627), (14, 0.13274784), (17, 0.038312834)]"
21586,21587.0,2021-10-18 17:51:53,4,920,"<p>The toric code and other popular codes can be decoded using minimum weight perfect matching.
Is this an optimal decoder? Here by optimal, I mean it gives the best logical error rate
vs physical error rate performance in depolarizing channel. &quot;Threshold&quot; is often used to characterize toric codes, does that assume optimal decoding or a particular type?</p>
",is the minimum weight perfect matching decoder optimal,<error-correction><stabilizer-code><toric-code>,2,0,,,"is the minimum weight perfect matching decoder optimal <p>The toric code and other popular codes can be decoded using minimum weight perfect matching.
Is this an optimal decoder? Here by optimal, I mean it gives the best logical error rate
vs physical error rate performance in depolarizing channel. &quot;Threshold&quot; is often used to characterize toric codes, does that assume optimal decoding or a particular type?</p>
",qc,minimum weight perfect matching decoder optimal p toric code popular codes decoded using minimum weight perfect matching optimal decoder optimal mean gives best logical error rate vs physical error rate performance depolarizing channel quot threshold quot often used characterize toric codes assume optimal decoding particular type,"[(5, 0.59107745), (7, 0.039334983), (13, 0.0539295), (17, 0.26581734), (19, 0.046592865)]"
21618,21619.0,2021-10-20 18:41:04,3,635,"<p>I'm running simulations using Stim to get logical error rate vs. physical error rates of some quantum error correcting codes (<a href=""https://en.wikipedia.org/wiki/Quantum_error_correction"" rel=""nofollow noreferrer"">QECC</a>).</p>
<p>I looked into the documentation, but I'm confused about the meaning of &quot;shots&quot; and &quot;rounds&quot;. I think I understand the meaning of &quot;shots&quot;: repeat the state generation, add random noise at physical error rate, measure, decode, count logical errors. How would the &quot;rounds&quot; parameter enter the picture? Why would I need more than one round of measurement? (Assuming each round measures all stabilizers.)</p>
<p>Here a code sniplet of an example:</p>
<pre><code>def Test():
 num_shots = 1000
 xs = []
 ys = []
 for noise in [0.1, 0.2, 0.3, 0.4, 0.5]:
  circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_z&quot;,distance=3,rounds=1,before_round_data_depolarization=noise)
  xs.append(noise)
  ys.append(count_logical_errors(circuit, num_shots) / num_shots)
 plt.plot(xs, ys)
 plt.semilogy()
 plt.xlabel(&quot;physical error rate&quot;)
 plt.ylabel(&quot;logical error rate&quot;)
 plt.show()
</code></pre>
","What is the meaning of ""shots"" and ""rounds"" in Stim?",<programming><error-correction><stim>,1,1,,,"What is the meaning of ""shots"" and ""rounds"" in Stim? <p>I'm running simulations using Stim to get logical error rate vs. physical error rates of some quantum error correcting codes (<a href=""https://en.wikipedia.org/wiki/Quantum_error_correction"" rel=""nofollow noreferrer"">QECC</a>).</p>
<p>I looked into the documentation, but I'm confused about the meaning of &quot;shots&quot; and &quot;rounds&quot;. I think I understand the meaning of &quot;shots&quot;: repeat the state generation, add random noise at physical error rate, measure, decode, count logical errors. How would the &quot;rounds&quot; parameter enter the picture? Why would I need more than one round of measurement? (Assuming each round measures all stabilizers.)</p>
<p>Here a code sniplet of an example:</p>
<pre><code>def Test():
 num_shots = 1000
 xs = []
 ys = []
 for noise in [0.1, 0.2, 0.3, 0.4, 0.5]:
  circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_z&quot;,distance=3,rounds=1,before_round_data_depolarization=noise)
  xs.append(noise)
  ys.append(count_logical_errors(circuit, num_shots) / num_shots)
 plt.plot(xs, ys)
 plt.semilogy()
 plt.xlabel(&quot;physical error rate&quot;)
 plt.ylabel(&quot;logical error rate&quot;)
 plt.show()
</code></pre>
",qc,meaning shots rounds stim p running simulations using stim get logical error rate physical error rates quantum error correcting codes https nofollow noreferrer qecc p looked documentation confused meaning quot shots quot quot rounds quot think understand meaning quot shots quot repeat state generation add random noise physical error rate measure decode count logical errors would quot rounds quot parameter enter picture would need one round measurement assuming round measures stabilizers p code sniplet example pre code def test 1000 xs ys noise circuit quot quot noise circuit xs ys quot physical error rate quot quot logical error rate quot,"[(4, 0.060117703), (5, 0.43565765), (14, 0.29888672), (17, 0.03624055), (19, 0.1675539)]"
21623,21624.0,2021-10-21 10:40:17,2,148,"<p>Exercise 2.6 in Preskill's notes (chapter 2, around page 48, pdf available <a href=""http://theory.caltech.edu/%7Epreskill/ph219/chap2_15.pdf"" rel=""nofollow noreferrer"">here</a>) asks to prove that an arbitrary state <span class=""math-container"">$\rho=\sum_i p_i |\alpha_i\rangle\!\langle\alpha_i|$</span>, where <span class=""math-container"">$p_i$</span> and <span class=""math-container"">$|\alpha_i\rangle$</span> are obtained from the spectral decomposition of <span class=""math-container"">$\rho$</span>, can be also decomposed as
<span class=""math-container"">$$\rho = \sum_\mu q_\mu |\varphi_\mu\rangle\!\langle \varphi_\mu|,$$</span>
for some ensemble of pure states <span class=""math-container"">$|\varphi_\mu\rangle$</span>, if and only if <span class=""math-container"">$q\preceq p$</span>, that is, if and only if there is some doubly stochastic matrix <span class=""math-container"">$D$</span> such that <span class=""math-container"">$q_\mu=\sum_i D_{\mu i}p_i$</span>.</p>
<p>As a hint, he remembers that the two decompositions above are simultaneously possible if and only if
<span class=""math-container"">$$\sqrt{q_\mu}|\varphi_\mu\rangle = \sum_i \sqrt{p_i} V_{\mu i}|\alpha_i\rangle,$$</span>
for some unitary <span class=""math-container"">$V$</span>. He also says we can use Horn's lemma: if <span class=""math-container"">$q\preceq p$</span> then <span class=""math-container"">$q=Dp$</span> with <span class=""math-container"">$D_{\mu i}=|U_{\mu i}|^2$</span> for some unitary <span class=""math-container"">$U$</span>.</p>
<p>I understand why the statements in the hints hold, but I'm not sure how to apply them to the given exercise. I tried using the above relation to isolate <span class=""math-container"">$q_\mu$</span>, but then I get
<span class=""math-container"">$$\sqrt{q_\mu} = \sum_i \sqrt{p_i} V_{\mu i}\langle \varphi_\mu|\alpha_i\rangle
\implies q_\mu = \sum_{ij} \sqrt{p_i p_j} V_{\mu i}\bar V_{\mu j} \langle \varphi_\mu|\alpha_i\rangle \langle\alpha_j|\varphi_\mu\rangle,$$</span>
which I'm not sure how to reframe as <span class=""math-container"">$q=Dp$</span>.
On the other hand, taking the expectation value over <span class=""math-container"">$|\alpha_i\rangle$</span>, I get the relation
<span class=""math-container"">$$p_i = \sum_\mu q_\mu |\langle\alpha_i|\varphi_\mu\rangle|^2,$$</span>
but again, this amounts to <span class=""math-container"">$p=A q$</span> for some <span class=""math-container"">$A$</span> about which we only know the <em>columns</em> sum to one. Besides, even if <span class=""math-container"">$A$</span> was doubly stochastic, the relation would be in the wrong direction.</p>
<p>Shur-Horn's theorem (if <span class=""math-container"">$\rho$</span> is Hermitian then <span class=""math-container"">$\operatorname{diag}(\rho)\preceq \operatorname{spec}(\rho)$</span>) seems to be also relevant, but the diagonal of <span class=""math-container"">$\rho$</span> in the above notation would have elements <span class=""math-container"">$q'_i = \sum_\mu q_\mu |\langle i|\varphi_\mu\rangle|^2$</span>, so we'd get <span class=""math-container"">$q'\preceq p$</span>, which is not quite the same as <span class=""math-container"">$q\preceq p$</span> as far as I can tell.
With <span class=""math-container"">$\operatorname{spec}(\rho)$</span> I mean the vector whose elements are the eivanvalues of <span class=""math-container"">$\rho$</span>.</p>
",Why can we write $\rho=\sum_\mu q_\mu|\varphi_\mu\rangle\!\langle\varphi_\mu|$ iff $q\preceq \mathrm{spec}(\rho)$?,<quantum-state><textbook-and-exercises><majorization>,1,0,,,"Why can we write $\rho=\sum_\mu q_\mu|\varphi_\mu\rangle\!\langle\varphi_\mu|$ iff $q\preceq \mathrm{spec}(\rho)$? <p>Exercise 2.6 in Preskill's notes (chapter 2, around page 48, pdf available <a href=""http://theory.caltech.edu/%7Epreskill/ph219/chap2_15.pdf"" rel=""nofollow noreferrer"">here</a>) asks to prove that an arbitrary state <span class=""math-container"">$\rho=\sum_i p_i |\alpha_i\rangle\!\langle\alpha_i|$</span>, where <span class=""math-container"">$p_i$</span> and <span class=""math-container"">$|\alpha_i\rangle$</span> are obtained from the spectral decomposition of <span class=""math-container"">$\rho$</span>, can be also decomposed as
<span class=""math-container"">$$\rho = \sum_\mu q_\mu |\varphi_\mu\rangle\!\langle \varphi_\mu|,$$</span>
for some ensemble of pure states <span class=""math-container"">$|\varphi_\mu\rangle$</span>, if and only if <span class=""math-container"">$q\preceq p$</span>, that is, if and only if there is some doubly stochastic matrix <span class=""math-container"">$D$</span> such that <span class=""math-container"">$q_\mu=\sum_i D_{\mu i}p_i$</span>.</p>
<p>As a hint, he remembers that the two decompositions above are simultaneously possible if and only if
<span class=""math-container"">$$\sqrt{q_\mu}|\varphi_\mu\rangle = \sum_i \sqrt{p_i} V_{\mu i}|\alpha_i\rangle,$$</span>
for some unitary <span class=""math-container"">$V$</span>. He also says we can use Horn's lemma: if <span class=""math-container"">$q\preceq p$</span> then <span class=""math-container"">$q=Dp$</span> with <span class=""math-container"">$D_{\mu i}=|U_{\mu i}|^2$</span> for some unitary <span class=""math-container"">$U$</span>.</p>
<p>I understand why the statements in the hints hold, but I'm not sure how to apply them to the given exercise. I tried using the above relation to isolate <span class=""math-container"">$q_\mu$</span>, but then I get
<span class=""math-container"">$$\sqrt{q_\mu} = \sum_i \sqrt{p_i} V_{\mu i}\langle \varphi_\mu|\alpha_i\rangle
\implies q_\mu = \sum_{ij} \sqrt{p_i p_j} V_{\mu i}\bar V_{\mu j} \langle \varphi_\mu|\alpha_i\rangle \langle\alpha_j|\varphi_\mu\rangle,$$</span>
which I'm not sure how to reframe as <span class=""math-container"">$q=Dp$</span>.
On the other hand, taking the expectation value over <span class=""math-container"">$|\alpha_i\rangle$</span>, I get the relation
<span class=""math-container"">$$p_i = \sum_\mu q_\mu |\langle\alpha_i|\varphi_\mu\rangle|^2,$$</span>
but again, this amounts to <span class=""math-container"">$p=A q$</span> for some <span class=""math-container"">$A$</span> about which we only know the <em>columns</em> sum to one. Besides, even if <span class=""math-container"">$A$</span> was doubly stochastic, the relation would be in the wrong direction.</p>
<p>Shur-Horn's theorem (if <span class=""math-container"">$\rho$</span> is Hermitian then <span class=""math-container"">$\operatorname{diag}(\rho)\preceq \operatorname{spec}(\rho)$</span>) seems to be also relevant, but the diagonal of <span class=""math-container"">$\rho$</span> in the above notation would have elements <span class=""math-container"">$q'_i = \sum_\mu q_\mu |\langle i|\varphi_\mu\rangle|^2$</span>, so we'd get <span class=""math-container"">$q'\preceq p$</span>, which is not quite the same as <span class=""math-container"">$q\preceq p$</span> as far as I can tell.
With <span class=""math-container"">$\operatorname{spec}(\rho)$</span> I mean the vector whose elements are the eivanvalues of <span class=""math-container"">$\rho$</span>.</p>
",qc,write iff spec p exercise preskill notes chapter 2 around page 48 pdf available http nofollow noreferrer asks prove arbitrary state span span span obtained spectral decomposition span also decomposed span ensemble pure states span span p doubly stochastic matrix span span p hint remembers two decompositions simultaneously possible span unitary span v also says use horn lemma span p span span unitary span u p understand statements hints hold sure apply given exercise tried using relation isolate span get span ij j sure reframe span hand taking expectation value span get relation span amounts span q span know em columns sum one besides even span doubly stochastic relation would wrong p theorem span hermitian span diag spec seems also relevant diagonal span notation would elements span get span p quite span p far tell span spec mean vector whose elements eivanvalues span,"[(3, 0.8759975), (9, 0.09209851), (17, 0.030682337)]"
21665,21666.0,2021-10-25 09:32:25,4,163,"<p>From the Qiskit textbook I read about <a href=""https://learn.qiskit.org/course/ch-algorithms/simons-algorithm#algorithm"" rel=""nofollow noreferrer"">Simon's algorithm</a>.
There are two n-wide quantum registers, so the general state is given by</p>
<p><span class=""math-container"">$$|x\rangle_n|y\rangle_n$$</span></p>
<p>where x and y are the <span class=""math-container"">$2^n-1$</span> binary representations.
A function from the n-subspace into n-subspace id defined by</p>
<p><span class=""math-container"">$$f: |x\rangle\mapsto|f(x)\rangle$$</span></p>
<p>Now, the &quot;query function&quot; is given by the operation</p>
<p><span class=""math-container"">$$|x\rangle|a\rangle \rightarrow |x\rangle |a \oplus f(x)\rangle$$</span></p>
<p>All building blocks in quantum computation shall be unitary transformations, so this mapping is unitary too - but how can I prove that this is really the case?</p>
<p>Is it enough to show, that norm is conserved like this:</p>
<p>Denoting</p>
<p><span class=""math-container"">$$U|x\rangle|a\rangle = |x\rangle |a \oplus f(x)\rangle$$</span></p>
<p>I would have</p>
<p><span class=""math-container"">$$\langle x| \langle a|U^\dagger = \langle x| \langle a \oplus f(x)|$$</span></p>
<p>so
<span class=""math-container"">$$\langle x| \langle a|U^\dagger U |x\rangle |a\rangle= \langle x|x\rangle \langle a \oplus f(x)|a \oplus f(x)\rangle = 1 \cdot 1 = 1$$</span></p>
<p>But this appears a bit too trivial to be a prove...</p>
",Why is the function operator used in Simon's algorithm unitary?,<quantum-gate><quantum-algorithms><simons-algorithm>,1,0,,,"Why is the function operator used in Simon's algorithm unitary? <p>From the Qiskit textbook I read about <a href=""https://learn.qiskit.org/course/ch-algorithms/simons-algorithm#algorithm"" rel=""nofollow noreferrer"">Simon's algorithm</a>.
There are two n-wide quantum registers, so the general state is given by</p>
<p><span class=""math-container"">$$|x\rangle_n|y\rangle_n$$</span></p>
<p>where x and y are the <span class=""math-container"">$2^n-1$</span> binary representations.
A function from the n-subspace into n-subspace id defined by</p>
<p><span class=""math-container"">$$f: |x\rangle\mapsto|f(x)\rangle$$</span></p>
<p>Now, the &quot;query function&quot; is given by the operation</p>
<p><span class=""math-container"">$$|x\rangle|a\rangle \rightarrow |x\rangle |a \oplus f(x)\rangle$$</span></p>
<p>All building blocks in quantum computation shall be unitary transformations, so this mapping is unitary too - but how can I prove that this is really the case?</p>
<p>Is it enough to show, that norm is conserved like this:</p>
<p>Denoting</p>
<p><span class=""math-container"">$$U|x\rangle|a\rangle = |x\rangle |a \oplus f(x)\rangle$$</span></p>
<p>I would have</p>
<p><span class=""math-container"">$$\langle x| \langle a|U^\dagger = \langle x| \langle a \oplus f(x)|$$</span></p>
<p>so
<span class=""math-container"">$$\langle x| \langle a|U^\dagger U |x\rangle |a\rangle= \langle x|x\rangle \langle a \oplus f(x)|a \oplus f(x)\rangle = 1 \cdot 1 = 1$$</span></p>
<p>But this appears a bit too trivial to be a prove...</p>
",qc,function operator used simon algorithm unitary p qiskit textbook read https algorithm nofollow noreferrer simon algorithm two quantum registers general state given p span p x span binary representations function id defined p span f x p quot query function quot given operation p span f x p building blocks quantum computation shall unitary transformations mapping unitary prove really case p enough show norm conserved like p denoting p span f x p would p span f x p span u f x f x 1 1 1 p appears bit trivial prove,"[(3, 0.4091251), (4, 0.09033141), (10, 0.3671824), (13, 0.09737926), (17, 0.010632759), (19, 0.023846509)]"
21676,21685.0,2021-10-26 03:09:20,0,407,"<p>I was thinking to ask this on Math Stackexchange, but maybe here would be better since I also hope the answers also explain from quantum computation context.</p>
<h2>Problem</h2>
<p>So I was reading the paper <a href=""https://tches.iacr.org/index.php/TCHES/article/view/8741"" rel=""nofollow noreferrer"">&quot;Concrete quantum-cryptanalysis of binary elliptic curves&quot;</a>, and I got stuck in understanding how to construct <strong>a multiplication by constant circuit for binary field</strong>. In their <a href=""https://youtu.be/LPOqI9BnTjE?t=638"" rel=""nofollow noreferrer"">CHES presentation</a> and <a href=""https://eprint.iacr.org/2019/1170.pdf"" rel=""nofollow noreferrer"">their other paper</a>, the authors describe that it is easy to construct the circuit from a matrix since multiplication by constant is just a linear mapping.</p>
<p>On <a href=""https://eprint.iacr.org/2019/1170.pdf"" rel=""nofollow noreferrer"">their other paper</a>, they present this matrix as a representation of multiplication by <span class=""math-container"">$1 + x^2$</span> modulo <span class=""math-container"">$1 + x + x^4$</span>:</p>
<p><span class=""math-container"">$\Gamma =  \begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 1 
\end{bmatrix}  $</span></p>
<p>which by LUP decomposition, corresponds to this circuit:</p>
<p><a href=""https://i.sstatic.net/Ot6fR.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ot6fR.png"" alt=""enter image description here"" /></a></p>
<h2>Questions</h2>
<p>The questions are interrelated. They are:</p>
<p><strong>1. How to construct matrix <span class=""math-container"">$\Gamma$</span>?</strong></p>
<p><strong>2. Why the multiplication matrix is a 4x4 matrix for a 4-qubit circuit? I thought it would be 16x16 <span class=""math-container"">$(2^n = 16)$</span>?</strong></p>
<p><strong>3. Is that particular matrix (<span class=""math-container"">$\Gamma$</span>) really correct for all values?</strong></p>
<h2>My Attempts So Far</h2>
<h3>For Question 1</h3>
<p>My guess is by creating two matrices, e.g., <span class=""math-container"">$INPUT$</span> and <span class=""math-container"">$OUTPUT$</span>, which includes all possible inputs and the corresponding output after the constant multiplication. Then, the matrix <span class=""math-container"">$\Gamma$</span> can be obtained from <span class=""math-container"">$OUTPUT * INPUT^{-1}$</span>.</p>
<p>I have tried from scratch: calculated all the possible 16 input and the corresponding output pairs (derived from SageMath) and make the mapping (i.e., <span class=""math-container"">$\left| x0,x,x^2,x^3 \right&gt; = \left| 0010 \right&gt; \rightarrow \left| 1110 \right&gt;, \left| 0100 \right&gt; \rightarrow \left| 0101 \right&gt;$</span>, and so on...</p>
<p>However, then I realized that the resulting matrix is a rectangular 16x4 matrix rather than a square matrix for each <span class=""math-container"">$INPUT$</span> and <span class=""math-container"">$OUTPUT$</span>, so the inversion can not be done when I tried that on Matlab.</p>
<h3>For Question 3</h3>
<p>For each possible input, I applied <span class=""math-container"">$\Gamma$</span> to verify the output result. While 6 of them are correct, the other 10 are wrong. For example, <span class=""math-container"">$\left| 1011 \right&gt; \rightarrow \left| 2231 \right&gt;$</span> rather than <span class=""math-container"">$\left| 0011 \right&gt; $</span>.</p>
<p>I am not sure that kind of paper would contain such errors. So my bet is my approach was all wrong.</p>
<p>I would be very grateful if anyone could guide me on this. Any help is appreciated. Thanks!</p>
",Understanding Constant Multiplication Circuit for Binary Field - How to Construct Quantum Circuit from Linear Mapping,<quantum-circuit><matrix-representation>,1,3,,,"Understanding Constant Multiplication Circuit for Binary Field - How to Construct Quantum Circuit from Linear Mapping <p>I was thinking to ask this on Math Stackexchange, but maybe here would be better since I also hope the answers also explain from quantum computation context.</p>
<h2>Problem</h2>
<p>So I was reading the paper <a href=""https://tches.iacr.org/index.php/TCHES/article/view/8741"" rel=""nofollow noreferrer"">&quot;Concrete quantum-cryptanalysis of binary elliptic curves&quot;</a>, and I got stuck in understanding how to construct <strong>a multiplication by constant circuit for binary field</strong>. In their <a href=""https://youtu.be/LPOqI9BnTjE?t=638"" rel=""nofollow noreferrer"">CHES presentation</a> and <a href=""https://eprint.iacr.org/2019/1170.pdf"" rel=""nofollow noreferrer"">their other paper</a>, the authors describe that it is easy to construct the circuit from a matrix since multiplication by constant is just a linear mapping.</p>
<p>On <a href=""https://eprint.iacr.org/2019/1170.pdf"" rel=""nofollow noreferrer"">their other paper</a>, they present this matrix as a representation of multiplication by <span class=""math-container"">$1 + x^2$</span> modulo <span class=""math-container"">$1 + x + x^4$</span>:</p>
<p><span class=""math-container"">$\Gamma =  \begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 1 
\end{bmatrix}  $</span></p>
<p>which by LUP decomposition, corresponds to this circuit:</p>
<p><a href=""https://i.sstatic.net/Ot6fR.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ot6fR.png"" alt=""enter image description here"" /></a></p>
<h2>Questions</h2>
<p>The questions are interrelated. They are:</p>
<p><strong>1. How to construct matrix <span class=""math-container"">$\Gamma$</span>?</strong></p>
<p><strong>2. Why the multiplication matrix is a 4x4 matrix for a 4-qubit circuit? I thought it would be 16x16 <span class=""math-container"">$(2^n = 16)$</span>?</strong></p>
<p><strong>3. Is that particular matrix (<span class=""math-container"">$\Gamma$</span>) really correct for all values?</strong></p>
<h2>My Attempts So Far</h2>
<h3>For Question 1</h3>
<p>My guess is by creating two matrices, e.g., <span class=""math-container"">$INPUT$</span> and <span class=""math-container"">$OUTPUT$</span>, which includes all possible inputs and the corresponding output after the constant multiplication. Then, the matrix <span class=""math-container"">$\Gamma$</span> can be obtained from <span class=""math-container"">$OUTPUT * INPUT^{-1}$</span>.</p>
<p>I have tried from scratch: calculated all the possible 16 input and the corresponding output pairs (derived from SageMath) and make the mapping (i.e., <span class=""math-container"">$\left| x0,x,x^2,x^3 \right&gt; = \left| 0010 \right&gt; \rightarrow \left| 1110 \right&gt;, \left| 0100 \right&gt; \rightarrow \left| 0101 \right&gt;$</span>, and so on...</p>
<p>However, then I realized that the resulting matrix is a rectangular 16x4 matrix rather than a square matrix for each <span class=""math-container"">$INPUT$</span> and <span class=""math-container"">$OUTPUT$</span>, so the inversion can not be done when I tried that on Matlab.</p>
<h3>For Question 3</h3>
<p>For each possible input, I applied <span class=""math-container"">$\Gamma$</span> to verify the output result. While 6 of them are correct, the other 10 are wrong. For example, <span class=""math-container"">$\left| 1011 \right&gt; \rightarrow \left| 2231 \right&gt;$</span> rather than <span class=""math-container"">$\left| 0011 \right&gt; $</span>.</p>
<p>I am not sure that kind of paper would contain such errors. So my bet is my approach was all wrong.</p>
<p>I would be very grateful if anyone could guide me on this. Any help is appreciated. Thanks!</p>
",qc,understanding constant multiplication circuit binary field construct quantum circuit linear mapping p thinking ask math stackexchange maybe would better since also hope answers also explain quantum computation h2 problem p reading paper https nofollow noreferrer quot concrete binary elliptic curves quot got stuck understanding construct strong multiplication constant circuit binary field https nofollow noreferrer ches presentation https nofollow noreferrer paper authors describe easy construct circuit matrix since multiplication constant linear p https nofollow noreferrer paper present matrix representation multiplication span 1 modulo span 1 x p span bmatrix 1 amp 0 amp 1 amp 0 0 amp 1 amp 1 amp 1 1 amp 0 amp 1 amp 1 0 amp 1 amp 0 amp 1 bmatrix p lup decomposition corresponds circuit p https nofollow noreferrer img https enter image description h2 questions p questions interrelated p strong 1 construct matrix span p strong 2 multiplication matrix 4x4 matrix circuit thought would 16x16 span 16 p strong 3 particular matrix span really correct values h2 attempts far h3 question 1 p guess creating two matrices span input span output includes possible inputs corresponding output constant multiplication matrix span obtained span output p tried scratch calculated possible 16 input corresponding output pairs derived sagemath make mapping span x0 x gt 0010 gt 1110 gt 0100 gt 0101 gt p however realized resulting matrix rectangular 16x4 matrix rather square matrix span input span output inversion done tried h3 question 3 p possible input applied span verify output result 6 correct 10 wrong example span 1011 gt 2231 gt rather span 0011 gt p sure kind paper would contain errors bet approach p would grateful anyone could guide help appreciated thanks,"[(0, 0.036626656), (2, 0.07343809), (3, 0.18535315), (4, 0.20001861), (6, 0.019469943), (7, 0.06284285), (10, 0.029252203), (11, 0.031731457), (13, 0.15849796), (14, 0.07283071), (15, 0.10254909), (17, 0.011800647), (19, 0.011639811)]"
21717,,2021-10-28 14:23:24,1,226,"<p>Is it possible to run qasm files on jupyter notebook (like with the qasm_simulator)?
I downloaded one code file and I would like to play around with it on jupyter notebook.</p>
",QASM Files on Jupyter Notebook,<programming><qasm>,1,1,,,"QASM Files on Jupyter Notebook <p>Is it possible to run qasm files on jupyter notebook (like with the qasm_simulator)?
I downloaded one code file and I would like to play around with it on jupyter notebook.</p>
",qc,qasm files jupyter notebook p possible run qasm files jupyter notebook like downloaded one code file would like play around jupyter,"[(0, 0.15996751), (14, 0.6887385), (17, 0.1432707)]"
21727,,2021-10-29 11:44:48,1,210,"<p>Suppose I have two quantum registers described respectively by the quantum states <span class=""math-container"">$| \psi_1 \rangle = \sum_i \alpha_i |i \rangle$</span> and <span class=""math-container"">$|\psi_2 \rangle = |0\rangle$</span>. I would like to implement a CNOT gate where the target is <span class=""math-container"">$|\psi_2\rangle$</span> and the control is the basis state <span class=""math-container"">$| i \rangle$</span>of <span class=""math-container"">$|\psi_1\rangle$</span> with the higher <span class=""math-container"">$|\alpha_i|^2$</span>.</p>
<p>Is there some primitive I can use?</p>
",How to determine the basis state with maximum amplitude without measurement?,<quantum-state><circuit-construction><quantum-circuit>,1,3,,,"How to determine the basis state with maximum amplitude without measurement? <p>Suppose I have two quantum registers described respectively by the quantum states <span class=""math-container"">$| \psi_1 \rangle = \sum_i \alpha_i |i \rangle$</span> and <span class=""math-container"">$|\psi_2 \rangle = |0\rangle$</span>. I would like to implement a CNOT gate where the target is <span class=""math-container"">$|\psi_2\rangle$</span> and the control is the basis state <span class=""math-container"">$| i \rangle$</span>of <span class=""math-container"">$|\psi_1\rangle$</span> with the higher <span class=""math-container"">$|\alpha_i|^2$</span>.</p>
<p>Is there some primitive I can use?</p>
",qc,determine basis state maximum amplitude without measurement p suppose two quantum registers described respectively quantum states span span would like implement cnot gate target span control basis state span span higher span p primitive use,"[(3, 0.32807338), (17, 0.030117804), (18, 0.6369779)]"
21731,,2021-10-29 15:57:31,0,231,"<p>I've been dealing with a QAOA implementation of a QUBO problem. In order to do this, I converted my QUBO matrix to a <code>QuadraticModel</code>. Once done, I have used <code>Hamiltonian, offset  = mdl.to_ising()</code> to generate a <code>Hamiltonian</code> and <code>offset</code>, with <code>mdl</code> being my <code>QuadraticProgram</code>.</p>
<p>Once done, I went on to verify theoretically that the ground state energy of this Hamiltonian tallies with results an annealer. In order to do this, I used:</p>
<p><code>min_val = NumPyMinimumEigensolver(Hamiltonian)</code></p>
<p>Sure enough, this matches. The ground state energy when added with the <code>offset</code> value brings the value to 0. Now when I am trying to implement a QAOA, I use the following lines of code. I am aware that I am using deprecated code but I'm not sure this contributes to the problem.</p>
<pre><code>aqua_globals.random_seed = np.random.default_rng(123)
seed = 10598
backend = Aer.get_backend('qasm_simulator')
quantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed)
qaoa = QAOA(quantum_instance=quantum_instance, p = 1)
qaoa_optimizer = MinimumEigenOptimizer(qaoa)
result = qaoa_optimizer.solve(mdl)
</code></pre>
<p>This gives me <code>optimal function value: 2.0</code> which isn't the result I am looking for.</p>
<p>I think I'm going wrong somewhere in the implementation of the QAOA, but I'm not sure where. Any help in this regard would be absolutely stellar!</p>
",Correct implementation of Qiskit QAOA,<qiskit><programming><qaoa><qubo>,0,2,,,"Correct implementation of Qiskit QAOA <p>I've been dealing with a QAOA implementation of a QUBO problem. In order to do this, I converted my QUBO matrix to a <code>QuadraticModel</code>. Once done, I have used <code>Hamiltonian, offset  = mdl.to_ising()</code> to generate a <code>Hamiltonian</code> and <code>offset</code>, with <code>mdl</code> being my <code>QuadraticProgram</code>.</p>
<p>Once done, I went on to verify theoretically that the ground state energy of this Hamiltonian tallies with results an annealer. In order to do this, I used:</p>
<p><code>min_val = NumPyMinimumEigensolver(Hamiltonian)</code></p>
<p>Sure enough, this matches. The ground state energy when added with the <code>offset</code> value brings the value to 0. Now when I am trying to implement a QAOA, I use the following lines of code. I am aware that I am using deprecated code but I'm not sure this contributes to the problem.</p>
<pre><code>aqua_globals.random_seed = np.random.default_rng(123)
seed = 10598
backend = Aer.get_backend('qasm_simulator')
quantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed)
qaoa = QAOA(quantum_instance=quantum_instance, p = 1)
qaoa_optimizer = MinimumEigenOptimizer(qaoa)
result = qaoa_optimizer.solve(mdl)
</code></pre>
<p>This gives me <code>optimal function value: 2.0</code> which isn't the result I am looking for.</p>
<p>I think I'm going wrong somewhere in the implementation of the QAOA, but I'm not sure where. Any help in this regard would be absolutely stellar!</p>
",qc,correct implementation qiskit qaoa p dealing qaoa implementation qubo problem order converted qubo matrix code quadraticmodel done used code hamiltonian offset generate code hamiltonian code offset code mdl code quadraticprogram p done went verify theoretically ground state energy hamiltonian tallies results annealer order used p code numpyminimumeigensolver hamiltonian p sure enough matches ground state energy added code offset value brings value trying implement qaoa use following lines code aware using deprecated code sure contributes pre code 123 seed 10598 backend quantuminstance backend qaoa qaoa p 1 minimumeigenoptimizer qaoa result mdl p gives code optimal function value result looking p think going wrong somewhere implementation qaoa sure help regard would absolutely stellar,"[(0, 0.5061451), (1, 0.13714422), (5, 0.023694543), (13, 0.053929847), (14, 0.22546364), (15, 0.013279016), (17, 0.022122761)]"
21748,21749.0,2021-11-01 04:45:38,5,1081,"<p>There are a couple of posts on this question, but I think they are not satisfactory. The question is Nielsen and Chuang's QCQI, Exercise 1.2, page 57, which asks &quot;Explain how a device which, upon input of two non-orthogonal states correctly identified the state, could be used to build a device which cloned the states...&quot; The answer offered <a href=""https://quantumcomputing.stackexchange.com/questions/2255/no-cloning-theorem-and-distinguishing-between-two-non-orthogonal-quantum-states"">here</a> is that if you knew the state you could synthesize a copy of it. That sounds convincing but I notice that they do not use the condition that the states are not orthogonal. Clearly, orthogonal states can be distinguished and yet doing so cannot lead to cloning. So the posted answer seems to be incomplete or incorrect.</p>
<p>If was assume that the hypothetical circuit that distinguishes non-orthogonal states outputs a qubit <span class=""math-container"">$|0\rangle$</span> for the first case and <span class=""math-container"">$|1\rangle$</span> for the second case, then I think it is easy to show that the circuit would not be unitary. So in a sense this is an answer to the exercise, but not exactly since it doesn't mention cloning.</p>
",No-cloning theorem and distinguishing between two non-orthogonal quantum states revisited,<quantum-state><nielsen-and-chuang><information-theory><no-cloning-theorem><cloning>,1,0,,,"No-cloning theorem and distinguishing between two non-orthogonal quantum states revisited <p>There are a couple of posts on this question, but I think they are not satisfactory. The question is Nielsen and Chuang's QCQI, Exercise 1.2, page 57, which asks &quot;Explain how a device which, upon input of two non-orthogonal states correctly identified the state, could be used to build a device which cloned the states...&quot; The answer offered <a href=""https://quantumcomputing.stackexchange.com/questions/2255/no-cloning-theorem-and-distinguishing-between-two-non-orthogonal-quantum-states"">here</a> is that if you knew the state you could synthesize a copy of it. That sounds convincing but I notice that they do not use the condition that the states are not orthogonal. Clearly, orthogonal states can be distinguished and yet doing so cannot lead to cloning. So the posted answer seems to be incomplete or incorrect.</p>
<p>If was assume that the hypothetical circuit that distinguishes non-orthogonal states outputs a qubit <span class=""math-container"">$|0\rangle$</span> for the first case and <span class=""math-container"">$|1\rangle$</span> for the second case, then I think it is easy to show that the circuit would not be unitary. So in a sense this is an answer to the exercise, but not exactly since it doesn't mention cloning.</p>
",qc,theorem distinguishing two quantum states revisited p couple posts question think satisfactory question nielsen chuang qcqi exercise page 57 asks quot explain device upon input two states correctly identified state could used build device cloned states quot answer offered https knew state could synthesize copy sounds convincing notice use condition states orthogonal clearly orthogonal states distinguished yet lead cloning posted answer seems incomplete p assume hypothetical circuit distinguishes states outputs qubit span first case span second case think easy show circuit would unitary sense answer exercise exactly since mention,"[(3, 0.2880399), (9, 0.16775975), (13, 0.20041499), (14, 0.14427553), (17, 0.050023116), (18, 0.12509385), (19, 0.022917356)]"
21769,21770.0,2021-11-02 01:21:46,8,2112,"<p>It is often said that one of the early applications for Quantum Computers will be drug discovery.</p>
<p>Q: Roughly speaking, How many qubits will be needed to study (or simulate) a molecule such as: <span class=""math-container"">$C_{29}H_{31}N_{7}O$</span> (Imatinib, sold under the brand name Gleevec &amp; Glivec ) ?</p>
<p>Or in general, if a molecule has 100 atoms, how many qubits will be needed to simulate it ?</p>
","Roughly speaking, How many qubits will be needed to study (or simulate) a molecule such as: C29H31N7O?",<quantum-state><simulation><chemistry>,1,0,,,"Roughly speaking, How many qubits will be needed to study (or simulate) a molecule such as: C29H31N7O? <p>It is often said that one of the early applications for Quantum Computers will be drug discovery.</p>
<p>Q: Roughly speaking, How many qubits will be needed to study (or simulate) a molecule such as: <span class=""math-container"">$C_{29}H_{31}N_{7}O$</span> (Imatinib, sold under the brand name Gleevec &amp; Glivec ) ?</p>
<p>Or in general, if a molecule has 100 atoms, how many qubits will be needed to simulate it ?</p>
",qc,roughly speaking many qubits needed study simulate molecule c29h31n7o p often said one early applications quantum computers drug p q roughly speaking many qubits needed study simulate molecule span 29 31 7 imatinib sold brand name gleevec amp glivec p general molecule 100 atoms many qubits needed simulate,"[(1, 0.20741376), (6, 0.026856456), (7, 0.21523109), (9, 0.3590992), (10, 0.025730256), (11, 0.024800044), (15, 0.031112162), (17, 0.106843464)]"
21802,,2021-11-04 22:41:41,4,556,"<p>It is often said that the molecule simulation for drug discovery will be one of the most important applications of Quantum Computing (QC).</p>
<p>As we all know that the entire process of new drug discovery is a long and costly process.</p>
<p><strong>How critical is the molecule simulation in the entire process of new drug discovery?</strong></p>
 
",Is molecule simulation by quantum computing critical for drug discovery?,<quantum-algorithms><chemistry><applications>,1,2,,,"Is molecule simulation by quantum computing critical for drug discovery? <p>It is often said that the molecule simulation for drug discovery will be one of the most important applications of Quantum Computing (QC).</p>
<p>As we all know that the entire process of new drug discovery is a long and costly process.</p>
<p><strong>How critical is the molecule simulation in the entire process of new drug discovery?</strong></p>
 
",qc,molecule simulation quantum computing critical drug discovery p often said molecule simulation drug discovery one important applications quantum computing qc p know entire process new drug discovery long costly p strong critical molecule simulation entire process new drug discovery,"[(1, 0.2620552), (5, 0.03591344), (8, 0.28720027), (9, 0.20676303), (14, 0.112831034), (17, 0.09125569)]"
21846,21848.0,2021-11-08 17:31:45,4,266,"<p>The <a href=""https://en.wikipedia.org/wiki/Fredkin_gate"" rel=""nofollow noreferrer"">Fredkin gate</a> is CSWAP gate. Given a control register in <span class=""math-container"">$0$</span> or <span class=""math-container"">$1$</span>, the gate does nothing or swaps two target registers respectively.</p>
<p><a href=""https://i.sstatic.net/Rnd4B.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Rnd4B.png"" alt=""enter image description here"" /></a></p>
<p>Is there a higher dimensional version of this gate? I have one d-dimensional control register (this takes values from the set <span class=""math-container"">$S = \{1, 2, ... , d\}$</span>) and <span class=""math-container"">$d$</span> target registers. If the control register takes on value <span class=""math-container"">$i\in S$</span>, then I would like to swap the first target register with the <span class=""math-container"">$i^{th}$</span> target register.</p>
",Is there a higher dimensional Fredkin gate?,<quantum-gate><circuit-construction><unitarity>,1,1,,,"Is there a higher dimensional Fredkin gate? <p>The <a href=""https://en.wikipedia.org/wiki/Fredkin_gate"" rel=""nofollow noreferrer"">Fredkin gate</a> is CSWAP gate. Given a control register in <span class=""math-container"">$0$</span> or <span class=""math-container"">$1$</span>, the gate does nothing or swaps two target registers respectively.</p>
<p><a href=""https://i.sstatic.net/Rnd4B.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Rnd4B.png"" alt=""enter image description here"" /></a></p>
<p>Is there a higher dimensional version of this gate? I have one d-dimensional control register (this takes values from the set <span class=""math-container"">$S = \{1, 2, ... , d\}$</span>) and <span class=""math-container"">$d$</span> target registers. If the control register takes on value <span class=""math-container"">$i\in S$</span>, then I would like to swap the first target register with the <span class=""math-container"">$i^{th}$</span> target register.</p>
",qc,higher dimensional fredkin gate p https nofollow noreferrer fredkin gate cswap gate given control register span 0 span 1 gate nothing swaps two target registers p https nofollow noreferrer img https enter image description p higher dimensional version gate one control register takes values set span 1 2 span target registers control register takes value span would like swap first target register span th target,"[(2, 0.051450633), (3, 0.19048977), (4, 0.26506624), (13, 0.13895726), (17, 0.041544046), (18, 0.31034425)]"
21852,,2021-11-09 04:44:40,1,297,"<p>I use the following code to calculate the ground state for the LiH molecule in an active space. I come across two problems. The first is I found that the Hartree Fock state gave energy that is far from the ground state energy. But the <code>qc</code> state is the true Hartree Fock state. The second problem is using the <code>ground_state</code>, it just outputs <code>0</code>. Can anybody help me with that?</p>
<pre><code>from qiskit import *
import numpy as np

#Circuit imports
from qiskit_nature.drivers import UnitsType
from qiskit_nature.drivers.second_quantization import PySCFDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.opflow.state_fns import StateFn, CircuitStateFn
import matplotlib
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity, Statevector
matplotlib.use('Agg')
np.set_printoptions(threshold=np.inf)

driver = PySCFDriver(atom='H .0, .0, .0; Li .0, .0, 0.5',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

# set parameters
molecule = &quot;LiH&quot;
set_as = True # set the active space or not
as_particle = 2 # number of particles in the active space
as_mol_orbital = 3 # number of molecular orbitals in the active space
at = ActiveSpaceTransformer(as_particle, as_mol_orbital, active_orbitals=[1,2,5])
ft = FreezeCoreTransformer()
as_problem = ElectronicStructureProblem(driver, transformers=[at])

# generate the second-quantized operators for active space
as_second_q_ops = as_problem.second_q_ops()
as_main_op = as_second_q_ops[0]

as_particle_number = as_problem.grouped_property_transformed.get_property(&quot;ParticleNumber&quot;)
as_num_particles = (as_particle_number.num_alpha, as_particle_number.num_beta)
as_num_spin_orbitals = as_particle_number.num_spin_orbitals

as_qubit_op = converter.convert(main_op, num_particles=num_particles)
as_init_state = HartreeFock(as_num_spin_orbitals, as_num_particles, converter)
qc = QuantumCircuit(as_num_spin_orbitals)
qc.x(1)
qc.x(3)

# calculate the energy
numpy_solver = NumPyMinimumEigensolver()
calc = GroundStateEigensolver(converter, numpy_solver)
calc.returns_groundstate()
as_res_ref = calc.solve(as_problem)
ground_state = as_res_ref.eigenstates[0]
print('G.S. energy is', as_res_ref.eigenenergies.min())
gse = (~ground_state @ as_qubit_op @ ground_state).eval()
print('Second G.S. energy is',gse)

e = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=as_init_state, coeff=1.)
e = e.eval()
print('HF state energy is',e)
e2 = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=qc, coeff=1.)
e2 = e2.eval()
print('qc state energy is',e2)
<span class=""math-container"">```</span>
</code></pre>
",Ground state compute issue by qiskit,<qiskit><programming><vqe>,0,4,,,"Ground state compute issue by qiskit <p>I use the following code to calculate the ground state for the LiH molecule in an active space. I come across two problems. The first is I found that the Hartree Fock state gave energy that is far from the ground state energy. But the <code>qc</code> state is the true Hartree Fock state. The second problem is using the <code>ground_state</code>, it just outputs <code>0</code>. Can anybody help me with that?</p>
<pre><code>from qiskit import *
import numpy as np

#Circuit imports
from qiskit_nature.drivers import UnitsType
from qiskit_nature.drivers.second_quantization import PySCFDriver
from qiskit_nature.problems.second_quantization.electronic import ElectronicStructureProblem
from qiskit_nature.circuit.library import HartreeFock
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer, ActiveSpaceTransformer
from qiskit_nature.algorithms import GroundStateEigensolver
from qiskit_nature.results import EigenstateResult
from qiskit import Aer
from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.opflow.state_fns import StateFn, CircuitStateFn
import matplotlib
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity, Statevector
matplotlib.use('Agg')
np.set_printoptions(threshold=np.inf)

driver = PySCFDriver(atom='H .0, .0, .0; Li .0, .0, 0.5',
                     unit=UnitsType.ANGSTROM,
                     basis='sto3g')

# set parameters
molecule = &quot;LiH&quot;
set_as = True # set the active space or not
as_particle = 2 # number of particles in the active space
as_mol_orbital = 3 # number of molecular orbitals in the active space
at = ActiveSpaceTransformer(as_particle, as_mol_orbital, active_orbitals=[1,2,5])
ft = FreezeCoreTransformer()
as_problem = ElectronicStructureProblem(driver, transformers=[at])

# generate the second-quantized operators for active space
as_second_q_ops = as_problem.second_q_ops()
as_main_op = as_second_q_ops[0]

as_particle_number = as_problem.grouped_property_transformed.get_property(&quot;ParticleNumber&quot;)
as_num_particles = (as_particle_number.num_alpha, as_particle_number.num_beta)
as_num_spin_orbitals = as_particle_number.num_spin_orbitals

as_qubit_op = converter.convert(main_op, num_particles=num_particles)
as_init_state = HartreeFock(as_num_spin_orbitals, as_num_particles, converter)
qc = QuantumCircuit(as_num_spin_orbitals)
qc.x(1)
qc.x(3)

# calculate the energy
numpy_solver = NumPyMinimumEigensolver()
calc = GroundStateEigensolver(converter, numpy_solver)
calc.returns_groundstate()
as_res_ref = calc.solve(as_problem)
ground_state = as_res_ref.eigenstates[0]
print('G.S. energy is', as_res_ref.eigenenergies.min())
gse = (~ground_state @ as_qubit_op @ ground_state).eval()
print('Second G.S. energy is',gse)

e = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=as_init_state, coeff=1.)
e = e.eval()
print('HF state energy is',e)
e2 = ~StateFn(as_qubit_op) @ CircuitStateFn(primitive=qc, coeff=1.)
e2 = e2.eval()
print('qc state energy is',e2)
<span class=""math-container"">```</span>
</code></pre>
",qc,ground state compute issue qiskit p use following code calculate ground state lih molecule active space come across two problems first found hartree fock state gave energy far ground state energy code qc state true hartree fock state second problem using code outputs code 0 anybody help pre code qiskit import import numpy np circuit imports import unitstype import pyscfdriver import electronicstructureproblem import hartreefock import freezecoretransformer activespacetransformer import groundstateeigensolver import eigenstateresult qiskit import aer import paritymapper jordanwignermapper import qubitconverter import vqe numpyminimumeigensolver import statefn circuitstatefn import matplotlib import import statevector driver pyscfdriver h li set parameters molecule quot lih quot true set active space 2 number particles active space 3 number molecular orbitals active space activespacetransformer ft freezecoretransformer electronicstructureproblem driver generate operators active space 0 quot particlenumber quot hartreefock converter qc quantumcircuit 1 3 calculate energy numpyminimumeigensolver calc groundstateeigensolver converter 0 print energy gse print energy gse e circuitstatefn e print state energy e e2 circuitstatefn e2 print state energy e2 span,"[(0, 0.46991947), (2, 0.031786963), (8, 0.119148016), (12, 0.035118025), (17, 0.21228895), (18, 0.097197026), (19, 0.025000855)]"
21861,,2021-11-09 15:49:56,4,89,"<p>Is there any standard notation for two states &quot;equivalent up to a global phase&quot;?</p>
<p>Currently, I use just an equal sign but I'd like to use a different symbol to distinguish between two phases that are exactly the same (equal sign) and two phases which are &quot;equivalent up to a global phase&quot; (some other symbol).</p>
","Is there any standard notation for two states being ""equivalent up to a global phase""?",<terminology-and-notation>,0,2,,,"Is there any standard notation for two states being ""equivalent up to a global phase""? <p>Is there any standard notation for two states &quot;equivalent up to a global phase&quot;?</p>
<p>Currently, I use just an equal sign but I'd like to use a different symbol to distinguish between two phases that are exactly the same (equal sign) and two phases which are &quot;equivalent up to a global phase&quot; (some other symbol).</p>
",qc,standard notation two states equivalent global phase p standard notation two states quot equivalent global phase quot p currently use equal sign like use different symbol distinguish two phases exactly equal sign two phases quot equivalent global phase quot symbol,"[(9, 0.3179046), (13, 0.19078626), (17, 0.05051934), (18, 0.33397195), (19, 0.103085935)]"
21895,,2021-11-11 22:29:59,4,154,"<p>I was reading about the Toric code and how the boundary codes give it a shape of of a torus. Is it interesting to look at other ways to orient the edges of a square lattice? I.e. a mobius strip, Klein bottle, projective plane. Or are these not useful because objects like the Klein Bottle or projective plane don't exist in real life?</p>
","Is it interesting to look at surface codes where the boundary conditions give the shape of a Mobius strip, Klein bottle, or the projective plane?",<error-correction><surface-code>,0,1,,,"Is it interesting to look at surface codes where the boundary conditions give the shape of a Mobius strip, Klein bottle, or the projective plane? <p>I was reading about the Toric code and how the boundary codes give it a shape of of a torus. Is it interesting to look at other ways to orient the edges of a square lattice? I.e. a mobius strip, Klein bottle, projective plane. Or are these not useful because objects like the Klein Bottle or projective plane don't exist in real life?</p>
",qc,interesting look surface codes boundary conditions give shape mobius strip klein bottle projective plane p reading toric code boundary codes give shape torus interesting look ways orient edges square lattice mobius strip klein bottle projective plane useful objects like klein bottle projective plane exist real life,"[(5, 0.25309938), (9, 0.31292728), (13, 0.20361921), (14, 0.13827445), (16, 0.0288312), (17, 0.059269153)]"
21899,,2021-11-12 09:26:08,1,54,"<p>Could anyone make explicit the code which gives the two plots at the end of the HHL tutorial. They show the results of the jobs on a real IBM quantum device.</p>
",Plots of the result for the qiskit HHL tutorial,<qiskit><programming><hhl-algorithm>,0,0,,,"Plots of the result for the qiskit HHL tutorial <p>Could anyone make explicit the code which gives the two plots at the end of the HHL tutorial. They show the results of the jobs on a real IBM quantum device.</p>
",qc,plots result qiskit hhl tutorial p could anyone make explicit code gives two plots end hhl tutorial show results jobs real ibm quantum,"[(7, 0.12669787), (14, 0.7158542), (17, 0.15011936)]"
21946,,2021-11-16 15:05:39,3,335,"<p><a href=""https://i.sstatic.net/pJGE7.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pJGE7.jpg"" alt=""enter image description here"" /></a></p>
<p>Above is a circuit for &quot;Approximate Quantum Cloning&quot;
The preparation state is given by <span class=""math-container"">$$|\psi\rangle =\alpha|0\rangle+\beta|1\rangle$$</span>
The gates labelled <span class=""math-container"">$\theta_i$</span> denote single qubit rotations given by <span class=""math-container"">$$R_y(-2\theta_i)=\begin{bmatrix}\cos\theta_i&amp;\sin\theta_i\\-\sin\theta_i&amp;\cos\theta_i\end{bmatrix} $$</span>
i.e Counterclockwise rotations of angle <span class=""math-container"">$-2\theta_i$</span> about the y-axis on Bloch Sphere.</p>
<p>Each gate rotation is given by:</p>
<p><span class=""math-container"">$\cos2\theta_1 =\frac{1}{\sqrt5}$</span></p>
<p><span class=""math-container"">$\cos2\theta_2 =\frac{\sqrt5}{3}$</span></p>
<p><span class=""math-container"">$\cos2\theta_3 =\frac{2}{\sqrt5}$</span></p>
<p>Question: Show at the end of the preparation stage the two qubits initially in the state <span class=""math-container"">$|00\rangle$</span> are transformed into the state <span class=""math-container"">$$|\phi\rangle =\frac{1}{\sqrt6}(2|00\rangle+|01\rangle+|11\rangle) $$</span></p>
<p>I'm quite unsure of how to approach this, as it is my first time dealing with a circuit like this. Are the two <span class=""math-container"">$|0\rangle$</span> states said to be entangled, hence the double <span class=""math-container"">$|00\rangle$</span> notation, I thought of applying the rotations to each qubit individually, along with a <span class=""math-container"">$\hat C_x $</span>gate operation?</p>
",Compute the output of this Approximate Quantum Cloning three-qubit circuit,<quantum-gate><circuit-construction><textbook-and-exercises><quantum-circuit><cloning>,2,0,,,"Compute the output of this Approximate Quantum Cloning three-qubit circuit <p><a href=""https://i.sstatic.net/pJGE7.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pJGE7.jpg"" alt=""enter image description here"" /></a></p>
<p>Above is a circuit for &quot;Approximate Quantum Cloning&quot;
The preparation state is given by <span class=""math-container"">$$|\psi\rangle =\alpha|0\rangle+\beta|1\rangle$$</span>
The gates labelled <span class=""math-container"">$\theta_i$</span> denote single qubit rotations given by <span class=""math-container"">$$R_y(-2\theta_i)=\begin{bmatrix}\cos\theta_i&amp;\sin\theta_i\\-\sin\theta_i&amp;\cos\theta_i\end{bmatrix} $$</span>
i.e Counterclockwise rotations of angle <span class=""math-container"">$-2\theta_i$</span> about the y-axis on Bloch Sphere.</p>
<p>Each gate rotation is given by:</p>
<p><span class=""math-container"">$\cos2\theta_1 =\frac{1}{\sqrt5}$</span></p>
<p><span class=""math-container"">$\cos2\theta_2 =\frac{\sqrt5}{3}$</span></p>
<p><span class=""math-container"">$\cos2\theta_3 =\frac{2}{\sqrt5}$</span></p>
<p>Question: Show at the end of the preparation stage the two qubits initially in the state <span class=""math-container"">$|00\rangle$</span> are transformed into the state <span class=""math-container"">$$|\phi\rangle =\frac{1}{\sqrt6}(2|00\rangle+|01\rangle+|11\rangle) $$</span></p>
<p>I'm quite unsure of how to approach this, as it is my first time dealing with a circuit like this. Are the two <span class=""math-container"">$|0\rangle$</span> states said to be entangled, hence the double <span class=""math-container"">$|00\rangle$</span> notation, I thought of applying the rotations to each qubit individually, along with a <span class=""math-container"">$\hat C_x $</span>gate operation?</p>
",qc,compute output approximate quantum cloning circuit p https nofollow noreferrer img https enter image description p circuit quot approximate quantum cloning quot preparation state given span gates labelled span denote single qubit rotations given span bmatrix amp amp bmatrix counterclockwise rotations angle span bloch p gate rotation given p span 1 p span 3 p span 2 p question show end preparation stage two qubits initially state span transformed state span 1 p quite unsure approach first time dealing circuit like two span states said entangled hence double span notation thought applying rotations qubit individually along span gate operation,"[(3, 0.29718035), (4, 0.16485277), (9, 0.19708131), (13, 0.12337237), (15, 0.057963237), (17, 0.021583557), (18, 0.11448169), (19, 0.022274649)]"
21956,,2021-11-17 00:23:22,3,568,"<p>How to determine the threshold value of the quantum error correction code, what is the specific method, such as surface code, how to determine the threshold value of the color code with a decoder, I don’t understand it very well, please answer it in detail.</p>
",How to determine the threshold value of the quantum error correction code,<quantum-state><error-correction><stabilizer-code>,1,0,,,"How to determine the threshold value of the quantum error correction code <p>How to determine the threshold value of the quantum error correction code, what is the specific method, such as surface code, how to determine the threshold value of the color code with a decoder, I don’t understand it very well, please answer it in detail.</p>
",qc,determine threshold value quantum error correction code p determine threshold value quantum error correction code specific method surface code determine threshold value color code decoder understand well please answer,"[(1, 0.16282897), (5, 0.64279187), (17, 0.18855672)]"
21969,,2021-11-17 22:20:07,1,52,"<p>I am reading <a href=""https://arxiv.org/abs/1605.05207"" rel=""nofollow noreferrer"">a paper</a> from 2016, &quot;Quantum computing with atomic qubits and
Rydberg interactions: Progress and challenges&quot;,</p>
<p>In section 2.1, a debate on whether identical or heterogeneous qubits work better for large scale systems. I have two questions:</p>
<ol>
<li>What is the difference between the identical and the heterogeneous qubits?</li>
<li>Is there a result for the debate above?</li>
</ol>
<p>Thanks for any help!</p>
","What are the natural, synthetic, identical, heterogeneous qubits? Can anyone explain with examples?",<experimental-realization><research>,0,0,,,"What are the natural, synthetic, identical, heterogeneous qubits? Can anyone explain with examples? <p>I am reading <a href=""https://arxiv.org/abs/1605.05207"" rel=""nofollow noreferrer"">a paper</a> from 2016, &quot;Quantum computing with atomic qubits and
Rydberg interactions: Progress and challenges&quot;,</p>
<p>In section 2.1, a debate on whether identical or heterogeneous qubits work better for large scale systems. I have two questions:</p>
<ol>
<li>What is the difference between the identical and the heterogeneous qubits?</li>
<li>Is there a result for the debate above?</li>
</ol>
<p>Thanks for any help!</p>
",qc,natural synthetic identical heterogeneous qubits anyone explain examples p reading https nofollow noreferrer paper 2016 quot quantum computing atomic qubits rydberg interactions progress challenges quot p section debate whether identical heterogeneous qubits work better large scale systems two questions ol li difference identical heterogeneous qubits li result debate p thanks help,"[(8, 0.3792237), (9, 0.46194947), (17, 0.109637104), (19, 0.045569014)]"
22014,,2021-11-21 22:23:44,3,269,"<p>I've been working on a code to run VQE with a grouped measurement. For some reason, my expectation values are slightly off from those computed by pennylane, the software I decided to use for this little project. I've been staring at my expectation value function <code>exp_val</code>, and I can't tell why it's wrong.</p>
<p>This is the code:</p>
<pre><code>import pennylane as qml
from pennylane import qchem
import numpy as np

symbols = [&quot;H&quot;, &quot;H&quot;]
coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])
h2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates)
n_shots = 1000

dev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots)

@qml.qnode(dev_noisy)
def VQE_circuit(params, group = None, n_qubits = None):
        qml.StronglyEntanglingLayers(params, wires = range(n_qubits))
        rotations = qml.grouping.diagonalize_qwc_pauli_words(group)[0]
        return qml.probs(wires=range(n_qubits))


import autograd.numpy as agnp
drawer = qml.draw(VQE_circuit)

def exp_val(results, coeffs, groupings):
        E = 0
        for i, result in enumerate(results):
                #Process each list of counts (probs)
                ops = groupings[i]
                coeff_list = coeffs[i]
                #print(drawer(params, group = groupings[i], n_qubits = n_qubits))
                for op_idx, op in enumerate(ops):
                        ##calculate expval for each operator in group
                        if op.name == 'Identity':
                                E += coeff_list[op_idx]
                        else:
                                exp_val = 0
                                for c_idx, count in enumerate(result):
                                        #process bitstring in result
                                        idxs = op.wires.toarray()
                                        bits = format(c_idx, &quot;b&quot;).zfill(n_qubits)
                                        sub_bits = [bits[i] for i in idxs]
                                        par = sub_bits.count('1')%2
                                        sign = (-1)**par
                                        exp_val += sign*count
                                exp_val *= coeff_list[op_idx]
                                E += exp_val
        return E
print(&quot;\n&quot;, h2_ham, &quot;\n&quot;)
groupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf')
param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=3, n_wires=n_qubits)
params = np.random.normal(scale=0.1, size=param_shape)
results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings]
print(exp_val(results, coeffs, groupings))


##VQE execution:
def naive_cost(params):
    results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings]
    return exp_val(results, coeffs, groupings)    
sparse = qml.utils.sparse_hamiltonian(h2_ham).toarray()
gs_E = np.linalg.eigvalsh(sparse)[0]
print(&quot;GSE: &quot;, gs_E)
import scipy.optimize as opt
param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits)
params = np.random.normal(scale=0.1, size=param_shape)
opt = qml.AdagradOptimizer(0.05)

max_iteration = 100
conv_tol = 1e-6
energy = [naive_cost(params)]
for n in range(max_iteration):
        params, prev_E = opt.step_and_cost(naive_cost, params)
        energy.append(naive_cost(params))
        conv = np.abs(energy[-1]-prev_E)
        if n % 2 == 0:
                print(f&quot;Step = {n},  Energy = {energy[-1]:.8f} Ha&quot;)

        if conv &lt;= conv_tol:
                break
#print(energy)
print(&quot;FOUND GROUND STATE E: &quot;, np.min(energy))
print(&quot;FINAL params: &quot;, params)
print(&quot;REAL GROUND STATE E: &quot;, gs_E)

</code></pre>
<p>Am I doing something obviously wrong? I've checked to ensure the endianness of the bits is correct, I made sure to calculate parities based on the active qubit indices for the desired observable, I made sure not to include a parity calculation when computing expected value of identity operators. I've triple checked that the coefficients are being applied to the correct operators, that the circuits are appended with the correct measurement circuits for the given operator in the group. Amongst these checks, I can't seem to find the flaw in my programming logic. Having an extra pair of eyes on this would be extremely helpful.</p>
<p>All the best,</p>
<p>cuhrazatee</p>
<p>PS:</p>
<p>Here's the code using Pennylane's built in exp_val.</p>
<pre><code>from openfermion.ops.operators.qubit_operator import QubitOperator
import pennylane as qml
from pennylane import qchem
import numpy as np
from functools import partial
from pennylane.measure import state
from pennylane.ops.qubit import observables
from pennylane.templates import UCCSD
import matplotlib.pyplot as plt

symbols = [&quot;H&quot;, &quot;H&quot;]
coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])
h2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates)
n_electrons = 2
singles, doubles = qchem.excitations(n_electrons, n_qubits)
s_wires, d_wires = qchem.excitations_to_wires(singles, doubles)
ref_state = qchem.hf_state(n_electrons, n_qubits)
ansatz = partial(UCCSD, init_state = ref_state, s_wires = s_wires, d_wires = d_wires)
groupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf')

n_shots = 10000
dev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots)

sparse = qml.utils.sparse_hamiltonian(h2_ham).toarray()
gs_E = np.linalg.eigvalsh(sparse)[0]

print(&quot;GSE: &quot;, gs_E)
param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits)
params = np.random.normal(scale=0.1, size=param_shape)
optimal_params = [[[0.15300575748799206, 0.0802866250748122, 0.6612327808749161],
  [-0.012197292985330403, 1.0054708209216188, -0.5031298708940922],
  [0.4871116388974964, 0.8755791036972337, 0.15300349217856668],
  [0.2125674641016197, -0.3988028820299284, -0.5903810690276766]],
 [[-0.26227065702483116, 0.7762008921102848, 0.20421958031876591],
  [-0.11210374173720475, -0.7158851608015426, -0.945090563307313],
  [-0.20041447281024863, -0.43875447105339715, -0.10552844761324888],
  [0.017868138476782234, -0.4067704016345291, 0.19911933547123295]],
 [[-0.1170885274951583, -0.40203947157121894, -0.44851762637470327],
  [-0.2715291337140317, 0.6888494094283752, 0.5389027752311034],
  [-0.5191082830999312, 0.4426962606005164, -0.25932474764548114],
  [0.8138172470220708, -0.54678942509227, 0.4102491578027457]],
 [[0.7676993827422776, -0.47721469081406376, 0.6337393057184456],
  [-0.6553402727229024, 0.8955375499127577, 0.5789282160827474],
  [0.6570560582613835, -0.8518341967262695, -0.6023881439081624],
  [0.040387149769954125, 0.3040045252649316, -0.38193967606295326]],
 [[0.42336490227621815, -0.3869902716443922, 0.27822533007353994],
  [1.2170710775127433, 0.6959673154584948, -0.11538272838636159],
  [0.33436903989516936, -0.7268804688737179, 0.49919014014531526],
  [0.818911996077618, -0.6280017753881122, 0.553169606547251]]]

cost = qml.ExpvalCost(qml.StronglyEntanglingLayers, h2_ham, dev_noisy, optimize=True)

opt = qml.AdagradOptimizer(0.06)



max_iteration = 100
conv_tol = 1e-6
energy = [cost(params)]
for n in range(max_iteration):
        params, prev_E = opt.step_and_cost(cost, params)
        energy.append(cost(params))
        conv = np.abs(energy[-1]-prev_E)
        if n % 2 == 0:
                print(f&quot;Step = {n},  Energy = {energy[-1]:.8f} Ha&quot;)

        if conv &lt;= conv_tol:
                break
#print(energy)
print(&quot;FOUND GROUND STATE E: &quot;, np.min(energy))
print(&quot;REAL GROUND STATE E: &quot;, gs_E)

<span class=""math-container"">```</span>
</code></pre>
","VQE from scratch, what have I got wrong?",<programming><vqe><pennylane>,1,2,,,"VQE from scratch, what have I got wrong? <p>I've been working on a code to run VQE with a grouped measurement. For some reason, my expectation values are slightly off from those computed by pennylane, the software I decided to use for this little project. I've been staring at my expectation value function <code>exp_val</code>, and I can't tell why it's wrong.</p>
<p>This is the code:</p>
<pre><code>import pennylane as qml
from pennylane import qchem
import numpy as np

symbols = [&quot;H&quot;, &quot;H&quot;]
coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])
h2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates)
n_shots = 1000

dev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots)

@qml.qnode(dev_noisy)
def VQE_circuit(params, group = None, n_qubits = None):
        qml.StronglyEntanglingLayers(params, wires = range(n_qubits))
        rotations = qml.grouping.diagonalize_qwc_pauli_words(group)[0]
        return qml.probs(wires=range(n_qubits))


import autograd.numpy as agnp
drawer = qml.draw(VQE_circuit)

def exp_val(results, coeffs, groupings):
        E = 0
        for i, result in enumerate(results):
                #Process each list of counts (probs)
                ops = groupings[i]
                coeff_list = coeffs[i]
                #print(drawer(params, group = groupings[i], n_qubits = n_qubits))
                for op_idx, op in enumerate(ops):
                        ##calculate expval for each operator in group
                        if op.name == 'Identity':
                                E += coeff_list[op_idx]
                        else:
                                exp_val = 0
                                for c_idx, count in enumerate(result):
                                        #process bitstring in result
                                        idxs = op.wires.toarray()
                                        bits = format(c_idx, &quot;b&quot;).zfill(n_qubits)
                                        sub_bits = [bits[i] for i in idxs]
                                        par = sub_bits.count('1')%2
                                        sign = (-1)**par
                                        exp_val += sign*count
                                exp_val *= coeff_list[op_idx]
                                E += exp_val
        return E
print(&quot;\n&quot;, h2_ham, &quot;\n&quot;)
groupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf')
param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=3, n_wires=n_qubits)
params = np.random.normal(scale=0.1, size=param_shape)
results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings]
print(exp_val(results, coeffs, groupings))


##VQE execution:
def naive_cost(params):
    results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings]
    return exp_val(results, coeffs, groupings)    
sparse = qml.utils.sparse_hamiltonian(h2_ham).toarray()
gs_E = np.linalg.eigvalsh(sparse)[0]
print(&quot;GSE: &quot;, gs_E)
import scipy.optimize as opt
param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits)
params = np.random.normal(scale=0.1, size=param_shape)
opt = qml.AdagradOptimizer(0.05)

max_iteration = 100
conv_tol = 1e-6
energy = [naive_cost(params)]
for n in range(max_iteration):
        params, prev_E = opt.step_and_cost(naive_cost, params)
        energy.append(naive_cost(params))
        conv = np.abs(energy[-1]-prev_E)
        if n % 2 == 0:
                print(f&quot;Step = {n},  Energy = {energy[-1]:.8f} Ha&quot;)

        if conv &lt;= conv_tol:
                break
#print(energy)
print(&quot;FOUND GROUND STATE E: &quot;, np.min(energy))
print(&quot;FINAL params: &quot;, params)
print(&quot;REAL GROUND STATE E: &quot;, gs_E)

</code></pre>
<p>Am I doing something obviously wrong? I've checked to ensure the endianness of the bits is correct, I made sure to calculate parities based on the active qubit indices for the desired observable, I made sure not to include a parity calculation when computing expected value of identity operators. I've triple checked that the coefficients are being applied to the correct operators, that the circuits are appended with the correct measurement circuits for the given operator in the group. Amongst these checks, I can't seem to find the flaw in my programming logic. Having an extra pair of eyes on this would be extremely helpful.</p>
<p>All the best,</p>
<p>cuhrazatee</p>
<p>PS:</p>
<p>Here's the code using Pennylane's built in exp_val.</p>
<pre><code>from openfermion.ops.operators.qubit_operator import QubitOperator
import pennylane as qml
from pennylane import qchem
import numpy as np
from functools import partial
from pennylane.measure import state
from pennylane.ops.qubit import observables
from pennylane.templates import UCCSD
import matplotlib.pyplot as plt

symbols = [&quot;H&quot;, &quot;H&quot;]
coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])
h2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates)
n_electrons = 2
singles, doubles = qchem.excitations(n_electrons, n_qubits)
s_wires, d_wires = qchem.excitations_to_wires(singles, doubles)
ref_state = qchem.hf_state(n_electrons, n_qubits)
ansatz = partial(UCCSD, init_state = ref_state, s_wires = s_wires, d_wires = d_wires)
groupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf')

n_shots = 10000
dev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots)

sparse = qml.utils.sparse_hamiltonian(h2_ham).toarray()
gs_E = np.linalg.eigvalsh(sparse)[0]

print(&quot;GSE: &quot;, gs_E)
param_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits)
params = np.random.normal(scale=0.1, size=param_shape)
optimal_params = [[[0.15300575748799206, 0.0802866250748122, 0.6612327808749161],
  [-0.012197292985330403, 1.0054708209216188, -0.5031298708940922],
  [0.4871116388974964, 0.8755791036972337, 0.15300349217856668],
  [0.2125674641016197, -0.3988028820299284, -0.5903810690276766]],
 [[-0.26227065702483116, 0.7762008921102848, 0.20421958031876591],
  [-0.11210374173720475, -0.7158851608015426, -0.945090563307313],
  [-0.20041447281024863, -0.43875447105339715, -0.10552844761324888],
  [0.017868138476782234, -0.4067704016345291, 0.19911933547123295]],
 [[-0.1170885274951583, -0.40203947157121894, -0.44851762637470327],
  [-0.2715291337140317, 0.6888494094283752, 0.5389027752311034],
  [-0.5191082830999312, 0.4426962606005164, -0.25932474764548114],
  [0.8138172470220708, -0.54678942509227, 0.4102491578027457]],
 [[0.7676993827422776, -0.47721469081406376, 0.6337393057184456],
  [-0.6553402727229024, 0.8955375499127577, 0.5789282160827474],
  [0.6570560582613835, -0.8518341967262695, -0.6023881439081624],
  [0.040387149769954125, 0.3040045252649316, -0.38193967606295326]],
 [[0.42336490227621815, -0.3869902716443922, 0.27822533007353994],
  [1.2170710775127433, 0.6959673154584948, -0.11538272838636159],
  [0.33436903989516936, -0.7268804688737179, 0.49919014014531526],
  [0.818911996077618, -0.6280017753881122, 0.553169606547251]]]

cost = qml.ExpvalCost(qml.StronglyEntanglingLayers, h2_ham, dev_noisy, optimize=True)

opt = qml.AdagradOptimizer(0.06)



max_iteration = 100
conv_tol = 1e-6
energy = [cost(params)]
for n in range(max_iteration):
        params, prev_E = opt.step_and_cost(cost, params)
        energy.append(cost(params))
        conv = np.abs(energy[-1]-prev_E)
        if n % 2 == 0:
                print(f&quot;Step = {n},  Energy = {energy[-1]:.8f} Ha&quot;)

        if conv &lt;= conv_tol:
                break
#print(energy)
print(&quot;FOUND GROUND STATE E: &quot;, np.min(energy))
print(&quot;REAL GROUND STATE E: &quot;, gs_E)

<span class=""math-container"">```</span>
</code></pre>
",qc,vqe scratch got wrong p working code run vqe grouped measurement reason expectation values slightly computed pennylane software decided use little project staring expectation value function code ca tell p code pre code import pennylane qml pennylane import qchem import numpy np symbols quot h quot quot h quot coordinates symbols coordinates 1000 wires shots def params group none none params wires range rotations group 0 return import agnp drawer def results coeffs groupings e 0 result enumerate results process list counts probs ops groupings coeffs print drawer params group groupings op enumerate ops calculate expval operator group e else 0 count enumerate result process bitstring result idxs bits format quot b quot bits idxs par 1 2 sign par sign count e return e print quot quot quot quot groupings coeffs 1 0 method params results params group group group groupings print results coeffs groupings vqe execution def params results params group group group groupings return results coeffs groupings sparse sparse 0 print quot gse quot import opt params opt 100 energy params n range params params params conv energy n 2 0 print f quot step n energy energy ha quot conv lt break print energy print quot found ground state e quot energy print quot final params quot params print quot real ground state e quot p something obviously wrong checked ensure endianness bits correct made sure calculate parities based active qubit indices desired observable made sure include parity calculation computing expected value identity operators triple checked coefficients applied correct operators circuits appended correct measurement circuits given operator group amongst checks ca seem find flaw programming logic extra pair eyes would extremely p best p cuhrazatee p ps p code using pennylane built pre code import qubitoperator import pennylane qml pennylane import qchem import numpy np functools import partial import state import observables import uccsd import plt symbols quot h quot quot h quot coordinates symbols coordinates 2 singles doubles singles doubles ansatz partial uccsd groupings coeffs 1 0 method 10000 wires shots sparse sparse 0 print quot gse quot params cost opt 100 energy cost params n range params cost params cost params conv energy n 2 0 print f quot step n energy energy ha quot conv lt break print energy print quot found ground state e quot energy print quot real ground state e quot span,"[(0, 0.44297242), (2, 0.034770004), (3, 0.06512403), (8, 0.08534037), (9, 0.028372772), (14, 0.119094074), (17, 0.07069932), (18, 0.01436141), (19, 0.13029031)]"
22034,,2021-11-23 16:21:21,4,88,"<p>I find that some algorithms can be sped up using Grover's search, but I have a question about the soundness of new algorithms. Since Grover's search is a probabilistic method, it has a chance to make mistakes during the program, resulting the algorithm result different from classical methods. Do people pay attention to speed up the algorithms with a tolerance on the soundness? Or, is there a way to keep the soundness while the speedup achieves?</p>
",Soundness of Grover's search application,<quantum-algorithms><grovers-algorithm>,1,0,,,"Soundness of Grover's search application <p>I find that some algorithms can be sped up using Grover's search, but I have a question about the soundness of new algorithms. Since Grover's search is a probabilistic method, it has a chance to make mistakes during the program, resulting the algorithm result different from classical methods. Do people pay attention to speed up the algorithms with a tolerance on the soundness? Or, is there a way to keep the soundness while the speedup achieves?</p>
",qc,soundness grover search application p find algorithms sped using grover search question soundness new algorithms since grover search probabilistic method chance make mistakes program resulting algorithm result different classical methods people pay attention speed algorithms tolerance soundness way keep soundness speedup achieves,"[(7, 0.35673875), (8, 0.31887513), (9, 0.16880119), (17, 0.027852802), (18, 0.12408616)]"
22130,,2021-11-30 04:26:58,3,319,"<p>I am trying to get my first openqasm3.0 program and I am getting error messages that I cannot interpret.</p>
<p>Here is my program:</p>
<pre><code>cloner1 = &quot;&quot;&quot;
OPENQASM 3.0;
//include &quot;qelib1.inc&quot;;
qubit[5] q;
bit[1] c;
x q[2];
x q[4];

x q[0]; //Set up input
measure q[0] -&gt; c[0];
if (c[0]==1) {
    CX q[1],q[2];
    CX q[2],q[1];
    CX q[1],q[2];
    CX q[3],q[4];
    CX q[4],q[3];
    CX q[3],q[4];
    }
measure q[1]-&gt;c[0];
measure q[3]-&gt;c[0];
&quot;&quot;&quot;

qc= QuantumCircuit.from_qasm_str(cloner1)
result = execute(qc, backend=qiskit.BasicAer.get_backend('qasm_simulator'),shots=1024).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p>THe error message I get is
Error near line 4 Column 7
Expected an ID, received '['&quot;</p>
<p>Apparently it doesn't like bit[1] c. But this is just like the code in the <a href=""https://arxiv.org/pdf/2104.14722.pdf"" rel=""nofollow noreferrer"">arxiv.org article</a></p>
<p>So I don't know what is wrong. It doesn't seem to be interpreting it as ASM3.0 code.</p>
",Qiskit does not interpret qasm string as 3.0?,<qiskit><programming><qasm>,1,1,,,"Qiskit does not interpret qasm string as 3.0? <p>I am trying to get my first openqasm3.0 program and I am getting error messages that I cannot interpret.</p>
<p>Here is my program:</p>
<pre><code>cloner1 = &quot;&quot;&quot;
OPENQASM 3.0;
//include &quot;qelib1.inc&quot;;
qubit[5] q;
bit[1] c;
x q[2];
x q[4];

x q[0]; //Set up input
measure q[0] -&gt; c[0];
if (c[0]==1) {
    CX q[1],q[2];
    CX q[2],q[1];
    CX q[1],q[2];
    CX q[3],q[4];
    CX q[4],q[3];
    CX q[3],q[4];
    }
measure q[1]-&gt;c[0];
measure q[3]-&gt;c[0];
&quot;&quot;&quot;

qc= QuantumCircuit.from_qasm_str(cloner1)
result = execute(qc, backend=qiskit.BasicAer.get_backend('qasm_simulator'),shots=1024).result()
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
<p>THe error message I get is
Error near line 4 Column 7
Expected an ID, received '['&quot;</p>
<p>Apparently it doesn't like bit[1] c. But this is just like the code in the <a href=""https://arxiv.org/pdf/2104.14722.pdf"" rel=""nofollow noreferrer"">arxiv.org article</a></p>
<p>So I don't know what is wrong. It doesn't seem to be interpreting it as ASM3.0 code.</p>
",qc,qiskit interpret qasm string p trying get first program getting error messages p program pre code cloner1 quot quot quot openqasm quot quot qubit 5 q bit 1 c x q 2 x q 4 x q 0 input measure q 0 gt c 0 c 0 cx q 1 q 2 cx q 2 q 1 cx q 1 q 2 cx q 3 q 4 cx q 4 q 3 cx q 3 q 4 measure q 1 gt c 0 measure q 3 gt c 0 quot quot quot cloner1 result execute qc counts counts p error message get error near line 4 column 7 expected id received quot p apparently like bit 1 like code https nofollow noreferrer article p know wrong seem interpreting,"[(0, 0.17405881), (2, 0.12978306), (4, 0.044559255), (6, 0.17978986), (10, 0.18074137), (13, 0.07900449), (14, 0.07177341), (17, 0.018006925), (19, 0.12141096)]"
22161,22162.0,2021-12-02 10:38:35,3,262,"<p>Is there a systematic way - in terms of a quantum circuit with single qubit and CNOT gates - to create a bell state with asymmetric amplitudes, e.g.,
<span class=""math-container"">$$
\alpha |00\rangle + \beta|11\rangle
$$</span>
where <span class=""math-container"">$\alpha, \beta$</span> are arbitrary complex values satisfying the condition of normalization?</p>
",How to create a Bell state with asymmetric amplitudes using single-qubit and CNOT gates?,<quantum-state><circuit-construction><quantum-circuit><bell-basis>,1,0,,,"How to create a Bell state with asymmetric amplitudes using single-qubit and CNOT gates? <p>Is there a systematic way - in terms of a quantum circuit with single qubit and CNOT gates - to create a bell state with asymmetric amplitudes, e.g.,
<span class=""math-container"">$$
\alpha |00\rangle + \beta|11\rangle
$$</span>
where <span class=""math-container"">$\alpha, \beta$</span> are arbitrary complex values satisfying the condition of normalization?</p>
",qc,create bell state asymmetric amplitudes using cnot gates p systematic way terms quantum circuit single qubit cnot gates create bell state asymmetric amplitudes span span arbitrary complex values satisfying condition normalization,"[(9, 0.25606102), (17, 0.064964615), (18, 0.6735241)]"
22186,,2021-12-05 18:09:56,3,58,"<p>My question relates to the theoretical application of the diffusion operator in Grover's algorithm.</p>
<p>I understand that a single Grover iteration on an equal superposition will change the amplitude of one specific basis and give it a higher probability of being measured.</p>
<p>The diffusion operation is defined as</p>
<p><span class=""math-container"">$H^{\otimes n}(2|0\rangle\langle0|-I)H^{\otimes n} = 2|s\rangle\langle s|-I$</span></p>
<p>where it basically assumes that the input states are in equal superposition. But this assumption is wrong as soon as more than one operation is applied, right? So how does this shape for the diffusion operator still hold when there is more than a single iteration of the Grover cycle?</p>
<p>Or is this definition simply like this for any initial state in the register and will always result in the inversion about the mean? I just haven't really found any good explanation on how did Grover/anybody else come up with this formula and what are the assumptions of it...</p>
",Does the diffusion operator change when there are multiple iterations of the Grover cycle?,<grovers-algorithm>,0,2,,,"Does the diffusion operator change when there are multiple iterations of the Grover cycle? <p>My question relates to the theoretical application of the diffusion operator in Grover's algorithm.</p>
<p>I understand that a single Grover iteration on an equal superposition will change the amplitude of one specific basis and give it a higher probability of being measured.</p>
<p>The diffusion operation is defined as</p>
<p><span class=""math-container"">$H^{\otimes n}(2|0\rangle\langle0|-I)H^{\otimes n} = 2|s\rangle\langle s|-I$</span></p>
<p>where it basically assumes that the input states are in equal superposition. But this assumption is wrong as soon as more than one operation is applied, right? So how does this shape for the diffusion operator still hold when there is more than a single iteration of the Grover cycle?</p>
<p>Or is this definition simply like this for any initial state in the register and will always result in the inversion about the mean? I just haven't really found any good explanation on how did Grover/anybody else come up with this formula and what are the assumptions of it...</p>
",qc,diffusion operator change multiple iterations grover cycle p question relates theoretical application diffusion operator grover p understand single grover iteration equal superposition change amplitude one specific basis give higher probability p diffusion operation defined p span n n p basically assumes input states equal superposition assumption wrong soon one operation applied right shape diffusion operator still hold single iteration grover cycle p definition simply like initial state register always result inversion mean really found good explanation else come formula assumptions,"[(3, 0.16412714), (5, 0.02656406), (7, 0.098421164), (8, 0.16436155), (17, 0.0129472725), (18, 0.5318323)]"
22223,,2021-12-07 22:58:29,3,147,"<p>I'm trying to reproduce quantum walk with decoherence as shown in figure 3 in <a href=""https://royalsocietypublishing.org/doi/10.1098/rsta.2006.1901"" rel=""nofollow noreferrer"">V. M. Kendon, Phil. Trans. R. Soc. A, 364, 2006</a> (<a href=""https://arxiv.org/abs/quant-ph/0609035"" rel=""nofollow noreferrer"">quant-ph/0609035</a>).</p>
<p>I am able to reproduce quantum walk without decoherence. And the code is attached.</p>
<p>To reproduce quantum walk with decoherence, I am thinking following the formula
<span class=""math-container"">$$|\psi_{t+1}\rangle = (1-p)U|\psi_t\rangle + pMU|\psi_t\rangle$$</span>
where <span class=""math-container"">$|\psi_t\rangle$</span> represents the state at <span class=""math-container"">$t$</span>-th step, <span class=""math-container"">$U$</span> is the quantum-walk operator, and <span class=""math-container"">$M$</span> is a measurement operator modeling the decoherence, <span class=""math-container"">$p$</span> is a specified probability that decoherence occurs at each step.</p>
<p>However, I'm having a hard time determining the operator <span class=""math-container"">$M$</span>. Any suggestions?</p>
<p>The MATLAB code for quantum walk without decoherence:</p>
<pre><code>clearvars;  clc;    close all 

t = 100;   % number of steps
P = 2*t+1; % number of positions

% coins
c0 = [1, 0];
c1 = [0, 1];

C00 = c0'*c0;
C01 = c0'*c1;
C10 = c1'*c0;
C11 = c1'*c1;

C = [1 1; 1 -1]/sqrt(2); % coin operator, or just the Hadamard operator

% shift operation
shiftplus  = circshift(eye(P),1);
shiftminus = circshift(eye(P),-1);
S = kron(shiftplus, C00) + kron(shiftminus, C11);

% walk operation
U = S*kron(eye(P), C);

% initial condition
x0 = zeros(P,1);
x0(t+1) = 1;
psi0 = kron(x0, (c0+c1*1i)'/sqrt(2));

% evolution
psi = U^t*psi0;

% measurement
p = zeros(P,1);

for i = 1:P
    x = zeros(P,1);
    x(i) = 1;
    Mi = kron(x*x', eye(2));
    proj = Mi*psi;
    p(i) = sum(real(proj.*conj(proj)));
end

% plotting
x = (-t:t)';
plot(x(1:2:end),p(1:2:end))
</code></pre>
",How to simulate a quantum walk with decoherence?,<quantum-algorithms><decoherence><quantum-walks>,0,6,,,"How to simulate a quantum walk with decoherence? <p>I'm trying to reproduce quantum walk with decoherence as shown in figure 3 in <a href=""https://royalsocietypublishing.org/doi/10.1098/rsta.2006.1901"" rel=""nofollow noreferrer"">V. M. Kendon, Phil. Trans. R. Soc. A, 364, 2006</a> (<a href=""https://arxiv.org/abs/quant-ph/0609035"" rel=""nofollow noreferrer"">quant-ph/0609035</a>).</p>
<p>I am able to reproduce quantum walk without decoherence. And the code is attached.</p>
<p>To reproduce quantum walk with decoherence, I am thinking following the formula
<span class=""math-container"">$$|\psi_{t+1}\rangle = (1-p)U|\psi_t\rangle + pMU|\psi_t\rangle$$</span>
where <span class=""math-container"">$|\psi_t\rangle$</span> represents the state at <span class=""math-container"">$t$</span>-th step, <span class=""math-container"">$U$</span> is the quantum-walk operator, and <span class=""math-container"">$M$</span> is a measurement operator modeling the decoherence, <span class=""math-container"">$p$</span> is a specified probability that decoherence occurs at each step.</p>
<p>However, I'm having a hard time determining the operator <span class=""math-container"">$M$</span>. Any suggestions?</p>
<p>The MATLAB code for quantum walk without decoherence:</p>
<pre><code>clearvars;  clc;    close all 

t = 100;   % number of steps
P = 2*t+1; % number of positions

% coins
c0 = [1, 0];
c1 = [0, 1];

C00 = c0'*c0;
C01 = c0'*c1;
C10 = c1'*c0;
C11 = c1'*c1;

C = [1 1; 1 -1]/sqrt(2); % coin operator, or just the Hadamard operator

% shift operation
shiftplus  = circshift(eye(P),1);
shiftminus = circshift(eye(P),-1);
S = kron(shiftplus, C00) + kron(shiftminus, C11);

% walk operation
U = S*kron(eye(P), C);

% initial condition
x0 = zeros(P,1);
x0(t+1) = 1;
psi0 = kron(x0, (c0+c1*1i)'/sqrt(2));

% evolution
psi = U^t*psi0;

% measurement
p = zeros(P,1);

for i = 1:P
    x = zeros(P,1);
    x(i) = 1;
    Mi = kron(x*x', eye(2));
    proj = Mi*psi;
    p(i) = sum(real(proj.*conj(proj)));
end

% plotting
x = (-t:t)';
plot(x(1:2:end),p(1:2:end))
</code></pre>
",qc,simulate quantum walk decoherence p trying reproduce quantum walk decoherence shown figure 3 https nofollow noreferrer v kendon phil trans soc 364 2006 https nofollow noreferrer p able reproduce quantum walk without decoherence code p reproduce quantum walk decoherence thinking following formula span span represents state span step span u operator span measurement operator modeling decoherence span p specified probability decoherence occurs p however hard time determining operator span suggestions p matlab code quantum walk without decoherence pre code clearvars clc close 100 number steps p 2 number positions coins c0 1 0 c1 0 1 c00 c0 c0 c01 c0 c1 c10 c1 c0 c11 c1 c1 c 1 1 1 2 coin operator hadamard operator shift operation shiftplus circshift eye p shiftminus circshift eye p kron shiftplus c00 kron shiftminus c11 walk operation u kron eye p c initial condition x0 zeros x0 1 psi0 kron x0 1i 2 evolution psi psi0 measurement p zeros 1 p x zeros x 1 mi kron x x eye 2 proj mi psi p sum real proj conj proj end plotting x plot x end p end,"[(0, 0.1514285), (1, 0.03782884), (2, 0.09561157), (3, 0.16839999), (4, 0.09416224), (6, 0.014656913), (9, 0.077467434), (10, 0.046348196), (13, 0.11125997), (14, 0.11720174), (17, 0.029070389), (19, 0.05606379)]"
22236,,2021-12-09 13:58:07,7,682,"<p>Suppose there exists an algorithm that takes as input an arbitrary unitary matrix and produces as output a quantum circuit representing that matrix. Then in theory that algorithm could construct any quantum circuit. This would be quite useful.</p>
<p>Furthermore, since any computable algorithm may be implemented as a quantum circuit, the hypothetical circuit constructing algorithm could in principle construct any such algorithm as a quantum circuit. This seems similar, though not identical, to the idea of Turing completeness.</p>
<p>Intuitively it seems bizarre that such an algorithm could exist. However, I am not able to think of something that disproves this. Has such an algorithm's existence been proven/disproven?</p>
",Does there exists an algorithm to construct a quantum circuit given an arbitrary unitary?,<circuit-construction><unitarity><quantum-turing-machine><church-turing-thesis>,2,6,,,"Does there exists an algorithm to construct a quantum circuit given an arbitrary unitary? <p>Suppose there exists an algorithm that takes as input an arbitrary unitary matrix and produces as output a quantum circuit representing that matrix. Then in theory that algorithm could construct any quantum circuit. This would be quite useful.</p>
<p>Furthermore, since any computable algorithm may be implemented as a quantum circuit, the hypothetical circuit constructing algorithm could in principle construct any such algorithm as a quantum circuit. This seems similar, though not identical, to the idea of Turing completeness.</p>
<p>Intuitively it seems bizarre that such an algorithm could exist. However, I am not able to think of something that disproves this. Has such an algorithm's existence been proven/disproven?</p>
",qc,exists algorithm construct quantum circuit given arbitrary unitary p suppose exists algorithm takes input arbitrary unitary matrix produces output quantum circuit representing matrix theory algorithm could construct quantum circuit would quite p furthermore since computable algorithm may implemented quantum circuit hypothetical circuit constructing algorithm could principle construct algorithm quantum circuit seems similar though identical idea turing p intuitively seems bizarre algorithm could exist however able think something disproves algorithm existence,"[(1, 0.027717905), (3, 0.12815699), (7, 0.18566069), (8, 0.3274923), (11, 0.025184069), (14, 0.2775748), (17, 0.026333293)]"
22246,,2021-12-10 14:36:03,1,39,"<p>I tried recreating the quantum teleportation circuit (in the Qiskit Foundation Youtube Playlist) both in Lab and Composer and getting different plots for each.</p>
<p>Here is circuit and histogram from Composer
<a href=""https://i.sstatic.net/grGtP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/grGtP.png"" alt=""enter image description here"" /></a></p>
<p>And here is the one in Lab</p>
<p><a href=""https://i.sstatic.net/m4diT.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m4diT.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/GiY2Y.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GiY2Y.png"" alt=""enter image description here"" /></a></p>
<p>How do I make sense of these? Link for tutorial <a href=""https://www.youtube.com/watch?v=mMwovHK2NrE&amp;list=PLOFEBzvs-Vvp2xg9-POLJhQwtVktlYGbY&amp;index=5"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=mMwovHK2NrE&amp;list=PLOFEBzvs-Vvp2xg9-POLJhQwtVktlYGbY&amp;index=5</a></p>
<p>Edit : Sorry for the wrong composer circuit earlier, thanks for correcting me.</p>
",Getting different sets of plots for the teleportation algorithm in Composer and Lab,<quantum-state><ibm-q-experience><quantum-circuit><teleportation>,0,3,,,"Getting different sets of plots for the teleportation algorithm in Composer and Lab <p>I tried recreating the quantum teleportation circuit (in the Qiskit Foundation Youtube Playlist) both in Lab and Composer and getting different plots for each.</p>
<p>Here is circuit and histogram from Composer
<a href=""https://i.sstatic.net/grGtP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/grGtP.png"" alt=""enter image description here"" /></a></p>
<p>And here is the one in Lab</p>
<p><a href=""https://i.sstatic.net/m4diT.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m4diT.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/GiY2Y.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GiY2Y.png"" alt=""enter image description here"" /></a></p>
<p>How do I make sense of these? Link for tutorial <a href=""https://www.youtube.com/watch?v=mMwovHK2NrE&amp;list=PLOFEBzvs-Vvp2xg9-POLJhQwtVktlYGbY&amp;index=5"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=mMwovHK2NrE&amp;list=PLOFEBzvs-Vvp2xg9-POLJhQwtVktlYGbY&amp;index=5</a></p>
<p>Edit : Sorry for the wrong composer circuit earlier, thanks for correcting me.</p>
",qc,getting different sets plots teleportation algorithm composer lab p tried recreating quantum teleportation circuit qiskit foundation youtube playlist lab composer getting different plots p circuit histogram composer https nofollow noreferrer img https enter image description p one lab p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p make sense link tutorial https amp amp nofollow noreferrer https amp amp p edit sorry wrong composer circuit earlier thanks correcting,"[(4, 0.8348662), (5, 0.014785675), (7, 0.06394067), (15, 0.057510767), (17, 0.026926816)]"
22252,,2021-12-11 19:22:28,4,126,"<p>Start with an <span class=""math-container"">$n \times n$</span> lattice, with each qubit initialized to the state <span class=""math-container"">$|0\rangle$</span>. Then, apply the Hadamard gate on each qubit. Then, evolve the system under the Hamiltonian
<span class=""math-container"">\begin{equation}
    H = \sum_{l, m \in [n]} \text{Z}_l \text{Z}_m,
\end{equation}</span>
for <span class=""math-container"">$d$</span> time steps.
Note that the final state of the Hamiltonian can be written as
<span class=""math-container"">\begin{equation}
    |\psi\rangle_{\text{final}} = \frac{1}{\sqrt{2^{n^{2}}}} \sum_{x \in \{0, 1\}^{n^{2}}} \sum_{l, m \in [n]} e^{-i d (-1)^{x_l + x_m}} |x\rangle,
\end{equation}</span>
where <span class=""math-container"">$x_i$</span> is the <span class=""math-container"">$i^{\text{th}}$</span> bit of <span class=""math-container"">$x$</span>.</p>
<p>I could not formally prove that this state abides by a volume law entanglement spread and that is where I needed help.</p>
<hr />
<p>Since the Hamiltonian allows for long-range interactions, it is qualitatively evident that the entanglement will follow a volume-law spread.</p>
",Volume law spread after Hamiltonian evolution,<quantum-state><entanglement>,0,5,,,"Volume law spread after Hamiltonian evolution <p>Start with an <span class=""math-container"">$n \times n$</span> lattice, with each qubit initialized to the state <span class=""math-container"">$|0\rangle$</span>. Then, apply the Hadamard gate on each qubit. Then, evolve the system under the Hamiltonian
<span class=""math-container"">\begin{equation}
    H = \sum_{l, m \in [n]} \text{Z}_l \text{Z}_m,
\end{equation}</span>
for <span class=""math-container"">$d$</span> time steps.
Note that the final state of the Hamiltonian can be written as
<span class=""math-container"">\begin{equation}
    |\psi\rangle_{\text{final}} = \frac{1}{\sqrt{2^{n^{2}}}} \sum_{x \in \{0, 1\}^{n^{2}}} \sum_{l, m \in [n]} e^{-i d (-1)^{x_l + x_m}} |x\rangle,
\end{equation}</span>
where <span class=""math-container"">$x_i$</span> is the <span class=""math-container"">$i^{\text{th}}$</span> bit of <span class=""math-container"">$x$</span>.</p>
<p>I could not formally prove that this state abides by a volume law entanglement spread and that is where I needed help.</p>
<hr />
<p>Since the Hamiltonian allows for long-range interactions, it is qualitatively evident that the entanglement will follow a volume-law spread.</p>
",qc,volume law spread hamiltonian evolution p start span n n lattice qubit initialized state span apply hadamard gate qubit evolve system hamiltonian span equation h l n z z equation span time steps note final state hamiltonian written span equation final 1 2 x 0 2 l n equation span span th bit span x p could formally prove state abides volume law entanglement spread needed hr p since hamiltonian allows interactions qualitatively evident entanglement follow,"[(1, 0.10809227), (2, 0.041096453), (3, 0.38782424), (9, 0.17347984), (10, 0.03272821), (15, 0.021640623), (16, 0.01344685), (17, 0.04030385), (18, 0.17992322)]"
23362,23363.0,2021-12-21 20:12:52,1,99,"<p>I have seen sometimes that in some protocols, one can uncompute a circuit using only Clifford + measurements. See for example</p>
<blockquote>
<p>Erase the two qubits containing <span class=""math-container"">$p_{w,r}$</span> and <span class=""math-container"">$p_{w,s}$</span>, then the register containing component w of p. These erasures can be done with measurements and Clifford gates.</p>
</blockquote>
<p>before eq 73 in <a href=""https://arxiv.org/abs/2105.12767"" rel=""nofollow noreferrer"">Su et al.</a> For context, these are qubits that were &quot;copied&quot; via C-Nots from another register, and have been used as a control in a C-Z gate.</p>
<p>When can one erase registers using measurements and Clifford gates in general?</p>
",When can we unprepare a circuit using Clifford + measurements?,<quantum-gate><clifford-group>,1,0,,,"When can we unprepare a circuit using Clifford + measurements? <p>I have seen sometimes that in some protocols, one can uncompute a circuit using only Clifford + measurements. See for example</p>
<blockquote>
<p>Erase the two qubits containing <span class=""math-container"">$p_{w,r}$</span> and <span class=""math-container"">$p_{w,s}$</span>, then the register containing component w of p. These erasures can be done with measurements and Clifford gates.</p>
</blockquote>
<p>before eq 73 in <a href=""https://arxiv.org/abs/2105.12767"" rel=""nofollow noreferrer"">Su et al.</a> For context, these are qubits that were &quot;copied&quot; via C-Nots from another register, and have been used as a control in a C-Z gate.</p>
<p>When can one erase registers using measurements and Clifford gates in general?</p>
",qc,unprepare circuit using clifford measurements p seen sometimes protocols one uncompute circuit using clifford measurements see example blockquote p erase two qubits containing span w r span w register containing component w erasures done measurements clifford p eq 73 https nofollow noreferrer su et context qubits quot copied quot via another register used control p one erase registers using measurements clifford gates general,"[(0, 0.023263711), (3, 0.18023829), (9, 0.35810462), (14, 0.12798496), (17, 0.017793378), (18, 0.24482718), (19, 0.04562635)]"
23371,23409.0,2021-12-22 13:52:56,4,972,"<p>I am trying to get the distance using the swap test circuit.</p>
<p><a href=""https://i.sstatic.net/m2fkq.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m2fkq.png"" alt=""enter image description here"" /></a>,</p>
<p>With the help of the codes I shared, I can only estimate the distance between two vectors. Can it calculate the distances of many vectors from each other with the help of a single circuit?</p>
<pre><code>
# import the necessary libraries 
import math as m
from qiskit import *
from qiskit import BasicAer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit_quantum_knn.encoding import analog
from numpy import linalg as LA
from scipy.spatial import distance



# First step is to encode the data into quantum states. 
#There are some techniques to do it, in this case Amplitude embedding was used.


A= [2,9,8,5,4,18,16,10]
B= [7,5,10,3,14,10,20,6]


A_norm=LA.norm(A)
B_norm=LA.norm(B)
Dist=distance.euclidean(A, B)
Z = round( A_norm**2 + B_norm**2 )
 
# create phi and psi state with the data    
phi = [A_norm/m.sqrt(Z),-B_norm/m.sqrt(Z)]
psi = []

for i in range(len(A)):
    psi.append(((A[i]/A_norm) /m.sqrt(2)))
    psi.append(((B[i]/B_norm) /m.sqrt(2)))
    
# Quantum Circuit
q1 = QuantumRegister(1,name='q1')
q2 = QuantumRegister(1,name='q2')
q3 = QuantumRegister(4,name='q3')
c = ClassicalRegister(1,name='c')
qc= QuantumCircuit(q1,q2,q3,c)

# states initialization
qc.initialize( phi, q2[0] )
qc.initialize( psi, q3[0:4])

# The swap test operator 
qc.h( q1[0])
qc.cswap( q1[0], q2[0], q3[0] )
qc.h( q1[0] )
qc.measure(q1,c)

display(qc.draw(output=&quot;mpl&quot;))


## Results
shots = 1000000
job = execute(qc,Aer.get_backend('qasm_simulator'),shots=shots)
job_result = job.result()
counts = job_result.get_counts(qc)
x = abs(((counts['0']/shots - 0.5)/0.5)*2*Z)
Q_Dist = round(m.sqrt(x),4)
print('Quantum Distance: ', round(Q_Dist,3))    
print('Euclidean Distance: ',round(Dist,3))   

</code></pre>
",Calculating the quantum euclidean distance between vectors,<qiskit><programming><quantum-algorithms><quantum-enhanced-machine-learning>,1,3,,,"Calculating the quantum euclidean distance between vectors <p>I am trying to get the distance using the swap test circuit.</p>
<p><a href=""https://i.sstatic.net/m2fkq.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/m2fkq.png"" alt=""enter image description here"" /></a>,</p>
<p>With the help of the codes I shared, I can only estimate the distance between two vectors. Can it calculate the distances of many vectors from each other with the help of a single circuit?</p>
<pre><code>
# import the necessary libraries 
import math as m
from qiskit import *
from qiskit import BasicAer
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit_quantum_knn.encoding import analog
from numpy import linalg as LA
from scipy.spatial import distance



# First step is to encode the data into quantum states. 
#There are some techniques to do it, in this case Amplitude embedding was used.


A= [2,9,8,5,4,18,16,10]
B= [7,5,10,3,14,10,20,6]


A_norm=LA.norm(A)
B_norm=LA.norm(B)
Dist=distance.euclidean(A, B)
Z = round( A_norm**2 + B_norm**2 )
 
# create phi and psi state with the data    
phi = [A_norm/m.sqrt(Z),-B_norm/m.sqrt(Z)]
psi = []

for i in range(len(A)):
    psi.append(((A[i]/A_norm) /m.sqrt(2)))
    psi.append(((B[i]/B_norm) /m.sqrt(2)))
    
# Quantum Circuit
q1 = QuantumRegister(1,name='q1')
q2 = QuantumRegister(1,name='q2')
q3 = QuantumRegister(4,name='q3')
c = ClassicalRegister(1,name='c')
qc= QuantumCircuit(q1,q2,q3,c)

# states initialization
qc.initialize( phi, q2[0] )
qc.initialize( psi, q3[0:4])

# The swap test operator 
qc.h( q1[0])
qc.cswap( q1[0], q2[0], q3[0] )
qc.h( q1[0] )
qc.measure(q1,c)

display(qc.draw(output=&quot;mpl&quot;))


## Results
shots = 1000000
job = execute(qc,Aer.get_backend('qasm_simulator'),shots=shots)
job_result = job.result()
counts = job_result.get_counts(qc)
x = abs(((counts['0']/shots - 0.5)/0.5)*2*Z)
Q_Dist = round(m.sqrt(x),4)
print('Quantum Distance: ', round(Q_Dist,3))    
print('Euclidean Distance: ',round(Dist,3))   

</code></pre>
",qc,calculating quantum euclidean distance vectors p trying get distance using swap test p https nofollow noreferrer img https enter image description p help codes shared estimate distance two vectors calculate distances many vectors help single circuit pre code import necessary libraries import math qiskit import qiskit import basicaer qiskit import quantumcircuit classicalregister quantumregister execute import analog numpy import linalg la import distance first step encode data quantum states techniques case amplitude embedding used b b z round 2 2 create phi psi state data phi z z psi range len 2 b 2 quantum circuit q1 quantumregister 1 q2 quantumregister 1 q3 quantumregister 4 c classicalregister 1 c quantumcircuit q1 q2 q3 c states initialization phi q2 0 psi q3 swap test operator q1 0 q1 0 q2 0 q3 0 q1 0 q1 c display quot mpl quot results shots 1000000 job execute qc counts qc x abs counts 0 2 z round x print distance round print distance round,"[(0, 0.35178185), (1, 0.0122182), (2, 0.111359745), (4, 0.07224727), (5, 0.029368771), (10, 0.010889491), (13, 0.08176564), (14, 0.14934658), (16, 0.04010207), (17, 0.095789716), (18, 0.035608742)]"
23399,23401.0,2021-12-23 23:04:44,4,357,"<p>In a recent <a href=""https://arxiv.org/abs/2112.07978"" rel=""nofollow noreferrer"">paper</a> on the arXiv, a team of researchers from Singapore and elsewhere claim to have established entanglement between a superconducting qubit and a <a href=""https://en.wikipedia.org/wiki/Tardigrade"" rel=""nofollow noreferrer"">tardigrade</a> (or water-bear), which is a teeny little critter that's known for being able to survive all sorts of extreme conditions (apparently even in the vacuum of outer space), by being able to enter a cryptobiotic state of suspended animation.</p>
<p>There may be scientific value in the study of the extremes tardigrades can be exposed to, e.g. in a dil-fridge, but it's natural to consider the experiment as a very trimmed-down version of <a href=""https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat"" rel=""nofollow noreferrer"">Schrödinger's cat</a>.</p>
<p><strong>If we define a Schrödinger's cat experiment as preparing and maintaining coherence of a state <span class=""math-container"">$\vert\psi\rangle=\frac{1}{\sqrt 2}(\vert\text{alive}\rangle+\vert\text{dead}\rangle)$</span> for some macroscopic cat-state, and then measuring in the appropriate basis to prove that the cat is in a coherent superposition of being alive and being dead, then can we say that the tardigrade experiment &quot;also&quot; put a tardigrade into a similar superposition?</strong></p>
<p>Clearly there's some click-baity headlines and perhaps some run-away conclusions, but can we formalize what the Singapore team did, in a way that requires a superconducting quantum computer?</p>
",How similar is the recent (2021) tardigrade experiment to a Schrödinger's cat experiment?,<interpretations><quantum-biology>,2,0,,,"How similar is the recent (2021) tardigrade experiment to a Schrödinger's cat experiment? <p>In a recent <a href=""https://arxiv.org/abs/2112.07978"" rel=""nofollow noreferrer"">paper</a> on the arXiv, a team of researchers from Singapore and elsewhere claim to have established entanglement between a superconducting qubit and a <a href=""https://en.wikipedia.org/wiki/Tardigrade"" rel=""nofollow noreferrer"">tardigrade</a> (or water-bear), which is a teeny little critter that's known for being able to survive all sorts of extreme conditions (apparently even in the vacuum of outer space), by being able to enter a cryptobiotic state of suspended animation.</p>
<p>There may be scientific value in the study of the extremes tardigrades can be exposed to, e.g. in a dil-fridge, but it's natural to consider the experiment as a very trimmed-down version of <a href=""https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat"" rel=""nofollow noreferrer"">Schrödinger's cat</a>.</p>
<p><strong>If we define a Schrödinger's cat experiment as preparing and maintaining coherence of a state <span class=""math-container"">$\vert\psi\rangle=\frac{1}{\sqrt 2}(\vert\text{alive}\rangle+\vert\text{dead}\rangle)$</span> for some macroscopic cat-state, and then measuring in the appropriate basis to prove that the cat is in a coherent superposition of being alive and being dead, then can we say that the tardigrade experiment &quot;also&quot; put a tardigrade into a similar superposition?</strong></p>
<p>Clearly there's some click-baity headlines and perhaps some run-away conclusions, but can we formalize what the Singapore team did, in a way that requires a superconducting quantum computer?</p>
",qc,similar recent 2021 tardigrade experiment schrödinger cat experiment p recent https nofollow noreferrer paper arxiv team researchers singapore elsewhere claim established entanglement superconducting qubit https nofollow noreferrer tardigrade teeny little critter known able survive sorts extreme conditions apparently even vacuum outer space able enter cryptobiotic state suspended p may scientific value study extremes tardigrades exposed natural consider experiment version https c3 b6dinger nofollow noreferrer schrödinger cat p strong define schrödinger cat experiment preparing maintaining coherence state span 1 2 alive dead macroscopic measuring appropriate basis prove cat coherent superposition alive dead say tardigrade experiment quot also quot put tardigrade similar superposition p clearly headlines perhaps conclusions formalize singapore team way requires superconducting quantum computer,"[(0, 0.013677181), (3, 0.14758542), (4, 0.08072178), (7, 0.10277035), (8, 0.12442664), (9, 0.20426646), (13, 0.24705677), (17, 0.011395942), (18, 0.04594198), (19, 0.021103289)]"
23405,,2021-12-24 15:46:51,5,384,"<p>Sometimes I need to simplify some commutators in the form
<span class=""math-container"">$[{\hat a}^\dagger{\hat a}^\dagger {\hat a},{\hat a}^\dagger\hat a \hat a]$</span>.</p>
<p>Doing it by hand is exhausting and boring.
Is there software (Matlab, Python, Mathematica, etc) that can handle such commutators?</p>
","Is there a software to simplify commutators such as $[{\hat a}^\dagger{\hat a}^\dagger {\hat a},{\hat a}^\dagger\hat a \hat a]$?",<programming>,1,3,,,"Is there a software to simplify commutators such as $[{\hat a}^\dagger{\hat a}^\dagger {\hat a},{\hat a}^\dagger\hat a \hat a]$? <p>Sometimes I need to simplify some commutators in the form
<span class=""math-container"">$[{\hat a}^\dagger{\hat a}^\dagger {\hat a},{\hat a}^\dagger\hat a \hat a]$</span>.</p>
<p>Doing it by hand is exhausting and boring.
Is there software (Matlab, Python, Mathematica, etc) that can handle such commutators?</p>
",qc,software simplify commutators p sometimes need simplify commutators form span p hand exhausting boring software matlab python mathematica etc handle commutators,"[(7, 0.06349044), (11, 0.118847646), (14, 0.43446276), (15, 0.282606), (17, 0.09277313)]"
23418,23419.0,2021-12-26 06:06:40,3,168,"<p>In Nielsen and Chuang's QC&amp;QI, I do not see a statement one way or another. In Steeb and Hardy's <em>Problems and Solutions</em>, orthogonality is asserted. If the <span class=""math-container"">$p_i$</span> in <span class=""math-container"">$\sum_i p_i |\psi_i\rangle\langle\psi_i|$</span> were guaranteed to be distinct, then the eigenvalues would be distinct and orthogonality would be assured. In the general case, I don't know, and I wonder if this question is important given that the <span class=""math-container"">$\psi_i$</span> are not uniquely determined.</p>
",Are the states in the convex decomposition of a density matrix necessarily orthogonal?,<quantum-state><textbook-and-exercises><nielsen-and-chuang><density-matrix><linear-algebra>,2,1,,,"Are the states in the convex decomposition of a density matrix necessarily orthogonal? <p>In Nielsen and Chuang's QC&amp;QI, I do not see a statement one way or another. In Steeb and Hardy's <em>Problems and Solutions</em>, orthogonality is asserted. If the <span class=""math-container"">$p_i$</span> in <span class=""math-container"">$\sum_i p_i |\psi_i\rangle\langle\psi_i|$</span> were guaranteed to be distinct, then the eigenvalues would be distinct and orthogonality would be assured. In the general case, I don't know, and I wonder if this question is important given that the <span class=""math-container"">$\psi_i$</span> are not uniquely determined.</p>
",qc,states convex decomposition density matrix necessarily orthogonal p nielsen chuang qc amp qi see statement one way another steeb hardy em problems solutions orthogonality asserted span span guaranteed distinct eigenvalues would distinct orthogonality would assured general case know wonder question important given span uniquely,"[(1, 0.10679639), (3, 0.7041178), (11, 0.06262918), (14, 0.045340054), (15, 0.028219607), (17, 0.049496178)]"
23437,23445.0,2021-12-27 11:47:07,4,410,"<p>I was reading <em>Quantum Computing in the NISQ era and beyond</em> (John Preskill, 2018) but I didn't get this point on pages 9-10:</p>
<blockquote>
<p>There is a substantial opportunity for experimentalists and theorists, working together
over the next few years, to find better ways of making quantum circuits noise resilient, and so extend the computational reach of NISQ technology. We should be wary, though,
of a potential tradeoff — <strong>making a quantum circuit more noise resilient may also make it easier to simulate classically</strong>.</p>
</blockquote>
<p>How does making a quantum circuit more noise resilient may also make it easier to simulate classically? What noise mitigation techniques could imply this?</p>
",Why does making a quantum circuit more noise resilient make it easier to simulate classically?,<experimental-realization><noise><error-mitigation>,3,1,,,"Why does making a quantum circuit more noise resilient make it easier to simulate classically? <p>I was reading <em>Quantum Computing in the NISQ era and beyond</em> (John Preskill, 2018) but I didn't get this point on pages 9-10:</p>
<blockquote>
<p>There is a substantial opportunity for experimentalists and theorists, working together
over the next few years, to find better ways of making quantum circuits noise resilient, and so extend the computational reach of NISQ technology. We should be wary, though,
of a potential tradeoff — <strong>making a quantum circuit more noise resilient may also make it easier to simulate classically</strong>.</p>
</blockquote>
<p>How does making a quantum circuit more noise resilient may also make it easier to simulate classically? What noise mitigation techniques could imply this?</p>
",qc,making quantum circuit noise resilient make easier simulate classically p reading em quantum computing nisq era beyond john preskill 2018 get point pages blockquote p substantial opportunity experimentalists theorists working together next years find better ways making quantum circuits noise resilient extend computational reach nisq technology wary though potential tradeoff strong making quantum circuit noise resilient may also make easier simulate classically p making quantum circuit noise resilient may also make easier simulate classically noise mitigation techniques could imply,"[(1, 0.21012472), (8, 0.22053462), (9, 0.21300183), (14, 0.340448), (17, 0.013894208)]"
23451,23973.0,2021-12-28 06:24:03,1,432,"<p>I am trying to multiply a symbol with a matrix which is defined by QuTip quantum object, but I got this error:</p>
<pre><code>TypeError: Incompatible object for multiplication
</code></pre>
<p>I used:</p>
<pre><code>from qutip import *
import sympy as sp
w0 = sp.Symbol('\omega_{0}')
w0*destroy(4)
</code></pre>
<p>Did I miss something?</p>
",QuTip: How to multiply symbol with matrix,<programming><qutip>,1,1,,,"QuTip: How to multiply symbol with matrix <p>I am trying to multiply a symbol with a matrix which is defined by QuTip quantum object, but I got this error:</p>
<pre><code>TypeError: Incompatible object for multiplication
</code></pre>
<p>I used:</p>
<pre><code>from qutip import *
import sympy as sp
w0 = sp.Symbol('\omega_{0}')
w0*destroy(4)
</code></pre>
<p>Did I miss something?</p>
",qc,qutip multiply symbol matrix p trying multiply symbol matrix defined qutip quantum object got error pre code typeerror incompatible object multiplication p used pre code qutip import import sympy sp w0 0 w0 destroy 4 p miss something,"[(0, 0.5688479), (4, 0.10415822), (11, 0.21810386), (15, 0.042897657), (17, 0.06206331)]"
23460,23461.0,2021-12-28 23:31:08,4,582,"<p>In 1938, in a famous paper, Alan Turing proved that you could simulate any Turing machine with the following six primitive operations:</p>
<pre><code>1. Move one square to the right
2. Move one square to the left
3. Write a symbol on the current square
4. Read any symbols on the current square
5. Erase any symbols on the current square
6. Do nothing
</code></pre>
<p>Is there an analogous set of minimum primitive operations for a quantum computer? Or is it the same set?</p>
",What is the minimum set of primitive operations for a quantum computer?,<quantum-turing-machine>,2,2,,,"What is the minimum set of primitive operations for a quantum computer? <p>In 1938, in a famous paper, Alan Turing proved that you could simulate any Turing machine with the following six primitive operations:</p>
<pre><code>1. Move one square to the right
2. Move one square to the left
3. Write a symbol on the current square
4. Read any symbols on the current square
5. Erase any symbols on the current square
6. Do nothing
</code></pre>
<p>Is there an analogous set of minimum primitive operations for a quantum computer? Or is it the same set?</p>
",qc,minimum set primitive operations quantum computer p 1938 famous paper alan turing proved could simulate turing machine following six primitive operations pre code 1 move one square right move one square left write symbol current square read symbols current square erase symbols current square nothing p analogous set minimum primitive operations quantum computer set,"[(3, 0.1549856), (8, 0.3680287), (9, 0.10762739), (14, 0.32501706), (17, 0.04146549)]"
23480,23484.0,2021-12-30 02:21:05,4,1254,"<p>Suppose <span class=""math-container"">$\Phi$</span> is a CPTP map with Kraus operators <span class=""math-container"">$\phi_n$</span>, so that <span class=""math-container"">$\hat{\Phi} := Σ_n (\phi_n ⊗ \phi_n^*)$</span> is the matrix representation (here <span class=""math-container"">$*$</span> being entry-wise complex conjugate).</p>
<p><em>Is there an upper bound for <span class=""math-container"">$\|\hat{\Phi}\|_{\rm op}$</span> (where <span class=""math-container"">$\|\cdot\|_{\rm op}$</span> is &quot;operator norm&quot; / max-singular value)? And how should I interpret this quantity?</em></p>
<p>I need this for purely technical reasons (i.e. to bound some other quantity), but I'd still like to know what it means. I know it must be at least <span class=""math-container"">$\leq\sqrt{d}$</span>, because e.g. it happens for the 1-qubit completely amplitude damping channel (defined <a href=""https://en.wikipedia.org/wiki/Amplitude_damping_channel"" rel=""nofollow noreferrer"">here</a>, with <span class=""math-container"">$\gamma=1$</span>). I also generated a 2-qubit channel from the single-qubit amplitude damping (with Kraus operators <span class=""math-container"">$\phi_i\otimes\phi_j$</span>, which to be fair I'm assuming it <em>is indeed</em> a channel) and the same holds. Furthermore, I'm tempted to understand this operator norm as a measure of how much the purity of a state (or I guess in a sense it's coherence) can be increased with the channel: for the example I cited of the amplitude damping channel, such case takes any state to the <span class=""math-container"">$|0\rangle$</span> state, <strike>on the other hand, if I try a totally depolarizing channel (such that <span class=""math-container"">$\Phi(\cdot)=\boldsymbol{1}/d$</span> ), then I get <span class=""math-container"">$\|\hat{\Phi}\|=1/2$</span> (which anyhow, <em>is not</em> <span class=""math-container"">$1/\sqrt{2}$</span>, as I would've expected)</strike>. I just haven't been able to prove or understand this generally.</p>
",Is there an upper-bound on the operator norm (max-singular value) of the matrix representation of a quantum channel?,<quantum-operation><kraus-representation>,4,1,,,"Is there an upper-bound on the operator norm (max-singular value) of the matrix representation of a quantum channel? <p>Suppose <span class=""math-container"">$\Phi$</span> is a CPTP map with Kraus operators <span class=""math-container"">$\phi_n$</span>, so that <span class=""math-container"">$\hat{\Phi} := Σ_n (\phi_n ⊗ \phi_n^*)$</span> is the matrix representation (here <span class=""math-container"">$*$</span> being entry-wise complex conjugate).</p>
<p><em>Is there an upper bound for <span class=""math-container"">$\|\hat{\Phi}\|_{\rm op}$</span> (where <span class=""math-container"">$\|\cdot\|_{\rm op}$</span> is &quot;operator norm&quot; / max-singular value)? And how should I interpret this quantity?</em></p>
<p>I need this for purely technical reasons (i.e. to bound some other quantity), but I'd still like to know what it means. I know it must be at least <span class=""math-container"">$\leq\sqrt{d}$</span>, because e.g. it happens for the 1-qubit completely amplitude damping channel (defined <a href=""https://en.wikipedia.org/wiki/Amplitude_damping_channel"" rel=""nofollow noreferrer"">here</a>, with <span class=""math-container"">$\gamma=1$</span>). I also generated a 2-qubit channel from the single-qubit amplitude damping (with Kraus operators <span class=""math-container"">$\phi_i\otimes\phi_j$</span>, which to be fair I'm assuming it <em>is indeed</em> a channel) and the same holds. Furthermore, I'm tempted to understand this operator norm as a measure of how much the purity of a state (or I guess in a sense it's coherence) can be increased with the channel: for the example I cited of the amplitude damping channel, such case takes any state to the <span class=""math-container"">$|0\rangle$</span> state, <strike>on the other hand, if I try a totally depolarizing channel (such that <span class=""math-container"">$\Phi(\cdot)=\boldsymbol{1}/d$</span> ), then I get <span class=""math-container"">$\|\hat{\Phi}\|=1/2$</span> (which anyhow, <em>is not</em> <span class=""math-container"">$1/\sqrt{2}$</span>, as I would've expected)</strike>. I just haven't been able to prove or understand this generally.</p>
",qc,operator norm value matrix representation quantum channel p suppose span cptp map kraus operators span span matrix representation span complex conjugate p em upper bound span op span op quot operator norm quot value interpret quantity p need purely technical reasons bound quantity still like know means know must least span happens completely amplitude damping channel defined https nofollow noreferrer span also generated channel amplitude damping kraus operators span fair assuming em indeed channel holds furthermore tempted understand operator norm measure much purity state guess sense coherence increased channel example cited amplitude damping channel case takes state span state strike hand try totally depolarizing channel span 1 get span anyhow em span 2 would expected able prove understand,"[(3, 0.7031637), (4, 0.021333707), (8, 0.052100446), (11, 0.02770849), (13, 0.017957643), (17, 0.069551736), (18, 0.06582247), (19, 0.03226102)]"
23507,23513.0,2021-12-31 13:41:32,3,188,"<p>What is the fastest and most resource-efficient way to create an LUT decoder for a quantum error correction code using Stim (<a href=""https://quantum-journal.org/papers/q-2021-07-06-497/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2021-07-06-497/</a>)?</p>
<p>Specfically, I am running simulations of a steane QECC using several conditional loops (this was addressed in the question <a href=""https://quantumcomputing.stackexchange.com/questions/22281/simulating-flag-qubits-and-conditional-branches-using-stim"">Simulating flag qubits and conditional branches using Stim</a>).</p>
<p>Is there an efficient way to create the relevant LUTs as well using the TableauSimulator?</p>
",Efficient Way to Create an LUT in Stim,<programming><error-correction><stim>,1,0,,,"Efficient Way to Create an LUT in Stim <p>What is the fastest and most resource-efficient way to create an LUT decoder for a quantum error correction code using Stim (<a href=""https://quantum-journal.org/papers/q-2021-07-06-497/"" rel=""nofollow noreferrer"">https://quantum-journal.org/papers/q-2021-07-06-497/</a>)?</p>
<p>Specfically, I am running simulations of a steane QECC using several conditional loops (this was addressed in the question <a href=""https://quantumcomputing.stackexchange.com/questions/22281/simulating-flag-qubits-and-conditional-branches-using-stim"">Simulating flag qubits and conditional branches using Stim</a>).</p>
<p>Is there an efficient way to create the relevant LUTs as well using the TableauSimulator?</p>
",qc,efficient way create lut stim p fastest way create lut decoder quantum error correction code using stim https nofollow noreferrer https p specfically running simulations steane qecc using several conditional loops addressed question https simulating flag qubits conditional branches using stim p efficient way create relevant luts well using tableausimulator,"[(4, 0.1238805), (5, 0.22437827), (7, 0.03402532), (9, 0.04133965), (14, 0.5497054), (17, 0.023636043)]"
23554,23569.0,2022-01-04 18:11:10,0,84,"<p>I'm an undergrad who would like to run some experiments using the surface code. I've been able to use their quantum repetition code (<a href=""https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html</a>) but how do I access the surface code?</p>
<p>If its not possible, are there any other open source software besides qiskit that allow users to run their surface codes?</p>
",Is it possible for public users to run experiments using Qiskit's surface code?,<qiskit><error-correction><surface-code>,1,1,,,"Is it possible for public users to run experiments using Qiskit's surface code? <p>I'm an undergrad who would like to run some experiments using the surface code. I've been able to use their quantum repetition code (<a href=""https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html</a>) but how do I access the surface code?</p>
<p>If its not possible, are there any other open source software besides qiskit that allow users to run their surface codes?</p>
",qc,possible public users run experiments using qiskit surface code p undergrad would like run experiments using surface code able use quantum repetition code https nofollow noreferrer https access surface code p possible open source software besides qiskit allow users run surface codes,"[(4, 0.15062253), (5, 0.22230248), (8, 0.047969908), (14, 0.5217012), (17, 0.05384498)]"
23578,23581.0,2022-01-05 22:25:29,1,332,"<p>I am reading this paper: <a href=""https://arxiv.org/pdf/2106.09567.pdf"" rel=""nofollow noreferrer"">Quantum Generative Training Using Rényi Divergences</a>. In it, the authors mention the following multiple times:</p>
<blockquote>
<p>&quot;...an unbounded loss function can circumvent the existing no-go results&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...unbounded loss functions, such as the quantum relative entropy...&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...unbounded loss function such as maximal Rényi divergence of order two...&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...other unbounded loss functions such as relative entropy...&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...entanglement between the hidden and visible layers can still destroy the ability to train the network with respect to the bounded loss function...&quot;</p>
</blockquote>
<p>I have no clue what they mean by &quot;unbounded/bounded loss function&quot; here. At one point, they also say:</p>
<blockquote>
<p>&quot;Existing algorithms almost exclusively utilize a <strong>linear bounded operator</strong> as a loss function. This condition is quite reasonable because the loss function is typically estimated by measuring the expectation values of Hermitian operators&quot;</p>
</blockquote>
<p>I am not sure if this usage of &quot;linear bounded operator&quot; is related; if not, what does it mean?</p>
","What are ""unbounded loss functions"" and ""unbounded operators""?",<vqe><machine-learning><terminology-and-notation><neural-network><quantum-neural-network>,1,0,,,"What are ""unbounded loss functions"" and ""unbounded operators""? <p>I am reading this paper: <a href=""https://arxiv.org/pdf/2106.09567.pdf"" rel=""nofollow noreferrer"">Quantum Generative Training Using Rényi Divergences</a>. In it, the authors mention the following multiple times:</p>
<blockquote>
<p>&quot;...an unbounded loss function can circumvent the existing no-go results&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...unbounded loss functions, such as the quantum relative entropy...&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...unbounded loss function such as maximal Rényi divergence of order two...&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...other unbounded loss functions such as relative entropy...&quot;</p>
</blockquote>
<blockquote>
<p>&quot;...entanglement between the hidden and visible layers can still destroy the ability to train the network with respect to the bounded loss function...&quot;</p>
</blockquote>
<p>I have no clue what they mean by &quot;unbounded/bounded loss function&quot; here. At one point, they also say:</p>
<blockquote>
<p>&quot;Existing algorithms almost exclusively utilize a <strong>linear bounded operator</strong> as a loss function. This condition is quite reasonable because the loss function is typically estimated by measuring the expectation values of Hermitian operators&quot;</p>
</blockquote>
<p>I am not sure if this usage of &quot;linear bounded operator&quot; is related; if not, what does it mean?</p>
",qc,unbounded loss functions unbounded operators p reading paper https nofollow noreferrer quantum generative training using rényi divergences authors mention following multiple times blockquote p quot unbounded loss function circumvent existing results quot blockquote p quot unbounded loss functions quantum relative entropy quot blockquote p quot unbounded loss function maximal rényi divergence order two quot blockquote p quot unbounded loss functions relative entropy quot blockquote p quot entanglement hidden visible layers still destroy ability train network respect bounded loss function quot p clue mean quot loss function quot one point also say blockquote p quot existing algorithms almost exclusively utilize strong linear bounded operator loss function condition quite reasonable loss function typically estimated measuring expectation values hermitian operators quot p sure usage quot linear bounded operator quot related mean,"[(3, 0.26375422), (4, 0.025798496), (5, 0.02172168), (8, 0.30298796), (13, 0.0149036), (14, 0.03324446), (17, 0.050799057), (18, 0.043400727), (19, 0.24250285)]"
23583,26740.0,2022-01-06 13:30:41,9,628,"<p>I want to impliment Projector Control-Not in Qiskit just like in this <a href=""https://i.sstatic.net/wYOul.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/wYOul.png"" alt=""image"" /></a>, which is a <span class=""math-container"">$|0\rangle\langle 0|$</span> projector found in the paper &quot;<a href=""https://arxiv.org/abs/2105.02859"" rel=""noreferrer"">Grand Unification of Quantum Algorithm</a>&quot; page 7. Also, is the angle <span class=""math-container"">$\phi$</span> and the exp same as the parameter of rz(<span class=""math-container"">$\phi$</span>) in Qiskit.</p>
",How to implement Projector Control-Not in Qiskit?,<qiskit><circuit-construction>,2,0,,,"How to implement Projector Control-Not in Qiskit? <p>I want to impliment Projector Control-Not in Qiskit just like in this <a href=""https://i.sstatic.net/wYOul.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/wYOul.png"" alt=""image"" /></a>, which is a <span class=""math-container"">$|0\rangle\langle 0|$</span> projector found in the paper &quot;<a href=""https://arxiv.org/abs/2105.02859"" rel=""noreferrer"">Grand Unification of Quantum Algorithm</a>&quot; page 7. Also, is the angle <span class=""math-container"">$\phi$</span> and the exp same as the parameter of rz(<span class=""math-container"">$\phi$</span>) in Qiskit.</p>
",qc,implement projector qiskit p want impliment projector qiskit like https noreferrer img https image span projector found paper quot https noreferrer grand unification quantum algorithm quot page also angle span exp parameter rz span,"[(3, 0.15407246), (4, 0.38640127), (8, 0.20901975), (9, 0.09878859), (17, 0.074113615), (19, 0.07338531)]"
23617,,2022-01-10 01:48:45,1,167,"<p>I am running some experiments on a real quantum backend of IBM with qmeans approach. My dataset has 2 features (2 dimensions).</p>
<p>I observe higher execution time on the Quantum Calculate Distance routine than on the classical euclidean distance. I cannot understand why, though. Any thoughts?</p>
",Time execution on real quantum backend higher than classical kmeans,<qubit-mapping>,1,0,,,"Time execution on real quantum backend higher than classical kmeans <p>I am running some experiments on a real quantum backend of IBM with qmeans approach. My dataset has 2 features (2 dimensions).</p>
<p>I observe higher execution time on the Quantum Calculate Distance routine than on the classical euclidean distance. I cannot understand why, though. Any thoughts?</p>
",qc,time execution real quantum backend higher classical kmeans p running experiments real quantum backend ibm qmeans approach dataset 2 features 2 dimensions p observe higher execution time quantum calculate distance routine classical euclidean distance understand though thoughts,"[(0, 0.10988718), (1, 0.21109106), (2, 0.053579763), (8, 0.20229179), (14, 0.30252492), (17, 0.11664531)]"
23635,23636.0,2022-01-11 01:56:28,2,969,"<p>There is a Hamiltonian I want to construct by a Python package, which is the following:
<span class=""math-container"">$$
H = 5.9I + 0.21Z_0 - 6.12 Z_1 - 2.14(X_0X_1 + Y_0Y_1) + 9.6(I-Z_2) - 3.9(X_1X_2 + Y_1Y_2)
$$</span>
It is very easy for me to create this Hamiltonian by the Python package Projectq. That is:</p>
<pre><code>h = 5.9*QubitOperator('') + 0.21*QubitOperator('Z0') - 6.12*QubitOperator('Z1') - 2.14*(QubitOperator('X0 X1')+QubitOperator('Y0 Y1') )+ 9.6*(QubitOperator('')-QubitOperator('Z2')) - 3.9*(QubitOperator('X1 X2') + QubitOperator('Y1 Y2') )
</code></pre>
<p>However, I want to do this by qiskit. Are there any command like <code>QubitOperator()</code> in qiskit?</p>
",How to construct a Hamiltonian containing Pauli string by qiskit?,<qiskit><programming><ibm-q-experience>,1,0,,,"How to construct a Hamiltonian containing Pauli string by qiskit? <p>There is a Hamiltonian I want to construct by a Python package, which is the following:
<span class=""math-container"">$$
H = 5.9I + 0.21Z_0 - 6.12 Z_1 - 2.14(X_0X_1 + Y_0Y_1) + 9.6(I-Z_2) - 3.9(X_1X_2 + Y_1Y_2)
$$</span>
It is very easy for me to create this Hamiltonian by the Python package Projectq. That is:</p>
<pre><code>h = 5.9*QubitOperator('') + 0.21*QubitOperator('Z0') - 6.12*QubitOperator('Z1') - 2.14*(QubitOperator('X0 X1')+QubitOperator('Y0 Y1') )+ 9.6*(QubitOperator('')-QubitOperator('Z2')) - 3.9*(QubitOperator('X1 X2') + QubitOperator('Y1 Y2') )
</code></pre>
<p>However, I want to do this by qiskit. Are there any command like <code>QubitOperator()</code> in qiskit?</p>
",qc,construct hamiltonian containing pauli string qiskit p hamiltonian want construct python package following span h easy create hamiltonian python package projectq pre code h qubitoperator qubitoperator qubitoperator qubitoperator x1 y1 qubitoperator qubitoperator x2 qubitoperator y2 p however want qiskit command like code qubitoperator qiskit,"[(1, 0.0794162), (3, 0.051060006), (7, 0.23173273), (14, 0.5121813), (17, 0.12213638)]"
23688,23689.0,2022-01-14 07:10:49,4,167,"<p>Niesen and Chuang, 2nd edition, page 107, Box 2.6, in its motivation for partial trace, says that if M is an observable on system A and <span class=""math-container"">$\tilde{M}$</span> is the corresponding observable on system AB, then it is physically reasonable that the average measurement outcomes computed for the two operators are equal. That is,</p>
<p><span class=""math-container"">$$\mathrm{tr}(M\rho^A)=\mathrm{tr}(\tilde{M}\rho^{AB})=\mathrm{tr}((M\otimes I_B)\rho^{AB})$$</span></p>
<p>I have no problem with these statements, but they go on to say that this is &quot;obviously satisfied&quot; if <span class=""math-container"">$\rho^A=\mathrm{tr}_B(\rho^{AB})$</span>.</p>
<p>This loses me.</p>
<p>The partial trace is defined by <span class=""math-container"">$\mathrm{tr}_B(A\otimes B)\equiv A \mathrm{tr}(B)$</span>, I believe.</p>
",Why does $\rho^A=\mathrm{tr}_B(\rho^{AB})$ guarantee that $\mathrm{tr}(M\rho^A)=\mathrm{tr}((M\otimes I_B)\rho^{AB})$?,<textbook-and-exercises><density-matrix><linear-algebra>,4,0,,,"Why does $\rho^A=\mathrm{tr}_B(\rho^{AB})$ guarantee that $\mathrm{tr}(M\rho^A)=\mathrm{tr}((M\otimes I_B)\rho^{AB})$? <p>Niesen and Chuang, 2nd edition, page 107, Box 2.6, in its motivation for partial trace, says that if M is an observable on system A and <span class=""math-container"">$\tilde{M}$</span> is the corresponding observable on system AB, then it is physically reasonable that the average measurement outcomes computed for the two operators are equal. That is,</p>
<p><span class=""math-container"">$$\mathrm{tr}(M\rho^A)=\mathrm{tr}(\tilde{M}\rho^{AB})=\mathrm{tr}((M\otimes I_B)\rho^{AB})$$</span></p>
<p>I have no problem with these statements, but they go on to say that this is &quot;obviously satisfied&quot; if <span class=""math-container"">$\rho^A=\mathrm{tr}_B(\rho^{AB})$</span>.</p>
<p>This loses me.</p>
<p>The partial trace is defined by <span class=""math-container"">$\mathrm{tr}_B(A\otimes B)\equiv A \mathrm{tr}(B)$</span>, I believe.</p>
",qc,tr ab guarantee tr tr ab p niesen chuang 2nd edition page 107 box motivation partial trace says observable system span corresponding observable system ab physically reasonable average measurement outcomes computed two operators equal p span tr tr ab tr ab p problem statements go say quot obviously satisfied quot span tr ab p loses p partial trace defined span tr b tr b,"[(3, 0.9415926), (17, 0.020637173), (19, 0.035035904)]"
23768,23769.0,2022-01-23 03:32:05,3,654,"<p>I have a Stim <a href=""https://github.com/quantumlib/Stim/blob/main/doc/file_format_dem_detector_error_model.md"" rel=""nofollow noreferrer"">detector error model file</a> derived from a surface code circuit. I'm trying to understand exactly what lines like <code>error(0.00033) D0 D9 L0 ^ D7 ^ D8</code> from the model file mean.</p>
<ol>
<li>Is the 0.00033 a probability?</li>
<li>What's the distinction between <code>L0</code> and <code>D0</code>?</li>
<li>Why are there multiple parts to the error, separated by <code>^</code>? Is this the X and Z parts of the matching graph?</li>
<li>Why is it three parts instead of two?</li>
</ol>
","Where do lines like ""error(0.00033) D0 D9 L0 ^ D7 ^ D8"" come from in a stim detector error model?",<stim>,1,1,,,"Where do lines like ""error(0.00033) D0 D9 L0 ^ D7 ^ D8"" come from in a stim detector error model? <p>I have a Stim <a href=""https://github.com/quantumlib/Stim/blob/main/doc/file_format_dem_detector_error_model.md"" rel=""nofollow noreferrer"">detector error model file</a> derived from a surface code circuit. I'm trying to understand exactly what lines like <code>error(0.00033) D0 D9 L0 ^ D7 ^ D8</code> from the model file mean.</p>
<ol>
<li>Is the 0.00033 a probability?</li>
<li>What's the distinction between <code>L0</code> and <code>D0</code>?</li>
<li>Why are there multiple parts to the error, separated by <code>^</code>? Is this the X and Z parts of the matching graph?</li>
<li>Why is it three parts instead of two?</li>
</ol>
",qc,lines like error d0 d9 l0 d7 d8 come stim detector error model p stim https nofollow noreferrer detector error model file derived surface code circuit trying understand exactly lines like code error d0 d9 l0 d7 d8 model file ol li probability li distinction code l0 code d0 li multiple parts error separated code x z parts matching graph li three parts instead two,"[(3, 0.022621045), (4, 0.04398514), (5, 0.4631112), (6, 0.08971696), (7, 0.13419296), (13, 0.07321135), (14, 0.11608218), (17, 0.01774917), (19, 0.037368424)]"
23771,23772.0,2022-01-23 12:56:01,0,113,"<p>I am trying to play with <code>NoiseModel</code> of <code>qiskit</code>, and I noticed that error on id gate is not giving any error results, while error on the measurement (or other gates) does give an error:</p>
<pre><code>def get_noise_model(p_err):
    error_gate1 = pauli_error([(&quot;X&quot;, p_err / 2), (&quot;Z&quot;, p_err / 2), (&quot;I&quot;, 1 - p_err)])
    noise_model = NoiseModel()
    noise_model.add_all_qubit_quantum_error(error_gate1, &quot;id&quot;)
    print(error_gate1)
    return noise_model

qc = QuantumCircuit(2, 2)
qc.id(0)
qc.measure([0, 1], [0, 1])

results = (execute(qc,Aer.get_backend(&quot;aer_simulator&quot;),noise_model=get_noise_model(0.2),shots=2048).result().get_counts())

plot_histogram(results)
</code></pre>
<p>Histogram:
<a href=""https://i.sstatic.net/FScYS.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/FScYS.png"" alt=""enter image description here"" /></a></p>
<p>And changing to :</p>
<pre><code>noise_model.add_all_qubit_quantum_error(error_gate1, &quot;measure&quot;)
</code></pre>
<p>gives that:
<a href=""https://i.sstatic.net/QEENi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QEENi.png"" alt=""enter image description here"" /></a></p>
<p>Why is that happening? If I perform noisy <code>id</code> gate</p>
<p>imports needed:</p>
<pre><code>from qiskit.visualization import plot_histogram
from qiskit.providers.aer.noise import NoiseModel
from qiskit.providers.aer.noise.errors import pauli_error
from qiskit import QuantumCircuit, execute , Aer
</code></pre>
","Error Model on id gate, is not giving any error",<qiskit><programming><quantum-gate><noise>,1,0,,,"Error Model on id gate, is not giving any error <p>I am trying to play with <code>NoiseModel</code> of <code>qiskit</code>, and I noticed that error on id gate is not giving any error results, while error on the measurement (or other gates) does give an error:</p>
<pre><code>def get_noise_model(p_err):
    error_gate1 = pauli_error([(&quot;X&quot;, p_err / 2), (&quot;Z&quot;, p_err / 2), (&quot;I&quot;, 1 - p_err)])
    noise_model = NoiseModel()
    noise_model.add_all_qubit_quantum_error(error_gate1, &quot;id&quot;)
    print(error_gate1)
    return noise_model

qc = QuantumCircuit(2, 2)
qc.id(0)
qc.measure([0, 1], [0, 1])

results = (execute(qc,Aer.get_backend(&quot;aer_simulator&quot;),noise_model=get_noise_model(0.2),shots=2048).result().get_counts())

plot_histogram(results)
</code></pre>
<p>Histogram:
<a href=""https://i.sstatic.net/FScYS.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/FScYS.png"" alt=""enter image description here"" /></a></p>
<p>And changing to :</p>
<pre><code>noise_model.add_all_qubit_quantum_error(error_gate1, &quot;measure&quot;)
</code></pre>
<p>gives that:
<a href=""https://i.sstatic.net/QEENi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QEENi.png"" alt=""enter image description here"" /></a></p>
<p>Why is that happening? If I perform noisy <code>id</code> gate</p>
<p>imports needed:</p>
<pre><code>from qiskit.visualization import plot_histogram
from qiskit.providers.aer.noise import NoiseModel
from qiskit.providers.aer.noise.errors import pauli_error
from qiskit import QuantumCircuit, execute , Aer
</code></pre>
",qc,error model id gate giving error p trying play code noisemodel code qiskit noticed error id gate giving error results error measurement gates give error pre code def quot x quot 2 quot z quot 2 quot quot 1 noisemodel quot id quot print return qc quantumcircuit 2 2 0 0 1 0 1 results execute qc quot quot results p histogram https nofollow noreferrer img https enter image description p changing pre code quot measure quot p gives https nofollow noreferrer img https enter image description p happening perform noisy code id gate p imports needed pre code import import noisemodel import qiskit import quantumcircuit execute aer,"[(0, 0.289646), (2, 0.08970192), (4, 0.2288639), (5, 0.07174), (14, 0.13350253), (17, 0.050574027), (19, 0.13476996)]"
23800,23827.0,2022-01-25 04:15:11,2,182,"<p>The error rates that I found on the calibration files are given in percentage, but I couldn't find whether it is calculated on full-scale (% FS) or on percentage of reading (% RD). If I do <span class=""math-container"">$20000$</span> shots and found <span class=""math-container"">$|00\rangle$</span>  at <span class=""math-container"">$5000$</span> with an error rate of <span class=""math-container"">$1\%$</span>, should it be <span class=""math-container"">$5000 \pm 200$</span> or <span class=""math-container"">$5000 \pm 50$</span>? Thank you!</p>
",Is the error rate of IBMQ devices full-scale (% FS) or on percentage of reading (% RD)?,<qiskit><ibm-q-experience><ibm-quantum-devices>,1,0,,,"Is the error rate of IBMQ devices full-scale (% FS) or on percentage of reading (% RD)? <p>The error rates that I found on the calibration files are given in percentage, but I couldn't find whether it is calculated on full-scale (% FS) or on percentage of reading (% RD). If I do <span class=""math-container"">$20000$</span> shots and found <span class=""math-container"">$|00\rangle$</span>  at <span class=""math-container"">$5000$</span> with an error rate of <span class=""math-container"">$1\%$</span>, should it be <span class=""math-container"">$5000 \pm 200$</span> or <span class=""math-container"">$5000 \pm 50$</span>? Thank you!</p>
",qc,error rate ibmq devices fs percentage reading rd p error rates found calibration files given percentage could find whether calculated fs percentage reading rd span 20000 shots found span span 5000 error rate span span 5000 200 span 5000 50 thank,"[(0, 0.07778185), (3, 0.20602503), (5, 0.16352952), (8, 0.17889236), (14, 0.30296513), (16, 0.04216386), (17, 0.02539979)]"
23859,23860.0,2022-01-29 05:19:14,3,303,"<p>When I use stim to simulate d=3 Bacon-Shor's code, I can't find the problem with my circuits resulting in the weird DetectorErrorModel.
The initialization and stabilizer measurement circuits are as follow:
<img src=""https://github.com/inmzhang123/picgo/blob/picgo/202201291309.png?raw=true"" alt=""layout"" /></p>
<p><img src=""https://github.com/inmzhang123/picgo/blob/picgo/202201291301.png?raw=true"" alt=""circuits"" /></p>
<p>I focus on <span class=""math-container"">$|0\rangle _L$</span> memory simulation and choose not to use reset after measurement. So with three rounds of stabilizer measurements, the detectors are</p>
<pre><code>...
DETECTOR(0, 0, 0) rec[-4]
DETECTOR(1, 0, 0) rec[-3]
...
SHIFT_COORDS(0, 0, 1)
DETECTOR(0, 0, 0) rec[-4]
DETECTOR(1, 0, 0) rec[-3]
...
SHIFT_COORDS(0, 0, 1)
DETECTOR(0, 0, 0) rec[-4] rec[-8]
DETECTOR(1, 0, 0) rec[-3] rec[-7]
...
DETECTOR(0, 0, 1) rec[-9] rec[-6] rec[-8] rec[-5] rec[-7] rec[-4] rec[-13] rec[-17]
DETECTOR(1, 0, 1) rec[-6] rec[-3] rec[-5] rec[-2] rec[-4] rec[-1] rec[-12] rec[-16]
</code></pre>
<p>some error I can't understand appear in auto-generated DetectorErrorModel like <code>D0 D4 L0 ^ D1 D5 ^ L0</code>.</p>
<p>Here is my <code>stim.Circuit</code> file and generated error_model:</p>
<p><strong>circuit.txt</strong></p>
<pre><code>stim.Circuit('''
    R 0 1 2 3 4 5 6 7 8 9 10 11 12
    H 0
    DEPOLARIZE1(0.001) 0
    CX 0 1
    DEPOLARIZE2(0.02) 0 1
    CX 1 2
    DEPOLARIZE2(0.02) 1 2
    H 3
    DEPOLARIZE1(0.001) 3
    CX 3 4
    DEPOLARIZE2(0.02) 3 4
    CX 4 5
    DEPOLARIZE2(0.02) 4 5
    H 6
    DEPOLARIZE1(0.001) 6
    CX 6 7
    DEPOLARIZE2(0.02) 6 7
    CX 7 8
    DEPOLARIZE2(0.02) 7 8
    H 0
    DEPOLARIZE1(0.001) 0
    H 1
    DEPOLARIZE1(0.001) 1
    H 2
    DEPOLARIZE1(0.001) 2
    H 3
    DEPOLARIZE1(0.001) 3
    H 4
    DEPOLARIZE1(0.001) 4
    H 5
    DEPOLARIZE1(0.001) 5
    H 6
    DEPOLARIZE1(0.001) 6
    H 7
    DEPOLARIZE1(0.001) 7
    H 8
    DEPOLARIZE1(0.001) 8 0 1 2 3 4 5 6 7 8
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 11 0
    DEPOLARIZE2(0.02) 11 0
    CX 12 1
    DEPOLARIZE2(0.02) 12 1
    DEPOLARIZE1(0.002) 2 3 4 5 6 7 8
    CX 11 1
    DEPOLARIZE2(0.02) 11 1
    CX 12 2
    DEPOLARIZE2(0.02) 12 2
    DEPOLARIZE1(0.002) 0 3 4 5 6 7 8
    CX 11 3
    DEPOLARIZE2(0.02) 11 3
    CX 12 4
    DEPOLARIZE2(0.02) 12 4
    DEPOLARIZE1(0.002) 0 1 2 5 6 7 8
    CX 11 4
    DEPOLARIZE2(0.02) 11 4
    CX 12 5
    DEPOLARIZE2(0.02) 12 5
    DEPOLARIZE1(0.002) 0 1 2 3 6 7 8
    CX 11 6
    DEPOLARIZE2(0.02) 11 6
    CX 12 7
    DEPOLARIZE2(0.02) 12 7
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 8
    CX 11 7
    DEPOLARIZE2(0.02) 11 7
    CX 12 8
    DEPOLARIZE2(0.02) 12 8
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 6
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 0 9
    DEPOLARIZE2(0.02) 0 9
    CX 3 10
    DEPOLARIZE2(0.02) 3 10
    DEPOLARIZE1(0.002) 1 2 4 5 6 7 8 11 12
    CX 3 9
    DEPOLARIZE2(0.02) 3 9
    CX 6 10
    DEPOLARIZE2(0.02) 6 10
    DEPOLARIZE1(0.002) 0 1 2 4 5 7 8 11 12
    CX 1 9
    DEPOLARIZE2(0.02) 1 9
    CX 4 10
    DEPOLARIZE2(0.02) 4 10
    DEPOLARIZE1(0.002) 0 2 3 5 6 7 8 11 12
    CX 4 9
    DEPOLARIZE2(0.02) 4 9
    CX 7 10
    DEPOLARIZE2(0.02) 7 10
    DEPOLARIZE1(0.002) 0 1 2 3 5 6 8 11 12
    CX 2 9
    DEPOLARIZE2(0.02) 2 9
    CX 5 10
    DEPOLARIZE2(0.02) 5 10
    DEPOLARIZE1(0.002) 0 1 3 4 6 7 8 11 12
    CX 5 9
    DEPOLARIZE2(0.02) 5 9
    CX 8 10
    DEPOLARIZE2(0.02) 8 10
    DEPOLARIZE1(0.002) 0 1 2 3 4 6 7 11 12
    DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
    X_ERROR(0.05) 9
    M 9
    X_ERROR(0.05) 10
    M 10
    X_ERROR(0.05) 11
    M 11
    X_ERROR(0.05) 12
    M 12
    DETECTOR(0, 0, 0) rec[-4]
    DETECTOR(1, 0, 0) rec[-3]
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 11 0
    DEPOLARIZE2(0.02) 11 0
    CX 12 1
    DEPOLARIZE2(0.02) 12 1
    DEPOLARIZE1(0.002) 2 3 4 5 6 7 8 9 10
    CX 11 1
    DEPOLARIZE2(0.02) 11 1
    CX 12 2
    DEPOLARIZE2(0.02) 12 2
    DEPOLARIZE1(0.002) 0 3 4 5 6 7 8 9 10
    CX 11 3
    DEPOLARIZE2(0.02) 11 3
    CX 12 4
    DEPOLARIZE2(0.02) 12 4
    DEPOLARIZE1(0.002) 0 1 2 5 6 7 8 9 10
    CX 11 4
    DEPOLARIZE2(0.02) 11 4
    CX 12 5
    DEPOLARIZE2(0.02) 12 5
    DEPOLARIZE1(0.002) 0 1 2 3 6 7 8 9 10
    CX 11 6
    DEPOLARIZE2(0.02) 11 6
    CX 12 7
    DEPOLARIZE2(0.02) 12 7
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 8 9 10
    CX 11 7
    DEPOLARIZE2(0.02) 11 7
    CX 12 8
    DEPOLARIZE2(0.02) 12 8
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 6 9 10
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 0 9
    DEPOLARIZE2(0.02) 0 9
    CX 3 10
    DEPOLARIZE2(0.02) 3 10
    DEPOLARIZE1(0.002) 1 2 4 5 6 7 8 11 12
    CX 3 9
    DEPOLARIZE2(0.02) 3 9
    CX 6 10
    DEPOLARIZE2(0.02) 6 10
    DEPOLARIZE1(0.002) 0 1 2 4 5 7 8 11 12
    CX 1 9
    DEPOLARIZE2(0.02) 1 9
    CX 4 10
    DEPOLARIZE2(0.02) 4 10
    DEPOLARIZE1(0.002) 0 2 3 5 6 7 8 11 12
    CX 4 9
    DEPOLARIZE2(0.02) 4 9
    CX 7 10
    DEPOLARIZE2(0.02) 7 10
    DEPOLARIZE1(0.002) 0 1 2 3 5 6 8 11 12
    CX 2 9
    DEPOLARIZE2(0.02) 2 9
    CX 5 10
    DEPOLARIZE2(0.02) 5 10
    DEPOLARIZE1(0.002) 0 1 3 4 6 7 8 11 12
    CX 5 9
    DEPOLARIZE2(0.02) 5 9
    CX 8 10
    DEPOLARIZE2(0.02) 8 10
    DEPOLARIZE1(0.002) 0 1 2 3 4 6 7 11 12
    DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
    X_ERROR(0.05) 9
    M 9
    X_ERROR(0.05) 10
    M 10
    X_ERROR(0.05) 11
    M 11
    X_ERROR(0.05) 12
    M 12
    SHIFT_COORDS(0, 0, 1)
    DETECTOR(0, 0, 0) rec[-4]
    DETECTOR(1, 0, 0) rec[-3]
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 11 0
    DEPOLARIZE2(0.02) 11 0
    CX 12 1
    DEPOLARIZE2(0.02) 12 1
    DEPOLARIZE1(0.002) 2 3 4 5 6 7 8 9 10
    CX 11 1
    DEPOLARIZE2(0.02) 11 1
    CX 12 2
    DEPOLARIZE2(0.02) 12 2
    DEPOLARIZE1(0.002) 0 3 4 5 6 7 8 9 10
    CX 11 3
    DEPOLARIZE2(0.02) 11 3
    CX 12 4
    DEPOLARIZE2(0.02) 12 4
    DEPOLARIZE1(0.002) 0 1 2 5 6 7 8 9 10
    CX 11 4
    DEPOLARIZE2(0.02) 11 4
    CX 12 5
    DEPOLARIZE2(0.02) 12 5
    DEPOLARIZE1(0.002) 0 1 2 3 6 7 8 9 10
    CX 11 6
    DEPOLARIZE2(0.02) 11 6
    CX 12 7
    DEPOLARIZE2(0.02) 12 7
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 8 9 10
    CX 11 7
    DEPOLARIZE2(0.02) 11 7
    CX 12 8
    DEPOLARIZE2(0.02) 12 8
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 6 9 10
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 0 9
    DEPOLARIZE2(0.02) 0 9
    CX 3 10
    DEPOLARIZE2(0.02) 3 10
    DEPOLARIZE1(0.002) 1 2 4 5 6 7 8 11 12
    CX 3 9
    DEPOLARIZE2(0.02) 3 9
    CX 6 10
    DEPOLARIZE2(0.02) 6 10
    DEPOLARIZE1(0.002) 0 1 2 4 5 7 8 11 12
    CX 1 9
    DEPOLARIZE2(0.02) 1 9
    CX 4 10
    DEPOLARIZE2(0.02) 4 10
    DEPOLARIZE1(0.002) 0 2 3 5 6 7 8 11 12
    CX 4 9
    DEPOLARIZE2(0.02) 4 9
    CX 7 10
    DEPOLARIZE2(0.02) 7 10
    DEPOLARIZE1(0.002) 0 1 2 3 5 6 8 11 12
    CX 2 9
    DEPOLARIZE2(0.02) 2 9
    CX 5 10
    DEPOLARIZE2(0.02) 5 10
    DEPOLARIZE1(0.002) 0 1 3 4 6 7 8 11 12
    CX 5 9
    DEPOLARIZE2(0.02) 5 9
    CX 8 10
    DEPOLARIZE2(0.02) 8 10
    DEPOLARIZE1(0.002) 0 1 2 3 4 6 7 11 12
    DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
    X_ERROR(0.05) 9
    M 9
    X_ERROR(0.05) 10
    M 10
    X_ERROR(0.05) 11
    M 11
    X_ERROR(0.05) 12
    M 12
    SHIFT_COORDS(0, 0, 1)
    DETECTOR(0, 0, 0) rec[-4] rec[-8]
    DETECTOR(1, 0, 0) rec[-3] rec[-7]
    X_ERROR(0.05) 0
    M 0
    X_ERROR(0.05) 1
    M 1
    X_ERROR(0.05) 2
    M 2
    X_ERROR(0.05) 3
    M 3
    X_ERROR(0.05) 4
    M 4
    X_ERROR(0.05) 5
    M 5
    X_ERROR(0.05) 6
    M 6
    X_ERROR(0.05) 7
    M 7
    X_ERROR(0.05) 8
    M 8
    DEPOLARIZE1(0.01) 9 10 11 12
    DETECTOR(0, 0, 1) rec[-9] rec[-6] rec[-8] rec[-5] rec[-7] rec[-4] rec[-13] rec[-17]
    DETECTOR(1, 0, 1) rec[-6] rec[-3] rec[-5] rec[-2] rec[-4] rec[-1] rec[-12] rec[-16]
    OBSERVABLE_INCLUDE(0) rec[-9] rec[-8] rec[-7]
''')
</code></pre>
<p><strong>error_model.txt</strong></p>
<pre><code>stim.DetectorErrorModel('''
    error(0.07819) D0 D2
    error(0.102128) D0 D4 L0
    error(0.102128) D0 D4 L0 ^ D1 D5 ^ L0
    error(0.0313222) D0 D4 L0 ^ D3 D5 ^ L0
    error(0.07819) D1 D3
    error(0.105303) D1 D5
    error(0.0860003) D2
    error(0.108379) D2 D4 L0
    error(0.117794) D2 D4 L0 ^ D3 D5 ^ L0
    error(0.0159144) D2 D4 L0 ^ D5 ^ L0
    error(0.0860003) D3
    error(0.108379) D3 D5
    error(0.117794) D4 D5
    error(0.0159144) D4 D5 ^ D2
    error(0.07239) D4 D6
    error(0.0313222) D4 D7
    error(0.120844) D4 L0
    error(0.0159144) D4 L0 ^ D2
    error(0.120844) D5
    error(0.07239) D5 D7
    error(0.0159144) D5 ^ D3
    error(0.166418) D6 D7
    error(0.169079) D6 L0
    error(0.0159144) D6 L0 ^ D4 L0
    error(0.166418) D7
    error(0.0159144) D7 ^ D5
    detector(0, 0, 0) D0
    detector(1, 0, 0) D1
    shift_detectors(0, 0, 1) 0
    detector(0, 0, 0) D2
    detector(1, 0, 0) D3
    shift_detectors(0, 0, 1) 0
    detector(0, 0, 0) D4
    detector(1, 0, 0) D5
    detector(0, 0, 1) D6
    detector(1, 0, 1) D7
''')
</code></pre>
<p>(Sorry for I did not combine some same-type gates into one line so it's a little uncomfortable to read.)
I'm not sure whether I made some mistakes in writing the circuits or there is any error mechanism I'm not aware of.</p>
",Use stim to simulate d=3 Bacon-Shor's code,<stim>,1,0,,,"Use stim to simulate d=3 Bacon-Shor's code <p>When I use stim to simulate d=3 Bacon-Shor's code, I can't find the problem with my circuits resulting in the weird DetectorErrorModel.
The initialization and stabilizer measurement circuits are as follow:
<img src=""https://github.com/inmzhang123/picgo/blob/picgo/202201291309.png?raw=true"" alt=""layout"" /></p>
<p><img src=""https://github.com/inmzhang123/picgo/blob/picgo/202201291301.png?raw=true"" alt=""circuits"" /></p>
<p>I focus on <span class=""math-container"">$|0\rangle _L$</span> memory simulation and choose not to use reset after measurement. So with three rounds of stabilizer measurements, the detectors are</p>
<pre><code>...
DETECTOR(0, 0, 0) rec[-4]
DETECTOR(1, 0, 0) rec[-3]
...
SHIFT_COORDS(0, 0, 1)
DETECTOR(0, 0, 0) rec[-4]
DETECTOR(1, 0, 0) rec[-3]
...
SHIFT_COORDS(0, 0, 1)
DETECTOR(0, 0, 0) rec[-4] rec[-8]
DETECTOR(1, 0, 0) rec[-3] rec[-7]
...
DETECTOR(0, 0, 1) rec[-9] rec[-6] rec[-8] rec[-5] rec[-7] rec[-4] rec[-13] rec[-17]
DETECTOR(1, 0, 1) rec[-6] rec[-3] rec[-5] rec[-2] rec[-4] rec[-1] rec[-12] rec[-16]
</code></pre>
<p>some error I can't understand appear in auto-generated DetectorErrorModel like <code>D0 D4 L0 ^ D1 D5 ^ L0</code>.</p>
<p>Here is my <code>stim.Circuit</code> file and generated error_model:</p>
<p><strong>circuit.txt</strong></p>
<pre><code>stim.Circuit('''
    R 0 1 2 3 4 5 6 7 8 9 10 11 12
    H 0
    DEPOLARIZE1(0.001) 0
    CX 0 1
    DEPOLARIZE2(0.02) 0 1
    CX 1 2
    DEPOLARIZE2(0.02) 1 2
    H 3
    DEPOLARIZE1(0.001) 3
    CX 3 4
    DEPOLARIZE2(0.02) 3 4
    CX 4 5
    DEPOLARIZE2(0.02) 4 5
    H 6
    DEPOLARIZE1(0.001) 6
    CX 6 7
    DEPOLARIZE2(0.02) 6 7
    CX 7 8
    DEPOLARIZE2(0.02) 7 8
    H 0
    DEPOLARIZE1(0.001) 0
    H 1
    DEPOLARIZE1(0.001) 1
    H 2
    DEPOLARIZE1(0.001) 2
    H 3
    DEPOLARIZE1(0.001) 3
    H 4
    DEPOLARIZE1(0.001) 4
    H 5
    DEPOLARIZE1(0.001) 5
    H 6
    DEPOLARIZE1(0.001) 6
    H 7
    DEPOLARIZE1(0.001) 7
    H 8
    DEPOLARIZE1(0.001) 8 0 1 2 3 4 5 6 7 8
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 11 0
    DEPOLARIZE2(0.02) 11 0
    CX 12 1
    DEPOLARIZE2(0.02) 12 1
    DEPOLARIZE1(0.002) 2 3 4 5 6 7 8
    CX 11 1
    DEPOLARIZE2(0.02) 11 1
    CX 12 2
    DEPOLARIZE2(0.02) 12 2
    DEPOLARIZE1(0.002) 0 3 4 5 6 7 8
    CX 11 3
    DEPOLARIZE2(0.02) 11 3
    CX 12 4
    DEPOLARIZE2(0.02) 12 4
    DEPOLARIZE1(0.002) 0 1 2 5 6 7 8
    CX 11 4
    DEPOLARIZE2(0.02) 11 4
    CX 12 5
    DEPOLARIZE2(0.02) 12 5
    DEPOLARIZE1(0.002) 0 1 2 3 6 7 8
    CX 11 6
    DEPOLARIZE2(0.02) 11 6
    CX 12 7
    DEPOLARIZE2(0.02) 12 7
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 8
    CX 11 7
    DEPOLARIZE2(0.02) 11 7
    CX 12 8
    DEPOLARIZE2(0.02) 12 8
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 6
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 0 9
    DEPOLARIZE2(0.02) 0 9
    CX 3 10
    DEPOLARIZE2(0.02) 3 10
    DEPOLARIZE1(0.002) 1 2 4 5 6 7 8 11 12
    CX 3 9
    DEPOLARIZE2(0.02) 3 9
    CX 6 10
    DEPOLARIZE2(0.02) 6 10
    DEPOLARIZE1(0.002) 0 1 2 4 5 7 8 11 12
    CX 1 9
    DEPOLARIZE2(0.02) 1 9
    CX 4 10
    DEPOLARIZE2(0.02) 4 10
    DEPOLARIZE1(0.002) 0 2 3 5 6 7 8 11 12
    CX 4 9
    DEPOLARIZE2(0.02) 4 9
    CX 7 10
    DEPOLARIZE2(0.02) 7 10
    DEPOLARIZE1(0.002) 0 1 2 3 5 6 8 11 12
    CX 2 9
    DEPOLARIZE2(0.02) 2 9
    CX 5 10
    DEPOLARIZE2(0.02) 5 10
    DEPOLARIZE1(0.002) 0 1 3 4 6 7 8 11 12
    CX 5 9
    DEPOLARIZE2(0.02) 5 9
    CX 8 10
    DEPOLARIZE2(0.02) 8 10
    DEPOLARIZE1(0.002) 0 1 2 3 4 6 7 11 12
    DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
    X_ERROR(0.05) 9
    M 9
    X_ERROR(0.05) 10
    M 10
    X_ERROR(0.05) 11
    M 11
    X_ERROR(0.05) 12
    M 12
    DETECTOR(0, 0, 0) rec[-4]
    DETECTOR(1, 0, 0) rec[-3]
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 11 0
    DEPOLARIZE2(0.02) 11 0
    CX 12 1
    DEPOLARIZE2(0.02) 12 1
    DEPOLARIZE1(0.002) 2 3 4 5 6 7 8 9 10
    CX 11 1
    DEPOLARIZE2(0.02) 11 1
    CX 12 2
    DEPOLARIZE2(0.02) 12 2
    DEPOLARIZE1(0.002) 0 3 4 5 6 7 8 9 10
    CX 11 3
    DEPOLARIZE2(0.02) 11 3
    CX 12 4
    DEPOLARIZE2(0.02) 12 4
    DEPOLARIZE1(0.002) 0 1 2 5 6 7 8 9 10
    CX 11 4
    DEPOLARIZE2(0.02) 11 4
    CX 12 5
    DEPOLARIZE2(0.02) 12 5
    DEPOLARIZE1(0.002) 0 1 2 3 6 7 8 9 10
    CX 11 6
    DEPOLARIZE2(0.02) 11 6
    CX 12 7
    DEPOLARIZE2(0.02) 12 7
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 8 9 10
    CX 11 7
    DEPOLARIZE2(0.02) 11 7
    CX 12 8
    DEPOLARIZE2(0.02) 12 8
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 6 9 10
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 0 9
    DEPOLARIZE2(0.02) 0 9
    CX 3 10
    DEPOLARIZE2(0.02) 3 10
    DEPOLARIZE1(0.002) 1 2 4 5 6 7 8 11 12
    CX 3 9
    DEPOLARIZE2(0.02) 3 9
    CX 6 10
    DEPOLARIZE2(0.02) 6 10
    DEPOLARIZE1(0.002) 0 1 2 4 5 7 8 11 12
    CX 1 9
    DEPOLARIZE2(0.02) 1 9
    CX 4 10
    DEPOLARIZE2(0.02) 4 10
    DEPOLARIZE1(0.002) 0 2 3 5 6 7 8 11 12
    CX 4 9
    DEPOLARIZE2(0.02) 4 9
    CX 7 10
    DEPOLARIZE2(0.02) 7 10
    DEPOLARIZE1(0.002) 0 1 2 3 5 6 8 11 12
    CX 2 9
    DEPOLARIZE2(0.02) 2 9
    CX 5 10
    DEPOLARIZE2(0.02) 5 10
    DEPOLARIZE1(0.002) 0 1 3 4 6 7 8 11 12
    CX 5 9
    DEPOLARIZE2(0.02) 5 9
    CX 8 10
    DEPOLARIZE2(0.02) 8 10
    DEPOLARIZE1(0.002) 0 1 2 3 4 6 7 11 12
    DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
    X_ERROR(0.05) 9
    M 9
    X_ERROR(0.05) 10
    M 10
    X_ERROR(0.05) 11
    M 11
    X_ERROR(0.05) 12
    M 12
    SHIFT_COORDS(0, 0, 1)
    DETECTOR(0, 0, 0) rec[-4]
    DETECTOR(1, 0, 0) rec[-3]
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 11 0
    DEPOLARIZE2(0.02) 11 0
    CX 12 1
    DEPOLARIZE2(0.02) 12 1
    DEPOLARIZE1(0.002) 2 3 4 5 6 7 8 9 10
    CX 11 1
    DEPOLARIZE2(0.02) 11 1
    CX 12 2
    DEPOLARIZE2(0.02) 12 2
    DEPOLARIZE1(0.002) 0 3 4 5 6 7 8 9 10
    CX 11 3
    DEPOLARIZE2(0.02) 11 3
    CX 12 4
    DEPOLARIZE2(0.02) 12 4
    DEPOLARIZE1(0.002) 0 1 2 5 6 7 8 9 10
    CX 11 4
    DEPOLARIZE2(0.02) 11 4
    CX 12 5
    DEPOLARIZE2(0.02) 12 5
    DEPOLARIZE1(0.002) 0 1 2 3 6 7 8 9 10
    CX 11 6
    DEPOLARIZE2(0.02) 11 6
    CX 12 7
    DEPOLARIZE2(0.02) 12 7
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 8 9 10
    CX 11 7
    DEPOLARIZE2(0.02) 11 7
    CX 12 8
    DEPOLARIZE2(0.02) 12 8
    DEPOLARIZE1(0.002) 0 1 2 3 4 5 6 9 10
    DEPOLARIZE1(0.001) 0 1 2 3 4 5 6 7 8 9 10
    H 11
    DEPOLARIZE1(0.001) 11
    H 12
    DEPOLARIZE1(0.001) 12
    CX 0 9
    DEPOLARIZE2(0.02) 0 9
    CX 3 10
    DEPOLARIZE2(0.02) 3 10
    DEPOLARIZE1(0.002) 1 2 4 5 6 7 8 11 12
    CX 3 9
    DEPOLARIZE2(0.02) 3 9
    CX 6 10
    DEPOLARIZE2(0.02) 6 10
    DEPOLARIZE1(0.002) 0 1 2 4 5 7 8 11 12
    CX 1 9
    DEPOLARIZE2(0.02) 1 9
    CX 4 10
    DEPOLARIZE2(0.02) 4 10
    DEPOLARIZE1(0.002) 0 2 3 5 6 7 8 11 12
    CX 4 9
    DEPOLARIZE2(0.02) 4 9
    CX 7 10
    DEPOLARIZE2(0.02) 7 10
    DEPOLARIZE1(0.002) 0 1 2 3 5 6 8 11 12
    CX 2 9
    DEPOLARIZE2(0.02) 2 9
    CX 5 10
    DEPOLARIZE2(0.02) 5 10
    DEPOLARIZE1(0.002) 0 1 3 4 6 7 8 11 12
    CX 5 9
    DEPOLARIZE2(0.02) 5 9
    CX 8 10
    DEPOLARIZE2(0.02) 8 10
    DEPOLARIZE1(0.002) 0 1 2 3 4 6 7 11 12
    DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
    X_ERROR(0.05) 9
    M 9
    X_ERROR(0.05) 10
    M 10
    X_ERROR(0.05) 11
    M 11
    X_ERROR(0.05) 12
    M 12
    SHIFT_COORDS(0, 0, 1)
    DETECTOR(0, 0, 0) rec[-4] rec[-8]
    DETECTOR(1, 0, 0) rec[-3] rec[-7]
    X_ERROR(0.05) 0
    M 0
    X_ERROR(0.05) 1
    M 1
    X_ERROR(0.05) 2
    M 2
    X_ERROR(0.05) 3
    M 3
    X_ERROR(0.05) 4
    M 4
    X_ERROR(0.05) 5
    M 5
    X_ERROR(0.05) 6
    M 6
    X_ERROR(0.05) 7
    M 7
    X_ERROR(0.05) 8
    M 8
    DEPOLARIZE1(0.01) 9 10 11 12
    DETECTOR(0, 0, 1) rec[-9] rec[-6] rec[-8] rec[-5] rec[-7] rec[-4] rec[-13] rec[-17]
    DETECTOR(1, 0, 1) rec[-6] rec[-3] rec[-5] rec[-2] rec[-4] rec[-1] rec[-12] rec[-16]
    OBSERVABLE_INCLUDE(0) rec[-9] rec[-8] rec[-7]
''')
</code></pre>
<p><strong>error_model.txt</strong></p>
<pre><code>stim.DetectorErrorModel('''
    error(0.07819) D0 D2
    error(0.102128) D0 D4 L0
    error(0.102128) D0 D4 L0 ^ D1 D5 ^ L0
    error(0.0313222) D0 D4 L0 ^ D3 D5 ^ L0
    error(0.07819) D1 D3
    error(0.105303) D1 D5
    error(0.0860003) D2
    error(0.108379) D2 D4 L0
    error(0.117794) D2 D4 L0 ^ D3 D5 ^ L0
    error(0.0159144) D2 D4 L0 ^ D5 ^ L0
    error(0.0860003) D3
    error(0.108379) D3 D5
    error(0.117794) D4 D5
    error(0.0159144) D4 D5 ^ D2
    error(0.07239) D4 D6
    error(0.0313222) D4 D7
    error(0.120844) D4 L0
    error(0.0159144) D4 L0 ^ D2
    error(0.120844) D5
    error(0.07239) D5 D7
    error(0.0159144) D5 ^ D3
    error(0.166418) D6 D7
    error(0.169079) D6 L0
    error(0.0159144) D6 L0 ^ D4 L0
    error(0.166418) D7
    error(0.0159144) D7 ^ D5
    detector(0, 0, 0) D0
    detector(1, 0, 0) D1
    shift_detectors(0, 0, 1) 0
    detector(0, 0, 0) D2
    detector(1, 0, 0) D3
    shift_detectors(0, 0, 1) 0
    detector(0, 0, 0) D4
    detector(1, 0, 0) D5
    detector(0, 0, 1) D6
    detector(1, 0, 1) D7
''')
</code></pre>
<p>(Sorry for I did not combine some same-type gates into one line so it's a little uncomfortable to read.)
I'm not sure whether I made some mistakes in writing the circuits or there is any error mechanism I'm not aware of.</p>
",qc,use stim simulate code p use stim simulate code ca find problem circuits resulting weird detectorerrormodel initialization stabilizer measurement circuits follow img https layout p img https circuits p focus span memory simulation choose use reset measurement three rounds stabilizer measurements detectors pre code detector 0 0 0 rec detector 1 0 0 rec 0 0 1 detector 0 0 0 rec detector 1 0 0 rec 0 0 1 detector 0 0 0 rec rec detector 1 0 0 rec rec detector 0 0 1 rec rec rec rec rec rec rec rec detector 1 0 1 rec rec rec rec rec rec rec rec p error ca understand appear detectorerrormodel like code d0 d4 l0 d1 d5 l0 p code file generated p strong pre code r 0 1 2 3 4 5 6 7 8 9 10 11 12 h 0 depolarize1 0 cx 0 1 depolarize2 0 1 cx 1 2 depolarize2 1 2 h 3 depolarize1 3 cx 3 4 depolarize2 3 4 cx 4 5 depolarize2 4 5 h 6 depolarize1 6 cx 6 7 depolarize2 6 7 cx 7 8 depolarize2 7 8 h 0 depolarize1 0 h 1 depolarize1 1 h 2 depolarize1 2 h 3 depolarize1 3 h 4 depolarize1 4 h 5 depolarize1 5 h 6 depolarize1 6 h 7 depolarize1 7 h 8 depolarize1 8 0 1 2 3 4 5 6 7 8 h 11 depolarize1 11 h 12 depolarize1 12 cx 11 0 depolarize2 11 0 cx 12 1 depolarize2 12 1 depolarize1 2 3 4 5 6 7 8 cx 11 1 depolarize2 11 1 cx 12 2 depolarize2 12 2 depolarize1 0 3 4 5 6 7 8 cx 11 3 depolarize2 11 3 cx 12 4 depolarize2 12 4 depolarize1 0 1 2 5 6 7 8 cx 11 4 depolarize2 11 4 cx 12 5 depolarize2 12 5 depolarize1 0 1 2 3 6 7 8 cx 11 6 depolarize2 11 6 cx 12 7 depolarize2 12 7 depolarize1 0 1 2 3 4 5 8 cx 11 7 depolarize2 11 7 cx 12 8 depolarize2 12 8 depolarize1 0 1 2 3 4 5 6 depolarize1 0 1 2 3 4 5 6 7 8 h 11 depolarize1 11 h 12 depolarize1 12 cx 0 9 depolarize2 0 9 cx 3 10 depolarize2 3 10 depolarize1 1 2 4 5 6 7 8 11 12 cx 3 9 depolarize2 3 9 cx 6 10 depolarize2 6 10 depolarize1 0 1 2 4 5 7 8 11 12 cx 1 9 depolarize2 1 9 cx 4 10 depolarize2 4 10 depolarize1 0 2 3 5 6 7 8 11 12 cx 4 9 depolarize2 4 9 cx 7 10 depolarize2 7 10 depolarize1 0 1 2 3 5 6 8 11 12 cx 2 9 depolarize2 2 9 cx 5 10 depolarize2 5 10 depolarize1 0 1 3 4 6 7 8 11 12 cx 5 9 depolarize2 5 9 cx 8 10 depolarize2 8 10 depolarize1 0 1 2 3 4 6 7 11 12 depolarize1 0 1 2 3 4 5 6 7 8 9 9 10 10 11 11 12 12 detector 0 0 0 rec detector 1 0 0 rec depolarize1 0 1 2 3 4 5 6 7 8 9 10 h 11 depolarize1 11 h 12 depolarize1 12 cx 11 0 depolarize2 11 0 cx 12 1 depolarize2 12 1 depolarize1 2 3 4 5 6 7 8 9 10 cx 11 1 depolarize2 11 1 cx 12 2 depolarize2 12 2 depolarize1 0 3 4 5 6 7 8 9 10 cx 11 3 depolarize2 11 3 cx 12 4 depolarize2 12 4 depolarize1 0 1 2 5 6 7 8 9 10 cx 11 4 depolarize2 11 4 cx 12 5 depolarize2 12 5 depolarize1 0 1 2 3 6 7 8 9 10 cx 11 6 depolarize2 11 6 cx 12 7 depolarize2 12 7 depolarize1 0 1 2 3 4 5 8 9 10 cx 11 7 depolarize2 11 7 cx 12 8 depolarize2 12 8 depolarize1 0 1 2 3 4 5 6 9 10 depolarize1 0 1 2 3 4 5 6 7 8 9 10 h 11 depolarize1 11 h 12 depolarize1 12 cx 0 9 depolarize2 0 9 cx 3 10 depolarize2 3 10 depolarize1 1 2 4 5 6 7 8 11 12 cx 3 9 depolarize2 3 9 cx 6 10 depolarize2 6 10 depolarize1 0 1 2 4 5 7 8 11 12 cx 1 9 depolarize2 1 9 cx 4 10 depolarize2 4 10 depolarize1 0 2 3 5 6 7 8 11 12 cx 4 9 depolarize2 4 9 cx 7 10 depolarize2 7 10 depolarize1 0 1 2 3 5 6 8 11 12 cx 2 9 depolarize2 2 9 cx 5 10 depolarize2 5 10 depolarize1 0 1 3 4 6 7 8 11 12 cx 5 9 depolarize2 5 9 cx 8 10 depolarize2 8 10 depolarize1 0 1 2 3 4 6 7 11 12 depolarize1 0 1 2 3 4 5 6 7 8 9 9 10 10 11 11 12 12 0 0 1 detector 0 0 0 rec detector 1 0 0 rec depolarize1 0 1 2 3 4 5 6 7 8 9 10 h 11 depolarize1 11 h 12 depolarize1 12 cx 11 0 depolarize2 11 0 cx 12 1 depolarize2 12 1 depolarize1 2 3 4 5 6 7 8 9 10 cx 11 1 depolarize2 11 1 cx 12 2 depolarize2 12 2 depolarize1 0 3 4 5 6 7 8 9 10 cx 11 3 depolarize2 11 3 cx 12 4 depolarize2 12 4 depolarize1 0 1 2 5 6 7 8 9 10 cx 11 4 depolarize2 11 4 cx 12 5 depolarize2 12 5 depolarize1 0 1 2 3 6 7 8 9 10 cx 11 6 depolarize2 11 6 cx 12 7 depolarize2 12 7 depolarize1 0 1 2 3 4 5 8 9 10 cx 11 7 depolarize2 11 7 cx 12 8 depolarize2 12 8 depolarize1 0 1 2 3 4 5 6 9 10 depolarize1 0 1 2 3 4 5 6 7 8 9 10 h 11 depolarize1 11 h 12 depolarize1 12 cx 0 9 depolarize2 0 9 cx 3 10 depolarize2 3 10 depolarize1 1 2 4 5 6 7 8 11 12 cx 3 9 depolarize2 3 9 cx 6 10 depolarize2 6 10 depolarize1 0 1 2 4 5 7 8 11 12 cx 1 9 depolarize2 1 9 cx 4 10 depolarize2 4 10 depolarize1 0 2 3 5 6 7 8 11 12 cx 4 9 depolarize2 4 9 cx 7 10 depolarize2 7 10 depolarize1 0 1 2 3 5 6 8 11 12 cx 2 9 depolarize2 2 9 cx 5 10 depolarize2 5 10 depolarize1 0 1 3 4 6 7 8 11 12 cx 5 9 depolarize2 5 9 cx 8 10 depolarize2 8 10 depolarize1 0 1 2 3 4 6 7 11 12 depolarize1 0 1 2 3 4 5 6 7 8 9 9 10 10 11 11 12 12 0 0 1 detector 0 0 0 rec rec detector 1 0 0 rec rec 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 depolarize1 9 10 11 12 detector 0 0 1 rec rec rec rec rec rec rec rec detector 1 0 1 rec rec rec rec rec rec rec rec 0 rec rec rec p strong pre code error d0 d2 error d0 d4 l0 error d0 d4 l0 d1 d5 l0 error d0 d4 l0 d3 d5 l0 error d1 d3 error d1 d5 error d2 error d2 d4 l0 error d2 d4 l0 d3 d5 l0 error d2 d4 l0 d5 l0 error d3 error d3 d5 error d4 d5 error d4 d5 d2 error d4 d6 error d4 d7 error d4 l0 error d4 l0 d2 error d5 error d5 d7 error d5 d3 error d6 d7 error d6 l0 error d6 l0 d4 l0 error d7 error d7 d5 detector 0 0 0 d0 detector 1 0 0 d1 0 0 1 0 detector 0 0 0 d2 detector 1 0 0 d3 0 0 1 0 detector 0 0 0 d4 detector 1 0 0 d5 detector 0 0 1 d6 detector 1 0 1 d7 p sorry combine gates one line little uncomfortable read sure whether made mistakes writing circuits error mechanism aware,"[(2, 0.079300016), (6, 0.87557185), (14, 0.019190766), (17, 0.011161204)]"
23932,,2022-02-03 15:10:16,1,165,"<p>Solving SAT using Grover's algorithm , if the f(x) = x1 and x2 and (not x3). I have a few questions:</p>
<ol>
<li><p>is this considered a 3 SAT problem as there are three literals here and one clause?</p>
</li>
<li><p>I have seen in other posts where if f(x) = x1 or  x2 or (not x3). In this case, we can use Cx gate such that f(x) =  x1 xor x2 xor (not x3).</p>
</li>
</ol>
<p>How to implement with boolean and? I can see that CZ gate can be used to get the result of 1</p>
",SOlving SAT problem having Boolean And f(x) = x1 and x2 and (not x3) using Grover's algorithm,<grovers-algorithm>,1,0,,,"SOlving SAT problem having Boolean And f(x) = x1 and x2 and (not x3) using Grover's algorithm <p>Solving SAT using Grover's algorithm , if the f(x) = x1 and x2 and (not x3). I have a few questions:</p>
<ol>
<li><p>is this considered a 3 SAT problem as there are three literals here and one clause?</p>
</li>
<li><p>I have seen in other posts where if f(x) = x1 or  x2 or (not x3). In this case, we can use Cx gate such that f(x) =  x1 xor x2 xor (not x3).</p>
</li>
</ol>
<p>How to implement with boolean and? I can see that CZ gate can be used to get the result of 1</p>
",qc,solving sat problem boolean f x x1 x2 x3 using grover algorithm p solving sat using grover algorithm f x x1 x2 x3 questions ol li p considered 3 sat problem three literals one clause li p seen posts f x x1 x2 x3 case use cx gate f x x1 xor x2 xor x3 p implement boolean see cz gate used get result 1,"[(1, 0.081494026), (6, 0.07029841), (7, 0.23571476), (9, 0.12314176), (10, 0.23428546), (13, 0.098429196), (17, 0.15461071)]"
23943,,2022-02-04 05:53:03,2,241,"<p>I'm reading the <a href=""https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html"" rel=""nofollow noreferrer"">Qiskit tutorial</a> on quantum phase estimation. In this tutorial, the controlled unitaries on the diagram are denoted as <span class=""math-container"">$U^{2^{t-1}}, ..., U^{2^{0}}$</span>:</p>
<p><a href=""https://i.sstatic.net/7nVqv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7nVqv.png"" alt=""enter image description here"" /></a></p>
<p>In the actual quantum circuit, however, those gates are implemented using controlled phase gates. When I tried to apply QPE to a single-qubit Hamiltonian I'm interested in, it turned out that I need to run 2 histograms separately in order to determine both energies, as in each of the histograms, there will be another eigenvalue associated with the phase gate, which is 1. For example:</p>
<p><a href=""https://i.sstatic.net/KDfgK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KDfgK.png"" alt=""enter image description here"" /></a></p>
<p>In this case, the string <code>'00101'</code> is one of my targets, but <code>'00000'</code> comes from the phase gate.</p>
<p>Now I wonder if it's okay to replace those controlled phase gates with controlled <span class=""math-container"">$U_3$</span> gates to see both energies in one histogram. If I do that, how can I make sure the phase works as we expected? Should I tune the length of time evolution as depicted on the diagram? Thanks!</p>
",Implementing controlled unitary gate in QPE,<qiskit><hamiltonian-simulation><quantum-phase-estimation>,0,1,,,"Implementing controlled unitary gate in QPE <p>I'm reading the <a href=""https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html"" rel=""nofollow noreferrer"">Qiskit tutorial</a> on quantum phase estimation. In this tutorial, the controlled unitaries on the diagram are denoted as <span class=""math-container"">$U^{2^{t-1}}, ..., U^{2^{0}}$</span>:</p>
<p><a href=""https://i.sstatic.net/7nVqv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7nVqv.png"" alt=""enter image description here"" /></a></p>
<p>In the actual quantum circuit, however, those gates are implemented using controlled phase gates. When I tried to apply QPE to a single-qubit Hamiltonian I'm interested in, it turned out that I need to run 2 histograms separately in order to determine both energies, as in each of the histograms, there will be another eigenvalue associated with the phase gate, which is 1. For example:</p>
<p><a href=""https://i.sstatic.net/KDfgK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KDfgK.png"" alt=""enter image description here"" /></a></p>
<p>In this case, the string <code>'00101'</code> is one of my targets, but <code>'00000'</code> comes from the phase gate.</p>
<p>Now I wonder if it's okay to replace those controlled phase gates with controlled <span class=""math-container"">$U_3$</span> gates to see both energies in one histogram. If I do that, how can I make sure the phase works as we expected? Should I tune the length of time evolution as depicted on the diagram? Thanks!</p>
",qc,implementing controlled unitary gate qpe p reading https nofollow noreferrer qiskit tutorial quantum phase estimation tutorial controlled unitaries diagram denoted span 0 p https nofollow noreferrer img https enter image description p actual quantum circuit however gates implemented using controlled phase gates tried apply qpe hamiltonian interested turned need run 2 histograms separately order determine energies histograms another eigenvalue associated phase gate example p https nofollow noreferrer img https enter image description p case string code one targets code comes phase p wonder okay replace controlled phase gates controlled span gates see energies one histogram make sure phase works expected tune length time evolution depicted diagram thanks,"[(1, 0.049066797), (2, 0.015319734), (4, 0.3484725), (6, 0.010222467), (7, 0.092633955), (9, 0.29468188), (14, 0.16509992), (17, 0.023360657)]"
23961,23996.0,2022-02-05 06:14:52,4,358,"<p>I am working with stim's excellent code generator together with pymatching, using stim's generated error model and the glue code in the tutorial <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">here</a>. I am trying to understand better what the output of the decoder means. Specifically, is it correct to say that the output of the decoder xor the logical observable, sampled using <code>OBSERVABLE_INCLUDE</code>, gives the output of a &quot;stanard&quot; decoder, created using a matching matrix and specifying the number of repetitions as arguments to pymatching's <code>Matching</code> constructor?</p>
<p>To clarify what I mean, I created a simple example of a distance 3 repetition code, which I decode using both the stim error model based decoder and the &quot;conventionally&quot; defined decoder. I am using an example generated by calling</p>
<pre><code>repc = stim.Circuit.generated(
    &quot;repetition_code:memory&quot;,
    rounds=1,
    distance=3)
</code></pre>
<p>and adapting it to include an error on qubits 0 and 2 with probability 0.5:</p>
<pre><code>repc = stim.Circuit('''
    R 0 1 2 3 4
    TICK
    CX 0 1 2 3
    TICK
    CX 2 1 4 3
    TICK
    MR 1 3
    DETECTOR(1, 0) rec[-2]
    DETECTOR(3, 0) rec[-1]

    X_ERROR(0.5) 0 2

    M 0 2 4
    DETECTOR(1, 1) rec[-2] rec[-3] rec[-5]
    DETECTOR(3, 1) rec[-1] rec[-2] rec[-4]
    OBSERVABLE_INCLUDE(0) rec[-1]
''')

m = detector_error_model_to_pymatching_graph(repc.detector_error_model(decompose_errors=True))
shots = repc.compile_detector_sampler().sample(1, append_observables=True)[0]
observable = shots[-1]
print('observable = ', observable)

# decode using glue code and error model
expanded_det = np.resize(shots[:-1], repc.num_detectors + 1)
expanded_det[-1] = 0
print('error model decode', m.decode(expanded_det))

# decode using matching matrix
detector_events = expanded_det[:-1].reshape(-1, 2)
print(detector_events)
m_matrix = pymatching.Matching([[1, 1, 0], [0, 1, 1]], repetitions=2)
print('matrix decode', m_matrix.decode(detector_events.T))
</code></pre>
<p>First of all, would it be possible to clarify why the logical observable was chosen to be qubit 4 (rather than, say 0^2^4)?</p>
<p>Secondly, in a shot where there are errors both on 0 and on 2, the output is:</p>
<pre><code>observable =  0
error model decode [0]
[[0 0]
 [0 1]]
matrix decode [0 0 1]
</code></pre>
<p>In this case my naive expectation would be that the error model decoder will want to flip the logical bit (which would result in a logical error), which is what the conventional decoder does. Does that make sense? If not, I'd be really happy to understand better how to interpret the result of the decoder.</p>
",compatibility of stim's error model with conventional decoding schemes,<error-correction><simulation><stim>,1,0,,,"compatibility of stim's error model with conventional decoding schemes <p>I am working with stim's excellent code generator together with pymatching, using stim's generated error model and the glue code in the tutorial <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">here</a>. I am trying to understand better what the output of the decoder means. Specifically, is it correct to say that the output of the decoder xor the logical observable, sampled using <code>OBSERVABLE_INCLUDE</code>, gives the output of a &quot;stanard&quot; decoder, created using a matching matrix and specifying the number of repetitions as arguments to pymatching's <code>Matching</code> constructor?</p>
<p>To clarify what I mean, I created a simple example of a distance 3 repetition code, which I decode using both the stim error model based decoder and the &quot;conventionally&quot; defined decoder. I am using an example generated by calling</p>
<pre><code>repc = stim.Circuit.generated(
    &quot;repetition_code:memory&quot;,
    rounds=1,
    distance=3)
</code></pre>
<p>and adapting it to include an error on qubits 0 and 2 with probability 0.5:</p>
<pre><code>repc = stim.Circuit('''
    R 0 1 2 3 4
    TICK
    CX 0 1 2 3
    TICK
    CX 2 1 4 3
    TICK
    MR 1 3
    DETECTOR(1, 0) rec[-2]
    DETECTOR(3, 0) rec[-1]

    X_ERROR(0.5) 0 2

    M 0 2 4
    DETECTOR(1, 1) rec[-2] rec[-3] rec[-5]
    DETECTOR(3, 1) rec[-1] rec[-2] rec[-4]
    OBSERVABLE_INCLUDE(0) rec[-1]
''')

m = detector_error_model_to_pymatching_graph(repc.detector_error_model(decompose_errors=True))
shots = repc.compile_detector_sampler().sample(1, append_observables=True)[0]
observable = shots[-1]
print('observable = ', observable)

# decode using glue code and error model
expanded_det = np.resize(shots[:-1], repc.num_detectors + 1)
expanded_det[-1] = 0
print('error model decode', m.decode(expanded_det))

# decode using matching matrix
detector_events = expanded_det[:-1].reshape(-1, 2)
print(detector_events)
m_matrix = pymatching.Matching([[1, 1, 0], [0, 1, 1]], repetitions=2)
print('matrix decode', m_matrix.decode(detector_events.T))
</code></pre>
<p>First of all, would it be possible to clarify why the logical observable was chosen to be qubit 4 (rather than, say 0^2^4)?</p>
<p>Secondly, in a shot where there are errors both on 0 and on 2, the output is:</p>
<pre><code>observable =  0
error model decode [0]
[[0 0]
 [0 1]]
matrix decode [0 0 1]
</code></pre>
<p>In this case my naive expectation would be that the error model decoder will want to flip the logical bit (which would result in a logical error), which is what the conventional decoder does. Does that make sense? If not, I'd be really happy to understand better how to interpret the result of the decoder.</p>
",qc,compatibility stim error model conventional decoding schemes p working stim excellent code generator together pymatching using stim generated error model glue code tutorial https nofollow noreferrer trying understand better output decoder means specifically correct say output decoder xor logical observable sampled using code gives output quot stanard quot decoder created using matching matrix specifying number repetitions arguments pymatching code matching constructor p clarify mean created simple example distance 3 repetition code decode using stim error model based decoder quot conventionally quot defined decoder using example generated calling pre code repc quot memory quot p adapting include error qubits 0 2 probability pre code repc r 0 1 2 3 4 tick cx 0 1 2 3 tick cx 2 1 4 3 tick mr 1 3 detector 1 0 rec detector 3 0 rec 0 2 0 2 4 detector 1 1 rec rec rec detector 3 1 rec rec rec 0 rec shots 1 0 observable shots print observable decode using glue code error model shots 1 0 print model decode decode using matching matrix 2 print 1 1 0 0 1 1 print decode p first would possible clarify logical observable chosen qubit 4 rather say p secondly shot errors 0 2 output pre code observable 0 error model decode 0 0 0 0 1 matrix decode 0 0 1 p case naive expectation would error model decoder want flip logical bit would result logical error conventional decoder make sense really happy understand better interpret result,"[(0, 0.043875128), (2, 0.2028322), (4, 0.010026829), (5, 0.27259427), (6, 0.13265781), (7, 0.03586454), (14, 0.22963698), (17, 0.033874236), (19, 0.031714458)]"
23992,23993.0,2022-02-08 19:11:48,2,324,"<p>How should I use the 'MPP' gate with append_operation in stim? For example it's clear from the documentation that circuit.append_operation('MX', [1,2]) will append two X-base measurements on qubits 1 and 2. However, I couldn't figure out how to do an X1*X2 measurement with 'MPP'. Could you please give me an example?</p>
",How do I add an MPP operation to a stim circuit using append_operation?,<stim>,1,1,,,"How do I add an MPP operation to a stim circuit using append_operation? <p>How should I use the 'MPP' gate with append_operation in stim? For example it's clear from the documentation that circuit.append_operation('MX', [1,2]) will append two X-base measurements on qubits 1 and 2. However, I couldn't figure out how to do an X1*X2 measurement with 'MPP'. Could you please give me an example?</p>
",qc,add mpp operation stim circuit using p use gate stim example clear documentation append two measurements qubits 1 however could figure x1 x2 measurement could please give example,"[(2, 0.033286966), (12, 0.036033597), (14, 0.8462481), (17, 0.07875687)]"
24002,,2022-02-09 03:36:02,3,131,"<p>I'm calibrating a custom gate using Qiskit Pulse. The gate has no parameters. Does the result of the circuit accurately reflect the effect of the pulse of the qubit? That is, if I calibrate a custom gate with a Gaussian pulse (lets say amp=0.5 and sigma=16), is the output from the quantum computer/simulator purely the effect of the pulse? Or does the gate have some sort of warping effect?</p>
<p>Extra information: I need the statevector of the result of the pulse on a quantum circuit, so currently I'm using FakeArmonk from qiskit.test.mock and calling the get_statevector() function from the Job result.</p>
",Does the effect of a pulse gate using a custom gate reflect the effect of the pulse on the qubit?,<qiskit>,1,4,,,"Does the effect of a pulse gate using a custom gate reflect the effect of the pulse on the qubit? <p>I'm calibrating a custom gate using Qiskit Pulse. The gate has no parameters. Does the result of the circuit accurately reflect the effect of the pulse of the qubit? That is, if I calibrate a custom gate with a Gaussian pulse (lets say amp=0.5 and sigma=16), is the output from the quantum computer/simulator purely the effect of the pulse? Or does the gate have some sort of warping effect?</p>
<p>Extra information: I need the statevector of the result of the pulse on a quantum circuit, so currently I'm using FakeArmonk from qiskit.test.mock and calling the get_statevector() function from the Job result.</p>
",qc,effect pulse gate using custom gate reflect effect pulse qubit p calibrating custom gate using qiskit pulse gate parameters result circuit accurately reflect effect pulse qubit calibrate custom gate gaussian pulse lets say output quantum purely effect pulse gate sort warping effect p extra information need statevector result pulse quantum circuit currently using fakearmonk calling function job,"[(0, 0.2750593), (8, 0.050803836), (9, 0.2166251), (13, 0.023531139), (14, 0.39371052), (17, 0.037732434)]"
24048,,2022-02-11 16:33:05,2,431,"<p>In stim's error corretion example <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">here</a>, and in pymatching's toric code example <a href=""https://pymatching.readthedocs.io/en/stable/toric-code-example.html"" rel=""nofollow noreferrer"">here</a>, the threshold calculation involves taking a number of rounds that scales as the code distance. Why is that the right way to do it?</p>
<p>To test what's going on if I try to do it some other way, calculated the threshold with a fixed number of rounds, yet much larger than the distance, and I get something that behaves reasonably until some &quot;pseudo threshold&quot; value, and then the errors seem to more or less track each other. How can we explain this behavior?</p>
<p>Here's an example of a surface code with <code>rounds = 3 * distance</code> as in the stim example:</p>
<img src=""https://i.sstatic.net/IUICB.png"" width=""500"">
<p>and here's one with <code>rounds=20</code>:</p>
<img src=""https://i.sstatic.net/9qcZz.png"" width=""500"">
<p>The x axis are physical (2 qubit gate) error rates, and the y axis is logical error rate</p>
<p>BTW, I have a vague feeling that this is somehow related to <a href=""https://quantumcomputing.stackexchange.com/questions/23971/why-do-we-need-to-keep-of-history-of-d-cycle-for-surface-code-in-order-to-resi"">this</a> question.</p>
","when calculating code thresholds, why do we need to take a number of rounds that scales with the code distance?",<error-correction><surface-code><stim>,1,0,,,"when calculating code thresholds, why do we need to take a number of rounds that scales with the code distance? <p>In stim's error corretion example <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">here</a>, and in pymatching's toric code example <a href=""https://pymatching.readthedocs.io/en/stable/toric-code-example.html"" rel=""nofollow noreferrer"">here</a>, the threshold calculation involves taking a number of rounds that scales as the code distance. Why is that the right way to do it?</p>
<p>To test what's going on if I try to do it some other way, calculated the threshold with a fixed number of rounds, yet much larger than the distance, and I get something that behaves reasonably until some &quot;pseudo threshold&quot; value, and then the errors seem to more or less track each other. How can we explain this behavior?</p>
<p>Here's an example of a surface code with <code>rounds = 3 * distance</code> as in the stim example:</p>
<img src=""https://i.sstatic.net/IUICB.png"" width=""500"">
<p>and here's one with <code>rounds=20</code>:</p>
<img src=""https://i.sstatic.net/9qcZz.png"" width=""500"">
<p>The x axis are physical (2 qubit gate) error rates, and the y axis is logical error rate</p>
<p>BTW, I have a vague feeling that this is somehow related to <a href=""https://quantumcomputing.stackexchange.com/questions/23971/why-do-we-need-to-keep-of-history-of-d-cycle-for-surface-code-in-order-to-resi"">this</a> question.</p>
",qc,calculating code thresholds need take number rounds scales code distance p stim error corretion example https nofollow noreferrer pymatching toric code example https nofollow noreferrer threshold calculation involves taking number rounds scales code distance right way p test going try way calculated threshold fixed number rounds yet much larger distance get something behaves reasonably quot pseudo threshold quot value errors seem less track explain behavior p example surface code code rounds 3 distance stim example img https 500 p one code img https 500 p x axis physical 2 qubit gate error rates axis logical error rate p btw vague feeling somehow related https,"[(4, 0.19861037), (5, 0.32625166), (8, 0.0892052), (13, 0.04623281), (14, 0.29260018), (17, 0.025344694), (19, 0.020482022)]"
24094,24096.0,2022-02-15 02:42:31,13,2680,"<p>The no-cloning theorem of quantum mechanics tells us there can be no general quantum circuit that can copy arbitrary qubit states, i.e. a quantum gate or circuit cannot send <span class=""math-container"">$|0\rangle |\psi\rangle\mapsto|\psi\rangle |\psi\rangle$</span> for arbitrary <span class=""math-container"">$|\psi\rangle$</span>.</p>
<p>However, in classical circuits we can easily perform the copy <span class=""math-container"">$(0, b)\mapsto(b, b)$</span> by the function <span class=""math-container"">$f:(a, b)\mapsto (a\oplus b, b)$</span>.</p>
<p>Now obviously, the no-cloning theorem doesn't apply because these are bits and not qubits, but the real question concerns the following dilemma. The above classical circuit can be physically realized, and the physical realization has to be ultimately reducible to quantum mechanics. If quantum mechanics truly explains our world, it must be able to give an account of the behavior of bits (not just qubits), and therefore it must be able to give an account of how bits can be cloned.</p>
<p>So I suppose my real question is, what is the quantum mechanical account of how classical bits can be copied?</p>
<p>There is a <a href=""https://quantumcomputing.stackexchange.com/questions/8388"">related question asking how is it possible that classical computations are non-unitary</a>. According to the answer, unitarity only applies to <em>isolated</em> quantum systems and any <em>open</em> system (such as a system in which measurements are done) does not necessarily obey unitarity (this is similar to how open systems do not necessarily obey conservation of energy).</p>
<p>This gives me a <em>partial answer</em>, but it doesn't give me a deep enough understanding. For example, I can understand how measurements lead to the apparent destruction of information, and so I can see how a classical gate can collapse bits (e.g. see XOR-gate <span class=""math-container"">$(a, b)\mapsto (a\oplus b)$</span> or AND-gate <span class=""math-container"">$(a, b)\mapsto (a\wedge b)$</span>). But I don't see how this could give an account of <em>cloning bits</em>.</p>
<p>How can this dilemma be resolved in the context of cloning bits?</p>
",How can classical bits be copied if qubits cannot be copied?,<information-theory><unitarity><no-cloning-theorem><nonclassicality>,1,2,,,"How can classical bits be copied if qubits cannot be copied? <p>The no-cloning theorem of quantum mechanics tells us there can be no general quantum circuit that can copy arbitrary qubit states, i.e. a quantum gate or circuit cannot send <span class=""math-container"">$|0\rangle |\psi\rangle\mapsto|\psi\rangle |\psi\rangle$</span> for arbitrary <span class=""math-container"">$|\psi\rangle$</span>.</p>
<p>However, in classical circuits we can easily perform the copy <span class=""math-container"">$(0, b)\mapsto(b, b)$</span> by the function <span class=""math-container"">$f:(a, b)\mapsto (a\oplus b, b)$</span>.</p>
<p>Now obviously, the no-cloning theorem doesn't apply because these are bits and not qubits, but the real question concerns the following dilemma. The above classical circuit can be physically realized, and the physical realization has to be ultimately reducible to quantum mechanics. If quantum mechanics truly explains our world, it must be able to give an account of the behavior of bits (not just qubits), and therefore it must be able to give an account of how bits can be cloned.</p>
<p>So I suppose my real question is, what is the quantum mechanical account of how classical bits can be copied?</p>
<p>There is a <a href=""https://quantumcomputing.stackexchange.com/questions/8388"">related question asking how is it possible that classical computations are non-unitary</a>. According to the answer, unitarity only applies to <em>isolated</em> quantum systems and any <em>open</em> system (such as a system in which measurements are done) does not necessarily obey unitarity (this is similar to how open systems do not necessarily obey conservation of energy).</p>
<p>This gives me a <em>partial answer</em>, but it doesn't give me a deep enough understanding. For example, I can understand how measurements lead to the apparent destruction of information, and so I can see how a classical gate can collapse bits (e.g. see XOR-gate <span class=""math-container"">$(a, b)\mapsto (a\oplus b)$</span> or AND-gate <span class=""math-container"">$(a, b)\mapsto (a\wedge b)$</span>). But I don't see how this could give an account of <em>cloning bits</em>.</p>
<p>How can this dilemma be resolved in the context of cloning bits?</p>
",qc,classical bits copied qubits copied p theorem quantum mechanics tells us general quantum circuit copy arbitrary qubit states quantum gate circuit send span arbitrary span p however classical circuits easily perform copy span 0 b b b function span f b b b p obviously theorem apply bits qubits real question concerns following dilemma classical circuit physically realized physical realization ultimately reducible quantum mechanics quantum mechanics truly explains world must able give account behavior bits qubits therefore must able give account bits p suppose real question quantum mechanical account classical bits copied p https related question asking possible classical computations according answer unitarity applies em isolated quantum systems em open system system measurements done necessarily obey unitarity similar open systems necessarily obey conservation energy p gives em partial answer give deep enough understanding example understand measurements lead apparent destruction information see classical gate collapse bits see span b b span b b see could give account em cloning bits p dilemma resolved context cloning bits,"[(1, 0.18856974), (3, 0.2779979), (8, 0.11099309), (9, 0.12671189), (14, 0.07186272), (17, 0.026984945), (18, 0.18047531)]"
24099,,2022-02-15 10:05:47,1,63,"<h2>Background</h2>
<p>Let's say I have a gas of <span class=""math-container"">$N$</span> particles where I cannot distinguish between the particles at a temperature <span class=""math-container"">$T$</span>.</p>
<p>Its density matrix is given by <span class=""math-container"">$\rho$</span>. Note, if my friend happens to measure the energy of all <span class=""math-container"">$N$</span> particles for large <span class=""math-container"">$N$</span> the system can still be described by the density matrix <span class=""math-container"">$\rho$</span>.</p>
<p>To see this we can write the density matrix in the energy eigenbasis:</p>
<p><span class=""math-container"">$$ \rho =\sum_{i=0} p_i |E_i \rangle \langle  E_i |$$</span></p>
<p>where <span class=""math-container"">$p_i$</span> is likelihood of eigenstate of the <span class=""math-container"">$i$</span>'th energy eigenstate and <span class=""math-container"">$|E_i \rangle$</span> is the energy eigenket. The measurement of energy effectively takes <span class=""math-container"">$|E_j \rangle \to |E_j \rangle $</span> due to orthogonality. Think of <span class=""math-container"">$p_i$</span> as the number of particles with energy <span class=""math-container"">$E_i$</span> out of <span class=""math-container"">$N$</span> particles.</p>
<p>My friend however can use the wavefunction <span class=""math-container"">$|\psi \rangle$</span> to describe the system.</p>
<p><strong>Claim</strong>: Both me and my friend will agree on the quantity <span class=""math-container"">$\rho |\psi \rangle$</span> and its time evolution:</p>
<p><span class=""math-container"">$$ i \hbar \frac{\partial \rho | \psi \rangle}{\partial t} = H \rho |\psi \rangle$$</span></p>
<p>(Use the product rule to prove the above).</p>
<h2>Question</h2>
<p>In the thought experiment of <a href=""https://en.wikipedia.org/wiki/Wigner%27s_friend"" rel=""nofollow noreferrer"">Wigner's friend</a> is <span class=""math-container"">$\rho |\psi \rangle$</span> an invariant where <span class=""math-container"">$|\psi\rangle$</span> is what Wigner's friend measures and <span class=""math-container"">$\rho$</span> is the pure state Wigner uses to describe the system?</p>
",Is $\rho | \psi \rangle$ invariant in the Wigners friend thought experiment?,<measurement><density-matrix>,0,0,,,"Is $\rho | \psi \rangle$ invariant in the Wigners friend thought experiment? <h2>Background</h2>
<p>Let's say I have a gas of <span class=""math-container"">$N$</span> particles where I cannot distinguish between the particles at a temperature <span class=""math-container"">$T$</span>.</p>
<p>Its density matrix is given by <span class=""math-container"">$\rho$</span>. Note, if my friend happens to measure the energy of all <span class=""math-container"">$N$</span> particles for large <span class=""math-container"">$N$</span> the system can still be described by the density matrix <span class=""math-container"">$\rho$</span>.</p>
<p>To see this we can write the density matrix in the energy eigenbasis:</p>
<p><span class=""math-container"">$$ \rho =\sum_{i=0} p_i |E_i \rangle \langle  E_i |$$</span></p>
<p>where <span class=""math-container"">$p_i$</span> is likelihood of eigenstate of the <span class=""math-container"">$i$</span>'th energy eigenstate and <span class=""math-container"">$|E_i \rangle$</span> is the energy eigenket. The measurement of energy effectively takes <span class=""math-container"">$|E_j \rangle \to |E_j \rangle $</span> due to orthogonality. Think of <span class=""math-container"">$p_i$</span> as the number of particles with energy <span class=""math-container"">$E_i$</span> out of <span class=""math-container"">$N$</span> particles.</p>
<p>My friend however can use the wavefunction <span class=""math-container"">$|\psi \rangle$</span> to describe the system.</p>
<p><strong>Claim</strong>: Both me and my friend will agree on the quantity <span class=""math-container"">$\rho |\psi \rangle$</span> and its time evolution:</p>
<p><span class=""math-container"">$$ i \hbar \frac{\partial \rho | \psi \rangle}{\partial t} = H \rho |\psi \rangle$$</span></p>
<p>(Use the product rule to prove the above).</p>
<h2>Question</h2>
<p>In the thought experiment of <a href=""https://en.wikipedia.org/wiki/Wigner%27s_friend"" rel=""nofollow noreferrer"">Wigner's friend</a> is <span class=""math-container"">$\rho |\psi \rangle$</span> an invariant where <span class=""math-container"">$|\psi\rangle$</span> is what Wigner's friend measures and <span class=""math-container"">$\rho$</span> is the pure state Wigner uses to describe the system?</p>
",qc,invariant wigners friend thought experiment h2 background p let say gas span n particles distinguish particles temperature span p density matrix given span note friend happens measure energy span n particles large span n system still described density matrix span p see write density matrix energy eigenbasis p span p span likelihood eigenstate span energy eigenstate span energy eigenket measurement energy effectively takes span due orthogonality think span number particles energy span span n p friend however use wavefunction span describe p strong claim friend agree quantity span time evolution p span h p use product rule prove h2 question p thought experiment https nofollow noreferrer wigner friend span invariant span wigner friend measures span pure state wigner uses describe system,"[(1, 0.03949883), (3, 0.5737067), (9, 0.22878064), (11, 0.044964787), (17, 0.05179345), (18, 0.060070798)]"
24124,,2022-02-16 14:28:07,3,252,"<p>I want to make a circuit that measures the expected value of a projector. In this case I want to measure the expected value of the singlet projector operator, that is a non-unitary hermitian matrix. How can I do this in Qiskit?</p>
<p>The singlet state is defines as:</p>
<p><span class=""math-container"">$\frac{|01&gt;-|10&gt;}{\sqrt{2}}$</span></p>
<p>And the matrix of the projector is:
<span class=""math-container"">\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1/2 &amp; -1/2 &amp; 0\\
0 &amp; -1/2 &amp; 1/2 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}</span></p>
",Projection and expected value in Qiskit?,<qiskit><programming><matrix-representation>,2,0,,,"Projection and expected value in Qiskit? <p>I want to make a circuit that measures the expected value of a projector. In this case I want to measure the expected value of the singlet projector operator, that is a non-unitary hermitian matrix. How can I do this in Qiskit?</p>
<p>The singlet state is defines as:</p>
<p><span class=""math-container"">$\frac{|01&gt;-|10&gt;}{\sqrt{2}}$</span></p>
<p>And the matrix of the projector is:
<span class=""math-container"">\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1/2 &amp; -1/2 &amp; 0\\
0 &amp; -1/2 &amp; 1/2 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}</span></p>
",qc,projection expected value qiskit p want make circuit measures expected value projector case want measure expected value singlet projector operator hermitian matrix qiskit p singlet state defines p span gt gt 2 p matrix projector span pmatrix 0 amp 0 amp 0 amp 0 amp amp amp 0 amp amp amp 0 amp 0 amp 0 amp 0 pmatrix,"[(0, 0.08045313), (2, 0.1539571), (3, 0.054315455), (11, 0.038245253), (14, 0.076375745), (15, 0.3520802), (17, 0.08733537), (18, 0.15521011)]"
24192,,2022-02-21 00:28:13,0,287,"<p>Assume I have tree qubits (A,B, and C)</p>
<p>I would like to flip qubit C if (A xor B)=1. The gate CCNOT(A,B,C) will flip C if A and B are both one.</p>
<p>Please let me know if there is a solution.</p>
",How to flip qubit C if (A xor B)=1?,<programming><quantum-circuit>,3,2,,,"How to flip qubit C if (A xor B)=1? <p>Assume I have tree qubits (A,B, and C)</p>
<p>I would like to flip qubit C if (A xor B)=1. The gate CCNOT(A,B,C) will flip C if A and B are both one.</p>
<p>Please let me know if there is a solution.</p>
",qc,flip qubit c xor b p assume tree qubits b c p would like flip qubit c xor b gate ccnot b c flip c b p please let know,"[(13, 0.21150999), (17, 0.26691142), (18, 0.51594716)]"
24291,,2022-02-28 16:51:59,1,173,"<p>I'm currently trying out some things with qutip in the field of optimal control (state-to-state transfer) and have some trouble to reproduce my results from the optimization process with sesolve.</p>
<p>My code for the optimization is:</p>
<pre><code># define the main hamiltonian of our system
H_0 = Qobj(w[0:dimension]*np.identity(dimension))
# define the drive-hamiltonian
H_d = Qobj(matrix)
# define the control-list for later optimization
H_c = [H_d]

# define the initial state of our system
psi_0 = basis(dimension,0)
# define the target state of our system
psi_target = basis(dimension,1)

# define the projector onto the inital state (|psi_0&gt;&lt;psi_0|)
proj0 = ket2dm(psi_0)
# define the projector onto the target state (|psi_target&gt;&lt;psi_target|)
proj1 = ket2dm(psi_target)
.
.
.
result = cpo.optimize_pulse_unitary(H_0, H_c, psi_0, psi_target, n_ts, evo_time, 
                fid_err_targ=fid_err_targ, min_grad=min_grad, 
                max_iter=max_iter, max_wall_time=max_wall_time, 
                init_pulse_type=p_type, 
                log_level=log_level, gen_stats=True)
</code></pre>
<p>Where I get a final fidelity error of 2.0313561943652303e-10.</p>
<p>I wanted to verify this result by taking the optimized pulse and plugging it into the qutip.sesolve function but doing so gives me fidelity errors which are not compatible with the result from the optimization.</p>
<p>My code for the sesolve function is:</p>
<pre><code># define an evenly spaced list with the number of intervals being equal to the the time steps of our control pulse
tlist = np.linspace(0, evo_time, n_ts)
# define the optimized pulse
optim_pulse = result.final_amps[:, 0]
# define our &quot;Hamiltonian&quot;
H = [H_0, [H_d, optim_pulse]]
# define the e_ops list
e_ops = [proj0, proj1]
# define the intial state
init_state = psi_0

options = Options()
options.store_states = True

# compute the time-evolution of the given Hamiltonian (including the drive term) from an inital state to a final state
evolved_State = qutip.sesolve(
            H=H,
            psi0=init_state,
            tlist=tlist,
            e_ops=e_ops,
            options=options)
</code></pre>
<p>Which produces a fidelity error of 0.0011998990068043947.</p>
<p>I wondered if I'm doing something wrong with the application of the sesolve function or if its something else which produces this difference?</p>
<p>Using other inital pulses I even sometimes get final populations of the target state lower then the inital state while the optimization result says it converged in the fidelity error.</p>
<p>Would be awesome if anyone could share some input on this idea, thank you!</p>
",qutip.sesolve and qutip.optimize_pulse_unitary produce different results,<programming><simulation><optimization><optical-quantum-computing><qutip>,0,0,,,"qutip.sesolve and qutip.optimize_pulse_unitary produce different results <p>I'm currently trying out some things with qutip in the field of optimal control (state-to-state transfer) and have some trouble to reproduce my results from the optimization process with sesolve.</p>
<p>My code for the optimization is:</p>
<pre><code># define the main hamiltonian of our system
H_0 = Qobj(w[0:dimension]*np.identity(dimension))
# define the drive-hamiltonian
H_d = Qobj(matrix)
# define the control-list for later optimization
H_c = [H_d]

# define the initial state of our system
psi_0 = basis(dimension,0)
# define the target state of our system
psi_target = basis(dimension,1)

# define the projector onto the inital state (|psi_0&gt;&lt;psi_0|)
proj0 = ket2dm(psi_0)
# define the projector onto the target state (|psi_target&gt;&lt;psi_target|)
proj1 = ket2dm(psi_target)
.
.
.
result = cpo.optimize_pulse_unitary(H_0, H_c, psi_0, psi_target, n_ts, evo_time, 
                fid_err_targ=fid_err_targ, min_grad=min_grad, 
                max_iter=max_iter, max_wall_time=max_wall_time, 
                init_pulse_type=p_type, 
                log_level=log_level, gen_stats=True)
</code></pre>
<p>Where I get a final fidelity error of 2.0313561943652303e-10.</p>
<p>I wanted to verify this result by taking the optimized pulse and plugging it into the qutip.sesolve function but doing so gives me fidelity errors which are not compatible with the result from the optimization.</p>
<p>My code for the sesolve function is:</p>
<pre><code># define an evenly spaced list with the number of intervals being equal to the the time steps of our control pulse
tlist = np.linspace(0, evo_time, n_ts)
# define the optimized pulse
optim_pulse = result.final_amps[:, 0]
# define our &quot;Hamiltonian&quot;
H = [H_0, [H_d, optim_pulse]]
# define the e_ops list
e_ops = [proj0, proj1]
# define the intial state
init_state = psi_0

options = Options()
options.store_states = True

# compute the time-evolution of the given Hamiltonian (including the drive term) from an inital state to a final state
evolved_State = qutip.sesolve(
            H=H,
            psi0=init_state,
            tlist=tlist,
            e_ops=e_ops,
            options=options)
</code></pre>
<p>Which produces a fidelity error of 0.0011998990068043947.</p>
<p>I wondered if I'm doing something wrong with the application of the sesolve function or if its something else which produces this difference?</p>
<p>Using other inital pulses I even sometimes get final populations of the target state lower then the inital state while the optimization result says it converged in the fidelity error.</p>
<p>Would be awesome if anyone could share some input on this idea, thank you!</p>
",qc,produce different results p currently trying things qutip field optimal control transfer trouble reproduce results optimization process p code optimization pre code define main hamiltonian system qobj w 0 dimension dimension define qobj matrix define later optimization define initial state system basis define target state system basis define projector onto inital state gt lt proj0 ket2dm define projector onto target state gt lt proj1 ket2dm result p get final fidelity error p wanted verify result taking optimized pulse plugging function gives fidelity errors compatible result p code sesolve function pre code define evenly spaced list number intervals equal time steps control pulse tlist 0 define optimized pulse 0 define quot hamiltonian quot h define list proj0 proj1 define intial state options options true compute given hamiltonian including drive term inital state final state p produces fidelity error p wondered something wrong application sesolve function something else produces difference p using inital pulses even sometimes get final populations target state lower inital state optimization result says converged fidelity p would awesome anyone could share input idea thank,"[(0, 0.28985584), (1, 0.073391), (2, 0.02409116), (10, 0.021984097), (11, 0.021606885), (14, 0.37981182), (17, 0.025758483), (18, 0.14811596), (19, 0.014710009)]"
24347,24357.0,2022-03-03 14:55:47,0,141,"<p>I want to apply the projector <span class=""math-container"">$|0\rangle\langle 0|$</span> onto a previously prepared state <span class=""math-container"">$|\psi_1\rangle$</span> in qiskit. I have already initialized a quantum circuit (with two registers) into <span class=""math-container"">$|\psi_1\rangle$</span>, but I don't know how to apply a gate that projects one of the registers into <span class=""math-container"">$|0\rangle$</span>.</p>
<p>How can I create a projector operator to obtain this? I want to run this program in QASM Simulator (and later in a real device).</p>
",How do you apply a projector in Qiskit?,<qiskit>,1,1,,,"How do you apply a projector in Qiskit? <p>I want to apply the projector <span class=""math-container"">$|0\rangle\langle 0|$</span> onto a previously prepared state <span class=""math-container"">$|\psi_1\rangle$</span> in qiskit. I have already initialized a quantum circuit (with two registers) into <span class=""math-container"">$|\psi_1\rangle$</span>, but I don't know how to apply a gate that projects one of the registers into <span class=""math-container"">$|0\rangle$</span>.</p>
<p>How can I create a projector operator to obtain this? I want to run this program in QASM Simulator (and later in a real device).</p>
",qc,apply projector qiskit p want apply projector span onto previously prepared state span qiskit already initialized quantum circuit two registers span know apply gate projects one registers span p create projector operator obtain want run program qasm simulator later real device,"[(3, 0.2355647), (14, 0.5581154), (17, 0.044502705), (18, 0.15793222)]"
24349,24434.0,2022-03-03 15:56:30,0,575,"<p>I'm currently following the &quot;Introduction To Quantum Programming&quot; course of qiskit.</p>
<p>At the beginning of &quot;Visualizing entanglement&quot; chapter :
<a href=""https://learn.qiskit.org/course/introduction/visualizing-entanglement"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/introduction/visualizing-entanglement</a></p>
<p>We have to run this line:
<code>from hello_qiskit import run_puzzle</code></p>
<p>This raises this error :</p>
<blockquote>
<p>ModuleNotFoundError: No module named 'hello_qiskit'</p>
</blockquote>
<p>I cannot find the hello_qiskit module in my anaconda environnement
And if I try to install it with</p>
<p><code>pip install hello_qiskit</code>
I have this error:</p>
<blockquote>
<p>ERROR: Could not find a version that satisfies the requirement
hello_qiskit (from versions: none) ERROR: No
matching distribution found for hello_qiskit</p>
</blockquote>
<p>How can I install this module or is there another way to use the run_puzzle function ?</p>
",cannot find hello_qiskit module,<qiskit><programming>,1,4,,,"cannot find hello_qiskit module <p>I'm currently following the &quot;Introduction To Quantum Programming&quot; course of qiskit.</p>
<p>At the beginning of &quot;Visualizing entanglement&quot; chapter :
<a href=""https://learn.qiskit.org/course/introduction/visualizing-entanglement"" rel=""nofollow noreferrer"">https://learn.qiskit.org/course/introduction/visualizing-entanglement</a></p>
<p>We have to run this line:
<code>from hello_qiskit import run_puzzle</code></p>
<p>This raises this error :</p>
<blockquote>
<p>ModuleNotFoundError: No module named 'hello_qiskit'</p>
</blockquote>
<p>I cannot find the hello_qiskit module in my anaconda environnement
And if I try to install it with</p>
<p><code>pip install hello_qiskit</code>
I have this error:</p>
<blockquote>
<p>ERROR: Could not find a version that satisfies the requirement
hello_qiskit (from versions: none) ERROR: No
matching distribution found for hello_qiskit</p>
</blockquote>
<p>How can I install this module or is there another way to use the run_puzzle function ?</p>
",qc,find module p currently following quot introduction quantum programming quot course p beginning quot visualizing entanglement quot chapter https nofollow noreferrer https p run line code import p raises error blockquote p modulenotfounderror module named p find module anaconda environnement try install p code pip install error blockquote p error could find version satisfies requirement versions none error matching distribution found p install module another way use function,"[(0, 0.29718077), (4, 0.123433016), (5, 0.041623615), (8, 0.20952316), (13, 0.20544626), (17, 0.013107184), (19, 0.10772162)]"
24416,,2022-03-07 11:02:42,3,358,"<p>I have been playing around with the qecsim Python library and a question has come to my thoght. Whenever I try to represent the logical error rate dependence with the physical error rate for several planar code distances the even ones do not intersect with the probability threshold, but the rest always do. Then I saw that most of the articles consider odd distances. Why is that?</p>
<p>My first thought has been to be the existence of a given symmetry for even distance codes which make their error detection to be worse, but I am not sure. I have been looking for the answer in articles online but could not find it. Does anyone know why?</p>
<p>Thank you very much in advance!</p>
",Why are the planar surface codes in articles always of odd distance?,<surface-code>,3,0,,,"Why are the planar surface codes in articles always of odd distance? <p>I have been playing around with the qecsim Python library and a question has come to my thoght. Whenever I try to represent the logical error rate dependence with the physical error rate for several planar code distances the even ones do not intersect with the probability threshold, but the rest always do. Then I saw that most of the articles consider odd distances. Why is that?</p>
<p>My first thought has been to be the existence of a given symmetry for even distance codes which make their error detection to be worse, but I am not sure. I have been looking for the answer in articles online but could not find it. Does anyone know why?</p>
<p>Thank you very much in advance!</p>
",qc,planar surface codes articles always odd distance p playing around qecsim python library question come thoght whenever try represent logical error rate dependence physical error rate several planar code distances even ones intersect probability threshold rest always saw articles consider odd distances p first thought existence given symmetry even distance codes make error detection worse sure looking answer articles online could find anyone know p thank much advance,"[(5, 0.3246989), (8, 0.29976165), (9, 0.17642201), (13, 0.15284158), (17, 0.04400822)]"
24428,24433.0,2022-03-08 09:14:31,3,836,"<p>I am currently doing some experiments using Variational Quantum Eigensolver in molecular dynamics using qiskit, and noticed that the time for execution on real backend is significantly higher than the simulated backend.</p>
<p>I am aware that this is normal, due to the overhead of quantum execution (i.e., resetting the qubits, transforming the circuit into waveforms and so on), and that for the type of instances I am using I cannot expect a speedup.</p>
<p>However, I would like to know if there are some &quot;best practices&quot; to take into account when executing my code on real backends. More precisely, I would like to know: is there a way that allows me to speed up the code, by knowing some architectural details (i.e., the topology and the type of qubits) or ways to prepare my input? Are there operators that are faster than others? Any idea about where I could find this information?</p>
<p>Any suggestion on the topic would be much appreciated.
Thanks for your attention!</p>
<p>Best Regards,</p>
",Qiskit best programming practices - how to speed up qiskit code?,<qiskit><programming><vqe><speedup><qiskit-runtime>,2,2,,,"Qiskit best programming practices - how to speed up qiskit code? <p>I am currently doing some experiments using Variational Quantum Eigensolver in molecular dynamics using qiskit, and noticed that the time for execution on real backend is significantly higher than the simulated backend.</p>
<p>I am aware that this is normal, due to the overhead of quantum execution (i.e., resetting the qubits, transforming the circuit into waveforms and so on), and that for the type of instances I am using I cannot expect a speedup.</p>
<p>However, I would like to know if there are some &quot;best practices&quot; to take into account when executing my code on real backends. More precisely, I would like to know: is there a way that allows me to speed up the code, by knowing some architectural details (i.e., the topology and the type of qubits) or ways to prepare my input? Are there operators that are faster than others? Any idea about where I could find this information?</p>
<p>Any suggestion on the topic would be much appreciated.
Thanks for your attention!</p>
<p>Best Regards,</p>
",qc,qiskit best programming practices speed qiskit code p currently experiments using variational quantum eigensolver molecular dynamics using qiskit noticed time execution real backend significantly higher simulated p aware normal due overhead quantum execution resetting qubits transforming circuit waveforms type instances using expect p however would like know quot best practices quot take account executing code real backends precisely would like know way allows speed code knowing architectural details topology type qubits ways prepare input operators faster others idea could find information p suggestion topic would much appreciated thanks attention p best regards,"[(1, 0.06989763), (3, 0.024630206), (8, 0.2924847), (14, 0.52919453), (17, 0.058437716), (19, 0.023817988)]"
24503,24510.0,2022-03-13 08:43:30,2,402,"<p>Suppose each qubit of <span class=""math-container"">$\text{GHZ}_3$</span> State is distribute to <span class=""math-container"">$3$</span> different parties at different locations through a noisy quantum channel. So each qubit can possibly go through: a bit flip error, a phase error or a combination of these two.</p>
<p>Is there some operation that can be performed locally by each parties to determine the errors in the qubit?</p>
<p>Basically I wanted to generalize the idea for Bell state to GHZ state as given <a href=""https://knilesh.notion.site/For-Question-0e07e755feb6478aa1bc0a978ff0771d"" rel=""nofollow noreferrer"">here</a>. Clearly in the case of Bell state when Alice sends other half to Bob, there exists measurements that can be performed localy to determine bit flip and phase error. That is (see <a href=""https://knilesh.notion.site/For-Question-0e07e755feb6478aa1bc0a978ff0771d"" rel=""nofollow noreferrer"">here</a> for detail):
<span class=""math-container"">$$
\begin{aligned}
&amp;\Pi_{\mathrm{bf}}=\frac{1}{2}\left(\mathrm{id} \otimes \mathrm{id}-\sigma_{z} \otimes \sigma_{z}\right) \\
&amp;\Pi_{\mathrm{pe}}=\frac{1}{2}\left(\mathrm{id} \otimes \mathrm{id}-\sigma_{x} \otimes \sigma_{x}\right)
\end{aligned}
$$</span></p>
<p>I am interested in estimating amount of error in GHZ state using local operations in order to apply the error correcting codes and to calculate the fidelity.</p>
",Calculating bit flip and phase error using local operations for GHZ state,<error-correction><noise>,1,1,,,"Calculating bit flip and phase error using local operations for GHZ state <p>Suppose each qubit of <span class=""math-container"">$\text{GHZ}_3$</span> State is distribute to <span class=""math-container"">$3$</span> different parties at different locations through a noisy quantum channel. So each qubit can possibly go through: a bit flip error, a phase error or a combination of these two.</p>
<p>Is there some operation that can be performed locally by each parties to determine the errors in the qubit?</p>
<p>Basically I wanted to generalize the idea for Bell state to GHZ state as given <a href=""https://knilesh.notion.site/For-Question-0e07e755feb6478aa1bc0a978ff0771d"" rel=""nofollow noreferrer"">here</a>. Clearly in the case of Bell state when Alice sends other half to Bob, there exists measurements that can be performed localy to determine bit flip and phase error. That is (see <a href=""https://knilesh.notion.site/For-Question-0e07e755feb6478aa1bc0a978ff0771d"" rel=""nofollow noreferrer"">here</a> for detail):
<span class=""math-container"">$$
\begin{aligned}
&amp;\Pi_{\mathrm{bf}}=\frac{1}{2}\left(\mathrm{id} \otimes \mathrm{id}-\sigma_{z} \otimes \sigma_{z}\right) \\
&amp;\Pi_{\mathrm{pe}}=\frac{1}{2}\left(\mathrm{id} \otimes \mathrm{id}-\sigma_{x} \otimes \sigma_{x}\right)
\end{aligned}
$$</span></p>
<p>I am interested in estimating amount of error in GHZ state using local operations in order to apply the error correcting codes and to calculate the fidelity.</p>
",qc,calculating bit flip phase error using local operations ghz state p suppose qubit span ghz state distribute span 3 different parties different locations noisy quantum channel qubit possibly go bit flip error phase error combination p operation performed locally parties determine errors qubit p basically wanted generalize idea bell state ghz state given https nofollow noreferrer clearly case bell state alice sends half bob exists measurements performed localy determine bit flip phase error see https nofollow noreferrer detail span aligned amp bf 1 2 id id z z amp pe 1 2 id id x x aligned p interested estimating amount error ghz state using local operations order apply error correcting codes calculate,"[(1, 0.014792545), (2, 0.016391391), (3, 0.10796852), (4, 0.099154815), (5, 0.15584292), (8, 0.033801742), (10, 0.01936121), (15, 0.046618886), (17, 0.06460974), (18, 0.44055006)]"
24507,24508.0,2022-03-13 22:57:28,2,320,"<p>I am currently trying to implement circuit (in Qiskit if that is relevant) to approximate a state of a qubit without measuring it (basically I want to &quot;attach it&quot; to a qubit and have some approximate idea about it's state while not collapsing it's quantum state and not changing it)</p>
<p>I have looked at Universal Quantum Cloning Machine:
<a href=""https://i.sstatic.net/Ap1HB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ap1HB.png"" alt=""enter image description here"" /></a></p>
<p>I have noticed that this does seem to change the state of the input qubit (I had an input state of |1&gt; but some of the post measurements returned 0 in a simulator).</p>
<p>is anyone aware of an approach that allows to approximate state of a qubit without changing it? (is that even possible under no cloning theorem or any other restrictions coming from quantum mechanics?)</p>
<p>I would be very grateful for any pointers</p>
",does there exist a quantum approximate cloning method that does not modify the initial qubit (the one whose state we want to clone)?,<qiskit><quantum-algorithms><no-cloning-theorem><cloning>,1,0,,,"does there exist a quantum approximate cloning method that does not modify the initial qubit (the one whose state we want to clone)? <p>I am currently trying to implement circuit (in Qiskit if that is relevant) to approximate a state of a qubit without measuring it (basically I want to &quot;attach it&quot; to a qubit and have some approximate idea about it's state while not collapsing it's quantum state and not changing it)</p>
<p>I have looked at Universal Quantum Cloning Machine:
<a href=""https://i.sstatic.net/Ap1HB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ap1HB.png"" alt=""enter image description here"" /></a></p>
<p>I have noticed that this does seem to change the state of the input qubit (I had an input state of |1&gt; but some of the post measurements returned 0 in a simulator).</p>
<p>is anyone aware of an approach that allows to approximate state of a qubit without changing it? (is that even possible under no cloning theorem or any other restrictions coming from quantum mechanics?)</p>
<p>I would be very grateful for any pointers</p>
",qc,exist quantum approximate cloning method modify initial qubit one whose state want clone p currently trying implement circuit qiskit relevant approximate state qubit without measuring basically want quot attach quot qubit approximate idea state collapsing quantum state changing p looked universal quantum cloning machine https nofollow noreferrer img https enter image description p noticed seem change state input qubit input state gt post measurements returned 0 simulator p anyone aware approach allows approximate state qubit without changing even possible cloning theorem restrictions coming quantum mechanics p would grateful pointers,"[(2, 0.01190259), (4, 0.12396336), (8, 0.09855904), (9, 0.19711064), (14, 0.18140684), (17, 0.04659572), (18, 0.31431636), (19, 0.02479969)]"
24551,,2022-03-17 14:53:02,1,172,"<p>I am trying to find the threshold of a surface code for dephasing error using pymatching and stim. I am unable to apply the Z_ERROR onto the qubits using the given format since a surface code will require coordinates of the qubits.</p>
<p>Format:
Z_ERROR (probability) qubit_number</p>
<p>Is there something I'm missing in terms of the syntax required to use Z_ERROR on the Stim generated surface code?</p>
",How do I specify the coordinates of dephasing errors in the surface code using Stim,<programming><error-correction><stim>,2,0,,,"How do I specify the coordinates of dephasing errors in the surface code using Stim <p>I am trying to find the threshold of a surface code for dephasing error using pymatching and stim. I am unable to apply the Z_ERROR onto the qubits using the given format since a surface code will require coordinates of the qubits.</p>
<p>Format:
Z_ERROR (probability) qubit_number</p>
<p>Is there something I'm missing in terms of the syntax required to use Z_ERROR on the Stim generated surface code?</p>
",qc,specify coordinates dephasing errors surface code using stim p trying find threshold surface code dephasing error using pymatching stim unable apply onto qubits using given format since surface code require coordinates p format probability p something missing terms syntax required use stim generated surface code,"[(5, 0.38881326), (14, 0.5843335), (17, 0.023091218)]"
24559,25561.0,2022-03-18 00:22:34,2,70,"<p>Currently, I reading the toric code section in the beginning of the paper <em>Topological Quantum Memory</em>. Here are a couple of sections that are somewhat confusing to me.</p>
<p>(1)</p>
<p>This quote below is under a small section that gives general remarks about surface codes.</p>
<blockquote>
<blockquote>
<p>These codes are especially well
suited for fault-tolerant implementation, because the procedure for measuring the error syndrome is highly local.</p>
</blockquote>
</blockquote>
<p><strong>Question: Why is this locality important? My guess is local errors do not destroy the quantum information if the information is distributed throughout the lattice, but I am not sure if this is what the author had in mind.</strong></p>
<p>(3)
<strong>Question: Throughout the section on the toric code, I see the words &quot;preserves the code subspace,&quot; but I am not sure what the meaning is. What is a code subspace and what does it mean to preserve it?</strong></p>
",Questions on Definitions and Concepts Regarding Toric Codes,<stabilizer-code><architecture><fault-tolerance><toric-code>,1,2,,,"Questions on Definitions and Concepts Regarding Toric Codes <p>Currently, I reading the toric code section in the beginning of the paper <em>Topological Quantum Memory</em>. Here are a couple of sections that are somewhat confusing to me.</p>
<p>(1)</p>
<p>This quote below is under a small section that gives general remarks about surface codes.</p>
<blockquote>
<blockquote>
<p>These codes are especially well
suited for fault-tolerant implementation, because the procedure for measuring the error syndrome is highly local.</p>
</blockquote>
</blockquote>
<p><strong>Question: Why is this locality important? My guess is local errors do not destroy the quantum information if the information is distributed throughout the lattice, but I am not sure if this is what the author had in mind.</strong></p>
<p>(3)
<strong>Question: Throughout the section on the toric code, I see the words &quot;preserves the code subspace,&quot; but I am not sure what the meaning is. What is a code subspace and what does it mean to preserve it?</strong></p>
",qc,questions definitions concepts regarding toric codes p currently reading toric code section beginning paper em topological quantum memory couple sections somewhat confusing p 1 p quote small section gives general remarks surface blockquote blockquote p codes especially well suited implementation procedure measuring error syndrome highly p strong question locality important guess local errors destroy quantum information information distributed throughout lattice sure author p 3 strong question throughout section toric code see words quot preserves code subspace quot sure meaning code subspace mean preserve,"[(5, 0.28248978), (7, 0.0491058), (8, 0.10470931), (9, 0.39549187), (13, 0.084634975), (16, 0.012562632), (17, 0.042467672), (19, 0.027059358)]"
25597,25599.0,2022-03-21 09:54:31,1,600,"<p>I am trying to execute qiskit runtime jobs on simulators and real machines and I would like to extract information about the time taken to execute each runtime job. Since using python <code>time.time()</code> method will include also queueing time, which I would like to exclude, I thought about checking on <code>time_taken</code> attribute of the <code>RuntimeJob</code>. To this end, I found this code:</p>
<pre><code>job = provider.runtime.run(program_id='...', inputs=inputs, options=options)
job_id = job.job_id()
job_info = backend.retrieve_job(job_id)
</code></pre>
<p>And my plan was to use the <code>time_taken</code> attribute, as I have seen in many other threads.
However, I get the following error:</p>
<pre><code>File &quot;/usr/local/lib/python3.9/dist-packages/qiskit/providers/ibmq/ibmqbackendservice.py&quot;, line 484, in retrieve_job
    raise IBMQBackendApiError('Failed to get job {}: {}'
qiskit.providers.ibmq.exceptions.IBMQBackendApiError: &quot;Failed to get job c8s4h14o112vg1vn8ed0: '404 Client Error: Not Found for url: https://api-qcon.quantum-computing.ibm.com/api/Network/.../main/Jobs/c8s4h14o112vg1vn8ed0/v/1. Job not found., Error code: 3250.'
</code></pre>
<p>I checked the id in the IBM quantum service web interface, and the <code>job_id</code> is the same. I do not understand what I am doing wrong. Is there something I am missing?</p>
<p>Until now, that's the best I could do, but I am sure there is a better way:</p>
<pre><code>job = provider.runtime.run(program_id='x', inputs=inputs, options=options)
while job.status() != JobStatus.RUNNING:
    pass
start = time.time()
res = job.result()
end = time.time()
</code></pre>
<p>Thanks a lot for your attention and Best Regards!</p>
",How to access a qiskit runtime job and query time_taken?,<qiskit><ibm-q-experience><qiskit-runtime>,1,1,,,"How to access a qiskit runtime job and query time_taken? <p>I am trying to execute qiskit runtime jobs on simulators and real machines and I would like to extract information about the time taken to execute each runtime job. Since using python <code>time.time()</code> method will include also queueing time, which I would like to exclude, I thought about checking on <code>time_taken</code> attribute of the <code>RuntimeJob</code>. To this end, I found this code:</p>
<pre><code>job = provider.runtime.run(program_id='...', inputs=inputs, options=options)
job_id = job.job_id()
job_info = backend.retrieve_job(job_id)
</code></pre>
<p>And my plan was to use the <code>time_taken</code> attribute, as I have seen in many other threads.
However, I get the following error:</p>
<pre><code>File &quot;/usr/local/lib/python3.9/dist-packages/qiskit/providers/ibmq/ibmqbackendservice.py&quot;, line 484, in retrieve_job
    raise IBMQBackendApiError('Failed to get job {}: {}'
qiskit.providers.ibmq.exceptions.IBMQBackendApiError: &quot;Failed to get job c8s4h14o112vg1vn8ed0: '404 Client Error: Not Found for url: https://api-qcon.quantum-computing.ibm.com/api/Network/.../main/Jobs/c8s4h14o112vg1vn8ed0/v/1. Job not found., Error code: 3250.'
</code></pre>
<p>I checked the id in the IBM quantum service web interface, and the <code>job_id</code> is the same. I do not understand what I am doing wrong. Is there something I am missing?</p>
<p>Until now, that's the best I could do, but I am sure there is a better way:</p>
<pre><code>job = provider.runtime.run(program_id='x', inputs=inputs, options=options)
while job.status() != JobStatus.RUNNING:
    pass
start = time.time()
res = job.result()
end = time.time()
</code></pre>
<p>Thanks a lot for your attention and Best Regards!</p>
",qc,access qiskit runtime job query p trying execute qiskit runtime jobs simulators real machines would like extract information time taken execute runtime job since using python code method include also queueing time would like exclude thought checking code attribute code runtimejob end found code pre code job p plan use code attribute seen many threads however get following error pre code file quot quot line 484 raise ibmqbackendapierror get job quot failed get job c8s4h14o112vg1vn8ed0 client error found url https job error code 3250 p checked id ibm quantum service web interface code understand wrong something missing p best could sure better way pre code job x pass start res end p thanks lot attention best regards,"[(0, 0.0667319), (7, 0.032964017), (8, 0.03756997), (10, 0.011053251), (14, 0.70344317), (17, 0.015879624), (19, 0.13119876)]"
25653,25659.0,2022-03-25 12:40:13,0,506,"<p>I have been reading some papers related to surface codes, and I have a doubt regarding the cycle time of surface codes. Both of the papers I have been studying (<a href=""https://arxiv.org/pdf/1905.09749.pdf"" rel=""nofollow noreferrer"">How to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubits</a> and <a href=""https://arxiv.org/pdf/1905.08916.pdf"" rel=""nofollow noreferrer"">Flexible layout of surface code computations using AutoCCZ states</a>) assume that their surface codes have a code cycle time of 1 <span class=""math-container"">$\mu s$</span> independent to the distance of such codes. Specifically, they consider two different distances <span class=""math-container"">$17$</span> and <span class=""math-container"">$27$</span>, and still consider that the cycle time is the same. Is there a reason for this to be like that? or is it just an assumption made by the authors?</p>
",Surface code cycle time,<error-correction><surface-code>,1,0,,,"Surface code cycle time <p>I have been reading some papers related to surface codes, and I have a doubt regarding the cycle time of surface codes. Both of the papers I have been studying (<a href=""https://arxiv.org/pdf/1905.09749.pdf"" rel=""nofollow noreferrer"">How to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubits</a> and <a href=""https://arxiv.org/pdf/1905.08916.pdf"" rel=""nofollow noreferrer"">Flexible layout of surface code computations using AutoCCZ states</a>) assume that their surface codes have a code cycle time of 1 <span class=""math-container"">$\mu s$</span> independent to the distance of such codes. Specifically, they consider two different distances <span class=""math-container"">$17$</span> and <span class=""math-container"">$27$</span>, and still consider that the cycle time is the same. Is there a reason for this to be like that? or is it just an assumption made by the authors?</p>
",qc,surface code cycle time p reading papers related surface codes doubt regarding cycle time surface codes papers studying https nofollow noreferrer factor 2048 bit rsa integers 8 hours using 20 million noisy qubits https nofollow noreferrer flexible layout surface code computations using autoccz states assume surface codes code cycle time 1 span independent distance codes specifically consider two different distances span 17 span 27 still consider cycle time reason like assumption made authors,"[(3, 0.07935601), (4, 0.093482435), (5, 0.45199916), (6, 0.063126504), (8, 0.29514107), (17, 0.014927771)]"
25663,27576.0,2022-03-25 23:32:15,3,204,"<h2>Background</h2>
<p>I'm reviewing basis encoding in <a href=""https://iopscience.iop.org/article/10.1088/2058-9565/abae7d"" rel=""nofollow noreferrer"">this paper</a>. In their example, they state:</p>
<blockquote>
<p><span class=""math-container"">$(-.07, 0.1, 0.2)^T \in \mathbb{R}^3$</span> is encoded as <span class=""math-container"">$|x\rangle = |11011\;01011\;00011\rangle$</span></p>
</blockquote>
<p>Unpacking this, it seems clear that the first bit representing each value is the sign bit and this appears to be corroborated in the text:</p>
<blockquote>
<p>The sign of the real number is encoded by an additional leading binary number, e.g. '1' for '−' and '0' for '+'.</p>
</blockquote>
<p>Removing the sign bit, we thus have:</p>
<p><span class=""math-container"">$0.7 \mapsto 1011$</span></p>
<p><span class=""math-container"">$0.1  \mapsto  1011$</span></p>
<p><span class=""math-container"">$0.2  \mapsto  0011$</span></p>
<p>Given we have 4 bits, that gives us 16 possible states. Alright. Assuming we're representing values in the interval <span class=""math-container"">$(-1.0, 1.0)$</span>, <span class=""math-container"">$1011$</span> gives us <span class=""math-container"">$11$</span> in decimal and <span class=""math-container"">$11/16 = 0.6875$</span>, where <span class=""math-container"">$\lceil 0.6875 \rceil = 0.7$</span>. By similar logic, <span class=""math-container"">$0011$</span> gives us <span class=""math-container"">$3$</span> in decimal and <span class=""math-container"">$3/16 = 0.1875$</span>, where <span class=""math-container"">$\lceil 0.1875 \rceil = 0.2$</span>. This all appears to make sense.</p>
<p>But then we have:</p>
<p><span class=""math-container"">$0.1  \mapsto  1011$</span></p>
<p>Okay, this doesn't make sense. <span class=""math-container"">$1011$</span> is the binary encoding we had for <span class=""math-container"">$0.7$</span> and, by the prior logic, I'd expect:</p>
<p><span class=""math-container"">$0.1 \mapsto 0001$</span>,</p>
<p>which would give us <span class=""math-container"">$1$</span> in decimal and <span class=""math-container"">$1/16 = 0.0625$</span>, where <span class=""math-container"">$\lceil 0.0625 \rceil = 0.1$</span>.</p>
<h2>Question</h2>
<p>What am I missing here? No alternative logic appears to be clearly correct. Maybe there's an error in the text but it's unclear to me where.</p>
<p>Can someone please explain the exact manipulations being done to go from the data <span class=""math-container"">$(-0.7, 0.1, 0.2)$</span> to the state <span class=""math-container"">$|x\rangle = |11011\;01011\;00011\rangle$</span>? Given this isn’t a pre-print, I’m assuming I’m the one who’s made an error or, worst case, this represents a fundamental conceptual gap in my knowledge of very basic QIS concepts.</p>
",Clarifying basis encoding,<quantum-state><quantum-algorithms>,1,2,,,"Clarifying basis encoding <h2>Background</h2>
<p>I'm reviewing basis encoding in <a href=""https://iopscience.iop.org/article/10.1088/2058-9565/abae7d"" rel=""nofollow noreferrer"">this paper</a>. In their example, they state:</p>
<blockquote>
<p><span class=""math-container"">$(-.07, 0.1, 0.2)^T \in \mathbb{R}^3$</span> is encoded as <span class=""math-container"">$|x\rangle = |11011\;01011\;00011\rangle$</span></p>
</blockquote>
<p>Unpacking this, it seems clear that the first bit representing each value is the sign bit and this appears to be corroborated in the text:</p>
<blockquote>
<p>The sign of the real number is encoded by an additional leading binary number, e.g. '1' for '−' and '0' for '+'.</p>
</blockquote>
<p>Removing the sign bit, we thus have:</p>
<p><span class=""math-container"">$0.7 \mapsto 1011$</span></p>
<p><span class=""math-container"">$0.1  \mapsto  1011$</span></p>
<p><span class=""math-container"">$0.2  \mapsto  0011$</span></p>
<p>Given we have 4 bits, that gives us 16 possible states. Alright. Assuming we're representing values in the interval <span class=""math-container"">$(-1.0, 1.0)$</span>, <span class=""math-container"">$1011$</span> gives us <span class=""math-container"">$11$</span> in decimal and <span class=""math-container"">$11/16 = 0.6875$</span>, where <span class=""math-container"">$\lceil 0.6875 \rceil = 0.7$</span>. By similar logic, <span class=""math-container"">$0011$</span> gives us <span class=""math-container"">$3$</span> in decimal and <span class=""math-container"">$3/16 = 0.1875$</span>, where <span class=""math-container"">$\lceil 0.1875 \rceil = 0.2$</span>. This all appears to make sense.</p>
<p>But then we have:</p>
<p><span class=""math-container"">$0.1  \mapsto  1011$</span></p>
<p>Okay, this doesn't make sense. <span class=""math-container"">$1011$</span> is the binary encoding we had for <span class=""math-container"">$0.7$</span> and, by the prior logic, I'd expect:</p>
<p><span class=""math-container"">$0.1 \mapsto 0001$</span>,</p>
<p>which would give us <span class=""math-container"">$1$</span> in decimal and <span class=""math-container"">$1/16 = 0.0625$</span>, where <span class=""math-container"">$\lceil 0.0625 \rceil = 0.1$</span>.</p>
<h2>Question</h2>
<p>What am I missing here? No alternative logic appears to be clearly correct. Maybe there's an error in the text but it's unclear to me where.</p>
<p>Can someone please explain the exact manipulations being done to go from the data <span class=""math-container"">$(-0.7, 0.1, 0.2)$</span> to the state <span class=""math-container"">$|x\rangle = |11011\;01011\;00011\rangle$</span>? Given this isn’t a pre-print, I’m assuming I’m the one who’s made an error or, worst case, this represents a fundamental conceptual gap in my knowledge of very basic QIS concepts.</p>
",qc,clarifying basis encoding h2 background p reviewing basis encoding https nofollow noreferrer paper example state blockquote p span r encoded span p unpacking seems clear first bit representing value sign bit appears corroborated text blockquote p sign real number encoded additional leading binary number 1 0 p removing sign bit thus p span 1011 p span 1011 p span 0011 p given 4 bits gives us 16 possible states alright assuming representing values interval span span 1011 gives us span 11 decimal span span similar logic span 0011 gives us span 3 decimal span span appears make p p span 1011 p okay make sense span 1011 binary encoding span prior logic expect p span 0001 p would give us span 1 decimal span span h2 question p missing alternative logic appears clearly correct maybe error text unclear p someone please explain exact manipulations done go data span state span given assuming one made error worst case represents fundamental conceptual gap knowledge basic qis,"[(3, 0.44782776), (5, 0.03241886), (6, 0.03281207), (7, 0.02052297), (8, 0.08647566), (9, 0.06675494), (13, 0.25881594), (17, 0.05361256)]"
25709,,2022-03-30 07:02:46,1,49,"<p>I see that conditional <span class=""math-container"">$L_2$</span> distances from uniform are defined in the following way:
<span class=""math-container"">$L_2(\rho_{AB}\vert \sigma_B)= \text{tr}\left(((\rho_{AB}- \mu_{A} \otimes \rho_{B}) (\mathbb{I}_A \otimes \sigma_B^{-1/2}))^2\right)$</span> where <span class=""math-container"">$\mu_{A}$</span> is the maximally mixed state on <span class=""math-container"">$A$</span>. I do not understand motivation for this definition.Furthermore, conditional collision entropy is defined in the follwing way: <span class=""math-container"">$S_2(\rho_{AB} \vert \sigma_B)= - \log(L_2(\rho_{AB}\vert \sigma_B))$</span>.
Is there an <span class=""math-container"">$L_p$</span> analogue of this?</p>
",Understanding conditional $L_2$ distances,<entropy><linear-algebra><trace-distance><min-entropy><renyi-entropies>,0,2,,,"Understanding conditional $L_2$ distances <p>I see that conditional <span class=""math-container"">$L_2$</span> distances from uniform are defined in the following way:
<span class=""math-container"">$L_2(\rho_{AB}\vert \sigma_B)= \text{tr}\left(((\rho_{AB}- \mu_{A} \otimes \rho_{B}) (\mathbb{I}_A \otimes \sigma_B^{-1/2}))^2\right)$</span> where <span class=""math-container"">$\mu_{A}$</span> is the maximally mixed state on <span class=""math-container"">$A$</span>. I do not understand motivation for this definition.Furthermore, conditional collision entropy is defined in the follwing way: <span class=""math-container"">$S_2(\rho_{AB} \vert \sigma_B)= - \log(L_2(\rho_{AB}\vert \sigma_B))$</span>.
Is there an <span class=""math-container"">$L_p$</span> analogue of this?</p>
",qc,understanding conditional distances p see conditional span distances uniform defined following way span ab tr ab b span maximally mixed state span understand motivation conditional collision entropy defined follwing way span ab ab span analogue,"[(3, 0.9274756), (17, 0.067101575)]"
25715,25717.0,2022-03-30 18:22:40,2,525,"<p>I am currently trying to study the ground state of the Toric Code. I am currently reading this <a href=""https://authors.library.caltech.edu/99798/2/1907.02540.pdf"" rel=""nofollow noreferrer"">paper</a>.  The Hamiltonian is given by the following, where <span class=""math-container"">$A_s$</span>'s are the star operators made out a tensor product of Pauli X matrices and <span class=""math-container"">$B_p$</span>'s are the plaquette operators made out of a tensor product of the Pauli Z matrices:</p>
<p><span class=""math-container"">$$
H = -\sum_s A_s-\sum_pB_p
$$</span></p>
<p>I can clearly see that all these operators <span class=""math-container"">$A,B$</span>'s commute with one another and therefore each star (and plaquette) operator commutes with the Hamiltonian. Hence the star (plaquette) operators and the Hamiltonian are simultaneously diagonalizable.</p>
<p>The paper mentions that one of the ground states is given by the following:</p>
<p><span class=""math-container"">$$
\propto \prod_s (1 + A_s)|0\rangle
$$</span></p>
<p>where <span class=""math-container"">$|0\rangle$</span> is a tensor product of k single-qubit states <span class=""math-container"">$|0\rangle$</span>, where the dimensions of the square lattice is <span class=""math-container"">$k \times k$</span>.</p>
<p><strong>Question 1: Why is this a ground state?</strong></p>
<p>I applied the Hamiltonian to this state. For instance, consider hitting the ground state with the operator <span class=""math-container"">$A_{s'}$</span>, where <span class=""math-container"">$s'$</span> is a particular site. Since all the star operators commute, I see that</p>
<p><span class=""math-container"">$$A_{s'}\prod_s (1 + A_s) |0\rangle = \bigg[ \prod_s (1 + A_s)\bigg]A_{s'}|0\rangle$$</span>.</p>
<p>I see that <span class=""math-container"">$A_{s'}|0\rangle$</span> creates a state where the qubits on the links adjacent to site <span class=""math-container"">$s'$</span> are flipped from <span class=""math-container"">$0$</span> to <span class=""math-container"">$1$</span>. Thus when I apply <span class=""math-container"">$\sum_s A_s$</span> to the claimed ground state, the resulting state is a sum of states of the form <span class=""math-container"">$ \prod_s(1 + A_s)| \text{mixture of 0s and 1s}\rangle$</span></p>
<p>I also see that applying <span class=""math-container"">$\sum_p B_p$</span> to the claimed ground state gives me a sum of states, where each state/term is the the claimed ground state.</p>
<p>When I combine these together, I do not see the why the result is the ground state. Can anyone show me (eg. a proof) why the above ground state formula is the ground state of the toric code?</p>
<p><strong>Question 2:</strong> How can I generate the other ground states of the Toric Code with the above formula for the ground state?</p>
",Why Is This the Ground State of a Toric Code?,<stabilizer-code><surface-code><topological-quantum-computing><toric-code>,1,0,,,"Why Is This the Ground State of a Toric Code? <p>I am currently trying to study the ground state of the Toric Code. I am currently reading this <a href=""https://authors.library.caltech.edu/99798/2/1907.02540.pdf"" rel=""nofollow noreferrer"">paper</a>.  The Hamiltonian is given by the following, where <span class=""math-container"">$A_s$</span>'s are the star operators made out a tensor product of Pauli X matrices and <span class=""math-container"">$B_p$</span>'s are the plaquette operators made out of a tensor product of the Pauli Z matrices:</p>
<p><span class=""math-container"">$$
H = -\sum_s A_s-\sum_pB_p
$$</span></p>
<p>I can clearly see that all these operators <span class=""math-container"">$A,B$</span>'s commute with one another and therefore each star (and plaquette) operator commutes with the Hamiltonian. Hence the star (plaquette) operators and the Hamiltonian are simultaneously diagonalizable.</p>
<p>The paper mentions that one of the ground states is given by the following:</p>
<p><span class=""math-container"">$$
\propto \prod_s (1 + A_s)|0\rangle
$$</span></p>
<p>where <span class=""math-container"">$|0\rangle$</span> is a tensor product of k single-qubit states <span class=""math-container"">$|0\rangle$</span>, where the dimensions of the square lattice is <span class=""math-container"">$k \times k$</span>.</p>
<p><strong>Question 1: Why is this a ground state?</strong></p>
<p>I applied the Hamiltonian to this state. For instance, consider hitting the ground state with the operator <span class=""math-container"">$A_{s'}$</span>, where <span class=""math-container"">$s'$</span> is a particular site. Since all the star operators commute, I see that</p>
<p><span class=""math-container"">$$A_{s'}\prod_s (1 + A_s) |0\rangle = \bigg[ \prod_s (1 + A_s)\bigg]A_{s'}|0\rangle$$</span>.</p>
<p>I see that <span class=""math-container"">$A_{s'}|0\rangle$</span> creates a state where the qubits on the links adjacent to site <span class=""math-container"">$s'$</span> are flipped from <span class=""math-container"">$0$</span> to <span class=""math-container"">$1$</span>. Thus when I apply <span class=""math-container"">$\sum_s A_s$</span> to the claimed ground state, the resulting state is a sum of states of the form <span class=""math-container"">$ \prod_s(1 + A_s)| \text{mixture of 0s and 1s}\rangle$</span></p>
<p>I also see that applying <span class=""math-container"">$\sum_p B_p$</span> to the claimed ground state gives me a sum of states, where each state/term is the the claimed ground state.</p>
<p>When I combine these together, I do not see the why the result is the ground state. Can anyone show me (eg. a proof) why the above ground state formula is the ground state of the toric code?</p>
<p><strong>Question 2:</strong> How can I generate the other ground states of the Toric Code with the above formula for the ground state?</p>
",qc,ground state toric code p currently trying study ground state toric code currently reading https nofollow noreferrer paper hamiltonian given following span star operators made tensor product pauli x matrices span plaquette operators made tensor product pauli z matrices p span h p clearly see operators span b commute one another therefore star plaquette operator commutes hamiltonian hence star plaquette operators hamiltonian simultaneously p paper mentions one ground states given following p span 1 p span tensor product k states span dimensions square lattice span k k p strong question 1 ground state p applied hamiltonian state instance consider hitting ground state operator span span particular site since star operators commute see p span 1 1 p see span creates state qubits links adjacent site span flipped span 0 span 1 thus apply span claimed ground state resulting state sum states form span 1 mixture 0s 1s p also see applying span claimed ground state gives sum states claimed ground p combine together see result ground state anyone show eg proof ground state formula ground state toric code p strong question 2 generate ground states toric code formula ground state,"[(1, 0.104513645), (2, 0.02348946), (3, 0.56308633), (7, 0.039764713), (9, 0.070728965), (14, 0.0684756), (17, 0.03742228), (18, 0.07753681)]"
25723,,2022-03-31 14:42:22,2,41,"<p>We know that we can quantify the degree of irreversibility of a quantum process using the entropy production rate of the same process. But sometimes it seems that the very fact that information has been lost in an irreversible way might be advantageous.</p>
<p>For instance <a href=""https://www.nature.com/articles/s41534-019-0138-y?amp%3Bcode=1983a7e6-8608-41d4-a0fd-c4675c6b4d22"" rel=""nofollow noreferrer"">we know that there is a way in which coherence plays a role in the entropy production</a>, which in itself is a quantity measuring the degree of irreversibility.</p>
<p>Also, we know that some quantum information processing tasks (CHSH game) <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.98.060302"" rel=""nofollow noreferrer"">may depend on the degree of irreversibility in a crucial way</a>.</p>
<p>With all this in mind I wonder if the following exists:</p>
<p><strong>Question:</strong> <em>Is there some resource theory of irreversibility?</em> In particular could be one that strictly mentions entropy production in quantum thermodynamics. Or for instance one that uses the erasure of (quantum) bits of information.</p>
",Is there a resource theory of irreversibility?,<resource-request><resource-theories>,0,0,,,"Is there a resource theory of irreversibility? <p>We know that we can quantify the degree of irreversibility of a quantum process using the entropy production rate of the same process. But sometimes it seems that the very fact that information has been lost in an irreversible way might be advantageous.</p>
<p>For instance <a href=""https://www.nature.com/articles/s41534-019-0138-y?amp%3Bcode=1983a7e6-8608-41d4-a0fd-c4675c6b4d22"" rel=""nofollow noreferrer"">we know that there is a way in which coherence plays a role in the entropy production</a>, which in itself is a quantity measuring the degree of irreversibility.</p>
<p>Also, we know that some quantum information processing tasks (CHSH game) <a href=""https://journals.aps.org/pra/abstract/10.1103/PhysRevA.98.060302"" rel=""nofollow noreferrer"">may depend on the degree of irreversibility in a crucial way</a>.</p>
<p>With all this in mind I wonder if the following exists:</p>
<p><strong>Question:</strong> <em>Is there some resource theory of irreversibility?</em> In particular could be one that strictly mentions entropy production in quantum thermodynamics. Or for instance one that uses the erasure of (quantum) bits of information.</p>
",qc,resource theory irreversibility p know quantify degree irreversibility quantum process using entropy production rate process sometimes seems fact information lost irreversible way might p instance https amp nofollow noreferrer know way coherence plays role entropy production quantity measuring degree p also know quantum information processing tasks chsh game https nofollow noreferrer may depend degree irreversibility crucial way p mind wonder following exists p strong question em resource theory irreversibility particular could one strictly mentions entropy production quantum thermodynamics instance one uses erasure quantum bits,"[(3, 0.14489378), (4, 0.0752131), (5, 0.016714592), (7, 0.0810914), (8, 0.4441964), (9, 0.1317211), (15, 0.014463566), (17, 0.013254325), (18, 0.07702567)]"
25770,25771.0,2022-04-02 18:12:52,2,130,"<p>I am attempting to write a <a href=""https://github.com/liorella-qm/CliffordTableau"" rel=""nofollow noreferrer"">module</a> for composition of Clifford Tableaus using only elementary arithmetic and logical operations. Everything seems to be working fine, except that as far as I understand, the matrices whose columns are the image of each Pauli X/Z operator should be symplectic, namely, pass the test:</p>
<p><span class=""math-container"">$$
g^T\Lambda g = \Lambda
$$</span>
where
<span class=""math-container"">$$
\Lambda = \begin{pmatrix}0 &amp; I_n \\ I_n &amp; 0\end{pmatrix},
$$</span>
and the field is <span class=""math-container"">$\mathbb{F}_2$</span>, namely, I perform all additions and multiplications mod 2.</p>
<p>While single qubit Cliffords do pass this test, e.g, S gate has the tableau:</p>
<pre><code>   |x0 z0
--+------
x0|1  0
z0|1  1
s |0  0
</code></pre>
<p>where <code>s</code> is a sign bit,
which is symplectic. However, when I define the S gate on qubit 1 for a 2 qubit circuit in the following way:</p>
<pre><code>   |x0 z0 x1 z1
--+------------
x0|1  0  0  0
z0|1  1  0  0
x1|0  0  1  0
z1|0  0  0  1
s |0  0  0  0
</code></pre>
<p>it is not symplectic using the test defined above! In all other respects, this gate behaves as expected (e.g when composing it with other gates, the composition gives the expected Clifford, as can be seen in the test file <a href=""https://github.com/liorella-qm/CliffordTableau/blob/master/test_simple_tableau.py"" rel=""nofollow noreferrer"">here</a>.)</p>
<p>So what am I missing here? Which one of my definitions is incorrect?</p>
",why does this definition of multi qubit Clifford Tableaus not pass symplectic test?,<simulation><clifford-group>,2,0,,,"why does this definition of multi qubit Clifford Tableaus not pass symplectic test? <p>I am attempting to write a <a href=""https://github.com/liorella-qm/CliffordTableau"" rel=""nofollow noreferrer"">module</a> for composition of Clifford Tableaus using only elementary arithmetic and logical operations. Everything seems to be working fine, except that as far as I understand, the matrices whose columns are the image of each Pauli X/Z operator should be symplectic, namely, pass the test:</p>
<p><span class=""math-container"">$$
g^T\Lambda g = \Lambda
$$</span>
where
<span class=""math-container"">$$
\Lambda = \begin{pmatrix}0 &amp; I_n \\ I_n &amp; 0\end{pmatrix},
$$</span>
and the field is <span class=""math-container"">$\mathbb{F}_2$</span>, namely, I perform all additions and multiplications mod 2.</p>
<p>While single qubit Cliffords do pass this test, e.g, S gate has the tableau:</p>
<pre><code>   |x0 z0
--+------
x0|1  0
z0|1  1
s |0  0
</code></pre>
<p>where <code>s</code> is a sign bit,
which is symplectic. However, when I define the S gate on qubit 1 for a 2 qubit circuit in the following way:</p>
<pre><code>   |x0 z0 x1 z1
--+------------
x0|1  0  0  0
z0|1  1  0  0
x1|0  0  1  0
z1|0  0  0  1
s |0  0  0  0
</code></pre>
<p>it is not symplectic using the test defined above! In all other respects, this gate behaves as expected (e.g when composing it with other gates, the composition gives the expected Clifford, as can be seen in the test file <a href=""https://github.com/liorella-qm/CliffordTableau/blob/master/test_simple_tableau.py"" rel=""nofollow noreferrer"">here</a>.)</p>
<p>So what am I missing here? Which one of my definitions is incorrect?</p>
",qc,definition multi qubit clifford tableaus pass symplectic test p attempting write https nofollow noreferrer module composition clifford tableaus using elementary arithmetic logical operations everything seems working fine except far understand matrices whose columns image pauli operator symplectic namely pass test p span g span pmatrix 0 amp amp pmatrix field span f namely perform additions multiplications mod p single qubit cliffords pass test gate tableau pre code z0 0 1 0 p code sign bit symplectic however define gate qubit 1 2 qubit circuit following way pre code z0 x1 z1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 p symplectic using test defined respects gate behaves expected composing gates composition gives expected clifford seen test file https nofollow noreferrer p missing one definitions incorrect,"[(2, 0.1905677), (3, 0.16073805), (4, 0.06205423), (5, 0.012827978), (7, 0.04222986), (9, 0.1277805), (12, 0.01588954), (14, 0.2892038), (15, 0.048199385), (17, 0.017285379), (18, 0.024193339)]"
25784,,2022-04-03 21:11:24,1,91,"<p>I have some issues using keras-rl2 with tensorflow_quantum and VQC (using identical architecture as <a href=""https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning"" rel=""nofollow noreferrer"">https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning</a>)</p>
<p><strong>After the creation of the model and DqnAgent, in <em>dqn.compile</em>:</strong></p>
<pre><code>   ############################################################
   def generate_model_Qlearning(qubits, n_layers, n_actions, observables, target):

   qubits = cirq.GridQubit.rect(1, n_qubits)
   ops = [cirq.Z(q) for q in qubits]
   observables = [ops[0]*ops[1], ops[2]*ops[3]] # Z_0*Z_1 for 
   action 0 and Z_2*Z_3 for action 1

   input_tensor = tf.keras.Input(shape=(len(qubits), ), 
   dtype=tf.dtypes.float32, name='input')
   re_uploading_pqc = ReUploadingPQC(qubits, n_layers, 
           observables, activation='tanh')([input_tensor])
   process = tf.keras.Sequential(
             [Rescaling(len(observables))], 
              name=target*&quot;Target&quot;+&quot;Q-values&quot;
             )
   Q_values = process(re_uploading_pqc)
   model = tf.keras.Model(inputs=[input_tensor], 
                          outputs=Q_values)

   return model

   ############################################################

   model = generate_model_Qlearning(qubits, n_layers, n_actions, 
                observables, False)
   model_target = generate_model_Qlearning(qubits, n_layers, 
                n_actions, observables, True)

   model_target.set_weights(model.get_weights())
  

   dqn = DQNAgent(model=model, enable_double_dqn = True, 
                  nb_actions=num_actions, 

   dqn.compile(Adam(learning_rate=1e-3), metrics=['mae'])

   history = dqn.fit(env, nb_steps=50000, visualize=False, 
             verbose=2)
</code></pre>
<p><strong>The following exception appears:</strong></p>
<pre><code>---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
Input In [119], in &lt;module&gt;
----&gt; 1 dqn.compile(Adam(learning_rate=1e-3), metrics=['mae'])
      3 history = dqn.fit(env, nb_steps=50000,
      4 visualize=False,
      5 verbose=2)

File ~.local/lib/python3.8/site-packages/rl/agents/dqn.py:167, in DQNAgent.compile(self, optimizer, metrics)
    164 metrics += [mean_q]  # register default metrics
    166 # We never train the target model, hence we can set the optimizer and loss arbitrarily.
--&gt; 167 **self.target_model = clone_model(self.model, self.custom_model_objects)**
    168 self.target_model.compile(optimizer='sgd', loss='mse')
    169 self.model.compile(optimizer='sgd', loss='mse')

File ~.local/lib/python3.8/site-packages/rl/util.py:13, in clone_model(model, custom_objects)
      9 def clone_model(model, custom_objects={}):
     10     # Requires Keras 1.0.7 since get_config has breaking changes.
     11     config = {
     12         'class_name': model.__class__.__name__,
---&gt; 13         **'config': model.get_config(),**
     14     }
     15     clone = model_from_config(config, custom_objects=custom_objects)
     16     clone.set_weights(model.get_weights())

File ~.local/lib/python3.8/site-packages/keras/engine/functional.py:685, in Functional.get_config(self)
    684 def get_config(self):
--&gt; 685   return copy.deepcopy(get_network_config(self))

File ~.local/lib/python3.8/site-packages/keras/engine/functional.py:1410, in get_network_config(network, serialize_layer_fn)
   1407     node_data = node.serialize(_make_node_key, node_conversion_map)
   1408     filtered_inbound_nodes.append(node_data)
-&gt; 1410 layer_config = serialize_layer_fn(layer)
   1411 layer_config['name'] = layer.name
   1412 layer_config['inbound_nodes'] = filtered_inbound_nodes

File ~.local/lib/python3.8/site-packages/keras/utils/generic_utils.py:510, in serialize_keras_object(instance)
    507   if _SKIP_FAILED_SERIALIZATION:
    508     return serialize_keras_class_and_config(
    509         name, {_LAYER_UNDEFINED_CONFIG_KEY: True})
--&gt; 510   raise e
    511 serialization_config = {}
    512 for key, item in config.items():

File ~.local/lib/python3.8/site-packages/keras/utils/generic_utils.py:505, in serialize_keras_object(instance)
    503 name = get_registered_name(instance.__class__)
    504 try:
--&gt; 505   config = instance.get_config()
    506 except NotImplementedError as e:
    507   if _SKIP_FAILED_SERIALIZATION:

File ~.local/lib/python3.8/site-packages/keras/engine/base_layer_v1.py:497, in Layer.get_config(self)
    494 # Check that either the only argument in the `__init__` is  `self`,
    495 # or that `get_config` has been overridden:
    496 if len(extra_args) &gt; 1 and hasattr(self.get_config, '_is_default'):
--&gt; 497   raise NotImplementedError('Layers with arguments in `__init__` must '
    498                             'override `get_config`.')
    499 return config

NotImplementedError: Layers with arguments in `__init__` must override `get_config`.
</code></pre>
<p><strong>the topology:</strong></p>
<p><a href=""https://i.sstatic.net/jIEak.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jIEak.png"" alt=""enter image description here"" /></a></p>
<p>It could be great if this library let us specify the dqn_target instead of doing Clone.
Because working with hybrid neural networks with a cirquit with parameters in a layer, it's difficult to serialize it. So, when it runs the line: <strong>model.get_config()</strong>, it fails.</p>
<p>Any idea to solve it?</p>
<p>Thanks!</p>
",keras agents fails in DQNAgent using PQC during clonation for target,<programming><quantum-enhanced-machine-learning><tfq>,0,0,,,"keras agents fails in DQNAgent using PQC during clonation for target <p>I have some issues using keras-rl2 with tensorflow_quantum and VQC (using identical architecture as <a href=""https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning"" rel=""nofollow noreferrer"">https://www.tensorflow.org/quantum/tutorials/quantum_reinforcement_learning</a>)</p>
<p><strong>After the creation of the model and DqnAgent, in <em>dqn.compile</em>:</strong></p>
<pre><code>   ############################################################
   def generate_model_Qlearning(qubits, n_layers, n_actions, observables, target):

   qubits = cirq.GridQubit.rect(1, n_qubits)
   ops = [cirq.Z(q) for q in qubits]
   observables = [ops[0]*ops[1], ops[2]*ops[3]] # Z_0*Z_1 for 
   action 0 and Z_2*Z_3 for action 1

   input_tensor = tf.keras.Input(shape=(len(qubits), ), 
   dtype=tf.dtypes.float32, name='input')
   re_uploading_pqc = ReUploadingPQC(qubits, n_layers, 
           observables, activation='tanh')([input_tensor])
   process = tf.keras.Sequential(
             [Rescaling(len(observables))], 
              name=target*&quot;Target&quot;+&quot;Q-values&quot;
             )
   Q_values = process(re_uploading_pqc)
   model = tf.keras.Model(inputs=[input_tensor], 
                          outputs=Q_values)

   return model

   ############################################################

   model = generate_model_Qlearning(qubits, n_layers, n_actions, 
                observables, False)
   model_target = generate_model_Qlearning(qubits, n_layers, 
                n_actions, observables, True)

   model_target.set_weights(model.get_weights())
  

   dqn = DQNAgent(model=model, enable_double_dqn = True, 
                  nb_actions=num_actions, 

   dqn.compile(Adam(learning_rate=1e-3), metrics=['mae'])

   history = dqn.fit(env, nb_steps=50000, visualize=False, 
             verbose=2)
</code></pre>
<p><strong>The following exception appears:</strong></p>
<pre><code>---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
Input In [119], in &lt;module&gt;
----&gt; 1 dqn.compile(Adam(learning_rate=1e-3), metrics=['mae'])
      3 history = dqn.fit(env, nb_steps=50000,
      4 visualize=False,
      5 verbose=2)

File ~.local/lib/python3.8/site-packages/rl/agents/dqn.py:167, in DQNAgent.compile(self, optimizer, metrics)
    164 metrics += [mean_q]  # register default metrics
    166 # We never train the target model, hence we can set the optimizer and loss arbitrarily.
--&gt; 167 **self.target_model = clone_model(self.model, self.custom_model_objects)**
    168 self.target_model.compile(optimizer='sgd', loss='mse')
    169 self.model.compile(optimizer='sgd', loss='mse')

File ~.local/lib/python3.8/site-packages/rl/util.py:13, in clone_model(model, custom_objects)
      9 def clone_model(model, custom_objects={}):
     10     # Requires Keras 1.0.7 since get_config has breaking changes.
     11     config = {
     12         'class_name': model.__class__.__name__,
---&gt; 13         **'config': model.get_config(),**
     14     }
     15     clone = model_from_config(config, custom_objects=custom_objects)
     16     clone.set_weights(model.get_weights())

File ~.local/lib/python3.8/site-packages/keras/engine/functional.py:685, in Functional.get_config(self)
    684 def get_config(self):
--&gt; 685   return copy.deepcopy(get_network_config(self))

File ~.local/lib/python3.8/site-packages/keras/engine/functional.py:1410, in get_network_config(network, serialize_layer_fn)
   1407     node_data = node.serialize(_make_node_key, node_conversion_map)
   1408     filtered_inbound_nodes.append(node_data)
-&gt; 1410 layer_config = serialize_layer_fn(layer)
   1411 layer_config['name'] = layer.name
   1412 layer_config['inbound_nodes'] = filtered_inbound_nodes

File ~.local/lib/python3.8/site-packages/keras/utils/generic_utils.py:510, in serialize_keras_object(instance)
    507   if _SKIP_FAILED_SERIALIZATION:
    508     return serialize_keras_class_and_config(
    509         name, {_LAYER_UNDEFINED_CONFIG_KEY: True})
--&gt; 510   raise e
    511 serialization_config = {}
    512 for key, item in config.items():

File ~.local/lib/python3.8/site-packages/keras/utils/generic_utils.py:505, in serialize_keras_object(instance)
    503 name = get_registered_name(instance.__class__)
    504 try:
--&gt; 505   config = instance.get_config()
    506 except NotImplementedError as e:
    507   if _SKIP_FAILED_SERIALIZATION:

File ~.local/lib/python3.8/site-packages/keras/engine/base_layer_v1.py:497, in Layer.get_config(self)
    494 # Check that either the only argument in the `__init__` is  `self`,
    495 # or that `get_config` has been overridden:
    496 if len(extra_args) &gt; 1 and hasattr(self.get_config, '_is_default'):
--&gt; 497   raise NotImplementedError('Layers with arguments in `__init__` must '
    498                             'override `get_config`.')
    499 return config

NotImplementedError: Layers with arguments in `__init__` must override `get_config`.
</code></pre>
<p><strong>the topology:</strong></p>
<p><a href=""https://i.sstatic.net/jIEak.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jIEak.png"" alt=""enter image description here"" /></a></p>
<p>It could be great if this library let us specify the dqn_target instead of doing Clone.
Because working with hybrid neural networks with a cirquit with parameters in a layer, it's difficult to serialize it. So, when it runs the line: <strong>model.get_config()</strong>, it fails.</p>
<p>Any idea to solve it?</p>
<p>Thanks!</p>
",qc,keras agents fails dqnagent using pqc clonation target p issues using vqc using identical architecture https nofollow noreferrer https p strong creation model dqnagent em pre code def qubits observables target qubits 1 ops q q qubits observables ops 0 ops 1 ops 2 ops 3 action 0 action 1 len qubits reuploadingpqc qubits observables process rescaling len observables quot target quot quot quot process model return model model qubits observables false qubits observables true dqn dqnagent true adam history env p strong following exception appears pre code notimplementederror traceback recent call last input 119 lt module gt gt 1 adam 3 history env 4 5 file self optimizer metrics 164 metrics register default metrics 166 never train target model hence set optimizer loss arbitrarily gt 167 168 169 file model 9 def model 10 requires keras since breaking changes 11 config 12 gt 13 14 15 clone config 16 file self 684 def self gt 685 return self file network 1407 1408 gt 1410 layer 1411 1412 file instance 507 508 return 509 name true gt 510 raise e 511 512 key item file instance 503 name 504 try gt 505 config 506 except notimplementederror e 507 file self 494 check either argument self 495 overridden 496 len gt 1 hasattr gt 497 raise notimplementederror arguments must 498 499 return config notimplementederror layers arguments must override p strong topology p https nofollow noreferrer img https enter image description p could great library let us specify instead clone working hybrid neural networks cirquit parameters layer difficult serialize runs line strong p idea solve p thanks,"[(0, 0.27419922), (4, 0.081373304), (6, 0.10530785), (8, 0.06672907), (9, 0.025629133), (14, 0.15697521), (17, 0.027243111), (19, 0.25252354)]"
25788,,2022-04-04 13:46:51,2,256,"<p>I know a <a href=""https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule#psi4.core.Molecule.nuclear_repulsion_energy_deriv1"" rel=""nofollow noreferrer"">function</a> in PSI4 computing a nuclear repulsion energy derivative located in <a href=""https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule#psi4.core.Molecule"" rel=""nofollow noreferrer"">psi4.core.Molecule</a>.</p>
<p>Is there a possibility to access such function from Qiskit interface? By this &quot;interface&quot; I mean mostly classes <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.drivers.Molecule.html"" rel=""nofollow noreferrer"">Molecule</a>, <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.html"" rel=""nofollow noreferrer"">ElectronicStructureProblem</a> and <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.drivers.second_quantization.ElectronicStructureMoleculeDriver.html"" rel=""nofollow noreferrer"">ElectronicStructureMoleculeDriver</a>. I need this functionality to solve my problem, while I'd much prefer to stick with the general interface enabling me to use different molecule drivers (PySCF, Gaussian...), then to depend solely on PSI4. On the other hand, I don't want to write it completely by myself, if possible, to prevent redundancy in the code.</p>
",Qiskit - nuclear repulsion energy derivative,<qiskit><programming><chemistry>,1,0,,,"Qiskit - nuclear repulsion energy derivative <p>I know a <a href=""https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule#psi4.core.Molecule.nuclear_repulsion_energy_deriv1"" rel=""nofollow noreferrer"">function</a> in PSI4 computing a nuclear repulsion energy derivative located in <a href=""https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule#psi4.core.Molecule"" rel=""nofollow noreferrer"">psi4.core.Molecule</a>.</p>
<p>Is there a possibility to access such function from Qiskit interface? By this &quot;interface&quot; I mean mostly classes <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.drivers.Molecule.html"" rel=""nofollow noreferrer"">Molecule</a>, <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.html"" rel=""nofollow noreferrer"">ElectronicStructureProblem</a> and <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.drivers.second_quantization.ElectronicStructureMoleculeDriver.html"" rel=""nofollow noreferrer"">ElectronicStructureMoleculeDriver</a>. I need this functionality to solve my problem, while I'd much prefer to stick with the general interface enabling me to use different molecule drivers (PySCF, Gaussian...), then to depend solely on PSI4. On the other hand, I don't want to write it completely by myself, if possible, to prevent redundancy in the code.</p>
",qc,qiskit nuclear repulsion energy derivative p know https nofollow noreferrer function psi4 computing nuclear repulsion energy derivative located https nofollow noreferrer p possibility access function qiskit interface quot interface quot mean mostly classes https nofollow noreferrer molecule https nofollow noreferrer electronicstructureproblem https nofollow noreferrer electronicstructuremoleculedriver need functionality solve problem much prefer stick general interface enabling use different molecule drivers pyscf gaussian depend solely psi4 hand want write completely possible prevent redundancy,"[(1, 0.09986425), (4, 0.3421159), (7, 0.03877708), (8, 0.26229584), (14, 0.11490532), (17, 0.0490107), (19, 0.090971395)]"
25909,26094.0,2022-04-11 13:04:53,4,393,"<p>I'm looking at cross-entropy benchmarks and there's much that I'm reading at the moment but I'm stuck on one detail: how to derive the linear cross-entropy formula from the cross-entropy formula.</p>
<p>The cross-entropy of probability densities <span class=""math-container"">$p(x)$</span> and <span class=""math-container"">$q(x)$</span> over <span class=""math-container"">$D=2^N$</span> possible values of <span class=""math-container"">$x\in \{0,1\}^N$</span> is given by</p>
<p><span class=""math-container"">$$ -\sum^D q(x) \log p(x) $$</span></p>
<p>I took the linearization of the log function <span class=""math-container"">$\log (x) = x-1$</span> in an attempt to get the linear cross entropy (following the derivation of <a href=""https://en.wikipedia.org/wiki/Purity_(quantum_mechanics)#Linear_entropy"" rel=""nofollow noreferrer"">Linear entropy</a>). As the linearization, I obtain</p>
<p><span class=""math-container"">$$
-\sum^D q(x) (p(x) -1) = 1 -\sum^D q(x) p(x)
$$</span></p>
<p>In both &quot;Quantum supremacy using a programmable superconducting processor&quot; and &quot;Limitations of Linear Cross-Entropy as a Measure for Quantum Advantage&quot; [arXiv:2112.01657] the linear cross-entropy is given as</p>
<p><span class=""math-container"">$$D\sum_{x}^{D} q(x) p(x) -1$$</span></p>
<ol>
<li><p>I have no idea why my sign is off and where the pre-factor of <span class=""math-container"">$D$</span> comes from. I can recover the linear XEB formula if <span class=""math-container"">$\log(p(x))\approx 1-D p(x)$</span>. However, I don't know how I can get the factor of <span class=""math-container"">$D$</span> to appear in any sensible approximation.</p>
</li>
<li><p>I tested some numerics and the XE and the linear XE do not appear to follow the same trends. I did an interpolation from <span class=""math-container"">$q_{s=0} = p$</span> to <span class=""math-container"">$q_{s=1}=unif$</span> in five steps and found that the XE increases as <span class=""math-container"">$q$</span> is further from <span class=""math-container"">$p$</span> while the linear XEB decreases to zero as <span class=""math-container"">$q$</span> approaches the uniform distribution. I think this is correct but I'm lost on the intuition/understanding of how the XE and linear XE are connected.</p>
</li>
</ol>
<pre><code>import numpy as np

#fix seed
np.random.seed(0)

#qubits
n=10

#from Google notation
D=2**n
#print(D)

#print(&quot;Randomly choosen \ket p in basis \e&quot;)
#print(p)

#distro p 
p = np.random.rand(D)
p = p / sum(p)

#distro q_s = (1-s) \ket p + s \ket Delta
Delta = np.random.rand(D)
Delta = Delta / sum(Delta)

#sharp
peaked = np.zeros(D)
peaked[np.random.randint(D)] =1.0

#unif
unif = np.ones(D)
unif = unif / sum(unif)


def getq(s,qmax=unif):
    &quot;&quot;&quot;get q for a given mixing parameter s&quot;&quot;&quot;
    if s&gt;1:
        s=1
    if s&lt;0:
        s=0
    return (1-s) * p + (s) * qmax

def xel(p,q):
    &quot;&quot;&quot;linear cross entropy of two distributions&quot;&quot;&quot;
    
    #sum 
    S=0
    
    for k in range(len(p)):
        S= S + (p[k] * q[k])
    
    return D*S -1


def xe(p,q):
    &quot;&quot;&quot;cross entropy&quot;&quot;&quot;
    #sum
    S=0
    
    for k in range(len(p)):
        if q[k]==0:
            continue
        
        S = S - q[k] * np.log(p[k])
    
    return S

def S(p):
    &quot;&quot;&quot; Entropy of probability density vector &quot;&quot;&quot;
    #entropy 
    S=0
    
    for k in range(len(p)):
        if p[k]==0:
            continue
        
        S = S - p[k]* np.log(p[k])
    
    return S

def purity(p):
    &quot;&quot;&quot; linear entropy &quot;&quot;&quot;
    #sum
    S = 0
    
    for k in range(len(p)):
        S = S + p[k]*(p[k]-1)
        
    return S    


print(&quot;Entropy of \ket p&quot;, S(p))
print(&quot;Purity of \ket p&quot;,purity(p))
print(&quot; &quot;)
print(&quot;Entropy of \ket q_max&quot;,S(getq(1,qmax)))
print(&quot;Purity of \ket q_max&quot;,purity(getq(1)))
print(&quot; &quot;)

print(&quot;purity max&quot;, purity(unif))

svals = np.linspace(0,1,5)
for s in svals:
        print(&quot;  s=&quot;,s)
        q= getq(s,qmax)
        
        print(&quot;xel_pq&quot;,xel(p,q))
        print(&quot;xe_pq&quot;,xe(p,q))
        
        #print(&quot;xel_qp&quot;,xel(q,p))
        #print(&quot;xe_qp&quot;,xe(q,p))
                
        print(&quot; &quot;)
</code></pre>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>s</th>
<th>xel_pq</th>
<th>xe_pq</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0</td>
<td>0.3448222395967324</td>
<td>6.734095320988952</td>
</tr>
<tr>
<td>0.25</td>
<td>0.25861667969755</td>
<td>6.860293267333703</td>
</tr>
<tr>
<td>0.5</td>
<td>0.17241111979836532</td>
<td>6.9864912136784465</td>
</tr>
<tr>
<td>0.75</td>
<td>0.08620555989918333</td>
<td>7.112689160023204</td>
</tr>
<tr>
<td>1.0</td>
<td>1.9984014443252818e-15</td>
<td>7.238887106367953</td>
</tr>
</tbody>
</table>
</div>",Derivation of the linear cross entropy,<information-theory><entropy><quantum-advantage>,2,0,,,"Derivation of the linear cross entropy <p>I'm looking at cross-entropy benchmarks and there's much that I'm reading at the moment but I'm stuck on one detail: how to derive the linear cross-entropy formula from the cross-entropy formula.</p>
<p>The cross-entropy of probability densities <span class=""math-container"">$p(x)$</span> and <span class=""math-container"">$q(x)$</span> over <span class=""math-container"">$D=2^N$</span> possible values of <span class=""math-container"">$x\in \{0,1\}^N$</span> is given by</p>
<p><span class=""math-container"">$$ -\sum^D q(x) \log p(x) $$</span></p>
<p>I took the linearization of the log function <span class=""math-container"">$\log (x) = x-1$</span> in an attempt to get the linear cross entropy (following the derivation of <a href=""https://en.wikipedia.org/wiki/Purity_(quantum_mechanics)#Linear_entropy"" rel=""nofollow noreferrer"">Linear entropy</a>). As the linearization, I obtain</p>
<p><span class=""math-container"">$$
-\sum^D q(x) (p(x) -1) = 1 -\sum^D q(x) p(x)
$$</span></p>
<p>In both &quot;Quantum supremacy using a programmable superconducting processor&quot; and &quot;Limitations of Linear Cross-Entropy as a Measure for Quantum Advantage&quot; [arXiv:2112.01657] the linear cross-entropy is given as</p>
<p><span class=""math-container"">$$D\sum_{x}^{D} q(x) p(x) -1$$</span></p>
<ol>
<li><p>I have no idea why my sign is off and where the pre-factor of <span class=""math-container"">$D$</span> comes from. I can recover the linear XEB formula if <span class=""math-container"">$\log(p(x))\approx 1-D p(x)$</span>. However, I don't know how I can get the factor of <span class=""math-container"">$D$</span> to appear in any sensible approximation.</p>
</li>
<li><p>I tested some numerics and the XE and the linear XE do not appear to follow the same trends. I did an interpolation from <span class=""math-container"">$q_{s=0} = p$</span> to <span class=""math-container"">$q_{s=1}=unif$</span> in five steps and found that the XE increases as <span class=""math-container"">$q$</span> is further from <span class=""math-container"">$p$</span> while the linear XEB decreases to zero as <span class=""math-container"">$q$</span> approaches the uniform distribution. I think this is correct but I'm lost on the intuition/understanding of how the XE and linear XE are connected.</p>
</li>
</ol>
<pre><code>import numpy as np

#fix seed
np.random.seed(0)

#qubits
n=10

#from Google notation
D=2**n
#print(D)

#print(&quot;Randomly choosen \ket p in basis \e&quot;)
#print(p)

#distro p 
p = np.random.rand(D)
p = p / sum(p)

#distro q_s = (1-s) \ket p + s \ket Delta
Delta = np.random.rand(D)
Delta = Delta / sum(Delta)

#sharp
peaked = np.zeros(D)
peaked[np.random.randint(D)] =1.0

#unif
unif = np.ones(D)
unif = unif / sum(unif)


def getq(s,qmax=unif):
    &quot;&quot;&quot;get q for a given mixing parameter s&quot;&quot;&quot;
    if s&gt;1:
        s=1
    if s&lt;0:
        s=0
    return (1-s) * p + (s) * qmax

def xel(p,q):
    &quot;&quot;&quot;linear cross entropy of two distributions&quot;&quot;&quot;
    
    #sum 
    S=0
    
    for k in range(len(p)):
        S= S + (p[k] * q[k])
    
    return D*S -1


def xe(p,q):
    &quot;&quot;&quot;cross entropy&quot;&quot;&quot;
    #sum
    S=0
    
    for k in range(len(p)):
        if q[k]==0:
            continue
        
        S = S - q[k] * np.log(p[k])
    
    return S

def S(p):
    &quot;&quot;&quot; Entropy of probability density vector &quot;&quot;&quot;
    #entropy 
    S=0
    
    for k in range(len(p)):
        if p[k]==0:
            continue
        
        S = S - p[k]* np.log(p[k])
    
    return S

def purity(p):
    &quot;&quot;&quot; linear entropy &quot;&quot;&quot;
    #sum
    S = 0
    
    for k in range(len(p)):
        S = S + p[k]*(p[k]-1)
        
    return S    


print(&quot;Entropy of \ket p&quot;, S(p))
print(&quot;Purity of \ket p&quot;,purity(p))
print(&quot; &quot;)
print(&quot;Entropy of \ket q_max&quot;,S(getq(1,qmax)))
print(&quot;Purity of \ket q_max&quot;,purity(getq(1)))
print(&quot; &quot;)

print(&quot;purity max&quot;, purity(unif))

svals = np.linspace(0,1,5)
for s in svals:
        print(&quot;  s=&quot;,s)
        q= getq(s,qmax)
        
        print(&quot;xel_pq&quot;,xel(p,q))
        print(&quot;xe_pq&quot;,xe(p,q))
        
        #print(&quot;xel_qp&quot;,xel(q,p))
        #print(&quot;xe_qp&quot;,xe(q,p))
                
        print(&quot; &quot;)
</code></pre>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>s</th>
<th>xel_pq</th>
<th>xe_pq</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0</td>
<td>0.3448222395967324</td>
<td>6.734095320988952</td>
</tr>
<tr>
<td>0.25</td>
<td>0.25861667969755</td>
<td>6.860293267333703</td>
</tr>
<tr>
<td>0.5</td>
<td>0.17241111979836532</td>
<td>6.9864912136784465</td>
</tr>
<tr>
<td>0.75</td>
<td>0.08620555989918333</td>
<td>7.112689160023204</td>
</tr>
<tr>
<td>1.0</td>
<td>1.9984014443252818e-15</td>
<td>7.238887106367953</td>
</tr>
</tbody>
</table>
</div>",qc,derivation linear cross entropy p looking benchmarks much reading moment stuck one detail derive linear formula p probability densities span p x span q x span possible values span given p span q x p x p took linearization log function span x attempt get linear cross entropy following derivation https nofollow noreferrer linear entropy linearization obtain p span q x p x 1 q x p x p quot quantum supremacy using programmable superconducting processor quot quot limitations linear measure quantum advantage quot linear given p span x q x p x ol li p idea sign span comes recover linear xeb formula span p x p x however know get factor span appear sensible li p tested numerics xe linear xe appear follow trends interpolation span p span five steps found xe increases span q span p linear xeb decreases zero span q approaches uniform distribution think correct lost xe linear xe pre code import numpy np fix seed 0 qubits google notation n print print quot randomly choosen p basis quot print p distro p p p p sum p distro p delta delta delta delta sum delta sharp peaked peaked unif unif unif unif sum unif def getq quot quot quot get q given mixing parameter quot quot quot gt 1 lt 0 return p qmax def xel p q quot quot quot linear cross entropy two distributions quot quot quot sum k range len p p k q k return def xe p q quot quot quot cross entropy quot quot quot sum k range len p q k continue q k p k return def p quot quot quot entropy probability density vector quot quot quot entropy k range len p p k continue p k p k return def purity p quot quot quot linear entropy quot quot quot sum 0 k range len p p k p k return print quot entropy p quot p print quot purity p quot purity p print quot quot print quot entropy quot getq 1 qmax print quot purity quot purity getq 1 print quot quot print quot purity max quot purity unif svals svals print quot quot getq qmax print quot quot xel p q print quot quot xe p q print quot quot xel q p print quot quot xe q p print quot quot div table thead tr th th th tbody tr td td td tr td td td tr td td td tr td td td tr td td td,"[(0, 0.13155131), (3, 0.37086165), (5, 0.010660339), (7, 0.03700625), (8, 0.025473982), (10, 0.115105085), (17, 0.07315019), (19, 0.21444684)]"
25910,25912.0,2022-04-11 13:33:52,5,401,"<p>Consider a quantum channel <span class=""math-container"">$\Phi$</span> that maps from density operators <span class=""math-container"">$\mathcal{S}(\mathcal{H}_A)$</span> to itself, that commutes with any unitary channel <span class=""math-container"">$\mathcal{U}$</span> on <span class=""math-container"">$\mathcal{S}(\mathcal{H}_A)$</span>, i.e. <span class=""math-container"">$\Phi(\mathcal{U}(\rho))=\mathcal{U}(\Phi(\rho)),\,\,\forall\rho\in\mathcal{S}(\mathcal{H}_A)$</span>.</p>
<p>Is there a general characterisation of such channels? (As far as I can think of it, <span class=""math-container"">$\Phi$</span> can either be a unitary channel or a depolarization channel. What are the other possibilities?)</p>
",Quantum channels that commute with any unitary channel,<quantum-operation><unitarity>,1,3,,,"Quantum channels that commute with any unitary channel <p>Consider a quantum channel <span class=""math-container"">$\Phi$</span> that maps from density operators <span class=""math-container"">$\mathcal{S}(\mathcal{H}_A)$</span> to itself, that commutes with any unitary channel <span class=""math-container"">$\mathcal{U}$</span> on <span class=""math-container"">$\mathcal{S}(\mathcal{H}_A)$</span>, i.e. <span class=""math-container"">$\Phi(\mathcal{U}(\rho))=\mathcal{U}(\Phi(\rho)),\,\,\forall\rho\in\mathcal{S}(\mathcal{H}_A)$</span>.</p>
<p>Is there a general characterisation of such channels? (As far as I can think of it, <span class=""math-container"">$\Phi$</span> can either be a unitary channel or a depolarization channel. What are the other possibilities?)</p>
",qc,quantum channels commute unitary channel p consider quantum channel span maps density operators span h commutes unitary channel span u span h span u u h p general characterisation channels far think span either unitary channel depolarization channel possibilities,"[(3, 0.9624827), (17, 0.032924354)]"
25936,,2022-04-12 23:58:15,2,86,"<p>Could anyone recommend some efficiently established packages to simulate Lindblad dynamics? I wrote some codes using numpy to solve the vectorized superoperator equation but it's rather slow.</p>
<hr />
<p>Update: I've tried three methods so far:</p>
<ol>
<li>Superoperator with NumPy</li>
<li>Numerical integrating ode with NumPy</li>
<li>Qutip (implemented with scipy ode)</li>
</ol>
<p>Here are the results (time in s)<br />
number of qubits:  2<br />
Method 0: unitary dynamics for comparison:  0.046922922134399414<br />
Method 1 numpy with vectorization:  0.0637671947479248<br />
Method 2: numpy ode:  1.5916249752044678<br />
Method 3: qutip:  0.4054644823074341</p>
<p>number of qubits:  3<br />
Method 0: unitary dynamics for comparison:  0.026817798614501953<br />
Method 1 numpy with vectorization:  0.278156042098999<br />
Method 2: numpy ode:  2.077683925628662<br />
Method 3: qutip:  0.5400867462158203</p>
<p>number of qubits:  4<br />
Method 0: unitary dynamics for comparison:  0.02422299385070801<br />
Method 1 numpy with vectorization:  4.19312310218811<br />
Method 2: numpy ode:  3.125500202178955<br />
Method 3: qutip:  0.7155057668685914</p>
<p>number of qubits:  5<br />
Method 0: unitary dynamics for comparison:  0.03640482425689697<br />
Method 1 numpy with vectorization:  81.54041790962219<br />
Method 2: numpy ode:  10.018388986587524<br />
Method 3: qutip:  2.1129989862442016</p>
<p>number of qubits:  6<br />
Method 0: unitary dynamics for comparison:  0.09250009059906006<br />
Method 3: qutip:  4.948623609542847</p>
<p>number of qubits:  7<br />
Method 0: unitary dynamics for comparison:  1.1378232717514039</p>
<p>number of qubits:  8<br />
Method 0: unitary dynamics for comparison:  1.9191678524017335</p>
",Recommendation for Efficient Lindblad Simulator Packages,<simulation><resource-request><open-quantum-systems>,0,5,,,"Recommendation for Efficient Lindblad Simulator Packages <p>Could anyone recommend some efficiently established packages to simulate Lindblad dynamics? I wrote some codes using numpy to solve the vectorized superoperator equation but it's rather slow.</p>
<hr />
<p>Update: I've tried three methods so far:</p>
<ol>
<li>Superoperator with NumPy</li>
<li>Numerical integrating ode with NumPy</li>
<li>Qutip (implemented with scipy ode)</li>
</ol>
<p>Here are the results (time in s)<br />
number of qubits:  2<br />
Method 0: unitary dynamics for comparison:  0.046922922134399414<br />
Method 1 numpy with vectorization:  0.0637671947479248<br />
Method 2: numpy ode:  1.5916249752044678<br />
Method 3: qutip:  0.4054644823074341</p>
<p>number of qubits:  3<br />
Method 0: unitary dynamics for comparison:  0.026817798614501953<br />
Method 1 numpy with vectorization:  0.278156042098999<br />
Method 2: numpy ode:  2.077683925628662<br />
Method 3: qutip:  0.5400867462158203</p>
<p>number of qubits:  4<br />
Method 0: unitary dynamics for comparison:  0.02422299385070801<br />
Method 1 numpy with vectorization:  4.19312310218811<br />
Method 2: numpy ode:  3.125500202178955<br />
Method 3: qutip:  0.7155057668685914</p>
<p>number of qubits:  5<br />
Method 0: unitary dynamics for comparison:  0.03640482425689697<br />
Method 1 numpy with vectorization:  81.54041790962219<br />
Method 2: numpy ode:  10.018388986587524<br />
Method 3: qutip:  2.1129989862442016</p>
<p>number of qubits:  6<br />
Method 0: unitary dynamics for comparison:  0.09250009059906006<br />
Method 3: qutip:  4.948623609542847</p>
<p>number of qubits:  7<br />
Method 0: unitary dynamics for comparison:  1.1378232717514039</p>
<p>number of qubits:  8<br />
Method 0: unitary dynamics for comparison:  1.9191678524017335</p>
",qc,recommendation efficient lindblad simulator packages p could anyone recommend efficiently established packages simulate lindblad dynamics wrote codes using numpy solve vectorized superoperator equation rather hr p update tried three methods far ol li superoperator numpy li numerical integrating ode numpy li qutip implemented scipy ode p results time br number qubits 2 br method 0 unitary dynamics comparison br method 1 numpy vectorization br method 2 numpy ode br method 3 qutip p number qubits 3 br method 0 unitary dynamics comparison br method 1 numpy vectorization br method 2 numpy ode br method 3 qutip p number qubits 4 br method 0 unitary dynamics comparison br method 1 numpy vectorization br method 2 numpy ode br method 3 qutip p number qubits 5 br method 0 unitary dynamics comparison br method 1 numpy vectorization br method 2 numpy ode br method 3 qutip p number qubits 6 br method 0 unitary dynamics comparison br method 3 qutip p number qubits 7 br method 0 unitary dynamics comparison p number qubits 8 br method 0 unitary dynamics comparison,"[(0, 0.07964062), (1, 0.034402277), (2, 0.17996146), (6, 0.032584026), (7, 0.30019453), (11, 0.08862155), (13, 0.1956207), (14, 0.035083536), (17, 0.039474078)]"
25987,,2022-04-16 10:21:21,3,1238,"<p>What do you think about the combination of <strong>NTRU Prime</strong> and <strong>X25519 ECDH</strong> in OpenSSH 9.0?</p>
<p>Why is the combination of NTRU Prime and X25519 ECDH in OpenSSH believed to be secure against quantum attacks in the future?</p>
<p>when I talk about one-way encryption in quantum computing
would reflect would i be able to generate 100% solution that would prevent me from causing a quantum computing collision?
We are currently at 99.9% with the current one-way encryption methods, in my opinion?</p>
<p>the current standard password methods have already lost out against the quantum attacks from quantum computing compared to asynchronous encryption methods?</p>
<p>Can i prevent against the 'harvest now, decrypt later' in theory with quantum computing?</p>
<p>I'm going to start a bounty because i need your opinions from</p>
<p><a href=""https://quantumcomputing.stackexchange.com"">https://quantumcomputing.stackexchange.com</a></p>
<p>Report from <a href=""https://www.heise.de/news/OpenSSH-9-0-sichert-Schluesselaustausch-gegen-Angriffe-durch-Quantencomputer-6668694.html"" rel=""nofollow noreferrer"">heise.de</a>:</p>
<p>The encryption of user data using a symmetrical method such as AES with 256 or almost any number of bits is not the real problem in attacks by quantum computers. It's &quot;only&quot; about cracking the exchange of the random key pair generated for this purpose, which has so far been done with a conventional Diffie-Hellman key exchange based on elliptic curves (X25519 ECDH).</p>
<p>This method is considered to be susceptible to quantum cryptographic attacks, even if the current (known) performance – i.e. the number of qubits – of the first quantum computer is far from sufficient.</p>
<p>There are many estimates of how many qubits are needed to crack asymmetric encryption in a timely manner, probably in the range of several thousand qubits.</p>
<p>Where is the current research? Google last year showed off its Sycamore processor with 54 qubits.</p>
<p>The OpenSSH developers, as part of the OpenBSD community, are aware that new implementations may contain bugs. Instead of just using a new algorithm, the OpenSSH developers are combining NTRU with the X25519 ECD, which has been the standard up to now. This is supposed to form a kind of safety net, because the old protection still applies even in the case of unknown security gaps or the secret backdoors of the secret services.</p>
<p><strong>What does that mean in theory? For example, if I have in performance, the number of 10,000 or 100,000 of qubits (that's just the theory!!!) would have
could I crack the asymmetric encryption?</strong></p>
<p><strong>I don't want detailed explanations about these 2 procedures but why the combination should make it safe.</strong></p>
<p>And now back to my question:</p>
<p><strong>Why is the combination of NTRU PRIME and X25519 ECDH in OpenSSH believed to be secure against quantum attacks in the future?</strong></p>
<p>Some links on the topic:</p>
<p><a href=""https://www.zdnet.com/article/openssh-now-defaults-to-protecting-against-quantum-computer-attacks/"" rel=""nofollow noreferrer"">OpenSSH now defaults to protecting against quantum computer attacks</a></p>
<p><a href=""https://www.zdnet.com/article/nato-cybersecurity-center-finishes-tests-of-quantum-proof-network/"" rel=""nofollow noreferrer"">NATO cybersecurity center finishes tests of quantum-proof network</a>/</p>
<p><a href=""https://man7.org/linux/man-pages/man8/cryptsetup.8.html"" rel=""nofollow noreferrer"">cryptsetup(8) — Linux manual page</a></p>
<p><a href=""https://www.openssh.com/releasenotes.html#9.0"" rel=""nofollow noreferrer"">OpenSSH 9.0/9.0p1 (2022-04-08)</a></p>
<p><a href=""https://crypto.stackexchange.com/q/99725/101118"">secret keys that protect the traffic</a></p>
",Why is the combination of NTRU Prime and X25519 ECDH in OpenSSH believed to be secure against quantum attacks?,<programming><quantum-algorithms><cryptography>,1,8,,,"Why is the combination of NTRU Prime and X25519 ECDH in OpenSSH believed to be secure against quantum attacks? <p>What do you think about the combination of <strong>NTRU Prime</strong> and <strong>X25519 ECDH</strong> in OpenSSH 9.0?</p>
<p>Why is the combination of NTRU Prime and X25519 ECDH in OpenSSH believed to be secure against quantum attacks in the future?</p>
<p>when I talk about one-way encryption in quantum computing
would reflect would i be able to generate 100% solution that would prevent me from causing a quantum computing collision?
We are currently at 99.9% with the current one-way encryption methods, in my opinion?</p>
<p>the current standard password methods have already lost out against the quantum attacks from quantum computing compared to asynchronous encryption methods?</p>
<p>Can i prevent against the 'harvest now, decrypt later' in theory with quantum computing?</p>
<p>I'm going to start a bounty because i need your opinions from</p>
<p><a href=""https://quantumcomputing.stackexchange.com"">https://quantumcomputing.stackexchange.com</a></p>
<p>Report from <a href=""https://www.heise.de/news/OpenSSH-9-0-sichert-Schluesselaustausch-gegen-Angriffe-durch-Quantencomputer-6668694.html"" rel=""nofollow noreferrer"">heise.de</a>:</p>
<p>The encryption of user data using a symmetrical method such as AES with 256 or almost any number of bits is not the real problem in attacks by quantum computers. It's &quot;only&quot; about cracking the exchange of the random key pair generated for this purpose, which has so far been done with a conventional Diffie-Hellman key exchange based on elliptic curves (X25519 ECDH).</p>
<p>This method is considered to be susceptible to quantum cryptographic attacks, even if the current (known) performance – i.e. the number of qubits – of the first quantum computer is far from sufficient.</p>
<p>There are many estimates of how many qubits are needed to crack asymmetric encryption in a timely manner, probably in the range of several thousand qubits.</p>
<p>Where is the current research? Google last year showed off its Sycamore processor with 54 qubits.</p>
<p>The OpenSSH developers, as part of the OpenBSD community, are aware that new implementations may contain bugs. Instead of just using a new algorithm, the OpenSSH developers are combining NTRU with the X25519 ECD, which has been the standard up to now. This is supposed to form a kind of safety net, because the old protection still applies even in the case of unknown security gaps or the secret backdoors of the secret services.</p>
<p><strong>What does that mean in theory? For example, if I have in performance, the number of 10,000 or 100,000 of qubits (that's just the theory!!!) would have
could I crack the asymmetric encryption?</strong></p>
<p><strong>I don't want detailed explanations about these 2 procedures but why the combination should make it safe.</strong></p>
<p>And now back to my question:</p>
<p><strong>Why is the combination of NTRU PRIME and X25519 ECDH in OpenSSH believed to be secure against quantum attacks in the future?</strong></p>
<p>Some links on the topic:</p>
<p><a href=""https://www.zdnet.com/article/openssh-now-defaults-to-protecting-against-quantum-computer-attacks/"" rel=""nofollow noreferrer"">OpenSSH now defaults to protecting against quantum computer attacks</a></p>
<p><a href=""https://www.zdnet.com/article/nato-cybersecurity-center-finishes-tests-of-quantum-proof-network/"" rel=""nofollow noreferrer"">NATO cybersecurity center finishes tests of quantum-proof network</a>/</p>
<p><a href=""https://man7.org/linux/man-pages/man8/cryptsetup.8.html"" rel=""nofollow noreferrer"">cryptsetup(8) — Linux manual page</a></p>
<p><a href=""https://www.openssh.com/releasenotes.html#9.0"" rel=""nofollow noreferrer"">OpenSSH 9.0/9.0p1 (2022-04-08)</a></p>
<p><a href=""https://crypto.stackexchange.com/q/99725/101118"">secret keys that protect the traffic</a></p>
",qc,combination ntru prime x25519 ecdh openssh believed secure quantum attacks p think combination strong ntru prime strong x25519 ecdh openssh p combination ntru prime x25519 ecdh openssh believed secure quantum attacks future p talk encryption quantum computing would reflect would able generate 100 solution would prevent causing quantum computing collision currently current encryption methods opinion p current standard password methods already lost quantum attacks quantum computing compared asynchronous encryption methods p prevent decrypt later theory quantum computing p going start bounty need opinions p https https p report https nofollow noreferrer p encryption user data using symmetrical method aes 256 almost number bits real problem attacks quantum computers quot quot cracking exchange random key pair generated purpose far done conventional key exchange based elliptic curves x25519 ecdh p method considered susceptible quantum cryptographic attacks even current known performance number qubits first quantum computer far p many estimates many qubits needed crack asymmetric encryption timely manner probably range several thousand p current research google last year showed sycamore processor 54 p openssh developers part openbsd community aware new implementations may contain bugs instead using new algorithm openssh developers combining ntru x25519 ecd standard supposed form kind safety net old protection still applies even case unknown security gaps secret backdoors secret p strong mean theory example performance number qubits theory would could crack asymmetric encryption p strong want detailed explanations 2 procedures combination make p back question p strong combination ntru prime x25519 ecdh openssh believed secure quantum attacks future p links topic p https nofollow noreferrer openssh defaults protecting quantum computer attacks p https nofollow noreferrer nato cybersecurity center finishes tests network p https nofollow noreferrer cryptsetup 8 linux manual page p https nofollow noreferrer openssh p https secret keys protect traffic,"[(4, 0.10404619), (6, 0.013836402), (7, 0.30462494), (8, 0.41943422), (13, 0.058349714), (14, 0.040829718), (17, 0.015427702), (18, 0.023772676)]"
25995,,2022-04-17 00:32:53,0,179,"<p>I am trying to replicate the results from this webpage here utilizing qiskit:</p>
<p><a href=""http://twistedoakstudios.com/blog/Post6536_implementing-quantum-pseudo-telepathy"" rel=""nofollow noreferrer"">http://twistedoakstudios.com/blog/Post6536_implementing-quantum-pseudo-telepathy</a></p>
<p>Since the splitter gate mentioned in the article is a custom gate they are using, I had to recreate it using the unitary function like so:</p>
<pre><code>splitter = [[1/sqrt(2), 1.j/sqrt(2)],
            [1.j/sqrt(2), 1/sqrt(2)]]

#to place the gate in qiskit

qc = QuantumCircuit(4)

qc.unitary(splitter, [0])
</code></pre>
<p>I tried to re-create the results of the example scenario (under the section &quot;playing the game&quot; where Alice is given the bottom row and Bob is given the center column). Here is a pic of the circuit:</p>
<p><a href=""https://i.sstatic.net/N88ep.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/N88ep.png"" alt=""enter image description here"" /></a></p>
<p>And these are results I get are the following histogram:</p>
<p><a href=""https://i.sstatic.net/IEamL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IEamL.png"" alt=""enter image description here"" /></a></p>
<p>Now, these results DO make sense if you interpret them as {Bob top, Bob center, Alice center, Alice left}. For example, if they measured the qubits and they collapsed into 1000, then that means Bob will place one token at the top and one token at the bottom slots (since there's a 0 in the center slot, the remaining token must go in the bottom slot), and Alice places no tokens (since she has 2 zeroes). This would beat the game.</p>
<p>However, I ran the same program, but this time testing when Alice gets the top row and Bob gets the left column. The resulting circuit looks like this:</p>
<p><a href=""https://i.sstatic.net/qzdoI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qzdoI.png"" alt=""enter image description here"" /></a></p>
<p>And the histogram looks like this:</p>
<p><a href=""https://i.sstatic.net/5mykG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5mykG.png"" alt=""enter image description here"" /></a></p>
<p>Assuming that we read the results the same way, these numbers suddenly fail. For example, 0100 fails because this means Bob places a token in the center and at the bottom while Alice places no tokens, meaning no one placed any tokens at the intersecting spot.</p>
<p>What, if anything, am I doing wrong?</p>
",Trouble re-creating quantum pseudo-telepathy,<qiskit><entanglement>,1,0,,,"Trouble re-creating quantum pseudo-telepathy <p>I am trying to replicate the results from this webpage here utilizing qiskit:</p>
<p><a href=""http://twistedoakstudios.com/blog/Post6536_implementing-quantum-pseudo-telepathy"" rel=""nofollow noreferrer"">http://twistedoakstudios.com/blog/Post6536_implementing-quantum-pseudo-telepathy</a></p>
<p>Since the splitter gate mentioned in the article is a custom gate they are using, I had to recreate it using the unitary function like so:</p>
<pre><code>splitter = [[1/sqrt(2), 1.j/sqrt(2)],
            [1.j/sqrt(2), 1/sqrt(2)]]

#to place the gate in qiskit

qc = QuantumCircuit(4)

qc.unitary(splitter, [0])
</code></pre>
<p>I tried to re-create the results of the example scenario (under the section &quot;playing the game&quot; where Alice is given the bottom row and Bob is given the center column). Here is a pic of the circuit:</p>
<p><a href=""https://i.sstatic.net/N88ep.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/N88ep.png"" alt=""enter image description here"" /></a></p>
<p>And these are results I get are the following histogram:</p>
<p><a href=""https://i.sstatic.net/IEamL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IEamL.png"" alt=""enter image description here"" /></a></p>
<p>Now, these results DO make sense if you interpret them as {Bob top, Bob center, Alice center, Alice left}. For example, if they measured the qubits and they collapsed into 1000, then that means Bob will place one token at the top and one token at the bottom slots (since there's a 0 in the center slot, the remaining token must go in the bottom slot), and Alice places no tokens (since she has 2 zeroes). This would beat the game.</p>
<p>However, I ran the same program, but this time testing when Alice gets the top row and Bob gets the left column. The resulting circuit looks like this:</p>
<p><a href=""https://i.sstatic.net/qzdoI.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qzdoI.png"" alt=""enter image description here"" /></a></p>
<p>And the histogram looks like this:</p>
<p><a href=""https://i.sstatic.net/5mykG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5mykG.png"" alt=""enter image description here"" /></a></p>
<p>Assuming that we read the results the same way, these numbers suddenly fail. For example, 0100 fails because this means Bob places a token in the center and at the bottom while Alice places no tokens, meaning no one placed any tokens at the intersecting spot.</p>
<p>What, if anything, am I doing wrong?</p>
",qc,trouble quantum p trying replicate results webpage utilizing qiskit p http nofollow noreferrer http p since splitter gate mentioned article custom gate using recreate using unitary function like pre code splitter 2 2 2 2 place gate qiskit qc quantumcircuit 4 splitter 0 p tried results example scenario section quot playing game quot alice given bottom row bob given center column pic circuit p https nofollow noreferrer img https enter image description p results get following histogram p https nofollow noreferrer img https enter image description p results make sense interpret bob top bob center alice center alice left example measured qubits collapsed 1000 means bob place one token top one token bottom slots since 0 center slot remaining token must go bottom slot alice places tokens since 2 zeroes would beat p however ran program time testing alice gets top row bob gets left column resulting circuit looks like p https nofollow noreferrer img https enter image description p histogram looks like p https nofollow noreferrer img https enter image description p assuming read results way numbers suddenly fail example 0100 fails means bob places token center bottom alice places tokens meaning one placed tokens intersecting p anything wrong,"[(2, 0.034913253), (4, 0.3626228), (9, 0.114768654), (13, 0.12597641), (14, 0.15701163), (17, 0.01288794), (18, 0.15717255), (19, 0.034018733)]"
26011,,2022-04-18 07:00:49,0,655,"<p>I have tried to run Shor's algorithm using IBM high performance simulator. I
am currently using <code>QuantumInstance</code> to factorize a number. The code is provided below:</p>
<pre><code>from qiskit import *

IBMQ.save_account('&lt;My API String&gt;')
IBMQ.load_account()

from qiskit.tools.monitor import job_monitor
from qiskit.utils import QuantumInstance
from qiskit.algorithms import Shor

N=63
provider = IBMQ.get_provider('ibm-q')
sim = provider.backends.ibmq_qasm_simulator
quantum_instance = QuantumInstance(sim, shots=1024)
shor = Shor(quantum_instance=quantum_instance)
job_monitor(shor, interval=2)
rslt = shor.factor(N)
hsl = rslt.factors[0]
print(&quot;Factor result: &quot;+str(hsl))
</code></pre>
<p>And it is giving me this error:</p>
<pre><code>configrc.store_credentials:WARNING:2022-04-18 13:49:09,225: Credentials already present. Set overwrite=True to overwrite.
Traceback (most recent call last):
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\session.py&quot;, line 278, in request
    response.raise_for_status()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\requests\models.py&quot;, line 960, in raise_for_status
    raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File &quot;D:\Python\test_shor_2_cloud.py&quot;, line 4, in &lt;module&gt;
    IBMQ.load_account()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py&quot;, line 191, in load_account
    self._initialize_providers(credentials, preferences)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py&quot;, line 456, in _initialize_providers
    auth_client = AuthClient(credentials.token,
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\clients\auth.py&quot;, line 41, in __init__
    self.base_api = self._init_service_clients(**request_kwargs)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\clients\auth.py&quot;, line 53, in _init_service_clients     
    access_token = self._request_access_token()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\clients\auth.py&quot;, line 75, in _request_access_token     
    response = self.auth_api.login(self.api_token)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py&quot;, line 125, in login
    return self.session.post(url, json={'apiToken': api_token}).json()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\requests\sessions.py&quot;, line 577, in post
    return self.request('POST', url, data=data, json=json, **kwargs)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\session.py&quot;, line 300, in request
    raise RequestsApiError(message, status_code) from ex
qiskit.providers.ibmq.api.exceptions.RequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'
</code></pre>
<p>Any suggestion?</p>
",How to run Quantum Instance into ibmq_qasm_simulator,<ibm-q-experience><shors-algorithm>,1,2,,,"How to run Quantum Instance into ibmq_qasm_simulator <p>I have tried to run Shor's algorithm using IBM high performance simulator. I
am currently using <code>QuantumInstance</code> to factorize a number. The code is provided below:</p>
<pre><code>from qiskit import *

IBMQ.save_account('&lt;My API String&gt;')
IBMQ.load_account()

from qiskit.tools.monitor import job_monitor
from qiskit.utils import QuantumInstance
from qiskit.algorithms import Shor

N=63
provider = IBMQ.get_provider('ibm-q')
sim = provider.backends.ibmq_qasm_simulator
quantum_instance = QuantumInstance(sim, shots=1024)
shor = Shor(quantum_instance=quantum_instance)
job_monitor(shor, interval=2)
rslt = shor.factor(N)
hsl = rslt.factors[0]
print(&quot;Factor result: &quot;+str(hsl))
</code></pre>
<p>And it is giving me this error:</p>
<pre><code>configrc.store_credentials:WARNING:2022-04-18 13:49:09,225: Credentials already present. Set overwrite=True to overwrite.
Traceback (most recent call last):
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\session.py&quot;, line 278, in request
    response.raise_for_status()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\requests\models.py&quot;, line 960, in raise_for_status
    raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File &quot;D:\Python\test_shor_2_cloud.py&quot;, line 4, in &lt;module&gt;
    IBMQ.load_account()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py&quot;, line 191, in load_account
    self._initialize_providers(credentials, preferences)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py&quot;, line 456, in _initialize_providers
    auth_client = AuthClient(credentials.token,
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\clients\auth.py&quot;, line 41, in __init__
    self.base_api = self._init_service_clients(**request_kwargs)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\clients\auth.py&quot;, line 53, in _init_service_clients     
    access_token = self._request_access_token()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\clients\auth.py&quot;, line 75, in _request_access_token     
    response = self.auth_api.login(self.api_token)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py&quot;, line 125, in login
    return self.session.post(url, json={'apiToken': api_token}).json()
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\requests\sessions.py&quot;, line 577, in post
    return self.request('POST', url, data=data, json=json, **kwargs)
  File &quot;C:\Users\LENOVO\AppData\Local\Programs\Python\Python310\lib\site-packages\qiskit\providers\ibmq\api\session.py&quot;, line 300, in request
    raise RequestsApiError(message, status_code) from ex
qiskit.providers.ibmq.api.exceptions.RequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'
</code></pre>
<p>Any suggestion?</p>
",qc,run quantum instance p tried run shor algorithm using ibm high performance simulator currently using code quantuminstance factorize number code provided pre code qiskit import lt api string gt import import quantuminstance import shor provider sim quantuminstance sim shor shor shor rslt n hsl 0 print quot factor result quot hsl p giving error pre code credentials already present set overwrite traceback recent call last file quot c quot line 278 request file quot c quot line 960 raise httperror 401 client error unauthorized url https exception direct cause following exception traceback recent call last file quot quot line 4 lt module gt file quot c quot line 191 credentials preferences file quot c quot line 456 authclient file quot c quot line 41 file quot c quot line 53 file quot c quot line 75 response file quot c quot line 125 login return url file quot c quot line 577 post return url kwargs file quot c quot line 300 request raise requestsapierror message ex client error unauthorized url https login error code 3446 p suggestion,"[(0, 0.38840175), (4, 0.028315911), (7, 0.058293846), (15, 0.014044014), (17, 0.04364939), (19, 0.46645594)]"
26053,26054.0,2022-04-20 04:42:58,3,197,"<p>I'm aware that one can <a href=""https://arxiv.org/abs/quant-ph/9701028"" rel=""nofollow noreferrer"">imperfectly clone entanglement that's shared between two parties</a> (i.e. Bell pairs) using deterministic quantum cloning machines to produce two, lower fidelity entangled states.</p>
<p>What I want to know is, does there exist some strategy to non-deterministically generate entanglement between two distant parties? In other words if Alice and Bob have a Bell pair between them, is there some LOCC strategy they can do that will either create another Bell pair of the same fidelity, or fail wiith some probability.</p>
",Is there a non-deterministic protocol for entanglement generation between distant parties?,<entanglement><information-theory><communication><locc-operation><cloning>,2,0,,,"Is there a non-deterministic protocol for entanglement generation between distant parties? <p>I'm aware that one can <a href=""https://arxiv.org/abs/quant-ph/9701028"" rel=""nofollow noreferrer"">imperfectly clone entanglement that's shared between two parties</a> (i.e. Bell pairs) using deterministic quantum cloning machines to produce two, lower fidelity entangled states.</p>
<p>What I want to know is, does there exist some strategy to non-deterministically generate entanglement between two distant parties? In other words if Alice and Bob have a Bell pair between them, is there some LOCC strategy they can do that will either create another Bell pair of the same fidelity, or fail wiith some probability.</p>
",qc,protocol entanglement generation distant parties p aware one https nofollow noreferrer imperfectly clone entanglement shared two parties bell pairs using deterministic quantum cloning machines produce two lower fidelity entangled p want know exist strategy generate entanglement two distant parties words alice bob bell pair locc strategy either create another bell pair fidelity fail wiith,"[(2, 0.03823036), (4, 0.071229294), (8, 0.06352216), (14, 0.1273117), (17, 0.12032683), (18, 0.5766945)]"
26167,26172.0,2022-04-26 12:24:20,5,394,"<p>I am trying to implement the Quantum Approximate Optimization Ansatz by creating a parametrized subcircuit</p>
<p><span class=""math-container"">$$V (α) = e^{−iH_M α_1} e^{−iH_D b_1} ... e^{−iH_M α_n} e^{−iH_D b_n}$$</span>
with the custom driver hamiltonian <span class=""math-container"">$H_M = \mathbb{I} - \left|b \right&gt; \left&lt; b\right|$</span>, where <span class=""math-container"">$\left| b \right&gt;= U \left| 0 \right&gt;$</span> is a random normalized state, and the default <span class=""math-container"">$H_M$</span> mixer hamiltonian of the original paper.</p>
<p>I have a problem feeding my hamiltonian to the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.QAOAAnsatz.html"" rel=""noreferrer""><code>QAOAAnsatz</code></a> as it asks an <code>OperatorBase</code> class for input.</p>
<p><strong>How do I construct the <code>Operator</code> object for <code>QAOAAnsatz</code> or how do I create a custom QAOA circuit?</strong></p>
",Qiskit: QAOAnsatz circuit with custom Hamiltonian,<qiskit><circuit-construction><vqe><optimization>,1,0,,,"Qiskit: QAOAnsatz circuit with custom Hamiltonian <p>I am trying to implement the Quantum Approximate Optimization Ansatz by creating a parametrized subcircuit</p>
<p><span class=""math-container"">$$V (α) = e^{−iH_M α_1} e^{−iH_D b_1} ... e^{−iH_M α_n} e^{−iH_D b_n}$$</span>
with the custom driver hamiltonian <span class=""math-container"">$H_M = \mathbb{I} - \left|b \right&gt; \left&lt; b\right|$</span>, where <span class=""math-container"">$\left| b \right&gt;= U \left| 0 \right&gt;$</span> is a random normalized state, and the default <span class=""math-container"">$H_M$</span> mixer hamiltonian of the original paper.</p>
<p>I have a problem feeding my hamiltonian to the <a href=""https://qiskit.org/documentation/stubs/qiskit.circuit.library.QAOAAnsatz.html"" rel=""noreferrer""><code>QAOAAnsatz</code></a> as it asks an <code>OperatorBase</code> class for input.</p>
<p><strong>How do I construct the <code>Operator</code> object for <code>QAOAAnsatz</code> or how do I create a custom QAOA circuit?</strong></p>
",qc,qiskit qaoansatz circuit custom hamiltonian p trying implement quantum approximate optimization ansatz creating parametrized subcircuit p span v α custom driver hamiltonian span gt lt span b gt u 0 gt random normalized state default span mixer hamiltonian original p problem feeding hamiltonian https noreferrer code qaoaansatz asks code operatorbase class p strong construct code operator object code qaoaansatz create custom qaoa circuit,"[(0, 0.4459362), (1, 0.10862133), (3, 0.18457279), (4, 0.04795042), (5, 0.015398595), (13, 0.027386576), (14, 0.1501112), (17, 0.018049506)]"
26181,,2022-04-27 15:20:33,1,131,"<p>I have checked IBM 'peekskill' system and it has basic gates defined as: <br />
CX, ID, RZ, SX, X, <strong>XPRS.</strong></p>
<p>It is the only one IBM system that has <strong>XPRS</strong> gate on its list.
<br />
Does anyone knows what kind of gate <strong>XPRS</strong> is?</p>
<p>Other 'peekskill' system properties:</p>
<ul>
<li>27 qubits</li>
<li>Processor type: Falcon r8</li>
<li>Version: 2.1.0</li>
</ul>
",What is XPRS basic gate on IBM 'peekskill' system?,<universal-gates>,0,2,,,"What is XPRS basic gate on IBM 'peekskill' system? <p>I have checked IBM 'peekskill' system and it has basic gates defined as: <br />
CX, ID, RZ, SX, X, <strong>XPRS.</strong></p>
<p>It is the only one IBM system that has <strong>XPRS</strong> gate on its list.
<br />
Does anyone knows what kind of gate <strong>XPRS</strong> is?</p>
<p>Other 'peekskill' system properties:</p>
<ul>
<li>27 qubits</li>
<li>Processor type: Falcon r8</li>
<li>Version: 2.1.0</li>
</ul>
",qc,xprs basic gate ibm system p checked ibm system basic gates defined br cx id rz sx x strong p one ibm system strong xprs gate list br anyone knows kind gate strong xprs p system properties ul li 27 qubits li processor type falcon r8 li version,"[(1, 0.08978526), (7, 0.09916014), (9, 0.28585938), (10, 0.027811475), (13, 0.05503464), (14, 0.41457376), (17, 0.024765354)]"
26201,26202.0,2022-04-29 08:01:01,0,26,"<p>Let <span class=""math-container"">$\rho$</span> is a bipartite state.</p>
<p>W is a local filtering operation that acts on a subsystem of the state  <span class=""math-container"">$\rho$</span>.</p>
<p>After the local filtering operation <span class=""math-container"">$\rho$</span> emerges into a <span class=""math-container"">$\tilde{\rho}$</span> i.e</p>
<p><span class=""math-container"">$\tilde{\rho}=\frac{I\otimes W \rho I\otimes W}{\mbox{Tr}(I\otimes W \rho I\otimes W)}$</span></p>
<p>Local filtering operation is trace decreasing?</p>
",Filtering operation is trace decreasing?,<quantum-operation><locc-operation>,1,0,,,"Filtering operation is trace decreasing? <p>Let <span class=""math-container"">$\rho$</span> is a bipartite state.</p>
<p>W is a local filtering operation that acts on a subsystem of the state  <span class=""math-container"">$\rho$</span>.</p>
<p>After the local filtering operation <span class=""math-container"">$\rho$</span> emerges into a <span class=""math-container"">$\tilde{\rho}$</span> i.e</p>
<p><span class=""math-container"">$\tilde{\rho}=\frac{I\otimes W \rho I\otimes W}{\mbox{Tr}(I\otimes W \rho I\otimes W)}$</span></p>
<p>Local filtering operation is trace decreasing?</p>
",qc,filtering operation trace decreasing p let span bipartite p w local filtering operation acts subsystem state span p local filtering operation span emerges span p span w w tr w w p local filtering operation trace decreasing,"[(3, 0.75538605), (8, 0.05884707), (16, 0.06649115), (17, 0.11496883)]"
26206,,2022-04-29 12:35:29,1,239,"<p>I am reading a book named Learn Quantum Computing with Python and IBM Quantum Experience authored by Robert Loredo. When I tried to run the code on Chapter 11, I followed the instruction and wroted down the code:</p>
<pre><code># Import plot and match libraries
import matplotlib.pyplot as plt

# Import the noise models and some standard error methods
from qiskit.providers.aer.noise import NoiseModel
# from qiskit.providers.aer.noise.errors.standard_errors import amplitude_damping_error, phase_damping_error
from qiskit.providers.aer.noise import amplitude_damping_error, phase_damping_error

# Import all three coherence circuits generators and fitters
from qiskit.ignis.characterization.coherence import t1_circuits, t2_circuits, t2star_circuits
from qiskit.ignis.characterization.coherence import T1Fitter, T2Fitter, T2StarFitter

# Generate the T1 test circuits

# Generate a list of number of gates to add to each circuit
# using np.linspace so that the number of gates increases linearly
# and append with a large span at the end of the list (200-4000)

num_of_gates = np.append((np.linspace(1, 100, 12)).astype(int),
                         np.array([200, 400, 800, 1000, 2000, 4000]))

# Define the gate time for each Idnentity gate
gate_time = 0.1

# Select the first qubit as the one we wish to measure T1
qubits = [0]

# Generate the test circuits given the above parameters
test_circuits, delay_times = t1_circuits(num_of_gates,
                                        gate_time, qubits)
# The number of I gates appended for each circuit
print('Number of gates per test circuit: \n', num_of_gates, '\n')

# The gate time of each circuit (number of I gate * gate_time)
print('Delay times for each test circuit created, respectively: \n',
      delay_times)
</code></pre>
<p>After I successfully generate the circuits, I added the amplitude damping error like:</p>
<pre><code># Set the simulator with amplitude damping noise

# Set the amplitude damping noise channel parameters T1 and Lambda
t1 = 20
lam = np.exp(-gate_time/t1)

# Generate the amplitude damping error channel
error = amplitude_damping_error(1 - lam)
noise_model = NoiseModel()
#print(error)

# Set the dampling error to the ID gate on qubit 0.
noise_model.add_quantum_error(error, 'id', [0])
</code></pre>
<p>Then I tried to execute this circuit on a simulator like:</p>
<pre><code># Run the simulator with the generated noise model
from qiskit import execute
backend = Aer.get_backend('qasm_simulator')
shots = 200
backend_result = execute(test_circuits, backend, shots = shots,
                         noise_model = noise_model).result()
</code></pre>
<p>Then the results are plotted:</p>
<pre><code># Plot the noisy results of the largest (last in the list) circuit
plot_histogram(backend_result.get_counts(test_circuits[0]))
</code></pre>
<p>The graph I got is like:
<a href=""https://i.sstatic.net/n5qKH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/n5qKH.png"" alt=""enter image description here"" /></a>
Howerver, the correct one should be like:
<a href=""https://i.sstatic.net/zx2z1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zx2z1.png"" alt=""enter image description here"" /></a></p>
<p>It seems to me the amplitude damping error was NOT added to the NoiseModel successfully. I wonder if anyone can help me to figure out the solution to this problem.</p>
",Fail to add amplitude damping error to NoiseModel,<qiskit><programming><noise>,1,0,,,"Fail to add amplitude damping error to NoiseModel <p>I am reading a book named Learn Quantum Computing with Python and IBM Quantum Experience authored by Robert Loredo. When I tried to run the code on Chapter 11, I followed the instruction and wroted down the code:</p>
<pre><code># Import plot and match libraries
import matplotlib.pyplot as plt

# Import the noise models and some standard error methods
from qiskit.providers.aer.noise import NoiseModel
# from qiskit.providers.aer.noise.errors.standard_errors import amplitude_damping_error, phase_damping_error
from qiskit.providers.aer.noise import amplitude_damping_error, phase_damping_error

# Import all three coherence circuits generators and fitters
from qiskit.ignis.characterization.coherence import t1_circuits, t2_circuits, t2star_circuits
from qiskit.ignis.characterization.coherence import T1Fitter, T2Fitter, T2StarFitter

# Generate the T1 test circuits

# Generate a list of number of gates to add to each circuit
# using np.linspace so that the number of gates increases linearly
# and append with a large span at the end of the list (200-4000)

num_of_gates = np.append((np.linspace(1, 100, 12)).astype(int),
                         np.array([200, 400, 800, 1000, 2000, 4000]))

# Define the gate time for each Idnentity gate
gate_time = 0.1

# Select the first qubit as the one we wish to measure T1
qubits = [0]

# Generate the test circuits given the above parameters
test_circuits, delay_times = t1_circuits(num_of_gates,
                                        gate_time, qubits)
# The number of I gates appended for each circuit
print('Number of gates per test circuit: \n', num_of_gates, '\n')

# The gate time of each circuit (number of I gate * gate_time)
print('Delay times for each test circuit created, respectively: \n',
      delay_times)
</code></pre>
<p>After I successfully generate the circuits, I added the amplitude damping error like:</p>
<pre><code># Set the simulator with amplitude damping noise

# Set the amplitude damping noise channel parameters T1 and Lambda
t1 = 20
lam = np.exp(-gate_time/t1)

# Generate the amplitude damping error channel
error = amplitude_damping_error(1 - lam)
noise_model = NoiseModel()
#print(error)

# Set the dampling error to the ID gate on qubit 0.
noise_model.add_quantum_error(error, 'id', [0])
</code></pre>
<p>Then I tried to execute this circuit on a simulator like:</p>
<pre><code># Run the simulator with the generated noise model
from qiskit import execute
backend = Aer.get_backend('qasm_simulator')
shots = 200
backend_result = execute(test_circuits, backend, shots = shots,
                         noise_model = noise_model).result()
</code></pre>
<p>Then the results are plotted:</p>
<pre><code># Plot the noisy results of the largest (last in the list) circuit
plot_histogram(backend_result.get_counts(test_circuits[0]))
</code></pre>
<p>The graph I got is like:
<a href=""https://i.sstatic.net/n5qKH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/n5qKH.png"" alt=""enter image description here"" /></a>
Howerver, the correct one should be like:
<a href=""https://i.sstatic.net/zx2z1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zx2z1.png"" alt=""enter image description here"" /></a></p>
<p>It seems to me the amplitude damping error was NOT added to the NoiseModel successfully. I wonder if anyone can help me to figure out the solution to this problem.</p>
",qc,fail add amplitude damping error noisemodel p reading book named learn quantum computing python ibm quantum experience authored robert loredo tried run code chapter 11 followed instruction wroted code pre code import plot match libraries import plt import noise models standard error methods import noisemodel import import import three coherence circuits generators fitters import import t1fitter t2fitter t2starfitter generate t1 test circuits generate list number gates add circuit using number gates increases linearly append large span end list 1 100 12 int 200 400 800 1000 2000 4000 define gate time idnentity gate select first qubit one wish measure t1 qubits 0 generate test circuits given parameters qubits number gates appended circuit print gates per test circuit gate time circuit number gate print times test circuit created respectively p successfully generate circuits added amplitude damping error like pre code set simulator amplitude damping noise set amplitude damping noise channel parameters t1 lambda t1 20 lam generate amplitude damping error channel error 1 lam noisemodel print error set dampling error id gate qubit error 0 p tried execute circuit simulator like pre code run simulator generated noise model qiskit import execute backend shots 200 execute backend shots shots p results plotted pre code plot noisy results largest last list circuit 0 p graph got like https nofollow noreferrer img https enter image description howerver correct one like https nofollow noreferrer img https enter image description p seems amplitude damping error added noisemodel successfully wonder anyone help figure solution,"[(0, 0.18805863), (2, 0.013319617), (4, 0.117587805), (5, 0.027204504), (6, 0.019126074), (8, 0.025291463), (14, 0.49200305), (17, 0.03490829), (18, 0.05008071)]"
26251,,2022-05-02 19:48:12,0,84,"<p>On page 11 of <a href=""https://arxiv.org/pdf/2103.03804.pdf"" rel=""nofollow noreferrer"">this study</a> they write that &quot;In order to calculate macroscopic values according to Eq.(11), point-wise addition of the distribution function ... is required. To perform this operation quantumly, a quantum circuit composed of controlled H, SWAP, and X gate is applied ... while an addition procedure is conducted by applying the Hadamard operation.&quot; They then go on to give an explicit circuit to do this operation  (Fig. 7).</p>
<p>My question is, what do they mean by &quot;point-wise addition?&quot; Is this the same as using an adder function as discussed <a href=""https://quantumcomputing.stackexchange.com/questions/1654/how-do-i-add-11-using-a-quantum-computer/1656"">here</a>? If not, what are they doing differently? It seems to me like they may be adding probability amplitudes, but that doesn't seem possible since I don't think it is a unitary operation.</p>
","What does ""point-wise addition"" mean in the context of this paper?",<circuit-construction>,0,3,,,"What does ""point-wise addition"" mean in the context of this paper? <p>On page 11 of <a href=""https://arxiv.org/pdf/2103.03804.pdf"" rel=""nofollow noreferrer"">this study</a> they write that &quot;In order to calculate macroscopic values according to Eq.(11), point-wise addition of the distribution function ... is required. To perform this operation quantumly, a quantum circuit composed of controlled H, SWAP, and X gate is applied ... while an addition procedure is conducted by applying the Hadamard operation.&quot; They then go on to give an explicit circuit to do this operation  (Fig. 7).</p>
<p>My question is, what do they mean by &quot;point-wise addition?&quot; Is this the same as using an adder function as discussed <a href=""https://quantumcomputing.stackexchange.com/questions/1654/how-do-i-add-11-using-a-quantum-computer/1656"">here</a>? If not, what are they doing differently? It seems to me like they may be adding probability amplitudes, but that doesn't seem possible since I don't think it is a unitary operation.</p>
",qc,addition mean context paper p page 11 https nofollow noreferrer study write quot order calculate macroscopic values according eq 11 addition distribution function required perform operation quantumly quantum circuit composed controlled h swap x gate applied addition procedure conducted applying hadamard quot go give explicit circuit operation fig 7 p question mean quot addition quot using adder function discussed https differently seems like may adding probability amplitudes seem possible since think unitary,"[(3, 0.093992904), (4, 0.14574598), (6, 0.047154754), (7, 0.022572957), (9, 0.24406701), (10, 0.031013098), (13, 0.3216048), (17, 0.015208719), (19, 0.07710996)]"
26313,26316.0,2022-05-08 19:20:01,2,227,"<p><em><strong>(Notation)</strong></em> Let <span class=""math-container"">$\Phi$</span> be a generic quantum map sending states in <span class=""math-container"">$\mathbb{C}^n$</span> into states in <span class=""math-container"">$\mathbb{C}^m$</span>. We say that <span class=""math-container"">$\Phi$</span> is <em>positive</em> when <span class=""math-container"">$\Phi(X)\ge0$</span> for any positive linear operator <span class=""math-container"">$X\in\mathrm{Lin}(\mathbb{C}^n)$</span>.
We say that <span class=""math-container"">$\Phi$</span> is <em>completely positive</em> (CP) when <span class=""math-container"">$\Phi\otimes \operatorname{Id}_k$</span> is a positive map for all <span class=""math-container"">$k\ge0$</span>.</p>
<p><em><strong>(A standard approach to proving that CP <span class=""math-container"">$\iff$</span> <span class=""math-container"">$n$</span>-positive)</strong></em> It is well-known that <span class=""math-container"">$\Phi$</span> is CP <em>iff</em> its Choi representation,
<span class=""math-container"">$$J(\Phi)\equiv (\Phi\otimes \operatorname{Id}_n)(|m\rangle\!\langle m|)\in\operatorname{Lin}(\mathbb{C}^m\otimes \mathbb{C}^n),$$</span>
is positive semidefinite. Here <span class=""math-container"">$|m\rangle\equiv \sum_{i=1}^n |i,i\rangle$</span> is the (unnormalised) maximally entangled state.
A standard way to show this is to observe that</p>
<ol>
<li>If <span class=""math-container"">$J(\Phi)$</span> is positive semidefinite then it admits an eigendecomposition <span class=""math-container"">$J(\Phi)=\sum_a v_a v_a^\dagger$</span> for some collection of vectors <span class=""math-container"">$v_a\in\mathbb{C}^m\otimes \mathbb{C}^n$</span>;</li>
<li>The eigendecomposition for <span class=""math-container"">$J(\Phi)$</span> corresponds to a Kraus-like decomposition for <span class=""math-container"">$\Phi$</span> itself: <span class=""math-container"">$\Phi(X)=\sum_a A_a X A_a^\dagger$</span> with <span class=""math-container"">$A_a$</span> being the linear operators with the same components as the vectors <span class=""math-container"">$v_a$</span>.</li>
<li>Such a Kraus-like decomposition can always be rewritten as a Stinespring-like representation <span class=""math-container"">$\Phi(X)=\operatorname{Tr}_1(VXV^\dagger)$</span> with <span class=""math-container"">$V\equiv \sum_a |a\rangle\otimes A_a$</span>, and any map with such a representation is CP, because
<span class=""math-container"">$$(\Phi\otimes \operatorname{Id}_k)(\mathbb{P}(|\Psi\rangle)) = \operatorname{Tr}_1\!\!\big[\mathbb{P}((V\otimes I_k)|\Psi\rangle)\big], \qquad \mathbb{P}(|\psi\rangle)\equiv |\psi\rangle\!\langle\psi|, \qquad \forall|\Psi\rangle\in \mathbb{C}^{n+k},$$</span>
meaning the action of any finite extension of <span class=""math-container"">$\Phi$</span> on unit-rank projections returns the partial trace of a unit-rank projection, which is always a positive semidefinite operator.</li>
</ol>
<p><em><strong>(The question)</strong></em> Now, suppose I'm interested in proving the fact that <span class=""math-container"">$\Phi\otimes \operatorname{Id}_n$</span> sending maximally entangled states to valid states is sufficient to know that any extension of <span class=""math-container"">$\Phi$</span> sends physical states into physical states (<em>i.e.</em> that <span class=""math-container"">$\Phi$</span> is CP). The above approach does of course work, but it involves quite a bit of machinery to show something that on the face of it seems a rather simple statement.</p>
<p>Is there a simpler or more direct way to show that <span class=""math-container"">$(\Phi\otimes \operatorname{Id}_n)(|m\rangle\!\langle m|)$</span> being positive is sufficient to know that <span class=""math-container"">$\Phi\otimes \operatorname{Id}_k$</span> is a positive map for all <span class=""math-container"">$k$</span>?</p>
",Why is $\Phi\otimes \operatorname{Id}_n$ being positive on maximally entangled states sufficient to know that $\Phi$ is CP?,<quantum-operation>,2,12,,,"Why is $\Phi\otimes \operatorname{Id}_n$ being positive on maximally entangled states sufficient to know that $\Phi$ is CP? <p><em><strong>(Notation)</strong></em> Let <span class=""math-container"">$\Phi$</span> be a generic quantum map sending states in <span class=""math-container"">$\mathbb{C}^n$</span> into states in <span class=""math-container"">$\mathbb{C}^m$</span>. We say that <span class=""math-container"">$\Phi$</span> is <em>positive</em> when <span class=""math-container"">$\Phi(X)\ge0$</span> for any positive linear operator <span class=""math-container"">$X\in\mathrm{Lin}(\mathbb{C}^n)$</span>.
We say that <span class=""math-container"">$\Phi$</span> is <em>completely positive</em> (CP) when <span class=""math-container"">$\Phi\otimes \operatorname{Id}_k$</span> is a positive map for all <span class=""math-container"">$k\ge0$</span>.</p>
<p><em><strong>(A standard approach to proving that CP <span class=""math-container"">$\iff$</span> <span class=""math-container"">$n$</span>-positive)</strong></em> It is well-known that <span class=""math-container"">$\Phi$</span> is CP <em>iff</em> its Choi representation,
<span class=""math-container"">$$J(\Phi)\equiv (\Phi\otimes \operatorname{Id}_n)(|m\rangle\!\langle m|)\in\operatorname{Lin}(\mathbb{C}^m\otimes \mathbb{C}^n),$$</span>
is positive semidefinite. Here <span class=""math-container"">$|m\rangle\equiv \sum_{i=1}^n |i,i\rangle$</span> is the (unnormalised) maximally entangled state.
A standard way to show this is to observe that</p>
<ol>
<li>If <span class=""math-container"">$J(\Phi)$</span> is positive semidefinite then it admits an eigendecomposition <span class=""math-container"">$J(\Phi)=\sum_a v_a v_a^\dagger$</span> for some collection of vectors <span class=""math-container"">$v_a\in\mathbb{C}^m\otimes \mathbb{C}^n$</span>;</li>
<li>The eigendecomposition for <span class=""math-container"">$J(\Phi)$</span> corresponds to a Kraus-like decomposition for <span class=""math-container"">$\Phi$</span> itself: <span class=""math-container"">$\Phi(X)=\sum_a A_a X A_a^\dagger$</span> with <span class=""math-container"">$A_a$</span> being the linear operators with the same components as the vectors <span class=""math-container"">$v_a$</span>.</li>
<li>Such a Kraus-like decomposition can always be rewritten as a Stinespring-like representation <span class=""math-container"">$\Phi(X)=\operatorname{Tr}_1(VXV^\dagger)$</span> with <span class=""math-container"">$V\equiv \sum_a |a\rangle\otimes A_a$</span>, and any map with such a representation is CP, because
<span class=""math-container"">$$(\Phi\otimes \operatorname{Id}_k)(\mathbb{P}(|\Psi\rangle)) = \operatorname{Tr}_1\!\!\big[\mathbb{P}((V\otimes I_k)|\Psi\rangle)\big], \qquad \mathbb{P}(|\psi\rangle)\equiv |\psi\rangle\!\langle\psi|, \qquad \forall|\Psi\rangle\in \mathbb{C}^{n+k},$$</span>
meaning the action of any finite extension of <span class=""math-container"">$\Phi$</span> on unit-rank projections returns the partial trace of a unit-rank projection, which is always a positive semidefinite operator.</li>
</ol>
<p><em><strong>(The question)</strong></em> Now, suppose I'm interested in proving the fact that <span class=""math-container"">$\Phi\otimes \operatorname{Id}_n$</span> sending maximally entangled states to valid states is sufficient to know that any extension of <span class=""math-container"">$\Phi$</span> sends physical states into physical states (<em>i.e.</em> that <span class=""math-container"">$\Phi$</span> is CP). The above approach does of course work, but it involves quite a bit of machinery to show something that on the face of it seems a rather simple statement.</p>
<p>Is there a simpler or more direct way to show that <span class=""math-container"">$(\Phi\otimes \operatorname{Id}_n)(|m\rangle\!\langle m|)$</span> being positive is sufficient to know that <span class=""math-container"">$\Phi\otimes \operatorname{Id}_k$</span> is a positive map for all <span class=""math-container"">$k$</span>?</p>
",qc,id positive maximally entangled states sufficient know cp p em strong notation let span generic quantum map sending states span c states span c say span em positive span x positive linear operator span lin c say span em completely positive cp span id positive map span p em strong standard approach proving cp span span n span cp em iff choi representation span j id lin c c positive semidefinite span unnormalised maximally entangled state standard way show observe ol li span j positive semidefinite admits eigendecomposition span j collection vectors span c c li eigendecomposition span j corresponds decomposition span span x x span linear operators components vectors span li decomposition always rewritten representation span x tr span map representation cp span id p tr p p c meaning action finite extension span projections returns partial trace projection always positive semidefinite p em strong question suppose interested proving fact span id sending maximally entangled states valid states sufficient know extension span sends physical states physical states em span cp approach course work involves quite bit machinery show something face seems rather simple p simpler direct way show span id positive sufficient know span id positive map span k,"[(3, 0.6581212), (9, 0.029828124), (10, 0.02108694), (11, 0.14602898), (17, 0.04131564), (18, 0.102916025)]"
26353,26358.0,2022-05-12 00:27:11,0,318,"<p>Recall the hamiltonian of the toric code: (information mainly extracted from <a href=""https://arxiv.org/pdf/1610.09260.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1610.09260.pdf</a>)</p>
<p><a href=""https://i.sstatic.net/Xcnva.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Xcnva.png"" alt=""enter image description here"" /></a></p>
<p>Consider Je=Jm=1. I've been trying to get the exact energies and degeneracies of the ground state but also for all the excited states of the toric code, depending on the size NxN of the lattice (we can do so as the hamiltonian is finite). For the degeneracy of the ground state it is well-known that it is 4 in a torus, yet for the excitations I haven't been able to find a satisfying answer. Also, from what I've understood, the ground state energy should be</p>
<p><a href=""https://i.sstatic.net/xFWJ9.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xFWJ9.png"" alt=""enter image description here"" /></a>,</p>
<p>and for each excitation, the energy should be increased by 4J. However, how do I find the degeneracies of these states, as well as the exact number of excited states?</p>
<p>I haven't found any analytical solution myself, so I've been trying to find it numerically. The main issue is that due to the amount of Kronecker/tensor products that need to be done (the dimension of the hamiltonian increases like 2^(2*N^2)), I've just been able to compute, using Python, the answer for N=2 and N=3 (for N=4 the computer still works, but the results I obtain cannot be correct). In particular, for N=2 and N=3 I've found:</p>
<p><a href=""https://i.sstatic.net/GEISh.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GEISh.png"" alt=""enter image description here"" /></a></p>
<p>Summing up, I have a few questions:</p>
<ol>
<li><p>Could anyone provide some directions on how to get the exact energies and degeneracies for the ground state and the excitations, independently of N? (I believe that the fact that A and B commute with H might help me, but I don't really know how). Ideally I would like an analytical answer, but if I knew how to compute the results correctly for larger N's, I'd also be satisfied.</p>
</li>
<li><p>Regarding my table, are the numbers on the table correct? I don't understand how do I only get 512 states for N=3, and also, how is it possible that the degeneracy of the ground state for N=3 is 8 instead of 4.</p>
</li>
<li><p>A more general question. I know that excitations behave like anyons. Is there any relation between the behaviour of anyons andthe energies and degeneracies of the toric code?</p>
</li>
</ol>
<p>Thanks a lot in advance and sorry for the long question.</p>
",Energy and degeneracy of the ground state and excitations of the toric code,<error-correction><anyons><toric-code>,1,1,,,"Energy and degeneracy of the ground state and excitations of the toric code <p>Recall the hamiltonian of the toric code: (information mainly extracted from <a href=""https://arxiv.org/pdf/1610.09260.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1610.09260.pdf</a>)</p>
<p><a href=""https://i.sstatic.net/Xcnva.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Xcnva.png"" alt=""enter image description here"" /></a></p>
<p>Consider Je=Jm=1. I've been trying to get the exact energies and degeneracies of the ground state but also for all the excited states of the toric code, depending on the size NxN of the lattice (we can do so as the hamiltonian is finite). For the degeneracy of the ground state it is well-known that it is 4 in a torus, yet for the excitations I haven't been able to find a satisfying answer. Also, from what I've understood, the ground state energy should be</p>
<p><a href=""https://i.sstatic.net/xFWJ9.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xFWJ9.png"" alt=""enter image description here"" /></a>,</p>
<p>and for each excitation, the energy should be increased by 4J. However, how do I find the degeneracies of these states, as well as the exact number of excited states?</p>
<p>I haven't found any analytical solution myself, so I've been trying to find it numerically. The main issue is that due to the amount of Kronecker/tensor products that need to be done (the dimension of the hamiltonian increases like 2^(2*N^2)), I've just been able to compute, using Python, the answer for N=2 and N=3 (for N=4 the computer still works, but the results I obtain cannot be correct). In particular, for N=2 and N=3 I've found:</p>
<p><a href=""https://i.sstatic.net/GEISh.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GEISh.png"" alt=""enter image description here"" /></a></p>
<p>Summing up, I have a few questions:</p>
<ol>
<li><p>Could anyone provide some directions on how to get the exact energies and degeneracies for the ground state and the excitations, independently of N? (I believe that the fact that A and B commute with H might help me, but I don't really know how). Ideally I would like an analytical answer, but if I knew how to compute the results correctly for larger N's, I'd also be satisfied.</p>
</li>
<li><p>Regarding my table, are the numbers on the table correct? I don't understand how do I only get 512 states for N=3, and also, how is it possible that the degeneracy of the ground state for N=3 is 8 instead of 4.</p>
</li>
<li><p>A more general question. I know that excitations behave like anyons. Is there any relation between the behaviour of anyons andthe energies and degeneracies of the toric code?</p>
</li>
</ol>
<p>Thanks a lot in advance and sorry for the long question.</p>
",qc,energy degeneracy ground state excitations toric code p recall hamiltonian toric code information mainly extracted https nofollow noreferrer https p https nofollow noreferrer img https enter image description p consider trying get exact energies degeneracies ground state also excited states toric code depending size nxn lattice hamiltonian finite degeneracy ground state 4 torus yet excitations able find satisfying answer also understood ground state energy p https nofollow noreferrer img https enter image description p excitation energy increased 4j however find degeneracies states well exact number excited states p found analytical solution trying find numerically main issue due amount products need done dimension hamiltonian increases like 2 able compute using python answer computer still works results obtain correct particular found p https nofollow noreferrer img https enter image description p summing questions ol li p could anyone provide directions get exact energies degeneracies ground state excitations independently n believe fact b commute h might help really know ideally would like analytical answer knew compute results correctly larger n also li p regarding table numbers table correct understand get 512 states also possible degeneracy ground state 8 instead li p general question know excitations behave like anyons relation behaviour anyons andthe energies degeneracies toric code p thanks lot advance sorry long,"[(1, 0.06615704), (3, 0.118473664), (4, 0.22387336), (7, 0.17330213), (8, 0.084630124), (13, 0.14659885), (14, 0.10387782), (17, 0.07735334)]"
26372,26378.0,2022-05-12 19:37:28,2,483,"<p>Does the unitary freedom in the choice of Kraus operators for a given quantum channel just come from the unitary freedom in choice of purification of a quantum state?</p>
<p>Here's what I'm thinking. If I have two representations of the same quantum channel
<span class=""math-container"">$$\Lambda(\rho) = \sum_k A_k\rho A_k^\dagger = \sum_k B_k \rho B_k^\dagger = \Lambda'(\rho),$$</span>
then we also have
<span class=""math-container"">$$(\Lambda \otimes id) \Omega = (\Lambda' \otimes id)\Omega,$$</span>
where <span class=""math-container"">$\Omega = \sum_i \frac{1}{d}\vert{ii}\rangle\langle ii \vert.$</span> Each of these results in different representations of the same density matrix. So, they can be purified and there is unitary freedom in the choice of purification. Tracing out the auxiliary state seems to explain why there is unitary freedom in the choice of Kraus operators.</p>
<p>My question is twofold: is this correct? Is there a better (or another) way to see why we have unitary freedom in Kraus operators?</p>
",Does the unitary freedom in choice of Kraus operators come from the freedom in the choice of purifications?,<quantum-operation><kraus-representation><purification>,2,0,,,"Does the unitary freedom in choice of Kraus operators come from the freedom in the choice of purifications? <p>Does the unitary freedom in the choice of Kraus operators for a given quantum channel just come from the unitary freedom in choice of purification of a quantum state?</p>
<p>Here's what I'm thinking. If I have two representations of the same quantum channel
<span class=""math-container"">$$\Lambda(\rho) = \sum_k A_k\rho A_k^\dagger = \sum_k B_k \rho B_k^\dagger = \Lambda'(\rho),$$</span>
then we also have
<span class=""math-container"">$$(\Lambda \otimes id) \Omega = (\Lambda' \otimes id)\Omega,$$</span>
where <span class=""math-container"">$\Omega = \sum_i \frac{1}{d}\vert{ii}\rangle\langle ii \vert.$</span> Each of these results in different representations of the same density matrix. So, they can be purified and there is unitary freedom in the choice of purification. Tracing out the auxiliary state seems to explain why there is unitary freedom in the choice of Kraus operators.</p>
<p>My question is twofold: is this correct? Is there a better (or another) way to see why we have unitary freedom in Kraus operators?</p>
",qc,unitary freedom choice kraus operators come freedom choice purifications p unitary freedom choice kraus operators given quantum channel come unitary freedom choice purification quantum state p thinking two representations quantum channel span also span id id span 1 ii ii results different representations density matrix purified unitary freedom choice purification tracing auxiliary state seems explain unitary freedom choice kraus p question twofold correct better another way see unitary freedom kraus operators,"[(3, 0.93895066), (11, 0.027316265), (17, 0.031310715)]"
26389,,2022-05-13 21:30:49,2,501,"<p>I'm currently trying to understand lattice surgeries. As an exercise I'm currently implementing the lattice surgery operations described in <a href=""https://arxiv.org/abs/2006.03071"" rel=""nofollow noreferrer"">Entangling logical qubits with lattice surgery, by Alexander Erhard et al.</a> on a 7 qubits surface code (distance = 2). The same code described in the article.</p>
<p><a href=""https://i.sstatic.net/yIHw3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yIHw3.png"" alt=""7 qubits surface code"" /></a></p>
<p>The operations I'm trying to implement in Qiskit are the following :</p>
<p><a href=""https://i.sstatic.net/Aao8U.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Aao8U.png"" alt=""CNOT, Teleportation and Hadamard using Lattice Surgery"" /></a></p>
<p>I'm struggling with the CNOT gate and I feel like I'm missing something obvious. I searched around a lot and found ZX-calculus and a lot of other interesting leads but I cannot understand why my code isn't working...</p>
<p>From my basic understanding a logical CNOT gate can be done using a smooth merge of the target and a temporary logical qubits. Which is done by measuring Z1Z3 of the temporary and Z2Z4 of the target into an ancilla qubit. (target above temporary). I did that using CNOT gates and Hadamard gates :</p>
<p><a href=""https://i.sstatic.net/zPhw4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zPhw4.png"" alt=""MZZ measurement"" /></a></p>
<p>Then I measured X1X2X3X4 of the control using 4 CNOT into another ancilla to perform a smooth split.
Finally, I performed a rough merge on the temporary and target by measuring X3 (Temporary) and X1 (Target) into a third ancilla and X4 (Temporary) and X2 (Target) into a fourth ancilla using 2 CNOT each time.
I then tried splitting, or not. Either way, my Target logical qubits doesn't end up in <span class=""math-container"">$|1\rangle_L$</span>...</p>
<p>I'm using <span class=""math-container"">$|0\rangle_L = \frac{1}{\sqrt{2}}(|1010\rangle + |0101\rangle)$</span> and <span class=""math-container"">$|1\rangle_L = \frac{1}{\sqrt{2}}(|1001\rangle + |0110\rangle)$</span> (same as the article.
And initializing the control to <span class=""math-container"">$|1\rangle_L$</span> and the temporary to <span class=""math-container"">$|+\rangle_L = (|0101\rangle + |1010\rangle + |1001\rangle + |0110\rangle)$</span>. The target is initialized to <span class=""math-container"">$|0\rangle_L$</span>.</p>
<p>Is my understanding correct ? Is my way of doing thing also correct?</p>
<p>I'm really sorry if I'm missing something obvious but I don't understand why at the end of this sequence, the target qubit isn't set to <span class=""math-container"">$|1\rangle_L$</span> ? If I'm lacking basic knowledge on Lattice surgeries, could you please provide me some resources I could look at please?</p>
<p>Thank you in advance.</p>
","Lattice surgery on small Surface Code (d=2, 7 qubits)",<error-correction><surface-code>,0,1,,,"Lattice surgery on small Surface Code (d=2, 7 qubits) <p>I'm currently trying to understand lattice surgeries. As an exercise I'm currently implementing the lattice surgery operations described in <a href=""https://arxiv.org/abs/2006.03071"" rel=""nofollow noreferrer"">Entangling logical qubits with lattice surgery, by Alexander Erhard et al.</a> on a 7 qubits surface code (distance = 2). The same code described in the article.</p>
<p><a href=""https://i.sstatic.net/yIHw3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yIHw3.png"" alt=""7 qubits surface code"" /></a></p>
<p>The operations I'm trying to implement in Qiskit are the following :</p>
<p><a href=""https://i.sstatic.net/Aao8U.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Aao8U.png"" alt=""CNOT, Teleportation and Hadamard using Lattice Surgery"" /></a></p>
<p>I'm struggling with the CNOT gate and I feel like I'm missing something obvious. I searched around a lot and found ZX-calculus and a lot of other interesting leads but I cannot understand why my code isn't working...</p>
<p>From my basic understanding a logical CNOT gate can be done using a smooth merge of the target and a temporary logical qubits. Which is done by measuring Z1Z3 of the temporary and Z2Z4 of the target into an ancilla qubit. (target above temporary). I did that using CNOT gates and Hadamard gates :</p>
<p><a href=""https://i.sstatic.net/zPhw4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zPhw4.png"" alt=""MZZ measurement"" /></a></p>
<p>Then I measured X1X2X3X4 of the control using 4 CNOT into another ancilla to perform a smooth split.
Finally, I performed a rough merge on the temporary and target by measuring X3 (Temporary) and X1 (Target) into a third ancilla and X4 (Temporary) and X2 (Target) into a fourth ancilla using 2 CNOT each time.
I then tried splitting, or not. Either way, my Target logical qubits doesn't end up in <span class=""math-container"">$|1\rangle_L$</span>...</p>
<p>I'm using <span class=""math-container"">$|0\rangle_L = \frac{1}{\sqrt{2}}(|1010\rangle + |0101\rangle)$</span> and <span class=""math-container"">$|1\rangle_L = \frac{1}{\sqrt{2}}(|1001\rangle + |0110\rangle)$</span> (same as the article.
And initializing the control to <span class=""math-container"">$|1\rangle_L$</span> and the temporary to <span class=""math-container"">$|+\rangle_L = (|0101\rangle + |1010\rangle + |1001\rangle + |0110\rangle)$</span>. The target is initialized to <span class=""math-container"">$|0\rangle_L$</span>.</p>
<p>Is my understanding correct ? Is my way of doing thing also correct?</p>
<p>I'm really sorry if I'm missing something obvious but I don't understand why at the end of this sequence, the target qubit isn't set to <span class=""math-container"">$|1\rangle_L$</span> ? If I'm lacking basic knowledge on Lattice surgeries, could you please provide me some resources I could look at please?</p>
<p>Thank you in advance.</p>
",qc,lattice surgery small surface code 7 qubits p currently trying understand lattice surgeries exercise currently implementing lattice surgery operations described https nofollow noreferrer entangling logical qubits lattice surgery alexander erhard et 7 qubits surface code distance 2 code described p https nofollow noreferrer img https 7 qubits surface code p operations trying implement qiskit following p https nofollow noreferrer img https cnot teleportation hadamard using lattice surgery p struggling cnot gate feel like missing something obvious searched around lot found lot interesting leads understand code working p basic understanding logical cnot gate done using smooth merge target temporary logical qubits done measuring z1z3 temporary z2z4 target ancilla qubit target temporary using cnot gates hadamard gates p https nofollow noreferrer img https mzz measurement p measured x1x2x3x4 control using 4 cnot another ancilla perform smooth split finally performed rough merge temporary target measuring x3 temporary x1 target third ancilla x4 temporary x2 target fourth ancilla using 2 cnot time tried splitting either way target logical qubits end span p using span 1 2 span 1 2 article initializing control span temporary span target initialized span p understanding correct way thing also correct p really sorry missing something obvious understand end sequence target qubit set span lacking basic knowledge lattice surgeries could please provide resources could look please p thank,"[(4, 0.18303898), (5, 0.086808264), (6, 0.039196294), (9, 0.05562932), (13, 0.15157819), (14, 0.116146445), (16, 0.053003), (17, 0.0112885805), (18, 0.2983248)]"
26422,,2022-05-16 07:51:57,0,381,"<p>I'm trying to implement the same Jupyter notebook in  <a href=""https://www.youtube.com/watch?v=Z-A6G0WVI9w"" rel=""nofollow noreferrer"">The Variational Quantum Eigensolver — Programming on Quantum Computers — Coding with Qiskit S2E4</a>;however,I found a problem:<br />
<strong>Error:</strong></p>
<pre><code>---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
Input In [5], in &lt;cell line: 12&gt;()
     10 from qiskit_nature.circuit.library import UCCSD
     11 from qiskit_nature.drivers.second_quantization.pyscfd import PySCFDriver
---&gt; 12 from qiskit.chemistry.core import Hamiltonian,QubitMappingType
     13 import matplotlib.pyplot as plt
     14 get_ipython().run_line_magic('matplotlib', 'inline')
ModuleNotFoundError: No module named 'qiskit.chemistry'
</code></pre>
<p>I know that qiskit.chemistry has been deprecated but don't know what code can replace
&quot;from qiskit.chemistry.core import Hamiltonian,QubitMappingType&quot;
Thanks for help!</p>
",Hamiltonian & QubitMappingType cannot be imported from qiskit.chemistry.core,<qiskit><programming><vqe>,0,6,,,"Hamiltonian & QubitMappingType cannot be imported from qiskit.chemistry.core <p>I'm trying to implement the same Jupyter notebook in  <a href=""https://www.youtube.com/watch?v=Z-A6G0WVI9w"" rel=""nofollow noreferrer"">The Variational Quantum Eigensolver — Programming on Quantum Computers — Coding with Qiskit S2E4</a>;however,I found a problem:<br />
<strong>Error:</strong></p>
<pre><code>---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
Input In [5], in &lt;cell line: 12&gt;()
     10 from qiskit_nature.circuit.library import UCCSD
     11 from qiskit_nature.drivers.second_quantization.pyscfd import PySCFDriver
---&gt; 12 from qiskit.chemistry.core import Hamiltonian,QubitMappingType
     13 import matplotlib.pyplot as plt
     14 get_ipython().run_line_magic('matplotlib', 'inline')
ModuleNotFoundError: No module named 'qiskit.chemistry'
</code></pre>
<p>I know that qiskit.chemistry has been deprecated but don't know what code can replace
&quot;from qiskit.chemistry.core import Hamiltonian,QubitMappingType&quot;
Thanks for help!</p>
",qc,hamiltonian qubitmappingtype imported p trying implement jupyter notebook https nofollow noreferrer variational quantum eigensolver programming quantum computers coding qiskit s2e4 however found problem br strong error pre code importerror traceback recent call last input 5 lt cell line 12 gt 10 import uccsd 11 import pyscfdriver gt 12 import hamiltonian qubitmappingtype 13 import plt 14 modulenotfounderror module named p know deprecated know code replace quot import hamiltonian qubitmappingtype quot thanks help,"[(0, 0.4626013), (1, 0.10641911), (4, 0.09940905), (6, 0.10647076), (8, 0.14018337), (14, 0.030811442), (17, 0.015982134), (19, 0.036335655)]"
26456,26473.0,2022-05-18 10:01:42,0,225,"<p>I'm trying to do Quantum PCA but I came across a problem. I now have a quantum state, say <span class=""math-container"">$\frac{|00\rangle+|01\rangle+|11\rangle}{\sqrt{3}}$</span> and I want to know how to prepare it from two <span class=""math-container"">$|0\rangle$</span> qubits. I mean, I wonder how can I calculate the parameters (<span class=""math-container"">$\theta, \phi, \lambda$</span>) of unitary gates? I really do appreicate it if you can help me!</p>
",How to calculate parameters of U3 gate from a certain quantum state?,<quantum-gate>,1,2,,,"How to calculate parameters of U3 gate from a certain quantum state? <p>I'm trying to do Quantum PCA but I came across a problem. I now have a quantum state, say <span class=""math-container"">$\frac{|00\rangle+|01\rangle+|11\rangle}{\sqrt{3}}$</span> and I want to know how to prepare it from two <span class=""math-container"">$|0\rangle$</span> qubits. I mean, I wonder how can I calculate the parameters (<span class=""math-container"">$\theta, \phi, \lambda$</span>) of unitary gates? I really do appreicate it if you can help me!</p>
",qc,calculate parameters u3 gate certain quantum state p trying quantum pca came across problem quantum state say span 3 want know prepare two span qubits mean wonder calculate parameters span unitary gates really appreicate help,"[(1, 0.12477844), (2, 0.06714934), (3, 0.17965852), (14, 0.41569602), (17, 0.020982804), (18, 0.18764009)]"
26491,,2022-05-19 17:31:17,2,197,"<p>In section 3.2.5 of Nielsen and Chuang (starting page 153) they talk about Landauer’s principle, where they discuss the lower bound on the thermodynamic cost of erasing information.</p>
<p>In irreversible computing (i.e. classical computers), we can <a href=""https://en.wikipedia.org/wiki/Functional_completeness"" rel=""nofollow noreferrer"">build</a> any algorithm from a series of NAND gates.  Since NAND gates take 2 inputs and give 1 output, a bit of information is erased (i.e. lost) and therefore <a href=""https://en.wikipedia.org/wiki/Landauer%27s_principle"" rel=""nofollow noreferrer"">Landauer’s principle</a> is in effect.</p>
<p>Nielson and Chuang discuss reversible computing and how it would not incur the cost of Landauer’s principle.</p>
<p><strong>QUESTION</strong></p>
<ol>
<li><p>Irreversible computing incurs the thermodynamic cost from Landauer’s principle and reversible computing does not. Heat and noise can ruin quantum states within quantum computers, is this related to Landauer’s principle?</p>
</li>
<li><p>I don’t see any direct statements connecting Landauer’s principle to why quantum computers must be reversible.  Can someone clarify the exact role Landauer’s principle plays in the reversibility of quantum computers and its relation to the unitary nature of quantum gates?</p>
</li>
</ol>
",What role does Landauer's principle play in quantum reversibility?,<quantum-gate><information-theory><unitarity><reversible-computation>,2,0,,,"What role does Landauer's principle play in quantum reversibility? <p>In section 3.2.5 of Nielsen and Chuang (starting page 153) they talk about Landauer’s principle, where they discuss the lower bound on the thermodynamic cost of erasing information.</p>
<p>In irreversible computing (i.e. classical computers), we can <a href=""https://en.wikipedia.org/wiki/Functional_completeness"" rel=""nofollow noreferrer"">build</a> any algorithm from a series of NAND gates.  Since NAND gates take 2 inputs and give 1 output, a bit of information is erased (i.e. lost) and therefore <a href=""https://en.wikipedia.org/wiki/Landauer%27s_principle"" rel=""nofollow noreferrer"">Landauer’s principle</a> is in effect.</p>
<p>Nielson and Chuang discuss reversible computing and how it would not incur the cost of Landauer’s principle.</p>
<p><strong>QUESTION</strong></p>
<ol>
<li><p>Irreversible computing incurs the thermodynamic cost from Landauer’s principle and reversible computing does not. Heat and noise can ruin quantum states within quantum computers, is this related to Landauer’s principle?</p>
</li>
<li><p>I don’t see any direct statements connecting Landauer’s principle to why quantum computers must be reversible.  Can someone clarify the exact role Landauer’s principle plays in the reversibility of quantum computers and its relation to the unitary nature of quantum gates?</p>
</li>
</ol>
",qc,role landauer principle play quantum reversibility p section nielsen chuang starting page 153 talk landauer principle discuss lower bound thermodynamic cost erasing p irreversible computing classical computers https nofollow noreferrer build algorithm series nand gates since nand gates take 2 inputs give 1 output bit information erased lost therefore https nofollow noreferrer landauer principle p nielson chuang discuss reversible computing would incur cost landauer p strong question ol li p irreversible computing incurs thermodynamic cost landauer principle reversible computing heat noise ruin quantum states within quantum computers related landauer principle li p see direct statements connecting landauer principle quantum computers must reversible someone clarify exact role landauer principle plays reversibility quantum computers relation unitary nature quantum gates,"[(1, 0.05950121), (2, 0.014914659), (3, 0.07271179), (7, 0.18793866), (8, 0.4169972), (9, 0.18278375), (13, 0.053483132), (17, 0.0105275465)]"
26517,,2022-05-20 22:58:25,2,287,"<p>Initializing a parameterized quantum circuit with a unitary sampled from a uniform distribution (so sampling from the Haar distribution) or in a weaker form: a unitary which is a unitary 2-design, brings the danger of starting in a barren plateau.</p>
<p>So why do we sample from the uniform? Because we have no prior knowledge?</p>
<p>The author in this <a href=""https://cpb-eu-w2.wpmucdn.com/blogs.bristol.ac.uk/dist/3/508/files/2019/02/barrenplateausblogpost-1xqcazi.pdf"" rel=""nofollow noreferrer"">paper without title</a> argues, that to sample measurements from a distribution that is hard using classical computing, we need unitaries which are unitary 2-designs. Is this the reason we consider the unitary 2-design?</p>
<p>Actually, this topic with the 2-design is quite confusing for me, why isn't it possible to use non-2-design unitaries?</p>
",Barren Plateau as a consequence of 2-design?,<vqe>,1,2,,,"Barren Plateau as a consequence of 2-design? <p>Initializing a parameterized quantum circuit with a unitary sampled from a uniform distribution (so sampling from the Haar distribution) or in a weaker form: a unitary which is a unitary 2-design, brings the danger of starting in a barren plateau.</p>
<p>So why do we sample from the uniform? Because we have no prior knowledge?</p>
<p>The author in this <a href=""https://cpb-eu-w2.wpmucdn.com/blogs.bristol.ac.uk/dist/3/508/files/2019/02/barrenplateausblogpost-1xqcazi.pdf"" rel=""nofollow noreferrer"">paper without title</a> argues, that to sample measurements from a distribution that is hard using classical computing, we need unitaries which are unitary 2-designs. Is this the reason we consider the unitary 2-design?</p>
<p>Actually, this topic with the 2-design is quite confusing for me, why isn't it possible to use non-2-design unitaries?</p>
",qc,barren plateau consequence p initializing parameterized quantum circuit unitary sampled uniform distribution sampling haar distribution weaker form unitary unitary brings danger starting barren p sample uniform prior knowledge p author https nofollow noreferrer paper without title argues sample measurements distribution hard using classical computing need unitaries unitary reason consider unitary p actually topic quite confusing possible use unitaries,"[(3, 0.3338801), (4, 0.05570821), (8, 0.23412038), (13, 0.07507797), (14, 0.28487238), (17, 0.013847598)]"
26541,,2022-05-24 08:36:13,1,190,"<p>I want to derive the Hamiltonian of the ion molecule <span class=""math-container"">$H_2^+$</span> by making use of Jordan-Wigner map.
Thus, I used qiskit nature. I wrote down the same command given in qiskit nature. The only difference is that I changed the charge number from 0 to 1. Then it generates following error message</p>
<pre><code>  Input In [6] in &lt;cell line: 2&gt;
    second_q_op = es_problem.second_q_ops()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py:94 in second_q_ops
    driver_result = self.driver.run()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py:179 in run
    return driver.run()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py:410 in run
    self._build_molecule()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py:460 in _build_molecule
    raise QiskitNatureError(&quot;Failed to build the PySCF Molecule object.&quot;) from exc
QiskitNatureError: 'Failed to build the PySCF Molecule object.'

Use %tb to get the full traceback.&quot;
</code></pre>
<p>If you know any method to fix it, please teach me. Thank you for your time.</p>
",Jordan-Wigner map for ionic molecule H_2^+,<qiskit><chemistry>,1,0,,,"Jordan-Wigner map for ionic molecule H_2^+ <p>I want to derive the Hamiltonian of the ion molecule <span class=""math-container"">$H_2^+$</span> by making use of Jordan-Wigner map.
Thus, I used qiskit nature. I wrote down the same command given in qiskit nature. The only difference is that I changed the charge number from 0 to 1. Then it generates following error message</p>
<pre><code>  Input In [6] in &lt;cell line: 2&gt;
    second_q_op = es_problem.second_q_ops()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py:94 in second_q_ops
    driver_result = self.driver.run()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py:179 in run
    return driver.run()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py:410 in run
    self._build_molecule()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py:460 in _build_molecule
    raise QiskitNatureError(&quot;Failed to build the PySCF Molecule object.&quot;) from exc
QiskitNatureError: 'Failed to build the PySCF Molecule object.'

Use %tb to get the full traceback.&quot;
</code></pre>
<p>If you know any method to fix it, please teach me. Thank you for your time.</p>
",qc,map ionic molecule p want derive hamiltonian ion molecule span making use map thus used qiskit nature wrote command given qiskit nature difference changed charge number 0 generates following error message pre code input 6 lt cell line 2 gt file file run return file run file raise qiskitnatureerror quot failed build pyscf molecule quot exc qiskitnatureerror build pyscf molecule object use tb get full quot p know method fix please teach thank,"[(0, 0.25205183), (2, 0.014244092), (3, 0.029854236), (4, 0.019707404), (6, 0.014258608), (8, 0.18096207), (11, 0.022822341), (14, 0.2870673), (17, 0.061602123), (19, 0.11600465)]"
26554,,2022-05-25 08:35:18,1,65,"<p>I am using the IonQ QPU on the Azure quantum provider with a <a href=""https://ionq.com/docs/get-started-with-google-cloud"" rel=""nofollow noreferrer"">Google Cloud API</a> to access the <a href=""https://ionq.com/docs/getting-started-with-native-gates"" rel=""nofollow noreferrer"">native gates</a>. As you can see in the image attached, I got this error:</p>
<pre><code>ConnectionError: ('Connection aborted.', OSError(107, 'Transport endpoint is not connected')) 
</code></pre>
<p><a href=""https://i.sstatic.net/uEuKN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uEuKN.png"" alt=""OSError107"" /></a></p>
<p><strong>What could be the reason for this error?</strong></p>
",Azure quantum error message,<qiskit><programming><ionq><azure-quantum>,0,2,,,"Azure quantum error message <p>I am using the IonQ QPU on the Azure quantum provider with a <a href=""https://ionq.com/docs/get-started-with-google-cloud"" rel=""nofollow noreferrer"">Google Cloud API</a> to access the <a href=""https://ionq.com/docs/getting-started-with-native-gates"" rel=""nofollow noreferrer"">native gates</a>. As you can see in the image attached, I got this error:</p>
<pre><code>ConnectionError: ('Connection aborted.', OSError(107, 'Transport endpoint is not connected')) 
</code></pre>
<p><a href=""https://i.sstatic.net/uEuKN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uEuKN.png"" alt=""OSError107"" /></a></p>
<p><strong>What could be the reason for this error?</strong></p>
",qc,azure quantum error message p using ionq qpu azure quantum provider https nofollow noreferrer google cloud api access https nofollow noreferrer native gates see image attached got error pre code connectionerror aborted oserror 107 endpoint connected p https nofollow noreferrer img https oserror107 p strong could reason error,"[(4, 0.3894131), (8, 0.08304686), (14, 0.500294), (17, 0.023618065)]"
26561,,2022-05-25 16:17:33,1,37,"<p>I am currently working on an SAT Solver using quantum computing. However, since current quantum computers are limited to a few qubits, I am in need of examples ranging from 4-30 variables. I know of a webpage that has DIMACS Files for 50+ variables but not less. Anyone know how to find ones with lesser variables?</p>
",DIMACS Examples with few variables,<qiskit><programming>,0,0,,,"DIMACS Examples with few variables <p>I am currently working on an SAT Solver using quantum computing. However, since current quantum computers are limited to a few qubits, I am in need of examples ranging from 4-30 variables. I know of a webpage that has DIMACS Files for 50+ variables but not less. Anyone know how to find ones with lesser variables?</p>
",qc,dimacs examples variables p currently working sat solver using quantum computing however since current quantum computers limited qubits need examples ranging variables know webpage dimacs files variables less anyone know find ones lesser variables,"[(1, 0.3177182), (7, 0.16075097), (8, 0.40817088), (13, 0.072356924), (17, 0.036341168)]"
26582,26583.0,2022-05-26 18:13:11,3,996,"<p>An erasure error is a heralded error that completely destroys a qubit (e.g. resets it or maximally mixes it). The qubit is gone but you <em>are told</em> it's gone. How do I simulate this kind of error using stim?</p>
",How do I perform an erasure error in stim?,<stim>,2,1,,,"How do I perform an erasure error in stim? <p>An erasure error is a heralded error that completely destroys a qubit (e.g. resets it or maximally mixes it). The qubit is gone but you <em>are told</em> it's gone. How do I simulate this kind of error using stim?</p>
",qc,perform erasure error stim p erasure error heralded error completely destroys qubit resets maximally mixes qubit gone em told gone simulate kind error using stim,"[(3, 0.074806534), (5, 0.36362836), (10, 0.08775884), (11, 0.04160002), (17, 0.17165767), (18, 0.2547566)]"
26601,26602.0,2022-05-27 14:47:18,1,962,"<p>I am trying to run the following circuit:</p>
<pre><code>from qiskit.circuit import ParameterVector, QuantumCircuit
p = qiskit.circuit.ParameterVector('p', 2)
th = qiskit.circuit.ParameterVector('th', 2)

circuit = qiskit.circuit.QuantumCircuit(2)
circuit.rx(p[0], 0) 
circuit.ry(p[1], 1)
circuit.ry(th[1], 1)
circuit.ry(th[0], 1)

qc = transpile(circuit, backend)
</code></pre>
<p>I want to pass parameters from two different lists, inp[0] and theta, each of length 2, like so:</p>
<pre><code>bind_dict = {}
j = 0
for key in qc.parameters:
    while j &lt;= 1: #this is the number of inputs, at the moment we have two inputs
        bind_dict[key] = inp[0][j]
        j+=1
    k = 0
    bind_dict[key] = theta[k]

qc.assign_parameters(bind_dict)
qobj = assemble(qc, shots = 10)
</code></pre>
<p>I get the following error:</p>
<pre><code>Traceback (most recent call last):
  Input In [316] in &lt;cell line: 1&gt;
    qobj = assemble(qc, shots = 10)
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:205 in assemble
    bound_experiments, run_config = _expand_parameters(
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:596 in _expand_parameters
    raise QiskitError(
QiskitError: 'Mismatch between run_config.parameter_binds and all circuit parameters.
Parameter binds: [] Circuit parameters: [ParameterView([ParameterVectorElement(p[0]),     
ParameterVectorElement(p[1]), ParameterVectorElement(th[0]),   
ParameterVectorElement(th[1])])]'

Use %tb to get the full traceback.
</code></pre>
<p>It does not seem to assign the parameters to the circuit?</p>
",Qiskit: Mismatch between run_config.parameter_binds and all circuit parameters,<qiskit><circuit-construction><quantum-circuit>,1,0,,,"Qiskit: Mismatch between run_config.parameter_binds and all circuit parameters <p>I am trying to run the following circuit:</p>
<pre><code>from qiskit.circuit import ParameterVector, QuantumCircuit
p = qiskit.circuit.ParameterVector('p', 2)
th = qiskit.circuit.ParameterVector('th', 2)

circuit = qiskit.circuit.QuantumCircuit(2)
circuit.rx(p[0], 0) 
circuit.ry(p[1], 1)
circuit.ry(th[1], 1)
circuit.ry(th[0], 1)

qc = transpile(circuit, backend)
</code></pre>
<p>I want to pass parameters from two different lists, inp[0] and theta, each of length 2, like so:</p>
<pre><code>bind_dict = {}
j = 0
for key in qc.parameters:
    while j &lt;= 1: #this is the number of inputs, at the moment we have two inputs
        bind_dict[key] = inp[0][j]
        j+=1
    k = 0
    bind_dict[key] = theta[k]

qc.assign_parameters(bind_dict)
qobj = assemble(qc, shots = 10)
</code></pre>
<p>I get the following error:</p>
<pre><code>Traceback (most recent call last):
  Input In [316] in &lt;cell line: 1&gt;
    qobj = assemble(qc, shots = 10)
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:205 in assemble
    bound_experiments, run_config = _expand_parameters(
  File /opt/conda/lib/python3.8/site-packages/qiskit/compiler/assembler.py:596 in _expand_parameters
    raise QiskitError(
QiskitError: 'Mismatch between run_config.parameter_binds and all circuit parameters.
Parameter binds: [] Circuit parameters: [ParameterView([ParameterVectorElement(p[0]),     
ParameterVectorElement(p[1]), ParameterVectorElement(th[0]),   
ParameterVectorElement(th[1])])]'

Use %tb to get the full traceback.
</code></pre>
<p>It does not seem to assign the parameters to the circuit?</p>
",qc,qiskit mismatch circuit parameters p trying run following circuit pre code import parametervector quantumcircuit p p 2 th 2 circuit 2 p 0 0 p 1 1 th 1 1 th 0 1 qc transpile circuit backend p want pass parameters two different lists inp 0 theta length 2 like pre code j 0 key j lt 1 number inputs moment two inputs key inp 0 j k 0 key theta k qobj assemble qc shots 10 p get following error pre code traceback recent call last input 316 lt cell line 1 gt qobj assemble qc shots 10 file assemble file raise qiskiterror qiskiterror circuit parameters parameter binds circuit parameters parameterview parametervectorelement p 0 parametervectorelement p 1 parametervectorelement th 0 parametervectorelement th 1 use tb get full traceback p seem assign parameters circuit,"[(0, 0.52999127), (2, 0.16171017), (14, 0.21966778), (16, 0.030766841), (17, 0.040622417)]"
26694,26695.0,2022-06-02 14:18:18,2,112,"<p><a href=""https://i.sstatic.net/d4JtD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/d4JtD.png"" alt=""enter image description here"" /></a></p>
<p>Does the barrier here won't simplify the circuit between the two H-gates?</p>
",what's the point of the first barrier in this circuit?,<qiskit><quantum-gate>,1,2,,,"what's the point of the first barrier in this circuit? <p><a href=""https://i.sstatic.net/d4JtD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/d4JtD.png"" alt=""enter image description here"" /></a></p>
<p>Does the barrier here won't simplify the circuit between the two H-gates?</p>
",qc,point first barrier circuit p https nofollow noreferrer img https enter image description p barrier wo simplify circuit two,"[(4, 0.93767506), (17, 0.052948475)]"
26715,,2022-06-03 14:09:24,2,45,"<p>I'm trying to do a comparison between the classical way to do portfolio selection with Markovitz and the quantum counterpart. With Markovitz I'm able to generate an output representing the best combination, for a specific criterion, and the weights associated to each share. Using a quantum optimization algorithm I only see the value of the objective function for each combination. How can I evaluate the weights of the shares of the selected portfolio?</p>
",How can I evaluate the weights of different shares in a portfolio optimization problem?,<qiskit><optimization><quantum-computing-for-finance>,0,1,,,"How can I evaluate the weights of different shares in a portfolio optimization problem? <p>I'm trying to do a comparison between the classical way to do portfolio selection with Markovitz and the quantum counterpart. With Markovitz I'm able to generate an output representing the best combination, for a specific criterion, and the weights associated to each share. Using a quantum optimization algorithm I only see the value of the objective function for each combination. How can I evaluate the weights of the shares of the selected portfolio?</p>
",qc,evaluate weights different shares portfolio optimization problem p trying comparison classical way portfolio selection markovitz quantum counterpart markovitz able generate output representing best combination specific criterion weights associated share using quantum optimization algorithm see value objective function combination evaluate weights shares selected portfolio,"[(1, 0.11149291), (8, 0.5894552), (14, 0.18817611), (17, 0.068715304), (18, 0.038330592)]"
26858,38465.0,2022-06-13 10:31:43,2,60,"<p>In <a href=""https://arxiv.org/pdf/1106.1445.pdf"" rel=""nofollow noreferrer"">this</a> set of notes, pg. 177, the quantum erasure channel (which does nothing to a transmitted state with probability <span class=""math-container"">$1-\varepsilon$</span> and 'erases' it with probability <span class=""math-container"">$\varepsilon$</span>) is defined as the operation
<span class=""math-container"">$$
\mathcal{E}(\rho)=(1-\varepsilon)\rho+\varepsilon|e\rangle\langle e|
$$</span>
where <span class=""math-container"">$|e\rangle$</span> is a state orthogonal to the entire input Hilbert space (i.e. <span class=""math-container"">$\mathcal{E}\,:\,L(\mathcal{H}_{2})\to L(\mathcal{H}_{2}\oplus\text{Span}(|e\rangle)$</span>, where <span class=""math-container"">$L(\ldots)$</span> refers to the space of operators on a Hilbert space). I'm trying to generalise this to the scenario where the input Hilbert space is not necessarily the space of a qubit; rather it's a space with tensor product structure <span class=""math-container"">$\mathcal{H}=\mathcal{H}_{A}\otimes\mathcal{H}_{\overline{A}}$</span>, and the channel should 'erase' the <span class=""math-container"">$\overline{A}$</span> subsystem with probability <span class=""math-container"">$\varepsilon$</span>. My attempt at doing so is the operation
<span class=""math-container"">$$
\mathcal{E}(\rho)\stackrel{?}{=}(1-\varepsilon)\rho+\varepsilon\,\text{Tr}_{\overline{A}}(\rho)\oplus|e\rangle\langle e|
$$</span>
I'm unconvinced that this is a valid operation, as the term involving the partial trace <span class=""math-container"">$\text{Tr}_{\overline{A}}(\rho)\oplus|e\rangle\langle e|$</span> seems to have support on a different Hilbert space to the <span class=""math-container"">$\rho$</span> term - specifically, <span class=""math-container"">$\rho$</span> has support on the full space<span class=""math-container"">$(\mathcal{H}_{A}\otimes\mathcal{H}_{\overline{A}})\oplus\text{Span}(|e\rangle)$</span>, but the partial trace term is only supported on <span class=""math-container"">$\mathcal{H}_{A}\oplus\text{Span}(|e\rangle)$</span>. My question is therefore whether (a) this channel is indeed not allowable and (b) if not, is a channel describing the scenario I'm interested in even possible? It's easy enough to do it in the case where the <span class=""math-container"">$\overline{A}$</span> subsystem is erased <em>with certainty</em> (so we can drop the 'error flag' <span class=""math-container"">$|e\rangle$</span> in the output space), in which case the operation looks like
<span class=""math-container"">$$
\mathcal{E}(\rho)=\text{Tr}_{\overline{A}}(\rho)
$$</span>
which is easy to work with and clearly valid, but is the above generalisation even possible to describe by a standard quantum operation?</p>
",Validity of a quantum operation for generalised state erasure,<error-correction><quantum-operation>,1,0,,,"Validity of a quantum operation for generalised state erasure <p>In <a href=""https://arxiv.org/pdf/1106.1445.pdf"" rel=""nofollow noreferrer"">this</a> set of notes, pg. 177, the quantum erasure channel (which does nothing to a transmitted state with probability <span class=""math-container"">$1-\varepsilon$</span> and 'erases' it with probability <span class=""math-container"">$\varepsilon$</span>) is defined as the operation
<span class=""math-container"">$$
\mathcal{E}(\rho)=(1-\varepsilon)\rho+\varepsilon|e\rangle\langle e|
$$</span>
where <span class=""math-container"">$|e\rangle$</span> is a state orthogonal to the entire input Hilbert space (i.e. <span class=""math-container"">$\mathcal{E}\,:\,L(\mathcal{H}_{2})\to L(\mathcal{H}_{2}\oplus\text{Span}(|e\rangle)$</span>, where <span class=""math-container"">$L(\ldots)$</span> refers to the space of operators on a Hilbert space). I'm trying to generalise this to the scenario where the input Hilbert space is not necessarily the space of a qubit; rather it's a space with tensor product structure <span class=""math-container"">$\mathcal{H}=\mathcal{H}_{A}\otimes\mathcal{H}_{\overline{A}}$</span>, and the channel should 'erase' the <span class=""math-container"">$\overline{A}$</span> subsystem with probability <span class=""math-container"">$\varepsilon$</span>. My attempt at doing so is the operation
<span class=""math-container"">$$
\mathcal{E}(\rho)\stackrel{?}{=}(1-\varepsilon)\rho+\varepsilon\,\text{Tr}_{\overline{A}}(\rho)\oplus|e\rangle\langle e|
$$</span>
I'm unconvinced that this is a valid operation, as the term involving the partial trace <span class=""math-container"">$\text{Tr}_{\overline{A}}(\rho)\oplus|e\rangle\langle e|$</span> seems to have support on a different Hilbert space to the <span class=""math-container"">$\rho$</span> term - specifically, <span class=""math-container"">$\rho$</span> has support on the full space<span class=""math-container"">$(\mathcal{H}_{A}\otimes\mathcal{H}_{\overline{A}})\oplus\text{Span}(|e\rangle)$</span>, but the partial trace term is only supported on <span class=""math-container"">$\mathcal{H}_{A}\oplus\text{Span}(|e\rangle)$</span>. My question is therefore whether (a) this channel is indeed not allowable and (b) if not, is a channel describing the scenario I'm interested in even possible? It's easy enough to do it in the case where the <span class=""math-container"">$\overline{A}$</span> subsystem is erased <em>with certainty</em> (so we can drop the 'error flag' <span class=""math-container"">$|e\rangle$</span> in the output space), in which case the operation looks like
<span class=""math-container"">$$
\mathcal{E}(\rho)=\text{Tr}_{\overline{A}}(\rho)
$$</span>
which is easy to work with and clearly valid, but is the above generalisation even possible to describe by a standard quantum operation?</p>
",qc,validity quantum operation generalised state erasure p https nofollow noreferrer set notes pg 177 quantum erasure channel nothing transmitted state probability span probability span defined operation span e span state orthogonal entire input hilbert space span e l h 2 l h 2 span span l refers space operators hilbert space trying generalise scenario input hilbert space necessarily space qubit rather space tensor product structure span h h h channel span subsystem probability span attempt operation span e tr unconvinced valid operation term involving partial trace span tr seems support different hilbert space span term specifically span support full space span h h span partial trace term supported span h span question therefore whether channel indeed allowable b channel describing scenario interested even possible easy enough case span subsystem erased em certainty drop flag span output space case operation looks like span e tr easy work clearly valid generalisation even possible describe standard quantum operation,"[(3, 0.9029798), (9, 0.055008233), (17, 0.033164777)]"
26883,27096.0,2022-06-14 16:55:29,2,180,"<p>It is known that for degradable channels <span class=""math-container"">$\mathcal{N}$</span> and <span class=""math-container"">$\mathcal{M}$</span>, the single-letter quantum capacity is aditive (<a href=""https://arxiv.org/pdf/1505.00907.pdf"" rel=""nofollow noreferrer"">Potential Capacities of Quantum Channels</a>), i.e.
<span class=""math-container"">\begin{equation}
Q^{(1)}(\mathcal{N}\otimes\mathcal{M}) = Q^{(1)}(\mathcal{N}) + Q^{(1)}(\mathcal{M}).
\end{equation}</span></p>
<p>I am unsure if this kind of results can be extrapolated to the setting of anti-degradable channels, that is, is it true that for <span class=""math-container"">$\mathcal{N}$</span> and <span class=""math-container"">$\mathcal{M}$</span> anti-degradable the quantum capacity equals zero (additive)? i.e.
<span class=""math-container"">\begin{equation}
Q^{(1)}(\mathcal{N}\otimes\mathcal{M}) = Q^{(1)}(\mathcal{N}) + Q^{(1)}(\mathcal{M})=0?
\end{equation}</span>
Moreover, would the following be also true: let <span class=""math-container"">$\mathcal{N}$</span> be a degradable channel and <span class=""math-container"">$\mathcal{M}$</span> an anti-degradable channel, then,
<span class=""math-container"">\begin{equation}
Q^{(1)}(\mathcal{N}\otimes\mathcal{M}) = Q^{(1)}(\mathcal{N}) + Q^{(1)}(\mathcal{M})=Q^{(1)}(\mathcal{N})?
\end{equation}</span></p>
<p>I have been looking in the literature for results of this type and have not found anything. Also, if this are not true in general, is it possible that they are true for particular channel, for example, if we have two amplitude damping channels, one with the damping parameter in the degradable region and the other with the damping parameter in the antidegradable region.</p>
",Additivity of degradable and anti-degradable quantum capacities,<information-theory><noise><channel-capacity>,1,1,,,"Additivity of degradable and anti-degradable quantum capacities <p>It is known that for degradable channels <span class=""math-container"">$\mathcal{N}$</span> and <span class=""math-container"">$\mathcal{M}$</span>, the single-letter quantum capacity is aditive (<a href=""https://arxiv.org/pdf/1505.00907.pdf"" rel=""nofollow noreferrer"">Potential Capacities of Quantum Channels</a>), i.e.
<span class=""math-container"">\begin{equation}
Q^{(1)}(\mathcal{N}\otimes\mathcal{M}) = Q^{(1)}(\mathcal{N}) + Q^{(1)}(\mathcal{M}).
\end{equation}</span></p>
<p>I am unsure if this kind of results can be extrapolated to the setting of anti-degradable channels, that is, is it true that for <span class=""math-container"">$\mathcal{N}$</span> and <span class=""math-container"">$\mathcal{M}$</span> anti-degradable the quantum capacity equals zero (additive)? i.e.
<span class=""math-container"">\begin{equation}
Q^{(1)}(\mathcal{N}\otimes\mathcal{M}) = Q^{(1)}(\mathcal{N}) + Q^{(1)}(\mathcal{M})=0?
\end{equation}</span>
Moreover, would the following be also true: let <span class=""math-container"">$\mathcal{N}$</span> be a degradable channel and <span class=""math-container"">$\mathcal{M}$</span> an anti-degradable channel, then,
<span class=""math-container"">\begin{equation}
Q^{(1)}(\mathcal{N}\otimes\mathcal{M}) = Q^{(1)}(\mathcal{N}) + Q^{(1)}(\mathcal{M})=Q^{(1)}(\mathcal{N})?
\end{equation}</span></p>
<p>I have been looking in the literature for results of this type and have not found anything. Also, if this are not true in general, is it possible that they are true for particular channel, for example, if we have two amplitude damping channels, one with the damping parameter in the degradable region and the other with the damping parameter in the antidegradable region.</p>
",qc,additivity degradable quantum capacities p known degradable channels span n span quantum capacity aditive https nofollow noreferrer potential capacities quantum channels span equation 1 n 1 n 1 equation p unsure kind results extrapolated setting channels true span n span quantum capacity equals zero additive span equation 1 n 1 n 1 equation moreover would following also true let span n degradable channel span channel span equation 1 n 1 n 1 1 n equation p looking literature results type found anything also true general possible true particular channel example two amplitude damping channels one damping parameter degradable region damping parameter antidegradable,"[(2, 0.07921096), (3, 0.6847278), (8, 0.08598062), (9, 0.11914657), (17, 0.029357526)]"
26889,26892.0,2022-06-15 00:25:57,2,461,"<p>I'm trying to save and load large circuits from files in Stim. For example, if I use a generated surface code from the intro notebook</p>
<pre><code>import stim

circuit = stim.Circuit.generated(
    &quot;surface_code:unrotated_memory_z&quot;,
    rounds=100,
    distance=3,
    after_clifford_depolarization=0.001,
    after_reset_flip_probability=0.001,
    before_measure_flip_probability=0.001,
    before_round_data_depolarization=0.001
)
</code></pre>
<p>The way I would currently save this is with</p>
<pre><code>with open('saved_circuit.stim', 'w') as f:
    f.write(circuit.__str__())
</code></pre>
<p>And then read it with</p>
<pre><code>circuit_file = open('saved_circuit.stim', 'r')
circuit_text = circuit_file.read()
circuit_file.close()

circuit = stim.Circuit()
circuit.append_from_stim_program_text(circuit_text)
</code></pre>
<p>This works fine and all, but I got the feeling that because they went through the trouble of defining the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/file_format_stim_circuit.md#the-stim-circuit-file-format-stim"" rel=""nofollow noreferrer"">stim circuit file format (.stim)</a>, it seemed that there would be simple methods like <code>circuit.save('filename.stim')</code> or <code>circuit.load('filename.stim')</code>. But I'm not having any luck finding any methods of the like. Right now my only solution is to define functions that do this, which is not a challenge, but just wondering if it's already an option.</p>
",Read/Write circuit to file in Stim,<stim>,1,0,,,"Read/Write circuit to file in Stim <p>I'm trying to save and load large circuits from files in Stim. For example, if I use a generated surface code from the intro notebook</p>
<pre><code>import stim

circuit = stim.Circuit.generated(
    &quot;surface_code:unrotated_memory_z&quot;,
    rounds=100,
    distance=3,
    after_clifford_depolarization=0.001,
    after_reset_flip_probability=0.001,
    before_measure_flip_probability=0.001,
    before_round_data_depolarization=0.001
)
</code></pre>
<p>The way I would currently save this is with</p>
<pre><code>with open('saved_circuit.stim', 'w') as f:
    f.write(circuit.__str__())
</code></pre>
<p>And then read it with</p>
<pre><code>circuit_file = open('saved_circuit.stim', 'r')
circuit_text = circuit_file.read()
circuit_file.close()

circuit = stim.Circuit()
circuit.append_from_stim_program_text(circuit_text)
</code></pre>
<p>This works fine and all, but I got the feeling that because they went through the trouble of defining the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/file_format_stim_circuit.md#the-stim-circuit-file-format-stim"" rel=""nofollow noreferrer"">stim circuit file format (.stim)</a>, it seemed that there would be simple methods like <code>circuit.save('filename.stim')</code> or <code>circuit.load('filename.stim')</code>. But I'm not having any luck finding any methods of the like. Right now my only solution is to define functions that do this, which is not a challenge, but just wondering if it's already an option.</p>
",qc,circuit file stim p trying save load large circuits files stim example use generated surface code intro notebook pre code import stim circuit quot quot p way would currently save pre code open w f p read pre code open r circuit p works fine got feeling went trouble defining https nofollow noreferrer stim circuit file format seemed would simple methods like code code luck finding methods like right solution define functions challenge wondering already,"[(0, 0.08193142), (4, 0.048514195), (5, 0.08268027), (13, 0.07068779), (14, 0.5821289), (17, 0.04184021), (19, 0.09048721)]"
26927,26932.0,2022-06-17 13:12:29,0,1473,"<p>I am a student and I am trying to use qiskit nature in order to calculate the ground state energy of a molecule. My probelm is that when I try to run the simulation an error message comes out:</p>
<pre><code>Traceback (most recent call last):
  Input In [7] in &lt;cell line: 4&gt;
    res = calc.solve(es_problem)
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/algorithms/ground_state_solvers/ground_state_eigensolver.py:93 in solve
    second_q_ops = problem.second_q_ops()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py:94 in second_q_ops
    driver_result = self.driver.run()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py:173 in run
    driver_class = ElectronicStructureDriverType.driver_class_from_type(
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py:84 in driver_class_from_type
    class_obj.check_installed()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py:382 in check_installed
    raise MissingOptionalLibraryError(
MissingOptionalLibraryError: The 'PySCF' library is required to use 'PySCFDriver'. You can install it with 'pip install 'qiskit-nature[pyscf]''.  See https://pyscf.org/install.html.
</code></pre>
<p>I have installed PySCF using qiskit-nature[pyscf] and I also followed the instructions on pyscf.org , but the message keeps coming out, even if everything is already installed. Where I am doing the mistake?
The code I am trying to run is the tutorial: <a href=""https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html</a></p>
",Help on PySCF library,<qiskit><vqe>,3,2,,,"Help on PySCF library <p>I am a student and I am trying to use qiskit nature in order to calculate the ground state energy of a molecule. My probelm is that when I try to run the simulation an error message comes out:</p>
<pre><code>Traceback (most recent call last):
  Input In [7] in &lt;cell line: 4&gt;
    res = calc.solve(es_problem)
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/algorithms/ground_state_solvers/ground_state_eigensolver.py:93 in solve
    second_q_ops = problem.second_q_ops()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/problems/second_quantization/electronic/electronic_structure_problem.py:94 in second_q_ops
    driver_result = self.driver.run()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py:173 in run
    driver_class = ElectronicStructureDriverType.driver_class_from_type(
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/electronic_structure_molecule_driver.py:84 in driver_class_from_type
    class_obj.check_installed()
  File /opt/conda/lib/python3.8/site-packages/qiskit_nature/drivers/second_quantization/pyscfd/pyscfdriver.py:382 in check_installed
    raise MissingOptionalLibraryError(
MissingOptionalLibraryError: The 'PySCF' library is required to use 'PySCFDriver'. You can install it with 'pip install 'qiskit-nature[pyscf]''.  See https://pyscf.org/install.html.
</code></pre>
<p>I have installed PySCF using qiskit-nature[pyscf] and I also followed the instructions on pyscf.org , but the message keeps coming out, even if everything is already installed. Where I am doing the mistake?
The code I am trying to run is the tutorial: <a href=""https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html</a></p>
",qc,help pyscf library p student trying use qiskit nature order calculate ground state energy molecule probelm try run simulation error message comes pre code traceback recent call last input 7 lt cell line 4 gt res file solve file file run file file raise missingoptionallibraryerror missingoptionallibraryerror library required use install install pyscf see https p installed pyscf using pyscf also followed instructions message keeps coming even everything already installed mistake code trying run tutorial https nofollow noreferrer https,"[(0, 0.42797074), (4, 0.107887246), (6, 0.019979265), (8, 0.18013015), (14, 0.17160319), (17, 0.039444074), (19, 0.051255878)]"
26931,,2022-06-17 14:59:00,0,197,"<p>Is there any way to get the quantum gate values more precisely in qiskit?</p>
<p>For example, if I want to create 1/√3[|00⟩+|01⟩+|11⟩]. By using initialize() I get the following circuit by using the draw() command.
<a href=""https://i.sstatic.net/erEWk.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/erEWk.png"" alt=""enter image description here"" /></a></p>
<p>However, I would like to know the more precise value of the first argument of R() i.e. 1.23 in R(1.23,pi/2) e.g. it could be 1.228967</p>
<p>Can we generate details files of angles of quantum circuits?</p>
<p>Here is the code for that:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.transpiler.passes import Decompose

qc = QuantumCircuit(2)
initial_state = np.array([1, 1, 0, 1], dtype=float)
initial_state /= np.linalg.norm(initial_state)
qc.initialize(initial_state)
qc.decompose().decompose().decompose().decompose().draw(&quot;mpl&quot;)
</code></pre>
",How to get precise angle values in Qiskit while using initialize() function to generate arbitrary quantum state?,<qiskit><initialization>,3,0,,,"How to get precise angle values in Qiskit while using initialize() function to generate arbitrary quantum state? <p>Is there any way to get the quantum gate values more precisely in qiskit?</p>
<p>For example, if I want to create 1/√3[|00⟩+|01⟩+|11⟩]. By using initialize() I get the following circuit by using the draw() command.
<a href=""https://i.sstatic.net/erEWk.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/erEWk.png"" alt=""enter image description here"" /></a></p>
<p>However, I would like to know the more precise value of the first argument of R() i.e. 1.23 in R(1.23,pi/2) e.g. it could be 1.228967</p>
<p>Can we generate details files of angles of quantum circuits?</p>
<p>Here is the code for that:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.transpiler.passes import Decompose

qc = QuantumCircuit(2)
initial_state = np.array([1, 1, 0, 1], dtype=float)
initial_state /= np.linalg.norm(initial_state)
qc.initialize(initial_state)
qc.decompose().decompose().decompose().decompose().draw(&quot;mpl&quot;)
</code></pre>
",qc,get precise angle values qiskit using initialize function generate arbitrary quantum state p way get quantum gate values precisely qiskit p example want create using initialize get following circuit using draw command https nofollow noreferrer img https enter image description p however would like know precise value first argument r r could p generate details files angles quantum circuits p code pre code import numpy np qiskit import quantumcircuit import decompose qc quantumcircuit 2 1 1 0 1 quot mpl quot,"[(0, 0.29995397), (2, 0.05815774), (4, 0.17717387), (9, 0.09218092), (14, 0.3334506), (17, 0.014588696), (19, 0.02289294)]"
26966,26967.0,2022-06-20 03:36:24,1,237,"<p>I've been reading about the standard phase estimation from the Qiskit tutorial and got stuck in interpreting the final state representation. What does the state <span class=""math-container"">$|2^t\theta\rangle$</span> mean? Is that the binary representation of the most probable state?
Thanks for the help!
<a href=""https://i.sstatic.net/T7EIw.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/T7EIw.png"" alt=""enter image description here"" /></a></p>
",How can I understand the notation for the final state of QPE algorithm?,<quantum-phase-estimation>,2,0,,,"How can I understand the notation for the final state of QPE algorithm? <p>I've been reading about the standard phase estimation from the Qiskit tutorial and got stuck in interpreting the final state representation. What does the state <span class=""math-container"">$|2^t\theta\rangle$</span> mean? Is that the binary representation of the most probable state?
Thanks for the help!
<a href=""https://i.sstatic.net/T7EIw.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/T7EIw.png"" alt=""enter image description here"" /></a></p>
",qc,understand notation final state qpe algorithm p reading standard phase estimation qiskit tutorial got stuck interpreting final state representation state span mean binary representation probable state thanks help https nofollow noreferrer img https enter image description,"[(4, 0.51262337), (7, 0.12696658), (13, 0.16059926), (17, 0.039468244), (18, 0.15619779)]"
26970,26974.0,2022-06-20 09:39:00,2,790,"<p>Qiskit seems to use matplotlib for rendering bloch spheres under the hood. Therefore, it would be nice if we could also make use of matplotlib's subplot technique.</p>
<p>I would like to implement subplots, each containing a bloch sphere (with different vectors), like the plot matrix in <a href=""https://matplotlib.org/stable/gallery/lines_bars_and_markers/eventplot_demo.html#sphx-glr-gallery-lines-bars-and-markers-eventplot-demo-py"" rel=""nofollow noreferrer"">this example</a>. I would be very grateful for a short help.</p>
<p>The result should look something like this at the end of the day:</p>
<p><a href=""https://i.sstatic.net/UMBo1m.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UMBo1m.jpg"" alt=""enter image description here"" /></a></p>
",How to implement subplots (several blochsphere plots) using qiskit?,<qiskit><programming><bloch-sphere><matrix-representation>,1,2,,,"How to implement subplots (several blochsphere plots) using qiskit? <p>Qiskit seems to use matplotlib for rendering bloch spheres under the hood. Therefore, it would be nice if we could also make use of matplotlib's subplot technique.</p>
<p>I would like to implement subplots, each containing a bloch sphere (with different vectors), like the plot matrix in <a href=""https://matplotlib.org/stable/gallery/lines_bars_and_markers/eventplot_demo.html#sphx-glr-gallery-lines-bars-and-markers-eventplot-demo-py"" rel=""nofollow noreferrer"">this example</a>. I would be very grateful for a short help.</p>
<p>The result should look something like this at the end of the day:</p>
<p><a href=""https://i.sstatic.net/UMBo1m.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UMBo1m.jpg"" alt=""enter image description here"" /></a></p>
",qc,implement subplots several blochsphere plots using qiskit p qiskit seems use matplotlib rendering bloch spheres hood therefore would nice could also make use matplotlib subplot p would like implement subplots containing bloch sphere different vectors like plot matrix https nofollow noreferrer example would grateful short p result look something like end day p https nofollow noreferrer img https enter image description,"[(0, 0.03990851), (4, 0.3341607), (8, 0.041813403), (11, 0.016534438), (13, 0.28024784), (14, 0.26641375), (17, 0.01860585)]"
27027,,2022-06-23 17:56:27,1,260,"<p>Why is it said that Portfolio Optimization is a  good case for quantum computing?
Is it only speed? IF speed is the only benefit, why cant we build more powerful supercompuetrs?</p>
",Why can quantum computing help in Portfolio Optimization?,<quantum-algorithms><quantum-computing-for-finance>,1,2,,,"Why can quantum computing help in Portfolio Optimization? <p>Why is it said that Portfolio Optimization is a  good case for quantum computing?
Is it only speed? IF speed is the only benefit, why cant we build more powerful supercompuetrs?</p>
",qc,quantum computing help portfolio optimization p said portfolio optimization good case quantum computing speed speed benefit cant build powerful supercompuetrs,"[(1, 0.14802527), (2, 0.055710927), (8, 0.6529865), (9, 0.061088186), (17, 0.074361436)]"
27107,,2022-06-27 13:33:08,1,39,"<p>I am studying Universal quantum cloning machines. I have found that two imperfect clones can be generated with fidelity of 83.33%. Where can we use these imperfect clones in quantum worlds? Can we use them for QKD for example?</p>
",Applications that support low fidelity qubits generated by UQCM,<qiskit><applications><no-cloning-theorem><cloning>,0,1,,,"Applications that support low fidelity qubits generated by UQCM <p>I am studying Universal quantum cloning machines. I have found that two imperfect clones can be generated with fidelity of 83.33%. Where can we use these imperfect clones in quantum worlds? Can we use them for QKD for example?</p>
",qc,applications support low fidelity qubits generated uqcm p studying universal quantum cloning machines found two imperfect clones generated fidelity use imperfect clones quantum worlds use qkd example,"[(8, 0.58327544), (9, 0.06753403), (14, 0.2629326), (15, 0.03890914), (17, 0.041598145)]"
27136,,2022-06-29 14:43:27,0,85,"<p>I have got a 2-qubit circuit with the following instructions:</p>
<pre><code>qc = QuantumCircuit(2,2)
qc.ry(2.1285844174659494, 0)
qc.u3(2.263106783376567, 0.3206834870221442, 0, 1)
qc.cx(1,0)
qc.u3(0.18291493410636106, -0.3915870470928269, 0.0, 0)
qc.cx(1,0)
qc.rz(0.17181884984660947, 0)
</code></pre>
<p>I guess I can reduce <em>cx</em> gates because <em>cx</em> commutes with <em>u3</em>. I check it via qiskit and numpy:</p>
<pre><code>qc_ = QuantumCircuit(2)
qc_.u3(0.18291493410636106, -0.3915870470928269, 0.0, 1)
op1 = Operator(qc_.to_instruction()).data

qc_ = QuantumCircuit(2)
qc_.cx(1, 0)
op2 = Operator(qc_.to_instruction()).data
print((np.multiply(op1, op2) == np.multiply(op2, op1)).all())
</code></pre>
<p>The result is <em>True</em>.</p>
<p>However, the state fidelity of the original circuit and circuit without cx gates is 0.884. Do I understand correctly that I can remove the <em>cx</em> gates as far as <em>cx</em> and <em>u3</em> can be permuted?</p>
",Commutative operators,<quantum-operation><matrix-representation><fidelity>,0,6,,,"Commutative operators <p>I have got a 2-qubit circuit with the following instructions:</p>
<pre><code>qc = QuantumCircuit(2,2)
qc.ry(2.1285844174659494, 0)
qc.u3(2.263106783376567, 0.3206834870221442, 0, 1)
qc.cx(1,0)
qc.u3(0.18291493410636106, -0.3915870470928269, 0.0, 0)
qc.cx(1,0)
qc.rz(0.17181884984660947, 0)
</code></pre>
<p>I guess I can reduce <em>cx</em> gates because <em>cx</em> commutes with <em>u3</em>. I check it via qiskit and numpy:</p>
<pre><code>qc_ = QuantumCircuit(2)
qc_.u3(0.18291493410636106, -0.3915870470928269, 0.0, 1)
op1 = Operator(qc_.to_instruction()).data

qc_ = QuantumCircuit(2)
qc_.cx(1, 0)
op2 = Operator(qc_.to_instruction()).data
print((np.multiply(op1, op2) == np.multiply(op2, op1)).all())
</code></pre>
<p>The result is <em>True</em>.</p>
<p>However, the state fidelity of the original circuit and circuit without cx gates is 0.884. Do I understand correctly that I can remove the <em>cx</em> gates as far as <em>cx</em> and <em>u3</em> can be permuted?</p>
",qc,commutative operators p got circuit following instructions pre code qc quantumcircuit 0 0 1 0 0 p guess reduce em cx gates em cx commutes em u3 check via qiskit numpy pre code quantumcircuit 2 1 op1 operator quantumcircuit 2 1 0 op2 operator print op1 op2 op2 op1 p result em true p however state fidelity original circuit circuit without cx gates understand correctly remove em cx gates far em cx em u3 permuted,"[(0, 0.19025402), (2, 0.24550034), (3, 0.10143923), (6, 0.08096298), (9, 0.20430245), (14, 0.14967705), (17, 0.026110945)]"
27159,27160.0,2022-07-01 13:35:44,2,591,"<p>This is the official demo(<a href=""https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/visualization-exposition.ipynb"" rel=""nofollow noreferrer"">https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/visualization-exposition.ipynb</a>). But after I run it, there is no error, but I can't output the graph of the Bloch sphere. This does not match the case. In addition, use display(b.b.make_sphere()) to return None. Something magical happened, what a beautiful day.</p>
<pre><code>%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from qutip import *

H = sigmaz() + 0.3 * sigmay()
e_ops = [sigmax(), sigmay(), sigmaz()]
times = np.linspace(0, 10, 100)
psi0 = (basis(2, 0) + basis(2, 1)).unit()
result = mesolve(H, psi0, times, [], e_ops)
plot_expectation_values(result)
b = Bloch()
b.add_vectors(expect(H.unit(), e_ops))
b.add_points(result.expect, meth='l')
b.make_sphere()
</code></pre>
<p>my output:</p>
<p><a href=""https://i.sstatic.net/QcZAf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QcZAf.png"" alt=""enter image description here"" /></a></p>
<p>demo's output:</p>
<p><a href=""https://i.sstatic.net/FrA6M.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/FrA6M.png"" alt=""enter image description here"" /></a></p>
","Why does qutip run without errors, but cannot output a Bloch sphere graph?",<qutip>,1,0,,,"Why does qutip run without errors, but cannot output a Bloch sphere graph? <p>This is the official demo(<a href=""https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/visualization-exposition.ipynb"" rel=""nofollow noreferrer"">https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/visualization-exposition.ipynb</a>). But after I run it, there is no error, but I can't output the graph of the Bloch sphere. This does not match the case. In addition, use display(b.b.make_sphere()) to return None. Something magical happened, what a beautiful day.</p>
<pre><code>%matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from qutip import *

H = sigmaz() + 0.3 * sigmay()
e_ops = [sigmax(), sigmay(), sigmaz()]
times = np.linspace(0, 10, 100)
psi0 = (basis(2, 0) + basis(2, 1)).unit()
result = mesolve(H, psi0, times, [], e_ops)
plot_expectation_values(result)
b = Bloch()
b.add_vectors(expect(H.unit(), e_ops))
b.add_points(result.expect, meth='l')
b.make_sphere()
</code></pre>
<p>my output:</p>
<p><a href=""https://i.sstatic.net/QcZAf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QcZAf.png"" alt=""enter image description here"" /></a></p>
<p>demo's output:</p>
<p><a href=""https://i.sstatic.net/FrA6M.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/FrA6M.png"" alt=""enter image description here"" /></a></p>
",qc,qutip run without errors output bloch sphere graph p official demo https nofollow noreferrer https run error ca output graph bloch sphere match case addition use display return none something magical happened beautiful pre code matplotlib inline import pandas pd import plt import numpy np qutip import h sigmaz sigmay sigmax sigmay sigmaz times 0 10 100 psi0 basis 2 0 basis 2 1 result mesolve h psi0 times result b bloch expect l p output p https nofollow noreferrer img https enter image description p demo output p https nofollow noreferrer img https enter image description,"[(0, 0.34569785), (2, 0.123758525), (4, 0.35488787), (5, 0.0148504665), (11, 0.027095601), (13, 0.10792878), (17, 0.024428703)]"
27161,,2022-07-01 16:55:43,1,33,"<p>I am looking over the TSP on Qiskit's Textbook, link below:
<a href=""https://qiskit.org/textbook/ch-paper-implementations/tsp.html#Building-the-Components-"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-paper-implementations/tsp.html#Building-the-Components-</a>
In the general strategy part of the documentation, they convert the matrices U1 -&gt; U4 to Uj, and in this step they introduce four variables, a through d, that when manipulated, can, as I understand, lead back to the original matrices U1-4. The text is in the picture below:
<a href=""https://i.sstatic.net/fG5H7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fG5H7.png"" alt=""enter image description here"" /></a></p>
<p>Should I be interpretting this less literally, or is the task to keep going finding these values a through d. I think I just got lost around here, any help is appreciated, thanks in advance!</p>
","On the Qiskit Txtbk page for TSP, how does the initial phase matrix work?",<qiskit><linear-algebra><phase-kickback>,0,0,,,"On the Qiskit Txtbk page for TSP, how does the initial phase matrix work? <p>I am looking over the TSP on Qiskit's Textbook, link below:
<a href=""https://qiskit.org/textbook/ch-paper-implementations/tsp.html#Building-the-Components-"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-paper-implementations/tsp.html#Building-the-Components-</a>
In the general strategy part of the documentation, they convert the matrices U1 -&gt; U4 to Uj, and in this step they introduce four variables, a through d, that when manipulated, can, as I understand, lead back to the original matrices U1-4. The text is in the picture below:
<a href=""https://i.sstatic.net/fG5H7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fG5H7.png"" alt=""enter image description here"" /></a></p>
<p>Should I be interpretting this less literally, or is the task to keep going finding these values a through d. I think I just got lost around here, any help is appreciated, thanks in advance!</p>
",qc,qiskit txtbk page tsp initial phase matrix work p looking tsp qiskit textbook link https nofollow noreferrer https general strategy part documentation convert matrices u1 gt u4 uj step introduce four variables manipulated understand lead back original matrices text picture https nofollow noreferrer img https enter image description p interpretting less literally task keep going finding values think got lost around help appreciated thanks advance,"[(4, 0.41472948), (8, 0.13394286), (9, 0.04090554), (11, 0.09020719), (13, 0.2166519), (17, 0.017274028), (18, 0.08412815)]"
27186,,2022-07-04 05:28:59,2,38,"<p>No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively</p>
",No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively?,<no-cloning-theorem>,0,2,,,"No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively? <p>No clonning states that one cannot clone any arbitrary given state. But can we have a device that can create same superposition state repetatively</p>
",qc,clonning states one clone arbitrary given state device create superposition state repetatively p clonning states one clone arbitrary given state device create superposition state repetatively,"[(8, 0.1047484), (16, 0.082909115), (17, 0.08749123), (18, 0.71793354)]"
27214,27229.0,2022-07-05 18:55:53,1,147,"<p>I am currently researching the Traveling Salesman Problem, and it is known that Quantum Computers have a strong likelihood to increase the efficiency of TSPs in industry. I have mainly heard this in regard to Quantum Annealing processors however, like D-Wave's, which is not publicly available (for free) like IBMQ or (to an extent) Quantinuum.
I have been using Grover's search algorithm to design the circuit, and only have work on paper at this point, but is it even possible to solve a 4 node TSP with 5-20 qubits over the cloud? Even if I just wanted to represent locations or distances in binary, I can't think of a way with that few bits to represent the locations/distances. I have considered switching to a different algorithm besides Grover's, but currently can't see how that few qubits can represent all of the variables even basic TSPs exhibit.
Thank you in advance for your help!</p>
",Can Quantum Computers (not simulators) solve a 4 node TSP?,<quantum-algorithms>,1,1,,,"Can Quantum Computers (not simulators) solve a 4 node TSP? <p>I am currently researching the Traveling Salesman Problem, and it is known that Quantum Computers have a strong likelihood to increase the efficiency of TSPs in industry. I have mainly heard this in regard to Quantum Annealing processors however, like D-Wave's, which is not publicly available (for free) like IBMQ or (to an extent) Quantinuum.
I have been using Grover's search algorithm to design the circuit, and only have work on paper at this point, but is it even possible to solve a 4 node TSP with 5-20 qubits over the cloud? Even if I just wanted to represent locations or distances in binary, I can't think of a way with that few bits to represent the locations/distances. I have considered switching to a different algorithm besides Grover's, but currently can't see how that few qubits can represent all of the variables even basic TSPs exhibit.
Thank you in advance for your help!</p>
",qc,quantum computers simulators solve 4 node tsp p currently researching traveling salesman problem known quantum computers strong likelihood increase efficiency tsps industry mainly heard regard quantum annealing processors however like publicly available free like ibmq extent quantinuum using grover search algorithm design circuit work paper point even possible solve 4 node tsp qubits cloud even wanted represent locations distances binary ca think way bits represent considered switching different algorithm besides grover currently ca see qubits represent variables even basic tsps exhibit thank advance help,"[(1, 0.1549015), (4, 0.017570646), (6, 0.018602269), (7, 0.098762296), (8, 0.28591877), (9, 0.11141395), (11, 0.037792124), (13, 0.16910443), (14, 0.090586305), (17, 0.014114611)]"
27233,,2022-07-07 04:46:54,0,230,"<p>I have a very simple qubo problem:</p>
<pre><code>Minimize
 obj: - 0.015284386652 x_0 + 0.000780952145 x_1 + [ 0.002541388592 x_0^2
      + 0.000146804433 x_0*x_1 + 0.000258486713 x_1^2 ]/2
Subject To
 c0: x_0 + x_1 = 1

Bounds
 0 &lt;= x_0 &lt;= 1
 0 &lt;= x_1 &lt;= 1

Binaries
 x_0 x_1
End
</code></pre>
<p>Then I got below ISING matrix from above QUBO:</p>
<pre><code>[[ 0.51530274+0.j  0.        +0.j  0.        +0.j  0.        +0.j]
 [ 0.        +0.j -0.51624963+0.j  0.        +0.j  0.        +0.j]
 [ 0.        +0.j  0.        +0.j -0.50132575+0.j  0.        +0.j]
 [ 0.        +0.j  0.        +0.j  0.        +0.j  0.50227264+0.j]]
</code></pre>
<p>and this is ISING formula:</p>
<pre><code>(PauliSumOp(SparsePauliOp(['IZ', 'ZI', 'ZZ'],coeffs=[ 6.98849562e-03+0.j, -4.73448305e-04+0.j,  5.08787690e-01+0.j]),coeff=1.0), 0.5022359414602106)
</code></pre>
<p>Then I submit my ISING matrix to a ISING solver, then this is what is get for best result <code>[0,1,1,0]</code>. SO how can I convert this result from ISING result to QUBO result ?</p>
<p>Below is my full code, using qiskit:</p>
<pre><code>from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.converters import QuadraticProgramToQubo
import datetime

num_assets = 2
seed = 123
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()
q = 0.5
budget = 1
portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()
print(qp)

conv = QuadraticProgramToQubo()
problem2 = conv.convert(qp)
test = problem2.to_ising()
print(test)
print(problem2)
matrix = test[0].to_matrix()
print(matrix)
</code></pre>
",qiskit: convert from ising result to qubo result?,<qiskit><quantum-state><hamiltonian-simulation><qubo><qiskit-runtime>,1,1,,,"qiskit: convert from ising result to qubo result? <p>I have a very simple qubo problem:</p>
<pre><code>Minimize
 obj: - 0.015284386652 x_0 + 0.000780952145 x_1 + [ 0.002541388592 x_0^2
      + 0.000146804433 x_0*x_1 + 0.000258486713 x_1^2 ]/2
Subject To
 c0: x_0 + x_1 = 1

Bounds
 0 &lt;= x_0 &lt;= 1
 0 &lt;= x_1 &lt;= 1

Binaries
 x_0 x_1
End
</code></pre>
<p>Then I got below ISING matrix from above QUBO:</p>
<pre><code>[[ 0.51530274+0.j  0.        +0.j  0.        +0.j  0.        +0.j]
 [ 0.        +0.j -0.51624963+0.j  0.        +0.j  0.        +0.j]
 [ 0.        +0.j  0.        +0.j -0.50132575+0.j  0.        +0.j]
 [ 0.        +0.j  0.        +0.j  0.        +0.j  0.50227264+0.j]]
</code></pre>
<p>and this is ISING formula:</p>
<pre><code>(PauliSumOp(SparsePauliOp(['IZ', 'ZI', 'ZZ'],coeffs=[ 6.98849562e-03+0.j, -4.73448305e-04+0.j,  5.08787690e-01+0.j]),coeff=1.0), 0.5022359414602106)
</code></pre>
<p>Then I submit my ISING matrix to a ISING solver, then this is what is get for best result <code>[0,1,1,0]</code>. SO how can I convert this result from ISING result to QUBO result ?</p>
<p>Below is my full code, using qiskit:</p>
<pre><code>from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.converters import QuadraticProgramToQubo
import datetime

num_assets = 2
seed = 123
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()
q = 0.5
budget = 1
portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()
print(qp)

conv = QuadraticProgramToQubo()
problem2 = conv.convert(qp)
test = problem2.to_ising()
print(test)
print(problem2)
matrix = test[0].to_matrix()
print(matrix)
</code></pre>
",qc,qiskit convert ising result qubo result p simple qubo problem pre code minimize obj subject c0 1 bounds 0 lt lt 1 0 lt lt 1 binaries end p got ising matrix qubo pre code 0 0 0 0 0 0 0 0 0 0 0 0 p ising formula pre code paulisumop sparsepauliop p submit ising matrix ising solver get best result code convert result ising result qubo result p full code using qiskit pre code import portfoliooptimization import randomdataprovider import quadraticprogramtoqubo import datetime 2 seed 123 stocks quot ticker quot range data randomdataprovider 2016 1 1 2016 1 30 mu sigma q budget 1 portfolio portfoliooptimization qp print qp conv quadraticprogramtoqubo problem2 qp test print test print problem2 matrix test 0 print matrix,"[(0, 0.5081102), (1, 0.09889606), (2, 0.21875891), (8, 0.024238786), (11, 0.026246784), (14, 0.01306911), (17, 0.10961506)]"
27260,,2022-07-08 14:06:28,1,47,"<p>Consider  a quantum qubit depolarizing channel which takes a quantum state <span class=""math-container"">$\rho$</span> to output</p>
<p><span class=""math-container"">$$N(\rho) = (1-p)\rho + p\frac{\mathbb{1}_2}{2}.$$</span></p>
<p>If I restrict <span class=""math-container"">$\rho$</span> to be either <span class=""math-container"">$\vert0\rangle\langle 0\vert$</span> or <span class=""math-container"">$\vert 1\rangle\langle 1\vert$</span>, then the depolarizing channel outputs</p>
<p><span class=""math-container"">$$N(\vert0\rangle\langle 0\vert) = (1-\frac{p}{2})\vert0\rangle\langle 0\vert + \frac{p}{2}\vert 1\rangle\langle 1\vert$$</span>
<span class=""math-container"">$$N(\vert1\rangle\langle 1\vert) = (1-\frac{p}{2})\vert1\rangle\langle 1\vert + \frac{p}{2}\vert 0\rangle\langle 0\vert.$$</span></p>
<p>That looks like a binary symmetric channel with crossover probability <span class=""math-container"">$\frac{p}{2}$</span>.</p>
<p>I am free to restrict <span class=""math-container"">$\rho$</span> to be a classical superposition i.e. of the form <span class=""math-container"">$q\vert0\rangle\langle 0\vert + (1-q)\vert 1\rangle\langle 1\vert$</span>, then it is clear that I still obtain the same results as a binary symmetric channel.</p>
<p>Is there a communication task where the quantum depolarizing channel is a more powerful resource than a classical BSC? I understand one can do say, entanglement distribution with one but not the other so to make the playing field even, I allow unlimited pre-shared entanglement between Alice and Bob.</p>
<p>Now, I would like to know if Alice and Bob who share depolarizing channels can actually use it to send more information than if they just had a classical BSC.</p>
",Entanglement-assisted communication ability of a quantum depolarizing channel vs. a classical binary symmetric channel,<information-theory><communication><nonclassicality><depolarizing-channel>,0,5,,,"Entanglement-assisted communication ability of a quantum depolarizing channel vs. a classical binary symmetric channel <p>Consider  a quantum qubit depolarizing channel which takes a quantum state <span class=""math-container"">$\rho$</span> to output</p>
<p><span class=""math-container"">$$N(\rho) = (1-p)\rho + p\frac{\mathbb{1}_2}{2}.$$</span></p>
<p>If I restrict <span class=""math-container"">$\rho$</span> to be either <span class=""math-container"">$\vert0\rangle\langle 0\vert$</span> or <span class=""math-container"">$\vert 1\rangle\langle 1\vert$</span>, then the depolarizing channel outputs</p>
<p><span class=""math-container"">$$N(\vert0\rangle\langle 0\vert) = (1-\frac{p}{2})\vert0\rangle\langle 0\vert + \frac{p}{2}\vert 1\rangle\langle 1\vert$$</span>
<span class=""math-container"">$$N(\vert1\rangle\langle 1\vert) = (1-\frac{p}{2})\vert1\rangle\langle 1\vert + \frac{p}{2}\vert 0\rangle\langle 0\vert.$$</span></p>
<p>That looks like a binary symmetric channel with crossover probability <span class=""math-container"">$\frac{p}{2}$</span>.</p>
<p>I am free to restrict <span class=""math-container"">$\rho$</span> to be a classical superposition i.e. of the form <span class=""math-container"">$q\vert0\rangle\langle 0\vert + (1-q)\vert 1\rangle\langle 1\vert$</span>, then it is clear that I still obtain the same results as a binary symmetric channel.</p>
<p>Is there a communication task where the quantum depolarizing channel is a more powerful resource than a classical BSC? I understand one can do say, entanglement distribution with one but not the other so to make the playing field even, I allow unlimited pre-shared entanglement between Alice and Bob.</p>
<p>Now, I would like to know if Alice and Bob who share depolarizing channels can actually use it to send more information than if they just had a classical BSC.</p>
",qc,communication ability quantum depolarizing channel classical binary symmetric channel p consider quantum qubit depolarizing channel takes quantum state span output p span n 1 2 p restrict span either span span depolarizing channel outputs p span n p 2 p 2 span n p 2 p 2 p looks like binary symmetric channel crossover probability span p 2 p free restrict span classical superposition form span clear still obtain results binary symmetric p communication task quantum depolarizing channel powerful resource classical bsc understand one say entanglement distribution one make playing field even allow unlimited entanglement alice p would like know alice bob share depolarizing channels actually use send information classical,"[(1, 0.10453621), (2, 0.036172267), (3, 0.40512496), (8, 0.06699445), (9, 0.049300283), (17, 0.050641414), (18, 0.28603902)]"
27270,,2022-07-08 19:43:40,1,179,"<p>I am going through portfolio optimization using Qiskit. It really looks interesting. The module has both VQE and QAOA algorithms for optimizing the portfolios.</p>
<p>In the VQE based solution the probability of finding the lowest energy state  [1 0 0 1]  (with energy  -0.0149 units) is 0.8456. One can interpret this as the ground state energy
has the highest probability to be found (for the optimization problem we address here).</p>
<p>However, in the QAOA based solution, the probability of find the lowest energy state<br />
[1 0 0 1]  (with energy  -0.0149 units) is  0.1680. This probability of 0.1680 is almost same as the probability of finding other states as can be seen from the table below.
This means the states ([1 0 1 0], [1 1 0 0], [0 0 1 1], [0 1 0 1], [0 1 1 0]) are in equal superposition with the optimal ground state [1 0 0 1]. I find some ambiguity in interpreting
the QAOA result even though both VQE and QAOA give us the same state [1 0 0 1] as the optimal value. Can you please kindly clarify this.</p>
<p>Please let me know if I am not clear or need more information.</p>
<p>The link to the Qiskit portfolio optimization is given below.
<a href=""https://qiskit.org/documentation/finance/tutorials/01_portfolio_optimization.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/finance/tutorials/01_portfolio_optimization.html</a></p>
<p>Qiskit Portfolio Optimization QAOA result.</p>
<p>Optimal: selection [1. 0. 0. 1.], value -0.0149</p>
<p>Full result is as follows:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>selection</th>
<th>Value</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr>
<td>[1 0 0 1]</td>
<td>-0.0149</td>
<td>0.1680</td>
</tr>
<tr>
<td>[1 0 1 0]</td>
<td>-0.0140</td>
<td>0.1679</td>
</tr>
<tr>
<td>[1 1 0 0]</td>
<td>-0.0130</td>
<td>0.1677</td>
</tr>
<tr>
<td>[0 0 1 1]</td>
<td>-0.0010</td>
<td>0.1656</td>
</tr>
<tr>
<td>[0 1 0 1]</td>
<td>0.0002</td>
<td>0.1654</td>
</tr>
<tr>
<td>[0 1 1 0]</td>
<td>0.0008</td>
<td>0.1653</td>
</tr>
<tr>
<td>[1 1 1 1]</td>
<td>4.0656</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 0 0 0]</td>
<td>4.0795</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 1 0 0]</td>
<td>1.0208</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 0 1 1]</td>
<td>1.0049</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 1 1 0]</td>
<td>1.0069</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 1 0 1]</td>
<td>1.0060</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 0 1 0]</td>
<td>1.0197</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 0 0 1]</td>
<td>1.0191</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 0 0 0]</td>
<td>1.0059</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 1 1 1]</td>
<td>1.0199</td>
<td>0.0000</td>
</tr>
</tbody>
</table>
</div>
<p>Thank you</p>
",Interpreting VQE and QAOA based solutions in portfolio optimization,<qiskit><vqe><qaoa><ibm-quantum-devices><quantum-computing-for-finance>,0,2,,,"Interpreting VQE and QAOA based solutions in portfolio optimization <p>I am going through portfolio optimization using Qiskit. It really looks interesting. The module has both VQE and QAOA algorithms for optimizing the portfolios.</p>
<p>In the VQE based solution the probability of finding the lowest energy state  [1 0 0 1]  (with energy  -0.0149 units) is 0.8456. One can interpret this as the ground state energy
has the highest probability to be found (for the optimization problem we address here).</p>
<p>However, in the QAOA based solution, the probability of find the lowest energy state<br />
[1 0 0 1]  (with energy  -0.0149 units) is  0.1680. This probability of 0.1680 is almost same as the probability of finding other states as can be seen from the table below.
This means the states ([1 0 1 0], [1 1 0 0], [0 0 1 1], [0 1 0 1], [0 1 1 0]) are in equal superposition with the optimal ground state [1 0 0 1]. I find some ambiguity in interpreting
the QAOA result even though both VQE and QAOA give us the same state [1 0 0 1] as the optimal value. Can you please kindly clarify this.</p>
<p>Please let me know if I am not clear or need more information.</p>
<p>The link to the Qiskit portfolio optimization is given below.
<a href=""https://qiskit.org/documentation/finance/tutorials/01_portfolio_optimization.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/finance/tutorials/01_portfolio_optimization.html</a></p>
<p>Qiskit Portfolio Optimization QAOA result.</p>
<p>Optimal: selection [1. 0. 0. 1.], value -0.0149</p>
<p>Full result is as follows:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>selection</th>
<th>Value</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr>
<td>[1 0 0 1]</td>
<td>-0.0149</td>
<td>0.1680</td>
</tr>
<tr>
<td>[1 0 1 0]</td>
<td>-0.0140</td>
<td>0.1679</td>
</tr>
<tr>
<td>[1 1 0 0]</td>
<td>-0.0130</td>
<td>0.1677</td>
</tr>
<tr>
<td>[0 0 1 1]</td>
<td>-0.0010</td>
<td>0.1656</td>
</tr>
<tr>
<td>[0 1 0 1]</td>
<td>0.0002</td>
<td>0.1654</td>
</tr>
<tr>
<td>[0 1 1 0]</td>
<td>0.0008</td>
<td>0.1653</td>
</tr>
<tr>
<td>[1 1 1 1]</td>
<td>4.0656</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 0 0 0]</td>
<td>4.0795</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 1 0 0]</td>
<td>1.0208</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 0 1 1]</td>
<td>1.0049</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 1 1 0]</td>
<td>1.0069</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 1 0 1]</td>
<td>1.0060</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 0 1 0]</td>
<td>1.0197</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 0 0 1]</td>
<td>1.0191</td>
<td>0.0000</td>
</tr>
<tr>
<td>[1 0 0 0]</td>
<td>1.0059</td>
<td>0.0000</td>
</tr>
<tr>
<td>[0 1 1 1]</td>
<td>1.0199</td>
<td>0.0000</td>
</tr>
</tbody>
</table>
</div>
<p>Thank you</p>
",qc,interpreting vqe qaoa based solutions portfolio optimization p going portfolio optimization using qiskit really looks interesting module vqe qaoa algorithms optimizing p vqe based solution probability finding lowest energy state 1 0 0 1 energy units one interpret ground state energy highest probability found optimization problem address p however qaoa based solution probability find lowest energy state br 1 0 0 1 energy units probability almost probability finding states seen table means states 1 0 1 0 1 1 0 0 0 0 1 1 0 1 0 1 0 1 1 0 equal superposition optimal ground state 1 0 0 1 find ambiguity interpreting qaoa result even though vqe qaoa give us state 1 0 0 1 optimal value please kindly clarify p please let know clear need p link qiskit portfolio optimization given https nofollow noreferrer https p qiskit portfolio optimization qaoa p optimal selection 1 0 0 1 value p full result follows div table thead tr th selection th value th probability tbody tr td 1 0 0 1 td td tr td 1 0 1 0 td td tr td 1 1 0 0 td td tr td 0 0 1 1 td td tr td 0 1 0 1 td td tr td 0 1 1 0 td td tr td 1 1 1 1 td td tr td 0 0 0 0 td td tr td 0 1 0 0 td td tr td 1 0 1 1 td td tr td 1 1 1 0 td td tr td 1 1 0 1 td td tr td 0 0 1 0 td td tr td 0 0 0 1 td td tr td 1 0 0 0 td td tr td 0 1 1 1 td td p thank,"[(2, 0.36813748), (4, 0.05555336), (7, 0.06939511), (8, 0.06782817), (17, 0.3742037), (18, 0.064409405)]"
27285,,2022-07-10 13:00:23,2,49,"<p>I understand the general idea of information reconciliation and advantage distillation, but I can't find any exposition of the algorithm used, unlike the quantum part of the protocol which is well documented and rather easy mathematically.</p>
",Where can I find a detailled exposition of the Information theoretic part of BB84?,<cryptography><bb84>,1,0,,,"Where can I find a detailled exposition of the Information theoretic part of BB84? <p>I understand the general idea of information reconciliation and advantage distillation, but I can't find any exposition of the algorithm used, unlike the quantum part of the protocol which is well documented and rather easy mathematically.</p>
",qc,find detailled exposition information theoretic part bb84 p understand general idea information reconciliation advantage distillation ca find exposition algorithm used unlike quantum part protocol well documented rather easy,"[(5, 0.04712395), (7, 0.3144825), (8, 0.26579982), (9, 0.057793792), (13, 0.07557268), (14, 0.062495995), (17, 0.076955676), (18, 0.09518098)]"
27305,27323.0,2022-07-12 07:54:01,0,271,"<p>I am trying to design a custom VQE algorithm using qiskit. The main customization of the algorithm is in the minimization of expectation value of the Hamiltonian. To accomplish this, I have used the following code. I have chosen the LiH molecule in sto3g basis.</p>
<p>First, I perform SCF calculation using pyscf just to get the number of orbitals, orbital occupation etc.</p>
<p>Code:</p>
<pre><code>from pyscf import gto, scf, fci
import numpy as np

mol = gto.Mole()
mol.build(atom='Li 0 0 0; H 0 0 1', basis='sto3g', symmetry=1)

mf = scf.RHF(mol)
mf.kernel()
print ('Occupation in MOs: ', mf.mo_occ)
</code></pre>
<p>Output:</p>
<pre><code>converged SCF energy = -7.76736213574856
Occupation in MOs:  [2. 2. 0. 0. 0. 0.]
</code></pre>
<p>Next, I generate the HF reference state and the UCCSD operator.</p>
<pre><code>from qiskit_nature.circuit.library.initial_states.hartree_fock import *
from qiskit_nature.circuit.library.ansatzes import UCC

#Writing the HF state in qubit occupation form 
#The following code gives a circuit to prepare the HF state from the state with all qubits =0
HF = HartreeFock(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True))
#print (HF)

UCC_operator = UCC(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, excitations='sd', qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True), initial_state = HF)
</code></pre>
<p>Then I write down the molecule whose energy needs to be calculated and obtain its Hamiltonian.</p>
<pre><code>from qiskit_nature.drivers import UnitsType, Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem

molecule = Molecule(
    # coordinates are given in Angstrom
    geometry=[
        [&quot;Li&quot;, [0.0, 0.0, 0.0]],
        [&quot;H&quot;, [0.0, 0.0, 1.0]]
    ],
    multiplicity=1,  # = 2*spin + 1
    charge=0,)

driver = ElectronicStructureMoleculeDriver(molecule, basis=&quot;sto3g&quot;, 
                    driver_type=ElectronicStructureDriverType.PYSCF)

problem = ElectronicStructureProblem(driver)
second_q_op = problem.second_q_ops()
qubit_converter = QubitConverter(mapper = JordanWignerMapper(), two_qubit_reduction = True)
Hamiltonian = qubit_converter.convert(second_q_op[0], num_particles=problem.num_particles)
</code></pre>
<p>Now since I am customizing in the minimization part of the VQE algorithm, I will just prepare the VQE instance and then use the <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.VQE.get_energy_evaluation.html#qiskit.algorithms.VQE.get_energy_evaluation"" rel=""nofollow noreferrer""><code>get_energy_evaluation</code></a> method that qiskit provides to use UCCSD-VQE circuit as a parametrized circuit to be evaluated at the desired parameter values.</p>
<pre><code>from qiskit import Aer
from qiskit.algorithms.optimizers import SLSQP
from qiskit.algorithms import VQE

backend = Aer.get_backend('aer_simulator_statevector')
optimizer = SLSQP(maxiter=100)

algorithm = VQE(UCC_operator, optimizer=optimizer, quantum_instance=backend)

energy_eval_func = algorithm.get_energy_evaluation(Hamiltonian, False)
</code></pre>
<p>Now that I have obtained the function to evaluate expectation value of the Hamiltonian of the molecule wrt to a desired UCC state (i.e. T1 and T2 amplitudes), I choose 2 kinds of parameters for the UCC operator and observe the results.</p>
<ol>
<li>All the parameters are equal to 0. This is equivalent to the <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.HFInitialPoint.html#qiskit_nature.algorithms.initial_points.HFInitialPoint"" rel=""nofollow noreferrer""><code>HFInitialpoint</code></a>. I use this as follows.</li>
</ol>
<pre><code>t = UCC_operator.parameters
num_params = len(t)
energy_eval_func(np.zeros(len(t))
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.354893768508214
</code></pre>
<ol start=""2"">
<li>I choose the parameter elements to be MP2 amplitudes. This can be achieved by using <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.MP2InitialPoint.html#qiskit_nature.algorithms.initial_points.MP2InitialPoint"" rel=""nofollow noreferrer""><code>MP2InitialPoint</code></a> as follows.</li>
</ol>
<pre><code>from qiskit_nature.algorithms.initial_points import *

mp2_initial_point = MP2InitialPoint()
mp2_initial_point.compute(UCC_operator, driver_results)
initial_point = mp2_initial_point.to_numpy_array()

energy_eval_func(initial_point)
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.324343952128133
</code></pre>
<p>This is what I do not understand.
<strong>Given that the theoretical energy is -9.371991912791, why is the energy lower for HF initial point than the MP2 initial point?</strong> I was of the opinion that it should have been the other way around. I do not see where have I gone wrong. It would be really helpful if you could clarify this doubt. Thank you.</p>
",Why is HF Initial point seems to be better than MP2 initial point in qiskit?,<qiskit><vqe>,1,0,,,"Why is HF Initial point seems to be better than MP2 initial point in qiskit? <p>I am trying to design a custom VQE algorithm using qiskit. The main customization of the algorithm is in the minimization of expectation value of the Hamiltonian. To accomplish this, I have used the following code. I have chosen the LiH molecule in sto3g basis.</p>
<p>First, I perform SCF calculation using pyscf just to get the number of orbitals, orbital occupation etc.</p>
<p>Code:</p>
<pre><code>from pyscf import gto, scf, fci
import numpy as np

mol = gto.Mole()
mol.build(atom='Li 0 0 0; H 0 0 1', basis='sto3g', symmetry=1)

mf = scf.RHF(mol)
mf.kernel()
print ('Occupation in MOs: ', mf.mo_occ)
</code></pre>
<p>Output:</p>
<pre><code>converged SCF energy = -7.76736213574856
Occupation in MOs:  [2. 2. 0. 0. 0. 0.]
</code></pre>
<p>Next, I generate the HF reference state and the UCCSD operator.</p>
<pre><code>from qiskit_nature.circuit.library.initial_states.hartree_fock import *
from qiskit_nature.circuit.library.ansatzes import UCC

#Writing the HF state in qubit occupation form 
#The following code gives a circuit to prepare the HF state from the state with all qubits =0
HF = HartreeFock(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True))
#print (HF)

UCC_operator = UCC(num_spin_orbitals=len(mf.mo_occ)*2, num_particles=mol.nelec, excitations='sd', qubit_converter=QubitConverter(mapper=JordanWignerMapper(), two_qubit_reduction=True), initial_state = HF)
</code></pre>
<p>Then I write down the molecule whose energy needs to be calculated and obtain its Hamiltonian.</p>
<pre><code>from qiskit_nature.drivers import UnitsType, Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem

molecule = Molecule(
    # coordinates are given in Angstrom
    geometry=[
        [&quot;Li&quot;, [0.0, 0.0, 0.0]],
        [&quot;H&quot;, [0.0, 0.0, 1.0]]
    ],
    multiplicity=1,  # = 2*spin + 1
    charge=0,)

driver = ElectronicStructureMoleculeDriver(molecule, basis=&quot;sto3g&quot;, 
                    driver_type=ElectronicStructureDriverType.PYSCF)

problem = ElectronicStructureProblem(driver)
second_q_op = problem.second_q_ops()
qubit_converter = QubitConverter(mapper = JordanWignerMapper(), two_qubit_reduction = True)
Hamiltonian = qubit_converter.convert(second_q_op[0], num_particles=problem.num_particles)
</code></pre>
<p>Now since I am customizing in the minimization part of the VQE algorithm, I will just prepare the VQE instance and then use the <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.VQE.get_energy_evaluation.html#qiskit.algorithms.VQE.get_energy_evaluation"" rel=""nofollow noreferrer""><code>get_energy_evaluation</code></a> method that qiskit provides to use UCCSD-VQE circuit as a parametrized circuit to be evaluated at the desired parameter values.</p>
<pre><code>from qiskit import Aer
from qiskit.algorithms.optimizers import SLSQP
from qiskit.algorithms import VQE

backend = Aer.get_backend('aer_simulator_statevector')
optimizer = SLSQP(maxiter=100)

algorithm = VQE(UCC_operator, optimizer=optimizer, quantum_instance=backend)

energy_eval_func = algorithm.get_energy_evaluation(Hamiltonian, False)
</code></pre>
<p>Now that I have obtained the function to evaluate expectation value of the Hamiltonian of the molecule wrt to a desired UCC state (i.e. T1 and T2 amplitudes), I choose 2 kinds of parameters for the UCC operator and observe the results.</p>
<ol>
<li>All the parameters are equal to 0. This is equivalent to the <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.HFInitialPoint.html#qiskit_nature.algorithms.initial_points.HFInitialPoint"" rel=""nofollow noreferrer""><code>HFInitialpoint</code></a>. I use this as follows.</li>
</ol>
<pre><code>t = UCC_operator.parameters
num_params = len(t)
energy_eval_func(np.zeros(len(t))
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.354893768508214
</code></pre>
<ol start=""2"">
<li>I choose the parameter elements to be MP2 amplitudes. This can be achieved by using <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.algorithms.initial_points.MP2InitialPoint.html#qiskit_nature.algorithms.initial_points.MP2InitialPoint"" rel=""nofollow noreferrer""><code>MP2InitialPoint</code></a> as follows.</li>
</ol>
<pre><code>from qiskit_nature.algorithms.initial_points import *

mp2_initial_point = MP2InitialPoint()
mp2_initial_point.compute(UCC_operator, driver_results)
initial_point = mp2_initial_point.to_numpy_array()

energy_eval_func(initial_point)
print (energy_eval_func)
</code></pre>
<p>Output:</p>
<pre><code>-9.324343952128133
</code></pre>
<p>This is what I do not understand.
<strong>Given that the theoretical energy is -9.371991912791, why is the energy lower for HF initial point than the MP2 initial point?</strong> I was of the opinion that it should have been the other way around. I do not see where have I gone wrong. It would be really helpful if you could clarify this doubt. Thank you.</p>
",qc,hf initial point seems better mp2 initial point qiskit p trying design custom vqe algorithm using qiskit main customization algorithm minimization expectation value hamiltonian accomplish used following code chosen lih molecule sto3g p first perform scf calculation using pyscf get number orbitals orbital occupation p code pre code pyscf import gto scf fci import numpy np mol 0 0 0 h 0 0 1 mf mol print mos p output pre code converged scf energy occupation mos 2 2 0 0 0 0 p next generate hf reference state uccsd pre code import import ucc writing hf state qubit occupation form following code gives circuit prepare hf state state qubits hf hartreefock 2 print hf ucc 2 hf p write molecule whose energy needs calculated obtain pre code import unitstype molecule import electronicstructuredrivertype electronicstructuremoleculedriver import electronicstructureproblem molecule molecule coordinates given angstrom quot li quot quot h quot 2 spin 1 driver electronicstructuremoleculedriver molecule quot sto3g quot problem electronicstructureproblem driver qubitconverter mapper jordanwignermapper true hamiltonian 0 p since customizing minimization part vqe algorithm prepare vqe instance use https nofollow noreferrer code method qiskit provides use circuit parametrized circuit evaluated desired parameter pre code qiskit import aer import slsqp import vqe backend optimizer slsqp algorithm vqe hamiltonian false p obtained function evaluate expectation value hamiltonian molecule wrt desired ucc state t1 t2 amplitudes choose 2 kinds parameters ucc operator observe ol li parameters equal equivalent https nofollow noreferrer code hfinitialpoint use pre code len len print p output pre code ol 2 li choose parameter elements mp2 amplitudes achieved using https nofollow noreferrer code mp2initialpoint pre code import mp2initialpoint print p output pre code p understand strong given theoretical energy energy lower hf initial point mp2 initial point opinion way around see gone wrong would really helpful could clarify doubt thank,"[(0, 0.32541832), (1, 0.02346823), (2, 0.06900455), (4, 0.08702842), (5, 0.020108752), (7, 0.045891266), (8, 0.1607497), (12, 0.011086986), (14, 0.08364056), (17, 0.07854532), (18, 0.06670976), (19, 0.028049467)]"
27321,,2022-07-13 09:00:26,0,61,"<p>The puzzle is from</p>
<p>Case 1: <a href=""https://qiskit.org/documentation/machine-learning/tutorials/03_quantum_kernel.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/machine-learning/tutorials/03_quantum_kernel.html</a></p>
<p>Case 2: <a href=""https://qiskit.org/documentation/machine-learning/tutorials/08_quantum_kernel_trainer.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/machine-learning/tutorials/08_quantum_kernel_trainer.html</a></p>
<p>Question 1: The above two cases indicate that although parameterized circuits are set, their parameters are all from the data set, so why does Case 2 have a training process?</p>
<p>Question 2: The datasets of case 1 and case 2 are ready, which means that the input of the kernel function is ready, but if the input of the quantum kernel function is uncertain, can the kernel function be dynamically learned? How to achieve it?</p>
<p>Question 3: The kernel function is the theoretical basis in the supervised learning field such as SVM. If the input is unlabeled data X and X1, that is, unsupervised learning, can the quantum kernel method continue to be used?</p>
","Quantum Kernel Method: If the input is the QK provided by the variable qiskit, is it still true?",<qiskit><quantum-enhanced-machine-learning><kernel-methods>,0,2,,,"Quantum Kernel Method: If the input is the QK provided by the variable qiskit, is it still true? <p>The puzzle is from</p>
<p>Case 1: <a href=""https://qiskit.org/documentation/machine-learning/tutorials/03_quantum_kernel.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/machine-learning/tutorials/03_quantum_kernel.html</a></p>
<p>Case 2: <a href=""https://qiskit.org/documentation/machine-learning/tutorials/08_quantum_kernel_trainer.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/machine-learning/tutorials/08_quantum_kernel_trainer.html</a></p>
<p>Question 1: The above two cases indicate that although parameterized circuits are set, their parameters are all from the data set, so why does Case 2 have a training process?</p>
<p>Question 2: The datasets of case 1 and case 2 are ready, which means that the input of the kernel function is ready, but if the input of the quantum kernel function is uncertain, can the kernel function be dynamically learned? How to achieve it?</p>
<p>Question 3: The kernel function is the theoretical basis in the supervised learning field such as SVM. If the input is unlabeled data X and X1, that is, unsupervised learning, can the quantum kernel method continue to be used?</p>
",qc,quantum kernel method input qk provided variable qiskit still true p puzzle p case 1 https nofollow noreferrer https p case 2 https nofollow noreferrer https p question 1 two cases indicate although parameterized circuits set parameters data set case 2 training process p question 2 datasets case 1 case 2 ready means input kernel function ready input quantum kernel function uncertain kernel function dynamically learned achieve p question 3 kernel function theoretical basis supervised learning field svm input unlabeled data x x1 unsupervised learning quantum kernel method continue used,"[(2, 0.086925425), (4, 0.111372046), (8, 0.3033797), (9, 0.04555359), (10, 0.026156489), (13, 0.12233979), (14, 0.29150334), (17, 0.01143682)]"
27326,27327.0,2022-07-13 17:27:52,1,492,"<p>I'm working with QECC using a non-python based platform. I'd like to move the results into python to do calculations that are better handled by packages like qiskit or stim. So the output of the non-python step is a binary matrix that has information about the encoder for the code.</p>
<p>For example, the encoder for the <span class=""math-container"">$[[5,1,3]]$</span> code is represented by a <span class=""math-container"">$10 \times 10$</span> binary matrix <span class=""math-container"">$A=$</span></p>
<pre><code>[[0,0,0,0,0,1,1,1,1,1],
 [1,0,0,0,1,0,0,1,1,0],
 [0,1,0,0,1,1,1,1,0,1],
 [0,0,1,0,1,0,1,1,1,1],
 [0,0,0,1,1,1,1,0,0,0],
 [0,0,0,0,1,0,1,1,0,0],
 [0,0,0,0,0,1,0,0,0,0],
 [0,0,0,0,0,0,1,0,0,0],
 [0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,0,1,0]]
</code></pre>
<p>The first row is the logical <span class=""math-container"">$\bar Z_1$</span>, the next 4 are the stabilizers <span class=""math-container"">$S_1,S_2,S_3,S_4$</span>, the next row is logical <span class=""math-container"">$\bar X_1$</span>, and the final 4 are destabilizers <span class=""math-container"">$D_1,D_2,D_3,D_4$</span>. Each row corresponds to the Pauli string of the operator; so <span class=""math-container"">$\bar Z_1=X_1X_2X_3X_4X_5$</span>,<span class=""math-container"">$S_1=Z_2X_3X_4Z_5$</span>;... I can write this binary matrix to a text file or I can reformat things different to make it easier to pull into python.</p>
<p>My question is this : starting with this binary matrix, how would I generate a corresponding tableau in qiskit or stim? once I have that tableau, how do I generate a circuit that implements it? This would essentially give me a circuit encoder for the code.</p>
",how to go from matrix to tableau to circuit in qiskit or stim,<qiskit><circuit-construction><error-correction><stim>,1,0,,,"how to go from matrix to tableau to circuit in qiskit or stim <p>I'm working with QECC using a non-python based platform. I'd like to move the results into python to do calculations that are better handled by packages like qiskit or stim. So the output of the non-python step is a binary matrix that has information about the encoder for the code.</p>
<p>For example, the encoder for the <span class=""math-container"">$[[5,1,3]]$</span> code is represented by a <span class=""math-container"">$10 \times 10$</span> binary matrix <span class=""math-container"">$A=$</span></p>
<pre><code>[[0,0,0,0,0,1,1,1,1,1],
 [1,0,0,0,1,0,0,1,1,0],
 [0,1,0,0,1,1,1,1,0,1],
 [0,0,1,0,1,0,1,1,1,1],
 [0,0,0,1,1,1,1,0,0,0],
 [0,0,0,0,1,0,1,1,0,0],
 [0,0,0,0,0,1,0,0,0,0],
 [0,0,0,0,0,0,1,0,0,0],
 [0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,0,1,0]]
</code></pre>
<p>The first row is the logical <span class=""math-container"">$\bar Z_1$</span>, the next 4 are the stabilizers <span class=""math-container"">$S_1,S_2,S_3,S_4$</span>, the next row is logical <span class=""math-container"">$\bar X_1$</span>, and the final 4 are destabilizers <span class=""math-container"">$D_1,D_2,D_3,D_4$</span>. Each row corresponds to the Pauli string of the operator; so <span class=""math-container"">$\bar Z_1=X_1X_2X_3X_4X_5$</span>,<span class=""math-container"">$S_1=Z_2X_3X_4Z_5$</span>;... I can write this binary matrix to a text file or I can reformat things different to make it easier to pull into python.</p>
<p>My question is this : starting with this binary matrix, how would I generate a corresponding tableau in qiskit or stim? once I have that tableau, how do I generate a circuit that implements it? This would essentially give me a circuit encoder for the code.</p>
",qc,go matrix tableau circuit qiskit stim p working qecc using based platform like move results python calculations better handled packages like qiskit stim output step binary matrix information encoder p example encoder span code represented span 10 10 binary matrix span pre code p first row logical span next 4 stabilizers span next row logical span final 4 destabilizers span row corresponds pauli string operator span span write binary matrix text file reformat things different make easier pull p question starting binary matrix would generate corresponding tableau qiskit stim tableau generate circuit implements would essentially give circuit encoder,"[(3, 0.17374314), (5, 0.10264004), (6, 0.03789771), (11, 0.054581925), (13, 0.14335303), (14, 0.47591493), (17, 0.010531335)]"
27335,28870.0,2022-07-14 09:36:19,4,113,"<p>A basic assumption of various error correction threshold theorems is that the probability of an error exponentially decreases with the weight of the error.</p>
<p>One of the selling features of ion traps is that in a single trap, the qubits have all-to-all connectivity. For, e.g., LDPC codes, this is essential. But does this also mean that there is a much higher chance of high-weight, coherent errors (e.g., cross-talk)?</p>
",High-weight errors from ion trap crosstalk,<error-correction><ion-trap-quantum-computing><trapped-ion>,1,0,,,"High-weight errors from ion trap crosstalk <p>A basic assumption of various error correction threshold theorems is that the probability of an error exponentially decreases with the weight of the error.</p>
<p>One of the selling features of ion traps is that in a single trap, the qubits have all-to-all connectivity. For, e.g., LDPC codes, this is essential. But does this also mean that there is a much higher chance of high-weight, coherent errors (e.g., cross-talk)?</p>
",qc,errors ion trap crosstalk p basic assumption various error correction threshold theorems probability error exponentially decreases weight p one selling features ion traps single trap qubits connectivity ldpc codes essential also mean much higher chance coherent errors,"[(4, 0.21123992), (5, 0.42789027), (8, 0.11664951), (9, 0.06391139), (11, 0.023138234), (17, 0.055468958), (18, 0.068407714), (19, 0.02977517)]"
27362,27363.0,2022-07-17 21:25:23,6,1578,"<p>As in <a href=""https://quantumcomputing.stackexchange.com/questions/12507/compiling-a-classical-function-to-a-quantum-circuit-in-practice"">Compiling a classical function to a quantum circuit in practice</a>, as far as my understanding goes, it is known that any classical function can be implemented as a quantum circuit. So given <span class=""math-container"">$f(x)=x$</span>, there should be some quantum circuit <span class=""math-container"">$Q_f$</span> such that, up to garbage bits and normalization, <span class=""math-container"">$$
\sum_{x}|x,0^k\rangle \xrightarrow{\mathit{Q_f}} \sum_{x}|x,x\rangle.
$$</span>
However, the no-cloning theorem suggests this is not possible, which leaves me confused. What is going on?</p>
","Is effective quantum cloning possible, given that any classical function can be implemented as a quantum circuit?",<quantum-state><unitarity><no-cloning-theorem>,3,1,,,"Is effective quantum cloning possible, given that any classical function can be implemented as a quantum circuit? <p>As in <a href=""https://quantumcomputing.stackexchange.com/questions/12507/compiling-a-classical-function-to-a-quantum-circuit-in-practice"">Compiling a classical function to a quantum circuit in practice</a>, as far as my understanding goes, it is known that any classical function can be implemented as a quantum circuit. So given <span class=""math-container"">$f(x)=x$</span>, there should be some quantum circuit <span class=""math-container"">$Q_f$</span> such that, up to garbage bits and normalization, <span class=""math-container"">$$
\sum_{x}|x,0^k\rangle \xrightarrow{\mathit{Q_f}} \sum_{x}|x,x\rangle.
$$</span>
However, the no-cloning theorem suggests this is not possible, which leaves me confused. What is going on?</p>
",qc,effective quantum cloning possible given classical function implemented quantum circuit p https compiling classical function quantum circuit practice far understanding goes known classical function implemented quantum circuit given span f x quantum circuit span garbage bits normalization span x x however theorem suggests possible leaves confused going,"[(1, 0.24614103), (9, 0.39510906), (10, 0.20028628), (14, 0.13403307), (17, 0.021251248)]"
27396,27397.0,2022-07-19 22:00:46,3,327,"<p>I'd like to understand how the signs in the tableau are calculated and if there's a way to force them to be +. Here's an example that shows what I see : (this is an encoder for <span class=""math-container"">$[[8,3,3]]$</span> code)</p>
<pre><code>import stim

def circuit_to_tableau(circuit: stim.Circuit) -&gt; stim.Tableau:
 s=stim.TableauSimulator()
 s.do_circuit(circuit)
 return s.current_inverse_tableau() ** -1

circuit=stim.Circuit('''
 CX 5 4
 CX 6 5
 CX 7 6
 H 0
 CX 0 4
 CX 0 5
 CX 0 6
 CZ 0 6
 H 1
 CZ 1 0
 CX 1 4
 CX 1 5
 CZ 1 5
 CX 1 7
 H 2
 CZ 2 0
 CX 2 4
 CZ 2 5
 CX 2 6
 CX 2 7
 CZ 2 7
 H 3
 CZ 3 0
 CZ 3 1
 CX 3 5
 CX 3 6
 CZ 3 6
 CX 3 7
 CZ 3 7
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
sampler=circuit.compile_sampler()
print(sampler.sample(shots=8))
tableau=circuit_to_tableau(circuit)
print(repr(tableau))
</code></pre>
<p>running it gives this result :</p>
<pre><code>[[False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+ZZZZ_XX_&quot;),
        stim.PauliString(&quot;+Z_Z___XX&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;-ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+___Z_ZZZ&quot;),
        stim.PauliString(&quot;+ZZ____ZZ&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
<p>Why did the fourth z stabilizer pick up a minus sign? these are all stabilizers, destabilizers, and logical for the code and everything works the same with + for all of them.</p>
<p>(PS. Let me know if there's a better place to post Stim specific questions...I have several about syntax ... and I don't want to clutter things here)</p>
<p>Here's another approach to get the encoding circuit using the routines described in a previous post <a href=""https://quantumcomputing.stackexchange.com/questions/27326/how-to-go-from-matrix-to-tableau-to-circuit-in-qiskit-or-stim"">how to go from matrix to tableau to circuit in qiskit or stim</a></p>
<pre><code> matrix=[
 [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
 [0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0],
 [0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0],
 [1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0],
 [0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0],
 [0,0,1,0,1,0,1,1,1,0,1,0,0,1,0,1],
 [0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0],
 [0,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0],
 [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1]]
 tableau = bit_matrix_to_tableau(matrix)
 print(repr(tableau))
 circuit1 = tableau_to_circuit_simple(tableau)
 circuit2=stim.Circuit('''
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
 circuit=circuit1+circuit2
 sampler=circuit.compile_sampler()
 print(sampler.sample(shots=8))
 tableau=circuit_to_tableau(circuit)
 print(repr(tableau))
</code></pre>
<p>This gives a + for all stabilizers when the tableau is generated from a matrix and even when you go matrix -&gt; tableau -&gt; circuit -&gt; tableau</p>
<pre><code>stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
[[False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
",Stim: How are the signs in tableau calculated and how to force them to +,<stim>,2,5,,,"Stim: How are the signs in tableau calculated and how to force them to + <p>I'd like to understand how the signs in the tableau are calculated and if there's a way to force them to be +. Here's an example that shows what I see : (this is an encoder for <span class=""math-container"">$[[8,3,3]]$</span> code)</p>
<pre><code>import stim

def circuit_to_tableau(circuit: stim.Circuit) -&gt; stim.Tableau:
 s=stim.TableauSimulator()
 s.do_circuit(circuit)
 return s.current_inverse_tableau() ** -1

circuit=stim.Circuit('''
 CX 5 4
 CX 6 5
 CX 7 6
 H 0
 CX 0 4
 CX 0 5
 CX 0 6
 CZ 0 6
 H 1
 CZ 1 0
 CX 1 4
 CX 1 5
 CZ 1 5
 CX 1 7
 H 2
 CZ 2 0
 CX 2 4
 CZ 2 5
 CX 2 6
 CX 2 7
 CZ 2 7
 H 3
 CZ 3 0
 CZ 3 1
 CX 3 5
 CX 3 6
 CZ 3 6
 CX 3 7
 CZ 3 7
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
sampler=circuit.compile_sampler()
print(sampler.sample(shots=8))
tableau=circuit_to_tableau(circuit)
print(repr(tableau))
</code></pre>
<p>running it gives this result :</p>
<pre><code>[[False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]
 [False False False  True False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+ZZZZ_XX_&quot;),
        stim.PauliString(&quot;+Z_Z___XX&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;-ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+___Z_ZZZ&quot;),
        stim.PauliString(&quot;+ZZ____ZZ&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
<p>Why did the fourth z stabilizer pick up a minus sign? these are all stabilizers, destabilizers, and logical for the code and everything works the same with + for all of them.</p>
<p>(PS. Let me know if there's a better place to post Stim specific questions...I have several about syntax ... and I don't want to clutter things here)</p>
<p>Here's another approach to get the encoding circuit using the routines described in a previous post <a href=""https://quantumcomputing.stackexchange.com/questions/27326/how-to-go-from-matrix-to-tableau-to-circuit-in-qiskit-or-stim"">how to go from matrix to tableau to circuit in qiskit or stim</a></p>
<pre><code> matrix=[
 [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
 [0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0],
 [0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,0],
 [0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0],
 [1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0],
 [0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0],
 [0,0,1,0,1,0,1,1,1,0,1,0,0,1,0,1],
 [0,0,0,1,0,1,1,1,1,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0],
 [0,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0],
 [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1]]
 tableau = bit_matrix_to_tableau(matrix)
 print(repr(tableau))
 circuit1 = tableau_to_circuit_simple(tableau)
 circuit2=stim.Circuit('''
 MPP Y0*Z2*Z3*X4*X5*Y6
 MPP Z0*Y1*Z3*X4*Y5*X7
 MPP Z0*Y2*X4*Z5*X6*Y7
 MPP Z0*Z1*X3*X5*Y6*Y7
 MPP Z0*Z1*Z2*Z3*Z4*Z5*Z6*Z7
 ''')
 circuit=circuit1+circuit2
 sampler=circuit.compile_sampler()
 print(sampler.sample(shots=8))
 tableau=circuit_to_tableau(circuit)
 print(repr(tableau))
</code></pre>
<p>This gives a + for all stabilizers when the tableau is generated from a matrix and even when you go matrix -&gt; tableau -&gt; circuit -&gt; tableau</p>
<pre><code>stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
[[False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]
 [False False False False False]]
stim.Tableau.from_conjugated_generators(
    xs=[
        stim.PauliString(&quot;+Z_______&quot;),
        stim.PauliString(&quot;+_Z______&quot;),
        stim.PauliString(&quot;+__Z_____&quot;),
        stim.PauliString(&quot;+___Z____&quot;),
        stim.PauliString(&quot;+____X___&quot;),
        stim.PauliString(&quot;+_ZZ_XX__&quot;),
        stim.PauliString(&quot;+Z__ZX_X_&quot;),
        stim.PauliString(&quot;+__ZZX__X&quot;),
    ],
    zs=[
        stim.PauliString(&quot;+Y_ZZXXY_&quot;),
        stim.PauliString(&quot;+ZY_ZXY_X&quot;),
        stim.PauliString(&quot;+Z_Y_XZXY&quot;),
        stim.PauliString(&quot;+ZZ_X_XYY&quot;),
        stim.PauliString(&quot;+ZZZZZZZZ&quot;),
        stim.PauliString(&quot;+ZZ_Z_Z__&quot;),
        stim.PauliString(&quot;+Z_ZZ__Z_&quot;),
        stim.PauliString(&quot;+_ZZZ___Z&quot;),
    ],
)
</code></pre>
",qc,stim signs tableau calculated force p like understand signs tableau calculated way force example shows see encoder span code pre code import stim def circuit gt circuit return cx 5 4 cx 6 5 cx 7 6 h 0 cx 0 4 cx 0 5 cx 0 6 cz 0 6 h 1 cz 1 0 cx 1 4 cx 1 5 cz 1 5 cx 1 7 h 2 cz 2 0 cx 2 4 cz 2 5 cx 2 6 cx 2 7 cz 2 7 h 3 cz 3 0 cz 3 1 cx 3 5 cx 3 6 cz 3 6 cx 3 7 cz 3 7 mpp y0 z2 z3 x4 x5 y6 mpp z0 y1 z3 x4 y5 x7 mpp z0 y2 x4 z5 x6 y7 mpp z0 z1 x3 x5 y6 y7 mpp z0 z1 z2 z3 z4 z5 z6 z7 print circuit print repr tableau p running gives result pre code false false false true false false false false true false false false false true false false false false true false false false false true false false false false true false false false false true false false false false true false quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot p fourth z stabilizer pick minus sign stabilizers destabilizers logical code everything works p ps let know better place post stim specific questions several syntax want clutter things p another approach get encoding circuit using routines described previous post https go matrix tableau circuit qiskit stim pre code tableau matrix print repr tableau circuit1 tableau mpp y0 z2 z3 x4 x5 y6 mpp z0 y1 z3 x4 y5 x7 mpp z0 y2 x4 z5 x6 y7 mpp z0 z1 x3 x5 y6 y7 mpp z0 z1 z2 z3 z4 z5 z6 z7 print circuit print repr tableau p gives stabilizers tableau generated matrix even go matrix gt tableau gt circuit gt tableau pre code quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false false quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot quot,"[(0, 0.033190742), (5, 0.023786493), (6, 0.4186969), (8, 0.014226059), (12, 0.07717625), (13, 0.014181036), (14, 0.090660155), (17, 0.027241118), (19, 0.2858093)]"
27495,27518.0,2022-07-27 11:34:50,3,150,"<p>Recently, I have paid attention to some oracle algorithms, such as Grover. Generally speaking, an oracle is a kind of black box, and Grover's algorithm constructs an oracle through quantum circuits. From a higher level, ask the question, which oracles are difficult to design, which ones can be designed, and which ones cannot be designed? What are the laws or mathematical laws that design oracles? What metric is the quantum advantage of oracles measured by?</p>
",What makes oracle algorithms difficult to design and implement?,<qiskit><grovers-algorithm><oracles>,1,0,,,"What makes oracle algorithms difficult to design and implement? <p>Recently, I have paid attention to some oracle algorithms, such as Grover. Generally speaking, an oracle is a kind of black box, and Grover's algorithm constructs an oracle through quantum circuits. From a higher level, ask the question, which oracles are difficult to design, which ones can be designed, and which ones cannot be designed? What are the laws or mathematical laws that design oracles? What metric is the quantum advantage of oracles measured by?</p>
",qc,makes oracle algorithms difficult design implement p recently paid attention oracle algorithms grover generally speaking oracle kind black box grover algorithm constructs oracle quantum circuits higher level ask question oracles difficult design ones designed ones designed laws mathematical laws design oracles metric quantum advantage oracles measured,"[(7, 0.1601756), (8, 0.5077235), (10, 0.084764935), (17, 0.08536737), (18, 0.15864863)]"
27540,27587.0,2022-07-30 07:38:50,2,458,"<p>The <a href=""https://qiskit.org/textbook/ch-algorithms/shor.html#3.-Qiskit-Implementation"" rel=""nofollow noreferrer"">Qiskit textbook</a> shows the following circuit for implementing the phase <span class=""math-container"">$(\frac{s}{r})$</span> estimation stage of Shor's algorithm for factorizing 15:
<a href=""https://i.sstatic.net/5sRK5.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5sRK5.png"" alt=""enter image description here"" /></a>
<br>My understanding is that the register of qubits 8-11 should be initialized to the state <span class=""math-container"">$|1\rangle$</span> which is the sum over <span class=""math-container"">$s \in \{0, .., r-1\}$</span> of the eigenstates<span class=""math-container"">$\frac{1}{\sqrt r}\sum_{k=0}^{r-1}e^{-\frac{2\pi i s k}{r}}|a^k \mod N\rangle$</span> of the modular multiplication operator <span class=""math-container"">$U|y\rangle = |ay \mod N \rangle$</span>.
<br>But the 4-qubit representation of <span class=""math-container"">$|1\rangle$</span> is <span class=""math-container"">$|0001\rangle$</span> and not <span class=""math-container"">$|1000\rangle$</span>. <br>So, shouldn't we set <span class=""math-container"">$q_8$</span> (the lsb of the modular exponentiation circuits) to 1 instead of <span class=""math-container"">$q_{11}$</span>?</p>
",Qiskit textbook: Shor's algorithm,<qiskit><shors-algorithm><quantum-phase-estimation>,1,2,,,"Qiskit textbook: Shor's algorithm <p>The <a href=""https://qiskit.org/textbook/ch-algorithms/shor.html#3.-Qiskit-Implementation"" rel=""nofollow noreferrer"">Qiskit textbook</a> shows the following circuit for implementing the phase <span class=""math-container"">$(\frac{s}{r})$</span> estimation stage of Shor's algorithm for factorizing 15:
<a href=""https://i.sstatic.net/5sRK5.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5sRK5.png"" alt=""enter image description here"" /></a>
<br>My understanding is that the register of qubits 8-11 should be initialized to the state <span class=""math-container"">$|1\rangle$</span> which is the sum over <span class=""math-container"">$s \in \{0, .., r-1\}$</span> of the eigenstates<span class=""math-container"">$\frac{1}{\sqrt r}\sum_{k=0}^{r-1}e^{-\frac{2\pi i s k}{r}}|a^k \mod N\rangle$</span> of the modular multiplication operator <span class=""math-container"">$U|y\rangle = |ay \mod N \rangle$</span>.
<br>But the 4-qubit representation of <span class=""math-container"">$|1\rangle$</span> is <span class=""math-container"">$|0001\rangle$</span> and not <span class=""math-container"">$|1000\rangle$</span>. <br>So, shouldn't we set <span class=""math-container"">$q_8$</span> (the lsb of the modular exponentiation circuits) to 1 instead of <span class=""math-container"">$q_{11}$</span>?</p>
",qc,qiskit textbook shor algorithm p https nofollow noreferrer qiskit textbook shows following circuit implementing phase span r estimation stage shor algorithm factorizing 15 https nofollow noreferrer img https enter image description br understanding register qubits initialized state span sum span 0 eigenstates span 1 r k r modular multiplication operator span n br representation span span span br set span lsb modular exponentiation circuits 1 instead span 11,"[(2, 0.028289529), (3, 0.35817462), (4, 0.3736553), (6, 0.040023558), (7, 0.098000124), (13, 0.08228066), (17, 0.017640388)]"
27599,27606.0,2022-08-03 04:55:36,2,97,"<p>In this <a href=""https://doi.org/10.1103/PhysRevLett.127.040505"" rel=""nofollow noreferrer"">first paper</a> <a href=""https://doi.org/10.48550/arXiv.2009.04092"" rel=""nofollow noreferrer"">(arXiv)</a> on the Rodeo algorithm, there is an argument on the second page about the suppression of &quot;spectral weights&quot; that I don't really understand.</p>
<p>In short, the algorithm is designed to find energy eigenvalues and prepare energy eigenstates. There are <span class=""math-container"">$N$</span> ancilla qubits, starting in the <span class=""math-container"">$| 1 \rangle$</span> state, which become entangled with the system of interest through stochastic controlled time evolution operators. As shown on page 2, for a system initially in the eigenstate with energy <span class=""math-container"">$E_{\rm obj}$</span>, the final probability of measuring all ancillas in the <span class=""math-container"">$| 1 \rangle$</span> state is <span class=""math-container"">$$\prod_{n=1}^{N} \cos^2 \left[ \left( E_{\rm obj} - E \right) \frac{t_n}{2} \right],$$</span></p>
<p>Where <span class=""math-container"">$E$</span> is some chosen &quot;target&quot; energy and the <span class=""math-container"">$t_n$</span> are random times (a normal distribution is used/assumed).
The argument below this equation, labelled <span class=""math-container"">$\left( 3 \right)$</span> on page 2, is the part I'm struggling to understand:</p>
<blockquote>
<p><em>&quot;If we now take random values of <span class=""math-container"">$t_n$</span>, we have an energy filter for <span class=""math-container"">$E_{\rm obj} = E$</span>. The geometric mean of <span class=""math-container"">$\cos^2 \theta$</span> when sampled uniformly over all <span class=""math-container"">$\theta$</span> is equal to <span class=""math-container"">$\frac{1}{4}$</span>. Therefore the spectral weight for any <span class=""math-container"">$E_{\rm obj} \neq E$</span> is suppressed by a factor of <span class=""math-container"">$\frac{1}{4^N}$</span> for large <span class=""math-container"">$N$</span>.&quot;</em></p>
</blockquote>
<p>Does &quot;spectral weight&quot; mean the probability of measuring the state with a particular energy? If so, how is it possible to recognise that the suppression factor is related to the geometric mean of <span class=""math-container"">$\cos^2 \theta$</span>?</p>
","Confusion about Rodeo algorithm ""spectral weight suppression"" argument",<quantum-phase-estimation><state-preparation>,1,0,,,"Confusion about Rodeo algorithm ""spectral weight suppression"" argument <p>In this <a href=""https://doi.org/10.1103/PhysRevLett.127.040505"" rel=""nofollow noreferrer"">first paper</a> <a href=""https://doi.org/10.48550/arXiv.2009.04092"" rel=""nofollow noreferrer"">(arXiv)</a> on the Rodeo algorithm, there is an argument on the second page about the suppression of &quot;spectral weights&quot; that I don't really understand.</p>
<p>In short, the algorithm is designed to find energy eigenvalues and prepare energy eigenstates. There are <span class=""math-container"">$N$</span> ancilla qubits, starting in the <span class=""math-container"">$| 1 \rangle$</span> state, which become entangled with the system of interest through stochastic controlled time evolution operators. As shown on page 2, for a system initially in the eigenstate with energy <span class=""math-container"">$E_{\rm obj}$</span>, the final probability of measuring all ancillas in the <span class=""math-container"">$| 1 \rangle$</span> state is <span class=""math-container"">$$\prod_{n=1}^{N} \cos^2 \left[ \left( E_{\rm obj} - E \right) \frac{t_n}{2} \right],$$</span></p>
<p>Where <span class=""math-container"">$E$</span> is some chosen &quot;target&quot; energy and the <span class=""math-container"">$t_n$</span> are random times (a normal distribution is used/assumed).
The argument below this equation, labelled <span class=""math-container"">$\left( 3 \right)$</span> on page 2, is the part I'm struggling to understand:</p>
<blockquote>
<p><em>&quot;If we now take random values of <span class=""math-container"">$t_n$</span>, we have an energy filter for <span class=""math-container"">$E_{\rm obj} = E$</span>. The geometric mean of <span class=""math-container"">$\cos^2 \theta$</span> when sampled uniformly over all <span class=""math-container"">$\theta$</span> is equal to <span class=""math-container"">$\frac{1}{4}$</span>. Therefore the spectral weight for any <span class=""math-container"">$E_{\rm obj} \neq E$</span> is suppressed by a factor of <span class=""math-container"">$\frac{1}{4^N}$</span> for large <span class=""math-container"">$N$</span>.&quot;</em></p>
</blockquote>
<p>Does &quot;spectral weight&quot; mean the probability of measuring the state with a particular energy? If so, how is it possible to recognise that the suppression factor is related to the geometric mean of <span class=""math-container"">$\cos^2 \theta$</span>?</p>
",qc,confusion rodeo algorithm spectral weight suppression argument p https nofollow noreferrer first paper https nofollow noreferrer arxiv rodeo algorithm argument second page suppression quot spectral weights quot really p short algorithm designed find energy eigenvalues prepare energy eigenstates span n ancilla qubits starting span 1 state become entangled system interest stochastic controlled time evolution operators shown page 2 system initially eigenstate energy span obj final probability measuring ancillas span 1 state span n obj e 2 p span e chosen quot target quot energy span random times normal distribution argument equation labelled span 3 page 2 part struggling understand blockquote p em quot take random values span energy filter span obj e geometric mean span sampled uniformly span equal span 1 4 therefore spectral weight span obj e suppressed factor span 1 large span n quot p quot spectral weight quot mean probability measuring state particular energy possible recognise suppression factor related geometric mean span,"[(0, 0.053671967), (1, 0.03683933), (2, 0.06352059), (3, 0.4849379), (4, 0.05554853), (5, 0.024829632), (7, 0.07244268), (17, 0.036954008), (18, 0.11525308), (19, 0.055349015)]"
27750,27755.0,2022-08-12 11:04:38,2,201,"<p>I've always worked on IBM Cloud when I needed to deploy a quantum application to a NISQ devices.</p>
<p>However, though not an hardware expert, I was asked to explore Microsoft Azure, which I see offers IonQ and Quantinuum platforms access.</p>
<p>I'm however struggling to understand their capabilities. For instance, <a href=""https://quantum-computing.ibm.com/services/resources"" rel=""nofollow noreferrer"">here</a> I can clearly see, for each device, how many qubits it has and what type of process it is. I'm looking for something similar on Azure cloud.</p>
",What are the qubit capabilities of Microsoft Azure?,<azure-quantum>,1,1,,,"What are the qubit capabilities of Microsoft Azure? <p>I've always worked on IBM Cloud when I needed to deploy a quantum application to a NISQ devices.</p>
<p>However, though not an hardware expert, I was asked to explore Microsoft Azure, which I see offers IonQ and Quantinuum platforms access.</p>
<p>I'm however struggling to understand their capabilities. For instance, <a href=""https://quantum-computing.ibm.com/services/resources"" rel=""nofollow noreferrer"">here</a> I can clearly see, for each device, how many qubits it has and what type of process it is. I'm looking for something similar on Azure cloud.</p>
",qc,qubit capabilities microsoft azure p always worked ibm cloud needed deploy quantum application nisq p however though hardware expert asked explore microsoft azure see offers ionq quantinuum platforms p however struggling understand capabilities instance https nofollow noreferrer clearly see device many qubits type process looking something similar azure,"[(8, 0.14143443), (9, 0.27784783), (13, 0.18041733), (14, 0.35554776), (17, 0.041572295)]"
27758,27778.0,2022-08-12 21:25:45,4,997,"<p>Qudit is a <span class=""math-container"">$d$</span>-level system that generalizes a qubit. From what I understood qudits are more resource efficient when it comes to spanning the state space. If <span class=""math-container"">$N$</span> is a dimension of a state space, then we need <span class=""math-container"">$\log_2 N$</span> qubits. With qudits, we need <span class=""math-container"">$\log_d N$</span> qudits. Taking the ratio of the two yields <span class=""math-container"">$\log_2 d$</span> improvement. I guess, this reduction should also reflect in efficiency of construction of algorithms.</p>
<p>Moreover, it seems, qudits have their own set of universal gates some of which are very similar to qubit gates. Algorithms like QFT, DJ, QPE can be implemented with qudits as well.</p>
<p>Why qudits are not as popular? What is the practical <span class=""math-container"">$d&gt;2$</span> we could hope for in the future?</p>
","Are there qudit systems, and why are they not as popular as qubit systems?",<architecture><quantum-state>,3,0,,,"Are there qudit systems, and why are they not as popular as qubit systems? <p>Qudit is a <span class=""math-container"">$d$</span>-level system that generalizes a qubit. From what I understood qudits are more resource efficient when it comes to spanning the state space. If <span class=""math-container"">$N$</span> is a dimension of a state space, then we need <span class=""math-container"">$\log_2 N$</span> qubits. With qudits, we need <span class=""math-container"">$\log_d N$</span> qudits. Taking the ratio of the two yields <span class=""math-container"">$\log_2 d$</span> improvement. I guess, this reduction should also reflect in efficiency of construction of algorithms.</p>
<p>Moreover, it seems, qudits have their own set of universal gates some of which are very similar to qubit gates. Algorithms like QFT, DJ, QPE can be implemented with qudits as well.</p>
<p>Why qudits are not as popular? What is the practical <span class=""math-container"">$d&gt;2$</span> we could hope for in the future?</p>
",qc,qudit systems popular qubit systems p qudit span system generalizes qubit understood qudits resource efficient comes spanning state space span n dimension state space need span n qubits qudits need span n qudits taking ratio two yields span improvement guess reduction also reflect efficiency construction p moreover seems qudits set universal gates similar qubit gates algorithms like qft dj qpe implemented qudits p qudits popular practical span gt 2 could hope future,"[(3, 0.33982524), (7, 0.114664905), (8, 0.15960892), (9, 0.24087615), (17, 0.015403509), (18, 0.12765394)]"
27802,,2022-08-16 13:38:24,4,281,"<p>According to the Qiskit documentation, a gate error is simulated by a thermal relaxation channel followed by a depolarisation channel, where the parameter of the depolarisation channel is adjusted so that the average gate infidelity corresponds to the gate error from the <code>backend.properties()</code>.</p>
<p>However, if the calculated average gate infidelity of the thermal relaxation error is greater than the gate error of the <code>backend.properties().gate_error(gate,qubits)</code>, the thermal relaxation error is returned directly to the <code>NoiseModel</code>. This sometimes leads to large deviations (up to 100%) of the simulated gate error rate and occurs in particular when the dephasing time <span class=""math-container"">$T_2$</span> is small (<span class=""math-container"">$\approx 20\mu s$</span>), since <span class=""math-container"">$1-\overline{F}_{relax} \approx \frac{1}{6} t/T_1 + \frac{1}{3} t/T_2$</span> (where <span class=""math-container"">$t$</span> is the gate time and <span class=""math-container"">$t\ll T_{1,2}$</span>).</p>
<pre><code>backend = FakeMontreal()  
noise = NoiseModel.from_backend(backend)

cx_error = noise._local_quantum_errors['cx'][(1,0)]
error_cal = 1 - average_gate_fidelity(cx_error)
error_rep = backend.properties().gate_error('cx',(1,0))

print(f'gate error from noise model: {error_cal:0.2%}')  # 1.17%
print(f'gate error from backend: {error_rep:0.2%}')      # 0.70%
</code></pre>
<p>Why are too large gate errors accepted instead of applying e.g. only a depolarization error?</p>
",Qiskit NoiseModel.from_backend gives wrong gate error,<qiskit><depolarizing-channel><gate-fidelity>,0,0,,,"Qiskit NoiseModel.from_backend gives wrong gate error <p>According to the Qiskit documentation, a gate error is simulated by a thermal relaxation channel followed by a depolarisation channel, where the parameter of the depolarisation channel is adjusted so that the average gate infidelity corresponds to the gate error from the <code>backend.properties()</code>.</p>
<p>However, if the calculated average gate infidelity of the thermal relaxation error is greater than the gate error of the <code>backend.properties().gate_error(gate,qubits)</code>, the thermal relaxation error is returned directly to the <code>NoiseModel</code>. This sometimes leads to large deviations (up to 100%) of the simulated gate error rate and occurs in particular when the dephasing time <span class=""math-container"">$T_2$</span> is small (<span class=""math-container"">$\approx 20\mu s$</span>), since <span class=""math-container"">$1-\overline{F}_{relax} \approx \frac{1}{6} t/T_1 + \frac{1}{3} t/T_2$</span> (where <span class=""math-container"">$t$</span> is the gate time and <span class=""math-container"">$t\ll T_{1,2}$</span>).</p>
<pre><code>backend = FakeMontreal()  
noise = NoiseModel.from_backend(backend)

cx_error = noise._local_quantum_errors['cx'][(1,0)]
error_cal = 1 - average_gate_fidelity(cx_error)
error_rep = backend.properties().gate_error('cx',(1,0))

print(f'gate error from noise model: {error_cal:0.2%}')  # 1.17%
print(f'gate error from backend: {error_rep:0.2%}')      # 0.70%
</code></pre>
<p>Why are too large gate errors accepted instead of applying e.g. only a depolarization error?</p>
",qc,qiskit gives wrong gate error p according qiskit documentation gate error simulated thermal relaxation channel followed depolarisation channel parameter depolarisation channel adjusted average gate infidelity corresponds gate error code p however calculated average gate infidelity thermal relaxation error greater gate error code gate qubits thermal relaxation error returned directly code noisemodel sometimes leads large deviations 100 simulated gate error rate occurs particular dephasing time span small span since span f relax 1 6 1 3 span gate time span pre code backend fakemontreal noise backend 1 print error noise model print error backend p large gate errors accepted instead applying depolarization error,"[(0, 0.073668666), (3, 0.1598215), (5, 0.18487509), (6, 0.042539015), (9, 0.19718839), (10, 0.010170452), (14, 0.31599173), (17, 0.014534206)]"
27853,,2022-08-18 20:38:09,1,904,"<p>I am new to Quantum ML, and I am currently using PennyLane to do the QML activity.</p>
<p>As per this <a href=""https://pennylane.ai/qml/demos/tutorial_kernel_based_training.html#id1"" rel=""nofollow noreferrer"">article</a>, total number of features is equal to the total number of qubits. (In the example, they have considered Iris dataset. And as we know Iris dataset has only 4 features)
In my case I have more than 800+ features, and I want to use all of them for prediction.</p>
<p>When I am trying to pass all my data as per the above article, I am getting the below error.</p>
<pre><code>n_qubits = len(X_train[0]) #896 is the output of this step
dev_kernel = qml.device(&quot;default.qubit&quot;, wires=0)

projector = np.zeros((2**n_qubits, 2**n_qubits))
projector[0, 0] = 1

@qml.qnode(dev_kernel)
def kernel(x1, x2):
    &quot;&quot;&quot;The quantum kernel.&quot;&quot;&quot;
    #AngleEmbedding(x1, wires=range(n_qubits))
    #qml.adjoint(AngleEmbedding)(x2, wires=range(n_qubits))
    #return qml.expval(qml.Hermitian(projector, wires=range(n_qubits)))
    AngleEmbedding(x1, wires=range(4))
    qml.adjoint(AngleEmbedding)(x2, wires=range(4))
    return qml.expval(qml.Hermitian(projector, wires=range(4)))
</code></pre>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [22], in &lt;cell line: 3&gt;()
      1 dev_kernel = qml.device(&quot;default.qubit&quot;, wires=0)
----&gt; 3 projector = np.zeros((2**n_qubits, 2**n_qubits))
      4 projector[0, 0] = 1
      6 @qml.qnode(dev_kernel)
      7 def kernel(x1, x2):

ValueError: Maximum allowed dimension exceeded
</code></pre>
<p>If I am changing the value back to 4 (to check the error and functioning of wires), I am getting the below error.</p>
<p>ValueError: Features must be of length 4 or less; got length 896.</p>
<p>Can anyone please help me to proceed further. I want to use all my features to create quantum circuit(s). How can I embed all these 896 features with in the available quantum circuits/dimensions.</p>
<p>Thanks in advance!</p>
",How to create a quantum circuit with 800+ features using PennyLane,<quantum-gate><quantum-circuit><quantum-enhanced-machine-learning><pennylane><embedding>,1,0,,,"How to create a quantum circuit with 800+ features using PennyLane <p>I am new to Quantum ML, and I am currently using PennyLane to do the QML activity.</p>
<p>As per this <a href=""https://pennylane.ai/qml/demos/tutorial_kernel_based_training.html#id1"" rel=""nofollow noreferrer"">article</a>, total number of features is equal to the total number of qubits. (In the example, they have considered Iris dataset. And as we know Iris dataset has only 4 features)
In my case I have more than 800+ features, and I want to use all of them for prediction.</p>
<p>When I am trying to pass all my data as per the above article, I am getting the below error.</p>
<pre><code>n_qubits = len(X_train[0]) #896 is the output of this step
dev_kernel = qml.device(&quot;default.qubit&quot;, wires=0)

projector = np.zeros((2**n_qubits, 2**n_qubits))
projector[0, 0] = 1

@qml.qnode(dev_kernel)
def kernel(x1, x2):
    &quot;&quot;&quot;The quantum kernel.&quot;&quot;&quot;
    #AngleEmbedding(x1, wires=range(n_qubits))
    #qml.adjoint(AngleEmbedding)(x2, wires=range(n_qubits))
    #return qml.expval(qml.Hermitian(projector, wires=range(n_qubits)))
    AngleEmbedding(x1, wires=range(4))
    qml.adjoint(AngleEmbedding)(x2, wires=range(4))
    return qml.expval(qml.Hermitian(projector, wires=range(4)))
</code></pre>
<pre><code>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [22], in &lt;cell line: 3&gt;()
      1 dev_kernel = qml.device(&quot;default.qubit&quot;, wires=0)
----&gt; 3 projector = np.zeros((2**n_qubits, 2**n_qubits))
      4 projector[0, 0] = 1
      6 @qml.qnode(dev_kernel)
      7 def kernel(x1, x2):

ValueError: Maximum allowed dimension exceeded
</code></pre>
<p>If I am changing the value back to 4 (to check the error and functioning of wires), I am getting the below error.</p>
<p>ValueError: Features must be of length 4 or less; got length 896.</p>
<p>Can anyone please help me to proceed further. I want to use all my features to create quantum circuit(s). How can I embed all these 896 features with in the available quantum circuits/dimensions.</p>
<p>Thanks in advance!</p>
",qc,create quantum circuit features using pennylane p new quantum ml currently using pennylane qml p per https id1 nofollow noreferrer article total number features equal total number qubits example considered iris dataset know iris dataset 4 features case features want use p trying pass data per article getting pre code len 0 896 output step quot quot projector 2 2 projector 0 0 1 def kernel x1 x2 quot quot quot quantum quot quot quot angleembedding x1 angleembedding x2 return projector angleembedding x1 4 angleembedding x2 4 return projector 4 pre code valueerror traceback recent call last input 22 lt cell line 3 gt 1 quot quot gt 3 projector 2 2 4 projector 0 0 1 6 7 def kernel x1 x2 valueerror maximum allowed dimension exceeded p changing value back 4 check error functioning wires getting p valueerror features must length 4 less got length p anyone please help proceed want use features create quantum circuit embed 896 features available quantum p thanks advance,"[(0, 0.27085218), (2, 0.08393564), (4, 0.033774856), (6, 0.05850665), (8, 0.2032694), (13, 0.03829906), (14, 0.077937596), (17, 0.099315435), (18, 0.015146392), (19, 0.11185873)]"
27857,27882.0,2022-08-19 00:32:14,1,189,"<p>I have this quantum state:
<span class=""math-container"">$$|\phi \rangle =\frac{1}{4\sqrt{2}}|000\rangle +\frac{3-\sqrt{5}i}{8}|001\rangle +\frac{1}{4\sqrt{2}}|010\rangle +\frac{3-\sqrt{5}i}{8}|011\rangle \\+\frac{1}{4\sqrt{2}}|100\rangle +\frac{3-\sqrt{5}i}{8}|101\rangle +\frac{1}{4\sqrt{2}}|110\rangle +\frac{3-\sqrt{5}i}{8}|111\rangle $$</span>
And I have to use Kronecker product to factorize that state into individual qubits (Image below). I'm not sure where to start, any hint would be appreciated</p>
<p><span class=""math-container"">$$|\phi \rangle =\left| Q_2 \right. \rangle \left| Q_1 \right. \rangle \left| Q_0 \right. \rangle =\left| Q_2Q_1Q_0 \right. \rangle $$</span></p>
",Factoring some qubits with Kronecker product,<quantum-state><textbook-and-exercises>,1,3,,,"Factoring some qubits with Kronecker product <p>I have this quantum state:
<span class=""math-container"">$$|\phi \rangle =\frac{1}{4\sqrt{2}}|000\rangle +\frac{3-\sqrt{5}i}{8}|001\rangle +\frac{1}{4\sqrt{2}}|010\rangle +\frac{3-\sqrt{5}i}{8}|011\rangle \\+\frac{1}{4\sqrt{2}}|100\rangle +\frac{3-\sqrt{5}i}{8}|101\rangle +\frac{1}{4\sqrt{2}}|110\rangle +\frac{3-\sqrt{5}i}{8}|111\rangle $$</span>
And I have to use Kronecker product to factorize that state into individual qubits (Image below). I'm not sure where to start, any hint would be appreciated</p>
<p><span class=""math-container"">$$|\phi \rangle =\left| Q_2 \right. \rangle \left| Q_1 \right. \rangle \left| Q_0 \right. \rangle =\left| Q_2Q_1Q_0 \right. \rangle $$</span></p>
",qc,factoring qubits kronecker product p quantum state span 1 2 5 8 1 2 5 8 1 2 5 8 1 2 5 8 use kronecker product factorize state individual qubits image sure start hint would appreciated p span,"[(2, 0.15094018), (3, 0.14565082), (4, 0.046074096), (6, 0.27358314), (8, 0.06557344), (17, 0.056925472), (18, 0.25784877)]"
27892,27895.0,2022-08-22 16:44:36,0,638,"<p>Working through <a href=""https://learn.qiskit.org/course/ch-labs/lab-5-accuracy-of-quantum-phase-estimation"" rel=""nofollow noreferrer"">Lab 5</a> in the Qiskit text, I have been attempting to complete Part 1, Step B.  I implemented the following code as it seemed, at the time, to be what the question was asking for:</p>
<pre><code>eList=[]

mList=list(count_qc4.values())
m=mList.index(max(mList))     #Giving the index of the highest value in the list as our desired output

#Calculate all possible e values
for i in range(16):
    eList.append(round(np.absolute(phi_est[m]-phi_est[i])*(2**t)))
    
#Chose our e as the highest one
e=max(eList)
print('e = ',e)
</code></pre>
<p>This gives me <span class=""math-container"">$e = 10$</span>. At the time I wrote this I was quite satisfied, but later on you rebuild the circuits with more counting qubits and are supposed to be able to graph the e-values you calculate to get <span class=""math-container"">$e=2^{t-2}-1$</span> which in the t=4 counting qubit scenario, gives me 3, not 10.</p>
<p>Any help with understanding how I was supposed to get that <span class=""math-container"">$e = 3$</span> using <span class=""math-container"">$|m-b|\leq e/2^t$</span> would be appreciated!</p>
<p>P.S. I have access to and have been referencing Sect 4.2.1 in QIQC by Nielson and Chaung as well as Sect 7.1.1 in the text by Kaye, Laflamme and Mosca.</p>
","Accuracy of Quantum Phase estimation; Finding the max difference integer, e",<qiskit><textbook-and-exercises><quantum-phase-estimation>,1,0,,,"Accuracy of Quantum Phase estimation; Finding the max difference integer, e <p>Working through <a href=""https://learn.qiskit.org/course/ch-labs/lab-5-accuracy-of-quantum-phase-estimation"" rel=""nofollow noreferrer"">Lab 5</a> in the Qiskit text, I have been attempting to complete Part 1, Step B.  I implemented the following code as it seemed, at the time, to be what the question was asking for:</p>
<pre><code>eList=[]

mList=list(count_qc4.values())
m=mList.index(max(mList))     #Giving the index of the highest value in the list as our desired output

#Calculate all possible e values
for i in range(16):
    eList.append(round(np.absolute(phi_est[m]-phi_est[i])*(2**t)))
    
#Chose our e as the highest one
e=max(eList)
print('e = ',e)
</code></pre>
<p>This gives me <span class=""math-container"">$e = 10$</span>. At the time I wrote this I was quite satisfied, but later on you rebuild the circuits with more counting qubits and are supposed to be able to graph the e-values you calculate to get <span class=""math-container"">$e=2^{t-2}-1$</span> which in the t=4 counting qubit scenario, gives me 3, not 10.</p>
<p>Any help with understanding how I was supposed to get that <span class=""math-container"">$e = 3$</span> using <span class=""math-container"">$|m-b|\leq e/2^t$</span> would be appreciated!</p>
<p>P.S. I have access to and have been referencing Sect 4.2.1 in QIQC by Nielson and Chaung as well as Sect 7.1.1 in the text by Kaye, Laflamme and Mosca.</p>
",qc,accuracy quantum phase estimation finding max difference integer e p working https nofollow noreferrer lab 5 qiskit text attempting complete part 1 step implemented following code seemed time question asking pre code max mlist giving index highest value list desired output calculate possible e values range 16 round 2 chose e highest one elist print e e p gives span e 10 time wrote quite satisfied later rebuild circuits counting qubits supposed able graph calculate get span counting qubit scenario gives 3 p help understanding supposed get span e 3 using span would appreciated p access referencing sect qiqc nielson chaung well sect text kaye laflamme,"[(0, 0.054063868), (3, 0.1256568), (6, 0.059344884), (7, 0.17108467), (10, 0.026806088), (13, 0.20815277), (14, 0.28098798), (17, 0.0727046)]"
27958,,2022-08-26 16:10:41,0,213,"<p>There are some very nice examples on how to handle circuits using qiskit.</p>
<p>However, once we get to the <em>qiskit-nature</em> documentation, it feels like a complete new world for the untrained eye.</p>
<p>I am running something similar to the &quot;<a href=""https://qiskit.org/documentation/nature/tutorials/05_Sampling_potential_energy_surfaces.html"" rel=""nofollow noreferrer"">Sampling the potential energy surface</a>&quot; example, where the <em>circuit</em> concept may be well hidden below those higher level objects.</p>
<p>I would like to access a <em>qiskit.QuantumCircuit</em>-like object, from the example above mentioned, in order to retrieve its properties, for example, estimating the computational cost, finding the amount of required qubits, circuit depth...</p>
<p>My guess was, somewhere after the <em>GroundStateEigensolver</em> (6th code block), but I can't find any method or attribute around, that could help.</p>
<p>Any clues on how to achieve this?</p>
",qiskit-nature accessing circuit,<qiskit><quantum-circuit><vqe><qiskit-runtime>,1,2,,,"qiskit-nature accessing circuit <p>There are some very nice examples on how to handle circuits using qiskit.</p>
<p>However, once we get to the <em>qiskit-nature</em> documentation, it feels like a complete new world for the untrained eye.</p>
<p>I am running something similar to the &quot;<a href=""https://qiskit.org/documentation/nature/tutorials/05_Sampling_potential_energy_surfaces.html"" rel=""nofollow noreferrer"">Sampling the potential energy surface</a>&quot; example, where the <em>circuit</em> concept may be well hidden below those higher level objects.</p>
<p>I would like to access a <em>qiskit.QuantumCircuit</em>-like object, from the example above mentioned, in order to retrieve its properties, for example, estimating the computational cost, finding the amount of required qubits, circuit depth...</p>
<p>My guess was, somewhere after the <em>GroundStateEigensolver</em> (6th code block), but I can't find any method or attribute around, that could help.</p>
<p>Any clues on how to achieve this?</p>
",qc,accessing circuit p nice examples handle circuits using p however get em documentation feels like complete new world untrained p running something similar quot https nofollow noreferrer sampling potential energy surface quot example em circuit concept may well hidden higher level p would like access em object example mentioned order retrieve properties example estimating computational cost finding amount required qubits circuit depth p guess somewhere em groundstateeigensolver 6th code block ca find method attribute around could p clues achieve,"[(5, 0.018274738), (7, 0.07195144), (8, 0.32892916), (9, 0.18778248), (14, 0.33725455), (17, 0.018181024), (19, 0.03591977)]"
27997,28001.0,2022-08-31 13:05:46,2,92,"<p>In quantum error correction, we start with the fact that no-cloning theorem doesn't allow cloning of unknown states, hence we need to come up with other strategies.</p>
<p>But often we know the circuit that produces the state that we want to protect, so can't we just prepare the same state multiple times to in-effect clone it?</p>
<p>I realize that the circuits used for preparation would themselves incur error. But wouldn't there be a way to go around it by using more copies?</p>
<p>Is there a precise way to see that this pursuit is completely useless - perhaps one could show that there is no way to do this without using an exponential number of copies?</p>
",Cloning for error correction by preparing state multiple times,<error-correction><no-cloning-theorem>,1,2,,,"Cloning for error correction by preparing state multiple times <p>In quantum error correction, we start with the fact that no-cloning theorem doesn't allow cloning of unknown states, hence we need to come up with other strategies.</p>
<p>But often we know the circuit that produces the state that we want to protect, so can't we just prepare the same state multiple times to in-effect clone it?</p>
<p>I realize that the circuits used for preparation would themselves incur error. But wouldn't there be a way to go around it by using more copies?</p>
<p>Is there a precise way to see that this pursuit is completely useless - perhaps one could show that there is no way to do this without using an exponential number of copies?</p>
",qc,cloning error correction preparing state multiple times p quantum error correction start fact theorem allow cloning unknown states hence need come p often know circuit produces state want protect ca prepare state multiple times clone p realize circuits used preparation would incur error would way go around using copies p precise way see pursuit completely useless perhaps one could show way without using exponential number copies,"[(1, 0.023605047), (5, 0.12964822), (7, 0.03150456), (8, 0.124256335), (9, 0.069807574), (14, 0.31335995), (17, 0.048476063), (18, 0.25749937)]"
28033,,2022-09-02 07:18:43,0,123,"<p>I'm looking on pennylane's tutorial</p>
<p><a href=""https://pennylane.ai/qml/demos/tutorial_barren_plateaus.html"" rel=""nofollow noreferrer"">https://pennylane.ai/qml/demos/tutorial_barren_plateaus.html</a></p>
<p>In this link, to illustrate barren plateaus, author used example circuit and barren plateau plots. However, I'm curious why the plot (the right figure) only includes the <span class=""math-container"">$\theta_1$</span> and <span class=""math-container"">$\theta_2$</span> (Is the plateau only  example to show the barren pleateaus or <span class=""math-container"">$\theta_3$</span> and <span class=""math-container"">$\theta_4$</span> are not related with it. Moreover, if the right figure is just an example and <span class=""math-container"">$\theta_3$</span> and <span class=""math-container"">$\theta_4$</span> are related with barren plateaus, Is there any way to plot barren plateaus of multi-qubit system? not only the 2qubit system.</p>
",Barren plateaus in multi-qubit system,<quantum-state>,1,0,,,"Barren plateaus in multi-qubit system <p>I'm looking on pennylane's tutorial</p>
<p><a href=""https://pennylane.ai/qml/demos/tutorial_barren_plateaus.html"" rel=""nofollow noreferrer"">https://pennylane.ai/qml/demos/tutorial_barren_plateaus.html</a></p>
<p>In this link, to illustrate barren plateaus, author used example circuit and barren plateau plots. However, I'm curious why the plot (the right figure) only includes the <span class=""math-container"">$\theta_1$</span> and <span class=""math-container"">$\theta_2$</span> (Is the plateau only  example to show the barren pleateaus or <span class=""math-container"">$\theta_3$</span> and <span class=""math-container"">$\theta_4$</span> are not related with it. Moreover, if the right figure is just an example and <span class=""math-container"">$\theta_3$</span> and <span class=""math-container"">$\theta_4$</span> are related with barren plateaus, Is there any way to plot barren plateaus of multi-qubit system? not only the 2qubit system.</p>
",qc,barren plateaus system p looking pennylane tutorial p https nofollow noreferrer https p link illustrate barren plateaus author used example circuit barren plateau plots however curious plot right figure includes span span plateau example show barren pleateaus span span related moreover right figure example span span related barren plateaus way plot barren plateaus system 2qubit,"[(3, 0.2639135), (4, 0.29036114), (14, 0.42306942), (17, 0.019645514)]"
28049,28063.0,2022-09-04 02:26:38,0,172,"<p>I need to rewrite a following circuit from <a href=""https://quantumai.google/cirq"" rel=""nofollow noreferrer"">Cirq</a> to <a href=""https://qiskit.org/"" rel=""nofollow noreferrer"">Qiskit</a> with <span class=""math-container"">$2\varphi = \pi$</span>.</p>
<p><a href=""https://i.sstatic.net/MqJQM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MqJQM.png"" alt=""enter image description here"" /></a></p>
<p>It's a circuit representing an initial state for VQE calculation. Considering, that <code>qiskit_nature</code> considers a different ordering of spin-orbitals (first all spin-up, then all spin-down), I've rewritten the circuit like this (switching 1st and 2nd qubit, indexing from 0):</p>
<p><a href=""https://i.sstatic.net/2QMAi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2QMAi.png"" alt=""enter image description here"" /></a></p>
<p>In both cases the statevector equals to</p>
<pre><code>array([ 0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ,  0.70710678, -0.        ,  0.        , -0.70710678,
        0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ])
</code></pre>
<p>, i.e.</p>
<p><span class=""math-container"">$$
\left|\psi\right&gt; = \frac{1}{\sqrt{2}}\left| 0110 \right&gt; - \frac{1}{\sqrt{2}}\left| 1001 \right&gt;.
$$</span></p>
<p>In Cirq, the total angular momentum <span class=""math-container"">$\left&lt;\psi \middle| S^2 \middle| \psi \right&gt; = 0$</span>, i.e. the state should be singlet. But when I try the same in qiskit with the help of <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html"" rel=""nofollow noreferrer"">second_q_ops()</a>, I'm getting <code>1.999999...</code>.</p>
<p>Why does my result differ?</p>
<hr />
<h3>My Code</h3>
<pre><code>#!/usr/bin/env python3
import numpy as np
import qiskit_nature
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.providers.aer import Aer
from qiskit.quantum_info import Statevector
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureMoleculeDriver, ElectronicStructureDriverType
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer

if __name__ == '__main__':

    qiskit_nature.settings.dict_aux_operators = True
    backend = Aer.get_backend('statevector_simulator')

    geometry = [('N', [0.000000000000, 0.000000000000, 0.000000000000]),
                ('C', [0.000000000000, 0.000000000000, 1.498047000000]),
                ('H', [0.000000000000, -0.938765985000, 2.004775984000]),
                ('H', [0.000000000000, 0.938765985000, 2.004775984000]),
                ('H', [-0.744681452, -0.131307432, -0.634501434])]

    # Obtaining ground state
    driver = ElectronicStructureMoleculeDriver(Molecule(geometry),
                                               basis=&quot;sto3g&quot;,
                                               driver_type=ElectronicStructureDriverType.PSI4)

    as_transformer = ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)
    es_problem = ElectronicStructureProblem(driver, transformers=[as_transformer])
    converter = QubitConverter(JordanWignerMapper())

    # Create circuit
    qreg_q = QuantumRegister(4, 'q')
    circuit = QuantumCircuit(qreg_q)

    circuit.x(qreg_q[2])
    circuit.ry(np.pi, qreg_q[0])
    circuit.ch(qreg_q[0], qreg_q[3])
    circuit.cx(qreg_q[3], qreg_q[2])
    circuit.cx(qreg_q[3], qreg_q[0])
    circuit.cx(qreg_q[0], qreg_q[1])
    circuit.z(qreg_q[3])
    circuit.x(qreg_q[0])
    print(f'Circuit:\n{circuit}')

    statevec = Statevector(circuit).data
    print(f'Statevector:\n{statevec}')

    # Obtain S^2 operator
    ss_op = es_problem.second_q_ops()['AngularMomentum']
    print(f'S^2 operator:\n{ss_op}')

    print(f'&lt;psi|S^2|psi&gt; = {statevec @ converter.convert(ss_op).to_matrix() @ statevec}')
</code></pre>
<h3>The Output</h3>
<pre><code>Circuit:
     ┌───────┐          ┌───┐     ┌───┐
q_0: ┤ Ry(π) ├──■───────┤ X ├──■──┤ X ├
     └───────┘  │       └─┬─┘┌─┴─┐└───┘
q_1: ───────────┼─────────┼──┤ X ├─────
       ┌───┐    │  ┌───┐  │  └───┘     
q_2: ──┤ X ├────┼──┤ X ├──┼────────────
       └───┘  ┌─┴─┐└─┬─┘  │  ┌───┐     
q_3: ─────────┤ H ├──■────■──┤ Z ├─────
              └───┘          └───┘     
Statevector:
[ 0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  6.12323400e-17+0.j
  7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
 -7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j]
S^2 operator:
Fermionic Operator
register length=4, number terms=12
  (0.75+0j) * ( +_0 -_0 )
+ (0.75+0j) * ( +_1 -_1 )
+ (0.75+0j) * ( +_2 -_2 )
+ (0.75+0j) * ( +_3 -_3 )
+ (0.5+0j) * ( +_0 -_0 +_1 -_1 )
+ (-1.5+0j) * ( +_0 -_0 +_2 -_2 )
+ (-0.5+0j) * ( +_0 -_0 + ...
&lt;psi|S^2|psi&gt; = (1.9999999999999996+0j)
</code></pre>
",$S^2$ expectation value of a circuit seems wrong,<qiskit><cirq><angular-momentum>,1,0,,,"$S^2$ expectation value of a circuit seems wrong <p>I need to rewrite a following circuit from <a href=""https://quantumai.google/cirq"" rel=""nofollow noreferrer"">Cirq</a> to <a href=""https://qiskit.org/"" rel=""nofollow noreferrer"">Qiskit</a> with <span class=""math-container"">$2\varphi = \pi$</span>.</p>
<p><a href=""https://i.sstatic.net/MqJQM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MqJQM.png"" alt=""enter image description here"" /></a></p>
<p>It's a circuit representing an initial state for VQE calculation. Considering, that <code>qiskit_nature</code> considers a different ordering of spin-orbitals (first all spin-up, then all spin-down), I've rewritten the circuit like this (switching 1st and 2nd qubit, indexing from 0):</p>
<p><a href=""https://i.sstatic.net/2QMAi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2QMAi.png"" alt=""enter image description here"" /></a></p>
<p>In both cases the statevector equals to</p>
<pre><code>array([ 0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ,  0.70710678, -0.        ,  0.        , -0.70710678,
        0.        , -0.        ,  0.        , -0.        ,  0.        ,
       -0.        ])
</code></pre>
<p>, i.e.</p>
<p><span class=""math-container"">$$
\left|\psi\right&gt; = \frac{1}{\sqrt{2}}\left| 0110 \right&gt; - \frac{1}{\sqrt{2}}\left| 1001 \right&gt;.
$$</span></p>
<p>In Cirq, the total angular momentum <span class=""math-container"">$\left&lt;\psi \middle| S^2 \middle| \psi \right&gt; = 0$</span>, i.e. the state should be singlet. But when I try the same in qiskit with the help of <a href=""https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html"" rel=""nofollow noreferrer"">second_q_ops()</a>, I'm getting <code>1.999999...</code>.</p>
<p>Why does my result differ?</p>
<hr />
<h3>My Code</h3>
<pre><code>#!/usr/bin/env python3
import numpy as np
import qiskit_nature
from qiskit import QuantumCircuit, QuantumRegister
from qiskit.providers.aer import Aer
from qiskit.quantum_info import Statevector
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import ElectronicStructureMoleculeDriver, ElectronicStructureDriverType
from qiskit_nature.mappers.second_quantization import JordanWignerMapper
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer

if __name__ == '__main__':

    qiskit_nature.settings.dict_aux_operators = True
    backend = Aer.get_backend('statevector_simulator')

    geometry = [('N', [0.000000000000, 0.000000000000, 0.000000000000]),
                ('C', [0.000000000000, 0.000000000000, 1.498047000000]),
                ('H', [0.000000000000, -0.938765985000, 2.004775984000]),
                ('H', [0.000000000000, 0.938765985000, 2.004775984000]),
                ('H', [-0.744681452, -0.131307432, -0.634501434])]

    # Obtaining ground state
    driver = ElectronicStructureMoleculeDriver(Molecule(geometry),
                                               basis=&quot;sto3g&quot;,
                                               driver_type=ElectronicStructureDriverType.PSI4)

    as_transformer = ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)
    es_problem = ElectronicStructureProblem(driver, transformers=[as_transformer])
    converter = QubitConverter(JordanWignerMapper())

    # Create circuit
    qreg_q = QuantumRegister(4, 'q')
    circuit = QuantumCircuit(qreg_q)

    circuit.x(qreg_q[2])
    circuit.ry(np.pi, qreg_q[0])
    circuit.ch(qreg_q[0], qreg_q[3])
    circuit.cx(qreg_q[3], qreg_q[2])
    circuit.cx(qreg_q[3], qreg_q[0])
    circuit.cx(qreg_q[0], qreg_q[1])
    circuit.z(qreg_q[3])
    circuit.x(qreg_q[0])
    print(f'Circuit:\n{circuit}')

    statevec = Statevector(circuit).data
    print(f'Statevector:\n{statevec}')

    # Obtain S^2 operator
    ss_op = es_problem.second_q_ops()['AngularMomentum']
    print(f'S^2 operator:\n{ss_op}')

    print(f'&lt;psi|S^2|psi&gt; = {statevec @ converter.convert(ss_op).to_matrix() @ statevec}')
</code></pre>
<h3>The Output</h3>
<pre><code>Circuit:
     ┌───────┐          ┌───┐     ┌───┐
q_0: ┤ Ry(π) ├──■───────┤ X ├──■──┤ X ├
     └───────┘  │       └─┬─┘┌─┴─┐└───┘
q_1: ───────────┼─────────┼──┤ X ├─────
       ┌───┐    │  ┌───┐  │  └───┘     
q_2: ──┤ X ├────┼──┤ X ├──┼────────────
       └───┘  ┌─┴─┐└─┬─┘  │  ┌───┐     
q_3: ─────────┤ H ├──■────■──┤ Z ├─────
              └───┘          └───┘     
Statevector:
[ 0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  6.12323400e-17+0.j
  7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
 -7.07106781e-01+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j  0.00000000e+00+0.j  0.00000000e+00+0.j
  0.00000000e+00+0.j]
S^2 operator:
Fermionic Operator
register length=4, number terms=12
  (0.75+0j) * ( +_0 -_0 )
+ (0.75+0j) * ( +_1 -_1 )
+ (0.75+0j) * ( +_2 -_2 )
+ (0.75+0j) * ( +_3 -_3 )
+ (0.5+0j) * ( +_0 -_0 +_1 -_1 )
+ (-1.5+0j) * ( +_0 -_0 +_2 -_2 )
+ (-0.5+0j) * ( +_0 -_0 + ...
&lt;psi|S^2|psi&gt; = (1.9999999999999996+0j)
</code></pre>
",qc,expectation value circuit seems wrong p need rewrite following circuit https nofollow noreferrer cirq https nofollow noreferrer qiskit span p https nofollow noreferrer img https enter image description p circuit representing initial state vqe calculation considering code considers different ordering first rewritten circuit like switching 1st 2nd qubit indexing 0 p https nofollow noreferrer img https enter image description p cases statevector equals pre code array p p span gt 1 2 0110 gt 1 2 1001 gt p cirq total angular momentum span lt gt 0 state singlet try qiskit help https nofollow noreferrer getting code p result differ hr h3 code pre code python3 import numpy np import qiskit import quantumcircuit quantumregister import aer import statevector import qubitconverter import molecule import electronicstructuremoleculedriver electronicstructuredrivertype import jordanwignermapper import electronicstructureproblem import activespacetransformer true backend geometry c h h h obtaining ground state driver electronicstructuremoleculedriver molecule geometry quot sto3g quot activespacetransformer electronicstructureproblem driver converter qubitconverter jordanwignermapper create circuit quantumregister 4 q circuit quantumcircuit 2 0 0 3 3 2 3 0 0 1 3 0 print circuit statevec statevector circuit print statevec obtain operator print operator print f lt gt statevec statevec h3 output pre code circuit ry π x x x x x h z statevector operator fermionic operator register number lt gt,"[(0, 0.4354121), (2, 0.08138322), (3, 0.03835698), (4, 0.23128848), (10, 0.041283187), (12, 0.010552346), (13, 0.017728971), (14, 0.015760144), (17, 0.03241723), (18, 0.08047333)]"
28050,28060.0,2022-09-04 07:38:52,0,254,"<p>I have a question about the ActiveSpaceTransformer which is used in vqe calculations for a molecule of LiH in Qiskit. In the documentation the inactive Fock operator is defined.I don't understand why is the inactive Fock operator defined in that way, what is his physical meaning? Then, Why are we substituting the one body integral with the inactive Fock operator in the original hamiltonian?</p>
",How does the Active Space Transform work theoretically?,<qiskit><programming><hamiltonian-simulation><vqe><chemistry>,1,0,,,"How does the Active Space Transform work theoretically? <p>I have a question about the ActiveSpaceTransformer which is used in vqe calculations for a molecule of LiH in Qiskit. In the documentation the inactive Fock operator is defined.I don't understand why is the inactive Fock operator defined in that way, what is his physical meaning? Then, Why are we substituting the one body integral with the inactive Fock operator in the original hamiltonian?</p>
",qc,active space transform work theoretically p question activespacetransformer used vqe calculations molecule lih qiskit documentation inactive fock operator understand inactive fock operator defined way physical meaning substituting one body integral inactive fock operator original hamiltonian,"[(1, 0.071402684), (3, 0.42264038), (8, 0.11123899), (9, 0.069998965), (14, 0.12997685), (17, 0.09259331), (18, 0.09797887)]"
28146,28150.0,2022-09-12 15:15:06,3,448,"<p>I experimented with stim and qiskit for QECC simulations. They both have limitations : for example stim has no support for non-clifford operations (qiskit does); qiskit has no support for multiple pauli strings measurement (stim does). The two are still useful for some sims, but I'd like a more complete package. Would cirq be an option to experiment with? what would be its advantages/drawbacks?</p>
",is cirq suitable for simulation of quantum error correction?,<qiskit><error-correction><simulation><cirq><stim>,1,0,,,"is cirq suitable for simulation of quantum error correction? <p>I experimented with stim and qiskit for QECC simulations. They both have limitations : for example stim has no support for non-clifford operations (qiskit does); qiskit has no support for multiple pauli strings measurement (stim does). The two are still useful for some sims, but I'd like a more complete package. Would cirq be an option to experiment with? what would be its advantages/drawbacks?</p>
",qc,cirq suitable simulation quantum error correction p experimented stim qiskit qecc simulations limitations example stim support operations qiskit qiskit support multiple pauli strings measurement stim two still useful sims like complete package would cirq option experiment would,"[(5, 0.1838888), (8, 0.14233518), (14, 0.640064), (17, 0.029165369)]"
28152,28158.0,2022-09-13 06:29:56,1,563,"<p>I am a newbie to quantum and have been trying <code>qiskit</code> library for learning quantum computing (in order to explore quantum effects on cryptography). I am basically trying to build Grover Oracle for different symmetric key algorithms. For this I am learning various operations mostly performed by these algos in classical counterparts like <code>XOR</code>, <code>Bit Shift</code>, <code>Addition</code> and <code>Modulo</code> operations etc.</p>
<p>I have created a 4 bit circuit for Full Adder in qiskit and extended it to 8 qbits. But when I am trying it for 12 bits, it raises above error</p>
<pre><code>Simulation failed and returned the following error message:
ERROR:  [Experiment 0] Insufficient memory to run circuit circuit-584 using the statevector simulator. Required memory: 67108864M, max memory: 32712M
QiskitError: 'Data for experiment &quot;circuit-584&quot; could not be found.'
</code></pre>
<p>I have written a simple quantum implementation of Full Adder and this Error arises when I try to measure the result.</p>
<pre><code>length=12

a = QuantumRegister(length)
b = QuantumRegister(length)
s = QuantumRegister(length)
aux = QuantumRegister(length)

cout = QuantumRegister(1)
cin = QuantumRegister(1)


result = ClassicalRegister(length+1)

input1 = 0xa82
input2 = 0x905

circ=QuantumCircuit(a,b,cin,s,cout,result,aux)

Round_constant_XOR(circ,input1,a,length) # Copying input1 to a
Round_constant_XOR(circ,input2,b,length) # Copying input2 to b 

full_adder(circ,a,b,cin,length,s,cout)

#circ.draw(output='mpl')
print(&quot;Operations Completed, now measuring qbits\n&quot;)
for i in range(length):
    circ.measure(s[i],result[i])
circ.measure(cout,result[length])

simulator1 = AerSimulator(method='statevector')
results1 = execute(circ,backend=simulator1).result()
print(&quot;Result is: &quot; + str(results1.get_counts(circ)))
plot_histogram(results1.get_counts(circ))
</code></pre>
<p>Complete Error is</p>
<pre><code>---------------------------------------------------------------------------
QiskitError                               Traceback (most recent call last)
C:\PROGRA~1\KMSpico\temp/ipykernel_12724/2309521244.py in &lt;module&gt;
     31 simulator1 = AerSimulator(method='statevector')
     32 results1 = execute(circ,backend=simulator1).result()
---&gt; 33 print(&quot;Result is: &quot; + str(results1.get_counts(circ)))
     34 plot_histogram(results1.get_counts(circ))

~\anaconda3\lib\site-packages\qiskit\result\result.py in get_counts(self, experiment)
    267         dict_list = []
    268         for key in exp_keys:
--&gt; 269             exp = self._get_experiment(key)
    270             try:
    271                 header = exp.header.to_dict()

~\anaconda3\lib\site-packages\qiskit\result\result.py in _get_experiment(self, key)
    378 
    379             if len(exp) == 0:
--&gt; 380                 raise QiskitError('Data for experiment &quot;%s&quot; could not be found.' % key)
    381             if len(exp) == 1:
    382                 exp = exp[0]
</code></pre>
<p>Does the problem lie in number of qbits simulator is able to handle or anything else. As I eventually want to perform different operations for at least 128 qbits registers in order to simulate practical symmetric algos.</p>
",Insufficient memory to run circuit using the statevector simulator,<qiskit><programming><grovers-algorithm><simulation><oracles>,1,2,,,"Insufficient memory to run circuit using the statevector simulator <p>I am a newbie to quantum and have been trying <code>qiskit</code> library for learning quantum computing (in order to explore quantum effects on cryptography). I am basically trying to build Grover Oracle for different symmetric key algorithms. For this I am learning various operations mostly performed by these algos in classical counterparts like <code>XOR</code>, <code>Bit Shift</code>, <code>Addition</code> and <code>Modulo</code> operations etc.</p>
<p>I have created a 4 bit circuit for Full Adder in qiskit and extended it to 8 qbits. But when I am trying it for 12 bits, it raises above error</p>
<pre><code>Simulation failed and returned the following error message:
ERROR:  [Experiment 0] Insufficient memory to run circuit circuit-584 using the statevector simulator. Required memory: 67108864M, max memory: 32712M
QiskitError: 'Data for experiment &quot;circuit-584&quot; could not be found.'
</code></pre>
<p>I have written a simple quantum implementation of Full Adder and this Error arises when I try to measure the result.</p>
<pre><code>length=12

a = QuantumRegister(length)
b = QuantumRegister(length)
s = QuantumRegister(length)
aux = QuantumRegister(length)

cout = QuantumRegister(1)
cin = QuantumRegister(1)


result = ClassicalRegister(length+1)

input1 = 0xa82
input2 = 0x905

circ=QuantumCircuit(a,b,cin,s,cout,result,aux)

Round_constant_XOR(circ,input1,a,length) # Copying input1 to a
Round_constant_XOR(circ,input2,b,length) # Copying input2 to b 

full_adder(circ,a,b,cin,length,s,cout)

#circ.draw(output='mpl')
print(&quot;Operations Completed, now measuring qbits\n&quot;)
for i in range(length):
    circ.measure(s[i],result[i])
circ.measure(cout,result[length])

simulator1 = AerSimulator(method='statevector')
results1 = execute(circ,backend=simulator1).result()
print(&quot;Result is: &quot; + str(results1.get_counts(circ)))
plot_histogram(results1.get_counts(circ))
</code></pre>
<p>Complete Error is</p>
<pre><code>---------------------------------------------------------------------------
QiskitError                               Traceback (most recent call last)
C:\PROGRA~1\KMSpico\temp/ipykernel_12724/2309521244.py in &lt;module&gt;
     31 simulator1 = AerSimulator(method='statevector')
     32 results1 = execute(circ,backend=simulator1).result()
---&gt; 33 print(&quot;Result is: &quot; + str(results1.get_counts(circ)))
     34 plot_histogram(results1.get_counts(circ))

~\anaconda3\lib\site-packages\qiskit\result\result.py in get_counts(self, experiment)
    267         dict_list = []
    268         for key in exp_keys:
--&gt; 269             exp = self._get_experiment(key)
    270             try:
    271                 header = exp.header.to_dict()

~\anaconda3\lib\site-packages\qiskit\result\result.py in _get_experiment(self, key)
    378 
    379             if len(exp) == 0:
--&gt; 380                 raise QiskitError('Data for experiment &quot;%s&quot; could not be found.' % key)
    381             if len(exp) == 1:
    382                 exp = exp[0]
</code></pre>
<p>Does the problem lie in number of qbits simulator is able to handle or anything else. As I eventually want to perform different operations for at least 128 qbits registers in order to simulate practical symmetric algos.</p>
",qc,insufficient memory run circuit using statevector simulator p newbie quantum trying code qiskit library learning quantum computing order explore quantum effects cryptography basically trying build grover oracle different symmetric key algorithms learning various operations mostly performed algos classical counterparts like code xor code bit shift code addition code modulo operations p created 4 bit circuit full adder qiskit extended 8 qbits trying 12 bits raises error pre code simulation failed returned following error message error experiment 0 insufficient memory run circuit using statevector simulator required memory 67108864m max memory 32712m qiskiterror experiment quot quot could found p written simple quantum implementation full adder error arises try measure pre code quantumregister length b quantumregister length quantumregister length aux quantumregister length cout quantumregister 1 cin quantumregister 1 result classicalregister input1 0xa82 input2 0x905 b cin cout result aux circ input1 length copying input1 circ input2 b length copying input2 b circ b cin length cout print quot operations completed measuring quot range length result cout result length simulator1 aersimulator results1 execute circ print quot result quot str circ circ p complete error pre code qiskiterror traceback recent call last c lt module gt 31 simulator1 aersimulator 32 results1 execute circ gt 33 print quot result quot str circ 34 circ self experiment 267 268 key gt 269 exp key 270 try 271 header self key 378 379 len exp 0 gt 380 raise qiskiterror experiment quot quot could found key 381 len exp 1 382 exp exp 0 p problem lie number qbits simulator able handle anything else eventually want perform different operations least 128 qbits registers order simulate practical symmetric,"[(0, 0.39365172), (2, 0.08055482), (5, 0.03522818), (6, 0.01240153), (7, 0.027922451), (8, 0.06691852), (9, 0.02341867), (13, 0.057157047), (14, 0.19752133), (17, 0.010526342), (19, 0.09434052)]"
28154,,2022-09-13 06:59:28,1,25,"<p>I have written a simple projectq code with 8qbits in order to perform full addition but it gets stuck somewhere between without generating any error message. It worked fine for 4 qbits.</p>
<pre><code>def full_adder(eng,x,y,length,s,cin,cout):
    aux = eng.allocate_qureg(4)

    print(&quot;Going into loop to perform operations \n&quot;)

    for i in range(length):
        Toffoli | (x[i], y[i], aux[1])
        CNOT | (x[i], s[i])
        CNOT | (y[i], s[i])
        Toffoli | (cin, s[i], aux[0])
        CNOT | (cin, s[i])
        CNOT | (aux[0], aux[2])
        CNOT | (aux[1], aux[2])
        Toffoli | (aux[0], aux[1], aux[3])
        CNOT | (aux[2], cout)
        CNOT | (aux[3], cout)
    
    print(&quot;Addition completed going out of the loop \n&quot;)

def main(eng):
    x = eng.allocate_qureg(8)  # first
    y = eng.allocate_qureg(8)  # second
    s = eng.allocate_qureg(8)  # sum
    cout = eng.allocate_qureg(1) # carry out
    cin = eng.allocate_qureg(1) # carry in

    length=8

    input1=0xab
    input2=0x12

    Round_constant_XOR(eng,x,input1,length)
    Round_constant_XOR(eng,y,input2,length)
    print(&quot;About to start Addition \n&quot;)
    full_adder(eng,x,y,length,s,cin,cout)
    print(&quot;Addition Completed, printing results \n&quot;)
    print_state(eng,s,length)

Simulate = MainEngine()
main(Simulate)
Simulate.flush()   
</code></pre>
<p>Below is the output</p>
<pre><code>(Note: This is the (slow) Python simulator.)
About to start Addition 

Going into loop to perform operations 

Addition completed going out of the loop 
</code></pre>
<p>Once it gets out of the <code>full_adder</code> function, it gets stuck, and nothing happens after this.</p>
",projectq code hangs with only 8 qibts,<programming><simulation><projectq>,0,0,,,"projectq code hangs with only 8 qibts <p>I have written a simple projectq code with 8qbits in order to perform full addition but it gets stuck somewhere between without generating any error message. It worked fine for 4 qbits.</p>
<pre><code>def full_adder(eng,x,y,length,s,cin,cout):
    aux = eng.allocate_qureg(4)

    print(&quot;Going into loop to perform operations \n&quot;)

    for i in range(length):
        Toffoli | (x[i], y[i], aux[1])
        CNOT | (x[i], s[i])
        CNOT | (y[i], s[i])
        Toffoli | (cin, s[i], aux[0])
        CNOT | (cin, s[i])
        CNOT | (aux[0], aux[2])
        CNOT | (aux[1], aux[2])
        Toffoli | (aux[0], aux[1], aux[3])
        CNOT | (aux[2], cout)
        CNOT | (aux[3], cout)
    
    print(&quot;Addition completed going out of the loop \n&quot;)

def main(eng):
    x = eng.allocate_qureg(8)  # first
    y = eng.allocate_qureg(8)  # second
    s = eng.allocate_qureg(8)  # sum
    cout = eng.allocate_qureg(1) # carry out
    cin = eng.allocate_qureg(1) # carry in

    length=8

    input1=0xab
    input2=0x12

    Round_constant_XOR(eng,x,input1,length)
    Round_constant_XOR(eng,y,input2,length)
    print(&quot;About to start Addition \n&quot;)
    full_adder(eng,x,y,length,s,cin,cout)
    print(&quot;Addition Completed, printing results \n&quot;)
    print_state(eng,s,length)

Simulate = MainEngine()
main(Simulate)
Simulate.flush()   
</code></pre>
<p>Below is the output</p>
<pre><code>(Note: This is the (slow) Python simulator.)
About to start Addition 

Going into loop to perform operations 

Addition completed going out of the loop 
</code></pre>
<p>Once it gets out of the <code>full_adder</code> function, it gets stuck, and nothing happens after this.</p>
",qc,projectq code hangs 8 qibts p written simple projectq code 8qbits order perform full addition gets stuck somewhere without generating error message worked fine 4 pre code def eng x length cin cout aux 4 print quot going loop perform operations quot range length toffoli x aux 1 cnot x cnot toffoli cin aux 0 cnot cin cnot aux 0 aux 2 cnot aux 1 aux 2 toffoli aux 0 aux 1 aux 3 cnot aux 2 cout cnot aux 3 cout print quot addition completed going loop quot def main eng x 8 first 8 second 8 sum cout 1 carry cin 1 carry eng x input1 length eng input2 length print quot start addition quot eng x length cin cout print quot addition completed printing results quot eng length simulate mainengine main simulate p output pre code note slow python simulator start addition going loop perform operations addition completed going loop p gets code function gets stuck nothing happens,"[(0, 0.07443949), (2, 0.113359615), (6, 0.048913456), (9, 0.082145005), (10, 0.059505135), (13, 0.045283735), (14, 0.35926276), (17, 0.10713303), (19, 0.10916726)]"
28204,28216.0,2022-09-17 21:46:28,6,928,"<p>We know that the angle between two orthogonal qubit states is 90 degrees. Why then, when we use the Bloch sphere, the angle becomes 180 degrees?</p>
",Why are orthogonal quantum states represented as collinear in the Bloch sphere?,<quantum-state><textbook-and-exercises><bloch-sphere>,1,2,,,"Why are orthogonal quantum states represented as collinear in the Bloch sphere? <p>We know that the angle between two orthogonal qubit states is 90 degrees. Why then, when we use the Bloch sphere, the angle becomes 180 degrees?</p>
",qc,orthogonal quantum states represented collinear bloch sphere p know angle two orthogonal qubit states 90 degrees use bloch sphere angle becomes 180 degrees,"[(3, 0.26350644), (9, 0.21400782), (13, 0.4558676), (17, 0.059407417)]"
28208,,2022-09-18 04:13:59,4,71,"<p>In <a href=""https://arxiv.org/abs/1703.01517"" rel=""nofollow noreferrer"">arXiv 1703.01517</a> (published <a href=""https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.033042"" rel=""nofollow noreferrer"">here</a>), a maximum likelihood decoding for qubit loss is explained.</p>
<p>A quantum erasure channel erases each qubit independently with some probability <span class=""math-container"">$p$</span> and replaces it with a totally mixed state <span class=""math-container"">$\mathcal I/2 = \frac{1}{4}(\rho + X\rho X + Y\rho Y + Z\rho Z)$</span>. This new qubit can be interpreted as the original state which suffers from a Pauli error <span class=""math-container"">$I, X, Y, Z$</span> chosen uniformly at random. The set of lost qubits is denoted <span class=""math-container"">$\mathcal E$</span> and the encoded state is subjected to a random uniform Pauli error <span class=""math-container"">$P$</span> whose support is included in <span class=""math-container"">$E$</span>. This condition is denoted as <span class=""math-container"">$P \subset \mathcal E$</span>.</p>
<p>Like for surface codes, one can measure the stabilizer generators <span class=""math-container"">$X_v$</span> and <span class=""math-container"">$Z_f$</span> and try to recover the error <span class=""math-container"">$P$</span> from its syndrome. The main difference with the Pauli channels is the additional knowledge of the erasure pattern <span class=""math-container"">$\mathcal E$</span>.</p>
<p>Since the operators in <span class=""math-container"">$S$</span> act trivially on the code space, the goal of the decoder is to identify the coset <span class=""math-container"">$P.S$</span> of the error, knowing the set <span class=""math-container"">$\mathcal E$</span> and the syndrome <span class=""math-container"">$\sigma$</span> of <span class=""math-container"">$P$</span>. The optimal strategy called <em>maximum likelihood decoding</em>, whose goal is to maximize the probability <span class=""math-container"">$\mathbb P(P.S|\mathcal E, \sigma)$</span>.</p>
<p>Then the paper has the following statement:</p>
<p><em>Due to the fact that errors <span class=""math-container"">$Q \subset \mathcal E$</span> are uniformly distributed,
(1) <span class=""math-container"">$\mathbb P(Q.S|\mathcal E, \sigma)$</span> is proportional to the number <span class=""math-container"">$|Q.S \cap \mathcal E|$</span> of Pauli errors of that coset that are included in <span class=""math-container"">$\mathcal E$</span>. (2) This number depends only on the number <span class=""math-container"">$|S \cap \mathcal E|$</span> of stabilizers having support inside <span class=""math-container"">$\mathcal E$</span>, which shows that all the cosets are equiprobable.</em></p>
<p>I don't understand how (1) and (2) follow from the fact that individual qubit errors in <span class=""math-container"">$Q$</span> have probability <span class=""math-container"">$p$</span> and are uniformly randomly chosen from Pauli <span class=""math-container"">$I$</span>, <span class=""math-container"">$X$</span>, <span class=""math-container"">$Y$</span>, <span class=""math-container"">$Z$</span>. Can someone explain this to me?</p>
<p>Thinking visually, say there is a straight line erasure chain <span class=""math-container"">$\mathcal E$</span> spanning <span class=""math-container"">$5$</span> qubits in a <span class=""math-container"">$10 \times 10$</span> square lattice toric code. Then in scenario (a) suppose there is a Pauli error on only one qubit in <span class=""math-container"">$\mathcal E$</span> and in scenario (b) suppose there is a Pauli error on three different qubits in <span class=""math-container"">$\mathcal E$</span>. I do not see why the cosets to which these two kinds of errors belong must have the same number of elements?</p>
",Why are all the error cosets $Q.S$ given the erasure chain $\mathcal E$ and a syndrome $\sigma$ equiprobable? (Delfosse-Zémor),<error-correction><surface-code><toric-code>,0,0,,,"Why are all the error cosets $Q.S$ given the erasure chain $\mathcal E$ and a syndrome $\sigma$ equiprobable? (Delfosse-Zémor) <p>In <a href=""https://arxiv.org/abs/1703.01517"" rel=""nofollow noreferrer"">arXiv 1703.01517</a> (published <a href=""https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.033042"" rel=""nofollow noreferrer"">here</a>), a maximum likelihood decoding for qubit loss is explained.</p>
<p>A quantum erasure channel erases each qubit independently with some probability <span class=""math-container"">$p$</span> and replaces it with a totally mixed state <span class=""math-container"">$\mathcal I/2 = \frac{1}{4}(\rho + X\rho X + Y\rho Y + Z\rho Z)$</span>. This new qubit can be interpreted as the original state which suffers from a Pauli error <span class=""math-container"">$I, X, Y, Z$</span> chosen uniformly at random. The set of lost qubits is denoted <span class=""math-container"">$\mathcal E$</span> and the encoded state is subjected to a random uniform Pauli error <span class=""math-container"">$P$</span> whose support is included in <span class=""math-container"">$E$</span>. This condition is denoted as <span class=""math-container"">$P \subset \mathcal E$</span>.</p>
<p>Like for surface codes, one can measure the stabilizer generators <span class=""math-container"">$X_v$</span> and <span class=""math-container"">$Z_f$</span> and try to recover the error <span class=""math-container"">$P$</span> from its syndrome. The main difference with the Pauli channels is the additional knowledge of the erasure pattern <span class=""math-container"">$\mathcal E$</span>.</p>
<p>Since the operators in <span class=""math-container"">$S$</span> act trivially on the code space, the goal of the decoder is to identify the coset <span class=""math-container"">$P.S$</span> of the error, knowing the set <span class=""math-container"">$\mathcal E$</span> and the syndrome <span class=""math-container"">$\sigma$</span> of <span class=""math-container"">$P$</span>. The optimal strategy called <em>maximum likelihood decoding</em>, whose goal is to maximize the probability <span class=""math-container"">$\mathbb P(P.S|\mathcal E, \sigma)$</span>.</p>
<p>Then the paper has the following statement:</p>
<p><em>Due to the fact that errors <span class=""math-container"">$Q \subset \mathcal E$</span> are uniformly distributed,
(1) <span class=""math-container"">$\mathbb P(Q.S|\mathcal E, \sigma)$</span> is proportional to the number <span class=""math-container"">$|Q.S \cap \mathcal E|$</span> of Pauli errors of that coset that are included in <span class=""math-container"">$\mathcal E$</span>. (2) This number depends only on the number <span class=""math-container"">$|S \cap \mathcal E|$</span> of stabilizers having support inside <span class=""math-container"">$\mathcal E$</span>, which shows that all the cosets are equiprobable.</em></p>
<p>I don't understand how (1) and (2) follow from the fact that individual qubit errors in <span class=""math-container"">$Q$</span> have probability <span class=""math-container"">$p$</span> and are uniformly randomly chosen from Pauli <span class=""math-container"">$I$</span>, <span class=""math-container"">$X$</span>, <span class=""math-container"">$Y$</span>, <span class=""math-container"">$Z$</span>. Can someone explain this to me?</p>
<p>Thinking visually, say there is a straight line erasure chain <span class=""math-container"">$\mathcal E$</span> spanning <span class=""math-container"">$5$</span> qubits in a <span class=""math-container"">$10 \times 10$</span> square lattice toric code. Then in scenario (a) suppose there is a Pauli error on only one qubit in <span class=""math-container"">$\mathcal E$</span> and in scenario (b) suppose there is a Pauli error on three different qubits in <span class=""math-container"">$\mathcal E$</span>. I do not see why the cosets to which these two kinds of errors belong must have the same number of elements?</p>
",qc,error cosets given erasure chain e syndrome equiprobable p https nofollow noreferrer arxiv published https nofollow noreferrer maximum likelihood decoding qubit loss p quantum erasure channel erases qubit independently probability span p replaces totally mixed state span 1 4 x z new qubit interpreted original state suffers pauli error span x z chosen uniformly random set lost qubits denoted span e encoded state subjected random uniform pauli error span p whose support included span e condition denoted span p e p like surface codes one measure stabilizer generators span span try recover error span p syndrome main difference pauli channels additional knowledge erasure pattern span e p since operators span act trivially code space goal decoder identify coset span error knowing set span e syndrome span span p optimal strategy called em maximum likelihood decoding whose goal maximize probability span p e p paper following statement p em due fact errors span q e uniformly distributed 1 span p e proportional number span pauli errors coset included span e 2 number depends number span stabilizers support inside span e shows cosets p understand 1 2 follow fact individual qubit errors span q probability span p uniformly randomly chosen pauli span span x span span z someone explain p thinking visually say straight line erasure chain span e spanning span 5 qubits span 10 10 square lattice toric code scenario suppose pauli error one qubit span e scenario b suppose pauli error three different qubits span e see cosets two kinds errors belong must number elements,"[(3, 0.63706934), (4, 0.019201675), (5, 0.19938047), (6, 0.017182961), (7, 0.024336785), (10, 0.020268451), (13, 0.01361918), (17, 0.04552726), (18, 0.019006386)]"
28234,,2022-09-20 13:09:11,2,114,"<p>I have been studying serial concatenations of quantum channels, i.e. <span class=""math-container"">$\mathcal{N}_{A\rightarrow B}=\mathcal{N}_1\circ\mathcal{N}_2=\mathcal{N}_{B'\rightarrow B}\circ\mathcal{N}_{A\rightarrow B'}$</span>. Here <span class=""math-container"">$A$</span>,<span class=""math-container"">$B'$</span> and <span class=""math-container"">$B$</span> refer to the initial system, the intermediate system and the output system.</p>
<p>I was wondering if acomplementary channel to the environment can be obtained by using the complementary channels of the individual channels. My reasoning would be that if we want to obtain complementary channel <span class=""math-container"">$\mathcal{N}^c_{A\rightarrow E}$</span>, we can obtain such by the following concatenation:
<span class=""math-container"">\begin{equation}
\mathcal{N}^c_{A\rightarrow E}=\mathcal{N}^c_{B'\rightarrow E}\circ\mathcal{N}_{A\rightarrow B'}.
\end{equation}</span></p>
<p>Is this correct? If not, where is the problem in my reasoning and is there any way to get such a complementary channel?</p>
",What is the complementary map of a serial concatenation of quantum channels?,<quantum-operation><noise><channel-capacity>,1,0,,,"What is the complementary map of a serial concatenation of quantum channels? <p>I have been studying serial concatenations of quantum channels, i.e. <span class=""math-container"">$\mathcal{N}_{A\rightarrow B}=\mathcal{N}_1\circ\mathcal{N}_2=\mathcal{N}_{B'\rightarrow B}\circ\mathcal{N}_{A\rightarrow B'}$</span>. Here <span class=""math-container"">$A$</span>,<span class=""math-container"">$B'$</span> and <span class=""math-container"">$B$</span> refer to the initial system, the intermediate system and the output system.</p>
<p>I was wondering if acomplementary channel to the environment can be obtained by using the complementary channels of the individual channels. My reasoning would be that if we want to obtain complementary channel <span class=""math-container"">$\mathcal{N}^c_{A\rightarrow E}$</span>, we can obtain such by the following concatenation:
<span class=""math-container"">\begin{equation}
\mathcal{N}^c_{A\rightarrow E}=\mathcal{N}^c_{B'\rightarrow E}\circ\mathcal{N}_{A\rightarrow B'}.
\end{equation}</span></p>
<p>Is this correct? If not, where is the problem in my reasoning and is there any way to get such a complementary channel?</p>
",qc,complementary map serial concatenation quantum channels p studying serial concatenations quantum channels span n b n n n b n b span span b span b refer initial system intermediate system output p wondering acomplementary channel environment obtained using complementary channels individual channels reasoning would want obtain complementary channel span n e obtain following concatenation span equation n e n e n b equation p correct problem reasoning way get complementary channel,"[(1, 0.039970998), (3, 0.88111144), (9, 0.04010488), (17, 0.03653198)]"
28252,28253.0,2022-09-21 20:49:49,2,85,"<p>Let's say you want to investigate if a quantum error correction or error mitigation protocol performs better under dephasing errors compared to depolarizing errors, or if a quantum algorithm is more robust against dephasing errors compared to depolarizing errors, or vice versa. Which one of the two following definitions for the error channels would provide the most fair comparison?</p>
<hr />
<h1>Option 1</h1>
<p>Define the depolarizing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{dep}(\rho) = \left(1-\frac{3}{4}\epsilon\right)\rho + \frac{\epsilon}{4}\left(X\rho X + Y\rho Y + Z\rho Z\right) = (1-\epsilon)\rho + \frac{\epsilon}{2}I,
$$</span>
where <span class=""math-container"">$X,Y,Z$</span> are Pauli matrices and <span class=""math-container"">$\epsilon\in[0,1]$</span> is the error probability, and define the dephasing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{Z}(\rho) = \left(1-\frac{\epsilon}{2}\right)\rho + \frac{\epsilon}{2} Z\rho Z.
$$</span>
Using this definition, when <span class=""math-container"">$\epsilon=1$</span>, we get a fully mixed state for the depolarizing channel and a fully dephased state for the dephasing channel.</p>
<hr />
<h1>Option 2</h1>
<p>Define the depolarizing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{dep}(\rho) = \left(1-\epsilon\right)\rho + \frac{\epsilon}{3}\left(X\rho X + Y\rho Y + Z\rho Z\right) = \left(1-\frac{4}{3}\epsilon\right)\rho + \frac{2}{3}\epsilon I,
$$</span>
and define the dephasing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{Z}(\rho) = \left(1-\epsilon\right)\rho + \epsilon Z\rho Z.
$$</span>
In this case we can interpret the two channels as having the same probability of an error occurring. However, in this case the worst case upper bounds are different for the two channels: <span class=""math-container"">$\epsilon_\mathrm{worst}=3/4$</span> for the depolarizing channel, and <span class=""math-container"">$\epsilon_\mathrm{worst}=1/2$</span> for the dephasing channel.</p>
<hr />
<p>So relating back to the opening of this question. If I want to simulate a QEC protocol to see if it performs better under dephasing errors compared to depolarizing errors, should I go with <strong>Option 1</strong> or <strong>Option 2</strong>?</p>
",Which error channel definitions should I use if I want to compare the performance of a QEC protocol for depolarizing errors vs dephasing errors?,<noise><error-mitigation>,1,3,,,"Which error channel definitions should I use if I want to compare the performance of a QEC protocol for depolarizing errors vs dephasing errors? <p>Let's say you want to investigate if a quantum error correction or error mitigation protocol performs better under dephasing errors compared to depolarizing errors, or if a quantum algorithm is more robust against dephasing errors compared to depolarizing errors, or vice versa. Which one of the two following definitions for the error channels would provide the most fair comparison?</p>
<hr />
<h1>Option 1</h1>
<p>Define the depolarizing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{dep}(\rho) = \left(1-\frac{3}{4}\epsilon\right)\rho + \frac{\epsilon}{4}\left(X\rho X + Y\rho Y + Z\rho Z\right) = (1-\epsilon)\rho + \frac{\epsilon}{2}I,
$$</span>
where <span class=""math-container"">$X,Y,Z$</span> are Pauli matrices and <span class=""math-container"">$\epsilon\in[0,1]$</span> is the error probability, and define the dephasing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{Z}(\rho) = \left(1-\frac{\epsilon}{2}\right)\rho + \frac{\epsilon}{2} Z\rho Z.
$$</span>
Using this definition, when <span class=""math-container"">$\epsilon=1$</span>, we get a fully mixed state for the depolarizing channel and a fully dephased state for the dephasing channel.</p>
<hr />
<h1>Option 2</h1>
<p>Define the depolarizing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{dep}(\rho) = \left(1-\epsilon\right)\rho + \frac{\epsilon}{3}\left(X\rho X + Y\rho Y + Z\rho Z\right) = \left(1-\frac{4}{3}\epsilon\right)\rho + \frac{2}{3}\epsilon I,
$$</span>
and define the dephasing channel as
<span class=""math-container"">$$
\Lambda_\mathrm{Z}(\rho) = \left(1-\epsilon\right)\rho + \epsilon Z\rho Z.
$$</span>
In this case we can interpret the two channels as having the same probability of an error occurring. However, in this case the worst case upper bounds are different for the two channels: <span class=""math-container"">$\epsilon_\mathrm{worst}=3/4$</span> for the depolarizing channel, and <span class=""math-container"">$\epsilon_\mathrm{worst}=1/2$</span> for the dephasing channel.</p>
<hr />
<p>So relating back to the opening of this question. If I want to simulate a QEC protocol to see if it performs better under dephasing errors compared to depolarizing errors, should I go with <strong>Option 1</strong> or <strong>Option 2</strong>?</p>
",qc,error channel definitions use want compare performance qec protocol depolarizing errors vs dephasing errors p let say want investigate quantum error correction error mitigation protocol performs better dephasing errors compared depolarizing errors quantum algorithm robust dephasing errors compared depolarizing errors vice versa one two following definitions error channels would provide fair comparison hr h1 option 1 p define depolarizing channel span dep 3 4 4 x 2 span x z pauli matrices span error probability define dephasing channel span z 2 2 z using definition span get fully mixed state depolarizing channel fully dephased state dephasing hr h1 option 2 p define depolarizing channel span dep 3 x 4 3 2 3 define dephasing channel span z z case interpret two channels probability error occurring however case worst case upper bounds different two channels span worst depolarizing channel span worst dephasing hr p relating back opening question want simulate qec protocol see performs better dephasing errors compared depolarizing errors go strong option 1 strong option 2,"[(2, 0.040321335), (3, 0.35368198), (5, 0.31044555), (6, 0.039904084), (10, 0.023284351), (13, 0.0556327), (17, 0.089783326), (18, 0.08620609)]"
28333,28354.0,2022-09-29 13:26:15,2,212,"<p>In the module <a href=""https://github.com/oscarhiggott/PyMatching/blob/master/src/pymatching/matching.py"" rel=""nofollow noreferrer"">matching.py</a> of <a href=""https://github.com/oscarhiggott/PyMatching"" rel=""nofollow noreferrer"">PyMatching</a>, it is possible to construct Matching objects to decode matching graphs using the minimum-weight perfect matching decoder.
The <code>decode()</code> method returns the most probable correction and &quot;The sum of the weights of the edges in the minimum-weight perfect matching&quot;.</p>
<p>Is it possible to get the matched nodes of the graph ?</p>
",How to get the matched nodes using Matching.decode() in PyMatching?,<error-correction><surface-code><toric-code>,1,0,,,"How to get the matched nodes using Matching.decode() in PyMatching? <p>In the module <a href=""https://github.com/oscarhiggott/PyMatching/blob/master/src/pymatching/matching.py"" rel=""nofollow noreferrer"">matching.py</a> of <a href=""https://github.com/oscarhiggott/PyMatching"" rel=""nofollow noreferrer"">PyMatching</a>, it is possible to construct Matching objects to decode matching graphs using the minimum-weight perfect matching decoder.
The <code>decode()</code> method returns the most probable correction and &quot;The sum of the weights of the edges in the minimum-weight perfect matching&quot;.</p>
<p>Is it possible to get the matched nodes of the graph ?</p>
",qc,get matched nodes using pymatching p module https nofollow noreferrer https nofollow noreferrer pymatching possible construct matching objects decode matching graphs using perfect matching decoder code decode method returns probable correction quot sum weights edges perfect matching quot p possible get matched nodes graph,"[(4, 0.16756272), (5, 0.17569612), (13, 0.17315201), (14, 0.23917253), (17, 0.17323366), (19, 0.06801324)]"
28352,28388.0,2022-09-30 10:58:46,2,468,"<p>My end goal is to recover the quantum state in its computational basis or reduced density matrix of a high number qubit circuit in a real QPU. Taking into account that the number of qubits will be high (+16 or +32 qubits) getting the density matrix as it is done in the common quantum state tomography algorithms is unfeasible.</p>
<p>My idea is to try tomography with Pauli basis measurements to get the individual reduced density matrix of each qubit, but due to the high number of qubits, the number of measurements required will be huge too.</p>
<p>I was wondering if there is a feasible way to get this or in case there isn't which option would be the least unfeasible to continue researching on it. Thanks in advance.</p>
<p>Pd: the circuit is a 16 or 32 qubit circuit with some hadamard, cnot and u(rotation) gates.</p>
",State tomography with Pauli basis measurements for a high number of qubits,<qiskit><quantum-state><density-matrix><state-tomography><shadow-tomography>,1,0,,,"State tomography with Pauli basis measurements for a high number of qubits <p>My end goal is to recover the quantum state in its computational basis or reduced density matrix of a high number qubit circuit in a real QPU. Taking into account that the number of qubits will be high (+16 or +32 qubits) getting the density matrix as it is done in the common quantum state tomography algorithms is unfeasible.</p>
<p>My idea is to try tomography with Pauli basis measurements to get the individual reduced density matrix of each qubit, but due to the high number of qubits, the number of measurements required will be huge too.</p>
<p>I was wondering if there is a feasible way to get this or in case there isn't which option would be the least unfeasible to continue researching on it. Thanks in advance.</p>
<p>Pd: the circuit is a 16 or 32 qubit circuit with some hadamard, cnot and u(rotation) gates.</p>
",qc,state tomography pauli basis measurements high number qubits p end goal recover quantum state computational basis reduced density matrix high number qubit circuit real qpu taking account number qubits high qubits getting density matrix done common quantum state tomography algorithms p idea try tomography pauli basis measurements get individual reduced density matrix qubit due high number qubits number measurements required huge p wondering feasible way get case option would least unfeasible continue researching thanks p pd circuit 16 32 qubit circuit hadamard cnot u rotation,"[(3, 0.02737634), (6, 0.012429012), (8, 0.11290863), (9, 0.051113218), (11, 0.08012235), (14, 0.40255418), (17, 0.011744104), (18, 0.3003261)]"
28357,,2022-09-30 16:24:27,5,509,"<p>So I'm auto-constructing quantum circuits that are being auto-generated from dimacs files along with the addition of the amplification function. It's for a satisfiability problem where the number of variables is 9. I end up with a quantum circuit depth that is 6k-10k. The results that I'm getting at the end are always wrong after 3 the execution of 3 different circuits(8k shots each) on the Kolkota processor.</p>
<p><strong>Getting to the question</strong> : Is it expected to always get wrong answers with such a depth or is the situation salvagable?</p>
",Reasonable Circuit Depth,<qiskit><ibm-quantum-devices>,2,0,,,"Reasonable Circuit Depth <p>So I'm auto-constructing quantum circuits that are being auto-generated from dimacs files along with the addition of the amplification function. It's for a satisfiability problem where the number of variables is 9. I end up with a quantum circuit depth that is 6k-10k. The results that I'm getting at the end are always wrong after 3 the execution of 3 different circuits(8k shots each) on the Kolkota processor.</p>
<p><strong>Getting to the question</strong> : Is it expected to always get wrong answers with such a depth or is the situation salvagable?</p>
",qc,reasonable circuit depth p quantum circuits dimacs files along addition amplification function satisfiability problem number variables end quantum circuit depth results getting end always wrong 3 execution 3 different circuits 8k shots kolkota p strong getting question expected always get wrong answers depth situation salvagable,"[(1, 0.05751374), (6, 0.043199047), (7, 0.15997933), (14, 0.6585218), (17, 0.027806232), (18, 0.04966078)]"
28359,28362.0,2022-09-30 16:52:31,4,734,"<p>The <a href=""https://github.com/quantumlib/stim"" rel=""nofollow noreferrer"">Stim package</a> is a tool for simulation and analysis of quantum stabilizer circuits. Stim's built-in surface code circuit generation, <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.6-Python-API-Reference#stim.Circuit.generated"" rel=""nofollow noreferrer"">stim.Circuit.generated</a>, can run different code tasks (rotated and unrotated surface codes for X and Z error probabilities for example) and takes as parameter the &quot;desired code distance of the generated circuit&quot;.
Is it possible to give two distances <span class=""math-container"">$d_X$</span> and <span class=""math-container"">$d_Z$</span> for rectangular surface codes ?</p>
",How to simulate rectangular surface code with stim?,<error-correction><surface-code><stim>,1,0,,,"How to simulate rectangular surface code with stim? <p>The <a href=""https://github.com/quantumlib/stim"" rel=""nofollow noreferrer"">Stim package</a> is a tool for simulation and analysis of quantum stabilizer circuits. Stim's built-in surface code circuit generation, <a href=""https://github.com/quantumlib/Stim/wiki/Stim-v1.6-Python-API-Reference#stim.Circuit.generated"" rel=""nofollow noreferrer"">stim.Circuit.generated</a>, can run different code tasks (rotated and unrotated surface codes for X and Z error probabilities for example) and takes as parameter the &quot;desired code distance of the generated circuit&quot;.
Is it possible to give two distances <span class=""math-container"">$d_X$</span> and <span class=""math-container"">$d_Z$</span> for rectangular surface codes ?</p>
",qc,simulate rectangular surface code stim p https nofollow noreferrer stim package tool simulation analysis quantum stabilizer circuits stim surface code circuit generation https nofollow noreferrer run different code tasks rotated unrotated surface codes x z error probabilities example takes parameter quot desired code distance generated circuit quot possible give two distances span span rectangular surface codes,"[(3, 0.08573072), (4, 0.12182543), (5, 0.32218865), (9, 0.049701095), (10, 0.014416188), (14, 0.34102005), (17, 0.023274709), (19, 0.039704714)]"
28445,28446.0,2022-10-06 22:03:38,2,1205,"<p>The depolarizing channel for an n-qubit quantum circuit is defined as
<span class=""math-container"">$$
\mathcal{E}(\rho) = \frac{pI}{2^n}\text{Tr}(\rho)+(1-p)\rho,\quad\text{where}
\quad\rho \equiv\sum_ip_i|\psi_i\rangle\langle\psi_i|.
$$</span>
My question is: is <span class=""math-container"">$\text{Tr}(\rho)$</span> necessary in the definition? Since the density matrices have a trace of <span class=""math-container"">$1$</span>, I was wondering if the term here has something to do with generalizing the definition for different input states or circuits.</p>
",Depolarizing channel for $n$ qubits: why is there a trace term?,<quantum-operation><depolarizing-channel>,1,1,,,"Depolarizing channel for $n$ qubits: why is there a trace term? <p>The depolarizing channel for an n-qubit quantum circuit is defined as
<span class=""math-container"">$$
\mathcal{E}(\rho) = \frac{pI}{2^n}\text{Tr}(\rho)+(1-p)\rho,\quad\text{where}
\quad\rho \equiv\sum_ip_i|\psi_i\rangle\langle\psi_i|.
$$</span>
My question is: is <span class=""math-container"">$\text{Tr}(\rho)$</span> necessary in the definition? Since the density matrices have a trace of <span class=""math-container"">$1$</span>, I was wondering if the term here has something to do with generalizing the definition for different input states or circuits.</p>
",qc,depolarizing channel n qubits trace term p depolarizing channel quantum circuit defined span e pi tr question span tr necessary definition since density matrices trace span 1 wondering term something generalizing definition different input states,"[(0, 0.035771962), (3, 0.74551773), (11, 0.048953433), (14, 0.074288175), (17, 0.09120635)]"
28462,,2022-10-08 14:16:00,7,663,"<p>The 2022 Nobel Prize in Physics was <a href=""https://www.nobelprize.org/prizes/physics/2022/press-release/"" rel=""noreferrer"">awarded to</a> Alain Aspect, John Clauser, and Anton Zeilinger for &quot;experiments with entangled photons... pioneering quantum information science&quot;.</p>
<p>Presumably there were noteworthy publications of each.</p>
<blockquote>
<p><strong>Are there separate publications at least partially authored by each of the three, that can each be said to be a &quot;Nobel-prize winning paper&quot;?</strong></p>
</blockquote>
<p>The Nobel prizes have historically been awarded for theorists whose work is later experimentally validated; some more recent Nobel prizes have somewhat loosened that theory vs. experiment dichotomy.</p>
<p>Can we create a timeline, with links to papers, from EPR to Bell to CHSH to the 70s - early 80's work of experiments of Clauser and Aspect to the GHZ/teleportation experiments and the Delft experiments, identifying noteworthy <a href=""https://en.wikipedia.org/wiki/Thought_experiment"" rel=""noreferrer"">gedanken</a>- and actual experiments, and how they anticipated or led into each other?</p>
","What are the 2022 Nobel Prize winning papers of Alain Aspect, John Clauser, and Anton Zeilinger, and how do they fit into the timeline of QIS?",<teleportation><bell-experiment><foundations><history>,1,2,,,"What are the 2022 Nobel Prize winning papers of Alain Aspect, John Clauser, and Anton Zeilinger, and how do they fit into the timeline of QIS? <p>The 2022 Nobel Prize in Physics was <a href=""https://www.nobelprize.org/prizes/physics/2022/press-release/"" rel=""noreferrer"">awarded to</a> Alain Aspect, John Clauser, and Anton Zeilinger for &quot;experiments with entangled photons... pioneering quantum information science&quot;.</p>
<p>Presumably there were noteworthy publications of each.</p>
<blockquote>
<p><strong>Are there separate publications at least partially authored by each of the three, that can each be said to be a &quot;Nobel-prize winning paper&quot;?</strong></p>
</blockquote>
<p>The Nobel prizes have historically been awarded for theorists whose work is later experimentally validated; some more recent Nobel prizes have somewhat loosened that theory vs. experiment dichotomy.</p>
<p>Can we create a timeline, with links to papers, from EPR to Bell to CHSH to the 70s - early 80's work of experiments of Clauser and Aspect to the GHZ/teleportation experiments and the Delft experiments, identifying noteworthy <a href=""https://en.wikipedia.org/wiki/Thought_experiment"" rel=""noreferrer"">gedanken</a>- and actual experiments, and how they anticipated or led into each other?</p>
",qc,2022 nobel prize winning papers alain aspect john clauser anton zeilinger fit timeline qis p 2022 nobel prize physics https noreferrer awarded alain aspect john clauser anton zeilinger quot experiments entangled photons pioneering quantum information science quot p presumably noteworthy publications blockquote p strong separate publications least partially authored three said quot winning paper quot p nobel prizes historically awarded theorists whose work later experimentally validated recent nobel prizes somewhat loosened theory experiment p create timeline links papers epr bell chsh 70s early 80 work experiments clauser aspect experiments delft experiments identifying noteworthy https noreferrer gedanken actual experiments anticipated led,"[(7, 0.018664928), (8, 0.121019386), (9, 0.3834162), (12, 0.03925282), (13, 0.20975962), (15, 0.04207694), (17, 0.02550138), (18, 0.10617429), (19, 0.05272264)]"
28492,,2022-10-10 11:03:34,0,374,"<p>I have downloaded a job from the <a href=""https://quantum-computing.ibm.com/jobs"" rel=""nofollow noreferrer"">COMPOSER JOBS</a> but I get a folder containing three files.</p>
<ol>
<li>632867a95ccea778be9446fb-info.json</li>
<li>632867a95ccea778be9446fb-input.json</li>
<li>632867a95ccea778be9446fb-output.json</li>
</ol>
<p>Is there any python code to load my job (from one of these files) and extract my result from it?</p>
",Extracting results from a job when it is in a json form,<qiskit><ibm-quantum-devices><ibm-q-experience>,1,0,,,"Extracting results from a job when it is in a json form <p>I have downloaded a job from the <a href=""https://quantum-computing.ibm.com/jobs"" rel=""nofollow noreferrer"">COMPOSER JOBS</a> but I get a folder containing three files.</p>
<ol>
<li>632867a95ccea778be9446fb-info.json</li>
<li>632867a95ccea778be9446fb-input.json</li>
<li>632867a95ccea778be9446fb-output.json</li>
</ol>
<p>Is there any python code to load my job (from one of these files) and extract my result from it?</p>
",qc,extracting results job json form p downloaded job https nofollow noreferrer composer jobs get folder containing three ol li li li p python code load job one files extract result,"[(0, 0.058915548), (4, 0.18375534), (7, 0.19373104), (14, 0.52207), (17, 0.03638541)]"
28496,,2022-10-10 14:42:49,0,73,"<p>I am wanting to add noise to my code which uses VQE to find ground state energy for LiH at various inter atomic distances. The code I am wanting to add to is the code found from the qiskit text book. <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/vqe-molecules.html</a> under &quot;running VQE on a statevector simulator&quot;</p>
<p>Any help would be greatly appreciated.</p>
<p>Thanks</p>
",Adding controllable noise to VQE to find ground state energy,<qiskit><vqe><noise>,0,2,,,"Adding controllable noise to VQE to find ground state energy <p>I am wanting to add noise to my code which uses VQE to find ground state energy for LiH at various inter atomic distances. The code I am wanting to add to is the code found from the qiskit text book. <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/vqe-molecules.html</a> under &quot;running VQE on a statevector simulator&quot;</p>
<p>Any help would be greatly appreciated.</p>
<p>Thanks</p>
",qc,adding controllable noise vqe find ground state energy p wanting add noise code uses vqe find ground state energy lih various inter atomic distances code wanting add code found qiskit text book https nofollow noreferrer https quot running vqe statevector simulator quot p help would greatly p thanks,"[(4, 0.10220907), (9, 0.105042174), (13, 0.15775195), (14, 0.3841862), (17, 0.20057705), (19, 0.047201686)]"
28508,28509.0,2022-10-11 09:56:31,1,348,"<p>If I've understood correctly, no-cloning theorem prevents copying qubit states during the computation. Could this be used to defend against quantum computers breaking encryption that can run with normal computers with high performance (pretty low memory needs, sensible CPU usage)?</p>
<p>For example, if the actual encryption key were build with</p>
<pre><code>sha256(secret || public_data || secret)
</code></pre>
<p>(where <code>||</code> means concatenating the strings) which would require cloning the unknown <code>secret</code> before doing SHA-256, would that prevent using quantum computer from breaking the encryption (that is, finding the value of <code>secret</code>)? (Of course, the SHA-256 is not a practical example for real world encryption but it illustrates the concept of using the secret keys twice which would need cloning if I've understood correctly.)</p>
","Could ""no cloning"" be used as a defence for quantum encryption?",<cryptography><no-cloning-theorem>,1,0,,,"Could ""no cloning"" be used as a defence for quantum encryption? <p>If I've understood correctly, no-cloning theorem prevents copying qubit states during the computation. Could this be used to defend against quantum computers breaking encryption that can run with normal computers with high performance (pretty low memory needs, sensible CPU usage)?</p>
<p>For example, if the actual encryption key were build with</p>
<pre><code>sha256(secret || public_data || secret)
</code></pre>
<p>(where <code>||</code> means concatenating the strings) which would require cloning the unknown <code>secret</code> before doing SHA-256, would that prevent using quantum computer from breaking the encryption (that is, finding the value of <code>secret</code>)? (Of course, the SHA-256 is not a practical example for real world encryption but it illustrates the concept of using the secret keys twice which would need cloning if I've understood correctly.)</p>
",qc,could cloning used defence quantum encryption p understood correctly theorem prevents copying qubit states computation could used defend quantum computers breaking encryption run normal computers high performance pretty low memory needs sensible cpu usage p example actual encryption key build pre code sha256 secret secret p code means concatenating strings would require cloning unknown code secret would prevent using quantum computer breaking encryption finding value code secret course practical example real world encryption illustrates concept using secret keys twice would need cloning understood correctly,"[(0, 0.021690588), (1, 0.058238287), (3, 0.027996846), (7, 0.17373286), (8, 0.21481882), (13, 0.17195833), (14, 0.27541286), (17, 0.05465169)]"
28511,28512.0,2022-10-11 10:51:36,1,106,"<p>I see the quantum gate
<span class=""math-container"">$U_1^{-1}\circ U_1\circ U_0=U_0$</span>, what is the <span class=""math-container"">$\circ$</span> called and mean?</p>
","What's the symbol $\circ$ called, and what does it mean?",<terminology-and-notation>,2,3,,,"What's the symbol $\circ$ called, and what does it mean? <p>I see the quantum gate
<span class=""math-container"">$U_1^{-1}\circ U_1\circ U_0=U_0$</span>, what is the <span class=""math-container"">$\circ$</span> called and mean?</p>
",qc,symbol called mean p see quantum gate span span called mean,"[(3, 0.30086178), (8, 0.4440208), (9, 0.1501505), (17, 0.090679765)]"
28517,28518.0,2022-10-11 16:07:06,1,655,"<ol>
<li><p>A common practice for simulating CSS code is to only apply the decoder for logical X (or Z) errors. Stim includes example circuits (from stim.Circuit.generated) for &quot;surface_code:unrotated_memory_z&quot; and &quot;surface_code:unrotated_memory_x&quot;. What's the difference between them? If I feed them to PyMatching using sinter, will PyMatching only decode for the logical Z errors on one and the logical X errors on the other?</p>
</li>
<li><p>Another common practice is to include one perfect round of stabilizer measurement after d rounds of noisy stabilizer measurements. If we use Stim together with PyMatching for circuit-level noise simulation as in the tutorial notebook, do we need to include the perfect rounds in the input circuit that is used to generate the detector noise model? The example circuits in Stim (from stim.Circuit.generated) do not include them - only noisy rounds. Is it unnecessary to include them when using Stim/PyMatching?</p>
</li>
</ol>
",Using Stim and PyMatching for circuit level noise simulation,<error-correction><stim>,1,0,,,"Using Stim and PyMatching for circuit level noise simulation <ol>
<li><p>A common practice for simulating CSS code is to only apply the decoder for logical X (or Z) errors. Stim includes example circuits (from stim.Circuit.generated) for &quot;surface_code:unrotated_memory_z&quot; and &quot;surface_code:unrotated_memory_x&quot;. What's the difference between them? If I feed them to PyMatching using sinter, will PyMatching only decode for the logical Z errors on one and the logical X errors on the other?</p>
</li>
<li><p>Another common practice is to include one perfect round of stabilizer measurement after d rounds of noisy stabilizer measurements. If we use Stim together with PyMatching for circuit-level noise simulation as in the tutorial notebook, do we need to include the perfect rounds in the input circuit that is used to generate the detector noise model? The example circuits in Stim (from stim.Circuit.generated) do not include them - only noisy rounds. Is it unnecessary to include them when using Stim/PyMatching?</p>
</li>
</ol>
",qc,using stim pymatching circuit level noise simulation ol li p common practice simulating css code apply decoder logical x z errors stim includes example circuits quot quot quot quot difference feed pymatching using sinter pymatching decode logical z errors one logical x errors li p another common practice include one perfect round stabilizer measurement rounds noisy stabilizer measurements use stim together pymatching noise simulation tutorial notebook need include perfect rounds input circuit used generate detector noise model example circuits stim include noisy rounds unnecessary include using,"[(5, 0.51772577), (10, 0.018119931), (14, 0.34135398), (17, 0.054860387), (19, 0.06619942)]"
28550,,2022-10-15 00:40:23,1,139,"<p><a href=""https://i.sstatic.net/ebOTk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ebOTk.jpg"" alt=""enter image description here"" /></a></p>
<p>Basically, I want to simulate the above photosystem process of light absorption. Above is a diagram of laser beams shot into antenna pigment molecules and traveling to the reaction center. Two theories surround the laser path: Random and shortest distance. The latter is more feasible.</p>
<p><a href=""https://i.sstatic.net/HOQuD.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HOQuD.jpg"" alt=""enter image description here"" /></a></p>
<p>My goal is to simulate the quantum effect behind this process regardless of which pigment molecule the light is being shot at. I came across this github repo on <a href=""https://github.com/fancompute/qpga"" rel=""nofollow noreferrer"">Quantum programmable gate arrays</a> so I want to know how to remodel it to simulate the above process.</p>
",Simulating light absorption in Photosynthesis through Quantum computing,<qiskit><programming><photonics><quantum-biology>,0,7,,,"Simulating light absorption in Photosynthesis through Quantum computing <p><a href=""https://i.sstatic.net/ebOTk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ebOTk.jpg"" alt=""enter image description here"" /></a></p>
<p>Basically, I want to simulate the above photosystem process of light absorption. Above is a diagram of laser beams shot into antenna pigment molecules and traveling to the reaction center. Two theories surround the laser path: Random and shortest distance. The latter is more feasible.</p>
<p><a href=""https://i.sstatic.net/HOQuD.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HOQuD.jpg"" alt=""enter image description here"" /></a></p>
<p>My goal is to simulate the quantum effect behind this process regardless of which pigment molecule the light is being shot at. I came across this github repo on <a href=""https://github.com/fancompute/qpga"" rel=""nofollow noreferrer"">Quantum programmable gate arrays</a> so I want to know how to remodel it to simulate the above process.</p>
",qc,simulating light absorption photosynthesis quantum computing p https nofollow noreferrer img https enter image description p basically want simulate photosystem process light absorption diagram laser beams shot antenna pigment molecules traveling reaction center two theories surround laser path random shortest distance latter p https nofollow noreferrer img https enter image description p goal simulate quantum effect behind process regardless pigment molecule light shot came across github repo https nofollow noreferrer quantum programmable gate arrays want know remodel simulate,"[(4, 0.4291603), (5, 0.019221695), (6, 0.014579262), (7, 0.01825757), (8, 0.18370773), (9, 0.06712806), (12, 0.013959811), (14, 0.1919729), (17, 0.033236105), (19, 0.027384797)]"
28589,,2022-10-18 12:46:37,1,267,"<p>I am looking the example of toric code in Pymatching.</p>
<p>Here is the code:</p>
<pre><code> import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import hstack, kron, eye, csr_matrix, block_diag


def repetition_code(n):
    
    row_ind, col_ind = zip(*((i, j) for i in range(n) for j in (i, (i+1)%n)))
    data = np.ones(2*n, dtype=np.uint8)
    return csr_matrix((data, (row_ind, col_ind)))


def toric_code_x_stabilisers(L):
    Hr = repetition_code(L)
    H = hstack(
            [kron(Hr, eye(Hr.shape[1])), kron(eye(Hr.shape[0]), Hr.T)],
            dtype=np.uint8
        )
    H.data = H.data % 2
    H.eliminate_zeros()
    return csr_matrix(H)
    
    
def toric_code_x_logicals(L):
   
    H1 = csr_matrix(([1], ([0],[0])), shape=(1,L), dtype=np.uint8)
    H0 = csr_matrix(np.ones((1, L), dtype=np.uint8))
    x_logicals = block_diag([kron(H1, H0), kron(H0, H1)])
    x_logicals.data = x_logicals.data % 2
    x_logicals.eliminate_zeros()
    return csr_matrix(x_logicals)
</code></pre>
<ol>
<li><p>I want to test minumum weight perfect matching in Pymatching. I want to run this code in the absence of noise and I want to see what will be the result of pymatching.
To do that, I use the following :</p>
<p>H=toric_code_x_stabilisers(4)</p>
<p>matching = pymatching.Matching(H)</p>
<p>matching.draw()</p>
</li>
</ol>
<p>Is that correct? I see nothing, is it because I have no error in the system or is it because there is some issue with matching.draw() function? Then I tried the following code scripts:</p>
<pre><code> H=toric_code_x_stabilisers(4)
noise = np.array([0,0,0,0]) #no error
z = H@noise % 2
m=Matching(H)
print(m)
m.draw()
c = m.decode(z)
</code></pre>
<p>And I got the dimension mismatch error..</p>
<ol start=""2"">
<li>I want to simulate surface code in the absence of error. It is simply I will initialize my data qubits in zero states and I will use x and z stabilizer. I will measure the stabilizers and I will see the result. For example, when I measure the X stabilizer, they will commute with Z stabilizer etc.. In that case, I am not sure what should change in toric code to make it surface code. It seemed to me that, <code>toric_code_x_stabilisers</code> can stay same. Do we have a small example for surface code?</li>
</ol>
",Pymatching Toric Code vs Surface Code,<programming><surface-code><toric-code><pymatching><minimum-weight-perfect-matching>,1,0,,,"Pymatching Toric Code vs Surface Code <p>I am looking the example of toric code in Pymatching.</p>
<p>Here is the code:</p>
<pre><code> import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import hstack, kron, eye, csr_matrix, block_diag


def repetition_code(n):
    
    row_ind, col_ind = zip(*((i, j) for i in range(n) for j in (i, (i+1)%n)))
    data = np.ones(2*n, dtype=np.uint8)
    return csr_matrix((data, (row_ind, col_ind)))


def toric_code_x_stabilisers(L):
    Hr = repetition_code(L)
    H = hstack(
            [kron(Hr, eye(Hr.shape[1])), kron(eye(Hr.shape[0]), Hr.T)],
            dtype=np.uint8
        )
    H.data = H.data % 2
    H.eliminate_zeros()
    return csr_matrix(H)
    
    
def toric_code_x_logicals(L):
   
    H1 = csr_matrix(([1], ([0],[0])), shape=(1,L), dtype=np.uint8)
    H0 = csr_matrix(np.ones((1, L), dtype=np.uint8))
    x_logicals = block_diag([kron(H1, H0), kron(H0, H1)])
    x_logicals.data = x_logicals.data % 2
    x_logicals.eliminate_zeros()
    return csr_matrix(x_logicals)
</code></pre>
<ol>
<li><p>I want to test minumum weight perfect matching in Pymatching. I want to run this code in the absence of noise and I want to see what will be the result of pymatching.
To do that, I use the following :</p>
<p>H=toric_code_x_stabilisers(4)</p>
<p>matching = pymatching.Matching(H)</p>
<p>matching.draw()</p>
</li>
</ol>
<p>Is that correct? I see nothing, is it because I have no error in the system or is it because there is some issue with matching.draw() function? Then I tried the following code scripts:</p>
<pre><code> H=toric_code_x_stabilisers(4)
noise = np.array([0,0,0,0]) #no error
z = H@noise % 2
m=Matching(H)
print(m)
m.draw()
c = m.decode(z)
</code></pre>
<p>And I got the dimension mismatch error..</p>
<ol start=""2"">
<li>I want to simulate surface code in the absence of error. It is simply I will initialize my data qubits in zero states and I will use x and z stabilizer. I will measure the stabilizers and I will see the result. For example, when I measure the X stabilizer, they will commute with Z stabilizer etc.. In that case, I am not sure what should change in toric code to make it surface code. It seemed to me that, <code>toric_code_x_stabilisers</code> can stay same. Do we have a small example for surface code?</li>
</ol>
",qc,pymatching toric code vs surface code p looking example toric code p code pre code import numpy np import plt import hstack kron eye def n zip j range n j n data 2 n return data def l hr l h hstack kron hr eye 1 kron eye 0 2 return h def l h1 1 0 0 1 l h0 1 l kron h1 h0 kron h0 h1 2 return ol li p want test minumum weight perfect matching pymatching want run code absence noise want see result pymatching use following p 4 p matching h p p correct see nothing error system issue function tried following code scripts pre code 4 noise error z h noise 2 h print c z p got dimension mismatch error ol 2 li want simulate surface code absence error simply initialize data qubits zero states use x z stabilizer measure stabilizers see result example measure x stabilizer commute z stabilizer etc case sure change toric code make surface code seemed code stay small example surface code,"[(0, 0.32384676), (2, 0.070611455), (3, 0.04185009), (5, 0.30418342), (6, 0.01290238), (10, 0.011607281), (14, 0.07319989), (17, 0.11408737), (19, 0.041364048)]"
28599,,2022-10-19 02:51:26,2,108,"<p>Qubits can be represented by a state vector <span class=""math-container"">$\psi \in \mathbb{C}^{2^N}$</span>, where <span class=""math-container"">$N$</span> is the number of qubits.</p>
<p>The higher <span class=""math-container"">$| \psi_i |$</span> is, for any index <span class=""math-container"">$i$</span>, the more likely it is to be measured. But is there any way to reverse this? The closer the value <span class=""math-container"">$| \psi_i |$</span> is to 0, the more probable the measurement of <span class=""math-container"">$i$</span> is?</p>
<p>In a rephrased way, is there a method to amplify probability amplitudes closer to 0? Such as Grover’s algorithm, which amplifies negative probability amplitudes. But instead for values closer to 0.</p>
",Measure or Amplify the least probable state,<quantum-state><measurement>,0,6,,,"Measure or Amplify the least probable state <p>Qubits can be represented by a state vector <span class=""math-container"">$\psi \in \mathbb{C}^{2^N}$</span>, where <span class=""math-container"">$N$</span> is the number of qubits.</p>
<p>The higher <span class=""math-container"">$| \psi_i |$</span> is, for any index <span class=""math-container"">$i$</span>, the more likely it is to be measured. But is there any way to reverse this? The closer the value <span class=""math-container"">$| \psi_i |$</span> is to 0, the more probable the measurement of <span class=""math-container"">$i$</span> is?</p>
<p>In a rephrased way, is there a method to amplify probability amplitudes closer to 0? Such as Grover’s algorithm, which amplifies negative probability amplitudes. But instead for values closer to 0.</p>
",qc,measure amplify least probable state p qubits represented state vector span c span n number p higher span index span likely measured way reverse closer value span 0 probable measurement span p rephrased way method amplify probability amplitudes closer 0 grover algorithm amplifies negative probability amplitudes instead values closer,"[(2, 0.046044927), (3, 0.24232222), (7, 0.052684974), (8, 0.1272691), (17, 0.07693793), (18, 0.4517735)]"
28617,28618.0,2022-10-20 17:47:53,1,36,"<p>I am trying to create a plot of groundstate energy against noise like mentioned in the title.</p>
<p>I do this in the aim of finding some sort of correlation between the two meaning I can find what the energy would be with no noise and see if this is close to the actual value.</p>
<p>So far I have used the groundstate energy for H2 and used different noisey backends for example: FakeMelbourne, FakeLondon etc.</p>
<p><a href=""https://i.sstatic.net/4ZcR4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4ZcR4.png"" alt=""enter image description here"" /></a></p>
<p>My question is, can I simulate noise a different way instead of using specific backends with noise already in them.</p>
<p>Thanks</p>
",Creating a plot of groundstate energy (for a set distance) against noise,<qiskit><hamiltonian-simulation><noise>,1,0,,,"Creating a plot of groundstate energy (for a set distance) against noise <p>I am trying to create a plot of groundstate energy against noise like mentioned in the title.</p>
<p>I do this in the aim of finding some sort of correlation between the two meaning I can find what the energy would be with no noise and see if this is close to the actual value.</p>
<p>So far I have used the groundstate energy for H2 and used different noisey backends for example: FakeMelbourne, FakeLondon etc.</p>
<p><a href=""https://i.sstatic.net/4ZcR4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4ZcR4.png"" alt=""enter image description here"" /></a></p>
<p>My question is, can I simulate noise a different way instead of using specific backends with noise already in them.</p>
<p>Thanks</p>
",qc,creating plot groundstate energy set distance noise p trying create plot groundstate energy noise like mentioned p aim finding sort correlation two meaning find energy would noise see close actual p far used groundstate energy h2 used different noisey backends example fakemelbourne fakelondon p https nofollow noreferrer img https enter image description p question simulate noise different way instead using specific backends noise already p thanks,"[(4, 0.28943858), (8, 0.10860422), (14, 0.4855636), (17, 0.11373517)]"
28625,,2022-10-21 12:26:32,1,56,"<p>I know this question looks ridiculous.</p>
<p>But I simply want to know if possible to store/load a superposition state into classical register from qubit. Specifically two bit of classical register.</p>
<p>Consider 1-qubit <span class=""math-container"">$q$</span> and 2-bit <span class=""math-container"">$c$</span>:</p>
<ul>
<li>If <span class=""math-container"">$q=|0\rangle$</span>, then <span class=""math-container"">$c=00$</span>.</li>
<li>If <span class=""math-container"">$q=|1\rangle$</span>, then <span class=""math-container"">$c=01$</span>.</li>
<li>If <span class=""math-container"">$q=|+\rangle$</span>, then <span class=""math-container"">$c=10$</span>.</li>
<li>If <span class=""math-container"">$q=|-\rangle$</span>, then <span class=""math-container"">$c=11$</span>.</li>
</ul>
<p>Basically left classical bit (MSB) will set to 1 if in superposition state, otherwise 0.</p>
<p>Right classical bit (LSB) was about binary state in qubit. But depends on context too, if in superposition state (MSB=1) then it represent previous value before became superposition state.</p>
<p>So is it possible to just using one qubit in this problem? I don't mind using many logic gates in single qubit.</p>
<p>What I mean with store and load is basically copy from/to classical register. Store with measurement, Load with using conditional <code>X</code> gate in classical bit, <a href=""https://quantumcomputing.stackexchange.com/questions/28560/how-to-copy-value-from-classical-register-to-quantum-register"">here</a> is what I mean.</p>
",Store/load superposition state of a qubit into/from classical register,<quantum-state><superposition>,1,0,,,"Store/load superposition state of a qubit into/from classical register <p>I know this question looks ridiculous.</p>
<p>But I simply want to know if possible to store/load a superposition state into classical register from qubit. Specifically two bit of classical register.</p>
<p>Consider 1-qubit <span class=""math-container"">$q$</span> and 2-bit <span class=""math-container"">$c$</span>:</p>
<ul>
<li>If <span class=""math-container"">$q=|0\rangle$</span>, then <span class=""math-container"">$c=00$</span>.</li>
<li>If <span class=""math-container"">$q=|1\rangle$</span>, then <span class=""math-container"">$c=01$</span>.</li>
<li>If <span class=""math-container"">$q=|+\rangle$</span>, then <span class=""math-container"">$c=10$</span>.</li>
<li>If <span class=""math-container"">$q=|-\rangle$</span>, then <span class=""math-container"">$c=11$</span>.</li>
</ul>
<p>Basically left classical bit (MSB) will set to 1 if in superposition state, otherwise 0.</p>
<p>Right classical bit (LSB) was about binary state in qubit. But depends on context too, if in superposition state (MSB=1) then it represent previous value before became superposition state.</p>
<p>So is it possible to just using one qubit in this problem? I don't mind using many logic gates in single qubit.</p>
<p>What I mean with store and load is basically copy from/to classical register. Store with measurement, Load with using conditional <code>X</code> gate in classical bit, <a href=""https://quantumcomputing.stackexchange.com/questions/28560/how-to-copy-value-from-classical-register-to-quantum-register"">here</a> is what I mean.</p>
",qc,superposition state qubit classical register p know question looks p simply want know possible superposition state classical register qubit specifically two bit classical p consider span q span c ul li span span li span span li span span li span span p basically left classical bit msb set 1 superposition state otherwise p right classical bit lsb binary state qubit depends context superposition state represent previous value became superposition p possible using one qubit problem mind using many logic gates single p mean store load basically copy classical register store measurement load using conditional code x gate classical bit https,"[(1, 0.064844966), (3, 0.10846638), (10, 0.024648555), (13, 0.05681077), (14, 0.09747416), (17, 0.015061472), (18, 0.6314082)]"
28640,28703.0,2022-10-22 20:00:40,2,1730,"<p>I'm trying to apply depolarization error on a 2-qubit circuit using the Qiskit Aer noise module. My question is how can I apply the depolarization error to each of the qubits in my circuit? Does the error also apply to 2-qubit gates?</p>
<p>From <a href=""https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html#All-qubit-quantum-error"" rel=""nofollow noreferrer"">this tutorial</a>, we can apply the 'same error to any occurrence of an instruction'. My understanding is if we apply the <code>All-qubit quantum error</code>, the same depolarization error will occur on each of the qubits:
<span class=""math-container"">$$
\mathcal{E}(\rho) = \frac{pI}{2^n}\text{Tr}(\rho)+(1-p)\rho,\quad\text{where}
\quad\rho \equiv\sum_ip_i|\psi_i\rangle\langle\psi_i|.
$$</span>
Thus the uniform X, Y, and Z errors are applied to each of them separately. The qiskit code is</p>
<pre><code># Create an empty noise model
noise_model = NoiseModel()

# Add depolarizing error to all single qubit u1, u2, u3 gates
error = depolarizing_error(0.05, 1)
noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])

# Print noise model info
print(noise_model)
</code></pre>
<p>However, as <a href=""https://algassert.com/post/2001"" rel=""nofollow noreferrer"">this post</a> suggests, a two-qubit depolarizing error would apply one of IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, or ZZ chosen uniformly at random. If we apply the code above on a 2-qubit circuit, are we really applying the error as we are expecting? Also, as specified in <code>noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])</code>, if there's a CNOT gate on my circuit, will the depolarization error affect this 2-qubit gate?</p>
<p>Thanks!</p>
",How do I apply depolarization error on 2 qubits using Qiskit?,<qiskit><simulation><depolarizing-channel>,1,0,,,"How do I apply depolarization error on 2 qubits using Qiskit? <p>I'm trying to apply depolarization error on a 2-qubit circuit using the Qiskit Aer noise module. My question is how can I apply the depolarization error to each of the qubits in my circuit? Does the error also apply to 2-qubit gates?</p>
<p>From <a href=""https://qiskit.org/documentation/tutorials/simulators/3_building_noise_models.html#All-qubit-quantum-error"" rel=""nofollow noreferrer"">this tutorial</a>, we can apply the 'same error to any occurrence of an instruction'. My understanding is if we apply the <code>All-qubit quantum error</code>, the same depolarization error will occur on each of the qubits:
<span class=""math-container"">$$
\mathcal{E}(\rho) = \frac{pI}{2^n}\text{Tr}(\rho)+(1-p)\rho,\quad\text{where}
\quad\rho \equiv\sum_ip_i|\psi_i\rangle\langle\psi_i|.
$$</span>
Thus the uniform X, Y, and Z errors are applied to each of them separately. The qiskit code is</p>
<pre><code># Create an empty noise model
noise_model = NoiseModel()

# Add depolarizing error to all single qubit u1, u2, u3 gates
error = depolarizing_error(0.05, 1)
noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])

# Print noise model info
print(noise_model)
</code></pre>
<p>However, as <a href=""https://algassert.com/post/2001"" rel=""nofollow noreferrer"">this post</a> suggests, a two-qubit depolarizing error would apply one of IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, or ZZ chosen uniformly at random. If we apply the code above on a 2-qubit circuit, are we really applying the error as we are expecting? Also, as specified in <code>noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])</code>, if there's a CNOT gate on my circuit, will the depolarization error affect this 2-qubit gate?</p>
<p>Thanks!</p>
",qc,apply depolarization error 2 qubits using qiskit p trying apply depolarization error circuit using qiskit aer noise module question apply depolarization error qubits circuit error also apply gates p https nofollow noreferrer tutorial apply error occurrence instruction understanding apply code quantum error depolarization error occur qubits span e pi tr thus uniform x z errors applied separately qiskit code pre code create empty noise model noisemodel add depolarizing error single qubit u1 u2 u3 gates error 1 error print noise model info print p however https nofollow noreferrer post suggests depolarizing error would apply one ix iy iz xi xx xy xz yi yx yy yz zi zx zy zz chosen uniformly random apply code circuit really applying error expecting also specified code error cnot gate circuit depolarization error affect gate p thanks,"[(0, 0.06698879), (3, 0.03089425), (4, 0.07134636), (5, 0.25225836), (10, 0.025955897), (11, 0.01853065), (14, 0.35155517), (15, 0.016286599), (17, 0.10887421), (18, 0.05654058)]"
28642,,2022-10-23 06:57:44,3,239,"<p>Let us see the one-qubit case of different noise channel, the depolarizing channel is
<span class=""math-container"">$\Lambda_1^{depol}(\rho_1)=(1-\frac{4}{3}\epsilon_1)\rho_1+\frac{1}{3}\epsilon_1\sum_{i=0}^{3}\sigma_i\rho_1\sigma_i$</span>, the dephasing noise is <span class=""math-container"">$\Lambda_1^{depha}(\rho_1)=(1-2\epsilon_1)\rho_1+\epsilon_1\sum_{i\in\{0,3\}}\sigma_i\rho_1\sigma_i$</span>, the bit flip channel is <span class=""math-container"">$\Lambda_1^{bit}(\rho_1)=(1-\epsilon_1)\rho_1+\epsilon_1\sigma_x\rho_1\sigma_x$</span>, and the Pauli channel is <span class=""math-container"">$\Lambda^{Pau}(\rho)=\sum_jp_jP_j\rho P_j$</span>, where <span class=""math-container"">$p_j$</span> is the Pauli error rate associated with the Pauli operator <span class=""math-container"">$P_j$</span>. There are also other quantum noise models.</p>
<p>Can I say the common of those quantum noises is that they all have a probability distribution which generated by the error rates, for example, for the depolarizing channel, the rates <span class=""math-container"">$\{1-\frac{4}{3}\epsilon_1, \frac{1}{3}\epsilon_1,\frac{1}{3}\epsilon_1,\frac{1}{3}\epsilon_1,\frac{1}{3}\epsilon_1\}$</span> form a probability distribution; and for Pauli channel, <span class=""math-container"">$p_j$</span> forms a probability distribution thus <span class=""math-container"">$\sum _jp_j=1$</span>. Am I right?</p>
",What do quantum noise models have in common?,<quantum-operation><noise><depolarizing-channel>,2,0,,,"What do quantum noise models have in common? <p>Let us see the one-qubit case of different noise channel, the depolarizing channel is
<span class=""math-container"">$\Lambda_1^{depol}(\rho_1)=(1-\frac{4}{3}\epsilon_1)\rho_1+\frac{1}{3}\epsilon_1\sum_{i=0}^{3}\sigma_i\rho_1\sigma_i$</span>, the dephasing noise is <span class=""math-container"">$\Lambda_1^{depha}(\rho_1)=(1-2\epsilon_1)\rho_1+\epsilon_1\sum_{i\in\{0,3\}}\sigma_i\rho_1\sigma_i$</span>, the bit flip channel is <span class=""math-container"">$\Lambda_1^{bit}(\rho_1)=(1-\epsilon_1)\rho_1+\epsilon_1\sigma_x\rho_1\sigma_x$</span>, and the Pauli channel is <span class=""math-container"">$\Lambda^{Pau}(\rho)=\sum_jp_jP_j\rho P_j$</span>, where <span class=""math-container"">$p_j$</span> is the Pauli error rate associated with the Pauli operator <span class=""math-container"">$P_j$</span>. There are also other quantum noise models.</p>
<p>Can I say the common of those quantum noises is that they all have a probability distribution which generated by the error rates, for example, for the depolarizing channel, the rates <span class=""math-container"">$\{1-\frac{4}{3}\epsilon_1, \frac{1}{3}\epsilon_1,\frac{1}{3}\epsilon_1,\frac{1}{3}\epsilon_1,\frac{1}{3}\epsilon_1\}$</span> form a probability distribution; and for Pauli channel, <span class=""math-container"">$p_j$</span> forms a probability distribution thus <span class=""math-container"">$\sum _jp_j=1$</span>. Am I right?</p>
",qc,quantum noise models common p let us see case different noise channel depolarizing channel span depol 4 3 1 3 3 dephasing noise span depha bit flip channel span bit pauli channel span pau span pauli error rate associated pauli operator span also quantum noise p say common quantum noises probability distribution generated error rates example depolarizing channel rates span 4 3 1 3 1 3 1 3 1 3 form probability distribution pauli channel span forms probability distribution thus span right,"[(1, 0.035008192), (2, 0.073285855), (3, 0.51693845), (5, 0.24569854), (6, 0.11144337), (17, 0.015857559)]"
28645,,2022-10-23 16:45:21,0,500,"<p>I'm trying to understand how the noise model works in Qiskit Aer noise simulator. From <a href=""https://qiskit.org/documentation/locale/de_DE/stubs/qiskit_aer.noise.NoiseModel.add_all_qubit_quantum_error.html"" rel=""nofollow noreferrer"">this information page</a>, <code>add_all_qubit_quantum_error()</code> has two required arguments: <code>param</code>, which specifies the noise strength, and <code>instructions</code>, which is ' the instructions error applies to'.</p>
<p>For 1-qubit noise, I noticed the general way to produce a noise model (say the depolarization channel) is</p>
<pre><code>error_1 = depolarizing_error(0.1, 1)
depolarizing_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
</code></pre>
<p>What is the appropriate instruction for 2-qubit circuits? Should I use the following code?</p>
<pre><code>error_2 = depolarizing_error(0.1, 2)
depolarizing_model.add_all_qubit_quantum_error(error_2, ['cx'])
</code></pre>
<p>I also noticed if I add any random instructions to the list, like</p>
<pre><code>depolarizing_model.add_all_qubit_quantum_error(error_2, ['cx','ww','yz1'])
</code></pre>
<p>It seems like the noise simulation still works. <strong>What is the appropriate way to build a noise model for a 2-qubit circuit? Which kind of instructions should I use?</strong></p>
<p>Thanks!!</p>
",What is an instruction when we `add_all_qubit_quantum_error`?,<qiskit><noise><depolarizing-channel>,2,0,,,"What is an instruction when we `add_all_qubit_quantum_error`? <p>I'm trying to understand how the noise model works in Qiskit Aer noise simulator. From <a href=""https://qiskit.org/documentation/locale/de_DE/stubs/qiskit_aer.noise.NoiseModel.add_all_qubit_quantum_error.html"" rel=""nofollow noreferrer"">this information page</a>, <code>add_all_qubit_quantum_error()</code> has two required arguments: <code>param</code>, which specifies the noise strength, and <code>instructions</code>, which is ' the instructions error applies to'.</p>
<p>For 1-qubit noise, I noticed the general way to produce a noise model (say the depolarization channel) is</p>
<pre><code>error_1 = depolarizing_error(0.1, 1)
depolarizing_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
</code></pre>
<p>What is the appropriate instruction for 2-qubit circuits? Should I use the following code?</p>
<pre><code>error_2 = depolarizing_error(0.1, 2)
depolarizing_model.add_all_qubit_quantum_error(error_2, ['cx'])
</code></pre>
<p>I also noticed if I add any random instructions to the list, like</p>
<pre><code>depolarizing_model.add_all_qubit_quantum_error(error_2, ['cx','ww','yz1'])
</code></pre>
<p>It seems like the noise simulation still works. <strong>What is the appropriate way to build a noise model for a 2-qubit circuit? Which kind of instructions should I use?</strong></p>
<p>Thanks!!</p>
",qc,instruction p trying understand noise model works qiskit aer noise simulator https nofollow noreferrer information page code two required arguments code param specifies noise strength code instructions instructions error applies p noise noticed general way produce noise model say depolarization channel pre code 1 p appropriate instruction circuits use following code pre code 2 p also noticed add random instructions list like pre code p seems like noise simulation still works strong appropriate way build noise model circuit kind instructions use p thanks,"[(0, 0.055641554), (2, 0.019334422), (4, 0.075534336), (5, 0.0431534), (14, 0.78257173), (17, 0.022080872)]"
28648,28654.0,2022-10-23 21:43:42,0,241,"<p>I'm trying to simulate 3 qubit (distance 3) bit-flip code in stim.
I wrote code similar to <a href=""https://quantumcomputing.stackexchange.com/questions/21485/how-to-import-a-generic-stabilizer-code-in-stim"">How to import a generic stabilizer code in stim</a> using MPP operation. I found the following way yields logical error rate below physical error rate</p>
<pre><code>MPP Z0*Z1 #stabilizer measurement in the last round
MPP Z1*Z2 #stabilizer measurement in the last round

M 0 1 2 #measure logical Z
DETECTOR rec[-2] rec[-3] rec[-5]
DETECTOR rec[-1] rec[-2] rec[-4]
OBSERVABLE_INCLUDE(0) rec[-1]
</code></pre>
<p>However is it possible to use MPP in the end? If so, how? I'm asking this because I'm confused when trying to write a similar readout for 7-qubit code where the relation is more complex.</p>
",How to use MPP to measure the logical Z in stim,<error-correction><simulation><stabilizer-code><stim>,1,0,,,"How to use MPP to measure the logical Z in stim <p>I'm trying to simulate 3 qubit (distance 3) bit-flip code in stim.
I wrote code similar to <a href=""https://quantumcomputing.stackexchange.com/questions/21485/how-to-import-a-generic-stabilizer-code-in-stim"">How to import a generic stabilizer code in stim</a> using MPP operation. I found the following way yields logical error rate below physical error rate</p>
<pre><code>MPP Z0*Z1 #stabilizer measurement in the last round
MPP Z1*Z2 #stabilizer measurement in the last round

M 0 1 2 #measure logical Z
DETECTOR rec[-2] rec[-3] rec[-5]
DETECTOR rec[-1] rec[-2] rec[-4]
OBSERVABLE_INCLUDE(0) rec[-1]
</code></pre>
<p>However is it possible to use MPP in the end? If so, how? I'm asking this because I'm confused when trying to write a similar readout for 7-qubit code where the relation is more complex.</p>
",qc,use mpp measure logical z stim p trying simulate 3 qubit distance 3 code stim wrote code similar https import generic stabilizer code stim using mpp operation found following way yields logical error rate physical error rate pre code mpp z0 z1 stabilizer measurement last round mpp z1 z2 stabilizer measurement last round 0 1 2 measure logical z detector rec rec rec detector rec rec rec 0 rec p however possible use mpp end asking confused trying write similar readout code relation,"[(0, 0.036885098), (5, 0.40964833), (6, 0.21329042), (7, 0.022179503), (12, 0.07410584), (14, 0.19741754), (17, 0.044910062)]"
28672,28676.0,2022-10-25 11:55:21,1,161,"<p>I have a stim circuit and when I call shortest graphlike error I find that it has distance 3:</p>
<p><code>assert len(shortsurfacecode.circ.shortest_graphlike_error()) == 3</code></p>
<p><strong>When I draw the match-graph-3d it consists of a single node and I don't understand why:</strong></p>
<p><code>shortsurfacecode.circ.detector_error_model().diagram(type=&quot;match-graph-3d&quot;)</code></p>
<p><a href=""https://i.sstatic.net/l6BzY.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/l6BzY.png"" alt=""enter image description here"" /></a></p>
<p>Here is the stim circuit:</p>
<pre><code>QUBIT_COORDS(0, 2) 0
QUBIT_COORDS(1, 1) 1
QUBIT_COORDS(2, 0) 2
QUBIT_COORDS(1, 3) 3
QUBIT_COORDS(2, 2) 4
QUBIT_COORDS(3, 1) 5
QUBIT_COORDS(2, 4) 6
QUBIT_COORDS(3, 3) 7
QUBIT_COORDS(4, 2) 8
R 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 3) 9
R 9
QUBIT_COORDS(1, 2) 10
R 10
QUBIT_COORDS(0, 1) 11
R 11
QUBIT_COORDS(3, 0) 12
R 12
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8 9 10 11 12
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 9 11
M 9 11
X_ERROR(0.01) 10 12
M 10 12
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 1) 13
R 13
QUBIT_COORDS(3, 2) 14
R 14
QUBIT_COORDS(4, 3) 15
R 15
QUBIT_COORDS(1, 4) 16
R 16
X_ERROR(0.01) 13 14 15 16
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
CX 13 5 8 14 6 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 5 8 14 6 16
DEPOLARIZE1(0.01) 0 1 2 3 4 7 15
CX 13 4 5 14 3 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 4 5 14 3 16
DEPOLARIZE1(0.01) 0 1 2 6 7 8 15
CX 13 2 7 14 15 8
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 2 7 14 15 8
DEPOLARIZE1(0.01) 0 1 3 4 5 6 16
CX 13 1 4 14 15 7
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 1 4 14 15 7
DEPOLARIZE1(0.01) 0 2 3 5 6 8 16
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
X_ERROR(0.01) 13 15
M 13 15
X_ERROR(0.01) 14 16
M 14 16
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
R 9 10 11 12
X_ERROR(0.01) 9 10 11 12
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 11
M 11
DETECTOR rec[-1] rec[-8]
X_ERROR(0.01) 12
M 12
DETECTOR rec[-1] rec[-7]
X_ERROR(0.01) 10
M 10
DETECTOR rec[-1] rec[-9]
X_ERROR(0.01) 9
M 9
DETECTOR rec[-1] rec[-12]
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8
M 0 1 2 3 4 5 6 7 8
DETECTOR rec[-11] rec[-9] rec[-6] rec[-8] rec[-5]
DETECTOR rec[-15] rec[-5] rec[-2] rec[-4] rec[-1]
DETECTOR rec[-12] rec[-7] rec[-4]
DETECTOR rec[-14] rec[-3] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-9] rec[-8] rec[-7]
</code></pre>
<p>And it's detector error model</p>
<pre><code>error(0.03185674550515311954) D0 D3
error(0.04975735925829932738) D0 D5
error(0.03809865556508435641) D0 L0
error(0.03059997378373536733) D1 D2
error(0.001338700097173320998) D1 D2 D4
error(0.01911873511075361937) D1 D3
error(0.004005357180252827609) D1 D4 D6
error(0.01126977837777042371) D1 D4 L0
error(0.03874469856294735642) D1 D6
error(0.04914933380809191621) D1 L0
error(0.04425734015754984041) D2
error(0.002673815958446297981) D2 D3
error(0.002673815958446297981) D2 D3 D7
error(0.001338700097173320998) D2 D4 D6
error(0.02293841413224595796) D2 D6
error(0.02165770036624231967) D2 D6 D7
error(0.02230280153587052214) D2 D7
error(0.002673815958446297981) D2 D7 D11
error(0.04733668245378268302) D2 D11
error(0.1110374976726973273) D3
error(0.04360252789818236385) D3 D5
error(0.001338700097173320998) D3 D5 D7
error(0.03557524547345392724) D3 D6
error(0.02676856776605827937) D3 D6 D7
error(0.03432845639209641808) D3 D7
error(0.002673815958446297981) D3 D7 D9
error(0.03997966359665833247) D3 D9
error(0.1662642703886834938) D4
error(0.08897217728373547907) D4 D6 L0
error(0.004005357180252827609) D5 D6
error(0.001338700097173320998) D5 D6 D7
error(0.05570001667892007791) D5 D9
error(0.04975735925829932738) D5 D10
error(0.09227216989561401461) D5 L0
error(0.004005357180252827609) D6 D7 D8
error(0.01584743398905801709) D6 D7 D9
error(0.02867209751539220169) D6 D7 D11
error(0.001338700097173320998) D6 D7 L0
error(0.03874469856294735642) D6 D8
error(0.01584743398905801709) D6 D9
error(0.02867209751539220169) D6 D11
error(0.09985261856122865098) D6 L0
error(0.2093485274052065692) D7
error(0.006000449842759884161) D7 D8 D9
error(0.005333333333333313206) D7 D8 D11
error(0.001338700097173320998) D7 D8 L0
error(0.02101172802650804611) D7 D9
error(0.002673815958446297981) D7 D9 D11
error(0.02867209751539220169) D7 D11
error(0.02870423005727528593) D8 D9
error(0.02169031111111104776) D8 D11
error(0.04854864330815450435) D8 L0
error(0.1298754953638350251) D9
error(0.02553048530927685272) D9 D10
error(0.002673815958446297981) D9 D11
error(0.01911873511075363324) D10 L0
error(0.05632945683604310971) D11
</code></pre>
",stim match graph of circuit with distance 3 only has one node,<error-correction><stim>,1,0,,,"stim match graph of circuit with distance 3 only has one node <p>I have a stim circuit and when I call shortest graphlike error I find that it has distance 3:</p>
<p><code>assert len(shortsurfacecode.circ.shortest_graphlike_error()) == 3</code></p>
<p><strong>When I draw the match-graph-3d it consists of a single node and I don't understand why:</strong></p>
<p><code>shortsurfacecode.circ.detector_error_model().diagram(type=&quot;match-graph-3d&quot;)</code></p>
<p><a href=""https://i.sstatic.net/l6BzY.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/l6BzY.png"" alt=""enter image description here"" /></a></p>
<p>Here is the stim circuit:</p>
<pre><code>QUBIT_COORDS(0, 2) 0
QUBIT_COORDS(1, 1) 1
QUBIT_COORDS(2, 0) 2
QUBIT_COORDS(1, 3) 3
QUBIT_COORDS(2, 2) 4
QUBIT_COORDS(3, 1) 5
QUBIT_COORDS(2, 4) 6
QUBIT_COORDS(3, 3) 7
QUBIT_COORDS(4, 2) 8
R 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 3) 9
R 9
QUBIT_COORDS(1, 2) 10
R 10
QUBIT_COORDS(0, 1) 11
R 11
QUBIT_COORDS(3, 0) 12
R 12
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8 9 10 11 12
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 9 11
M 9 11
X_ERROR(0.01) 10 12
M 10 12
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
QUBIT_COORDS(2, 1) 13
R 13
QUBIT_COORDS(3, 2) 14
R 14
QUBIT_COORDS(4, 3) 15
R 15
QUBIT_COORDS(1, 4) 16
R 16
X_ERROR(0.01) 13 14 15 16
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
CX 13 5 8 14 6 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 5 8 14 6 16
DEPOLARIZE1(0.01) 0 1 2 3 4 7 15
CX 13 4 5 14 3 16
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 4 5 14 3 16
DEPOLARIZE1(0.01) 0 1 2 6 7 8 15
CX 13 2 7 14 15 8
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 2 7 14 15 8
DEPOLARIZE1(0.01) 0 1 3 4 5 6 16
CX 13 1 4 14 15 7
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 13 1 4 14 15 7
DEPOLARIZE1(0.01) 0 2 3 5 6 8 16
H 13 15
TICK
DEPOLARIZE1(0.01) 13 15 0 1 2 3 4 5 6 7 8 14 16
X_ERROR(0.01) 13 15
M 13 15
X_ERROR(0.01) 14 16
M 14 16
DETECTOR rec[-1]
DETECTOR rec[-2]
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
R 9 10 11 12
X_ERROR(0.01) 9 10 11 12
DEPOLARIZE1(0.01) 0 1 2 3 4 5 6 7 8
TICK
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
CX 9 7 11 1 4 10
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 7 11 1 4 10
DEPOLARIZE1(0.01) 0 2 3 5 6 8 12
CX 9 6 1 10 11 0
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 6 1 10 11 0
DEPOLARIZE1(0.01) 2 3 4 5 7 8 12
CX 9 4 3 10 5 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 4 3 10 5 12
DEPOLARIZE1(0.01) 0 1 2 6 7 8 11
CX 9 3 0 10 2 12
TICK
DEPOLARIZE1(0.01)
DEPOLARIZE2(0.01) 9 3 0 10 2 12
DEPOLARIZE1(0.01) 1 4 5 6 7 8 11
H 9 11
TICK
DEPOLARIZE1(0.01) 9 11 0 1 2 3 4 5 6 7 8 10 12
X_ERROR(0.01) 11
M 11
DETECTOR rec[-1] rec[-8]
X_ERROR(0.01) 12
M 12
DETECTOR rec[-1] rec[-7]
X_ERROR(0.01) 10
M 10
DETECTOR rec[-1] rec[-9]
X_ERROR(0.01) 9
M 9
DETECTOR rec[-1] rec[-12]
X_ERROR(0.01) 0 1 2 3 4 5 6 7 8
M 0 1 2 3 4 5 6 7 8
DETECTOR rec[-11] rec[-9] rec[-6] rec[-8] rec[-5]
DETECTOR rec[-15] rec[-5] rec[-2] rec[-4] rec[-1]
DETECTOR rec[-12] rec[-7] rec[-4]
DETECTOR rec[-14] rec[-3] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-9] rec[-8] rec[-7]
</code></pre>
<p>And it's detector error model</p>
<pre><code>error(0.03185674550515311954) D0 D3
error(0.04975735925829932738) D0 D5
error(0.03809865556508435641) D0 L0
error(0.03059997378373536733) D1 D2
error(0.001338700097173320998) D1 D2 D4
error(0.01911873511075361937) D1 D3
error(0.004005357180252827609) D1 D4 D6
error(0.01126977837777042371) D1 D4 L0
error(0.03874469856294735642) D1 D6
error(0.04914933380809191621) D1 L0
error(0.04425734015754984041) D2
error(0.002673815958446297981) D2 D3
error(0.002673815958446297981) D2 D3 D7
error(0.001338700097173320998) D2 D4 D6
error(0.02293841413224595796) D2 D6
error(0.02165770036624231967) D2 D6 D7
error(0.02230280153587052214) D2 D7
error(0.002673815958446297981) D2 D7 D11
error(0.04733668245378268302) D2 D11
error(0.1110374976726973273) D3
error(0.04360252789818236385) D3 D5
error(0.001338700097173320998) D3 D5 D7
error(0.03557524547345392724) D3 D6
error(0.02676856776605827937) D3 D6 D7
error(0.03432845639209641808) D3 D7
error(0.002673815958446297981) D3 D7 D9
error(0.03997966359665833247) D3 D9
error(0.1662642703886834938) D4
error(0.08897217728373547907) D4 D6 L0
error(0.004005357180252827609) D5 D6
error(0.001338700097173320998) D5 D6 D7
error(0.05570001667892007791) D5 D9
error(0.04975735925829932738) D5 D10
error(0.09227216989561401461) D5 L0
error(0.004005357180252827609) D6 D7 D8
error(0.01584743398905801709) D6 D7 D9
error(0.02867209751539220169) D6 D7 D11
error(0.001338700097173320998) D6 D7 L0
error(0.03874469856294735642) D6 D8
error(0.01584743398905801709) D6 D9
error(0.02867209751539220169) D6 D11
error(0.09985261856122865098) D6 L0
error(0.2093485274052065692) D7
error(0.006000449842759884161) D7 D8 D9
error(0.005333333333333313206) D7 D8 D11
error(0.001338700097173320998) D7 D8 L0
error(0.02101172802650804611) D7 D9
error(0.002673815958446297981) D7 D9 D11
error(0.02867209751539220169) D7 D11
error(0.02870423005727528593) D8 D9
error(0.02169031111111104776) D8 D11
error(0.04854864330815450435) D8 L0
error(0.1298754953638350251) D9
error(0.02553048530927685272) D9 D10
error(0.002673815958446297981) D9 D11
error(0.01911873511075363324) D10 L0
error(0.05632945683604310971) D11
</code></pre>
",qc,stim match graph circuit distance 3 one node p stim circuit call shortest graphlike error find distance 3 p code assert len 3 p strong draw consists single node understand p code quot quot p https nofollow noreferrer img https enter image description p stim circuit pre code 0 2 0 1 1 1 2 0 2 1 3 3 2 2 4 3 1 5 2 4 6 3 3 7 4 2 8 r 0 1 2 3 4 5 6 7 8 2 3 9 r 9 1 2 10 r 10 0 1 11 r 11 3 0 12 r 12 0 1 2 3 4 5 6 7 8 9 10 11 12 h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 cx 9 7 11 1 4 10 tick depolarize1 depolarize2 9 7 11 1 4 10 depolarize1 0 2 3 5 6 8 12 cx 9 6 1 10 11 0 tick depolarize1 depolarize2 9 6 1 10 11 0 depolarize1 2 3 4 5 7 8 12 cx 9 4 3 10 5 12 tick depolarize1 depolarize2 9 4 3 10 5 12 depolarize1 0 1 2 6 7 8 11 cx 9 3 0 10 2 12 tick depolarize1 depolarize2 9 3 0 10 2 12 depolarize1 1 4 5 6 7 8 11 h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 9 11 9 11 10 12 10 12 detector rec detector rec depolarize1 0 1 2 3 4 5 6 7 8 2 1 13 r 13 3 2 14 r 14 4 3 15 r 15 1 4 16 r 16 13 14 15 16 depolarize1 0 1 2 3 4 5 6 7 8 h 13 15 tick depolarize1 13 15 0 1 2 3 4 5 6 7 8 14 16 cx 13 5 8 14 6 16 tick depolarize1 depolarize2 13 5 8 14 6 16 depolarize1 0 1 2 3 4 7 15 cx 13 4 5 14 3 16 tick depolarize1 depolarize2 13 4 5 14 3 16 depolarize1 0 1 2 6 7 8 15 cx 13 2 7 14 15 8 tick depolarize1 depolarize2 13 2 7 14 15 8 depolarize1 0 1 3 4 5 6 16 cx 13 1 4 14 15 7 tick depolarize1 depolarize2 13 1 4 14 15 7 depolarize1 0 2 3 5 6 8 16 h 13 15 tick depolarize1 13 15 0 1 2 3 4 5 6 7 8 14 16 13 15 13 15 14 16 14 16 detector rec detector rec depolarize1 0 1 2 3 4 5 6 7 8 tick r 9 10 11 12 9 10 11 12 depolarize1 0 1 2 3 4 5 6 7 8 tick h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 cx 9 7 11 1 4 10 tick depolarize1 depolarize2 9 7 11 1 4 10 depolarize1 0 2 3 5 6 8 12 cx 9 6 1 10 11 0 tick depolarize1 depolarize2 9 6 1 10 11 0 depolarize1 2 3 4 5 7 8 12 cx 9 4 3 10 5 12 tick depolarize1 depolarize2 9 4 3 10 5 12 depolarize1 0 1 2 6 7 8 11 cx 9 3 0 10 2 12 tick depolarize1 depolarize2 9 3 0 10 2 12 depolarize1 1 4 5 6 7 8 11 h 9 11 tick depolarize1 9 11 0 1 2 3 4 5 6 7 8 10 12 11 11 detector rec rec 12 12 detector rec rec 10 10 detector rec rec 9 9 detector rec rec 0 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 detector rec rec rec rec rec detector rec rec rec rec rec detector rec rec rec detector rec rec rec 0 rec rec rec p detector error model pre code error d0 d3 error d0 d5 error d0 l0 error d1 d2 error d1 d2 d4 error d1 d3 error d1 d4 d6 error d1 d4 l0 error d1 d6 error d1 l0 error d2 error d2 d3 error d2 d3 d7 error d2 d4 d6 error d2 d6 error d2 d6 d7 error d2 d7 error d2 d7 d11 error d2 d11 error d3 error d3 d5 error d3 d5 d7 error d3 d6 error d3 d6 d7 error d3 d7 error d3 d7 d9 error d3 d9 error d4 error d4 d6 l0 error d5 d6 error d5 d6 d7 error d5 d9 error d5 d10 error d5 l0 error d6 d7 d8 error d6 d7 d9 error d6 d7 d11 error d6 d7 l0 error d6 d8 error d6 d9 error d6 d11 error d6 l0 error d7 error d7 d8 d9 error d7 d8 d11 error d7 d8 l0 error d7 d9 error d7 d9 d11 error d7 d11 error d8 d9 error d8 d11 error d8 l0 error d9 error d9 d10 error d9 d11 error d10 l0 error d11,"[(4, 0.013661991), (6, 0.9187669), (12, 0.015522798), (14, 0.026377957), (17, 0.012391423)]"
28681,28697.0,2022-10-25 23:55:23,1,141,"<p>Here is the toric code example which I found from :<a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">https://pymatching.readthedocs.io/en/latest/toric-code-example.html</a></p>
<pre><code>def repetition_code(n):

  row_ind, col_ind = zip(*((i, j) for i in range(n) for j in (i, (i+1)%n)))
  data = np.ones(2*n, dtype=np.uint8)
  return csr_matrix((data, (row_ind, col_ind)))


def toric_code_x_stabilisers(L):
    &quot;&quot;&quot;
    Sparse check matrix for the X stabilisers of a toric code with
    lattice size L, constructed as the hypergraph product of
    two repetition codes.
    &quot;&quot;&quot;
    Hr = repetition_code(L)
    H = hstack(
            [kron(Hr, eye(Hr.shape[1])), kron(eye(Hr.shape[0]), Hr.T)],
            dtype=np.uint8
        )
    H.data = H.data % 2
    H.eliminate_zeros()
    return csr_matrix(H)
    
</code></pre>
<p>My problem is I want to switch this code to the surface code but I do not know how.
<strong>I do not want to use STIM</strong>. In surface code, we have x and z stabilizers. I will add also a Z stabilizer function. This is fine but I do not know what will be different in this code to make it a surface code. It seemed to me X stabilizers can stay same. Probably I should change something(which can be boundaries) in the repetition code function, but I do not know how.</p>
<p>Can someone explain to me what I should change and how?
Thanks</p>
",How to Switch Toric Code to Surface Code (no using STIM!),<programming><surface-code><toric-code>,2,2,,,"How to Switch Toric Code to Surface Code (no using STIM!) <p>Here is the toric code example which I found from :<a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">https://pymatching.readthedocs.io/en/latest/toric-code-example.html</a></p>
<pre><code>def repetition_code(n):

  row_ind, col_ind = zip(*((i, j) for i in range(n) for j in (i, (i+1)%n)))
  data = np.ones(2*n, dtype=np.uint8)
  return csr_matrix((data, (row_ind, col_ind)))


def toric_code_x_stabilisers(L):
    &quot;&quot;&quot;
    Sparse check matrix for the X stabilisers of a toric code with
    lattice size L, constructed as the hypergraph product of
    two repetition codes.
    &quot;&quot;&quot;
    Hr = repetition_code(L)
    H = hstack(
            [kron(Hr, eye(Hr.shape[1])), kron(eye(Hr.shape[0]), Hr.T)],
            dtype=np.uint8
        )
    H.data = H.data % 2
    H.eliminate_zeros()
    return csr_matrix(H)
    
</code></pre>
<p>My problem is I want to switch this code to the surface code but I do not know how.
<strong>I do not want to use STIM</strong>. In surface code, we have x and z stabilizers. I will add also a Z stabilizer function. This is fine but I do not know what will be different in this code to make it a surface code. It seemed to me X stabilizers can stay same. Probably I should change something(which can be boundaries) in the repetition code function, but I do not know how.</p>
<p>Can someone explain to me what I should change and how?
Thanks</p>
",qc,switch toric code surface code using stim p toric code example found https nofollow noreferrer https pre code def n zip j range n j n data 2 n return data def l quot quot quot sparse check matrix x stabilisers toric code lattice size l constructed hypergraph product two repetition codes quot quot quot hr l h hstack kron hr eye 1 kron eye 0 2 return h p problem want switch code surface code know strong want use stim surface code x z stabilizers add also z stabilizer function fine know different code make surface code seemed x stabilizers stay probably change something boundaries repetition code function know p someone explain change thanks,"[(0, 0.19753894), (2, 0.03567065), (4, 0.038186777), (5, 0.2700918), (7, 0.11387201), (10, 0.04975409), (13, 0.10599065), (17, 0.06970709), (19, 0.10890185)]"
28692,28694.0,2022-10-26 18:20:26,1,48,"<p>I created the following code to run a simple circuit through a quantum device twice.  My purpose was to show the effects of noise with different arrangements of qubits when using ibmq_belem.</p>
<pre><code>#Run circuit with two different qubit layouts
from qiskit import IBMQ, execute
#Load account
provider=IBMQ.load_account()
#Choose device
backend=provider.get_backend('ibmq_belem')
C=[]
for initial_layout in [[0,3],[2,4]]:
    job=execute(circuit, backend, initial_layout=initial_layout).result()
    c=result.get_counts()
    C.append(c)
</code></pre>
<p>followed by
<code>plot_histogram([C[0],C[1]],title=&quot;Comparing Noise&quot;)</code>
to create the histogram which give me ...
<a href=""https://i.sstatic.net/eigrz.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eigrz.png"" alt=""enter image description here"" /></a></p>
<p>Which does not reflect any of the noise that I see in my results taken directly from IBMQ which shows the first and second runthroughs respectivly as ...
<a href=""https://i.sstatic.net/QxRZY.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QxRZY.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/9IZLd.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9IZLd.png"" alt=""enter image description here"" /></a></p>
<p>These are clearly not the identically perfect versions that my C set seems to have created.  This makes my question; What have I done wrong in coding this that C is not accurately reflecting my counts?</p>
<p><strong>Edit:</strong> I note that it has somehow decided to take the counts from when I ran this circuit on a simulator in a prior cell using the following code.</p>
<pre><code>simulator=Aer.get_backend('aer_simulator')
result=execute(circuit,backend=simulator).result()
plot_histogram(result.get_counts(circuit)) 
</code></pre>
<p>This code had been run before I ever created the set C, so I did not expect it to interfere, but now I'm not sure how to work around this.</p>
",Histogram does not reflect quantum device results,<programming><ibm-q-experience>,1,2,,,"Histogram does not reflect quantum device results <p>I created the following code to run a simple circuit through a quantum device twice.  My purpose was to show the effects of noise with different arrangements of qubits when using ibmq_belem.</p>
<pre><code>#Run circuit with two different qubit layouts
from qiskit import IBMQ, execute
#Load account
provider=IBMQ.load_account()
#Choose device
backend=provider.get_backend('ibmq_belem')
C=[]
for initial_layout in [[0,3],[2,4]]:
    job=execute(circuit, backend, initial_layout=initial_layout).result()
    c=result.get_counts()
    C.append(c)
</code></pre>
<p>followed by
<code>plot_histogram([C[0],C[1]],title=&quot;Comparing Noise&quot;)</code>
to create the histogram which give me ...
<a href=""https://i.sstatic.net/eigrz.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eigrz.png"" alt=""enter image description here"" /></a></p>
<p>Which does not reflect any of the noise that I see in my results taken directly from IBMQ which shows the first and second runthroughs respectivly as ...
<a href=""https://i.sstatic.net/QxRZY.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QxRZY.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/9IZLd.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9IZLd.png"" alt=""enter image description here"" /></a></p>
<p>These are clearly not the identically perfect versions that my C set seems to have created.  This makes my question; What have I done wrong in coding this that C is not accurately reflecting my counts?</p>
<p><strong>Edit:</strong> I note that it has somehow decided to take the counts from when I ran this circuit on a simulator in a prior cell using the following code.</p>
<pre><code>simulator=Aer.get_backend('aer_simulator')
result=execute(circuit,backend=simulator).result()
plot_histogram(result.get_counts(circuit)) 
</code></pre>
<p>This code had been run before I ever created the set C, so I did not expect it to interfere, but now I'm not sure how to work around this.</p>
",qc,histogram reflect quantum device results p created following code run simple circuit quantum device twice purpose show effects noise different arrangements qubits using pre code run circuit two different qubit layouts qiskit import ibmq execute load account choose device circuit backend c p followed code c 0 c 1 quot comparing noise quot create histogram give https nofollow noreferrer img https enter image description p reflect noise see results taken directly ibmq shows first second runthroughs respectivly https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p clearly identically perfect versions c set seems created makes question done wrong coding c accurately reflecting counts p strong edit note somehow decided take counts ran circuit simulator prior cell using following pre code circuit circuit p code run ever created set c expect interfere sure work around,"[(0, 0.05912435), (2, 0.011546757), (4, 0.32990634), (9, 0.0746607), (13, 0.011754467), (14, 0.4361229), (17, 0.04224041), (19, 0.0337813)]"
28713,28716.0,2022-10-28 14:57:24,2,112,"<p>I have having trouble getting the <code>decode(...)</code> function for a <code>pymatching.Matching</code> object to return an array of an appropriate size. Instead of returning an array with the number of qubits in a code, the function returns an array containing a single 0 or 1. The decode function seems to work with the <code>pymatching</code> tutorial notebooks, but I am unable to get the result on my own. The interesting thing is that when using the new <code>decode_to_matched_dets_array(...)</code> function, I get the matched pairs. Below is an example of what I'm talking about using a stim generated circuit:</p>
<pre><code># Inputs
distance = 9
reps = 9
shots = 1
noise = 1e-2*np.ones(4)

# Define circuit and matching graph
circuit = stim.Circuit.generated(
    'repetition_code:memory',
    rounds=reps,
    distance=distance,
    after_clifford_depolarization=noise[0],
    after_reset_flip_probability=noise[1],
    before_measure_flip_probability=noise[2],
    before_round_data_depolarization=noise[3]
)
error_model = circuit.detector_error_model(decompose_errors=True)
match = pm.Matching.from_detector_error_model(error_model)

# Sample results
sampler = circuit.compile_detector_sampler()
syndromes, observables = sampler.sample(shots, separate_observables=True)

# Decode Results
int_syndromes = [int(det) for det in syndromes[0]]
pairs = match.decode_to_matched_dets_array(int_syndromes)
corrections = match.decode(int_syndromes)

print('corrections:\n',corrections)
print('pairs:\n',pairs)
</code></pre>
<p>Would output something like</p>
<pre><code>corrections:
 [0]
pairs:
 [[18 20]
 [57 65]
 [58 59]
 [62 63]]
</code></pre>
<p>when I would expect <code>corrections</code> to show an array containing 0s and 1s of length 9.</p>
",PyMatching.Matching.decode() returns incorrectly sized array,<error-correction><stim><pymatching>,1,0,,,"PyMatching.Matching.decode() returns incorrectly sized array <p>I have having trouble getting the <code>decode(...)</code> function for a <code>pymatching.Matching</code> object to return an array of an appropriate size. Instead of returning an array with the number of qubits in a code, the function returns an array containing a single 0 or 1. The decode function seems to work with the <code>pymatching</code> tutorial notebooks, but I am unable to get the result on my own. The interesting thing is that when using the new <code>decode_to_matched_dets_array(...)</code> function, I get the matched pairs. Below is an example of what I'm talking about using a stim generated circuit:</p>
<pre><code># Inputs
distance = 9
reps = 9
shots = 1
noise = 1e-2*np.ones(4)

# Define circuit and matching graph
circuit = stim.Circuit.generated(
    'repetition_code:memory',
    rounds=reps,
    distance=distance,
    after_clifford_depolarization=noise[0],
    after_reset_flip_probability=noise[1],
    before_measure_flip_probability=noise[2],
    before_round_data_depolarization=noise[3]
)
error_model = circuit.detector_error_model(decompose_errors=True)
match = pm.Matching.from_detector_error_model(error_model)

# Sample results
sampler = circuit.compile_detector_sampler()
syndromes, observables = sampler.sample(shots, separate_observables=True)

# Decode Results
int_syndromes = [int(det) for det in syndromes[0]]
pairs = match.decode_to_matched_dets_array(int_syndromes)
corrections = match.decode(int_syndromes)

print('corrections:\n',corrections)
print('pairs:\n',pairs)
</code></pre>
<p>Would output something like</p>
<pre><code>corrections:
 [0]
pairs:
 [[18 20]
 [57 65]
 [58 59]
 [62 63]]
</code></pre>
<p>when I would expect <code>corrections</code> to show an array containing 0s and 1s of length 9.</p>
",qc,returns incorrectly sized array p trouble getting code decode function code object return array appropriate size instead returning array number qubits code function returns array containing single 0 decode function seems work code pymatching tutorial notebooks unable get result interesting thing using new code function get matched pairs example talking using stim generated circuit pre code inputs distance 9 reps 9 shots 1 noise 4 define circuit matching graph circuit memory 0 1 2 3 match sample results sampler syndromes observables shots decode results int det det syndromes 0 pairs corrections print corrections print pairs p would output something like pre code corrections 0 pairs 18 20 57 65 58 59 62 63 p would expect code corrections show array containing 0s 1s length,"[(0, 0.20729472), (2, 0.07201003), (5, 0.07480702), (6, 0.04656063), (8, 0.023539351), (14, 0.5389377), (17, 0.019145172)]"
28747,,2022-10-31 04:55:40,1,152,"<p>What are the angles (lambda, phi and theta) for Pauli-Z gate in U3 ?</p>
",How to find angle for Pauli-Z in U3,<qiskit><pauli-gates>,2,1,,,"How to find angle for Pauli-Z in U3 <p>What are the angles (lambda, phi and theta) for Pauli-Z gate in U3 ?</p>
",qc,find angle u3 p angles lambda phi theta gate u3,"[(0, 0.4457686), (9, 0.3373445), (17, 0.20021729)]"
28771,,2022-11-01 01:32:42,1,53,"<p>I am reading the <a href=""https://arxiv.org/abs/2105.02859"" rel=""nofollow noreferrer"">grand unification of quantum algorithms</a>, and read over the hamiltonian simulation technique.</p>
<p>However, I am a bit confused. They pose that</p>
<p><span class=""math-container"">$
e^{-iHt} = cos(Ht) - isin(Ht)
$</span></p>
<p>for all square matrices, <span class=""math-container"">$H$</span>.</p>
<p>Then they use this fact to reduce the problem of hamiltonian simulation to finding <span class=""math-container"">$cos(Ht)$</span> and <span class=""math-container"">$sin(Ht)$</span>, which is all well and good.</p>
<p>Then they make approximations for <span class=""math-container"">$cos(xt)$</span> and <span class=""math-container"">$-isin(xt)$</span> using Bessel functions. These functions will get applied to the singular values of <span class=""math-container"">$H$</span>.</p>
<p>My question is this:
It was proven that <span class=""math-container"">$e^{-iHt} = cos(Ht) - isin(Ht)$</span>, but it was never proven that <span class=""math-container"">$cos(Ht) = \sum_\sigma cos(\sigma t) \left | w_\sigma \right &gt; \left &lt; v_\sigma \right |$</span> (and the same for <span class=""math-container"">$-isin(xt)$</span>, where <span class=""math-container"">$\sigma$</span> denotes the singular values of <span class=""math-container"">$H$</span>, <span class=""math-container"">$w_\sigma$</span> denotes a left singular vector, and <span class=""math-container"">$v_\sigma$</span> denotes a right singular vector.</p>
<p>Wouldn't a proof of this be necessary to assert that quantum simulation can be done by simply using QSVT on the singular values?</p>
<p>I also wrote a simple python script to demonstrate that this is not the case:</p>
<pre><code>import numpy as np
import math as math
import pandas as pd

#cosine taylor series
def cos(x):
    f = x - x

    for i in range(30): #finite cutoff of 30
        f = f + ((-1) ** i) * (np.power(x, 2 * i)) * 1 / math.factorial(2 * i)
    
    return f

#example hermitian matrix
G = np.array([
    [3, 1, 2, 3],
    [1, 9, 4, 2],
    [2, 4, 5, 1],
    [3, 2, 1, 7]
])

svd = np.linalg.svd(G)

mat = [[0] * len(G)] * len(G)

for i in range(len(svd[1])):
    mat += cos(svd[1][i]) * np.outer(np.transpose(svd[0])[i], svd[2][i])

print(pd.DataFrame(cos(G))) #cosine of the matrix
print(pd.DataFrame(mat)) #cosine of the singular values (reconstruct the matrix)
</code></pre>
",Proof of $cos(Ht) = \sum_\sigma cos(\sigma) \left | w_\sigma \right > \left < v_\sigma \right |$ in Quantum Singular Value Transform,<simulation><hamiltonian-simulation><hamiltonian>,0,7,,,"Proof of $cos(Ht) = \sum_\sigma cos(\sigma) \left | w_\sigma \right > \left < v_\sigma \right |$ in Quantum Singular Value Transform <p>I am reading the <a href=""https://arxiv.org/abs/2105.02859"" rel=""nofollow noreferrer"">grand unification of quantum algorithms</a>, and read over the hamiltonian simulation technique.</p>
<p>However, I am a bit confused. They pose that</p>
<p><span class=""math-container"">$
e^{-iHt} = cos(Ht) - isin(Ht)
$</span></p>
<p>for all square matrices, <span class=""math-container"">$H$</span>.</p>
<p>Then they use this fact to reduce the problem of hamiltonian simulation to finding <span class=""math-container"">$cos(Ht)$</span> and <span class=""math-container"">$sin(Ht)$</span>, which is all well and good.</p>
<p>Then they make approximations for <span class=""math-container"">$cos(xt)$</span> and <span class=""math-container"">$-isin(xt)$</span> using Bessel functions. These functions will get applied to the singular values of <span class=""math-container"">$H$</span>.</p>
<p>My question is this:
It was proven that <span class=""math-container"">$e^{-iHt} = cos(Ht) - isin(Ht)$</span>, but it was never proven that <span class=""math-container"">$cos(Ht) = \sum_\sigma cos(\sigma t) \left | w_\sigma \right &gt; \left &lt; v_\sigma \right |$</span> (and the same for <span class=""math-container"">$-isin(xt)$</span>, where <span class=""math-container"">$\sigma$</span> denotes the singular values of <span class=""math-container"">$H$</span>, <span class=""math-container"">$w_\sigma$</span> denotes a left singular vector, and <span class=""math-container"">$v_\sigma$</span> denotes a right singular vector.</p>
<p>Wouldn't a proof of this be necessary to assert that quantum simulation can be done by simply using QSVT on the singular values?</p>
<p>I also wrote a simple python script to demonstrate that this is not the case:</p>
<pre><code>import numpy as np
import math as math
import pandas as pd

#cosine taylor series
def cos(x):
    f = x - x

    for i in range(30): #finite cutoff of 30
        f = f + ((-1) ** i) * (np.power(x, 2 * i)) * 1 / math.factorial(2 * i)
    
    return f

#example hermitian matrix
G = np.array([
    [3, 1, 2, 3],
    [1, 9, 4, 2],
    [2, 4, 5, 1],
    [3, 2, 1, 7]
])

svd = np.linalg.svd(G)

mat = [[0] * len(G)] * len(G)

for i in range(len(svd[1])):
    mat += cos(svd[1][i]) * np.outer(np.transpose(svd[0])[i], svd[2][i])

print(pd.DataFrame(cos(G))) #cosine of the matrix
print(pd.DataFrame(mat)) #cosine of the singular values (reconstruct the matrix)
</code></pre>
",qc,proof cos ht cos quantum singular value transform p reading https nofollow noreferrer grand unification quantum algorithms read hamiltonian simulation p however bit confused pose p span cos ht isin ht p square matrices span h p use fact reduce problem hamiltonian simulation finding span cos ht span sin ht well p make approximations span cos xt span xt using bessel functions functions get applied singular values span h p question proven span cos ht isin ht never proven span cos ht cos gt lt span xt span denotes singular values span h span denotes left singular vector span denotes right singular p would proof necessary assert quantum simulation done simply using qsvt singular values p also wrote simple python script demonstrate case pre code import numpy np import math math import pandas pd cosine taylor series def cos x f x x range 30 finite cutoff 30 f f x 2 1 2 return f example hermitian matrix g 3 1 2 3 1 9 4 2 2 4 5 1 3 2 1 7 svd g mat 0 len g len g range len svd 1 mat cos svd 1 svd 0 svd 2 print cos g cosine matrix print mat cosine singular values reconstruct matrix,"[(0, 0.14562012), (1, 0.043237034), (2, 0.18295972), (3, 0.20331632), (6, 0.021931859), (7, 0.17925224), (8, 0.051855158), (9, 0.07820851), (10, 0.052356508), (11, 0.014061172), (17, 0.021747006)]"
28788,28793.0,2022-11-02 09:48:43,1,165,"<p><a href=""https://i.sstatic.net/TaTEu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/TaTEu.png"" alt=""enter image description here"" /></a></p>
<p>In the image below for stabilizers for shors 9 qubit QECC, I understand the role of S1 to S8 operators but I am not getting role of X-bar and Z-bar operators. I know how to obtain them using standard form but not clear with its use and why do we need it</p>
","In stabilizer codes, I am not getting why do we need logical operators X-bar and Z-bar",<stabilizer-code>,1,0,,,"In stabilizer codes, I am not getting why do we need logical operators X-bar and Z-bar <p><a href=""https://i.sstatic.net/TaTEu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/TaTEu.png"" alt=""enter image description here"" /></a></p>
<p>In the image below for stabilizers for shors 9 qubit QECC, I understand the role of S1 to S8 operators but I am not getting role of X-bar and Z-bar operators. I know how to obtain them using standard form but not clear with its use and why do we need it</p>
",qc,stabilizer codes getting need logical operators p https nofollow noreferrer img https enter image description p image stabilizers shors 9 qubit qecc understand role s1 s8 operators getting role operators know obtain using standard form clear use need,"[(0, 0.033647016), (4, 0.4651342), (5, 0.4408088), (6, 0.028183931), (17, 0.028078951)]"
28799,28801.0,2022-11-03 03:05:59,3,224,"<p>I was following the Qiskit textbook:</p>
<p><a href=""https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html</a></p>
<p>In this, there is a statement as indicated below:</p>
<blockquote>
<p>With superconducting qubits, higher energy levels are also available,
but we fabricate the systems to be anharmonic so that we can control
which transition we are exciting. That way, we are able to isolate two
energy levels and treat each qubit as a basic two-level system,
ignoring higher energy states.</p>
</blockquote>
<p>I understand that there are higher energy levels available, but how are we controlling which transition we are exciting by fabricating the system to be anharmonic?</p>
",Why are quantum systems fabricated to be anharmonic?,<qiskit><experimental-realization>,1,0,,,"Why are quantum systems fabricated to be anharmonic? <p>I was following the Qiskit textbook:</p>
<p><a href=""https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-pulse.html</a></p>
<p>In this, there is a statement as indicated below:</p>
<blockquote>
<p>With superconducting qubits, higher energy levels are also available,
but we fabricate the systems to be anharmonic so that we can control
which transition we are exciting. That way, we are able to isolate two
energy levels and treat each qubit as a basic two-level system,
ignoring higher energy states.</p>
</blockquote>
<p>I understand that there are higher energy levels available, but how are we controlling which transition we are exciting by fabricating the system to be anharmonic?</p>
",qc,quantum systems fabricated anharmonic p following qiskit textbook p https nofollow noreferrer https p statement indicated blockquote p superconducting qubits higher energy levels also available fabricate systems anharmonic control transition exciting way able isolate two energy levels treat qubit basic system ignoring higher energy p understand higher energy levels available controlling transition exciting fabricating system anharmonic,"[(1, 0.12552433), (4, 0.21365161), (8, 0.13125317), (9, 0.32703283), (13, 0.05320647), (17, 0.14642504)]"
28826,28843.0,2022-11-04 16:53:43,1,80,"<p>Nielsen and Chuang [10e, p. 74] introduce the Kronecker product <span class=""math-container"">$A\otimes_K B$</span> as a matrix representation of the tensor product <span class=""math-container"">$A\otimes B$</span> of the operators <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> (for clarity I use a subscript <span class=""math-container"">$K$</span> to distinguish the Kronecker product of matrices from the tensor product). My question is about whether there is such a representation for biproduct mixed states in multipartite quantum systems.</p>
<p>Suppose I have Hilbert spaces <span class=""math-container"">$H_A$</span>, <span class=""math-container"">$H_B$</span>, <span class=""math-container"">$H_C$</span> of a tripartite system e.g. three qubits. An example of a fully separable state is the product <span class=""math-container"">$\rho^A \otimes \rho^B \otimes \rho^C$</span> where the density operators  <span class=""math-container"">$\rho^A$</span>, <span class=""math-container"">$\rho^B$</span>, <span class=""math-container"">$\rho^C$</span> lie in the respective Hilbert spaces. Examples of biseperable states might be <span class=""math-container"">$\rho^A \otimes \rho^{BC} $</span> and <span class=""math-container"">$\rho^B \otimes \rho^{AC}$</span> where the density operators <span class=""math-container"">$\rho^{BC}$</span> and <span class=""math-container"">$\rho^{AC}$</span> now lie in the composite Hilbert spaces <span class=""math-container"">$H_B\otimes H_C$</span> and <span class=""math-container"">$H_A\otimes H_C$</span> respectively.</p>
<p>I wouldn't be surprised if you told me the matrix representation of the product <span class=""math-container"">$\rho^A \otimes \rho^B \otimes \rho^C$</span> was <span class=""math-container"">$\rho^A \otimes_K \rho^B \otimes_K \rho^C$</span>, or that the representation of <span class=""math-container"">$\rho^A \otimes \rho^{BC} $</span> was <span class=""math-container"">$\rho^A \otimes_K \rho^{BC} $</span> (where <span class=""math-container"">$\rho^{BC}$</span> is a square matrix of side length <span class=""math-container"">$\text{dim}(H_B)\times \text{dim}(H_C)$</span>). However, I don't think the matrix representation of  <span class=""math-container"">$\rho^B \otimes \rho^{AC}$</span> could possibly be of the form <span class=""math-container"">$\rho^B \otimes_K \rho^{AC}$</span>, because the spaces are 'in the wrong order.'</p>
<p>Mathematically, I understand the Kronecker product as a matrix representation <em>with respect to</em> bases <span class=""math-container"">$U_A,U_B,U_C$</span> (say) of the subsystems <em>in a given order</em>. So if I take
<span class=""math-container"">$\rho^A \otimes_K \rho^B \otimes_K \rho^C$</span> to be the matrix representation of <span class=""math-container"">$\rho^A\otimes \rho^B \otimes \rho^C$</span>, I feel like I would need to apply some permutation to the <span class=""math-container"">$\text{dim}(H_A) \times  \text{dim}(H_B) \times \text{dim}(H_C) $</span> matrix  <span class=""math-container"">$\rho^B \otimes_K \rho^{AC}$</span> in order for it to represent  <span class=""math-container"">$\rho^B \otimes \rho^{AC}$</span>. Is there a consistent way of doing this? Perhaps I am misunderstanding the use of the tensor product in quantum information, in which case please let me know.</p>
",Matrix representation for biproduct mixed states,<entanglement><density-matrix><matrix-representation><linear-algebra><quantum-state>,1,0,,,"Matrix representation for biproduct mixed states <p>Nielsen and Chuang [10e, p. 74] introduce the Kronecker product <span class=""math-container"">$A\otimes_K B$</span> as a matrix representation of the tensor product <span class=""math-container"">$A\otimes B$</span> of the operators <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> (for clarity I use a subscript <span class=""math-container"">$K$</span> to distinguish the Kronecker product of matrices from the tensor product). My question is about whether there is such a representation for biproduct mixed states in multipartite quantum systems.</p>
<p>Suppose I have Hilbert spaces <span class=""math-container"">$H_A$</span>, <span class=""math-container"">$H_B$</span>, <span class=""math-container"">$H_C$</span> of a tripartite system e.g. three qubits. An example of a fully separable state is the product <span class=""math-container"">$\rho^A \otimes \rho^B \otimes \rho^C$</span> where the density operators  <span class=""math-container"">$\rho^A$</span>, <span class=""math-container"">$\rho^B$</span>, <span class=""math-container"">$\rho^C$</span> lie in the respective Hilbert spaces. Examples of biseperable states might be <span class=""math-container"">$\rho^A \otimes \rho^{BC} $</span> and <span class=""math-container"">$\rho^B \otimes \rho^{AC}$</span> where the density operators <span class=""math-container"">$\rho^{BC}$</span> and <span class=""math-container"">$\rho^{AC}$</span> now lie in the composite Hilbert spaces <span class=""math-container"">$H_B\otimes H_C$</span> and <span class=""math-container"">$H_A\otimes H_C$</span> respectively.</p>
<p>I wouldn't be surprised if you told me the matrix representation of the product <span class=""math-container"">$\rho^A \otimes \rho^B \otimes \rho^C$</span> was <span class=""math-container"">$\rho^A \otimes_K \rho^B \otimes_K \rho^C$</span>, or that the representation of <span class=""math-container"">$\rho^A \otimes \rho^{BC} $</span> was <span class=""math-container"">$\rho^A \otimes_K \rho^{BC} $</span> (where <span class=""math-container"">$\rho^{BC}$</span> is a square matrix of side length <span class=""math-container"">$\text{dim}(H_B)\times \text{dim}(H_C)$</span>). However, I don't think the matrix representation of  <span class=""math-container"">$\rho^B \otimes \rho^{AC}$</span> could possibly be of the form <span class=""math-container"">$\rho^B \otimes_K \rho^{AC}$</span>, because the spaces are 'in the wrong order.'</p>
<p>Mathematically, I understand the Kronecker product as a matrix representation <em>with respect to</em> bases <span class=""math-container"">$U_A,U_B,U_C$</span> (say) of the subsystems <em>in a given order</em>. So if I take
<span class=""math-container"">$\rho^A \otimes_K \rho^B \otimes_K \rho^C$</span> to be the matrix representation of <span class=""math-container"">$\rho^A\otimes \rho^B \otimes \rho^C$</span>, I feel like I would need to apply some permutation to the <span class=""math-container"">$\text{dim}(H_A) \times  \text{dim}(H_B) \times \text{dim}(H_C) $</span> matrix  <span class=""math-container"">$\rho^B \otimes_K \rho^{AC}$</span> in order for it to represent  <span class=""math-container"">$\rho^B \otimes \rho^{AC}$</span>. Is there a consistent way of doing this? Perhaps I am misunderstanding the use of the tensor product in quantum information, in which case please let me know.</p>
",qc,matrix representation biproduct mixed states p nielsen chuang 10e 74 introduce kronecker product span b matrix representation tensor product span b operators span span b clarity use subscript span k distinguish kronecker product matrices tensor product question whether representation biproduct mixed states multipartite quantum p suppose hilbert spaces span span span tripartite system three qubits example fully separable state product span density operators span span span lie respective hilbert spaces examples biseperable states might span bc span ac density operators span bc span ac lie composite hilbert spaces span span p would surprised told matrix representation product span span representation span bc span bc span bc square matrix side length span dim dim however think matrix representation span ac could possibly form span ac spaces wrong order p mathematically understand kronecker product matrix representation em respect bases span say subsystems em given order take span matrix representation span feel like would need apply permutation span dim dim dim matrix span ac order represent span ac consistent way perhaps misunderstanding use tensor product quantum information case please let,"[(3, 0.87488544), (11, 0.09587321), (17, 0.020349441)]"
28859,28865.0,2022-11-07 00:58:31,1,181,"<p>I am interested in translating something to Stim so that it can run faster. The QEC code that I am trying to implement includes some syndromes that are only measured every 2 rounds. They are obtained by taking the parity between some gauge operators from the odd rounds and some gauge operators from the even rounds.</p>
<p>When building the decoder graph, the old implementation handles these special syndromes by repeating their measurements from the (2n)th round in the (2n + 1)th round. So that the decoder graph has the same structure as if all syndromes are measured every round.</p>
<p>If I specify this code in a Stim circuit, will it work? Stim gives users lots of freedom in specifying the circuit, so I think it will probably work better than the old implementation described above. Can anyone confirm?</p>
",Does Stim work if some syndromes are only measured every 2 rounds?,<error-correction><stim>,1,0,,,"Does Stim work if some syndromes are only measured every 2 rounds? <p>I am interested in translating something to Stim so that it can run faster. The QEC code that I am trying to implement includes some syndromes that are only measured every 2 rounds. They are obtained by taking the parity between some gauge operators from the odd rounds and some gauge operators from the even rounds.</p>
<p>When building the decoder graph, the old implementation handles these special syndromes by repeating their measurements from the (2n)th round in the (2n + 1)th round. So that the decoder graph has the same structure as if all syndromes are measured every round.</p>
<p>If I specify this code in a Stim circuit, will it work? Stim gives users lots of freedom in specifying the circuit, so I think it will probably work better than the old implementation described above. Can anyone confirm?</p>
",qc,stim work syndromes measured every 2 rounds p interested translating something stim run faster qec code trying implement includes syndromes measured every 2 rounds obtained taking parity gauge operators odd rounds gauge operators even p building decoder graph old implementation handles special syndromes repeating measurements 2n th round 2n 1 th round decoder graph structure syndromes measured every p specify code stim circuit work stim gives users lots freedom specifying circuit think probably work better old implementation described anyone confirm,"[(2, 0.03309576), (3, 0.0877652), (5, 0.3012011), (8, 0.021089396), (9, 0.077734455), (13, 0.05814251), (14, 0.3708973), (17, 0.048577007)]"
28921,29659.0,2022-11-09 05:49:03,0,182,"<p>In the simplest case, let's assume we have distance 2 surface code. The X stabilizers will be: X1X2X3 and X3X4X5 which is shown by the red lines.</p>
<p><a href=""https://i.sstatic.net/sj31b.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/sj31b.png"" alt=""enter image description here"" /></a></p>
<p>So the parity check matrix will be:
<span class=""math-container"">$$
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp;0 &amp;0 \\
0 &amp; 0 &amp; 1  &amp;1 &amp; 1
\end{bmatrix}
$$</span>
Now when I run the code scripts with pymatching to see how it works,</p>
<pre><code>m =Matching()
m.load_from_check_matrix([[1, 1,1,0,0],[0,0,1,1,1]])
plt.show()
</code></pre>
<p>I get the following image as a result. I actually did not understand what this plot means. The empty circle is the boundary. Is it the boundary qubit? Filled circles (in this case 0 and 1) are the stabilizers. But I have just 2 filled circles. Does this mean that one of the filled circle is X1X2X3 and the other filled circle X3X4X5?  I also did not understand the weights, for example why do we have 0 between boundary and the circle-0 and why do we have 3 between boundary and the circle-1? Can someone explain me what this plot represents?
<a href=""https://i.sstatic.net/0hNr0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0hNr0.png"" alt=""enter image description here"" /></a></p>
",Check_matrix in Pymatching and Understanding the Plot,<programming><surface-code><pymatching>,1,0,,,"Check_matrix in Pymatching and Understanding the Plot <p>In the simplest case, let's assume we have distance 2 surface code. The X stabilizers will be: X1X2X3 and X3X4X5 which is shown by the red lines.</p>
<p><a href=""https://i.sstatic.net/sj31b.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/sj31b.png"" alt=""enter image description here"" /></a></p>
<p>So the parity check matrix will be:
<span class=""math-container"">$$
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp;0 &amp;0 \\
0 &amp; 0 &amp; 1  &amp;1 &amp; 1
\end{bmatrix}
$$</span>
Now when I run the code scripts with pymatching to see how it works,</p>
<pre><code>m =Matching()
m.load_from_check_matrix([[1, 1,1,0,0],[0,0,1,1,1]])
plt.show()
</code></pre>
<p>I get the following image as a result. I actually did not understand what this plot means. The empty circle is the boundary. Is it the boundary qubit? Filled circles (in this case 0 and 1) are the stabilizers. But I have just 2 filled circles. Does this mean that one of the filled circle is X1X2X3 and the other filled circle X3X4X5?  I also did not understand the weights, for example why do we have 0 between boundary and the circle-0 and why do we have 3 between boundary and the circle-1? Can someone explain me what this plot represents?
<a href=""https://i.sstatic.net/0hNr0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0hNr0.png"" alt=""enter image description here"" /></a></p>
",qc,pymatching understanding plot p simplest case let assume distance 2 surface code x stabilizers x1x2x3 x3x4x5 shown red p https nofollow noreferrer img https enter image description p parity check matrix span bmatrix 1 amp 1 amp 1 amp 0 amp 0 0 amp 0 amp 1 amp 1 amp 1 bmatrix run code scripts pymatching see works pre code 1 p get following image result actually understand plot means empty circle boundary boundary qubit filled circles case 0 1 stabilizers 2 filled circles mean one filled circle x1x2x3 filled circle x3x4x5 also understand weights example 0 boundary 3 boundary someone explain plot represents https nofollow noreferrer img https enter image description,"[(2, 0.16450061), (4, 0.44759628), (5, 0.22309424), (6, 0.01126881), (15, 0.13212104), (17, 0.020124046)]"
28976,28995.0,2022-11-13 11:39:32,2,268,"<p>As a practice exercise, I am trying to factor <span class=""math-container"">$N=14$</span> using Shor's algorithm. My initial guess is <span class=""math-container"">$a = 5$</span>, and I need a quantum circuit <span class=""math-container"">$U$</span> for:</p>
<p><span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 14 \rangle$</span> for <span class=""math-container"">$y=1, 2, \cdots, 13$</span>, i.e. for <span class=""math-container"">$y=0001, 0010,  ... , 1101$</span>. The modular arithmetic yields the table:</p>
<p>01 0001 0011 <br />
02 0010 0110 <br />
03 0011 1001 <br />
04 0100 1100 <br />
05 0101 0001 <br />
06 0110 0100 <br />
07 0111 0111 <br />
08 1000 1010 <br />
09 1001 1101 <br />
10 1010 0010 <br />
11 1011 0101 <br />
12 1100 1000 <br />
13 1101 1011</p>
<p>The qiskit examples give a circuit for <span class=""math-container"">$N=15$</span>, and
I was able to find a similar circuit for factoring <span class=""math-container"">$N=6$</span> by trial and error. <span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 6 \rangle$</span> is reproduced by:</p>
<p><a href=""https://i.sstatic.net/qaF7A.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qaF7A.jpg"" alt=""enter image description here"" /></a></p>
<p>Clearly, trial and error isn't going to work for <span class=""math-container"">$N=14$</span>. Is there a systematic method that will provide the circuit I am looking for?</p>
",How to factor $N=14$ with Shor's algorithm?,<quantum-algorithms><circuit-construction><shors-algorithm>,2,1,,,"How to factor $N=14$ with Shor's algorithm? <p>As a practice exercise, I am trying to factor <span class=""math-container"">$N=14$</span> using Shor's algorithm. My initial guess is <span class=""math-container"">$a = 5$</span>, and I need a quantum circuit <span class=""math-container"">$U$</span> for:</p>
<p><span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 14 \rangle$</span> for <span class=""math-container"">$y=1, 2, \cdots, 13$</span>, i.e. for <span class=""math-container"">$y=0001, 0010,  ... , 1101$</span>. The modular arithmetic yields the table:</p>
<p>01 0001 0011 <br />
02 0010 0110 <br />
03 0011 1001 <br />
04 0100 1100 <br />
05 0101 0001 <br />
06 0110 0100 <br />
07 0111 0111 <br />
08 1000 1010 <br />
09 1001 1101 <br />
10 1010 0010 <br />
11 1011 0101 <br />
12 1100 1000 <br />
13 1101 1011</p>
<p>The qiskit examples give a circuit for <span class=""math-container"">$N=15$</span>, and
I was able to find a similar circuit for factoring <span class=""math-container"">$N=6$</span> by trial and error. <span class=""math-container"">$U\vert y \rangle = \vert 5 \cdot y ~{\rm mod}~ 6 \rangle$</span> is reproduced by:</p>
<p><a href=""https://i.sstatic.net/qaF7A.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qaF7A.jpg"" alt=""enter image description here"" /></a></p>
<p>Clearly, trial and error isn't going to work for <span class=""math-container"">$N=14$</span>. Is there a systematic method that will provide the circuit I am looking for?</p>
",qc,factor shor algorithm p practice exercise trying factor span using shor algorithm initial guess span 5 need quantum circuit span u p span 5 mod 14 span 2 13 span 0010 1101 modular arithmetic yields table p 01 0001 0011 br 02 0010 0110 br 03 0011 1001 br 04 0100 1100 br 05 0101 0001 br 06 0110 0100 br 07 0111 0111 br 08 1000 1010 br 09 1001 1101 br 10 1010 0010 br 11 1011 0101 br 12 1100 1000 br 13 1101 1011 p qiskit examples give circuit span able find similar circuit factoring span trial error span 5 mod 6 reproduced p https nofollow noreferrer img https enter image description p clearly trial error going work span systematic method provide circuit looking,"[(3, 0.19624029), (4, 0.2456238), (6, 0.12288077), (7, 0.102600046), (8, 0.059165563), (12, 0.06665884), (13, 0.16601714), (17, 0.039722923)]"
28993,,2022-11-14 16:09:09,0,61,"<br>
After I read the ""[Quantum computing foundations](https://learn.microsoft.com/en-us/training/paths/quantum-computing-fundamentals/)
of Microsoft I would like to be sure I understand a little the things. So, I code my own Groover search. The problem is simple. My code wants retrieve the index in array given a value. The very simple example is I have an array [""A"", ""B"", ""C"", ""D""] and the given value is ""B"" so I would like have as result 1.
<p>I have 2 errors for the moment:
<br>
First, I have an error with my function to retrieve the index, but I think it's a  little thing.
<a href=""https://i.sstatic.net/c6Hlf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/c6Hlf.png"" alt=""enter image description here"" /></a></p>
<br>
Secondly (and most important), the output register returns me an array of bits matching with ""A"" and not ""B"" as I wish.
<p><a href=""https://i.sstatic.net/2YIv4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2YIv4.png"" alt=""enter image description here"" /></a></p>
<p>Someone could help me understand what I am doing wrong.</p>
<pre><code>namespace MyFirstOwnGroversSearch {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Measurement;


    
    @EntryPoint()
    operation MyFirstOwnGroverSearch() : Unit {
        Message(&quot;Hello quantum world!&quot;);
        let values = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
        let asciiValues = [65,66,67,68];
        let asciiValuesAsBooleans = [IntAsBoolArray(65,7), IntAsBoolArray(66,7), IntAsBoolArray(67,7), IntAsBoolArray(68,7)];

        use (registerToBeMatched) = (Qubit[7]);
        // prepare registerToBeMatched -&gt; apply an X gate to each qubit that corresponds to &quot;true&quot; bit in the bit string.
        let targetValue = 66; // &quot;B&quot;;
        let targetValueAsBool = IntAsBoolArray(targetValue,7); 
        ApplyPauliFromBitString(PauliX, true, asciiValuesAsBooleans[0], registerToBeMatched);
        
        use target = Qubit();

        let markingOracle = MarkEquality(_,_,_); // put target to 1 if arrays bits are equals ( first and second args)
        let phaseOracle = ApplyMarkingOracleAsPhaseOracle(markingOracle,_,registerToBeMatched);

        // Define the parameters of the search.
        // Each character is described using 7 bits (or qubits).
        let nQubits = 7;
        // The search space is all bit strings of length nQubits.
        let searchSpaceSize = 2 ^ (nQubits);
        let nSolutions = 1;
        // The number of iterations can be computed using a formula.
        let nIterations = Round(PI() / 4.0 * Sqrt(IntAsDouble(searchSpaceSize) / IntAsDouble(nSolutions)));

        mutable answer = new Bool[nQubits];
        use (register, output) = (Qubit[nQubits], Qubit());
        mutable isCorrect = false;
        repeat {
            RunGroversSearch(register, phaseOracle, nIterations);
            let res = MultiM(register);
            // Check whether the result is correct.
            markingOracle(register, registerToBeMatched, output);
            if (MResetZ(output) == One) {
                set isCorrect = true;
                set answer = ResultArrayAsBoolArray(res);
            }
            ResetAll(register);
        } until (isCorrect);

        // Convert the answer to readable format (actual graph coloring).
        let resultAsInt = BoolArrayAsInt(answer);
        let idx = IndexOf(isEqual(resultAsInt,targetValue), asciiValues);
        //Message(<span class=""math-container"">$""result: {BoolArrayAsInt(answer)} and index is {idx}"");
    Message($</span>&quot;result: {BoolArrayAsInt(answer)}&quot;);
        Reset(output);
        ResetAll(registerToBeMatched);
    }

    operation isEqual (a: Int, b: Int) :  Bool {
        return (a == b);
    }
    
    operation MarkEquality(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl {
        within {
            for (q0, q1) in Zipped(c0, c1) {
                // Compute XOR of bits q0 and q1 in place (storing it in q1).
                CNOT(q0, q1);
            }
        } apply {
            // If all computed XORs are 0, the bit strings are equal - flip the state of the target.
            (ControlledOnInt(0, X))(c1, target);
        }
    }    

    operation ApplyMarkingOracleAsPhaseOracle(
        markingOracle : ((Qubit[], Qubit[], Qubit) =&gt; Unit is Adj), 
        c0 : Qubit[],
        c1 : Qubit[]
    ) : Unit is Adj {
        use target = Qubit();
        within {
            // Put the target qubit into the |-⟩ state.
            X(target);
            H(target);
        } apply {
            // Apply the marking oracle; since the target is in the |-⟩ state,
            // flipping the target if the register state satisfies the condition 
            // will apply a -1 relative phase to the register state.
            markingOracle(c0, c1, target);
        }
    }

    operation RunGroversSearch(register : Qubit[], phaseOracle : ((Qubit[]) =&gt; Unit is Adj), iterations : Int) : Unit {
        ApplyToEach(H, register);
        
        for _ in 1 .. iterations {
            phaseOracle(register);
            within {
                ApplyToEachA(H, register);
                ApplyToEachA(X, register);
            } apply {
                Controlled Z(Most(register), Tail(register));
            }
        }
    }

}
<span class=""math-container"">```</span>
</code></pre>
",My First Own Grover Search with Q#,<q#>,0,3,,,"My First Own Grover Search with Q# <br>
After I read the ""[Quantum computing foundations](https://learn.microsoft.com/en-us/training/paths/quantum-computing-fundamentals/)
of Microsoft I would like to be sure I understand a little the things. So, I code my own Groover search. The problem is simple. My code wants retrieve the index in array given a value. The very simple example is I have an array [""A"", ""B"", ""C"", ""D""] and the given value is ""B"" so I would like have as result 1.
<p>I have 2 errors for the moment:
<br>
First, I have an error with my function to retrieve the index, but I think it's a  little thing.
<a href=""https://i.sstatic.net/c6Hlf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/c6Hlf.png"" alt=""enter image description here"" /></a></p>
<br>
Secondly (and most important), the output register returns me an array of bits matching with ""A"" and not ""B"" as I wish.
<p><a href=""https://i.sstatic.net/2YIv4.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2YIv4.png"" alt=""enter image description here"" /></a></p>
<p>Someone could help me understand what I am doing wrong.</p>
<pre><code>namespace MyFirstOwnGroversSearch {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Measurement;


    
    @EntryPoint()
    operation MyFirstOwnGroverSearch() : Unit {
        Message(&quot;Hello quantum world!&quot;);
        let values = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];
        let asciiValues = [65,66,67,68];
        let asciiValuesAsBooleans = [IntAsBoolArray(65,7), IntAsBoolArray(66,7), IntAsBoolArray(67,7), IntAsBoolArray(68,7)];

        use (registerToBeMatched) = (Qubit[7]);
        // prepare registerToBeMatched -&gt; apply an X gate to each qubit that corresponds to &quot;true&quot; bit in the bit string.
        let targetValue = 66; // &quot;B&quot;;
        let targetValueAsBool = IntAsBoolArray(targetValue,7); 
        ApplyPauliFromBitString(PauliX, true, asciiValuesAsBooleans[0], registerToBeMatched);
        
        use target = Qubit();

        let markingOracle = MarkEquality(_,_,_); // put target to 1 if arrays bits are equals ( first and second args)
        let phaseOracle = ApplyMarkingOracleAsPhaseOracle(markingOracle,_,registerToBeMatched);

        // Define the parameters of the search.
        // Each character is described using 7 bits (or qubits).
        let nQubits = 7;
        // The search space is all bit strings of length nQubits.
        let searchSpaceSize = 2 ^ (nQubits);
        let nSolutions = 1;
        // The number of iterations can be computed using a formula.
        let nIterations = Round(PI() / 4.0 * Sqrt(IntAsDouble(searchSpaceSize) / IntAsDouble(nSolutions)));

        mutable answer = new Bool[nQubits];
        use (register, output) = (Qubit[nQubits], Qubit());
        mutable isCorrect = false;
        repeat {
            RunGroversSearch(register, phaseOracle, nIterations);
            let res = MultiM(register);
            // Check whether the result is correct.
            markingOracle(register, registerToBeMatched, output);
            if (MResetZ(output) == One) {
                set isCorrect = true;
                set answer = ResultArrayAsBoolArray(res);
            }
            ResetAll(register);
        } until (isCorrect);

        // Convert the answer to readable format (actual graph coloring).
        let resultAsInt = BoolArrayAsInt(answer);
        let idx = IndexOf(isEqual(resultAsInt,targetValue), asciiValues);
        //Message(<span class=""math-container"">$""result: {BoolArrayAsInt(answer)} and index is {idx}"");
    Message($</span>&quot;result: {BoolArrayAsInt(answer)}&quot;);
        Reset(output);
        ResetAll(registerToBeMatched);
    }

    operation isEqual (a: Int, b: Int) :  Bool {
        return (a == b);
    }
    
    operation MarkEquality(c0 : Qubit[], c1 : Qubit[], target : Qubit) : Unit is Adj+Ctl {
        within {
            for (q0, q1) in Zipped(c0, c1) {
                // Compute XOR of bits q0 and q1 in place (storing it in q1).
                CNOT(q0, q1);
            }
        } apply {
            // If all computed XORs are 0, the bit strings are equal - flip the state of the target.
            (ControlledOnInt(0, X))(c1, target);
        }
    }    

    operation ApplyMarkingOracleAsPhaseOracle(
        markingOracle : ((Qubit[], Qubit[], Qubit) =&gt; Unit is Adj), 
        c0 : Qubit[],
        c1 : Qubit[]
    ) : Unit is Adj {
        use target = Qubit();
        within {
            // Put the target qubit into the |-⟩ state.
            X(target);
            H(target);
        } apply {
            // Apply the marking oracle; since the target is in the |-⟩ state,
            // flipping the target if the register state satisfies the condition 
            // will apply a -1 relative phase to the register state.
            markingOracle(c0, c1, target);
        }
    }

    operation RunGroversSearch(register : Qubit[], phaseOracle : ((Qubit[]) =&gt; Unit is Adj), iterations : Int) : Unit {
        ApplyToEach(H, register);
        
        for _ in 1 .. iterations {
            phaseOracle(register);
            within {
                ApplyToEachA(H, register);
                ApplyToEachA(X, register);
            } apply {
                Controlled Z(Most(register), Tail(register));
            }
        }
    }

}
<span class=""math-container"">```</span>
</code></pre>
",qc,first grover search q br read quantum computing foundations https microsoft would like sure understand little things code groover search problem simple code wants retrieve index array given value simple example array b c given value b would like result 1 p 2 errors moment br first error function retrieve index think little thing https nofollow noreferrer img https enter image description br secondly important output register returns array bits matching b wish p https nofollow noreferrer img https enter image description p someone could help understand pre code namespace myfirstowngroverssearch open open open open open open open entrypoint operation myfirstowngroversearch unit message quot hello quantum world quot let values quot quot quot b quot quot c quot quot quot let asciivalues let asciivaluesasbooleans intasboolarray intasboolarray intasboolarray intasboolarray use registertobematched qubit 7 prepare registertobematched gt apply x gate qubit corresponds quot true quot bit bit string let targetvalue 66 quot b quot let targetvalueasbool intasboolarray applypaulifrombitstring paulix true asciivaluesasbooleans 0 registertobematched use target qubit let markingoracle markequality put target 1 arrays bits equals first second args let phaseoracle applymarkingoracleasphaseoracle markingoracle registertobematched define parameters search character described using 7 bits qubits let nqubits 7 search space bit strings length nqubits let searchspacesize 2 nqubits let nsolutions 1 number iterations computed using formula let niterations round pi sqrt intasdouble searchspacesize intasdouble nsolutions mutable answer new bool nqubits use register output qubit nqubits qubit mutable iscorrect false repeat rungroverssearch register phaseoracle niterations let res multim register check whether result correct markingoracle register registertobematched output mresetz output one set iscorrect true set answer resultarrayasboolarray res resetall register iscorrect convert answer readable format actual graph coloring let resultasint boolarrayasint answer let idx indexof isequal resultasint targetvalue asciivalues span result boolarrayasint answer index idx message quot result boolarrayasint answer quot reset output resetall registertobematched operation isequal int b int bool return b operation markequality c0 qubit c1 qubit target qubit unit within q0 q1 zipped c0 c1 compute xor bits q0 q1 place storing q1 cnot q0 q1 apply computed xors 0 bit strings equal flip state target controlledonint 0 x c1 target operation applymarkingoracleasphaseoracle markingoracle qubit qubit qubit gt unit adj c0 qubit c1 qubit unit adj use target qubit within put target qubit state x target h target apply apply marking oracle since target state flipping target register state satisfies condition apply relative phase register state markingoracle c0 c1 target operation rungroverssearch register qubit phaseoracle qubit gt unit adj iterations int unit applytoeach h register 1 iterations phaseoracle register within applytoeacha h register applytoeacha x register apply controlled z register tail register span,"[(0, 0.13179857), (2, 0.01687887), (4, 0.0806392), (6, 0.020952933), (7, 0.03741616), (10, 0.023512166), (13, 0.14580496), (14, 0.0673588), (16, 0.08936225), (17, 0.020114344), (18, 0.28704107), (19, 0.07890204)]"
29019,,2022-11-16 21:14:54,2,202,"<p>It is normal to extend <a href=""https://arxiv.org/abs/1409.3305"" rel=""nofollow noreferrer"">fixed-point amplitude amplification</a> to an oblivious version, i.e.,
<span class=""math-container"">$1 - (1-e^{i \beta})|t\rangle \langle t |  \rightarrow 1 - (1-e^{i \beta}) 1 \otimes |0\rangle \langle 0|$</span>, and one uses an additional ancilla to apply a phase to the target state <span class=""math-container"">$|t\rangle$</span>.</p>
<p>However typically the other reflection, <span class=""math-container"">$1 - (1-e^{-i\alpha}) |0\rangle \langle 0|$</span> is about the all-zero initial state.  But suppose you are given an unknown initial state, <span class=""math-container"">$|\psi_0 \rangle$</span>.  You know you can construct a unitary <span class=""math-container"">$U$</span> that does
<span class=""math-container"">$$
U |\psi_0\rangle |0\rangle = \sqrt{a}|A_0\rangle |0\rangle + \sqrt{1-a}|A_1\rangle |1\rangle,
$$</span>
and so could amplify the probability of <span class=""math-container"">$|A_{0}\rangle |0\rangle$</span> to 1, but only if you could implement <span class=""math-container"">$1 - (1-e^{-i\alpha})|\psi_0\rangle\langle \psi_0 | \otimes |0\rangle \langle 0|$</span>, and you don't know how <span class=""math-container"">$|\psi_{0}\rangle$</span> came about.  Is it possible instead to construct a unitary <span class=""math-container"">$U'$</span> that will give you
<span class=""math-container"">$$
U' |\psi_0\rangle |0\rangle = \sqrt{a}|A_0\rangle |0\rangle + \sqrt{1-a}|A_1\rangle |1\rangle,
$$</span>
while simultaneously only using <span class=""math-container"">$1 - (1-e^{-i\alpha})1\otimes |0\rangle \langle 0|$</span> for the initial state reflection during amplitude amplification?  It is not clear to me how one would construct a <span class=""math-container"">$U'$</span> that moves between the two bases <span class=""math-container"">$|A_0\rangle |0\rangle$</span>, <span class=""math-container"">$|A_1\rangle |1\rangle$</span>, and <span class=""math-container"">$|\psi_0\rangle |0\rangle$</span>, <span class=""math-container"">$|\psi_{1}\rangle |1\rangle$</span>, for some <span class=""math-container"">$|\psi_1 \rangle |1\rangle$</span>.</p>
",Can one obliviously reflect about the *initial* state in fixed-point amplitude amplification?,<amplitude-amplification>,1,0,,,"Can one obliviously reflect about the *initial* state in fixed-point amplitude amplification? <p>It is normal to extend <a href=""https://arxiv.org/abs/1409.3305"" rel=""nofollow noreferrer"">fixed-point amplitude amplification</a> to an oblivious version, i.e.,
<span class=""math-container"">$1 - (1-e^{i \beta})|t\rangle \langle t |  \rightarrow 1 - (1-e^{i \beta}) 1 \otimes |0\rangle \langle 0|$</span>, and one uses an additional ancilla to apply a phase to the target state <span class=""math-container"">$|t\rangle$</span>.</p>
<p>However typically the other reflection, <span class=""math-container"">$1 - (1-e^{-i\alpha}) |0\rangle \langle 0|$</span> is about the all-zero initial state.  But suppose you are given an unknown initial state, <span class=""math-container"">$|\psi_0 \rangle$</span>.  You know you can construct a unitary <span class=""math-container"">$U$</span> that does
<span class=""math-container"">$$
U |\psi_0\rangle |0\rangle = \sqrt{a}|A_0\rangle |0\rangle + \sqrt{1-a}|A_1\rangle |1\rangle,
$$</span>
and so could amplify the probability of <span class=""math-container"">$|A_{0}\rangle |0\rangle$</span> to 1, but only if you could implement <span class=""math-container"">$1 - (1-e^{-i\alpha})|\psi_0\rangle\langle \psi_0 | \otimes |0\rangle \langle 0|$</span>, and you don't know how <span class=""math-container"">$|\psi_{0}\rangle$</span> came about.  Is it possible instead to construct a unitary <span class=""math-container"">$U'$</span> that will give you
<span class=""math-container"">$$
U' |\psi_0\rangle |0\rangle = \sqrt{a}|A_0\rangle |0\rangle + \sqrt{1-a}|A_1\rangle |1\rangle,
$$</span>
while simultaneously only using <span class=""math-container"">$1 - (1-e^{-i\alpha})1\otimes |0\rangle \langle 0|$</span> for the initial state reflection during amplitude amplification?  It is not clear to me how one would construct a <span class=""math-container"">$U'$</span> that moves between the two bases <span class=""math-container"">$|A_0\rangle |0\rangle$</span>, <span class=""math-container"">$|A_1\rangle |1\rangle$</span>, and <span class=""math-container"">$|\psi_0\rangle |0\rangle$</span>, <span class=""math-container"">$|\psi_{1}\rangle |1\rangle$</span>, for some <span class=""math-container"">$|\psi_1 \rangle |1\rangle$</span>.</p>
",qc,one obliviously reflect initial state amplitude amplification p normal extend https nofollow noreferrer amplitude amplification oblivious version span 1 1 1 one uses additional ancilla apply phase target state span p however typically reflection span 1 initial state suppose given unknown initial state span know construct unitary span u span u could amplify probability span 0 1 could implement span 1 know span 0 came possible instead construct unitary span u give span u simultaneously using span 1 initial state reflection amplitude amplification clear one would construct span u moves two bases span span span span 1 span,"[(2, 0.09633853), (3, 0.36800355), (4, 0.034721527), (9, 0.033374447), (17, 0.010565463), (18, 0.45554072)]"
29055,,2022-11-17 15:42:20,2,96,"<p>I am learning quantum chemistry at the moment and I'm trying to understand the Hamiltonian generated by the <a href=""https://www.google.com/search?as_q=openfermion"" rel=""nofollow noreferrer"">OpenFermion</a> package. I'm now stuck at understanding how openfermion calculates the coefficients in second quantization Hamiltonians.</p>
<p>Take the for Hydrogen molecule for example. My understanding is that the coefficients</p>
<blockquote>
<ul>
<li><span class=""math-container"">$h_{00}$</span>, represents electron 1 in 1s orbit with spin up.</li>
<li><span class=""math-container"">$h_{11}$</span>, represents electron 1 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{22}$</span>, represents electron 2 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{33}$</span>, represents electron 2 in 1s orbit with spin down.</li>
</ul>
</blockquote>
<p>As the wavefunction of 1s orbits takes the form</p>
<p><span class=""math-container"">$$\psi_{1s}(r) = \frac{1}{\sqrt{\pi}}e^{-r}$$</span></p>
<p>The <span class=""math-container"">$h_{ii}$</span> should be</p>
<p><span class=""math-container"">\begin{equation}
2\pi \int_0^{\infty}\int_0^{\pi}\psi_{1s}(r)\left(-\frac{1}{2}\nabla^2-\frac{1}{r}-\frac{1}{\sqrt{r^2+R^2-2r R\cos\theta}}\right)\psi_{1s}(r)r^2 \sin\theta d\theta dr
= -1.07123
\end{equation}</span>
when <span class=""math-container"">$R = 0.74$</span> Bohr radius, which does not match with openfermion's
<span class=""math-container"">\begin{align}
h_{00} &amp;= h_{11} = -1.2524635735648988\\
h_{22} &amp;= h_{33} = -0.47594871522096416\\
\end{align}</span></p>
<p>Can anyone tell me why I am wrong?</p>
",Reproducing Hydrogen Molecule Hamiltonian in OpenFermion,<chemistry><openfermion>,0,3,,,"Reproducing Hydrogen Molecule Hamiltonian in OpenFermion <p>I am learning quantum chemistry at the moment and I'm trying to understand the Hamiltonian generated by the <a href=""https://www.google.com/search?as_q=openfermion"" rel=""nofollow noreferrer"">OpenFermion</a> package. I'm now stuck at understanding how openfermion calculates the coefficients in second quantization Hamiltonians.</p>
<p>Take the for Hydrogen molecule for example. My understanding is that the coefficients</p>
<blockquote>
<ul>
<li><span class=""math-container"">$h_{00}$</span>, represents electron 1 in 1s orbit with spin up.</li>
<li><span class=""math-container"">$h_{11}$</span>, represents electron 1 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{22}$</span>, represents electron 2 in 1s orbit with spin down.</li>
<li><span class=""math-container"">$h_{33}$</span>, represents electron 2 in 1s orbit with spin down.</li>
</ul>
</blockquote>
<p>As the wavefunction of 1s orbits takes the form</p>
<p><span class=""math-container"">$$\psi_{1s}(r) = \frac{1}{\sqrt{\pi}}e^{-r}$$</span></p>
<p>The <span class=""math-container"">$h_{ii}$</span> should be</p>
<p><span class=""math-container"">\begin{equation}
2\pi \int_0^{\infty}\int_0^{\pi}\psi_{1s}(r)\left(-\frac{1}{2}\nabla^2-\frac{1}{r}-\frac{1}{\sqrt{r^2+R^2-2r R\cos\theta}}\right)\psi_{1s}(r)r^2 \sin\theta d\theta dr
= -1.07123
\end{equation}</span>
when <span class=""math-container"">$R = 0.74$</span> Bohr radius, which does not match with openfermion's
<span class=""math-container"">\begin{align}
h_{00} &amp;= h_{11} = -1.2524635735648988\\
h_{22} &amp;= h_{33} = -0.47594871522096416\\
\end{align}</span></p>
<p>Can anyone tell me why I am wrong?</p>
",qc,reproducing hydrogen molecule hamiltonian openfermion p learning quantum chemistry moment trying understand hamiltonian generated https nofollow noreferrer openfermion package stuck understanding openfermion calculates coefficients second quantization p take hydrogen molecule example understanding coefficients blockquote ul li span 00 represents electron 1 1s orbit spin li span 11 represents electron 1 1s orbit spin li span 22 represents electron 2 1s orbit spin li span 33 represents electron 2 1s orbit spin p wavefunction 1s orbits takes form p span 1s r 1 p span ii p span equation 1s r 1 2 1 r 1 1s r dr equation span r bohr radius match openfermion span align 00 amp 11 22 amp 33 align p anyone tell wrong,"[(1, 0.039787408), (2, 0.125357), (3, 0.37252584), (4, 0.05850182), (6, 0.03307925), (7, 0.1542187), (8, 0.107961245), (12, 0.017579742), (15, 0.07197446), (17, 0.01815252)]"
29048,,2022-11-18 16:09:45,1,92,"<p>How to transform the U3 gate of parameters (theta, phi, lambda) to an Operator. (in qiskit)
The following code don't work</p>
<pre><code>theta = Parameter('theta')
phi   = Parameter('phi')
lamb  = Parameter('lam')

UO=Operator(UGate(theta,phi,lamb))
</code></pre>
",How to create Parametrized Operator,<qiskit><quantum-gate><ibm-q-experience><quantum-operation><quantum-circuit>,1,0,,,"How to create Parametrized Operator <p>How to transform the U3 gate of parameters (theta, phi, lambda) to an Operator. (in qiskit)
The following code don't work</p>
<pre><code>theta = Parameter('theta')
phi   = Parameter('phi')
lamb  = Parameter('lam')

UO=Operator(UGate(theta,phi,lamb))
</code></pre>
",qc,create parametrized operator p transform u3 gate parameters theta phi lambda operator qiskit following code work pre code theta parameter phi parameter lamb parameter ugate theta phi lamb,"[(0, 0.95241773), (17, 0.040438242)]"
29056,,2022-11-18 21:37:40,6,245,"<p>In QECC literature, I often come across the &quot;combined amplitude and phase damping channel&quot; as being representative of a realistic noise model which makes sense (as amplitude damping and de-phasing are the two fundamental error processes for a coherent single-qubit state). It is often twirled to make it simulatable efficiently and thereby turn it into Pauli channel, where the coefficients are related back to the decoherence times (T1 and T2).</p>
<p>My question however is not about the twirling but the starting point where the &quot;combined amplitude and phase damping channel&quot; is assumed to be representative of the circuit noise.</p>
<p>How can this be a sufficient description when noisy gates are in operation? Said differently, how can a noise model focused on single qubits be sufficient when entangling gates are noisy?</p>
<p>If it is indeed the case that the combined amplitude and phase damping channel is not sufficient for modeling errors, how can I model it better (such as the impact of noisy CNOT gates)?</p>
",Why is combined amplitude and phase damping considered sufficient for noise modeling?,<error-correction><quantum-operation>,0,0,,,"Why is combined amplitude and phase damping considered sufficient for noise modeling? <p>In QECC literature, I often come across the &quot;combined amplitude and phase damping channel&quot; as being representative of a realistic noise model which makes sense (as amplitude damping and de-phasing are the two fundamental error processes for a coherent single-qubit state). It is often twirled to make it simulatable efficiently and thereby turn it into Pauli channel, where the coefficients are related back to the decoherence times (T1 and T2).</p>
<p>My question however is not about the twirling but the starting point where the &quot;combined amplitude and phase damping channel&quot; is assumed to be representative of the circuit noise.</p>
<p>How can this be a sufficient description when noisy gates are in operation? Said differently, how can a noise model focused on single qubits be sufficient when entangling gates are noisy?</p>
<p>If it is indeed the case that the combined amplitude and phase damping channel is not sufficient for modeling errors, how can I model it better (such as the impact of noisy CNOT gates)?</p>
",qc,combined amplitude phase damping considered sufficient noise modeling p qecc literature often come across quot combined amplitude phase damping channel quot representative realistic noise model makes sense amplitude damping two fundamental error processes coherent state often twirled make simulatable efficiently thereby turn pauli channel coefficients related back decoherence times t1 t2 p question however twirling starting point quot combined amplitude phase damping channel quot assumed representative circuit p sufficient description noisy gates operation said differently noise model focused single qubits sufficient entangling gates noisy p indeed case combined amplitude phase damping channel sufficient modeling errors model better impact noisy cnot gates,"[(1, 0.029129747), (4, 0.013861618), (5, 0.15039688), (8, 0.08821198), (9, 0.2887868), (14, 0.08035074), (17, 0.08952843), (18, 0.19375947), (19, 0.06488622)]"
29062,,2022-11-19 10:05:29,1,46,"<p>I am aware that there are algorithms that can clone states with unit fidelity but with a positive probability of failure. What would be the best known algorithms to create a perfect clone of an arbitrary unknown single qubit state with minimum probability of failure?</p>
",What are the best algorithms to achieve probabilistic quantum cloning?,<no-cloning-theorem><cloning>,0,1,,,"What are the best algorithms to achieve probabilistic quantum cloning? <p>I am aware that there are algorithms that can clone states with unit fidelity but with a positive probability of failure. What would be the best known algorithms to create a perfect clone of an arbitrary unknown single qubit state with minimum probability of failure?</p>
",qc,best algorithms achieve probabilistic quantum cloning p aware algorithms clone states unit fidelity positive probability failure would best known algorithms create perfect clone arbitrary unknown single qubit state minimum probability failure,"[(5, 0.14462636), (8, 0.31497693), (11, 0.060759567), (16, 0.028037319), (17, 0.118338436), (18, 0.32877308)]"
29069,29086.0,2022-11-20 11:12:02,5,166,"<p>Let's assume I have some quantum program I tested and tuned on a simulator and that now I want to see how it actually performs on real quantum hardware. I test it on IBM Superconducting devices and then I want to move to a different vendor offering a different technology, say trapped ions available on Microsoft Azure or Amazon Braket.</p>
<p>Does it make sense to make a comparison ? What differences should I pay attention to ? What should be the purpose of this experiment ?</p>
",Does it make sense to compare different quantum computer technologies?,<experimental-realization>,1,0,,,"Does it make sense to compare different quantum computer technologies? <p>Let's assume I have some quantum program I tested and tuned on a simulator and that now I want to see how it actually performs on real quantum hardware. I test it on IBM Superconducting devices and then I want to move to a different vendor offering a different technology, say trapped ions available on Microsoft Azure or Amazon Braket.</p>
<p>Does it make sense to make a comparison ? What differences should I pay attention to ? What should be the purpose of this experiment ?</p>
",qc,make sense compare different quantum computer technologies p let assume quantum program tested tuned simulator want see actually performs real quantum hardware test ibm superconducting devices want move different vendor offering different technology say trapped ions available microsoft azure amazon p make sense make comparison differences pay attention purpose experiment,"[(2, 0.015327323), (4, 0.057506636), (8, 0.6056974), (14, 0.2327942), (17, 0.049182888), (18, 0.036626168)]"
29143,,2022-11-26 10:23:10,1,82,"<p>The [[3,0,2]] code, stabilizers are X<sub>1</sub>Z<sub>2</sub>I<sub>3</sub>,Z<sub>1</sub>X<sub>2</sub>Z<sub>3</sub>,I<sub>1</sub>Z<sub>2</sub>X<sub>3</sub>.
Use the circuit to decode and measure stabilizers:
<a href=""https://i.sstatic.net/VFrJH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VFrJH.png"" alt=""enter image description here"" /></a></p>
<p>As for amplitude damping error syndrome,  use <span class=""math-container"">$\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \sqrt{1-\gamma}\end{array}\right], \quad\left[\begin{array}{cc}0 &amp; \sqrt{\gamma} \\ 0 &amp; 0\end{array}\right], \gamma=1$</span></p>
<p><span class=""math-container"">$\rho \prime=E_0 \rho E_0^{\dagger}+E_1 \rho E_1^{\dagger}$</span>, <span class=""math-container"">$
\langle S\rangle_\rho=\operatorname{Tr}(\rho S)
$</span> to compute.</p>
<p>The result is :
<span class=""math-container"">$$
\begin{array}{c|c|c|c}
 &amp; \mathrm{X}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{I}_{\mathrm{c}} &amp; \mathrm{Z}_{\mathrm{a}} \mathrm{X}_{\mathrm{b}} \mathrm{Z}_{\mathrm{c}} &amp; \mathrm{I}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{X}_{\mathrm{c}} \\
\hline ap_{a} &amp; 0 &amp; 0 &amp; +1 \\
\hline ap_{b} &amp; 0 &amp; 0 &amp; 0 \\
\hline ap_{c} &amp; +1 &amp; 0 &amp; 0\\
\end{array}
$$</span></p>
<p>Then simulate the circuit in qiskit.
Add  amplitude damping error to one of the three qubit, get the result:</p>
<p>Add  amplitude damping error to q0(a):</p>
<p><a href=""https://i.sstatic.net/yOHqa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yOHqa.png"" alt=""enter image description here"" /></a> which is the same as error syndrome.(The stabilizer order is from top to bottom)</p>
<p>But for q1(b):</p>
<p><a href=""https://i.sstatic.net/hRQ1g.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hRQ1g.png"" alt=""enter image description here"" /></a>
The result is +1  0  0  , but the syndrome is 0  0  0.</p>
<p>For q2(c):</p>
<p><a href=""https://i.sstatic.net/hmQs7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hmQs7.png"" alt=""enter image description here"" /></a>
The result is +1  +1  0  , but the syndrome is +1  0  0.</p>
<p>Why the results don't correspond ?
And where my mistake was in the process?</p>
<pre><code>#add identity gates to qubit and add amplitude damping error
p = 1
amplitude_error = amplitude_damping_error(p)
noise_model = NoiseModel()
noise_model.add_quantum_error(amplitude_error, ['id'], [2])

simulator = provider.get_backend('ibmq_qasm_simulator')
noise_job = execute(circuit, backend=simulator, shots=8192, optimization_level = 0, noise_model=noise_model)
result = noise_job.result()  
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
",Why QECC amplitude damping error syndrome and qiskit simulation are different?,<qiskit><error-correction><stabilizer-code>,0,4,,,"Why QECC amplitude damping error syndrome and qiskit simulation are different? <p>The [[3,0,2]] code, stabilizers are X<sub>1</sub>Z<sub>2</sub>I<sub>3</sub>,Z<sub>1</sub>X<sub>2</sub>Z<sub>3</sub>,I<sub>1</sub>Z<sub>2</sub>X<sub>3</sub>.
Use the circuit to decode and measure stabilizers:
<a href=""https://i.sstatic.net/VFrJH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VFrJH.png"" alt=""enter image description here"" /></a></p>
<p>As for amplitude damping error syndrome,  use <span class=""math-container"">$\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \sqrt{1-\gamma}\end{array}\right], \quad\left[\begin{array}{cc}0 &amp; \sqrt{\gamma} \\ 0 &amp; 0\end{array}\right], \gamma=1$</span></p>
<p><span class=""math-container"">$\rho \prime=E_0 \rho E_0^{\dagger}+E_1 \rho E_1^{\dagger}$</span>, <span class=""math-container"">$
\langle S\rangle_\rho=\operatorname{Tr}(\rho S)
$</span> to compute.</p>
<p>The result is :
<span class=""math-container"">$$
\begin{array}{c|c|c|c}
 &amp; \mathrm{X}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{I}_{\mathrm{c}} &amp; \mathrm{Z}_{\mathrm{a}} \mathrm{X}_{\mathrm{b}} \mathrm{Z}_{\mathrm{c}} &amp; \mathrm{I}_{\mathrm{a}} \mathrm{Z}_{\mathrm{b}} \mathrm{X}_{\mathrm{c}} \\
\hline ap_{a} &amp; 0 &amp; 0 &amp; +1 \\
\hline ap_{b} &amp; 0 &amp; 0 &amp; 0 \\
\hline ap_{c} &amp; +1 &amp; 0 &amp; 0\\
\end{array}
$$</span></p>
<p>Then simulate the circuit in qiskit.
Add  amplitude damping error to one of the three qubit, get the result:</p>
<p>Add  amplitude damping error to q0(a):</p>
<p><a href=""https://i.sstatic.net/yOHqa.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/yOHqa.png"" alt=""enter image description here"" /></a> which is the same as error syndrome.(The stabilizer order is from top to bottom)</p>
<p>But for q1(b):</p>
<p><a href=""https://i.sstatic.net/hRQ1g.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hRQ1g.png"" alt=""enter image description here"" /></a>
The result is +1  0  0  , but the syndrome is 0  0  0.</p>
<p>For q2(c):</p>
<p><a href=""https://i.sstatic.net/hmQs7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hmQs7.png"" alt=""enter image description here"" /></a>
The result is +1  +1  0  , but the syndrome is +1  0  0.</p>
<p>Why the results don't correspond ?
And where my mistake was in the process?</p>
<pre><code>#add identity gates to qubit and add amplitude damping error
p = 1
amplitude_error = amplitude_damping_error(p)
noise_model = NoiseModel()
noise_model.add_quantum_error(amplitude_error, ['id'], [2])

simulator = provider.get_backend('ibmq_qasm_simulator')
noise_job = execute(circuit, backend=simulator, shots=8192, optimization_level = 0, noise_model=noise_model)
result = noise_job.result()  
counts = result.get_counts()
plot_histogram(counts)
</code></pre>
",qc,qecc amplitude damping error syndrome qiskit simulation different p code stabilizers x sub 1 z sub 2 sub 3 z sub 1 x sub 2 z sub 3 sub 1 z sub 2 x sub 3 use circuit decode measure stabilizers https nofollow noreferrer img https enter image description p amplitude damping error syndrome use span array cc 1 amp 0 0 amp array array cc 0 amp 0 amp array p span span tr p result span array amp x z b c amp z x b z c amp z b x c amp 0 amp 0 amp b amp 0 amp 0 amp 0 c amp amp 0 amp array p simulate circuit qiskit add amplitude damping error one three qubit get result p add amplitude damping error q0 p https nofollow noreferrer img https enter image description error syndrome stabilizer order top bottom p q1 b p https nofollow noreferrer img https enter image description result 0 0 syndrome 0 0 p q2 c p https nofollow noreferrer img https enter image description result 0 syndrome 0 p results correspond mistake process pre code add identity gates qubit add amplitude damping error p 1 p noisemodel 2 simulator execute circuit 0 result counts counts,"[(0, 0.027373608), (2, 0.15444854), (4, 0.2664075), (5, 0.122683465), (10, 0.030890087), (14, 0.043529674), (15, 0.33074528), (16, 0.010406227), (17, 0.012987235)]"
29175,,2022-11-29 08:56:30,1,104,"<p>I am implementing QEC cycles for CSS codes and using PyMatching for decoding. Since I can quickly obtain the parity-check matrix, PyMatching is convenient. However, when I try to use it for CSS codes where you have more than two non-zero elements per column in the parity-check matrix, which corresponds to having more than two stabilizers per qubit, it gives an error. My current solution is to erase some elements in each column to have, at maximum, two stabilizers per qubit. This is non-optimum (in principle, one could use the additional information per qubit to improve the decoder), and I would like to know what else I can do.</p>
",Using PyMatching for CSS code with more than two Stabilizers per qubit,<error-correction><stabilizer-code><stim><pymatching>,1,0,,,"Using PyMatching for CSS code with more than two Stabilizers per qubit <p>I am implementing QEC cycles for CSS codes and using PyMatching for decoding. Since I can quickly obtain the parity-check matrix, PyMatching is convenient. However, when I try to use it for CSS codes where you have more than two non-zero elements per column in the parity-check matrix, which corresponds to having more than two stabilizers per qubit, it gives an error. My current solution is to erase some elements in each column to have, at maximum, two stabilizers per qubit. This is non-optimum (in principle, one could use the additional information per qubit to improve the decoder), and I would like to know what else I can do.</p>
",qc,using pymatching css code two stabilizers per qubit p implementing qec cycles css codes using pymatching decoding since quickly obtain matrix pymatching convenient however try use css codes two elements per column matrix corresponds two stabilizers per qubit gives error current solution erase elements column maximum two stabilizers per qubit principle one could use additional information per qubit improve decoder would like know else,"[(5, 0.310663), (8, 0.33983043), (11, 0.032945015), (13, 0.0957079), (17, 0.054888144), (18, 0.16374953)]"
29199,,2022-12-01 13:57:04,4,187,"<p>Suppose, you have two parts of a circuit in Qiskit, <code>qc1</code> and <code>qc2</code> on any number of qubits such that the entire circuit is given by</p>
<pre><code>qc = qc1.compose(qc2)
</code></pre>
<p>For sake of concreteness, here is an example on 2 qubits:</p>
<pre><code>qc1 = QuantumCircuit(2)
qc2 = QuantumCircuit(2)

qc1.h([0,1])
qc2.x(0)
</code></pre>
<p>I want to apply a single-qubit channel on the first qubit, say a depolarizing one, in between <code>qc1</code> and <code>qc2</code> and then simulate the whole circuit using qiskit. That is, after <code>qc1</code> and before <code>qc2</code>. After having looked at the Qiskit Aer <code>noise</code> module, my idea would be to introduce a noisy version of an identity gate between the two circuits <code>qc1</code> and <code>qc2</code>. How to do this?</p>
",Apply a single-qubit channel between in between two circuits in Qiskit,<qiskit><simulation><noise>,0,8,,,"Apply a single-qubit channel between in between two circuits in Qiskit <p>Suppose, you have two parts of a circuit in Qiskit, <code>qc1</code> and <code>qc2</code> on any number of qubits such that the entire circuit is given by</p>
<pre><code>qc = qc1.compose(qc2)
</code></pre>
<p>For sake of concreteness, here is an example on 2 qubits:</p>
<pre><code>qc1 = QuantumCircuit(2)
qc2 = QuantumCircuit(2)

qc1.h([0,1])
qc2.x(0)
</code></pre>
<p>I want to apply a single-qubit channel on the first qubit, say a depolarizing one, in between <code>qc1</code> and <code>qc2</code> and then simulate the whole circuit using qiskit. That is, after <code>qc1</code> and before <code>qc2</code>. After having looked at the Qiskit Aer <code>noise</code> module, my idea would be to introduce a noisy version of an identity gate between the two circuits <code>qc1</code> and <code>qc2</code>. How to do this?</p>
",qc,apply channel two circuits qiskit p suppose two parts circuit qiskit code qc1 code qc2 number qubits entire circuit given pre code qc qc2 p sake concreteness example 2 qubits pre code qc1 quantumcircuit 2 qc2 quantumcircuit 2 0 p want apply channel first qubit say depolarizing one code qc1 code qc2 simulate whole circuit using qiskit code qc1 code qc2 looked qiskit aer code noise module idea would introduce noisy version identity gate two circuits code qc1 code qc2,"[(0, 0.08721173), (2, 0.22016092), (14, 0.5789814), (17, 0.028187048), (18, 0.08356441)]"
29202,,2022-12-01 16:41:28,8,291,"<p>A recently published <a href=""https://www.nature.com/articles/s41586-022-05424-3"" rel=""nofollow noreferrer"">Nature paper</a> of Jafferis <em>et al.</em> describes an experiment with a handful of qubits performed on Google's Sycamore processor to explore the <a href=""https://en.wikipedia.org/wiki/Sachdev%E2%80%93Ye%E2%80%93Kitaev_model"" rel=""nofollow noreferrer"">SYK model</a> in the context of AdS/CFT and quantum gravity, and states that the experiment &quot;represents a step towards a program for studying quantum gravity in the laboratory&quot;.</p>
<p>The figures in the Nature article appear to present a high-level summary of the experiment but not at the level of gates acting on the particular topology of Sycamore.  Figure 1c of Jafferis <em>et al.</em> appears to provide a standard wormhole-inspired teleportation circuit diagram, with time advancing upwards.</p>
<hr />
<p>Figure 1 in an earlier counterpart <a href=""https://arxiv.org/abs/2205.14081"" rel=""nofollow noreferrer"">paper</a> of Shapoval <em>et al.</em>, as below, also provides a high-level summary of a wormhole-inspired teleportation protocol - this appears to be almost the same as in Figure 1c of Jafferis <em>et al.</em> with time advancing to the right.</p>
<p><a href=""https://i.sstatic.net/dbL2M.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dbL2M.png"" alt=""Figure 1 of Shapoval et al."" /></a></p>
<p>In step 0, the Left and Right qubits are created as Bell pairs and correspond to the mouths of a wormhole.  In step 1, the Left black hole scrambles and evolves backwards in time until the target qubit <span class=""math-container"">$|\psi\rangle$</span> is introduced in step 2 while then evolving forward in time in step 3; in step 4 the wormhole gets injected with a negative-energy Hamiltonian <span class=""math-container"">$V$</span>; while in step 5, by time-evolving the Right black hole the qubit <span class=""math-container"">$|\psi\rangle$</span> is teleported.</p>
<p>Additionally, Figure 4 in Shapoval <em>et al.</em> gets into the weeds of individual gates, and how they might be implemented on IBM's transmon devices and/or Quantinuum's trapped ion devices.</p>
<hr />
<p>We know that the native 2-qubit gates used in earlier Sycamore experiments are related to <strong>iSWAP</strong> gates.  The Jafferis <em>et al.</em> experiment reportedly was done on a 72-qubit version of Sycamore but only uses nine of these qubits and apparently involves several hundred 1- and 2-qubit gates.</p>
<blockquote>
<p>What was the particular circuit used in this experiment, preferably at the level provided by the other <a href=""https://quantumcomputing.stackexchange.com/questions/8342/understanding-googles-quantum-supremacy-using-a-programmable-superconducting-p"">Sycamore experiments</a> or at the level of Shapoval <em>et al.</em>'s proposal?</p>
</blockquote>
<p>For example, were the other qubits on Sycamore <strong>Id</strong>ling, or were they doing any other supportive ancillary work (such as <strong>SWAP</strong>ping info and out)? Did the circuit use these <strong>iSWAP</strong> gates, or something more subtle?  How deep was the circuit?  Apparently an important aspect of the experiment involved classical machine-learning to simplify and sparsify the Hamiltonian - did this machine learning characterize other qubits not used in the circuit, to know which ones not to use?</p>
",What is a gate-level circuit used in the 2022 Jafferis et al. experiment on Sycamore?,<quantum-circuit><experimental-realization><google-sycamore>,0,6,,,"What is a gate-level circuit used in the 2022 Jafferis et al. experiment on Sycamore? <p>A recently published <a href=""https://www.nature.com/articles/s41586-022-05424-3"" rel=""nofollow noreferrer"">Nature paper</a> of Jafferis <em>et al.</em> describes an experiment with a handful of qubits performed on Google's Sycamore processor to explore the <a href=""https://en.wikipedia.org/wiki/Sachdev%E2%80%93Ye%E2%80%93Kitaev_model"" rel=""nofollow noreferrer"">SYK model</a> in the context of AdS/CFT and quantum gravity, and states that the experiment &quot;represents a step towards a program for studying quantum gravity in the laboratory&quot;.</p>
<p>The figures in the Nature article appear to present a high-level summary of the experiment but not at the level of gates acting on the particular topology of Sycamore.  Figure 1c of Jafferis <em>et al.</em> appears to provide a standard wormhole-inspired teleportation circuit diagram, with time advancing upwards.</p>
<hr />
<p>Figure 1 in an earlier counterpart <a href=""https://arxiv.org/abs/2205.14081"" rel=""nofollow noreferrer"">paper</a> of Shapoval <em>et al.</em>, as below, also provides a high-level summary of a wormhole-inspired teleportation protocol - this appears to be almost the same as in Figure 1c of Jafferis <em>et al.</em> with time advancing to the right.</p>
<p><a href=""https://i.sstatic.net/dbL2M.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/dbL2M.png"" alt=""Figure 1 of Shapoval et al."" /></a></p>
<p>In step 0, the Left and Right qubits are created as Bell pairs and correspond to the mouths of a wormhole.  In step 1, the Left black hole scrambles and evolves backwards in time until the target qubit <span class=""math-container"">$|\psi\rangle$</span> is introduced in step 2 while then evolving forward in time in step 3; in step 4 the wormhole gets injected with a negative-energy Hamiltonian <span class=""math-container"">$V$</span>; while in step 5, by time-evolving the Right black hole the qubit <span class=""math-container"">$|\psi\rangle$</span> is teleported.</p>
<p>Additionally, Figure 4 in Shapoval <em>et al.</em> gets into the weeds of individual gates, and how they might be implemented on IBM's transmon devices and/or Quantinuum's trapped ion devices.</p>
<hr />
<p>We know that the native 2-qubit gates used in earlier Sycamore experiments are related to <strong>iSWAP</strong> gates.  The Jafferis <em>et al.</em> experiment reportedly was done on a 72-qubit version of Sycamore but only uses nine of these qubits and apparently involves several hundred 1- and 2-qubit gates.</p>
<blockquote>
<p>What was the particular circuit used in this experiment, preferably at the level provided by the other <a href=""https://quantumcomputing.stackexchange.com/questions/8342/understanding-googles-quantum-supremacy-using-a-programmable-superconducting-p"">Sycamore experiments</a> or at the level of Shapoval <em>et al.</em>'s proposal?</p>
</blockquote>
<p>For example, were the other qubits on Sycamore <strong>Id</strong>ling, or were they doing any other supportive ancillary work (such as <strong>SWAP</strong>ping info and out)? Did the circuit use these <strong>iSWAP</strong> gates, or something more subtle?  How deep was the circuit?  Apparently an important aspect of the experiment involved classical machine-learning to simplify and sparsify the Hamiltonian - did this machine learning characterize other qubits not used in the circuit, to know which ones not to use?</p>
",qc,circuit used 2022 jafferis et al experiment sycamore p recently published https nofollow noreferrer nature paper jafferis em et describes experiment handful qubits performed google sycamore processor explore https e2 80 93ye e2 80 nofollow noreferrer syk model context quantum gravity states experiment quot represents step towards program studying quantum gravity laboratory quot p figures nature article appear present summary experiment level gates acting particular topology sycamore figure 1c jafferis em et appears provide standard teleportation circuit diagram time advancing hr p figure 1 earlier counterpart https nofollow noreferrer paper shapoval em et also provides summary teleportation protocol appears almost figure 1c jafferis em et time advancing p https nofollow noreferrer img https figure 1 shapoval et al p step 0 left right qubits created bell pairs correspond mouths wormhole step 1 left black hole scrambles evolves backwards time target qubit span introduced step 2 evolving forward time step 3 step 4 wormhole gets injected hamiltonian span v step 5 right black hole qubit span p additionally figure 4 shapoval em et gets weeds individual gates might implemented ibm transmon devices quantinuum trapped ion hr p know native gates used earlier sycamore experiments related strong iswap gates jafferis em et experiment reportedly done version sycamore uses nine qubits apparently involves several hundred blockquote p particular circuit used experiment preferably level provided https sycamore experiments level shapoval em et proposal p example qubits sycamore strong id ling supportive ancillary work strong swap ping info circuit use strong iswap gates something subtle deep circuit apparently important aspect experiment involved classical simplify sparsify hamiltonian machine learning characterize qubits used circuit know ones use,"[(1, 0.030913087), (2, 0.02128202), (3, 0.016824871), (4, 0.19150683), (8, 0.13831843), (9, 0.34199303), (10, 0.013139188), (12, 0.01697972), (13, 0.09809886), (14, 0.03483244), (17, 0.011080738), (18, 0.07467872), (19, 0.0100625735)]"
29230,,2022-12-04 05:48:40,1,224,"<p>I am getting Type error of invalid parameter in base sampler module. From what I know sampler is constructor and doesn't take any parameter values, on the qisit.org tutorial of svm they have even said it gets constructed by default.
here is my code :</p>
<pre><code>import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from qiskit import Aer
from qiskit.circuit.library import ZZFeatureMap
from qiskit_machine_learning.kernels import FidelityQuantumKernel
from qiskit.algorithms.state_fidelities import ComputeUncompute
from qiskit.primitives import Sampler
from qiskit.utils import QuantumInstance
from qiskit_machine_learning.algorithms import QSVC

data=pd.read_csv('train.csv')
X = data.loc[1:1000,[&quot;marital&quot;,&quot;balance&quot;,&quot;loan&quot;]].values
Y = data.iloc[:1000,-1].values
for i in range(0,1000):
    if Y[i]=='yes':
       Y[i]='1'
    else:
        Y[i]='0'

x_train, x_test, y_train, y_test = train_test_split(X, Y)
data_feature_map = ZZFeatureMap(feature_dimension=3, reps=2,entanglement='linear' )
sampler = Sampler()
fidelity = ComputeUncompute(sampler=sampler)
data_kernel = FidelityQuantumKernel(feature_map=data_feature_map,fidelity=fidelity)
qsvc = QSVC(quantum_kernel=data_kernel)
qsvc.fit(x_train, y_train)
qsvc_score = QSVC.score(x_test, y_test)



print(f&quot;Callable kernel classification test score: {qsvc_score}&quot;)
</code></pre>
<p>and here is my error :</p>
<pre><code>      File &quot;C:\Users\Dell\Desktop\SEM Project\qsvm.py&quot;, line 30, in &lt;module&gt;
    qsvc.fit(x_train, y_train)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 251, in fit
    fit(X, y, sample_weight, solver_type, kernel, random_seed=seed)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 314, in _dense_fit
    X = self._compute_kernel(X)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 512, in _compute_kernel
    kernel = self.kernel(X, self.__Xfit)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 121, in evaluate
    kernel_matrix = self._get_symmetric_kernel_matrix(
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 212, in _get_symmetric_kernel_matrix       
    kernel_entries = self._get_kernel_entries(left_parameters, right_parameters)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 234, in _get_kernel_entries
    kernel_entries = np.real(job.result().fidelities)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\primitive_job.py&quot;, line 50, in result
    return self._future.result()
  File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\thread.py&quot;, line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py&quot;, line 141, in _run
    job = self._sampler.run(circuits=circuits, parameter_values=values, **opts.__dict__)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\base\base_sampler.py&quot;, line 172, in run
    parameter_values = self._validate_parameter_values(
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\base\base_primitive.py&quot;, line 108, in _validate_parameter_values
    raise TypeError(&quot;Invalid parameter values, expected Sequence[Sequence[float]].&quot;)
TypeError: Invalid parameter values, expected Sequence[Sequence[float]].
</code></pre>
",Error in Implementing Quantum SVM,<qiskit><programming><machine-learning>,0,3,,,"Error in Implementing Quantum SVM <p>I am getting Type error of invalid parameter in base sampler module. From what I know sampler is constructor and doesn't take any parameter values, on the qisit.org tutorial of svm they have even said it gets constructed by default.
here is my code :</p>
<pre><code>import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from qiskit import Aer
from qiskit.circuit.library import ZZFeatureMap
from qiskit_machine_learning.kernels import FidelityQuantumKernel
from qiskit.algorithms.state_fidelities import ComputeUncompute
from qiskit.primitives import Sampler
from qiskit.utils import QuantumInstance
from qiskit_machine_learning.algorithms import QSVC

data=pd.read_csv('train.csv')
X = data.loc[1:1000,[&quot;marital&quot;,&quot;balance&quot;,&quot;loan&quot;]].values
Y = data.iloc[:1000,-1].values
for i in range(0,1000):
    if Y[i]=='yes':
       Y[i]='1'
    else:
        Y[i]='0'

x_train, x_test, y_train, y_test = train_test_split(X, Y)
data_feature_map = ZZFeatureMap(feature_dimension=3, reps=2,entanglement='linear' )
sampler = Sampler()
fidelity = ComputeUncompute(sampler=sampler)
data_kernel = FidelityQuantumKernel(feature_map=data_feature_map,fidelity=fidelity)
qsvc = QSVC(quantum_kernel=data_kernel)
qsvc.fit(x_train, y_train)
qsvc_score = QSVC.score(x_test, y_test)



print(f&quot;Callable kernel classification test score: {qsvc_score}&quot;)
</code></pre>
<p>and here is my error :</p>
<pre><code>      File &quot;C:\Users\Dell\Desktop\SEM Project\qsvm.py&quot;, line 30, in &lt;module&gt;
    qsvc.fit(x_train, y_train)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 251, in fit
    fit(X, y, sample_weight, solver_type, kernel, random_seed=seed)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 314, in _dense_fit
    X = self._compute_kernel(X)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\sklearn\svm\_base.py&quot;, line 512, in _compute_kernel
    kernel = self.kernel(X, self.__Xfit)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 121, in evaluate
    kernel_matrix = self._get_symmetric_kernel_matrix(
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 212, in _get_symmetric_kernel_matrix       
    kernel_entries = self._get_kernel_entries(left_parameters, right_parameters)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit_machine_learning\kernels\fidelity_quantum_kernel.py&quot;, line 234, in _get_kernel_entries
    kernel_entries = np.real(job.result().fidelities)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\primitive_job.py&quot;, line 50, in result
    return self._future.result()
  File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;C:\Users\Dell\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\thread.py&quot;, line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\algorithms\state_fidelities\compute_uncompute.py&quot;, line 141, in _run
    job = self._sampler.run(circuits=circuits, parameter_values=values, **opts.__dict__)
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\base\base_sampler.py&quot;, line 172, in run
    parameter_values = self._validate_parameter_values(
  File &quot;C:\Users\Dell\Desktop\SEM Project\venv\lib\site-packages\qiskit\primitives\base\base_primitive.py&quot;, line 108, in _validate_parameter_values
    raise TypeError(&quot;Invalid parameter values, expected Sequence[Sequence[float]].&quot;)
TypeError: Invalid parameter values, expected Sequence[Sequence[float]].
</code></pre>
",qc,error implementing quantum svm p getting type error invalid parameter base sampler module know sampler constructor take parameter values tutorial svm even said gets constructed default code pre code import pandas pd import plt import numpy np import svc import qiskit import aer import zzfeaturemap import fidelityquantumkernel import computeuncompute import sampler import quantuminstance import qsvc x quot marital quot quot balance quot quot loan quot range 1 else 0 x zzfeaturemap sampler sampler fidelity computeuncompute fidelityquantumkernel qsvc qsvc print f quot callable kernel classification test score quot p error pre code file quot c quot line 30 lt module gt file quot c quot line 251 fit fit x kernel file quot c quot line 314 x x file quot c quot line 512 kernel x file quot c quot line 121 evaluate file quot c quot line 212 file quot c quot line 234 file quot c quot line 50 result return file quot c quot line 439 result return file quot c quot line 391 raise file quot c quot line 58 run result file quot c quot line 141 job file quot c quot line 172 run file quot c quot line 108 raise typeerror quot invalid parameter values expected sequence sequence float quot typeerror invalid parameter values expected sequence sequence float,"[(0, 0.34550756), (10, 0.033139315), (14, 0.15550849), (17, 0.024460755), (19, 0.4328569)]"
29255,,2022-12-05 19:20:55,1,151,"<p>I have created a noise model which uses depolarizing error and I add it using the add to all qubits quantum error command. I also use readout error and add that using the add to all qubits readoute error command.</p>
<p>When I've tested this noisemodel on a simple circuit I can successfully vary the amount of noise the circuit receives, however when I try to add it in to my VQE code which is the code from the QisKit textbook, when I increase the parameters there isn't a noticeable change.</p>
<p>I was thinking this is because the VQE algorithm is already quite good at handling noise, however when I am increasing these parameters by a power of 10 there should be some sort of change.</p>
<p>Any insight would be greatly appreciated.</p>
<p>Here is my code for my simple example:</p>
<pre><code>from qiskit import QuantumCircuit, execute
from qiskit import IBMQ, Aer
from qiskit.visualization import plot_histogram
from qiskit_aer.noise import NoiseModel

# Build noise model from backend properties
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_quito')
noise_model = NoiseModel.from_backend(backend)

# Get coupling map from backend
coupling_map = backend.configuration().coupling_map

# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 coupling_map=coupling_map,
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>The reuslts from this are below
<a href=""https://i.sstatic.net/E6QkZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/E6QkZ.png"" alt=""The results from this example"" /></a></p>
<p>I then created by own noisemodel with the following</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
import qiskit_aer.noise as noise
from qiskit.providers.aer.noise import QuantumError, ReadoutError

# Error probabilities
prob_1 = 0.02  # 1-qubit gate
prob_2 = 0.2  # 2-qubit gate

# Depolarizing quantum errors
error_1 = noise.depolarizing_error(prob_1, 1)
error_2 = noise.depolarizing_error(prob_2, 2)

# Readout quantum errors
p0given1 = 0.1
p1given0 = 0.05

ReadoutError = ReadoutError([[1 - p1given0, p1given0], [p0given1, 1 - p0given1]])

# Add errors to noise model
noise_model = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model.add_all_qubit_readout_error(ReadoutError)
print(noise_model)
# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>And I get the following:</p>
<p><a href=""https://i.sstatic.net/jRfhK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jRfhK.png"" alt=""Own noise model results"" /></a></p>
<p>I can then change my parameters: prob_1, prob_2, p0given1 and p1given0
Increasing these increases my noise, decreasing these decreases my noise. This is what I wanted to achieve of having controllable noise. Then when I take this code over to my VQE code I add them to a noise model through the following:</p>
<pre><code>noise_model1 = noise.NoiseModel()
noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model1.add_all_qubit_readout_error(readout_error)
sim_noise = AerSimulator(noise_model=noise_model1)
qi = QuantumInstance(sim_noise,
                    noise_model=noise_model1)
</code></pre>
<p>This then gives me the quantum instance which I can use in my VQE code. However all of my results are very similar even if I'm changing my probabilities massively. Even when I put the probabilities to almost no error it still acts as if I have set the probabilities to a very high error.</p>
<p>Below is my entire VQE code:
Note: I am aware that I could nest my parameters increasing in size into a loop instead of using if statements, I've just done it this way to help me visualize.</p>
<p>I also have 3 parameters p_reset,p_meas and p_gate1 which I used when testing a different type of &quot;quantum_error&quot; which also didn't help improving my results so these can be ignored. They aren't applied to the noisemodel.</p>
<p>I also have tried with 'qasm_simulator' and AerSimulator, both give the same result and don't really change with changes in these parameters.</p>
<pre><code>from qiskit.algorithms import VQE
from qiskit.algorithms import NumPyMinimumEigensolver
from qiskit_nature.algorithms import (GroundStateEigensolver,
                                      NumPyMinimumEigensolverFactory)
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import (
    ElectronicStructureMoleculeDriver, ElectronicStructureDriverType)
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.mappers.second_quantization import ParityMapper

import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
import numpy as np
from qiskit.providers.aer import AerSimulator

# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.providers.aer import QasmSimulator

def get_qubit_op(dist):
    molecule = Molecule(
        geometry=[ [&quot;H&quot;, [0.0, 0.0, 0.0] ],
                  [&quot;H&quot;, [dist, 0.0, 0.0725] ]],
        multiplicity=1,charge=0)

    driver = ElectronicStructureMoleculeDriver(
        molecule=molecule,
        basis=&quot;sto3g&quot;,
        driver_type=ElectronicStructureDriverType.PYSCF)

    problem = ElectronicStructureProblem(driver)

    second_q_ops = problem.second_q_ops()  # Get 2nd Quant OP
    num_spin_orbitals = problem.num_spin_orbitals
    num_particles = problem.num_particles

    mapper = ParityMapper()  # Set Mapper

    hamiltonian = second_q_ops[0]  # Set Hamiltonian

    # Do two qubit reduction
    converter = QubitConverter(mapper,two_qubit_reduction=True)
    reducer = TwoQubitReduction(num_particles)
    qubit_op = converter.convert(hamiltonian)
    qubit_op = reducer.convert(qubit_op)
    return qubit_op, num_particles, num_spin_orbitals, problem, converter

from qiskit.providers.aer.noise import pauli_error
from qiskit import IBMQ
from qiskit.providers.aer.noise import NoiseModel, ReadoutError
from qiskit.providers.fake_provider import FakeMelbourne
backend = FakeMelbourne()
from qiskit.providers.aer.noise import depolarizing_error
nm_1 = NoiseModel.from_backend(backend)
import qiskit_aer.noise as noise
def custom_noise(idx): 
    # Error probabilities
    if idx == 0:
        prob_1 = 0.005  # 1-qubit gate
        prob_2 = 0.01   # 2-qubit gate
        p0_1 = 0.99
        p1_0 = 0.005
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.015
        p_meas = 0.01
        p_gate1 = 0.0125
    elif idx == 1:
        prob_1 = 0.05  # 1-qubit gate
        prob_2 = 0.1   # 2-qubit gate
        p0_1 = 0.9
        p1_0 = 0.05
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.15
        p_meas = 0.1
        p_gate1 = 0.125
    elif idx == 2:
        prob_1 = 0.1  # 1-qubit gate
        prob_2 = 0.2   # 2-qubit gate
        p0_1 = 0.8
        p1_0 = 0.1
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.3
        p_meas = 0.2
        p_gate1 = 0.35
    elif idx == 3:
        prob_1 = 0.15  # 1-qubit gate
        prob_2 = 0.3   # 2-qubit gate
        p0_1 = 0.6
        p1_0 = 0.3
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.45
        p_meas = 0.3
        p_gate1 = 0.475
    elif idx == 4:
        prob_1 = 0.2  # 1-qubit gate
        prob_2 = 0.4   # 2-qubit gate
        p0_1 = 0.5
        p1_0 = 0.4
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.60
        p_meas = 0.4
        p_gate1 = 0.6
    print(prob_1,p0_1,p_reset)
    #adding quantum error objects
    '''
    error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)])
    error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)])
    error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)])
    error_gate2 = error_gate1.tensor(error_gate1)
    '''
    
    # Depolarizing quantum errors
    error_1 = noise.depolarizing_error(prob_1, 1)
    error_2 = noise.depolarizing_error(prob_2, 2)
    
    #Readout errors
    readout_error = ReadoutError([[p0_1, p0], [p1_0, p1]])
    
    # Add errors to noise model
    noise_model1 = noise.NoiseModel()
   # noise_model.add_all_qubit_quantum_error(error_reset, &quot;reset&quot;)
   # noise_model.add_all_qubit_quantum_error(error_meas, &quot;measure&quot;)
   # noise_model.add_all_qubit_quantum_error(error_gate1, [&quot;u1&quot;, &quot;u2&quot;, &quot;u3&quot;])
   # noise_model.add_all_qubit_quantum_error(error_gate2, [&quot;cx&quot;])
   # noise_model.add_all_qubit_readout_error(readout_error)
    noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
    noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
    noise_model1.add_all_qubit_readout_error(readout_error)
    print(noise_model1)
    
    '''
    noise_model = NoiseModel()
    error = depolarizing_error(prob_1,1)
    noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])
    '''
    backend1 = Aer.get_backend('qasm_simulator')
    basis_gates = noise_model1.basis_gates
    sim_noise = AerSimulator(noise_model=noise_model1)
    qi = QuantumInstance(backend1,
                         noise_model=noise_model1,
                         basis_gates=basis_gates,
                         measurement_error_mitigation_cls=CompleteMeasFitter)
    return qi

def exact_solver(problem, converter):
    solver = NumPyMinimumEigensolverFactory()
    calc = GroundStateEigensolver(converter, solver)
    result = calc.solve(problem)
    return result

distances = np.arange(0.2, 2.5, 0.2)

for idx in range(0,5):
    exact_energies = []
    vqe_energies = []
    optimizer = SLSQP(maxiter=100)
    qi = custom_noise(idx)
    for dist in distances:
        (qubit_op, num_particles, num_spin_orbitals,
                                 problem, converter) = get_qubit_op(dist)
        result = exact_solver(problem,converter)
        exact_energies.append(result.total_energies[0])
        init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
        var_form = EfficientSU2(qubit_op.num_qubits, entanglement=&quot;linear&quot;)
        vqe = VQE(var_form, optimizer=optimizer, quantum_instance=qi)
        vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
        vqe_result = problem.interpret(vqe_calc).total_energies[0].real
        vqe_energies.append(vqe_result)
        print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
              f&quot;VQE Result: {vqe_result:.5f}&quot;,
              f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
    print(&quot;Energies for idx {} have been calculated&quot;.format(idx))
    plt.plot(distances, vqe_energies, label=&quot;VQE Energy index = {}&quot;.format(idx))
    
print(&quot;All energies have been calculated&quot;)
plt.plot(distances, exact_energies, label=&quot;Exact Energy&quot;)
plt.xlabel('Atomic distance (Angstrom)')
plt.ylabel('Energy')
plt.legend()
plt.show()
</code></pre>
<p>Below are the results:
<a href=""https://i.sstatic.net/psoz3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/psoz3.png"" alt=""Image of diff noises by similar"" /></a>
This shows that increasing the noise doesn't have the same affect as which it has on my simple example above.</p>
",Why my noise model acts different on my VQE circuit compared to a simple circuit,<qiskit><noise>,0,7,,,"Why my noise model acts different on my VQE circuit compared to a simple circuit <p>I have created a noise model which uses depolarizing error and I add it using the add to all qubits quantum error command. I also use readout error and add that using the add to all qubits readoute error command.</p>
<p>When I've tested this noisemodel on a simple circuit I can successfully vary the amount of noise the circuit receives, however when I try to add it in to my VQE code which is the code from the QisKit textbook, when I increase the parameters there isn't a noticeable change.</p>
<p>I was thinking this is because the VQE algorithm is already quite good at handling noise, however when I am increasing these parameters by a power of 10 there should be some sort of change.</p>
<p>Any insight would be greatly appreciated.</p>
<p>Here is my code for my simple example:</p>
<pre><code>from qiskit import QuantumCircuit, execute
from qiskit import IBMQ, Aer
from qiskit.visualization import plot_histogram
from qiskit_aer.noise import NoiseModel

# Build noise model from backend properties
provider = IBMQ.load_account()
backend = provider.get_backend('ibmq_quito')
noise_model = NoiseModel.from_backend(backend)

# Get coupling map from backend
coupling_map = backend.configuration().coupling_map

# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 coupling_map=coupling_map,
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>The reuslts from this are below
<a href=""https://i.sstatic.net/E6QkZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/E6QkZ.png"" alt=""The results from this example"" /></a></p>
<p>I then created by own noisemodel with the following</p>
<pre><code>from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
import qiskit_aer.noise as noise
from qiskit.providers.aer.noise import QuantumError, ReadoutError

# Error probabilities
prob_1 = 0.02  # 1-qubit gate
prob_2 = 0.2  # 2-qubit gate

# Depolarizing quantum errors
error_1 = noise.depolarizing_error(prob_1, 1)
error_2 = noise.depolarizing_error(prob_2, 2)

# Readout quantum errors
p0given1 = 0.1
p1given0 = 0.05

ReadoutError = ReadoutError([[1 - p1given0, p1given0], [p0given1, 1 - p0given1]])

# Add errors to noise model
noise_model = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model.add_all_qubit_readout_error(ReadoutError)
print(noise_model)
# Get basis gates from noise model
basis_gates = noise_model.basis_gates

# Make a circuit
circ = QuantumCircuit(3, 3)
circ.h(0)
circ.cx(0, 1)
circ.cx(1, 2)
circ.measure([0, 1, 2], [0, 1, 2])

# Perform a noise simulation
result = execute(circ, Aer.get_backend('qasm_simulator'),
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
counts = result.get_counts(0)
plot_histogram(counts)
</code></pre>
<p>And I get the following:</p>
<p><a href=""https://i.sstatic.net/jRfhK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jRfhK.png"" alt=""Own noise model results"" /></a></p>
<p>I can then change my parameters: prob_1, prob_2, p0given1 and p1given0
Increasing these increases my noise, decreasing these decreases my noise. This is what I wanted to achieve of having controllable noise. Then when I take this code over to my VQE code I add them to a noise model through the following:</p>
<pre><code>noise_model1 = noise.NoiseModel()
noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
noise_model1.add_all_qubit_readout_error(readout_error)
sim_noise = AerSimulator(noise_model=noise_model1)
qi = QuantumInstance(sim_noise,
                    noise_model=noise_model1)
</code></pre>
<p>This then gives me the quantum instance which I can use in my VQE code. However all of my results are very similar even if I'm changing my probabilities massively. Even when I put the probabilities to almost no error it still acts as if I have set the probabilities to a very high error.</p>
<p>Below is my entire VQE code:
Note: I am aware that I could nest my parameters increasing in size into a loop instead of using if statements, I've just done it this way to help me visualize.</p>
<p>I also have 3 parameters p_reset,p_meas and p_gate1 which I used when testing a different type of &quot;quantum_error&quot; which also didn't help improving my results so these can be ignored. They aren't applied to the noisemodel.</p>
<p>I also have tried with 'qasm_simulator' and AerSimulator, both give the same result and don't really change with changes in these parameters.</p>
<pre><code>from qiskit.algorithms import VQE
from qiskit.algorithms import NumPyMinimumEigensolver
from qiskit_nature.algorithms import (GroundStateEigensolver,
                                      NumPyMinimumEigensolverFactory)
from qiskit_nature.drivers import Molecule
from qiskit_nature.drivers.second_quantization import (
    ElectronicStructureMoleculeDriver, ElectronicStructureDriverType)
from qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer
from qiskit_nature.problems.second_quantization import ElectronicStructureProblem
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.mappers.second_quantization import ParityMapper

import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
import numpy as np
from qiskit.providers.aer import AerSimulator

# Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.providers.aer import QasmSimulator

def get_qubit_op(dist):
    molecule = Molecule(
        geometry=[ [&quot;H&quot;, [0.0, 0.0, 0.0] ],
                  [&quot;H&quot;, [dist, 0.0, 0.0725] ]],
        multiplicity=1,charge=0)

    driver = ElectronicStructureMoleculeDriver(
        molecule=molecule,
        basis=&quot;sto3g&quot;,
        driver_type=ElectronicStructureDriverType.PYSCF)

    problem = ElectronicStructureProblem(driver)

    second_q_ops = problem.second_q_ops()  # Get 2nd Quant OP
    num_spin_orbitals = problem.num_spin_orbitals
    num_particles = problem.num_particles

    mapper = ParityMapper()  # Set Mapper

    hamiltonian = second_q_ops[0]  # Set Hamiltonian

    # Do two qubit reduction
    converter = QubitConverter(mapper,two_qubit_reduction=True)
    reducer = TwoQubitReduction(num_particles)
    qubit_op = converter.convert(hamiltonian)
    qubit_op = reducer.convert(qubit_op)
    return qubit_op, num_particles, num_spin_orbitals, problem, converter

from qiskit.providers.aer.noise import pauli_error
from qiskit import IBMQ
from qiskit.providers.aer.noise import NoiseModel, ReadoutError
from qiskit.providers.fake_provider import FakeMelbourne
backend = FakeMelbourne()
from qiskit.providers.aer.noise import depolarizing_error
nm_1 = NoiseModel.from_backend(backend)
import qiskit_aer.noise as noise
def custom_noise(idx): 
    # Error probabilities
    if idx == 0:
        prob_1 = 0.005  # 1-qubit gate
        prob_2 = 0.01   # 2-qubit gate
        p0_1 = 0.99
        p1_0 = 0.005
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.015
        p_meas = 0.01
        p_gate1 = 0.0125
    elif idx == 1:
        prob_1 = 0.05  # 1-qubit gate
        prob_2 = 0.1   # 2-qubit gate
        p0_1 = 0.9
        p1_0 = 0.05
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.15
        p_meas = 0.1
        p_gate1 = 0.125
    elif idx == 2:
        prob_1 = 0.1  # 1-qubit gate
        prob_2 = 0.2   # 2-qubit gate
        p0_1 = 0.8
        p1_0 = 0.1
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.3
        p_meas = 0.2
        p_gate1 = 0.35
    elif idx == 3:
        prob_1 = 0.15  # 1-qubit gate
        prob_2 = 0.3   # 2-qubit gate
        p0_1 = 0.6
        p1_0 = 0.3
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.45
        p_meas = 0.3
        p_gate1 = 0.475
    elif idx == 4:
        prob_1 = 0.2  # 1-qubit gate
        prob_2 = 0.4   # 2-qubit gate
        p0_1 = 0.5
        p1_0 = 0.4
        p0 = 1 - p0_1
        p1 = 1 - p1_0
        p_reset = 0.60
        p_meas = 0.4
        p_gate1 = 0.6
    print(prob_1,p0_1,p_reset)
    #adding quantum error objects
    '''
    error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)])
    error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)])
    error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)])
    error_gate2 = error_gate1.tensor(error_gate1)
    '''
    
    # Depolarizing quantum errors
    error_1 = noise.depolarizing_error(prob_1, 1)
    error_2 = noise.depolarizing_error(prob_2, 2)
    
    #Readout errors
    readout_error = ReadoutError([[p0_1, p0], [p1_0, p1]])
    
    # Add errors to noise model
    noise_model1 = noise.NoiseModel()
   # noise_model.add_all_qubit_quantum_error(error_reset, &quot;reset&quot;)
   # noise_model.add_all_qubit_quantum_error(error_meas, &quot;measure&quot;)
   # noise_model.add_all_qubit_quantum_error(error_gate1, [&quot;u1&quot;, &quot;u2&quot;, &quot;u3&quot;])
   # noise_model.add_all_qubit_quantum_error(error_gate2, [&quot;cx&quot;])
   # noise_model.add_all_qubit_readout_error(readout_error)
    noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])
    noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])
    noise_model1.add_all_qubit_readout_error(readout_error)
    print(noise_model1)
    
    '''
    noise_model = NoiseModel()
    error = depolarizing_error(prob_1,1)
    noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])
    '''
    backend1 = Aer.get_backend('qasm_simulator')
    basis_gates = noise_model1.basis_gates
    sim_noise = AerSimulator(noise_model=noise_model1)
    qi = QuantumInstance(backend1,
                         noise_model=noise_model1,
                         basis_gates=basis_gates,
                         measurement_error_mitigation_cls=CompleteMeasFitter)
    return qi

def exact_solver(problem, converter):
    solver = NumPyMinimumEigensolverFactory()
    calc = GroundStateEigensolver(converter, solver)
    result = calc.solve(problem)
    return result

distances = np.arange(0.2, 2.5, 0.2)

for idx in range(0,5):
    exact_energies = []
    vqe_energies = []
    optimizer = SLSQP(maxiter=100)
    qi = custom_noise(idx)
    for dist in distances:
        (qubit_op, num_particles, num_spin_orbitals,
                                 problem, converter) = get_qubit_op(dist)
        result = exact_solver(problem,converter)
        exact_energies.append(result.total_energies[0])
        init_state = HartreeFock(num_spin_orbitals, num_particles, converter)
        var_form = EfficientSU2(qubit_op.num_qubits, entanglement=&quot;linear&quot;)
        vqe = VQE(var_form, optimizer=optimizer, quantum_instance=qi)
        vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
        vqe_result = problem.interpret(vqe_calc).total_energies[0].real
        vqe_energies.append(vqe_result)
        print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
              f&quot;VQE Result: {vqe_result:.5f}&quot;,
              f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
    print(&quot;Energies for idx {} have been calculated&quot;.format(idx))
    plt.plot(distances, vqe_energies, label=&quot;VQE Energy index = {}&quot;.format(idx))
    
print(&quot;All energies have been calculated&quot;)
plt.plot(distances, exact_energies, label=&quot;Exact Energy&quot;)
plt.xlabel('Atomic distance (Angstrom)')
plt.ylabel('Energy')
plt.legend()
plt.show()
</code></pre>
<p>Below are the results:
<a href=""https://i.sstatic.net/psoz3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/psoz3.png"" alt=""Image of diff noises by similar"" /></a>
This shows that increasing the noise doesn't have the same affect as which it has on my simple example above.</p>
",qc,noise model acts different vqe circuit compared simple circuit p created noise model uses depolarizing error add using add qubits quantum error command also use readout error add using add qubits readoute error p tested noisemodel simple circuit successfully vary amount noise circuit receives however try add vqe code code qiskit textbook increase parameters noticeable p thinking vqe algorithm already quite good handling noise however increasing parameters power 10 sort p insight would greatly p code simple example pre code qiskit import quantumcircuit execute qiskit import ibmq aer import import noisemodel build noise model backend properties provider backend backend get coupling map backend get basis gates noise model make circuit circ quantumcircuit 3 3 0 0 1 1 2 0 1 2 0 1 2 perform noise simulation result execute circ counts 0 counts p reuslts https nofollow noreferrer img https results example p created noisemodel following pre code qiskit import quantumcircuit execute aer import import noise import quantumerror readouterror error probabilities gate gate depolarizing quantum errors 1 2 readout quantum errors p0given1 p1given0 readouterror readouterror 1 p1given0 p1given0 p0given1 1 p0given1 add errors noise model readouterror print get basis gates noise model make circuit circ quantumcircuit 3 3 0 0 1 1 2 0 1 2 0 1 2 perform noise simulation result execute circ counts 0 counts p get following p https nofollow noreferrer img https noise model results p change parameters p0given1 p1given0 increasing increases noise decreasing decreases noise wanted achieve controllable noise take code vqe code add noise model following pre code aersimulator qi quantuminstance p gives quantum instance use vqe code however results similar even changing probabilities massively even put probabilities almost error still acts set probabilities high p entire vqe code note aware could nest parameters increasing size loop instead using statements done way help p also 3 parameters used testing different type quot quot also help improving results ignored applied p also tried aersimulator give result really change changes pre code import vqe import numpyminimumeigensolver import groundstateeigensolver numpyminimumeigensolverfactory import molecule import electronicstructuremoleculedriver electronicstructuredrivertype import freezecoretransformer import electronicstructureproblem import qubitconverter import paritymapper import plt import numpy np import uccsd hartreefock import efficientsu2 import cobyla spsa slsqp import twoqubitreduction qiskit import basicaer aer import quantuminstance import completemeasfitter import noisemodel import numpy np import aersimulator importing standard qiskit libraries qiskit import quantumcircuit transpile aer ibmq import qasmsimulator def dist molecule molecule quot h quot quot h quot dist driver electronicstructuremoleculedriver quot sto3g quot problem electronicstructureproblem driver get 2nd quant op mapper paritymapper set mapper hamiltonian 0 set hamiltonian two qubit reduction converter qubitconverter mapper reducer twoqubitreduction hamiltonian return problem converter import qiskit import ibmq import noisemodel readouterror import fakemelbourne backend fakemelbourne import backend import noise def idx error probabilities idx 0 gate gate p0 1 p1 1 elif idx 1 gate gate p0 1 p1 1 elif idx 2 gate gate p0 1 p1 1 elif idx 3 gate gate p0 1 p1 1 elif idx 4 gate gate p0 1 p1 1 print adding quantum error objects x 1 x 1 x 1 depolarizing quantum errors 1 2 readout errors readouterror p0 p1 add errors noise model quot reset quot quot measure quot quot u1 quot quot u2 quot quot u3 quot quot cx quot print noisemodel error error backend1 aersimulator qi quantuminstance backend1 return qi def problem converter solver numpyminimumeigensolverfactory calc groundstateeigensolver converter solver result problem return result distances idx range optimizer slsqp qi idx dist distances problem converter dist result problem converter 0 hartreefock converter efficientsu2 quot linear quot vqe vqe 0 print f quot interatomic distance dist 2 quot f quot vqe result quot f quot exact energy quot print quot energies idx calculated quot idx distances quot vqe energy index quot idx print quot energies calculated quot distances quot exact energy quot distance angstrom p results https nofollow noreferrer img https image diff noises similar shows increasing noise affect simple example,"[(0, 0.33382562), (2, 0.09343485), (4, 0.03416691), (5, 0.019585501), (8, 0.056674495), (9, 0.03427455), (12, 0.0125162415), (14, 0.2688809), (17, 0.05268304), (19, 0.08164184)]"
29258,,2022-12-06 03:29:13,1,186,"<p>I understand that for standard bits the difference between a 64 bit memory and a 32 bit memory is 2^64 divided by 2^32. This means that with 64 bits we can access approximately 4294967296 or about four billion times the physical memory than with 32 bits.</p>
<p>Now I am wondering what the difference is for quantum computers, if theres is any.</p>
<p>Can you explain this to me please? Thank you!</p>
",How many elements could a 64 qubit quantum computer hold hypothetically compared to a 32 qubit computer?,<programming>,1,1,,,"How many elements could a 64 qubit quantum computer hold hypothetically compared to a 32 qubit computer? <p>I understand that for standard bits the difference between a 64 bit memory and a 32 bit memory is 2^64 divided by 2^32. This means that with 64 bits we can access approximately 4294967296 or about four billion times the physical memory than with 32 bits.</p>
<p>Now I am wondering what the difference is for quantum computers, if theres is any.</p>
<p>Can you explain this to me please? Thank you!</p>
",qc,many elements could 64 qubit quantum computer hold hypothetically compared 32 qubit computer p understand standard bits difference 64 bit memory 32 bit memory divided means 64 bits access approximately 4294967296 four billion times physical memory 32 p wondering difference quantum computers theres p explain please thank,"[(1, 0.13738297), (8, 0.25475392), (13, 0.13607989), (14, 0.23138586), (17, 0.025637295), (18, 0.2115175)]"
29332,,2022-12-12 08:09:22,3,369,"<p>I'm trying to use the Estimator and Sampler functions from the recent Qiskit version:
<a href=""https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-estimator.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-estimator.html</a>
<a href=""https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-sampler.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-sampler.html</a></p>
<p>My environment:</p>
<pre><code>{'qiskit-terra': '0.22.2', 'qiskit-aer': '0.11.1', 'qiskit-ignis': None, 'qiskit-ibmq-provider': '0.19.2', 'qiskit': '0.39.2', 'qiskit-nature': '0.5.0', 'qiskit-finance': '0.3.4', 'qiskit-optimization': '0.4.0', 'qiskit-machine-learning': '0.5.0'}
</code></pre>
<p>When running the example from the Tutorial on ibm_kawasaki, the job fails with the error message:</p>
<pre><code>Job has failed: Delays must be a multiple of 16 samples. Error code: 8043
</code></pre>
<p>Calling &quot;backend.configuration().timing_constraints&quot;
indeed yields on Kawasaki:</p>
<pre><code>   {'acquire_alignment': 16, 'granularity': 16, 'min_length': 64, 'pulse_alignment': 16}
</code></pre>
<p>On other clusters (ibm_cairo) the pulse_alignment is 1, and the code finishes successfully.</p>
<p>There is a timing_constraints option that can be set when transpiling the circuit, but
when calling the Estimator, there is no parameter or option that can be set for this.
During a transpilation call these restrictions seem to be automatically taken from
the backend information, but calling the Estimator with a non-transpiled circuit
does not seem to do this. Calling the Estimator with a manually transpiled circuit
also does not work.</p>
<p>A similar issue has been discussed in the past here:
<a href=""https://github.com/Qiskit/qiskit-terra/issues/7317"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/issues/7317</a></p>
<p>But I did not find any way of setting the timing_constraints with the Sampler or Estimator primitive.
Does anyone know how to make them work on clusters with pulse_alignment 16 ?</p>
<p>Edit:
Transpiling the circuit with</p>
<pre><code>transpiled_circuits = transpile(psi1, backend=backend, scheduling_method=&quot;alap&quot;)
</code></pre>
<p>inflates the circuit to the total number of qubits on the machine, which then throws the error</p>
<pre><code>File /opt/conda/lib/python3.8/site-packages/qiskit/primitives/base/base_estimator.py:283 in _cross_validate_circuits_observables raise ValueError(
ValueError: The number of qubits of the 0-th circuit (27) does not match the number of qubits of the 0-th observable (4)
</code></pre>
<p>I circumvented this by padding the observables with identity operations as suggested, but then the</p>
<pre><code>Job has failed: Delays must be a multiple of 16 samples. Error code: 8043
</code></pre>
<p>persists.
This is the code that produces said error:</p>
<pre><code>service = QiskitRuntimeService()
backend = service.backend(&quot;ibm_kawasaki&quot;)
options = Options(optimization_level=3)
options.execution.shots = 1024 
padding_str = (backend.configuration().n_qubits - 4) * 'I'

psi1 = RealAmplitudes(num_qubits=4, reps=2, entanglement=[[0,1],[2,3],[0,2],[1,3]], skip_final_rotation_layer=True)
H1 = SparsePauliOp.from_list([(&quot;IIII&quot;+padding_str, 1), (&quot;IIII&quot;+padding_str, -2), (&quot;ZIZI&quot;+padding_str, 0)])
theta1 = [0, 1, 1, 2, 3, 5, 1, 1]

with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    transpiled_circuits = transpile(psi1, backend=backend, scheduling_method=&quot;alap&quot;)
    job = estimator.run(circuits=[transpiled_circuits], observables=[H1], parameter_values=[theta1])
    print(f&quot;Job result is {job.result()}&quot;)
</code></pre>
","How to avoid ""Delays must be a multiple of 16 samples"" Error with Estimator & Sampler",<qiskit>,2,0,,,"How to avoid ""Delays must be a multiple of 16 samples"" Error with Estimator & Sampler <p>I'm trying to use the Estimator and Sampler functions from the recent Qiskit version:
<a href=""https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-estimator.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-estimator.html</a>
<a href=""https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-sampler.html"" rel=""nofollow noreferrer"">https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials/how-to-getting-started-with-sampler.html</a></p>
<p>My environment:</p>
<pre><code>{'qiskit-terra': '0.22.2', 'qiskit-aer': '0.11.1', 'qiskit-ignis': None, 'qiskit-ibmq-provider': '0.19.2', 'qiskit': '0.39.2', 'qiskit-nature': '0.5.0', 'qiskit-finance': '0.3.4', 'qiskit-optimization': '0.4.0', 'qiskit-machine-learning': '0.5.0'}
</code></pre>
<p>When running the example from the Tutorial on ibm_kawasaki, the job fails with the error message:</p>
<pre><code>Job has failed: Delays must be a multiple of 16 samples. Error code: 8043
</code></pre>
<p>Calling &quot;backend.configuration().timing_constraints&quot;
indeed yields on Kawasaki:</p>
<pre><code>   {'acquire_alignment': 16, 'granularity': 16, 'min_length': 64, 'pulse_alignment': 16}
</code></pre>
<p>On other clusters (ibm_cairo) the pulse_alignment is 1, and the code finishes successfully.</p>
<p>There is a timing_constraints option that can be set when transpiling the circuit, but
when calling the Estimator, there is no parameter or option that can be set for this.
During a transpilation call these restrictions seem to be automatically taken from
the backend information, but calling the Estimator with a non-transpiled circuit
does not seem to do this. Calling the Estimator with a manually transpiled circuit
also does not work.</p>
<p>A similar issue has been discussed in the past here:
<a href=""https://github.com/Qiskit/qiskit-terra/issues/7317"" rel=""nofollow noreferrer"">https://github.com/Qiskit/qiskit-terra/issues/7317</a></p>
<p>But I did not find any way of setting the timing_constraints with the Sampler or Estimator primitive.
Does anyone know how to make them work on clusters with pulse_alignment 16 ?</p>
<p>Edit:
Transpiling the circuit with</p>
<pre><code>transpiled_circuits = transpile(psi1, backend=backend, scheduling_method=&quot;alap&quot;)
</code></pre>
<p>inflates the circuit to the total number of qubits on the machine, which then throws the error</p>
<pre><code>File /opt/conda/lib/python3.8/site-packages/qiskit/primitives/base/base_estimator.py:283 in _cross_validate_circuits_observables raise ValueError(
ValueError: The number of qubits of the 0-th circuit (27) does not match the number of qubits of the 0-th observable (4)
</code></pre>
<p>I circumvented this by padding the observables with identity operations as suggested, but then the</p>
<pre><code>Job has failed: Delays must be a multiple of 16 samples. Error code: 8043
</code></pre>
<p>persists.
This is the code that produces said error:</p>
<pre><code>service = QiskitRuntimeService()
backend = service.backend(&quot;ibm_kawasaki&quot;)
options = Options(optimization_level=3)
options.execution.shots = 1024 
padding_str = (backend.configuration().n_qubits - 4) * 'I'

psi1 = RealAmplitudes(num_qubits=4, reps=2, entanglement=[[0,1],[2,3],[0,2],[1,3]], skip_final_rotation_layer=True)
H1 = SparsePauliOp.from_list([(&quot;IIII&quot;+padding_str, 1), (&quot;IIII&quot;+padding_str, -2), (&quot;ZIZI&quot;+padding_str, 0)])
theta1 = [0, 1, 1, 2, 3, 5, 1, 1]

with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    transpiled_circuits = transpile(psi1, backend=backend, scheduling_method=&quot;alap&quot;)
    job = estimator.run(circuits=[transpiled_circuits], observables=[H1], parameter_values=[theta1])
    print(f&quot;Job result is {job.result()}&quot;)
</code></pre>
",qc,avoid delays must multiple 16 samples error estimator sampler p trying use estimator sampler functions recent qiskit version https nofollow noreferrer https https nofollow noreferrer https p environment pre code none p running example tutorial job fails error message pre code job failed delays must multiple 16 samples error code 8043 p calling quot quot indeed yields kawasaki pre code 16 16 64 16 p clusters 1 code finishes p option set transpiling circuit calling estimator parameter option set transpilation call restrictions seem automatically taken backend information calling estimator circuit seem calling estimator manually transpiled circuit also p similar issue discussed past https nofollow noreferrer https p find way setting sampler estimator primitive anyone know make work clusters 16 p edit transpiling circuit pre code transpile psi1 quot alap quot p inflates circuit total number qubits machine throws error pre code file raise valueerror valueerror number qubits circuit 27 match number qubits observable 4 p circumvented padding observables identity operations suggested pre code job failed delays must multiple 16 samples error code 8043 p persists code produces said error pre code service qiskitruntimeservice backend quot quot options options 1024 4 psi1 realamplitudes h1 quot iiii quot 1 quot iiii quot quot zizi quot 0 theta1 0 1 1 2 3 5 1 1 session session estimator estimator transpile psi1 quot alap quot job h1 theta1 print f quot job result quot,"[(0, 0.29709288), (2, 0.031591304), (4, 0.07220585), (6, 0.05725326), (9, 0.038398795), (10, 0.012062164), (14, 0.28639945), (17, 0.014944895), (19, 0.18955132)]"
29383,,2022-12-15 18:22:15,1,201,"<p>I would like to know if there is a functionality in qiskit to simplify a sequence of gates in a QASM file. For example, say we have a sequence of two expensive (in fault-tolerant context) gates <span class=""math-container"">$TT$</span>. Instead of executing an operation <span class=""math-container"">$TT$</span>, it is preferable to re-express <span class=""math-container"">$TT$</span> with a single Clifford gate <span class=""math-container"">$S$</span>, i.e., <span class=""math-container"">$TT=S$</span>.</p>
<p>Is there a qiskit function that allows the mapping <span class=""math-container"">$TT \rightarrow S$</span> in a QASM file?
Also, sequences like <span class=""math-container"">$HH$</span> etc could be simplified as well.</p>
",How to simplify sequence of gates in QASM file?,<qiskit><quantum-gate><qasm>,2,0,,,"How to simplify sequence of gates in QASM file? <p>I would like to know if there is a functionality in qiskit to simplify a sequence of gates in a QASM file. For example, say we have a sequence of two expensive (in fault-tolerant context) gates <span class=""math-container"">$TT$</span>. Instead of executing an operation <span class=""math-container"">$TT$</span>, it is preferable to re-express <span class=""math-container"">$TT$</span> with a single Clifford gate <span class=""math-container"">$S$</span>, i.e., <span class=""math-container"">$TT=S$</span>.</p>
<p>Is there a qiskit function that allows the mapping <span class=""math-container"">$TT \rightarrow S$</span> in a QASM file?
Also, sequences like <span class=""math-container"">$HH$</span> etc could be simplified as well.</p>
",qc,simplify sequence gates qasm file p would like know functionality qiskit simplify sequence gates qasm file example say sequence two expensive context gates span tt instead executing operation span tt preferable span tt single clifford gate span span p qiskit function allows mapping span tt qasm file also sequences like span hh etc could simplified,"[(3, 0.17988454), (9, 0.23059954), (14, 0.5541183), (17, 0.03227172)]"
29402,,2022-12-17 03:10:47,1,225,"<p>I wrote code again using updated qiskit nature libraries but I am facing error , I need help to finding solution so that we can run this code on latest version of qiskit.</p>
<p>I am attaching code below......</p>
<p>import numpy as np</p>
<h1>Importing standard Qiskit libraries</h1>
<p>from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from ibm_quantum_widgets import *
from qiskit.providers.aer import QasmSimulator</p>
<h1>Loading your IBM Quantum account(s)</h1>
<p>provider = IBMQ.load_account()
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [3]:
from qiskit.algorithms import VQE
from qiskit_nature.second_q.algorithms import (GroundStateEigensolver,
NumPyMinimumEigensolverFactory)
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.mappers import ParityMapper, QubitConverter, JordanWignerMapper</p>
<p>import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.second_q.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [4]:
def get_qubit_op(dist):
# Define Molecule
molecule = MoleculeInfo(
# Coordinates in Angstrom
[&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (dist, 0.0, 0.0)],
multiplicity=1,  # = 2*spin + 1
charge=0,
)</p>
<pre><code>driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

# Get properties
properties = driver.run()
num_particles = properties.num_particles
num_spatial_orbitals = properties.num_spatial_orbitals

# Define Problem, Use freeze core approximation, remove orbitals.

transformer = FreezeCoreTransformer(freeze_core=True,remove_orbitals=[-3,-2])
problem = transformer.transform(properties)

num_spatial_orbitals = problem.num_spatial_orbitals
num_particles = problem.num_particles

hamiltonian = problem.hamiltonian.second_q_op()
# Do two qubit reduction
converter = QubitConverter(JordanWignerMapper())
reducer = TwoQubitReduction(num_particles)
qubit_op = converter.convert(hamiltonian)
qubit_op = reducer.convert(qubit_op)

return qubit_op, num_particles, num_spatial_orbitals, problem, converter
</code></pre>
<p>In [5]:
def exact_solver(problem, converter):
solver = NumPyMinimumEigensolverFactory()
calc = GroundStateEigensolver(converter, solver)
result = calc.solve(problem)
return result</p>
<p>backend = BasicAer.get_backend(&quot;statevector_simulator&quot;)
distances = np.arange(0.5, 4.0, 0.2)
exact_energies = []
vqe_energies = []
optimizer = SLSQP(maxiter=5)
for dist in distances:
(qubit_op, num_particles, num_spatial_orbitals,
problem, converter) = get_qubit_op(dist)
result = exact_solver(problem,converter)
exact_energies.append(result.total_energies[0].real)</p>
<pre><code>var_form = UCCSD()
var_form.num_particles = num_particles
var_form.num_spatial_orbitals = (num_spatial_orbitals)
var_form.qubit_converter = converter
init_state = HartreeFock()
init_state.num_particles = num_particles
init_state.num_spatial_orbitals = (num_spatial_orbitals)
init_state.qubit_converter = converter

var_form.initial_state=init_state

vqe = VQE(var_form, optimizer, quantum_instance=backend)
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
vqe_result = problem.interpret(vqe_calc).total_energies[0].real
vqe_energies.append(vqe_result)
print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
      f&quot;VQE Result: {vqe_result:.5f}&quot;,
      f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
</code></pre>
<p>print(&quot;All energies have been calculated&quot;)
Traceback (most recent call last):
Input In [5] in &lt;cell line: 12&gt;
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:496 in compute_minimum_eigenvalue
self._check_operator_ansatz(operator)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:331 in _check_operator_ansatz
raise AlgorithmError(
AlgorithmError: 'The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using <code>num_qubits</code>.'</p>
<p>Use %tb to get the full traceback.
Search for solution online</p>
",getting error while simulating LiH using VQE,<quantum-algorithms><simulation><vqe>,0,2,,,"getting error while simulating LiH using VQE <p>I wrote code again using updated qiskit nature libraries but I am facing error , I need help to finding solution so that we can run this code on latest version of qiskit.</p>
<p>I am attaching code below......</p>
<p>import numpy as np</p>
<h1>Importing standard Qiskit libraries</h1>
<p>from qiskit import QuantumCircuit, transpile, Aer, IBMQ
from qiskit.tools.jupyter import *
from qiskit.visualization import *
from ibm_quantum_widgets import *
from qiskit.providers.aer import QasmSimulator</p>
<h1>Loading your IBM Quantum account(s)</h1>
<p>provider = IBMQ.load_account()
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [3]:
from qiskit.algorithms import VQE
from qiskit_nature.second_q.algorithms import (GroundStateEigensolver,
NumPyMinimumEigensolverFactory)
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.mappers import ParityMapper, QubitConverter, JordanWignerMapper</p>
<p>import matplotlib.pyplot as plt
import numpy as np
from qiskit_nature.second_q.circuit.library import UCCSD, HartreeFock
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP
from qiskit.opflow import TwoQubitReduction
from qiskit import BasicAer, Aer
from qiskit.utils import QuantumInstance
from qiskit.utils.mitigation import CompleteMeasFitter
from qiskit.providers.aer.noise import NoiseModel
:219: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
In [4]:
def get_qubit_op(dist):
# Define Molecule
molecule = MoleculeInfo(
# Coordinates in Angstrom
[&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (dist, 0.0, 0.0)],
multiplicity=1,  # = 2*spin + 1
charge=0,
)</p>
<pre><code>driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

# Get properties
properties = driver.run()
num_particles = properties.num_particles
num_spatial_orbitals = properties.num_spatial_orbitals

# Define Problem, Use freeze core approximation, remove orbitals.

transformer = FreezeCoreTransformer(freeze_core=True,remove_orbitals=[-3,-2])
problem = transformer.transform(properties)

num_spatial_orbitals = problem.num_spatial_orbitals
num_particles = problem.num_particles

hamiltonian = problem.hamiltonian.second_q_op()
# Do two qubit reduction
converter = QubitConverter(JordanWignerMapper())
reducer = TwoQubitReduction(num_particles)
qubit_op = converter.convert(hamiltonian)
qubit_op = reducer.convert(qubit_op)

return qubit_op, num_particles, num_spatial_orbitals, problem, converter
</code></pre>
<p>In [5]:
def exact_solver(problem, converter):
solver = NumPyMinimumEigensolverFactory()
calc = GroundStateEigensolver(converter, solver)
result = calc.solve(problem)
return result</p>
<p>backend = BasicAer.get_backend(&quot;statevector_simulator&quot;)
distances = np.arange(0.5, 4.0, 0.2)
exact_energies = []
vqe_energies = []
optimizer = SLSQP(maxiter=5)
for dist in distances:
(qubit_op, num_particles, num_spatial_orbitals,
problem, converter) = get_qubit_op(dist)
result = exact_solver(problem,converter)
exact_energies.append(result.total_energies[0].real)</p>
<pre><code>var_form = UCCSD()
var_form.num_particles = num_particles
var_form.num_spatial_orbitals = (num_spatial_orbitals)
var_form.qubit_converter = converter
init_state = HartreeFock()
init_state.num_particles = num_particles
init_state.num_spatial_orbitals = (num_spatial_orbitals)
init_state.qubit_converter = converter

var_form.initial_state=init_state

vqe = VQE(var_form, optimizer, quantum_instance=backend)
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
vqe_result = problem.interpret(vqe_calc).total_energies[0].real
vqe_energies.append(vqe_result)
print(f&quot;Interatomic Distance: {np.round(dist, 2)}&quot;,
      f&quot;VQE Result: {vqe_result:.5f}&quot;,
      f&quot;Exact Energy: {exact_energies[-1]:.5f}&quot;)
</code></pre>
<p>print(&quot;All energies have been calculated&quot;)
Traceback (most recent call last):
Input In [5] in &lt;cell line: 12&gt;
vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:496 in compute_minimum_eigenvalue
self._check_operator_ansatz(operator)
File /opt/conda/lib/python3.8/site-packages/qiskit/algorithms/minimum_eigen_solvers/vqe.py:331 in _check_operator_ansatz
raise AlgorithmError(
AlgorithmError: 'The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using <code>num_qubits</code>.'</p>
<p>Use %tb to get the full traceback.
Search for solution online</p>
",qc,getting error simulating lih using vqe p wrote code using updated qiskit nature libraries facing error need help finding solution run code latest version p attaching code p import numpy np h1 importing standard qiskit libraries p qiskit import quantumcircuit transpile aer ibmq import import import import qasmsimulator h1 loading ibm quantum account p provider runtimewarning size changed may indicate binary incompatibility expected 56 c header got 64 pyobject 3 import vqe import groundstateeigensolver numpyminimumeigensolverfactory import pyscfdriver import moleculeinfo import freezecoretransformer import paritymapper qubitconverter jordanwignermapper p import plt import numpy np import uccsd hartreefock import efficientsu2 import cobyla spsa slsqp import twoqubitreduction qiskit import basicaer aer import quantuminstance import completemeasfitter import noisemodel runtimewarning size changed may indicate binary incompatibility expected 56 c header got 64 pyobject 4 def dist define molecule molecule moleculeinfo coordinates angstrom quot li quot quot h quot dist 2 spin 1 pre code driver molecule quot sto3g quot get properties properties define problem use freeze core approximation remove orbitals transformer freezecoretransformer problem properties hamiltonian two qubit reduction converter qubitconverter jordanwignermapper reducer twoqubitreduction hamiltonian return problem converter p 5 def problem converter solver numpyminimumeigensolverfactory calc groundstateeigensolver converter solver result problem return result p backend quot quot distances optimizer slsqp dist distances problem converter dist result problem converter 0 pre code uccsd converter hartreefock converter vqe vqe optimizer 0 print f quot interatomic distance dist 2 quot f quot vqe result quot f quot exact energy quot p print quot energies calculated quot traceback recent call last input 5 lt cell line 12 gt file operator file raise algorithmerror algorithmerror number qubits ansatz match operator ansatz allow setting number qubits using code p use tb get full traceback search solution online,"[(0, 0.55189323), (1, 0.021958997), (6, 0.010477144), (7, 0.03003769), (8, 0.11583022), (12, 0.035755754), (14, 0.046884537), (17, 0.081974424), (19, 0.09275688)]"
29430,,2022-12-20 04:19:32,3,119,"<p>For our study with Yosi Rinott and Tomer Shoham we need the following simple data:</p>
<p>Starting with a quantum circuit <span class=""math-container"">$C$</span> on <span class=""math-container"">$n$</span> qubits we need two files:</p>
<p>a) A file of probabilities (or amplitudes) for the <span class=""math-container"">$2^n$</span> bitstrings as described by the (ideal) circuit <span class=""math-container"">$C$</span>. (Namely, the probability distribution on <span class=""math-container"">$2^n$</span> bitstrings described by <span class=""math-container"">$C$</span>.)</p>
<p>b) A file of probabilities (or amplitudes) for the <span class=""math-container"">$2^n$</span> bitstrings as described by the a <strong>noisy</strong> version of the circuit <span class=""math-container"">$C$</span>. Where the noise is simply a depolarizing noise on the gates of <span class=""math-container"">$C$</span>. (But other forms of noise are also welcome.)</p>
<p>We need such pairs of files for 12-24 qubits (say). Since our main study is that of Google 2019 experiment we have some preferences for random circuits (or even the Google experimental circuits themselves) but data from other circuits will also be welcome.</p>
<p>We know that this data can be obtained by several available simulators:</p>
<ol>
<li>Google's simulators</li>
<li>the IBM simulators</li>
<li>The NASA simulators. Given with an open-sourced code that combines tensor contraction,
Clifford expansion, and state vector simulation:
<a href=""https://github.com/nasa/hybridq"" rel=""nofollow noreferrer"">https://github.com/nasa/hybridq</a></li>
</ol>
<p><a href=""https://arxiv.org/abs/2111.06868"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2111.06868</a></p>
<p>Our question is if such pairs of files representing the noisy and noiseless distribution are publicly available, or could be made available for us.</p>
",Simulation files for noisy quantum circuits,<ibm-q-experience><quantum-circuit><simulation><noise><random-quantum-circuit>,1,2,,,"Simulation files for noisy quantum circuits <p>For our study with Yosi Rinott and Tomer Shoham we need the following simple data:</p>
<p>Starting with a quantum circuit <span class=""math-container"">$C$</span> on <span class=""math-container"">$n$</span> qubits we need two files:</p>
<p>a) A file of probabilities (or amplitudes) for the <span class=""math-container"">$2^n$</span> bitstrings as described by the (ideal) circuit <span class=""math-container"">$C$</span>. (Namely, the probability distribution on <span class=""math-container"">$2^n$</span> bitstrings described by <span class=""math-container"">$C$</span>.)</p>
<p>b) A file of probabilities (or amplitudes) for the <span class=""math-container"">$2^n$</span> bitstrings as described by the a <strong>noisy</strong> version of the circuit <span class=""math-container"">$C$</span>. Where the noise is simply a depolarizing noise on the gates of <span class=""math-container"">$C$</span>. (But other forms of noise are also welcome.)</p>
<p>We need such pairs of files for 12-24 qubits (say). Since our main study is that of Google 2019 experiment we have some preferences for random circuits (or even the Google experimental circuits themselves) but data from other circuits will also be welcome.</p>
<p>We know that this data can be obtained by several available simulators:</p>
<ol>
<li>Google's simulators</li>
<li>the IBM simulators</li>
<li>The NASA simulators. Given with an open-sourced code that combines tensor contraction,
Clifford expansion, and state vector simulation:
<a href=""https://github.com/nasa/hybridq"" rel=""nofollow noreferrer"">https://github.com/nasa/hybridq</a></li>
</ol>
<p><a href=""https://arxiv.org/abs/2111.06868"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2111.06868</a></p>
<p>Our question is if such pairs of files representing the noisy and noiseless distribution are publicly available, or could be made available for us.</p>
",qc,simulation files noisy quantum circuits p study yosi rinott tomer shoham need following simple data p starting quantum circuit span c span n qubits need two files p file probabilities amplitudes span bitstrings described ideal circuit span c namely probability distribution span bitstrings described span c p b file probabilities amplitudes span bitstrings described strong noisy version circuit span c noise simply depolarizing noise gates span c forms noise also welcome p need pairs files qubits say since main study google 2019 experiment preferences random circuits even google experimental circuits data circuits also p know data obtained several available simulators ol li google simulators li ibm simulators li nasa simulators given code combines tensor contraction clifford expansion state vector simulation https nofollow noreferrer https p https nofollow noreferrer https p question pairs files representing noisy noiseless distribution publicly available could made available,"[(3, 0.2564911), (4, 0.108111754), (7, 0.05232491), (9, 0.108020894), (14, 0.40939918), (17, 0.06462318)]"
29432,29434.0,2022-12-20 07:36:34,2,134,"<p>Disclaimer: I recently started learning quantum information.</p>
<p>I've been exploring creating the  <span class=""math-container"">$|\Phi^+\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$</span> Bell state (starting with the state <span class=""math-container"">$|00\rangle$</span>).</p>
<p>I know we can apply the <span class=""math-container"">$H$</span> gate to the leftmost qubit, then use the same qubit as a control for the <span class=""math-container"">$CNOT$</span> gate applied on both qubits to entangle them.</p>
<p>Before the <span class=""math-container"">$CNOT$</span> gate is applied, the two qubits have no correlation. They are separable qubits, where one is in a superposition.</p>
<p>So I wonder: Is it necessary, in this case, to apply a first <span class=""math-container"">$CNOT$</span> gate to the two qubits before applying the <span class=""math-container"">$H$</span> gate and the final <span class=""math-container"">$CNOT$</span> that creates the entanglement?</p>
<p>(I know that using both methods will still create the <span class=""math-container"">$|\Phi^+\rangle$</span> Bell state. I just want to find out if it's necessary to create any correlation between the two qubits before performing any operations on them)</p>
","Is it necessary to apply CNOT for the sole purpose of ""establishing a correlation"" between two qubits",<quantum-gate><entanglement><bell-basis>,1,0,,,"Is it necessary to apply CNOT for the sole purpose of ""establishing a correlation"" between two qubits <p>Disclaimer: I recently started learning quantum information.</p>
<p>I've been exploring creating the  <span class=""math-container"">$|\Phi^+\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)$</span> Bell state (starting with the state <span class=""math-container"">$|00\rangle$</span>).</p>
<p>I know we can apply the <span class=""math-container"">$H$</span> gate to the leftmost qubit, then use the same qubit as a control for the <span class=""math-container"">$CNOT$</span> gate applied on both qubits to entangle them.</p>
<p>Before the <span class=""math-container"">$CNOT$</span> gate is applied, the two qubits have no correlation. They are separable qubits, where one is in a superposition.</p>
<p>So I wonder: Is it necessary, in this case, to apply a first <span class=""math-container"">$CNOT$</span> gate to the two qubits before applying the <span class=""math-container"">$H$</span> gate and the final <span class=""math-container"">$CNOT$</span> that creates the entanglement?</p>
<p>(I know that using both methods will still create the <span class=""math-container"">$|\Phi^+\rangle$</span> Bell state. I just want to find out if it's necessary to create any correlation between the two qubits before performing any operations on them)</p>
",qc,necessary apply cnot sole purpose establishing correlation two qubits p disclaimer recently started learning quantum p exploring creating span 1 2 bell state starting state span p know apply span h gate leftmost qubit use qubit control span cnot gate applied qubits entangle p span cnot gate applied two qubits correlation separable qubits one p wonder necessary case apply first span cnot gate two qubits applying span h gate final span cnot creates entanglement p know using methods still create span bell state want find necessary create correlation two qubits performing operations,"[(3, 0.10354059), (7, 0.013121101), (8, 0.117009245), (17, 0.011996154), (18, 0.75268406)]"
29454,29462.0,2022-12-22 08:51:56,2,418,"<p>Quantum computing simulators like <code>qasm_simulator</code> in Qiskit Aer have a function to simulate quantum measurements (for example, the command of <code>execute</code> in case of <code>qasm_simulator</code>). In quantum computing simulators, unlike real quantum computers, the values of the quantum amplitude are already known (to simulators), so I think that there is no need to simulate the process of measurement. I think it would be more efficient to simply inform users of several high-amplitude quantum states rather than to employ the sampling method so that they get the measurement results. <em>(We get the almost same outcomes by the both ways, which is guaranteed by the law of large numbers!)</em></p>
<p>What is the significance of simulating the process of measurement in quantum computing simulators?</p>
",Why do quantum computing simulators have the measurement function?,<qiskit><measurement><simulation>,4,1,,,"Why do quantum computing simulators have the measurement function? <p>Quantum computing simulators like <code>qasm_simulator</code> in Qiskit Aer have a function to simulate quantum measurements (for example, the command of <code>execute</code> in case of <code>qasm_simulator</code>). In quantum computing simulators, unlike real quantum computers, the values of the quantum amplitude are already known (to simulators), so I think that there is no need to simulate the process of measurement. I think it would be more efficient to simply inform users of several high-amplitude quantum states rather than to employ the sampling method so that they get the measurement results. <em>(We get the almost same outcomes by the both ways, which is guaranteed by the law of large numbers!)</em></p>
<p>What is the significance of simulating the process of measurement in quantum computing simulators?</p>
",qc,quantum computing simulators measurement function p quantum computing simulators like code qiskit aer function simulate quantum measurements example command code execute case code quantum computing simulators unlike real quantum computers values quantum amplitude already known simulators think need simulate process measurement think would efficient simply inform users several quantum states rather employ sampling method get measurement results em get almost outcomes ways guaranteed law large numbers p significance simulating process measurement quantum computing simulators,"[(1, 0.22493173), (8, 0.15832725), (9, 0.019838095), (11, 0.027081441), (14, 0.47252816), (17, 0.014365479), (18, 0.08115068)]"
29494,,2022-12-27 23:01:24,4,399,"<p>I guess code distance is the same as &quot;Hamming distance&quot; which is related to the overlap between different &quot;codewords&quot; in the codespace?</p>
<p>More technically, my understanding is that a stabilizer quantum-error-correcting code (QECC) having code distance <span class=""math-container"">$d$</span> implies that any operator <span class=""math-container"">$\mathcal{E}$</span> capable of producing a logical error must have support (i.e., act nontrivially) on at least <span class=""math-container"">$d$</span> qubits? This implies that every logical operator acts nontrivially on at least <span class=""math-container"">$d$</span> qubits.</p>
<p>I'm curious if there are other (equivalent) definitions. Specifically, I'm wondering if the minimum number of errors applies equally to deletion / erasure errors (on at most <span class=""math-container"">$d-1$</span> qubits). However, I guess  deletion errors aren't the same as logical errors (i.e., they don't change between codewords), so you can correct at most <span class=""math-container"">$t = (d-1)/2$</span> of them, so that's the maximum number of deletion errors that can be tolerated?</p>
<p>If so, then I would expect the following statement to hold: Given a QECC with code distance <span class=""math-container"">$d$</span> and nominal logical operators <span class=""math-container"">$\{ \overline{X}, \overline{Y}, \overline{Z}\}$</span>, then for any region <span class=""math-container"">$C$</span> that contains <span class=""math-container"">$\left| C \right| = d-1$</span> qubits (or more likely <span class=""math-container"">$\left| C \right| =  t = (d-1)/2$</span> qubits), there exist elements <span class=""math-container"">$ \mathcal{S}_x $</span>, <span class=""math-container"">$\mathcal{S}_y$</span>, <span class=""math-container"">$\mathcal{S}_z$</span> of the stabilizer group such that <span class=""math-container"">$\{ \mathcal{S}_x \overline{X} , ~\mathcal{S}_y \overline{Y} , ~ \mathcal{S}_z \overline{Z} \}$</span> are also valid logical operators, <em>each</em> of which acts trivially on <em>every</em> qubit in <span class=""math-container"">$C$</span>?</p>
<p>As a bonus question: If this definition <em>is</em> correct, are we guaranteed that the stabilizer elements <span class=""math-container"">$ \mathcal{S}_x $</span>, <span class=""math-container"">$\mathcal{S}_y$</span>, and <span class=""math-container"">$\mathcal{S}_z$</span> are unique (assuming that <span class=""math-container"">$\left| C\right|$</span> is maximal for code distance <span class=""math-container"">$d$</span>)? Do the numbers <span class=""math-container"">$N$</span> and <span class=""math-container"">$k$</span> of physical and logical qubits matter for this?</p>
<p>Also if I just need to open Nielsen and Chuang to a particular section, feel free to let me know! I'll have a copy soon. Also, if you have a random fun fact relating code distance to something else, feel free to comment it, since I'm generally interested.</p>
",Are there other ways to understand/define code distance in stabilizer QEC codes?,<error-correction><stabilizer-code><research>,1,3,,,"Are there other ways to understand/define code distance in stabilizer QEC codes? <p>I guess code distance is the same as &quot;Hamming distance&quot; which is related to the overlap between different &quot;codewords&quot; in the codespace?</p>
<p>More technically, my understanding is that a stabilizer quantum-error-correcting code (QECC) having code distance <span class=""math-container"">$d$</span> implies that any operator <span class=""math-container"">$\mathcal{E}$</span> capable of producing a logical error must have support (i.e., act nontrivially) on at least <span class=""math-container"">$d$</span> qubits? This implies that every logical operator acts nontrivially on at least <span class=""math-container"">$d$</span> qubits.</p>
<p>I'm curious if there are other (equivalent) definitions. Specifically, I'm wondering if the minimum number of errors applies equally to deletion / erasure errors (on at most <span class=""math-container"">$d-1$</span> qubits). However, I guess  deletion errors aren't the same as logical errors (i.e., they don't change between codewords), so you can correct at most <span class=""math-container"">$t = (d-1)/2$</span> of them, so that's the maximum number of deletion errors that can be tolerated?</p>
<p>If so, then I would expect the following statement to hold: Given a QECC with code distance <span class=""math-container"">$d$</span> and nominal logical operators <span class=""math-container"">$\{ \overline{X}, \overline{Y}, \overline{Z}\}$</span>, then for any region <span class=""math-container"">$C$</span> that contains <span class=""math-container"">$\left| C \right| = d-1$</span> qubits (or more likely <span class=""math-container"">$\left| C \right| =  t = (d-1)/2$</span> qubits), there exist elements <span class=""math-container"">$ \mathcal{S}_x $</span>, <span class=""math-container"">$\mathcal{S}_y$</span>, <span class=""math-container"">$\mathcal{S}_z$</span> of the stabilizer group such that <span class=""math-container"">$\{ \mathcal{S}_x \overline{X} , ~\mathcal{S}_y \overline{Y} , ~ \mathcal{S}_z \overline{Z} \}$</span> are also valid logical operators, <em>each</em> of which acts trivially on <em>every</em> qubit in <span class=""math-container"">$C$</span>?</p>
<p>As a bonus question: If this definition <em>is</em> correct, are we guaranteed that the stabilizer elements <span class=""math-container"">$ \mathcal{S}_x $</span>, <span class=""math-container"">$\mathcal{S}_y$</span>, and <span class=""math-container"">$\mathcal{S}_z$</span> are unique (assuming that <span class=""math-container"">$\left| C\right|$</span> is maximal for code distance <span class=""math-container"">$d$</span>)? Do the numbers <span class=""math-container"">$N$</span> and <span class=""math-container"">$k$</span> of physical and logical qubits matter for this?</p>
<p>Also if I just need to open Nielsen and Chuang to a particular section, feel free to let me know! I'll have a copy soon. Also, if you have a random fun fact relating code distance to something else, feel free to comment it, since I'm generally interested.</p>
",qc,ways code distance stabilizer qec codes p guess code distance quot hamming distance quot related overlap different quot codewords quot codespace p technically understanding stabilizer code qecc code distance span implies operator span e capable producing logical error must support act nontrivially least span qubits implies every logical operator acts nontrivially least span p curious equivalent definitions specifically wondering minimum number errors applies equally deletion erasure errors span qubits however guess deletion errors logical errors change codewords correct span maximum number deletion errors tolerated p would expect following statement hold given qecc code distance span nominal logical operators span x z region span c contains span c qubits likely span c qubits exist elements span span span stabilizer group span x z also valid logical operators em acts trivially em every qubit span c p bonus question definition em correct guaranteed stabilizer elements span span span unique assuming span maximal code distance span numbers span n span k physical logical qubits matter p also need open nielsen chuang particular section feel free let know copy soon also random fun fact relating code distance something else feel free comment since generally,"[(3, 0.57301605), (5, 0.31545922), (9, 0.030540759), (17, 0.027317375), (19, 0.05285599)]"
29504,29509.0,2022-12-30 14:26:41,1,106,"<p>In the paper <a href=""https://quantum-journal.org/papers/q-2021-10-19-564/"" rel=""nofollow noreferrer"">&quot;Dynamically Generated Logical Qubits&quot;</a>, The authors state that the stabilizer group includes &quot;two homologically nontrivial cycles
wrapping different directions of the torus&quot;.</p>
<p>If we look at the surface code on an torus, the logical operators <span class=""math-container"">$\hat{X}_L$</span>, <span class=""math-container"">$\hat{Z}_L$</span> are those operators - they wrap the torus in different directions. To my understanding, if we included those operators in the stabilizer group then we have less degrees of freedom, and we could not encode a logical qubit on it.</p>
<p>Why can't we just do the same on the honeycomb code? If we don't include these operators in the stabilizer group for the honeycomb code, can we get a degree of freedom that can be used for a logical qubit?</p>
",Choosing stabilizers on the honeycomb code,<error-correction><surface-code>,1,0,,,"Choosing stabilizers on the honeycomb code <p>In the paper <a href=""https://quantum-journal.org/papers/q-2021-10-19-564/"" rel=""nofollow noreferrer"">&quot;Dynamically Generated Logical Qubits&quot;</a>, The authors state that the stabilizer group includes &quot;two homologically nontrivial cycles
wrapping different directions of the torus&quot;.</p>
<p>If we look at the surface code on an torus, the logical operators <span class=""math-container"">$\hat{X}_L$</span>, <span class=""math-container"">$\hat{Z}_L$</span> are those operators - they wrap the torus in different directions. To my understanding, if we included those operators in the stabilizer group then we have less degrees of freedom, and we could not encode a logical qubit on it.</p>
<p>Why can't we just do the same on the honeycomb code? If we don't include these operators in the stabilizer group for the honeycomb code, can we get a degree of freedom that can be used for a logical qubit?</p>
",qc,choosing stabilizers honeycomb code p paper https nofollow noreferrer quot dynamically generated logical qubits quot authors state stabilizer group includes quot two homologically nontrivial cycles wrapping different directions torus quot p look surface code torus logical operators span x span z operators wrap torus different directions understanding included operators stabilizer group less degrees freedom could encode logical qubit p ca honeycomb code include operators stabilizer group honeycomb code get degree freedom used logical qubit,"[(3, 0.13096403), (5, 0.473115), (9, 0.29033628), (17, 0.043118868), (19, 0.060407568)]"
29551,,2023-01-03 20:46:48,2,196,"<p>Grover's algorithm circuit may be implemented as follows:</p>
<p><a href=""https://i.sstatic.net/fAG8P.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fAG8P.png"" alt=""enter image description here"" /></a></p>
<p>(from <a href=""https://quantumcomputinguk.org/tutorials/grovers-algorithm-with-code"" rel=""nofollow noreferrer"">here</a>)</p>
<p>It is shown very elegantly by @MartinVesely (<a href=""https://quantumcomputing.stackexchange.com/questions/9614/how-to-interpret-a-4-qubit-quantum-circuit-as-a-matrix"">How to interpret a 4 qubit quantum circuit as a matrix?</a>) how to translate a 4 qubit circuit into its complete matrix representation.</p>
<p>Building on the previous question, I would like translate the full Grover's ciruit into a single state matrix. I attempted as follows:</p>
<p><strong>Op 1</strong>: <span class=""math-container"">$H \otimes H \otimes H \otimes H$</span></p>
<p><strong>Op 2</strong>: <span class=""math-container"">$X \otimes X \otimes X \otimes X$</span></p>
<p><strong>Op 3</strong>: ?</p>
<p><strong>Op 4</strong>: <span class=""math-container"">$CNOT \otimes I \otimes I$</span></p>
<p><strong>Op 5</strong>: ?</p>
<p><strong>...</strong></p>
<p>Does anyone know how to correctly translate operation 3 and operation 5 in particular into its state matrix, please?</p>
",How to translate a 4-qubit Grover's algorithm circuit into a state Matrix?,<circuit-construction><quantum-circuit><grovers-algorithm><density-matrix><matrix-representation>,2,3,,,"How to translate a 4-qubit Grover's algorithm circuit into a state Matrix? <p>Grover's algorithm circuit may be implemented as follows:</p>
<p><a href=""https://i.sstatic.net/fAG8P.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fAG8P.png"" alt=""enter image description here"" /></a></p>
<p>(from <a href=""https://quantumcomputinguk.org/tutorials/grovers-algorithm-with-code"" rel=""nofollow noreferrer"">here</a>)</p>
<p>It is shown very elegantly by @MartinVesely (<a href=""https://quantumcomputing.stackexchange.com/questions/9614/how-to-interpret-a-4-qubit-quantum-circuit-as-a-matrix"">How to interpret a 4 qubit quantum circuit as a matrix?</a>) how to translate a 4 qubit circuit into its complete matrix representation.</p>
<p>Building on the previous question, I would like translate the full Grover's ciruit into a single state matrix. I attempted as follows:</p>
<p><strong>Op 1</strong>: <span class=""math-container"">$H \otimes H \otimes H \otimes H$</span></p>
<p><strong>Op 2</strong>: <span class=""math-container"">$X \otimes X \otimes X \otimes X$</span></p>
<p><strong>Op 3</strong>: ?</p>
<p><strong>Op 4</strong>: <span class=""math-container"">$CNOT \otimes I \otimes I$</span></p>
<p><strong>Op 5</strong>: ?</p>
<p><strong>...</strong></p>
<p>Does anyone know how to correctly translate operation 3 and operation 5 in particular into its state matrix, please?</p>
",qc,translate grover algorithm circuit state matrix p grover algorithm circuit may implemented follows p https nofollow noreferrer img https enter image description p https nofollow noreferrer p shown elegantly martinvesely https interpret 4 qubit quantum circuit matrix translate 4 qubit circuit complete matrix p building previous question would like translate full grover ciruit single state matrix attempted follows p strong op 1 span h h h h p strong op 2 span x x x x p strong op 3 p strong op 4 span cnot p strong op 5 p strong p anyone know correctly translate operation 3 operation 5 particular state matrix please,"[(4, 0.40841702), (6, 0.104869485), (8, 0.096239425), (10, 0.06700786), (11, 0.049765594), (17, 0.054154046), (18, 0.21827428)]"
29592,29607.0,2023-01-06 15:26:43,2,520,"<p>I have trouble recreating the graphs shown in this paper
<a href=""https://arxiv.org/pdf/quant-ph/0508176.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/quant-ph/0508176.pdf</a>
i.e. the quadratic trend of the logical error against physical single qubit error for [7,1,3] code</p>
<p>I attempted to do the simplest case, the logical error rate graph for a transversal H gate and wrote the following piece of quantum circuit with qiskit,</p>
<pre><code> lz = ['0000000', '1010101', '1100110', '0110011',
      '1111000', '0101101', '0011110', '1001011']

for ind, pi in enumerate(p):
    error_1 = noise.depolarizing_error(4 * pi / 3, 1)
    error_2 = noise.depolarizing_error(16 * pi / 15, 2)
    nm = noise.NoiseModel()
    nm.add_all_qubit_quantum_error(error_1, ['id', 'h'])

    s = 0
    fid = 0
    for i in tqdm(range(n)):
        lq = QuantumRegister(7)
        x_anc = QuantumRegister(3)
        z_anc = QuantumRegister(3)
        x_syn = ClassicalRegister(3)
        z_syn = ClassicalRegister(3)
        qc = QuantumCircuit(x_anc, z_anc, lq, x_syn, z_syn)

        # prepare a logical 0 state as in [AGP05][1]
        perf_qc_0(qc, lq)
        # to compute threshold of transversal H gate
        qc.h(lq)

        EC(qc, x_anc, z_anc, lq, x_syn, z_syn)

        # append a noiseless transversal H as reverse operation
        qc.append(h_nl, [lq])
        qc.measure_all()

        run = backend.run(qc, noise_model=nm, shots=1).result() #
        mmt = list(run.get_counts().keys())[0]

        # if measurement returns to space spanned by logical 0 components, accept
        if (mmt[:7] in lz):
            s += 1

    le[ind] = 1-s/n
    print(&quot;logical error rate is {}&quot;.format(le[ind]))
</code></pre>
<p>The error correction gadget I have is</p>
<pre><code>def EC(qc, x_anc, z_anc, lq, x_syn, z_syn):
# Syndrome measurements
qc.h(x_anc)
qc.h(z_anc)

qc.cx(z_anc[2], [lq[i - 1] for i in [4, 5, 6, 7]])
qc.cx(z_anc[1], [lq[i - 1] for i in [2, 3, 6, 7]])
qc.cx(z_anc[0], [lq[i - 1] for i in [1, 3, 5, 7]])

qc.cz(x_anc[2], [lq[i - 1] for i in [4, 5, 6, 7]])
qc.cz(x_anc[1], [lq[i - 1] for i in [2, 3, 6, 7]])
qc.cz(x_anc[0], [lq[i - 1] for i in [1, 3, 5, 7]])

qc.h(x_anc)
qc.h(z_anc)
qc.measure(x_anc, x_syn)
qc.measure(z_anc, z_syn)

# Apply correction X gates
for i in range(1,8):
    qc.x(lq[i-1]).c_if(x_syn, i)

# Apply correction Z gates
for i in range(1,8):
    qc.z(lq[i-1]).c_if(z_syn, i)
</code></pre>
<p>The graph I obtain is more of a linear trend for some reason ...</p>
<p>I must have done something wrong but I can't see where. I'm still quite new to QECC so thanks if you can help!!</p>
<p>Update: I found that Stim is a library specifically for QECC, however I'm not sure how to implement Steane code with correct decoder in pymatching. Anyone can help?</p>
",Estimate of threshold values for 7-qubit Steane code with qiskit (or stim),<qiskit><error-correction><stabilizer-code><stim><fault-tolerance>,1,2,,,"Estimate of threshold values for 7-qubit Steane code with qiskit (or stim) <p>I have trouble recreating the graphs shown in this paper
<a href=""https://arxiv.org/pdf/quant-ph/0508176.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/quant-ph/0508176.pdf</a>
i.e. the quadratic trend of the logical error against physical single qubit error for [7,1,3] code</p>
<p>I attempted to do the simplest case, the logical error rate graph for a transversal H gate and wrote the following piece of quantum circuit with qiskit,</p>
<pre><code> lz = ['0000000', '1010101', '1100110', '0110011',
      '1111000', '0101101', '0011110', '1001011']

for ind, pi in enumerate(p):
    error_1 = noise.depolarizing_error(4 * pi / 3, 1)
    error_2 = noise.depolarizing_error(16 * pi / 15, 2)
    nm = noise.NoiseModel()
    nm.add_all_qubit_quantum_error(error_1, ['id', 'h'])

    s = 0
    fid = 0
    for i in tqdm(range(n)):
        lq = QuantumRegister(7)
        x_anc = QuantumRegister(3)
        z_anc = QuantumRegister(3)
        x_syn = ClassicalRegister(3)
        z_syn = ClassicalRegister(3)
        qc = QuantumCircuit(x_anc, z_anc, lq, x_syn, z_syn)

        # prepare a logical 0 state as in [AGP05][1]
        perf_qc_0(qc, lq)
        # to compute threshold of transversal H gate
        qc.h(lq)

        EC(qc, x_anc, z_anc, lq, x_syn, z_syn)

        # append a noiseless transversal H as reverse operation
        qc.append(h_nl, [lq])
        qc.measure_all()

        run = backend.run(qc, noise_model=nm, shots=1).result() #
        mmt = list(run.get_counts().keys())[0]

        # if measurement returns to space spanned by logical 0 components, accept
        if (mmt[:7] in lz):
            s += 1

    le[ind] = 1-s/n
    print(&quot;logical error rate is {}&quot;.format(le[ind]))
</code></pre>
<p>The error correction gadget I have is</p>
<pre><code>def EC(qc, x_anc, z_anc, lq, x_syn, z_syn):
# Syndrome measurements
qc.h(x_anc)
qc.h(z_anc)

qc.cx(z_anc[2], [lq[i - 1] for i in [4, 5, 6, 7]])
qc.cx(z_anc[1], [lq[i - 1] for i in [2, 3, 6, 7]])
qc.cx(z_anc[0], [lq[i - 1] for i in [1, 3, 5, 7]])

qc.cz(x_anc[2], [lq[i - 1] for i in [4, 5, 6, 7]])
qc.cz(x_anc[1], [lq[i - 1] for i in [2, 3, 6, 7]])
qc.cz(x_anc[0], [lq[i - 1] for i in [1, 3, 5, 7]])

qc.h(x_anc)
qc.h(z_anc)
qc.measure(x_anc, x_syn)
qc.measure(z_anc, z_syn)

# Apply correction X gates
for i in range(1,8):
    qc.x(lq[i-1]).c_if(x_syn, i)

# Apply correction Z gates
for i in range(1,8):
    qc.z(lq[i-1]).c_if(z_syn, i)
</code></pre>
<p>The graph I obtain is more of a linear trend for some reason ...</p>
<p>I must have done something wrong but I can't see where. I'm still quite new to QECC so thanks if you can help!!</p>
<p>Update: I found that Stim is a library specifically for QECC, however I'm not sure how to implement Steane code with correct decoder in pymatching. Anyone can help?</p>
",qc,estimate threshold values steane code qiskit stim p trouble recreating graphs shown paper https nofollow noreferrer https quadratic trend logical error physical single qubit error code p attempted simplest case logical error rate graph transversal h gate wrote following piece quantum circuit qiskit pre code lz ind pi enumerate p 4 pi 3 1 16 pi 15 2 nm h 0 fid 0 tqdm range n lq quantumregister 7 quantumregister 3 quantumregister 3 classicalregister 3 classicalregister 3 qc quantumcircuit lq prepare logical 0 state agp05 1 qc lq compute threshold transversal h gate lq ec qc lq append noiseless transversal h reverse operation lq run qc mmt list 0 measurement returns space spanned logical 0 components accept mmt lz 1 le ind print quot logical error rate quot le ind p error correction gadget pre code def ec qc lq syndrome measurements 2 lq 1 4 5 6 7 1 lq 1 2 3 6 7 0 lq 1 1 3 5 7 2 lq 1 4 5 6 7 1 lq 1 2 3 6 7 0 lq 1 1 3 5 7 apply correction x gates range lq apply correction z gates range lq p graph obtain linear trend reason p must done something wrong ca see still quite new qecc thanks help p update found stim library specifically qecc however sure implement steane code correct decoder pymatching anyone help,"[(0, 0.1949594), (2, 0.12254302), (3, 0.04550108), (4, 0.041371208), (5, 0.23908831), (6, 0.16452488), (13, 0.019833418), (14, 0.14701955), (17, 0.016973538)]"
29617,,2023-01-09 08:00:07,0,373,"<p>Id like to decompose root iswap gate into root cz (not cz or cx) and single-qubit gates.</p>
<p>1)Is it possible to decompose like that?</p>
<p>2)Is there a way to do such a decomposition with qiskit, qutip, etc.?</p>
",How to decompose root iswap into root cz and single-qubit gates,<quantum-gate><circuit-construction>,1,0,,,"How to decompose root iswap into root cz and single-qubit gates <p>Id like to decompose root iswap gate into root cz (not cz or cx) and single-qubit gates.</p>
<p>1)Is it possible to decompose like that?</p>
<p>2)Is there a way to do such a decomposition with qiskit, qutip, etc.?</p>
",qc,decompose root iswap root cz gates p id like decompose root iswap gate root cz cz cx p 1 possible decompose like p 2 way decomposition qiskit qutip etc,"[(6, 0.1637304), (9, 0.4324796), (11, 0.17694712), (14, 0.18651004), (17, 0.035195064)]"
29650,29726.0,2023-01-11 09:06:23,1,402,"<p>I am  master student currently working on a project using the IBMQ platform with qiskit. We are using the available quantum hardware with the processor type Falcon r5.11.</p>
<p>We would like to have a better understanding of the circuits we have composed and how it is really implemented onto the quantum computers. For the processor mentioned above, the basis gates are:</p>
<p>CX, ID, IF_ELSE, RZ, SX, and X.</p>
<p>Since we are able to compose in qiskit any quantum gate, I believe that these 6 gates complete a universal set, and therefore any gate can be composed by a combination of the basis gates above.</p>
<p>Can anyone please tell me what this <strong>IF_ELSE</strong> basis gate is?
What does it look like in matrix form?</p>
<p>Any input is appreciated, thank you in advance!</p>
",What is the IF_ELSE basis gate of the processor type Falcon r5.11 on the IBM Quantum platform?,<qiskit><universal-gates><ibm-quantum-devices>,3,0,,,"What is the IF_ELSE basis gate of the processor type Falcon r5.11 on the IBM Quantum platform? <p>I am  master student currently working on a project using the IBMQ platform with qiskit. We are using the available quantum hardware with the processor type Falcon r5.11.</p>
<p>We would like to have a better understanding of the circuits we have composed and how it is really implemented onto the quantum computers. For the processor mentioned above, the basis gates are:</p>
<p>CX, ID, IF_ELSE, RZ, SX, and X.</p>
<p>Since we are able to compose in qiskit any quantum gate, I believe that these 6 gates complete a universal set, and therefore any gate can be composed by a combination of the basis gates above.</p>
<p>Can anyone please tell me what this <strong>IF_ELSE</strong> basis gate is?
What does it look like in matrix form?</p>
<p>Any input is appreciated, thank you in advance!</p>
",qc,basis gate processor type falcon ibm quantum platform p master student currently working project using ibmq platform qiskit using available quantum hardware processor type falcon p would like better understanding circuits composed really implemented onto quantum computers processor mentioned basis gates p cx id rz sx p since able compose qiskit quantum gate believe 6 gates complete universal set therefore gate composed combination basis gates p anyone please tell strong basis gate look like matrix form p input appreciated thank advance,"[(6, 0.021351717), (8, 0.3267398), (9, 0.17333768), (11, 0.040052567), (14, 0.42343074), (17, 0.013319484)]"
29658,29678.0,2023-01-11 15:33:15,3,87,"<p>I am interested in looking into histogram distributions of decoder timing for different syndrome inputs (sourced from stim) into pymatching. Unfortunately, it seems the histograms I product are more a function of how my PC runs the simulations vs actual differences in how pymatching handles different syndrome inputs. As an example, I produced two overlaid timing histograms below to show what I am talking about.</p>
<p><a href=""https://i.sstatic.net/zn2sp.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zn2sp.png"" alt=""enter image description here"" /></a></p>
<p>Orange shows decoding times for <em>different</em> stim output syndromes, while blue shows the decoding times for decoding the <em>same</em> syndrome data over and over. Given the very close agreement, it seems that any data I get with how I am doing this tells me absolutely nothing about the syndrome input's effect on decoding times.</p>
<p>I am wondering if anyone knows why this is happening. Maybe a problem with my implementation? Does pymatching use some randomness in its decoding process? Maybe to select the first root to start an alternating tree. If so is it possible to define a seed? Maybe relying on python for such sensitive timing was doomed to fail from the start.</p>
<p>Here is the code used to generate the data above, changing the distance or error rate input changes the exact distribution, but the agreement is always quite good with rare exception. There is a chance of getting an syndrome set that is actually more difficult to decode, and if that is the first shot of the sampler then the blue distribution can be shifted to higher times.</p>
<pre><code># Inputs
distance = 11
reps = 11
shots = 1000000
noise = 1e-3

# Define circuit and matching graph
circuit = stim.Circuit.generated(
    'surface_code:rotated_memory_z',
    rounds=reps,
    distance=distance,
    after_clifford_depolarization=noise,
    after_reset_flip_probability=noise,
    before_measure_flip_probability=noise,
    before_round_data_depolarization=noise
)
error_model = circuit.detector_error_model(decompose_errors=True)
match = pm.Matching.from_detector_error_model(error_model)

# Sample results
sampler = circuit.compile_detector_sampler()
syndromes, observables = sampler.sample(shots, separate_observables=True)
int_syndromes = np.array(syndromes).astype(dtype='uint8')

# Decoding number of shots
times_same_data, times_different_data = [], []
for s in range(shots):
    same_start = time.time()
    match.decode(int_syndromes[0])
    same_end = time.time()
    times_same_data.append(same_end - same_start)

    different_start = time.time()
    match.decode(int_syndromes[s])
    different_end = time.time()
    times_different_data.append(different_end - different_start)
</code></pre>
",Pymatching shows a large timing distribution to decode the same set of syndromes,<pymatching>,1,0,,,"Pymatching shows a large timing distribution to decode the same set of syndromes <p>I am interested in looking into histogram distributions of decoder timing for different syndrome inputs (sourced from stim) into pymatching. Unfortunately, it seems the histograms I product are more a function of how my PC runs the simulations vs actual differences in how pymatching handles different syndrome inputs. As an example, I produced two overlaid timing histograms below to show what I am talking about.</p>
<p><a href=""https://i.sstatic.net/zn2sp.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zn2sp.png"" alt=""enter image description here"" /></a></p>
<p>Orange shows decoding times for <em>different</em> stim output syndromes, while blue shows the decoding times for decoding the <em>same</em> syndrome data over and over. Given the very close agreement, it seems that any data I get with how I am doing this tells me absolutely nothing about the syndrome input's effect on decoding times.</p>
<p>I am wondering if anyone knows why this is happening. Maybe a problem with my implementation? Does pymatching use some randomness in its decoding process? Maybe to select the first root to start an alternating tree. If so is it possible to define a seed? Maybe relying on python for such sensitive timing was doomed to fail from the start.</p>
<p>Here is the code used to generate the data above, changing the distance or error rate input changes the exact distribution, but the agreement is always quite good with rare exception. There is a chance of getting an syndrome set that is actually more difficult to decode, and if that is the first shot of the sampler then the blue distribution can be shifted to higher times.</p>
<pre><code># Inputs
distance = 11
reps = 11
shots = 1000000
noise = 1e-3

# Define circuit and matching graph
circuit = stim.Circuit.generated(
    'surface_code:rotated_memory_z',
    rounds=reps,
    distance=distance,
    after_clifford_depolarization=noise,
    after_reset_flip_probability=noise,
    before_measure_flip_probability=noise,
    before_round_data_depolarization=noise
)
error_model = circuit.detector_error_model(decompose_errors=True)
match = pm.Matching.from_detector_error_model(error_model)

# Sample results
sampler = circuit.compile_detector_sampler()
syndromes, observables = sampler.sample(shots, separate_observables=True)
int_syndromes = np.array(syndromes).astype(dtype='uint8')

# Decoding number of shots
times_same_data, times_different_data = [], []
for s in range(shots):
    same_start = time.time()
    match.decode(int_syndromes[0])
    same_end = time.time()
    times_same_data.append(same_end - same_start)

    different_start = time.time()
    match.decode(int_syndromes[s])
    different_end = time.time()
    times_different_data.append(different_end - different_start)
</code></pre>
",qc,pymatching shows large timing distribution decode set syndromes p interested looking histogram distributions decoder timing different syndrome inputs sourced stim pymatching unfortunately seems histograms product function pc runs simulations vs actual differences pymatching handles different syndrome inputs example produced two overlaid timing histograms show talking p https nofollow noreferrer img https enter image description p orange shows decoding times em different stim output syndromes blue shows decoding times decoding em syndrome data given close agreement seems data get tells absolutely nothing syndrome input effect decoding p wondering anyone knows happening maybe problem implementation pymatching use randomness decoding process maybe select first root start alternating tree possible define seed maybe relying python sensitive timing doomed fail p code used generate data changing distance error rate input changes exact distribution agreement always quite good rare exception chance getting syndrome set actually difficult decode first shot sampler blue distribution shifted higher pre code inputs distance 11 reps 11 shots 1000000 noise define circuit matching graph circuit match sample results sampler syndromes observables shots syndromes decoding number shots range shots 0,"[(0, 0.026194593), (4, 0.10258243), (5, 0.21698573), (6, 0.038144954), (8, 0.061625857), (13, 0.021267563), (14, 0.4524334), (17, 0.041374292), (18, 0.032750458)]"
29666,,2023-01-11 22:57:22,1,239,"<p>I've been coding QECC with qiskit recently. As I'm not very skilled in programming I encountered a lot of questions.</p>
<p>Now I'm trying to generate the logical error rate against physical error rate graph using qiskit. If I understand correctly, a logical error is one that anticommutes with logical operators, e.g. for the 7-qubit Steane code, X^7 and Z^7.</p>
<p>When I checked out other people's codes, they generally apply Pauli errors to gates, and track the propagation, at the end of the QECC circuit they obtain a Pauli operator, then check if it commutes with logical X and Z.</p>
<p>But for Qiskit this cannot be done ... what I'm getting is a statevector instead of specific error operator. How do I obtain logical error rate in this case?</p>
",Logical error rate for QECC using qiskit,<qiskit><error-correction><fault-tolerance>,1,0,,,"Logical error rate for QECC using qiskit <p>I've been coding QECC with qiskit recently. As I'm not very skilled in programming I encountered a lot of questions.</p>
<p>Now I'm trying to generate the logical error rate against physical error rate graph using qiskit. If I understand correctly, a logical error is one that anticommutes with logical operators, e.g. for the 7-qubit Steane code, X^7 and Z^7.</p>
<p>When I checked out other people's codes, they generally apply Pauli errors to gates, and track the propagation, at the end of the QECC circuit they obtain a Pauli operator, then check if it commutes with logical X and Z.</p>
<p>But for Qiskit this cannot be done ... what I'm getting is a statevector instead of specific error operator. How do I obtain logical error rate in this case?</p>
",qc,logical error rate qecc using qiskit p coding qecc qiskit recently skilled programming encountered lot p trying generate logical error rate physical error rate graph using qiskit understand correctly logical error one anticommutes logical operators steane code p checked people codes generally apply pauli errors gates track propagation end qecc circuit obtain pauli operator check commutes logical x p qiskit done getting statevector instead specific error operator obtain logical error rate case,"[(5, 0.6054748), (8, 0.050362013), (9, 0.019576883), (14, 0.2784934), (17, 0.04398468)]"
29672,31525.0,2023-01-12 11:57:33,3,90,"<p>For a density matrix <span class=""math-container"">$\hat \rho$</span>, one can construct a &quot;Bell operator&quot; <span class=""math-container"">$\hat B$</span>, such that the violation of the inequality <span class=""math-container"">$\langle \hat B \rangle \le 2$</span> is a clear indication of quantum correlations (entanglement) in the system.</p>
<p>Let's call the expectation of the Bell operator <span class=""math-container"">$(\langle \hat B \rangle)$</span> the &quot;Bell value.&quot; The maximum Bell value possible is <span class=""math-container"">$2 \sqrt{2}$</span>.</p>
<p>Suppose some state <span class=""math-container"">$\hat \rho$</span> has the Bell value, say <span class=""math-container"">$2.7$</span>, and some other state <span class=""math-container"">$\hat \rho'$</span> has the Bell value <span class=""math-container"">$2.3$</span>. What exactly can we conclude from the fact that the Bell value of one state is higher than the other? In particular, is there an advantage in using one over the other (potentially for some quantum communication task)?</p>
",Is it advantageous for a state to have higher Bell CHSH violation?,<entanglement><communication><bell-experiment>,1,1,,,"Is it advantageous for a state to have higher Bell CHSH violation? <p>For a density matrix <span class=""math-container"">$\hat \rho$</span>, one can construct a &quot;Bell operator&quot; <span class=""math-container"">$\hat B$</span>, such that the violation of the inequality <span class=""math-container"">$\langle \hat B \rangle \le 2$</span> is a clear indication of quantum correlations (entanglement) in the system.</p>
<p>Let's call the expectation of the Bell operator <span class=""math-container"">$(\langle \hat B \rangle)$</span> the &quot;Bell value.&quot; The maximum Bell value possible is <span class=""math-container"">$2 \sqrt{2}$</span>.</p>
<p>Suppose some state <span class=""math-container"">$\hat \rho$</span> has the Bell value, say <span class=""math-container"">$2.7$</span>, and some other state <span class=""math-container"">$\hat \rho'$</span> has the Bell value <span class=""math-container"">$2.3$</span>. What exactly can we conclude from the fact that the Bell value of one state is higher than the other? In particular, is there an advantage in using one over the other (potentially for some quantum communication task)?</p>
",qc,advantageous state higher bell chsh violation p density matrix span one construct quot bell operator quot span b violation inequality span b 2 clear indication quantum correlations entanglement p let call expectation bell operator span b quot bell quot maximum bell value possible span 2 2 p suppose state span bell value say span state span bell value span exactly conclude fact bell value one state higher particular advantage using one potentially quantum communication task,"[(3, 0.4136661), (7, 0.02367732), (11, 0.03683165), (17, 0.035197485), (18, 0.41608322), (19, 0.07265683)]"
29690,29696.0,2023-01-14 19:21:11,0,290,"<p>In Qiskit's <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">VQE tutorial</a>, the FreezeCoreTransformer is used and some orbitals are removed. In the particular case of LiH, they remove [-2,-3] orbitals. Why are the orbitals indexed in this way? How can I choose the unoccupied orbitals for other molecules just as NaH or BeH2?</p>
<p>Sincerely,</p>
<p>Maria Gabriela</p>
",Remove Orbitals in FreezeCoreTransformer (qiskit),<qiskit><vqe><chemistry>,1,0,,,"Remove Orbitals in FreezeCoreTransformer (qiskit) <p>In Qiskit's <a href=""https://qiskit.org/textbook/ch-applications/vqe-molecules.html"" rel=""nofollow noreferrer"">VQE tutorial</a>, the FreezeCoreTransformer is used and some orbitals are removed. In the particular case of LiH, they remove [-2,-3] orbitals. Why are the orbitals indexed in this way? How can I choose the unoccupied orbitals for other molecules just as NaH or BeH2?</p>
<p>Sincerely,</p>
<p>Maria Gabriela</p>
",qc,remove orbitals freezecoretransformer qiskit p qiskit https nofollow noreferrer vqe tutorial freezecoretransformer used orbitals removed particular case lih remove orbitals orbitals indexed way choose unoccupied orbitals molecules nah beh2 p sincerely p maria gabriela,"[(4, 0.4274276), (6, 0.03464106), (8, 0.1854552), (9, 0.0686707), (10, 0.036676425), (14, 0.17480648), (17, 0.067856796)]"
29691,,2023-01-14 19:42:38,2,61,"<p>State fidelity is the most used measure to compute similarity of input and output states in articles dealing with a quantum teleportation.</p>
<p>For my research, I would like to know whether are there references that use trace distance to calculate quality in the teleportation?</p>
",References that use trace distance to calculate quality of teleportation,<resource-request><teleportation><trace-distance>,0,3,,,"References that use trace distance to calculate quality of teleportation <p>State fidelity is the most used measure to compute similarity of input and output states in articles dealing with a quantum teleportation.</p>
<p>For my research, I would like to know whether are there references that use trace distance to calculate quality in the teleportation?</p>
",qc,references use trace distance calculate quality teleportation p state fidelity used measure compute similarity input output states articles dealing quantum p research would like know whether references use trace distance calculate quality teleportation,"[(1, 0.07092254), (7, 0.28215963), (11, 0.07519306), (14, 0.25488183), (17, 0.05976819), (18, 0.25285637)]"
29717,29718.0,2023-01-16 18:54:05,4,423,"<p>Consider the single qubit depolarizing noise channel given by</p>
<p><span class=""math-container"">$$\Phi(\rho) = \frac{\lambda}{d} \mathbb{I}  + (1- \lambda) \rho.$$</span></p>
<p>What might be the adjoint <span class=""math-container"">$\Phi^{*}(\cdot)$</span> of this channel? In particular, I am trying to find how the adjoint acts on standard basis states <span class=""math-container"">$|0\rangle\langle 0|$</span> and <span class=""math-container"">$|1\rangle\langle 1|$</span>.</p>
",What is the adjoint of the depolarizing channel?,<quantum-operation><density-matrix><depolarizing-channel>,1,0,,,"What is the adjoint of the depolarizing channel? <p>Consider the single qubit depolarizing noise channel given by</p>
<p><span class=""math-container"">$$\Phi(\rho) = \frac{\lambda}{d} \mathbb{I}  + (1- \lambda) \rho.$$</span></p>
<p>What might be the adjoint <span class=""math-container"">$\Phi^{*}(\cdot)$</span> of this channel? In particular, I am trying to find how the adjoint acts on standard basis states <span class=""math-container"">$|0\rangle\langle 0|$</span> and <span class=""math-container"">$|1\rangle\langle 1|$</span>.</p>
",qc,adjoint depolarizing channel p consider single qubit depolarizing noise channel given p span p might adjoint span channel particular trying find adjoint acts standard basis states span span,"[(3, 0.8285608), (14, 0.092209235), (17, 0.07320055)]"
29808,38648.0,2023-01-22 18:43:02,1,142,"<p>Is there an open source color code decoder available somewhere?</p>
<p>For the surface code there's pymatching, for the color code there's...?</p>
",Open source color code decoder,<resource-request>,1,1,,,"Open source color code decoder <p>Is there an open source color code decoder available somewhere?</p>
<p>For the surface code there's pymatching, for the color code there's...?</p>
",qc,open source color code decoder p open source color code decoder available somewhere p surface code pymatching color code,"[(5, 0.57850665), (13, 0.22026773), (17, 0.19237027)]"
29815,,2023-01-23 10:27:46,2,93,"<p>I am trying to implement QAOA for graph coloring with hard constraints. In <a href=""https://core.ac.uk/download/pdf/227725576.pdf"" rel=""nofollow noreferrer"">this paper</a>, eq. 9 a custom mixer is proposed, is looks like this:</p>
<p><span class=""math-container"">$B_{ui} = \frac{1}{2^{l + 1}}(X_{u0}X_{u1} + Y_{u0}Y_{u1}) \prod_{j=1}^l(I + Z_{v_ji})$</span>.</p>
<p><span class=""math-container"">$l$</span> is the number of neighboring nodes, u - the node, i - the color. And I think, there is a mistake, and <span class=""math-container"">$i$</span> should be instead of ones. As I understand, new mixer unitary is this:</p>
<p><span class=""math-container"">$\hat{U}_M = \prod_{u, i} e^{-i\frac{a}{2^{l+1}}X_{u0}X_{u1}\prod_{j=1}^l(I + Z_{v_ji})}e^{-i\frac{a}{2^{l+1}}Y_{u0}Y_{u1}\prod_{j=1}^l(I + Z_{v_ji})}$</span></p>
<p>How to implement this on qiskit? Are there any tips, examples or advice?</p>
<p>I know how to implement terms which are products of Pauli gates such as <span class=""math-container"">$Z_iZ_kY_j$</span> or something like it, but I have no idea, how to write product in general, especially when <span class=""math-container"">$I$</span> is involved.</p>
<p>I have found a <a href=""https://quantumcomputing.stackexchange.com/questions/13992/custom-mixer-for-qaoa-error-operator-object-has-no-attribute-primitive-strin"">question</a>, which shed light on how to implement custom mixers, but I still don't quite understand.</p>
<p><a href=""https://lucaman99.github.io/new_blog/2020/mar16.html"" rel=""nofollow noreferrer"">A blog post</a> could be helpful, investigating. Not exactly, there are solutions for exact number of nodes, which I might try.</p>
","Custom Mixer for QAOA for Graph Coloring, where to start?",<qiskit><programming><qaoa>,0,0,,,"Custom Mixer for QAOA for Graph Coloring, where to start? <p>I am trying to implement QAOA for graph coloring with hard constraints. In <a href=""https://core.ac.uk/download/pdf/227725576.pdf"" rel=""nofollow noreferrer"">this paper</a>, eq. 9 a custom mixer is proposed, is looks like this:</p>
<p><span class=""math-container"">$B_{ui} = \frac{1}{2^{l + 1}}(X_{u0}X_{u1} + Y_{u0}Y_{u1}) \prod_{j=1}^l(I + Z_{v_ji})$</span>.</p>
<p><span class=""math-container"">$l$</span> is the number of neighboring nodes, u - the node, i - the color. And I think, there is a mistake, and <span class=""math-container"">$i$</span> should be instead of ones. As I understand, new mixer unitary is this:</p>
<p><span class=""math-container"">$\hat{U}_M = \prod_{u, i} e^{-i\frac{a}{2^{l+1}}X_{u0}X_{u1}\prod_{j=1}^l(I + Z_{v_ji})}e^{-i\frac{a}{2^{l+1}}Y_{u0}Y_{u1}\prod_{j=1}^l(I + Z_{v_ji})}$</span></p>
<p>How to implement this on qiskit? Are there any tips, examples or advice?</p>
<p>I know how to implement terms which are products of Pauli gates such as <span class=""math-container"">$Z_iZ_kY_j$</span> or something like it, but I have no idea, how to write product in general, especially when <span class=""math-container"">$I$</span> is involved.</p>
<p>I have found a <a href=""https://quantumcomputing.stackexchange.com/questions/13992/custom-mixer-for-qaoa-error-operator-object-has-no-attribute-primitive-strin"">question</a>, which shed light on how to implement custom mixers, but I still don't quite understand.</p>
<p><a href=""https://lucaman99.github.io/new_blog/2020/mar16.html"" rel=""nofollow noreferrer"">A blog post</a> could be helpful, investigating. Not exactly, there are solutions for exact number of nodes, which I might try.</p>
",qc,custom mixer qaoa graph coloring start p trying implement qaoa graph coloring hard constraints https nofollow noreferrer paper eq 9 custom mixer proposed looks like p span ui 1 l 1 u0 u1 u0 u1 p span l number neighboring nodes u node color think mistake span instead ones understand new mixer unitary p span u u u0 u1 u0 u1 p implement qiskit tips examples advice p know implement terms products pauli gates span something like idea write product general especially span p found https question shed light implement custom mixers still quite p https nofollow noreferrer blog post could helpful investigating exactly solutions exact number nodes might,"[(3, 0.2391573), (4, 0.09042041), (5, 0.074291244), (6, 0.01890949), (7, 0.046201378), (8, 0.1328919), (9, 0.09980505), (13, 0.13539256), (14, 0.08397213), (17, 0.078033134)]"
29821,29828.0,2023-01-23 18:04:47,2,120,"<p>In this tutorial <a href=""https://qiskit.org/textbook/ch-paper-implementations/tsp.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-paper-implementations/tsp.html</a> I understood most of the steps of how to build it, but not the result. In the code, I see they don't get to the part of doing grover search. I think, they only get to this part of the approach they mention:</p>
<ul>
<li>&quot;Then we apply phase estimation algorithm to certain eigenstates which gives us all the total distances possible for all the routes&quot;.</li>
</ul>
<p>I am not sure if I understand that sentence. As I understand, an eigenstate represents a path that goes through each city (encoded in binary with the function they show). I thought reading and running the code  would make it clearer, but the output of the code when ran is '100100' for the eigenstate '11000110'. Is that supposed to be the total distance for the path that represents that eigenstate? '100100' is 36 in decimal, is that encode in some way? or is actually that the cost of that path?</p>
<p>-- edit:
I know the distances are represented as phases, so they are bounded between 0 and 2*pi, but i don't get what that '100100' could be</p>
",traveling salesman output from qiskit docs,<qiskit><quantum-algorithms>,1,0,,,"traveling salesman output from qiskit docs <p>In this tutorial <a href=""https://qiskit.org/textbook/ch-paper-implementations/tsp.html"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-paper-implementations/tsp.html</a> I understood most of the steps of how to build it, but not the result. In the code, I see they don't get to the part of doing grover search. I think, they only get to this part of the approach they mention:</p>
<ul>
<li>&quot;Then we apply phase estimation algorithm to certain eigenstates which gives us all the total distances possible for all the routes&quot;.</li>
</ul>
<p>I am not sure if I understand that sentence. As I understand, an eigenstate represents a path that goes through each city (encoded in binary with the function they show). I thought reading and running the code  would make it clearer, but the output of the code when ran is '100100' for the eigenstate '11000110'. Is that supposed to be the total distance for the path that represents that eigenstate? '100100' is 36 in decimal, is that encode in some way? or is actually that the cost of that path?</p>
<p>-- edit:
I know the distances are represented as phases, so they are bounded between 0 and 2*pi, but i don't get what that '100100' could be</p>
",qc,traveling salesman output qiskit docs p tutorial https nofollow noreferrer https understood steps build result code see get part grover search think get part approach mention ul li quot apply phase estimation algorithm certain eigenstates gives us total distances possible routes quot p sure understand sentence understand eigenstate represents path goes city encoded binary function show thought reading running code would make clearer output code ran eigenstate supposed total distance path represents eigenstate 36 decimal encode way actually cost path p edit know distances represented phases bounded 0 2 pi get could,"[(0, 0.06648151), (2, 0.016991073), (3, 0.110544816), (4, 0.05897883), (7, 0.1357009), (8, 0.13852282), (9, 0.04448021), (13, 0.25367662), (14, 0.101943806), (17, 0.04514018), (19, 0.026540393)]"
29829,29830.0,2023-01-24 07:59:04,0,78,"<p>Does the &quot;Pymatching&quot; decoder of the &quot;sinter&quot; python package use Pymatching 1.0 or 2.0?</p>
<p><a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">https://pypi.org/project/sinter/</a></p>
",Pymatching decoder version in sinter package,<error-correction>,1,0,,,"Pymatching decoder version in sinter package <p>Does the &quot;Pymatching&quot; decoder of the &quot;sinter&quot; python package use Pymatching 1.0 or 2.0?</p>
<p><a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">https://pypi.org/project/sinter/</a></p>
",qc,pymatching decoder version sinter package p quot pymatching quot decoder quot sinter quot python package use pymatching p https nofollow noreferrer https,"[(4, 0.3204817), (17, 0.2251029), (19, 0.44675663)]"
29831,29856.0,2023-01-24 08:35:31,2,100,"<p>Studying Grover on IBM lab using Qiskit. But the following code produces unexpected outputs. Note that `PhaseOracle produces 2 CCZ gates. Could anyone check (and explain) why are those unexpected counts/outputs(given at the bottom) being produced?</p>
<p>Note that when I try a similar code with similar logical expressions with aqua (which is deprecated, the expected outputs are produced)</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit import *
from qiskit.tools.visualization import plot_histogram
from qiskit.circuit.library import PhaseOracle
from qiskit.algorithms import Grover, AmplificationProblem
%matplotlib inline

matplotlib inline
oracle = PhaseOracle('((A &amp; C) | (B &amp; D)) &amp; ~(C &amp; D)')
problem = AmplificationProblem(oracle=oracle, is_good_state=oracle.evaluate_bitstring)
backend = Aer.get_backend('qasm_simulator')
grover = Grover(quantum_instance=backend)
result = grover.amplify(problem)
print(result.circuit_results[0])
{'0111': 259, '1100': 244, '1101': 234, '0011': 287}
</code></pre>
","Grover, CCZ Gate on IBM Quantum Lab & unexpected outputs",<qiskit><grovers-algorithm>,1,2,,,"Grover, CCZ Gate on IBM Quantum Lab & unexpected outputs <p>Studying Grover on IBM lab using Qiskit. But the following code produces unexpected outputs. Note that `PhaseOracle produces 2 CCZ gates. Could anyone check (and explain) why are those unexpected counts/outputs(given at the bottom) being produced?</p>
<p>Note that when I try a similar code with similar logical expressions with aqua (which is deprecated, the expected outputs are produced)</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit import *
from qiskit.tools.visualization import plot_histogram
from qiskit.circuit.library import PhaseOracle
from qiskit.algorithms import Grover, AmplificationProblem
%matplotlib inline

matplotlib inline
oracle = PhaseOracle('((A &amp; C) | (B &amp; D)) &amp; ~(C &amp; D)')
problem = AmplificationProblem(oracle=oracle, is_good_state=oracle.evaluate_bitstring)
backend = Aer.get_backend('qasm_simulator')
grover = Grover(quantum_instance=backend)
result = grover.amplify(problem)
print(result.circuit_results[0])
{'0111': 259, '1100': 244, '1101': 234, '0011': 287}
</code></pre>
",qc,grover ccz gate ibm quantum lab unexpected outputs p studying grover ibm lab using qiskit following code produces unexpected outputs note phaseoracle produces 2 ccz gates could anyone check explain unexpected given bottom produced p note try similar code similar logical expressions aqua deprecated expected outputs produced pre code qiskit import import import phaseoracle import grover amplificationproblem matplotlib inline matplotlib inline oracle phaseoracle amp c b amp amp c amp problem amplificationproblem backend grover grover result problem print 0 259 244 234 287,"[(0, 0.35628387), (5, 0.048397534), (7, 0.18380691), (13, 0.08384245), (14, 0.20914164), (15, 0.0854379), (17, 0.017677184), (19, 0.013874753)]"
29844,29846.0,2023-01-25 02:11:57,0,62,"<p>In pymatching, the check_matrix structure is for stabilizers rather than measurement outcome of stabilizers.</p>
<p>I want to plot &quot;matching&quot; for my measurement outcomes.To do that, I need to convert the measurement results into detection events. Here I wonder if the detection events mean that temporal and spatial coordinates that errors happened. Is the detection events mean that temportal and spatial coordinates that errors happens?</p>
<p>The second question, after finding my detection events, how can I use this structure to decode/matching in pymatching?</p>
",Do detection events mean temporal and spatial coordinates?,<error-correction><pymatching><minimum-weight-perfect-matching>,1,0,,,"Do detection events mean temporal and spatial coordinates? <p>In pymatching, the check_matrix structure is for stabilizers rather than measurement outcome of stabilizers.</p>
<p>I want to plot &quot;matching&quot; for my measurement outcomes.To do that, I need to convert the measurement results into detection events. Here I wonder if the detection events mean that temporal and spatial coordinates that errors happened. Is the detection events mean that temportal and spatial coordinates that errors happens?</p>
<p>The second question, after finding my detection events, how can I use this structure to decode/matching in pymatching?</p>
",qc,detection events mean temporal spatial coordinates p pymatching structure stabilizers rather measurement outcome p want plot quot matching quot measurement need convert measurement results detection events wonder detection events mean temporal spatial coordinates errors happened detection events mean temportal spatial coordinates errors happens p second question finding detection events use structure pymatching,"[(0, 0.075613245), (5, 0.31326264), (7, 0.085437536), (8, 0.21394195), (13, 0.0445987), (14, 0.16414244), (17, 0.05999908), (19, 0.04065567)]"
29852,,2023-01-25 13:02:35,1,283,"<p>When I study ‘Dynamic decoupling’, one method is <code>add_dynamical_decoupling</code>.
Firstly I should install <code>qiskit_research</code> in my Jupyter notebook (IBM quantum lab), but when I use</p>
<pre><code>git clone https://github.com/qiskit-research/qiskit-research.git
cd qiskit-research
pip install .
</code></pre>
<p>Then there is an error.
<a href=""https://i.sstatic.net/YHt6y.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YHt6y.jpg"" alt=""enter image description here"" /></a></p>
<p>Does anyone know how to using this ‘qiskit-research’?</p>
",How to install qiskit-research in IBM quantum lab?,<qiskit><programming><quantum-algorithms><dynamics>,1,0,,,"How to install qiskit-research in IBM quantum lab? <p>When I study ‘Dynamic decoupling’, one method is <code>add_dynamical_decoupling</code>.
Firstly I should install <code>qiskit_research</code> in my Jupyter notebook (IBM quantum lab), but when I use</p>
<pre><code>git clone https://github.com/qiskit-research/qiskit-research.git
cd qiskit-research
pip install .
</code></pre>
<p>Then there is an error.
<a href=""https://i.sstatic.net/YHt6y.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YHt6y.jpg"" alt=""enter image description here"" /></a></p>
<p>Does anyone know how to using this ‘qiskit-research’?</p>
",qc,install ibm quantum lab p study dynamic decoupling one method code firstly install code jupyter notebook ibm quantum lab use pre code git clone https cd pip install p error https nofollow noreferrer img https enter image description p anyone know using,"[(0, 0.18669511), (1, 0.057682414), (4, 0.33899942), (14, 0.38732097), (17, 0.025569579)]"
29867,,2023-01-25 23:03:20,3,403,"<p>Stim only supports Pauli noises like <code>DEPOLARIZE1</code>, <code>DEPOLARIZE2</code>, <code>X_ERROR</code>, <code>Z_ERROR</code>. Given <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span> values of qubits, how would I adjust a stim circuit file to reflect these? For instance, we might have qubits with different <span class=""math-container"">$T_1$</span> and <span class=""math-container"">$T_2$</span> values. How would I decide the magnitudes of the <code>DEPOLARIZE1</code> errors on them when they are idle?</p>
<p>We've read the post <a href=""https://quantumcomputing.stackexchange.com/questions/23577/incorporating-idling-errors-while-using-stim/23579#23579"">Incorporating idling errors while using stim</a>,
but a more detailed explanation would be helpful.</p>
",Converting $T_1$ and $T_2$ decay rates to noise supported by stim,<error-correction><quantum-operation><noise><stim>,2,1,,,"Converting $T_1$ and $T_2$ decay rates to noise supported by stim <p>Stim only supports Pauli noises like <code>DEPOLARIZE1</code>, <code>DEPOLARIZE2</code>, <code>X_ERROR</code>, <code>Z_ERROR</code>. Given <span class=""math-container"">$T_1$</span>, <span class=""math-container"">$T_2$</span> values of qubits, how would I adjust a stim circuit file to reflect these? For instance, we might have qubits with different <span class=""math-container"">$T_1$</span> and <span class=""math-container"">$T_2$</span> values. How would I decide the magnitudes of the <code>DEPOLARIZE1</code> errors on them when they are idle?</p>
<p>We've read the post <a href=""https://quantumcomputing.stackexchange.com/questions/23577/incorporating-idling-errors-while-using-stim/23579#23579"">Incorporating idling errors while using stim</a>,
but a more detailed explanation would be helpful.</p>
",qc,converting decay rates noise supported stim p stim supports pauli noises like code depolarize1 code depolarize2 code code given span span values qubits would adjust stim circuit file reflect instance might qubits different span span values would decide magnitudes code depolarize1 errors idle p read post https 23579 incorporating idling errors using stim detailed explanation would,"[(3, 0.108255096), (4, 0.042592976), (5, 0.24992616), (6, 0.098716475), (8, 0.11489658), (14, 0.32852322), (17, 0.020239307), (19, 0.034672085)]"
29873,29886.0,2023-01-26 11:11:57,3,433,"<p>It's well known that the single-qubit rotation gate <span class=""math-container"">$U(\theta, \phi, \lambda)$</span> and the controlled-not gate <span class=""math-container"">$CX_{i,j}$</span> form one of the <strong>universal set of gates</strong> for quantum computation. So here's my question: is the Qiskit <a href=""https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html?highlight=transpile#qiskit.compiler.transpile"" rel=""nofollow noreferrer""><code>transpile</code></a> function able to compile any given quantum circuit by using <code>u</code> and <code>cx</code> gates only?</p>
<p>In particular, I would assume that the following code will always work with no errors:</p>
<pre><code>from qiskit.circuit.random import random_circuit
from qiskit.compiler import transpile

qc = random_circuit(num_qubits=5, depth=10)
tqc = transpile(qc, basis_gates=['u', 'cx'])
</code></pre>
<p>Unfortunately, it would seem not to be so and I was wondering why. I also noticed that, if I add the identity gate <code>id</code> in the list of <code>basis_gates</code>, the transpilation looks to always run successfully and I'm not sure about the reason for this.</p>
<p>The error produced by qiskit is:</p>
<pre><code>QiskitError: &quot;Cannot unroll the circuit to the given basis, ['u', 'cx'].
Instruction id not found in equivalence library and no rule found to expand.&quot;
</code></pre>
","Is Qiskit transpile function (with basis_gates=['u', 'cx']) universal?",<qiskit><universal-gates><transpile>,1,2,,,"Is Qiskit transpile function (with basis_gates=['u', 'cx']) universal? <p>It's well known that the single-qubit rotation gate <span class=""math-container"">$U(\theta, \phi, \lambda)$</span> and the controlled-not gate <span class=""math-container"">$CX_{i,j}$</span> form one of the <strong>universal set of gates</strong> for quantum computation. So here's my question: is the Qiskit <a href=""https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html?highlight=transpile#qiskit.compiler.transpile"" rel=""nofollow noreferrer""><code>transpile</code></a> function able to compile any given quantum circuit by using <code>u</code> and <code>cx</code> gates only?</p>
<p>In particular, I would assume that the following code will always work with no errors:</p>
<pre><code>from qiskit.circuit.random import random_circuit
from qiskit.compiler import transpile

qc = random_circuit(num_qubits=5, depth=10)
tqc = transpile(qc, basis_gates=['u', 'cx'])
</code></pre>
<p>Unfortunately, it would seem not to be so and I was wondering why. I also noticed that, if I add the identity gate <code>id</code> in the list of <code>basis_gates</code>, the transpilation looks to always run successfully and I'm not sure about the reason for this.</p>
<p>The error produced by qiskit is:</p>
<pre><code>QiskitError: &quot;Cannot unroll the circuit to the given basis, ['u', 'cx'].
Instruction id not found in equivalence library and no rule found to expand.&quot;
</code></pre>
",qc,qiskit transpile function u universal p well known rotation gate span u gate span j form one strong universal set gates quantum computation question qiskit https nofollow noreferrer code transpile function able compile given quantum circuit using code u code cx gates p particular would assume following code always work errors pre code import import transpile qc tqc transpile qc u p unfortunately would seem wondering also noticed add identity gate code id list code transpilation looks always run successfully sure reason p error produced qiskit pre code qiskiterror quot unroll circuit given basis u instruction id found equivalence library rule found quot,"[(0, 0.20289552), (3, 0.12567191), (9, 0.21935143), (14, 0.40525886), (17, 0.019725468), (19, 0.025739828)]"
29899,,2023-01-27 14:19:44,5,466,"<p>To detect and correct for errors in a topological quantum memory (toric code for example) one needs a quantum error correction algorithm also known as decoder.</p>
<p>The minimum weight perfect matching (MWPM) decoder is currently the most standard decoder for topological codes and an open source implementation exists in Python/C++ called <a href=""https://pymatching.readthedocs.io/en/latest/index.html"" rel=""noreferrer"">PyMatching</a>.</p>
<p>Other decoders exist, such as Union-Find, Two-pass matching, Belief-matching or Tensor-network decoding, each with different levels of accuracy and speed.</p>
<p>Are there open source implementations of these other decoders available somewhere, for example using Python?</p>
",Are there open source implementations of quantum error correction decoders?,<error-correction><resource-request><topological-quantum-computing><programming><pymatching>,3,0,,,"Are there open source implementations of quantum error correction decoders? <p>To detect and correct for errors in a topological quantum memory (toric code for example) one needs a quantum error correction algorithm also known as decoder.</p>
<p>The minimum weight perfect matching (MWPM) decoder is currently the most standard decoder for topological codes and an open source implementation exists in Python/C++ called <a href=""https://pymatching.readthedocs.io/en/latest/index.html"" rel=""noreferrer"">PyMatching</a>.</p>
<p>Other decoders exist, such as Union-Find, Two-pass matching, Belief-matching or Tensor-network decoding, each with different levels of accuracy and speed.</p>
<p>Are there open source implementations of these other decoders available somewhere, for example using Python?</p>
",qc,open source implementations quantum error correction decoders p detect correct errors topological quantum memory toric code example one needs quantum error correction algorithm also known p minimum weight perfect matching mwpm decoder currently standard decoder topological codes open source implementation exists called https noreferrer pymatching p decoders exist matching decoding different levels accuracy p open source implementations decoders available somewhere example using python,"[(5, 0.38273838), (7, 0.08992102), (8, 0.27637538), (13, 0.13644063), (17, 0.092973664), (19, 0.019334903)]"
29900,,2023-01-27 14:25:59,4,377,"<p>What is the expectation value for the ground state of <span class=""math-container"">$ H = \sum_i Z_i Z_{i+1} + \sum_i X_i $</span> ? In Eq. 15b <a href=""https://paramekanti.weebly.com/uploads/1/1/2/8/11287579/atan_paper.pdf"" rel=""nofollow noreferrer"">this</a> provides a solution in k space. The minimum would be reached for <span class=""math-container"">$E = -4$</span>.  But for example <a href=""https://tensorcircuit.readthedocs.io/en/latest/tutorials/tfim_vqe.html"" rel=""nofollow noreferrer"">here</a> the energy is calculated numerically as -7.3 ?</p>
",What is the expectation value for the ground state of $ H = \sum_i Z_i Z_{i+1} + \sum_i X_i $?,<vqe>,1,1,,,"What is the expectation value for the ground state of $ H = \sum_i Z_i Z_{i+1} + \sum_i X_i $? <p>What is the expectation value for the ground state of <span class=""math-container"">$ H = \sum_i Z_i Z_{i+1} + \sum_i X_i $</span> ? In Eq. 15b <a href=""https://paramekanti.weebly.com/uploads/1/1/2/8/11287579/atan_paper.pdf"" rel=""nofollow noreferrer"">this</a> provides a solution in k space. The minimum would be reached for <span class=""math-container"">$E = -4$</span>.  But for example <a href=""https://tensorcircuit.readthedocs.io/en/latest/tutorials/tfim_vqe.html"" rel=""nofollow noreferrer"">here</a> the energy is calculated numerically as -7.3 ?</p>
",qc,expectation value ground state h p expectation value ground state span h eq 15b https nofollow noreferrer provides solution k space minimum would reached span e example https nofollow noreferrer energy calculated numerically,"[(3, 0.48928303), (4, 0.20604044), (7, 0.065353364), (9, 0.061601736), (17, 0.17306063)]"
29933,29934.0,2023-01-29 23:20:52,1,279,"<p>Hello I am trying to create an Q0-&gt;HSSH Q1-&gt;HSH using U3 Gate only.</p>
<p>I am trying U3(pi/2, 0, pi) for H Gate and U3(4<em>pi/2, 2</em>pi,0) for S gate.</p>
<p>The output state vector using normal H and S gate don't seem to match the output from U3. Am I not understanding something correctly?</p>
",How can you create S-GATE with U3?,<quantum-gate><quantum-state>,1,0,,,"How can you create S-GATE with U3? <p>Hello I am trying to create an Q0-&gt;HSSH Q1-&gt;HSH using U3 Gate only.</p>
<p>I am trying U3(pi/2, 0, pi) for H Gate and U3(4<em>pi/2, 2</em>pi,0) for S gate.</p>
<p>The output state vector using normal H and S gate don't seem to match the output from U3. Am I not understanding something correctly?</p>
",qc,create u3 p hello trying create gt hssh gt hsh using u3 gate p trying u3 0 pi h gate u3 4 em 2 p output state vector using normal h gate seem match output u3 understanding something correctly,"[(0, 0.18483336), (2, 0.082525454), (4, 0.11872358), (13, 0.154203), (14, 0.2967131), (17, 0.1592371)]"
29936,,2023-01-30 01:27:34,0,69,"<p>I recently took part in a hackathon, and following that I would like to keep working on the project, which consists in developing an FRQI circuit.</p>
<p>I was working on its optimization through boolean simplification, as explained in the Qiskit documentation: <a href=""https://qiskit.org/textbook/ch-applications/image-processing-frqi-neqr.html#5.-Compression"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/image-processing-frqi-neqr.html#5.-Compression</a>. However, I did not manage to make it work, and with some input matrices I get part of the images which have wrong values.</p>
<p>Here is what I understood so far:</p>
<ol>
<li>First, I group the pixels by intensity.</li>
<li>Second, using <a href=""https://docs.sympy.org/latest/modules/logic.html#sympy.logic.boolalg.to_dnf"" rel=""nofollow noreferrer"">sympy.to_dnf</a>, I simplify the binary expressions computed from the pixel positions of each group. First, are there methods faster than <code>to_dnf</code> for large groups please? I read about Espresso for instance.</li>
<li>Third, I add the CX gates and controlled rotations based on the results of the latter. When it is simplified to one product of boolean variables, the controlled qubits are only the one figuring in it. I apply the required CX gates before. But I wonder about the angle of the rotation to apply. Should I multiply it by the number of pixels in the group?</li>
<li>When the simplified expression has still several products, I am not sure of how to handle it. Currently I just apply the step 3. for every product. However I should be wrong because the generated circuit does not always work. So I was thinking if there might be some commutativity issues or other aspects to pay attention to, regarding the theory of quantum physics.</li>
</ol>
<p>If you would like to see the code, you can find it <a href=""https://github.com/LouisJustinTALLOT/2023_IonQ_Remote_Somervillains/blob/ab591ca28a3cba0b7ae038e63cc6366a4fa0d238/part1.py"" rel=""nofollow noreferrer"">here</a>. The non optimized function is <code>encode</code>, and the current optimized function which does not work is <code>encode_compress</code>. Sorry for the code being slightly messy, but I aim at making sure the implemented principles are correct before considering implementation errors.</p>
<p>If you need any additional information, please let me know,</p>
<p>Many thanks in advance for your help!</p>
<p>Best regards,</p>
<p>jd6</p>
",Boolean simplification for FRQI,<qiskit>,0,2,,,"Boolean simplification for FRQI <p>I recently took part in a hackathon, and following that I would like to keep working on the project, which consists in developing an FRQI circuit.</p>
<p>I was working on its optimization through boolean simplification, as explained in the Qiskit documentation: <a href=""https://qiskit.org/textbook/ch-applications/image-processing-frqi-neqr.html#5.-Compression"" rel=""nofollow noreferrer"">https://qiskit.org/textbook/ch-applications/image-processing-frqi-neqr.html#5.-Compression</a>. However, I did not manage to make it work, and with some input matrices I get part of the images which have wrong values.</p>
<p>Here is what I understood so far:</p>
<ol>
<li>First, I group the pixels by intensity.</li>
<li>Second, using <a href=""https://docs.sympy.org/latest/modules/logic.html#sympy.logic.boolalg.to_dnf"" rel=""nofollow noreferrer"">sympy.to_dnf</a>, I simplify the binary expressions computed from the pixel positions of each group. First, are there methods faster than <code>to_dnf</code> for large groups please? I read about Espresso for instance.</li>
<li>Third, I add the CX gates and controlled rotations based on the results of the latter. When it is simplified to one product of boolean variables, the controlled qubits are only the one figuring in it. I apply the required CX gates before. But I wonder about the angle of the rotation to apply. Should I multiply it by the number of pixels in the group?</li>
<li>When the simplified expression has still several products, I am not sure of how to handle it. Currently I just apply the step 3. for every product. However I should be wrong because the generated circuit does not always work. So I was thinking if there might be some commutativity issues or other aspects to pay attention to, regarding the theory of quantum physics.</li>
</ol>
<p>If you would like to see the code, you can find it <a href=""https://github.com/LouisJustinTALLOT/2023_IonQ_Remote_Somervillains/blob/ab591ca28a3cba0b7ae038e63cc6366a4fa0d238/part1.py"" rel=""nofollow noreferrer"">here</a>. The non optimized function is <code>encode</code>, and the current optimized function which does not work is <code>encode_compress</code>. Sorry for the code being slightly messy, but I aim at making sure the implemented principles are correct before considering implementation errors.</p>
<p>If you need any additional information, please let me know,</p>
<p>Many thanks in advance for your help!</p>
<p>Best regards,</p>
<p>jd6</p>
",qc,boolean simplification frqi p recently took part hackathon following would like keep working project consists developing frqi p working optimization boolean simplification explained qiskit documentation https nofollow noreferrer https however manage make work input matrices get part images wrong p understood far ol li first group pixels li second using https nofollow noreferrer simplify binary expressions computed pixel positions group first methods faster code large groups please read espresso li third add cx gates controlled rotations based results latter simplified one product boolean variables controlled qubits one figuring apply required cx gates wonder angle rotation apply multiply number pixels group li simplified expression still several products sure handle currently apply step every product however wrong generated circuit always work thinking might commutativity issues aspects pay attention regarding theory quantum p would like see code find https nofollow noreferrer non optimized function code encode current optimized function work code sorry code slightly messy aim making sure implemented principles correct considering implementation p need additional information please let know p many thanks advance help p best regards p jd6,"[(4, 0.06601045), (8, 0.11145116), (9, 0.1480113), (11, 0.010790974), (13, 0.254295), (14, 0.32860282), (17, 0.012579307), (18, 0.060414936)]"
29938,29949.0,2023-01-30 09:05:59,0,453,"<p>How can I convert a Stim detector error model into a networkx/rustworkx weighted graph representing the equivalent syndrome graph?</p>
<p>I want it to test a possible method to introduce erasures in the high erasure rate regime, where the method described in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim?rq=1"">How do I perform an erasure error in stim?</a> might be invalid.</p>
",Stim detector error model to syndrome graph,<error-correction><stim>,1,0,,,"Stim detector error model to syndrome graph <p>How can I convert a Stim detector error model into a networkx/rustworkx weighted graph representing the equivalent syndrome graph?</p>
<p>I want it to test a possible method to introduce erasures in the high erasure rate regime, where the method described in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim?rq=1"">How do I perform an erasure error in stim?</a> might be invalid.</p>
",qc,stim detector error model syndrome graph p convert stim detector error model weighted graph representing equivalent syndrome graph p want test possible method introduce erasures high erasure rate regime method described https perform erasure error stim might,"[(5, 0.5405709), (9, 0.0534327), (13, 0.28309244), (17, 0.118601106)]"
29945,,2023-01-30 15:27:42,3,87,"<p>Consider the (asymmetric) quantum discord, defined as (borrowing notation from Eq. 4.13c of <a href=""https://arxiv.org/abs/2208.09019"" rel=""nofollow noreferrer"">Zurek's review</a>):
<span class=""math-container"">$$\mathcal D(\mathcal S:\mathcal A) = I(\mathcal S:\mathcal A) - \chi(\rho_{\mathcal A}),$$</span>
where
<span class=""math-container"">$$\chi(\rho_{\cal A}) \equiv \max_{\{\boldsymbol\pi_k\}}(H(\rho_{\mathcal A}) - \sum_k p_k H(\mathcal A|\boldsymbol\pi_k)).$$</span>
Here we're considering bipartite states <span class=""math-container"">$\rho\equiv\rho_{\mathcal S\mathcal A}$</span>, denoting with <span class=""math-container"">$I(\mathcal S:\mathcal A)$</span> the standard quantum mutual information, and the maximum is taken with respect to all possible POVMs <span class=""math-container"">$\{\boldsymbol\pi_k\}_k$</span>, so that <span class=""math-container"">$\sum_k \boldsymbol\pi_k=I$</span> and <span class=""math-container"">$\boldsymbol\pi_k\ge0$</span>.
The outcome probabilities read <span class=""math-container"">$p_k\equiv \operatorname{tr}(\boldsymbol\pi_k \rho_{\cal SA})$</span>, and <span class=""math-container"">$H(\mathcal A|\boldsymbol\pi_k)$</span> is the entropy of <span class=""math-container"">$\mathcal A$</span> conditioned on having measured <span class=""math-container"">$\mathcal S$</span> and found the <span class=""math-container"">$k$</span>-th outcome, meaning that
<span class=""math-container"">$H(\mathcal A|\boldsymbol\pi_k)$</span> is the (von Neumann) entropy of the state <span class=""math-container"">$\rho_k\equiv \operatorname{tr}_{\cal S}(\boldsymbol\pi_k\rho_{\cal SA})/p_k$</span>.</p>
<p>It is mentioned in the above review (just above (4.12c)) that there are situations where the maximum in the definition of <span class=""math-container"">$\chi(\rho_{\cal A})$</span>, or equivalently, the accessible mutual information, is achieved with <em>non-projective POVMs</em>. I'm looking for explicit &quot;simple&quot; examples of this being the case.</p>
<p>In (<a href=""https://arxiv.org/abs/1112.6238"" rel=""nofollow noreferrer"">Modi et al. 2011</a>) the authors mention (section I.3, page 11) that the discord is always optimized by rank-1 extremal POVMs.
Most topical reviews (<a href=""https://arxiv.org/abs/1112.6238"" rel=""nofollow noreferrer"">Modi et al. 2011</a>, <a href=""https://arxiv.org/abs/1312.7676"" rel=""nofollow noreferrer"">Modi 2013</a>, <a href=""https://arxiv.org/abs/1703.10542"" rel=""nofollow noreferrer"">Bera et al. 2017</a>) mention the fact that the discord is in general achieved with non-projective POVMs, but I'm failing to actually extract an explicit simple examples from the provided citations.
Going through the relevant references given in (Modi 2011), I see that (<a href=""https://arxiv.org/abs/1102.0181"" rel=""nofollow noreferrer"">Chen et al. 2011</a>) work out the discord for two-qubit X states. However, if I understand correctly, this is still a numerical result. (<a href=""https://arxiv.org/abs/1107.2005"" rel=""nofollow noreferrer"">Galve et al. 2011</a>) show that for rank-2 states PVMs are sufficient, but only show numerically that POVMs are more generally needed. (<a href=""https://arxiv.org/abs/1107.2005"" rel=""nofollow noreferrer"">Shi et al. 2011</a>) also analyze the discord of X-states and show that non-projective PVMs are needed, but also in this case I don't know how to extract an explicit example of such a state and associated POVM.</p>
<p>Is there any analytical example of a state where the discord/accessible information (be it the asymmetric or symmetric one) is achieved with non-projective measurements?</p>
",What are examples where the quantum discord is achieved by a non-projective POVM?,<measurement><povm><mutual-information><quantum-discord>,0,4,,,"What are examples where the quantum discord is achieved by a non-projective POVM? <p>Consider the (asymmetric) quantum discord, defined as (borrowing notation from Eq. 4.13c of <a href=""https://arxiv.org/abs/2208.09019"" rel=""nofollow noreferrer"">Zurek's review</a>):
<span class=""math-container"">$$\mathcal D(\mathcal S:\mathcal A) = I(\mathcal S:\mathcal A) - \chi(\rho_{\mathcal A}),$$</span>
where
<span class=""math-container"">$$\chi(\rho_{\cal A}) \equiv \max_{\{\boldsymbol\pi_k\}}(H(\rho_{\mathcal A}) - \sum_k p_k H(\mathcal A|\boldsymbol\pi_k)).$$</span>
Here we're considering bipartite states <span class=""math-container"">$\rho\equiv\rho_{\mathcal S\mathcal A}$</span>, denoting with <span class=""math-container"">$I(\mathcal S:\mathcal A)$</span> the standard quantum mutual information, and the maximum is taken with respect to all possible POVMs <span class=""math-container"">$\{\boldsymbol\pi_k\}_k$</span>, so that <span class=""math-container"">$\sum_k \boldsymbol\pi_k=I$</span> and <span class=""math-container"">$\boldsymbol\pi_k\ge0$</span>.
The outcome probabilities read <span class=""math-container"">$p_k\equiv \operatorname{tr}(\boldsymbol\pi_k \rho_{\cal SA})$</span>, and <span class=""math-container"">$H(\mathcal A|\boldsymbol\pi_k)$</span> is the entropy of <span class=""math-container"">$\mathcal A$</span> conditioned on having measured <span class=""math-container"">$\mathcal S$</span> and found the <span class=""math-container"">$k$</span>-th outcome, meaning that
<span class=""math-container"">$H(\mathcal A|\boldsymbol\pi_k)$</span> is the (von Neumann) entropy of the state <span class=""math-container"">$\rho_k\equiv \operatorname{tr}_{\cal S}(\boldsymbol\pi_k\rho_{\cal SA})/p_k$</span>.</p>
<p>It is mentioned in the above review (just above (4.12c)) that there are situations where the maximum in the definition of <span class=""math-container"">$\chi(\rho_{\cal A})$</span>, or equivalently, the accessible mutual information, is achieved with <em>non-projective POVMs</em>. I'm looking for explicit &quot;simple&quot; examples of this being the case.</p>
<p>In (<a href=""https://arxiv.org/abs/1112.6238"" rel=""nofollow noreferrer"">Modi et al. 2011</a>) the authors mention (section I.3, page 11) that the discord is always optimized by rank-1 extremal POVMs.
Most topical reviews (<a href=""https://arxiv.org/abs/1112.6238"" rel=""nofollow noreferrer"">Modi et al. 2011</a>, <a href=""https://arxiv.org/abs/1312.7676"" rel=""nofollow noreferrer"">Modi 2013</a>, <a href=""https://arxiv.org/abs/1703.10542"" rel=""nofollow noreferrer"">Bera et al. 2017</a>) mention the fact that the discord is in general achieved with non-projective POVMs, but I'm failing to actually extract an explicit simple examples from the provided citations.
Going through the relevant references given in (Modi 2011), I see that (<a href=""https://arxiv.org/abs/1102.0181"" rel=""nofollow noreferrer"">Chen et al. 2011</a>) work out the discord for two-qubit X states. However, if I understand correctly, this is still a numerical result. (<a href=""https://arxiv.org/abs/1107.2005"" rel=""nofollow noreferrer"">Galve et al. 2011</a>) show that for rank-2 states PVMs are sufficient, but only show numerically that POVMs are more generally needed. (<a href=""https://arxiv.org/abs/1107.2005"" rel=""nofollow noreferrer"">Shi et al. 2011</a>) also analyze the discord of X-states and show that non-projective PVMs are needed, but also in this case I don't know how to extract an explicit example of such a state and associated POVM.</p>
<p>Is there any analytical example of a state where the discord/accessible information (be it the asymmetric or symmetric one) is achieved with non-projective measurements?</p>
",qc,examples quantum discord achieved povm p consider asymmetric quantum discord defined borrowing notation eq https nofollow noreferrer zurek review span span h h considering bipartite states span denoting span standard quantum mutual information maximum taken respect possible povms span span span outcome probabilities read span tr sa span h entropy span conditioned measured span found span k outcome meaning span h von neumann entropy state span tr sa p mentioned review situations maximum definition span equivalently accessible mutual information achieved em povms looking explicit quot simple quot examples p https nofollow noreferrer modi et al 2011 authors mention section page 11 discord always optimized extremal povms topical reviews https nofollow noreferrer modi et al 2011 https nofollow noreferrer modi 2013 https nofollow noreferrer bera et al 2017 mention fact discord general achieved povms failing actually extract explicit simple examples provided citations going relevant references given modi 2011 see https nofollow noreferrer chen et al 2011 work discord x states however understand correctly still numerical result https nofollow noreferrer galve et al 2011 show states pvms sufficient show numerically povms generally needed https nofollow noreferrer shi et al 2011 also analyze discord show pvms needed also case know extract explicit example state associated p analytical example state information asymmetric symmetric one achieved measurements,"[(3, 0.5294073), (4, 0.10860564), (7, 0.013760469), (8, 0.029105807), (9, 0.26794663), (13, 0.014381541), (17, 0.011468673), (19, 0.015064944)]"
29982,29999.0,2023-02-02 02:42:12,0,301,"<p>I am running distance 3 surface code with 3 rounds:</p>
<p>Here is the parity check matrix of X stabilizers for distance three surface code:</p>
<pre><code> H_d3x = csr_matrix(np.array([
[1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1]
    ]))
</code></pre>
<p>My syndrome measurements are as follows:</p>
<pre><code>Round = 0, X syndromes are: (1, 1, 1, 0, 1, 0, )
Round = 1, X syndromes are: (0, 0, 1, 0, 0, 0, )
Round = 2, X syndromes are: (1, 1, 0, 1, 1, 0, )
</code></pre>
<p>So the detection events at the end of the third round is: detection_events = [0,0,1,1,0,0]
(because at the end of the all rounds, syndrome 1,2,5 and 6 stayed same so they did not get affected by errors so detection is 0. However, syndrome3 and 4 changed)
Now in Pymatching:
I can simply say:</p>
<pre><code>m3x = Matching(H_d3x)
</code></pre>
<p>But then, for decoding errors, should I say</p>
<pre><code>xdecode = list(reversed(m3x.decode(detection_events)))
</code></pre>
<p>?</p>
<p>or should I say</p>
<pre><code>xdecode = list(reversed(m3x.decode(Xsyndromes)))
</code></pre>
<p>?</p>
<p>I assume that I should put detection events in  <code>decode</code> fucntion.
However, I see some codes in github, they used syndrome measurements directly so I wanted to double check here</p>
","Pymatching, Parity Check Matrix with Syndrome Measurements and Detection Events",<surface-code><pymatching>,1,0,,,"Pymatching, Parity Check Matrix with Syndrome Measurements and Detection Events <p>I am running distance 3 surface code with 3 rounds:</p>
<p>Here is the parity check matrix of X stabilizers for distance three surface code:</p>
<pre><code> H_d3x = csr_matrix(np.array([
[1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1]
    ]))
</code></pre>
<p>My syndrome measurements are as follows:</p>
<pre><code>Round = 0, X syndromes are: (1, 1, 1, 0, 1, 0, )
Round = 1, X syndromes are: (0, 0, 1, 0, 0, 0, )
Round = 2, X syndromes are: (1, 1, 0, 1, 1, 0, )
</code></pre>
<p>So the detection events at the end of the third round is: detection_events = [0,0,1,1,0,0]
(because at the end of the all rounds, syndrome 1,2,5 and 6 stayed same so they did not get affected by errors so detection is 0. However, syndrome3 and 4 changed)
Now in Pymatching:
I can simply say:</p>
<pre><code>m3x = Matching(H_d3x)
</code></pre>
<p>But then, for decoding errors, should I say</p>
<pre><code>xdecode = list(reversed(m3x.decode(detection_events)))
</code></pre>
<p>?</p>
<p>or should I say</p>
<pre><code>xdecode = list(reversed(m3x.decode(Xsyndromes)))
</code></pre>
<p>?</p>
<p>I assume that I should put detection events in  <code>decode</code> fucntion.
However, I see some codes in github, they used syndrome measurements directly so I wanted to double check here</p>
",qc,pymatching parity check matrix syndrome measurements detection events p running distance 3 surface code 3 rounds p parity check matrix x stabilizers distance three surface code pre code 1 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 1 1 p syndrome measurements follows pre code round 0 x syndromes 1 1 1 0 1 0 round 1 x syndromes 0 0 1 0 0 0 round 2 x syndromes 1 1 0 1 1 0 p detection events end third round end rounds syndrome 6 stayed get affected errors detection however syndrome3 4 changed pymatching simply say pre code m3x matching p decoding errors say pre code xdecode list reversed p p say pre code xdecode list reversed xsyndromes p p assume put detection events code decode fucntion however see codes github used syndrome measurements directly wanted double check,"[(2, 0.5985717), (5, 0.2115235), (8, 0.03037206), (10, 0.02157548), (13, 0.022715034), (14, 0.09172075), (17, 0.02286863)]"
29993,,2023-02-02 13:05:03,0,280,"<p>I want to simulate erasures in a surface code using stim, assuming that any gate on the data qubits can cause an erasure.
If I induce erasure after each gate by the method described in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a>, the loss-ancilla can be flipped an even number of times, making the even number of erasures on the same qubit unheralded.
On the other hand, if I add a different loss-ancilla to any gate, it looks like over-heralding the erasure since it gives information on the specific gate where the loss occurred.
Any idea?</p>
",Circuit-based erasure simulation using stim,<error-correction><stim>,1,0,,,"Circuit-based erasure simulation using stim <p>I want to simulate erasures in a surface code using stim, assuming that any gate on the data qubits can cause an erasure.
If I induce erasure after each gate by the method described in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a>, the loss-ancilla can be flipped an even number of times, making the even number of erasures on the same qubit unheralded.
On the other hand, if I add a different loss-ancilla to any gate, it looks like over-heralding the erasure since it gives information on the specific gate where the loss occurred.
Any idea?</p>
",qc,erasure simulation using stim p want simulate erasures surface code using stim assuming gate data qubits cause erasure induce erasure gate method described https perform erasure error stim flipped even number times making even number erasures qubit unheralded hand add different gate looks like erasure since gives information specific gate loss occurred idea,"[(5, 0.19326982), (9, 0.078907974), (14, 0.50213224), (17, 0.2226241)]"
30020,,2023-02-04 00:01:29,1,121,"<p>I am trying to program in python the following quantum circuit but for some reason when I write the matrix after the z gate, M8, the resultant matrix is zero.
<a href=""https://i.sstatic.net/lSM0v.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lSM0v.png"" alt=""enter image description here"" /></a></p>
<p>The code is:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

qubits = [np.array([[1, 0]]) for i in range(9)]
qubits[0] = np.array([[1, 0]])

Projector = [np.matmul(qubits[i].transpose(), qubits[i]) for i in range(9)]

State_0_projector = np.matmul(np.array([[1, 0]]).transpose(), np.array([[1, 0]]))
State_1_projector = np.matmul(np.array([[0, 1]]).transpose(), np.array([[0, 1]]))

# Gates
Id = np.identity(2)
Id9 = np.identity(9)
X = np.array([[0, 1], [1, 0]])
H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
Z = np.array([[1, 0], [0, -1]])

def kronecker(A, B, C, D, E, F, G, H, I):
    matrix = np.kron(A, np.kron(B, np.kron(C, np.kron(D, np.kron(E, np.kron(F, np.kron(G, np.kron(H, I))))))))
    return matrix

# Initial state
psi = kronecker(qubits[0], qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])


# Encoding of the initial state
M1 = np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id), kronecker(State_1_projector, Id, Id, X, Id, Id, Id, Id, Id))

M2 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id),
               kronecker(State_1_projector, Id, Id, Id, Id, Id, X, Id, Id)), M1)

M3 = np.matmul(kronecker(H, Id, Id, H, Id, Id, H, Id, Id), M2)

M4 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, X, Id, State_1_projector, X, Id, State_1_projector, X, Id)), M3)

M5 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, Id, X, State_1_projector, Id, X, State_1_projector, Id, X)), M4)

# Error induction on the qubit 0
M6 = np.matmul(kronecker(X, Id, Id, Id, Id, Id, Id, Id, Id), M5)

M7 = np.matmul(kronecker(Z, Id, Id, Id, Id, Id, Id, Id, Id), M6)

# Correction of the flip error
M8 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, X, Id, State_1_projector, X, Id, State_1_projector, X, Id)), M7)

M9 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, Id, X, State_1_projector, Id, X, State_1_projector, Id, X)), M8)

M10 = np.matmul(np.add(kronecker(Id, State_0_projector, State_0_projector, Id, State_0_projector, State_0_projector, Id, State_0_projector, State_0_projector),
                kronecker(X, State_1_projector, State_1_projector, X, State_1_projector, State_1_projector, X, State_1_projector, State_1_projector)), M9)


# Correction of the phase error
M11 = np.matmul(kronecker(H, Id, Id, H, Id, Id, H, Id, Id), M10)

M12 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id),
                kronecker(State_1_projector, Id, Id, X, Id, Id, Id, Id, Id)), M11)

M13 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id),
               kronecker(State_1_projector, Id, Id, Id, Id, Id, X, Id, Id)), M12)


MS = M13


Final_State = np.matmul(MS, psi.transpose())


State_0 = kronecker(np.array([[1, 0]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])
State_1 = kronecker(np.array([[0, 1]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])

Projector_psi_0 = kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id)
Projector_psi_1 = kronecker(State_1_projector, Id, Id, Id, Id, Id, Id, Id, Id)


P_0 = (abs(np.matmul(State_0, np.matmul(Projector_psi_0, Final_State))))**2
print(P_0)

P_1 = (abs(np.matmul(State_1, np.matmul(Projector_psi_1, Final_State))))**2
print(P_1)
</code></pre>
<p>M7 matrix:</p>
<p><a href=""https://i.sstatic.net/bzgxi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/bzgxi.png"" alt=""enter image description here"" /></a></p>
<p>And, well, M8 matrix:</p>
<p><a href=""https://i.sstatic.net/eM3C0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eM3C0.png"" alt=""enter image description here"" /></a></p>
<p>Each M1, M2, ..., M13 is the matrix of the system defined by the multiplication of the corresponding operator with the previous matrix. I am considering the inicial state being all |0&gt; and the qubit 0 being |1&gt;.</p>
<p>By the way could someone check if the measurement of the qubit 0 in the end of the circuit is currectly done?</p>
",Having trouble trying to program the shor 9 qubit code,<quantum-circuit><shors-algorithm><programming>,0,0,,,"Having trouble trying to program the shor 9 qubit code <p>I am trying to program in python the following quantum circuit but for some reason when I write the matrix after the z gate, M8, the resultant matrix is zero.
<a href=""https://i.sstatic.net/lSM0v.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lSM0v.png"" alt=""enter image description here"" /></a></p>
<p>The code is:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

qubits = [np.array([[1, 0]]) for i in range(9)]
qubits[0] = np.array([[1, 0]])

Projector = [np.matmul(qubits[i].transpose(), qubits[i]) for i in range(9)]

State_0_projector = np.matmul(np.array([[1, 0]]).transpose(), np.array([[1, 0]]))
State_1_projector = np.matmul(np.array([[0, 1]]).transpose(), np.array([[0, 1]]))

# Gates
Id = np.identity(2)
Id9 = np.identity(9)
X = np.array([[0, 1], [1, 0]])
H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
Z = np.array([[1, 0], [0, -1]])

def kronecker(A, B, C, D, E, F, G, H, I):
    matrix = np.kron(A, np.kron(B, np.kron(C, np.kron(D, np.kron(E, np.kron(F, np.kron(G, np.kron(H, I))))))))
    return matrix

# Initial state
psi = kronecker(qubits[0], qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])


# Encoding of the initial state
M1 = np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id), kronecker(State_1_projector, Id, Id, X, Id, Id, Id, Id, Id))

M2 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id),
               kronecker(State_1_projector, Id, Id, Id, Id, Id, X, Id, Id)), M1)

M3 = np.matmul(kronecker(H, Id, Id, H, Id, Id, H, Id, Id), M2)

M4 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, X, Id, State_1_projector, X, Id, State_1_projector, X, Id)), M3)

M5 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, Id, X, State_1_projector, Id, X, State_1_projector, Id, X)), M4)

# Error induction on the qubit 0
M6 = np.matmul(kronecker(X, Id, Id, Id, Id, Id, Id, Id, Id), M5)

M7 = np.matmul(kronecker(Z, Id, Id, Id, Id, Id, Id, Id, Id), M6)

# Correction of the flip error
M8 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, X, Id, State_1_projector, X, Id, State_1_projector, X, Id)), M7)

M9 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, State_0_projector, Id, Id, State_0_projector, Id, Id),
               kronecker(State_1_projector, Id, X, State_1_projector, Id, X, State_1_projector, Id, X)), M8)

M10 = np.matmul(np.add(kronecker(Id, State_0_projector, State_0_projector, Id, State_0_projector, State_0_projector, Id, State_0_projector, State_0_projector),
                kronecker(X, State_1_projector, State_1_projector, X, State_1_projector, State_1_projector, X, State_1_projector, State_1_projector)), M9)


# Correction of the phase error
M11 = np.matmul(kronecker(H, Id, Id, H, Id, Id, H, Id, Id), M10)

M12 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id),
                kronecker(State_1_projector, Id, Id, X, Id, Id, Id, Id, Id)), M11)

M13 = np.matmul(np.add(kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id),
               kronecker(State_1_projector, Id, Id, Id, Id, Id, X, Id, Id)), M12)


MS = M13


Final_State = np.matmul(MS, psi.transpose())


State_0 = kronecker(np.array([[1, 0]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])
State_1 = kronecker(np.array([[0, 1]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])

Projector_psi_0 = kronecker(State_0_projector, Id, Id, Id, Id, Id, Id, Id, Id)
Projector_psi_1 = kronecker(State_1_projector, Id, Id, Id, Id, Id, Id, Id, Id)


P_0 = (abs(np.matmul(State_0, np.matmul(Projector_psi_0, Final_State))))**2
print(P_0)

P_1 = (abs(np.matmul(State_1, np.matmul(Projector_psi_1, Final_State))))**2
print(P_1)
</code></pre>
<p>M7 matrix:</p>
<p><a href=""https://i.sstatic.net/bzgxi.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/bzgxi.png"" alt=""enter image description here"" /></a></p>
<p>And, well, M8 matrix:</p>
<p><a href=""https://i.sstatic.net/eM3C0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eM3C0.png"" alt=""enter image description here"" /></a></p>
<p>Each M1, M2, ..., M13 is the matrix of the system defined by the multiplication of the corresponding operator with the previous matrix. I am considering the inicial state being all |0&gt; and the qubit 0 being |1&gt;.</p>
<p>By the way could someone check if the measurement of the qubit 0 in the end of the circuit is currectly done?</p>
",qc,trouble trying program shor 9 qubit code p trying program python following quantum circuit reason write matrix z gate m8 resultant matrix zero https nofollow noreferrer img https enter image description p code pre code import numpy np import plt qubits 1 0 range 9 qubits 0 1 0 projector qubits qubits range 9 1 0 1 0 0 1 0 1 gates id 2 id9 9 x 0 1 1 0 h 1 1 1 2 z 1 0 0 def kronecker b c e f g h matrix b c e f g h return matrix initial state psi kronecker qubits 0 qubits 1 qubits 2 qubits 3 qubits 4 qubits 5 qubits 6 qubits 7 qubits 8 encoding initial state m1 kronecker id id id id id id id id kronecker id id x id id id id id m2 kronecker id id id id id id id id kronecker id id id id id x id id m1 m3 kronecker h id id h id id h id id m2 m4 kronecker id id id id id id kronecker x id x id x id m3 m5 kronecker id id id id id id kronecker id x id x id x m4 error induction qubit 0 m6 kronecker x id id id id id id id id m5 m7 kronecker z id id id id id id id id m6 correction flip error m8 kronecker id id id id id id kronecker x id x id x id m7 m9 kronecker id id id id id id kronecker id x id x id x m8 m10 kronecker id id id kronecker x x x m9 correction phase error m11 kronecker h id id h id id h id id m10 m12 kronecker id id id id id id id id kronecker id id x id id id id id m11 m13 kronecker id id id id id id id id kronecker id id id id id x id id m12 ms m13 ms kronecker 1 0 qubits 1 qubits 2 qubits 3 qubits 4 qubits 5 qubits 6 qubits 7 qubits 8 kronecker 0 1 qubits 1 qubits 2 qubits 3 qubits 4 qubits 5 qubits 6 qubits 7 qubits 8 kronecker id id id id id id id id kronecker id id id id id id id id abs 2 print abs 2 print p m7 matrix p https nofollow noreferrer img https enter image description p well m8 matrix p https nofollow noreferrer img https enter image description p m1 m2 m13 matrix system defined multiplication corresponding operator previous matrix considering inicial state gt qubit 0 gt p way could someone check measurement qubit 0 end circuit currectly done,"[(0, 0.03835199), (2, 0.10972776), (3, 0.021114657), (4, 0.08204013), (5, 0.02644735), (6, 0.05660928), (10, 0.066832885), (11, 0.015253723), (14, 0.039589528), (17, 0.51385516), (18, 0.023364577)]"
30062,30065.0,2023-02-06 12:45:43,0,411,"<p>Let's say we have an error mechanism <code>error(0.1) D7 D8 ^ D9 D10 ^ D13 D15</code>. I understand that Stim is trying to decompose the complex errors into graphlike errors. It is saying: ok, we have one error mechanism, when it happens, we have three edges <code>D7--D8</code>, <code>D9--D10</code>, and <code>D13--D15</code>.</p>
<p>My understanding is that: we are adding these 3 weighted edges to the matching graph. And these 3 edges are <strong>dependent</strong> on each other. Namely, if <code>D7--D8</code> is triggered, then we also know that <code>D9--D10</code>, and <code>D13--D15</code> is triggered.</p>
<p>However, it is not right. Because the MWPM decoder assumes <strong>independent</strong> probability of each qubit suffering an error (if I understand it in the right way), which means the weights of the matching graph should also be <strong>independent</strong> of each other so that we can add weights of edges that connect two defects.</p>
<p>My questions are the followings:</p>
<ol>
<li>How does Stim convert a DEM to a matching graph with <strong>independent</strong> edges?</li>
<li>Let's say we have a DEM with two error mechanisms: <code>error(0.1) D1 D2 ^ D2 D3 ^ D7 D8</code> and <code>error(0.2) D2 D3 ^ D4 D7 ^ D7 </code>. How does Stim deal with the weight of edge <code>D2--D3</code>?</li>
<li>Can we get the matching graph <strong>with weights</strong> in some way?</li>
</ol>
<p>Thanks!</p>
",How is the match graph extracted from a stim.circuit.detector_error_model?,<error-correction><stim><pymatching>,1,0,,,"How is the match graph extracted from a stim.circuit.detector_error_model? <p>Let's say we have an error mechanism <code>error(0.1) D7 D8 ^ D9 D10 ^ D13 D15</code>. I understand that Stim is trying to decompose the complex errors into graphlike errors. It is saying: ok, we have one error mechanism, when it happens, we have three edges <code>D7--D8</code>, <code>D9--D10</code>, and <code>D13--D15</code>.</p>
<p>My understanding is that: we are adding these 3 weighted edges to the matching graph. And these 3 edges are <strong>dependent</strong> on each other. Namely, if <code>D7--D8</code> is triggered, then we also know that <code>D9--D10</code>, and <code>D13--D15</code> is triggered.</p>
<p>However, it is not right. Because the MWPM decoder assumes <strong>independent</strong> probability of each qubit suffering an error (if I understand it in the right way), which means the weights of the matching graph should also be <strong>independent</strong> of each other so that we can add weights of edges that connect two defects.</p>
<p>My questions are the followings:</p>
<ol>
<li>How does Stim convert a DEM to a matching graph with <strong>independent</strong> edges?</li>
<li>Let's say we have a DEM with two error mechanisms: <code>error(0.1) D1 D2 ^ D2 D3 ^ D7 D8</code> and <code>error(0.2) D2 D3 ^ D4 D7 ^ D7 </code>. How does Stim deal with the weight of edge <code>D2--D3</code>?</li>
<li>Can we get the matching graph <strong>with weights</strong> in some way?</li>
</ol>
<p>Thanks!</p>
",qc,match graph extracted p let say error mechanism code error d7 d8 d9 d10 d13 d15 understand stim trying decompose complex errors graphlike errors saying ok one error mechanism happens three edges code d7 d8 code d9 d10 code d13 d15 p understanding adding 3 weighted edges matching graph 3 edges strong dependent namely code d7 d8 triggered also know code d9 d10 code d13 d15 p however right mwpm decoder assumes strong independent probability qubit suffering error understand right way means weights matching graph also strong independent add weights edges connect two p questions followings ol li stim convert dem matching graph strong independent edges li let say dem two error mechanisms code error d1 d2 d2 d3 d7 d8 code error d2 d3 d4 d7 d7 stim deal weight edge code d2 d3 li get matching graph strong weights way p thanks,"[(5, 0.3233097), (6, 0.0891451), (7, 0.026954053), (8, 0.02788715), (12, 0.04003255), (13, 0.21950006), (14, 0.21297462), (17, 0.04826538), (19, 0.011058448)]"
30090,30124.0,2023-02-07 06:39:55,0,2141,"<p>I do this but it still gives an error for load account</p>
<ul>
<li>IBMQ.delete_account()</li>
<li>IBMQ.active_account()</li>
<li>IBMQ.save_account('myAPI toke ')</li>
<li>IBMQ.save_account('my API toke')</li>
<li>IBMQ.load_account()</li>
</ul>
<p><strong>entire error</strong></p>
<p>HTTPError               Traceback (most recent call last)
C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
277             response = super().request(method, final_url, headers=headers, **kwargs)
--&gt; 278             response.raise_for_status()
279         except RequestException as ex:</p>
<p>C:\111\lib\site-packages\requests\models.py in raise_for_status(self)
1020         if http_error_msg:
-&gt; 1021             raise HTTPError(http_error_msg, response=self)
1022</p>
<p>HTTPError: 403 Client Error: Forbidden for url: <a href=""https://auth.quantum-computing.ibm.com/api/version"" rel=""nofollow noreferrer"">https://auth.quantum-computing.ibm.com/api/version</a></p>
<p>The above exception was the direct cause of the following exception:</p>
<p>RequestsApiError                          Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_297760\485379158.py in 
----&gt; 1 IBMQ.load_account()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in load_account(self)
175         # Explicitly check via a server call, to allow environment auth URLs
176         # contain IBM Quantum Experience v2 URL (but not auth) slipping through.
--&gt; 177         version_info = self._check_api_version(credentials)
178
179         # Check the URL is a valid authentication URL.</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in _check_api_version(credentials)
442         version_finder = VersionClient(credentials.base_url,
443                                        **credentials.connection_parameters())
--&gt; 444         return version_finder.version()
445
446     def _initialize_providers(</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\clients\version.py in version(self)
47                 * <code>api-*</code> (str): The versions of each individual API component
48         &quot;&quot;&quot;
---&gt; 49         return self.client_version_finder.version()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py in version(self)
100         &quot;&quot;&quot;
101         url = self.get_url('version')
--&gt; 102         response = self.session.get(url)
103
104         try:</p>
<p>C:\111\lib\site-packages\requests\sessions.py in get(self, url, **kwargs)
598
599         kwargs.setdefault(&quot;allow_redirects&quot;, True)
--&gt; 600         return self.request(&quot;GET&quot;, url, **kwargs)
601
602     def options(self, url, **kwargs):</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
298                 self._modify_chained_exception_messages(ex)
299
--&gt; 300             raise RequestsApiError(message, status_code) from ex
301
302         return response</p>
<p><strong>I perform this operation, but again it gives an error for load account</strong></p>
",I can't load account on IBM's qiskit,<qiskit><programming><ibm-q-experience><quantum-circuit><qiskit-runtime>,1,10,,,"I can't load account on IBM's qiskit <p>I do this but it still gives an error for load account</p>
<ul>
<li>IBMQ.delete_account()</li>
<li>IBMQ.active_account()</li>
<li>IBMQ.save_account('myAPI toke ')</li>
<li>IBMQ.save_account('my API toke')</li>
<li>IBMQ.load_account()</li>
</ul>
<p><strong>entire error</strong></p>
<p>HTTPError               Traceback (most recent call last)
C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
277             response = super().request(method, final_url, headers=headers, **kwargs)
--&gt; 278             response.raise_for_status()
279         except RequestException as ex:</p>
<p>C:\111\lib\site-packages\requests\models.py in raise_for_status(self)
1020         if http_error_msg:
-&gt; 1021             raise HTTPError(http_error_msg, response=self)
1022</p>
<p>HTTPError: 403 Client Error: Forbidden for url: <a href=""https://auth.quantum-computing.ibm.com/api/version"" rel=""nofollow noreferrer"">https://auth.quantum-computing.ibm.com/api/version</a></p>
<p>The above exception was the direct cause of the following exception:</p>
<p>RequestsApiError                          Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_297760\485379158.py in 
----&gt; 1 IBMQ.load_account()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in load_account(self)
175         # Explicitly check via a server call, to allow environment auth URLs
176         # contain IBM Quantum Experience v2 URL (but not auth) slipping through.
--&gt; 177         version_info = self._check_api_version(credentials)
178
179         # Check the URL is a valid authentication URL.</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\ibmqfactory.py in _check_api_version(credentials)
442         version_finder = VersionClient(credentials.base_url,
443                                        **credentials.connection_parameters())
--&gt; 444         return version_finder.version()
445
446     def _initialize_providers(</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\clients\version.py in version(self)
47                 * <code>api-*</code> (str): The versions of each individual API component
48         &quot;&quot;&quot;
---&gt; 49         return self.client_version_finder.version()</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\rest\root.py in version(self)
100         &quot;&quot;&quot;
101         url = self.get_url('version')
--&gt; 102         response = self.session.get(url)
103
104         try:</p>
<p>C:\111\lib\site-packages\requests\sessions.py in get(self, url, **kwargs)
598
599         kwargs.setdefault(&quot;allow_redirects&quot;, True)
--&gt; 600         return self.request(&quot;GET&quot;, url, **kwargs)
601
602     def options(self, url, **kwargs):</p>
<p>C:\111\lib\site-packages\qiskit\providers\ibmq\api\session.py in request(self, method, url, bare, **kwargs)
298                 self._modify_chained_exception_messages(ex)
299
--&gt; 300             raise RequestsApiError(message, status_code) from ex
301
302         return response</p>
<p><strong>I perform this operation, but again it gives an error for load account</strong></p>
",qc,ca load account ibm qiskit p still gives error load account ul li li li toke li api toke li p strong entire error p httperror traceback recent call last c request self method url bare kwargs 277 response super method kwargs gt 278 279 except requestexception ex p c self 1020 gt 1021 raise httperror 1022 p httperror 403 client error forbidden url https nofollow noreferrer https p exception direct cause following exception p requestsapierror traceback recent call last gt 1 p c self 175 explicitly check via server call allow environment auth urls 176 contain ibm quantum experience v2 url auth slipping gt 177 credentials 178 179 check url valid authentication p c credentials 442 versionclient 443 gt 444 return 445 446 def p c version self 47 code str versions individual api component 48 quot quot quot gt 49 return p c version self 100 quot quot quot 101 url gt 102 response url 103 104 try p c get self url kwargs 598 599 quot quot true gt 600 return quot get quot url kwargs 601 602 def options self url kwargs p c request self method url bare kwargs 298 ex 299 gt 300 raise requestsapierror message ex 301 302 return response p strong perform operation gives error load account,"[(0, 0.29626927), (4, 0.033600237), (6, 0.041599315), (7, 0.05819105), (8, 0.06621414), (9, 0.033106774), (16, 0.011647101), (17, 0.0133340005), (19, 0.44545218)]"
30178,,2023-02-12 10:05:51,3,719,"<p>I am working on creating a dashboard that contains CircuitComposer and several other ipywidgets and plots that will allow for playing around with quantum circuits in an intuitable manner. For this I have decided to use a voila rendered jupyter notebook. In trying to do so it became clear to me that there are some serious compatibility issues between these packages. Can anybody attest for the stability of a given combination of these packages? For example as far as I understand voila 0.4.0 has problems with ipywidgets, and from my own experience ibm_quantum_widgets is not compatible with python&gt;3.10.</p>
",Is CircuitComposer from ibm_quantum_widgets pypi package deprecated?,<qiskit>,1,0,,,"Is CircuitComposer from ibm_quantum_widgets pypi package deprecated? <p>I am working on creating a dashboard that contains CircuitComposer and several other ipywidgets and plots that will allow for playing around with quantum circuits in an intuitable manner. For this I have decided to use a voila rendered jupyter notebook. In trying to do so it became clear to me that there are some serious compatibility issues between these packages. Can anybody attest for the stability of a given combination of these packages? For example as far as I understand voila 0.4.0 has problems with ipywidgets, and from my own experience ibm_quantum_widgets is not compatible with python&gt;3.10.</p>
",qc,circuitcomposer pypi package deprecated p working creating dashboard contains circuitcomposer several ipywidgets plots allow playing around quantum circuits intuitable manner decided use voila rendered jupyter notebook trying became clear serious compatibility issues packages anybody attest stability given combination packages example far understand voila problems ipywidgets experience compatible python gt,"[(0, 0.08853911), (7, 0.038497023), (8, 0.33886397), (14, 0.5032204), (17, 0.026947213)]"
30190,,2023-02-13 05:17:45,1,404,"<p>In the phenomenological noise model, we have an approximately 2% error threshold in surface codes. In the circuit-based noise model, the threshold ranges from 0.5% to 0.7%. I'm curious if there's a mapping between these two models. Is it possible to calculate, or more accurately predict, the phenomenological noise model threshold from the circuit-based noise model threshold for a given p error rate? I'm trying to understand the mapping between these two error models. To the best of my knowledge, we can calculate these threshold values numerically, but I am sure there is a mapping between them, and I do not know what it is.</p>
",Is there any map between Phenomenological Noise Model and Circuit Based Noise Model?,<noise><surface-code>,1,0,,,"Is there any map between Phenomenological Noise Model and Circuit Based Noise Model? <p>In the phenomenological noise model, we have an approximately 2% error threshold in surface codes. In the circuit-based noise model, the threshold ranges from 0.5% to 0.7%. I'm curious if there's a mapping between these two models. Is it possible to calculate, or more accurately predict, the phenomenological noise model threshold from the circuit-based noise model threshold for a given p error rate? I'm trying to understand the mapping between these two error models. To the best of my knowledge, we can calculate these threshold values numerically, but I am sure there is a mapping between them, and I do not know what it is.</p>
",qc,map phenomenological noise model circuit based noise model p phenomenological noise model approximately 2 error threshold surface codes noise model threshold ranges curious mapping two models possible calculate accurately predict phenomenological noise model threshold noise model threshold given p error rate trying understand mapping two error models best knowledge calculate threshold values numerically sure mapping know,"[(2, 0.01648748), (5, 0.45990017), (7, 0.05509993), (14, 0.37363687), (17, 0.09220466)]"
30197,,2023-02-13 15:21:14,7,807,"<p>In his paper &quot;<a href=""https://arxiv.org/pdf/2008.05188.pdf"" rel=""noreferrer"">The Argument against Quantum Computers, the Quantum Laws of Nature, and Google’s Supremacy Claims</a>&quot;, Gil Kalai argues that quantum advantage will never be reached. For NISQ devices in particular, he argues that for a large variety of noise, the correlation between the ideal distribution and the noised one converges to <span class=""math-container"">$0$</span>, meaning that the results are effectively unusable.</p>
<p>A common counter-argument is the Threshold theorem, which states that for an acceptable level of noise, we can error-correct a Quantum Computer. Gil Kalai however argues that:</p>
<blockquote>
<p>At the center of my analysis is a computational complexity argument stating that <span class=""math-container"">$\gamma&lt;\delta$</span></p>
</blockquote>
<p>where</p>
<blockquote>
<ul>
<li><span class=""math-container"">$\gamma$</span> is the rate of noise required for quantum advantage, and</li>
<li><span class=""math-container"">$\delta$</span> is the rate of noise that can realistically be achieved.</li>
</ul>
</blockquote>
<p>Thus, Gil Kalai states that the Threshold Theorem will never be applied in practice, that the level of noise in NISQ devices will always be higher that the aforementioned threshold.</p>
<p>However, last year, the Google Quantum AI team published &quot;<a href=""https://arxiv.org/pdf/2207.06431.pdf"" rel=""noreferrer"">Suppressing quantum errors by scaling a surface code logical qubit</a>&quot;, where they show, from my understanding, that they managed to perform error-correction at threshold, meaning that correcting a Quantum Computer does not add more errors than it corrects.</p>
<p>Is this paper enough to invalidate all of Gil Kalai's arguments? For instance, does the fact that NISQ-generated distributions can be approximated by low-degree polynomials still hold, or is it linked to the previous argument and thus rendered void?</p>
<p>I don't think there has been a follow-up bu Gil Kalai on this paper, though I may have missed it.</p>
",Does Google's error correction paper invalidate Gil Kalai's arguments?,<experimental-realization><quantum-advantage><nisq>,3,6,,,"Does Google's error correction paper invalidate Gil Kalai's arguments? <p>In his paper &quot;<a href=""https://arxiv.org/pdf/2008.05188.pdf"" rel=""noreferrer"">The Argument against Quantum Computers, the Quantum Laws of Nature, and Google’s Supremacy Claims</a>&quot;, Gil Kalai argues that quantum advantage will never be reached. For NISQ devices in particular, he argues that for a large variety of noise, the correlation between the ideal distribution and the noised one converges to <span class=""math-container"">$0$</span>, meaning that the results are effectively unusable.</p>
<p>A common counter-argument is the Threshold theorem, which states that for an acceptable level of noise, we can error-correct a Quantum Computer. Gil Kalai however argues that:</p>
<blockquote>
<p>At the center of my analysis is a computational complexity argument stating that <span class=""math-container"">$\gamma&lt;\delta$</span></p>
</blockquote>
<p>where</p>
<blockquote>
<ul>
<li><span class=""math-container"">$\gamma$</span> is the rate of noise required for quantum advantage, and</li>
<li><span class=""math-container"">$\delta$</span> is the rate of noise that can realistically be achieved.</li>
</ul>
</blockquote>
<p>Thus, Gil Kalai states that the Threshold Theorem will never be applied in practice, that the level of noise in NISQ devices will always be higher that the aforementioned threshold.</p>
<p>However, last year, the Google Quantum AI team published &quot;<a href=""https://arxiv.org/pdf/2207.06431.pdf"" rel=""noreferrer"">Suppressing quantum errors by scaling a surface code logical qubit</a>&quot;, where they show, from my understanding, that they managed to perform error-correction at threshold, meaning that correcting a Quantum Computer does not add more errors than it corrects.</p>
<p>Is this paper enough to invalidate all of Gil Kalai's arguments? For instance, does the fact that NISQ-generated distributions can be approximated by low-degree polynomials still hold, or is it linked to the previous argument and thus rendered void?</p>
<p>I don't think there has been a follow-up bu Gil Kalai on this paper, though I may have missed it.</p>
",qc,google error correction paper invalidate gil kalai arguments p paper quot https noreferrer argument quantum computers quantum laws nature google supremacy claims quot gil kalai argues quantum advantage never reached nisq devices particular argues large variety noise correlation ideal distribution noised one converges span 0 meaning results effectively p common threshold theorem states acceptable level noise quantum computer gil kalai however argues blockquote p center analysis computational complexity argument stating span lt p blockquote ul li span rate noise required quantum advantage li span rate noise realistically p thus gil kalai states threshold theorem never applied practice level noise nisq devices always higher aforementioned p however last year google quantum ai team published quot https noreferrer suppressing quantum errors scaling surface code logical qubit quot show understanding managed perform threshold meaning correcting quantum computer add errors p paper enough invalidate gil kalai arguments instance fact distributions approximated polynomials still hold linked previous argument thus rendered void p think bu gil kalai paper though may missed,"[(3, 0.09972524), (5, 0.19761333), (7, 0.07119825), (8, 0.30445135), (9, 0.23153839), (13, 0.011728088), (17, 0.035278298), (19, 0.033239204)]"
30204,,2023-02-13 18:04:06,0,470,"<p>I have a quantum circuit with 9 qubits. I have the matrix of the system. My question is how am I supposed to measure the final state of my first qubit? I know I need to apply a projection operator, but how I can write it?</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import sys
np.set_printoptions(threshold=sys.maxsize)

qubits = [np.array([[1, 0]]) for i in range(9)]


Projector = [np.matmul(qubits[i].transpose(), qubits[i]) for i in range(9)]

State_0_projector = np.matmul(np.array([[1, 0]]).transpose(), np.array([[1, 0]]))
State_1_projector = np.matmul(np.array([[0, 1]]).transpose(), np.array([[0, 1]]))

# Gates
Id = np.identity(2)
Id9 = np.identity(512)
X = np.array([[0, 1], [1, 0]])
H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
Z = np.array([[1, 0], [0, -1]])

def kronecker(A, B, C, D, E, F, G, H, I):
    matrix = np.kron(A, np.kron(B, np.kron(C, np.kron(D, np.kron(E, np.kron(F, np.kron(G, np.kron(H, I))))))))
    return matrix

# Initial state
psi = kronecker(qubits[0], qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#For simplifying consider we define MS as the final matrix of the system.

Final_State = np.matmul(MS, psi.transpose())



State_0 = kronecker(np.array([[1, 0]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])
State_1 = kronecker(np.array([[0, 1]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])


Projector_psi_0 = kronecker(Id, Id, Id, Id, Id, Id, Id, Id, State_0_projector)
Projector_psi_1 = kronecker(Id, Id, Id, Id, Id, Id, Id, Id, State_1_projector)

P = np.matmul(Projector_psi_0.transpose(), Projector_psi_0)

P_0 = (abs(np.matmul(State_0, np.matmul(P, Final_State))))**2
print(P_0)

P_1 = (abs(np.matmul(State_1, np.matmul(Projector_psi_1, Final_State))))**2
print(P_1)

<span class=""math-container"">```</span>
</code></pre>
",How am I suposed to do a measurement in a quantum circuit?,<measurement>,1,5,,,"How am I suposed to do a measurement in a quantum circuit? <p>I have a quantum circuit with 9 qubits. I have the matrix of the system. My question is how am I supposed to measure the final state of my first qubit? I know I need to apply a projection operator, but how I can write it?</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import sys
np.set_printoptions(threshold=sys.maxsize)

qubits = [np.array([[1, 0]]) for i in range(9)]


Projector = [np.matmul(qubits[i].transpose(), qubits[i]) for i in range(9)]

State_0_projector = np.matmul(np.array([[1, 0]]).transpose(), np.array([[1, 0]]))
State_1_projector = np.matmul(np.array([[0, 1]]).transpose(), np.array([[0, 1]]))

# Gates
Id = np.identity(2)
Id9 = np.identity(512)
X = np.array([[0, 1], [1, 0]])
H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
Z = np.array([[1, 0], [0, -1]])

def kronecker(A, B, C, D, E, F, G, H, I):
    matrix = np.kron(A, np.kron(B, np.kron(C, np.kron(D, np.kron(E, np.kron(F, np.kron(G, np.kron(H, I))))))))
    return matrix

# Initial state
psi = kronecker(qubits[0], qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#For simplifying consider we define MS as the final matrix of the system.

Final_State = np.matmul(MS, psi.transpose())



State_0 = kronecker(np.array([[1, 0]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])
State_1 = kronecker(np.array([[0, 1]]), qubits[1], qubits[2], qubits[3], qubits[4], qubits[5], qubits[6], qubits[7], qubits[8])


Projector_psi_0 = kronecker(Id, Id, Id, Id, Id, Id, Id, Id, State_0_projector)
Projector_psi_1 = kronecker(Id, Id, Id, Id, Id, Id, Id, Id, State_1_projector)

P = np.matmul(Projector_psi_0.transpose(), Projector_psi_0)

P_0 = (abs(np.matmul(State_0, np.matmul(P, Final_State))))**2
print(P_0)

P_1 = (abs(np.matmul(State_1, np.matmul(Projector_psi_1, Final_State))))**2
print(P_1)

<span class=""math-container"">```</span>
</code></pre>
",qc,suposed measurement quantum circuit p quantum circuit 9 qubits matrix system question supposed measure final state first qubit know need apply projection operator write pre code import numpy np import plt import sys qubits 1 0 range 9 projector qubits qubits range 9 1 0 1 0 0 1 0 1 gates id 2 id9 512 x 0 1 1 0 h 1 1 1 2 z 1 0 0 def kronecker b c e f g h matrix b c e f g h return matrix initial state psi kronecker qubits 0 qubits 1 qubits 2 qubits 3 qubits 4 qubits 5 qubits 6 qubits 7 qubits 8 simplifying consider define ms final matrix system ms kronecker 1 0 qubits 1 qubits 2 qubits 3 qubits 4 qubits 5 qubits 6 qubits 7 qubits 8 kronecker 0 1 qubits 1 qubits 2 qubits 3 qubits 4 qubits 5 qubits 6 qubits 7 qubits 8 kronecker id id id id id id id id kronecker id id id id id id id id p abs p 2 print abs 2 print span,"[(0, 0.10722868), (2, 0.24231918), (6, 0.12954824), (10, 0.01777301), (11, 0.023139404), (14, 0.043908875), (17, 0.25632268), (18, 0.17909014)]"
30246,30247.0,2023-02-17 06:06:12,0,227,"<p>I have the following Hamiltonian</p>
<pre><code>H = - Z1Z2 - Z2Z3 - Z1Z3 - 6(Z1 + Z2 + Z3)
</code></pre>
<p>Here, Z1, Z2, Z3 represent the Pauli-Z operators acting on qubits 1, 2, and 3, respectively. The interaction terms Z1Z2, Z2Z3, and Z1Z3 indicate that there is a ferromagnetic coupling between adjacent qubits. How can I simplify this further by substituting for Z1Z2, Z2Z3, Z1Z3 etc. in tensor product form in computational basis? Something like this (not sure how this can be obtained)</p>
<pre><code>Z1Z2 = (Z ⊗ Z) (|1⟩⟨1| ⊗ |0⟩⟨0| + |0⟩⟨0| ⊗ |1⟩⟨1|)
</code></pre>
",How to find the matrix representation of a given many-qubit Hamiltonian?,<matrix-representation><linear-algebra>,1,0,,,"How to find the matrix representation of a given many-qubit Hamiltonian? <p>I have the following Hamiltonian</p>
<pre><code>H = - Z1Z2 - Z2Z3 - Z1Z3 - 6(Z1 + Z2 + Z3)
</code></pre>
<p>Here, Z1, Z2, Z3 represent the Pauli-Z operators acting on qubits 1, 2, and 3, respectively. The interaction terms Z1Z2, Z2Z3, and Z1Z3 indicate that there is a ferromagnetic coupling between adjacent qubits. How can I simplify this further by substituting for Z1Z2, Z2Z3, Z1Z3 etc. in tensor product form in computational basis? Something like this (not sure how this can be obtained)</p>
<pre><code>Z1Z2 = (Z ⊗ Z) (|1⟩⟨1| ⊗ |0⟩⟨0| + |0⟩⟨0| ⊗ |1⟩⟨1|)
</code></pre>
",qc,find matrix representation given hamiltonian p following hamiltonian pre code h z1z2 z2z3 z1z3 6 z1 z2 z3 p z1 z2 z3 represent operators acting qubits 1 2 3 respectively interaction terms z1z2 z2z3 z1z3 indicate ferromagnetic coupling adjacent qubits simplify substituting z1z2 z2z3 z1z3 etc tensor product form computational basis something like sure obtained pre code z1z2 z z,"[(1, 0.063566186), (3, 0.3532053), (6, 0.061476782), (11, 0.044875525), (12, 0.040904764), (14, 0.3127634), (17, 0.1207152)]"
30310,30312.0,2023-02-21 10:08:31,0,80,"<p>This question is related to <a href=""https://quantumcomputing.stackexchange.com/questions/26623/within-stim-how-to-trace-back-dem-error-instructions-to-stim-circuit-faults"">Within Stim, how to trace back DEM error instructions to Stim circuit faults</a>.</p>
<p>I created a circuit of a distance-3 square surface code as you can see in the picture.
<a href=""https://i.sstatic.net/CuVqn.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CuVqn.jpg"" alt=""Distance-3 square surface code"" /></a></p>
<p>The DEM file contains one error mechanism '''error(0.000266738) D6 D7 D12 D13'''. I want to know which circuit faults in the original circuit contributed to this error mechanism.</p>
<p>So I use the following code:</p>
<pre><code>dem_errors_to_explain = stim.DetectorErrorModel(&quot;&quot;&quot;
    error(0.000266738) D6 D7 D12 D13
&quot;&quot;&quot;)

circuit_errors = circuit.explain_detector_error_model_errors(
    dem_filter=dem_errors_to_explain,
    reduce_to_one_representative_error=True
)

print(circuit_errors[0])
</code></pre>
<p>The result is as followings:</p>
<pre><code>ExplainedError {
dem_error_terms: D6[coords 0,1,1] D7[coords 2,1,1] D12[coords 1,0,1] D13[coords 3,0,1]
CircuitErrorLocation {
    flipped_pauli_product: X2[coords 2,0]*X1[coords 1,0]
    Circuit location stack trace:
        (after 10 TICKs)
        at instruction #50 (a REPEAT 10 block) in the circuit
        after 0 completed iterations
        at instruction #13 (DEPOLARIZE2) in the REPEAT block
        at targets #1 to #2 of the instruction
        resolving to DEPOLARIZE2(0.001) 2[coords 2,0] 1[coords 1,0]
}
</code></pre>
<p>We could find that Stim tells us the error mechanism contributing to syndrome '''D6 D7 D12 D13''' is the two-qubit error '''XX''' on qubit 1 and 2 after the depolarization channel.
However, this seems not correct because two X errors on qubit 1 and 2 will only lead to defects D12 and D13.</p>
<p>So where am I wrong?</p>
",It seems a failure to track back error mechanism from DEM to circuit faults,<stim>,1,0,,,"It seems a failure to track back error mechanism from DEM to circuit faults <p>This question is related to <a href=""https://quantumcomputing.stackexchange.com/questions/26623/within-stim-how-to-trace-back-dem-error-instructions-to-stim-circuit-faults"">Within Stim, how to trace back DEM error instructions to Stim circuit faults</a>.</p>
<p>I created a circuit of a distance-3 square surface code as you can see in the picture.
<a href=""https://i.sstatic.net/CuVqn.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/CuVqn.jpg"" alt=""Distance-3 square surface code"" /></a></p>
<p>The DEM file contains one error mechanism '''error(0.000266738) D6 D7 D12 D13'''. I want to know which circuit faults in the original circuit contributed to this error mechanism.</p>
<p>So I use the following code:</p>
<pre><code>dem_errors_to_explain = stim.DetectorErrorModel(&quot;&quot;&quot;
    error(0.000266738) D6 D7 D12 D13
&quot;&quot;&quot;)

circuit_errors = circuit.explain_detector_error_model_errors(
    dem_filter=dem_errors_to_explain,
    reduce_to_one_representative_error=True
)

print(circuit_errors[0])
</code></pre>
<p>The result is as followings:</p>
<pre><code>ExplainedError {
dem_error_terms: D6[coords 0,1,1] D7[coords 2,1,1] D12[coords 1,0,1] D13[coords 3,0,1]
CircuitErrorLocation {
    flipped_pauli_product: X2[coords 2,0]*X1[coords 1,0]
    Circuit location stack trace:
        (after 10 TICKs)
        at instruction #50 (a REPEAT 10 block) in the circuit
        after 0 completed iterations
        at instruction #13 (DEPOLARIZE2) in the REPEAT block
        at targets #1 to #2 of the instruction
        resolving to DEPOLARIZE2(0.001) 2[coords 2,0] 1[coords 1,0]
}
</code></pre>
<p>We could find that Stim tells us the error mechanism contributing to syndrome '''D6 D7 D12 D13''' is the two-qubit error '''XX''' on qubit 1 and 2 after the depolarization channel.
However, this seems not correct because two X errors on qubit 1 and 2 will only lead to defects D12 and D13.</p>
<p>So where am I wrong?</p>
",qc,seems failure track back error mechanism dem circuit faults p question related https within stim trace back dem error instructions stim circuit faults p created circuit square surface code see picture https nofollow noreferrer img https square surface code p dem file contains one error mechanism d6 d7 d12 d13 want know circuit faults original circuit contributed error p use following code pre code quot quot quot error d6 d7 d12 d13 quot quot quot print 0 p result followings pre code explainederror d6 coords d7 coords d12 coords d13 coords circuiterrorlocation x2 coords x1 coords circuit location stack trace 10 ticks instruction 50 repeat 10 block circuit 0 completed iterations instruction 13 depolarize2 repeat block targets 1 2 instruction resolving depolarize2 2 coords 1 coords p could find stim tells us error mechanism contributing syndrome d7 d12 d13 error qubit 1 2 depolarization channel however seems correct two x errors qubit 1 2 lead defects d12 p wrong,"[(4, 0.102146), (5, 0.20388824), (6, 0.27158654), (7, 0.017359111), (13, 0.011550036), (14, 0.2994321), (17, 0.028319703), (19, 0.06489597)]"
30327,30331.0,2023-02-22 15:08:03,1,229,"<p>I created a distance-3 square surface code circuit, and below is the 'timeline-svg' diagram.
<a href=""https://i.sstatic.net/zYKzo.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zYKzo.jpg"" alt=""enter image description here"" /></a></p>
<p>Since it would be easier to check where the detectors are detecting errors at each time slice, I use the 'detslice-with-ops-svg' diagram, which is shown below. (PS: I also tried to use 'detslice-svg', but it doesn't work.)
<a href=""https://i.sstatic.net/0Xe8K.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0Xe8K.jpg"" alt=""enter image description here"" /></a></p>
<p>My questions are as followings:</p>
<ol>
<li>What does these plots mean?</li>
<li>Why in the second graph there are two blue squares each missing a corner?</li>
<li>What do the big red and blue circles mean?</li>
<li>Do red and blue area mean Z and X stabilizers? And these areas' deformations mean stabilizer group transformation under unitary operations?</li>
<li>There are some curved edges and leaf-shape areas in some plots. What do they mean?</li>
</ol>
","What does each ""detslice-with-ops-svg"" plot mean?",<stim>,1,2,,,"What does each ""detslice-with-ops-svg"" plot mean? <p>I created a distance-3 square surface code circuit, and below is the 'timeline-svg' diagram.
<a href=""https://i.sstatic.net/zYKzo.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zYKzo.jpg"" alt=""enter image description here"" /></a></p>
<p>Since it would be easier to check where the detectors are detecting errors at each time slice, I use the 'detslice-with-ops-svg' diagram, which is shown below. (PS: I also tried to use 'detslice-svg', but it doesn't work.)
<a href=""https://i.sstatic.net/0Xe8K.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0Xe8K.jpg"" alt=""enter image description here"" /></a></p>
<p>My questions are as followings:</p>
<ol>
<li>What does these plots mean?</li>
<li>Why in the second graph there are two blue squares each missing a corner?</li>
<li>What do the big red and blue circles mean?</li>
<li>Do red and blue area mean Z and X stabilizers? And these areas' deformations mean stabilizer group transformation under unitary operations?</li>
<li>There are some curved edges and leaf-shape areas in some plots. What do they mean?</li>
</ol>
",qc,plot mean p created square surface code circuit diagram https nofollow noreferrer img https enter image description p since would easier check detectors detecting errors time slice use diagram shown ps also tried use work https nofollow noreferrer img https enter image description p questions followings ol li plots mean li second graph two blue squares missing corner li big red blue circles mean li red blue area mean z x stabilizers areas deformations mean stabilizer group transformation unitary operations li curved edges areas plots mean,"[(1, 0.035254255), (4, 0.47942993), (5, 0.22017694), (7, 0.08624874), (9, 0.0829994), (13, 0.06875992), (17, 0.025602771)]"
30347,,2023-02-23 09:45:18,6,183,"<p>I would like to compute the diamond norm of the difference of two single-qubit channels <span class=""math-container"">$\Phi_1$</span> and <span class=""math-container"">$\Phi_2$</span>. This difference is equal to, for any <span class=""math-container"">$2\times2$</span> complex matrix <span class=""math-container"">$\rho$</span>:
<span class=""math-container"">$$\DeclareMathOperator{tr}{tr}\Phi_1(\rho)-\Phi_2(\rho)=\beta\rho+\gamma Z\rho Z+\delta\tr(\rho)|0\rangle\!\langle0|+\varepsilon\tr(\rho)|1\rangle\!\langle1|$$</span>
with <span class=""math-container"">$\beta+\gamma+\delta+\varepsilon=0$</span>.</p>
<p>Is it possible to obtain a closed-form expression of <span class=""math-container"">$\left\|\Phi_1-\Phi_2\right\|_{\diamond}$</span>?</p>
<p>Since this difference is Hermitian preserving, I intended to use the following formula:
<span class=""math-container"">$$\left\|\Phi_1-\Phi_2\right\|_{\diamond}=\max_{|\psi\rangle\in\mathbb{C}^4}\left\|\left({\rm id}\otimes(\Phi_1-\Phi_2\right))(|\psi\rangle\!\langle\psi|)\right\|_1$$</span>
However, the computations get quite overwhelming, not to mention that I would have to optimize over the coefficients of <span class=""math-container"">$|\psi\rangle$</span> thereafter. Furthermore, since I'm interested in a closed form expression, I can't use the semidefinite problem the diamond norm is associated with.</p>
<p>Is there a way for me to compute this diamond norm? If there's not, is it possible if I set some coefficients to <span class=""math-container"">$0$</span>?</p>
",Is it possible to obtain a closed-form expression of the diamond distance between two single-qubit channels?,<quantum-operation><diamond-norm>,0,0,,,"Is it possible to obtain a closed-form expression of the diamond distance between two single-qubit channels? <p>I would like to compute the diamond norm of the difference of two single-qubit channels <span class=""math-container"">$\Phi_1$</span> and <span class=""math-container"">$\Phi_2$</span>. This difference is equal to, for any <span class=""math-container"">$2\times2$</span> complex matrix <span class=""math-container"">$\rho$</span>:
<span class=""math-container"">$$\DeclareMathOperator{tr}{tr}\Phi_1(\rho)-\Phi_2(\rho)=\beta\rho+\gamma Z\rho Z+\delta\tr(\rho)|0\rangle\!\langle0|+\varepsilon\tr(\rho)|1\rangle\!\langle1|$$</span>
with <span class=""math-container"">$\beta+\gamma+\delta+\varepsilon=0$</span>.</p>
<p>Is it possible to obtain a closed-form expression of <span class=""math-container"">$\left\|\Phi_1-\Phi_2\right\|_{\diamond}$</span>?</p>
<p>Since this difference is Hermitian preserving, I intended to use the following formula:
<span class=""math-container"">$$\left\|\Phi_1-\Phi_2\right\|_{\diamond}=\max_{|\psi\rangle\in\mathbb{C}^4}\left\|\left({\rm id}\otimes(\Phi_1-\Phi_2\right))(|\psi\rangle\!\langle\psi|)\right\|_1$$</span>
However, the computations get quite overwhelming, not to mention that I would have to optimize over the coefficients of <span class=""math-container"">$|\psi\rangle$</span> thereafter. Furthermore, since I'm interested in a closed form expression, I can't use the semidefinite problem the diamond norm is associated with.</p>
<p>Is there a way for me to compute this diamond norm? If there's not, is it possible if I set some coefficients to <span class=""math-container"">$0$</span>?</p>
",qc,possible obtain expression diamond distance two channels p would like compute diamond norm difference two channels span span difference equal span complex matrix span span tr tr span p possible obtain expression span p since difference hermitian preserving intended use following formula span c id however computations get quite overwhelming mention would optimize coefficients span thereafter furthermore since interested closed form expression ca use semidefinite problem diamond norm associated p way compute diamond norm possible set coefficients span 0,"[(3, 0.8191802), (9, 0.018651687), (11, 0.034969814), (14, 0.07216596), (15, 0.03840549), (17, 0.014855795)]"
30410,30413.0,2023-02-27 11:30:47,1,133,"<p>thanks for all your answers so far! I'm wondering, what do max_shots and max_errors mean (as in the code below) when sampling from a stabiliser circuit to produce threshold curves using stim? Would changing their values reduce uncertainty when plotting threshold curves for quite large distances of the surface code?</p>
<p><a href=""https://i.sstatic.net/Aopj3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Aopj3.png"" alt=""enter image description here"" /></a></p>
<p>The code I'm using to produce the graph is from Stim's <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">Getting Started</a> notebook but modified to include higher distances:</p>
<pre><code>import scipy.stats
import numpy as np
import stim
import pymatching
import sinter 
from typing import *
import matplotlib.pyplot as plt

surface_code_tasks = [
    sinter.Task(
        circuit = stim.Circuit.generated(
            &quot;surface_code:rotated_memory_z&quot;,
            rounds=d * 3,
            distance=d,
            after_clifford_depolarization=noise,
            after_reset_flip_probability=noise,
            before_measure_flip_probability=noise,
            before_round_data_depolarization=noise,
        ),
        json_metadata={'d': d, 'r': d * 3, 'p': noise},
    )
    for d in [3, 5, 7, 9, 11, 13,15,17,19,21]
    for noise in [0.008, 0.009, 0.01, 0.011, 0.012,0.013]
]

collected_surface_code_stats: List[sinter.TaskStats] = sinter.collect(
    num_workers=4,
    tasks=surface_code_tasks,
    decoders=['pymatching'],
    max_shots=10_000_000,
    max_errors=5_000,
    print_progress=False,
)

#Plot logical error rate per round of stab measurements for each distance

fig, ax = plt.subplots(1, 1)
sinter.plot_error_rate(
    ax=ax,
    stats=collected_surface_code_stats,
    x_func=lambda stats: stats.json_metadata['p'],
    group_func=lambda stats: stats.json_metadata['d'],
    failure_units_per_shot_func=lambda stats: stats.json_metadata['r'],
)
# ax.set_ylim(5e-3, 5e-2)
# ax.set_xlim(0.008, 0.02)
ax.loglog()
ax.set_title(&quot;Rotated Surface Code Error Rates per Round under Circuit Noise&quot;)
ax.set_xlabel(&quot;Physical Error Rate&quot;)
ax.set_ylabel(&quot;Logical Error Rate per Round&quot;)
ax.grid(which='major')
ax.grid(which='minor')
ax.legend()
fig.set_dpi(120)  # Show it bigger
</code></pre>
",max_shots and max_errors to reduce uncerainty in threshold curves with sinter / stim?,<stim>,1,0,,,"max_shots and max_errors to reduce uncerainty in threshold curves with sinter / stim? <p>thanks for all your answers so far! I'm wondering, what do max_shots and max_errors mean (as in the code below) when sampling from a stabiliser circuit to produce threshold curves using stim? Would changing their values reduce uncertainty when plotting threshold curves for quite large distances of the surface code?</p>
<p><a href=""https://i.sstatic.net/Aopj3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Aopj3.png"" alt=""enter image description here"" /></a></p>
<p>The code I'm using to produce the graph is from Stim's <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">Getting Started</a> notebook but modified to include higher distances:</p>
<pre><code>import scipy.stats
import numpy as np
import stim
import pymatching
import sinter 
from typing import *
import matplotlib.pyplot as plt

surface_code_tasks = [
    sinter.Task(
        circuit = stim.Circuit.generated(
            &quot;surface_code:rotated_memory_z&quot;,
            rounds=d * 3,
            distance=d,
            after_clifford_depolarization=noise,
            after_reset_flip_probability=noise,
            before_measure_flip_probability=noise,
            before_round_data_depolarization=noise,
        ),
        json_metadata={'d': d, 'r': d * 3, 'p': noise},
    )
    for d in [3, 5, 7, 9, 11, 13,15,17,19,21]
    for noise in [0.008, 0.009, 0.01, 0.011, 0.012,0.013]
]

collected_surface_code_stats: List[sinter.TaskStats] = sinter.collect(
    num_workers=4,
    tasks=surface_code_tasks,
    decoders=['pymatching'],
    max_shots=10_000_000,
    max_errors=5_000,
    print_progress=False,
)

#Plot logical error rate per round of stab measurements for each distance

fig, ax = plt.subplots(1, 1)
sinter.plot_error_rate(
    ax=ax,
    stats=collected_surface_code_stats,
    x_func=lambda stats: stats.json_metadata['p'],
    group_func=lambda stats: stats.json_metadata['d'],
    failure_units_per_shot_func=lambda stats: stats.json_metadata['r'],
)
# ax.set_ylim(5e-3, 5e-2)
# ax.set_xlim(0.008, 0.02)
ax.loglog()
ax.set_title(&quot;Rotated Surface Code Error Rates per Round under Circuit Noise&quot;)
ax.set_xlabel(&quot;Physical Error Rate&quot;)
ax.set_ylabel(&quot;Logical Error Rate per Round&quot;)
ax.grid(which='major')
ax.grid(which='minor')
ax.legend()
fig.set_dpi(120)  # Show it bigger
</code></pre>
",qc,reduce uncerainty threshold curves sinter stim p thanks answers far wondering mean code sampling stabiliser circuit produce threshold curves using stim would changing values reduce uncertainty plotting threshold curves quite large distances surface code p https nofollow noreferrer img https enter image description p code using produce graph stim https nofollow noreferrer getting started notebook modified include higher distances pre code import import numpy np import stim import pymatching import sinter typing import import plt circuit quot quot 3 r 3 p noise 3 5 7 9 11 noise list plot logical error rate per round stab measurements distance fig ax 1 1 stats p stats stats r quot rotated surface code error rates per round circuit noise quot quot physical error rate quot quot logical error rate per round quot 120 show bigger,"[(0, 0.15783508), (4, 0.17056485), (5, 0.26738113), (6, 0.0697576), (8, 0.035078824), (14, 0.08147071), (17, 0.07993851), (19, 0.1370582)]"
30445,34013.0,2023-03-01 22:36:13,1,599,"<p>In <a href=""https://en.wikipedia.org/wiki/The_Fabric_of_Reality"" rel=""nofollow noreferrer"">The Fabric of Reality</a>, David Deutsch argues the following:</p>
<blockquote>
<p>To those who still cling to a single-universe world-view, I issue this challenge: <em>explain how Shor's algorithm works.</em> I do not merely mean predict that it will work, which is merely a matter of solving a few uncontroversial equations. I mean provide an explanation. When Shor's algorithm has factorized a number, using <span class=""math-container"">$10^{500}$</span> or so times the computational resources that can be seen to be present, where was the number factorized? There are only about <span class=""math-container"">$10^{80}$</span> atoms in the entire visible universe, an utterly minuscule number compared with <span class=""math-container"">$10^{500}$</span>. So if the visible universe where the extent of physical reality, physical reality would not even remotely contain the resources required to factorize such a large number. Who did factorize it, then? How, and where, was the computation performed?</p>
</blockquote>
<p>Doesn't this imply the existence of the multiverse? How/where could the number be factorized otherwise?</p>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/8662/effects-of-quantum-computing-on-parallel-universes"">This thread</a> does not answer this question, as 1. the fact that there are still <a href=""https://quantumcomputing.stackexchange.com/a/8663/23560"">some unknowns</a> doesn't necessarily mean the multiverse theory is wrong, and 2. it doesn't explain how/where the number could be factorized otherwise if not in the so-called &quot;parallel universes&quot;.</p>
",Does Shor's algorithm imply the existence of the multiverse?,<shors-algorithm>,3,5,,,"Does Shor's algorithm imply the existence of the multiverse? <p>In <a href=""https://en.wikipedia.org/wiki/The_Fabric_of_Reality"" rel=""nofollow noreferrer"">The Fabric of Reality</a>, David Deutsch argues the following:</p>
<blockquote>
<p>To those who still cling to a single-universe world-view, I issue this challenge: <em>explain how Shor's algorithm works.</em> I do not merely mean predict that it will work, which is merely a matter of solving a few uncontroversial equations. I mean provide an explanation. When Shor's algorithm has factorized a number, using <span class=""math-container"">$10^{500}$</span> or so times the computational resources that can be seen to be present, where was the number factorized? There are only about <span class=""math-container"">$10^{80}$</span> atoms in the entire visible universe, an utterly minuscule number compared with <span class=""math-container"">$10^{500}$</span>. So if the visible universe where the extent of physical reality, physical reality would not even remotely contain the resources required to factorize such a large number. Who did factorize it, then? How, and where, was the computation performed?</p>
</blockquote>
<p>Doesn't this imply the existence of the multiverse? How/where could the number be factorized otherwise?</p>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/8662/effects-of-quantum-computing-on-parallel-universes"">This thread</a> does not answer this question, as 1. the fact that there are still <a href=""https://quantumcomputing.stackexchange.com/a/8663/23560"">some unknowns</a> doesn't necessarily mean the multiverse theory is wrong, and 2. it doesn't explain how/where the number could be factorized otherwise if not in the so-called &quot;parallel universes&quot;.</p>
",qc,shor algorithm imply existence multiverse p https nofollow noreferrer fabric reality david deutsch argues following blockquote p still cling issue challenge em explain shor algorithm merely mean predict work merely matter solving uncontroversial equations mean provide explanation shor algorithm factorized number using span 500 times computational resources seen present number factorized span 80 atoms entire visible universe utterly minuscule number compared span 500 visible universe extent physical reality physical reality would even remotely contain resources required factorize large number factorize computation performed p imply existence multiverse could number factorized otherwise p https thread answer question fact still https unknowns necessarily mean multiverse theory wrong explain number could factorized otherwise quot parallel universes quot,"[(4, 0.031878024), (7, 0.2805644), (8, 0.443018), (9, 0.05377508), (10, 0.012267578), (12, 0.01052544), (14, 0.0381473), (15, 0.087428816), (17, 0.019460129), (19, 0.021925706)]"
31469,,2023-03-03 19:07:03,2,111,"<p>The problem I have is that, I have a quantum circuit performing a certain task (e.g. Shor's algorithm) and the circuit is subject to depolarizing noise, Pauli errors, after each gate. And I want to investigate the correlation between the success probability of the final output and physical error rate, given no error correction is applied. I have trouble with such analysis ... since for each gate applied there is a new conditional probability, it gets quite messy ... and I don't think it's a Markov chain?
I think this question arises very naturally but I'm unable to find resources on such theoretical analysis. Could anyone give suggestions or what mathematical tools might be useful? Thanks.</p>
",Bounds on success probability of an algorithm under depolarizing noise,<quantum-algorithms><error-correction><quantum-circuit><error-mitigation>,1,0,,,"Bounds on success probability of an algorithm under depolarizing noise <p>The problem I have is that, I have a quantum circuit performing a certain task (e.g. Shor's algorithm) and the circuit is subject to depolarizing noise, Pauli errors, after each gate. And I want to investigate the correlation between the success probability of the final output and physical error rate, given no error correction is applied. I have trouble with such analysis ... since for each gate applied there is a new conditional probability, it gets quite messy ... and I don't think it's a Markov chain?
I think this question arises very naturally but I'm unable to find resources on such theoretical analysis. Could anyone give suggestions or what mathematical tools might be useful? Thanks.</p>
",qc,bounds success probability algorithm depolarizing noise p problem quantum circuit performing certain task shor algorithm circuit subject depolarizing noise pauli errors gate want investigate correlation success probability final output physical error rate given error correction applied trouble analysis since gate applied new conditional probability gets quite messy think markov chain think question arises naturally unable find resources theoretical analysis could anyone give suggestions mathematical tools might useful,"[(5, 0.19018716), (7, 0.07347064), (8, 0.28711239), (13, 0.10218525), (14, 0.22455078), (17, 0.027682578), (18, 0.09284656)]"
31511,,2023-03-06 20:26:24,1,50,"<p>I'm trying to evolve a 3 qubit system under a Pauli Sum Hamiltonian in QISKIT using the TrotterQRTE method, and observe the projection of on the singlet state at every time step. How do I program the singlet projector properly in 'aux_operators'?</p>
<pre><code>def TimeEvolve(theta, A=A_vedral, gamma=5.):
     hamiltonian = PauliSumHamiltonian(theta,A)
     qr_pair = QuantumRegister(2, name=&quot;e&quot;)
     qr_mol = QuantumRegister(1, name=&quot;z&quot;)
     qc_initial = QuantumCircuit(qr_pair, qr_mol)
     qc_initial.x(0)
     qc_initial.x(1)
     qc_initial.h(1)
     qc_initial.cnot(1, 0)


     projector = tensor(singlet_state().proj(), qeye(2)).unit().data.toarray()

     time = gamma
     evolution_problem = EvolutionProblem(hamiltonian, time, qc_initial, aux_operators=projector)

     product_formula = LieTrotter(reps = 2)
     backend = AerSimulator(method='density_matrix')#,noise_model=noise_model)
     quantum_instance = QuantumInstance(backend=backend)
     expectation = AerPauliExpectation()#.convert(measurable_expression)
     trotter_qrte = TrotterQRTE(product_formula = product_formula, expectation=expectation, quantum_instance=quantum_instance)
     evolved_state = trotter_qrte.evolve(evolution_problem).evolved_state
     return evolved_state
</code></pre>
<p>I usually get the error &quot;QiskitError: 'Sum of amplitudes-squared does not equal one.'&quot;. I'm only interested in measuring the first two qubits.</p>
",How do I use 'aux_operators' in 'TrotterQRTE' time evolution problem?,<qiskit><trotterization>,0,0,,,"How do I use 'aux_operators' in 'TrotterQRTE' time evolution problem? <p>I'm trying to evolve a 3 qubit system under a Pauli Sum Hamiltonian in QISKIT using the TrotterQRTE method, and observe the projection of on the singlet state at every time step. How do I program the singlet projector properly in 'aux_operators'?</p>
<pre><code>def TimeEvolve(theta, A=A_vedral, gamma=5.):
     hamiltonian = PauliSumHamiltonian(theta,A)
     qr_pair = QuantumRegister(2, name=&quot;e&quot;)
     qr_mol = QuantumRegister(1, name=&quot;z&quot;)
     qc_initial = QuantumCircuit(qr_pair, qr_mol)
     qc_initial.x(0)
     qc_initial.x(1)
     qc_initial.h(1)
     qc_initial.cnot(1, 0)


     projector = tensor(singlet_state().proj(), qeye(2)).unit().data.toarray()

     time = gamma
     evolution_problem = EvolutionProblem(hamiltonian, time, qc_initial, aux_operators=projector)

     product_formula = LieTrotter(reps = 2)
     backend = AerSimulator(method='density_matrix')#,noise_model=noise_model)
     quantum_instance = QuantumInstance(backend=backend)
     expectation = AerPauliExpectation()#.convert(measurable_expression)
     trotter_qrte = TrotterQRTE(product_formula = product_formula, expectation=expectation, quantum_instance=quantum_instance)
     evolved_state = trotter_qrte.evolve(evolution_problem).evolved_state
     return evolved_state
</code></pre>
<p>I usually get the error &quot;QiskitError: 'Sum of amplitudes-squared does not equal one.'&quot;. I'm only interested in measuring the first two qubits.</p>
",qc,use time evolution problem p trying evolve 3 qubit system pauli sum hamiltonian qiskit using trotterqrte method observe projection singlet state every time step program singlet projector properly pre code def timeevolve theta hamiltonian paulisumhamiltonian theta quantumregister 2 quot e quot quantumregister 1 quot z quot quantumcircuit 0 1 1 1 0 projector tensor qeye 2 time gamma evolutionproblem hamiltonian time lietrotter reps 2 backend aersimulator quantuminstance expectation aerpauliexpectation trotterqrte return p usually get error quot qiskiterror equal quot interested measuring first two,"[(0, 0.29397342), (1, 0.15353738), (2, 0.1264551), (11, 0.025103869), (14, 0.047809362), (17, 0.04095354), (18, 0.13973568), (19, 0.17091545)]"
31528,,2023-03-07 22:56:47,0,59,"<p>If we have the following upper bound on the sum of trace distances:</p>
<p><span class=""math-container"">$$
\frac{1}{N} \sum_{a, b}||p_1(a | b) \rho_{ab} - p_2(a | b) \sigma_{ab}|| \le \epsilon,
$$</span>
where <span class=""math-container"">$p_1$</span> and <span class=""math-container"">$p_2$</span> are two probability distributions and <span class=""math-container"">$\rho_{ab}$</span> and <span class=""math-container"">$\sigma_{ab}$</span> are quantum states depending on <span class=""math-container"">$a, b$</span>.
Then, what is the best that we could say about the following in terms of <span class=""math-container"">$\epsilon$</span>:</p>
<p><span class=""math-container"">$$
||\rho_{ab} - \sigma_{ab}|| \le ? 
$$</span></p>
",Upper bound on trace distance of subsystems based on full system,<quantum-state><trace-distance><trace-norm>,1,0,,,"Upper bound on trace distance of subsystems based on full system <p>If we have the following upper bound on the sum of trace distances:</p>
<p><span class=""math-container"">$$
\frac{1}{N} \sum_{a, b}||p_1(a | b) \rho_{ab} - p_2(a | b) \sigma_{ab}|| \le \epsilon,
$$</span>
where <span class=""math-container"">$p_1$</span> and <span class=""math-container"">$p_2$</span> are two probability distributions and <span class=""math-container"">$\rho_{ab}$</span> and <span class=""math-container"">$\sigma_{ab}$</span> are quantum states depending on <span class=""math-container"">$a, b$</span>.
Then, what is the best that we could say about the following in terms of <span class=""math-container"">$\epsilon$</span>:</p>
<p><span class=""math-container"">$$
||\rho_{ab} - \sigma_{ab}|| \le ? 
$$</span></p>
",qc,upper bound trace distance subsystems based full system p following upper bound sum trace distances p span 1 n b b ab b ab span span two probability distributions span ab span ab quantum states depending span b best could say following terms span p span ab ab,"[(3, 0.93106353), (17, 0.06520146)]"
31567,,2023-03-10 03:38:12,2,118,"<p>Could anyone elaborate on how these three concepts relate to each other? According to Charlie Bennett's original paper <a href=""https://arxiv.org/abs/quant-ph/9604024"" rel=""nofollow noreferrer"">BDSW96</a>, EPP is equivalent to QEC in the sense that both have the hashing bound as capacity. I was quite confused since the EPP and QEC in the paper are rather specific(they did a proof by construction)... as these two areas have evolved greatly over these two decades, does such equivalence still hold? Is there any recent proof?</p>
<p>Mark Wilde in his book presented a proof of the hashing bound <a href=""https://markwilde.com/qit-notes.pdf"" rel=""nofollow noreferrer"">Thm 24.6.2</a>, the capacity of depolarizing channel, based on typical space and its properties. And it's saying there exists some QECC that achieves the bound, I'm wondering if such proof can be extended to EPP</p>
","How do Hashing bound, entanglement purification, and QECC, relate to each other?",<entanglement><error-correction><depolarizing-channel><channel-capacity>,0,1,,,"How do Hashing bound, entanglement purification, and QECC, relate to each other? <p>Could anyone elaborate on how these three concepts relate to each other? According to Charlie Bennett's original paper <a href=""https://arxiv.org/abs/quant-ph/9604024"" rel=""nofollow noreferrer"">BDSW96</a>, EPP is equivalent to QEC in the sense that both have the hashing bound as capacity. I was quite confused since the EPP and QEC in the paper are rather specific(they did a proof by construction)... as these two areas have evolved greatly over these two decades, does such equivalence still hold? Is there any recent proof?</p>
<p>Mark Wilde in his book presented a proof of the hashing bound <a href=""https://markwilde.com/qit-notes.pdf"" rel=""nofollow noreferrer"">Thm 24.6.2</a>, the capacity of depolarizing channel, based on typical space and its properties. And it's saying there exists some QECC that achieves the bound, I'm wondering if such proof can be extended to EPP</p>
",qc,hashing bound entanglement purification qecc relate p could anyone elaborate three concepts relate according charlie bennett original paper https nofollow noreferrer bdsw96 epp equivalent qec sense hashing bound capacity quite confused since epp qec paper rather specific proof construction two areas evolved greatly two decades equivalence still hold recent proof p mark wilde book presented proof hashing bound https nofollow noreferrer thm capacity depolarizing channel based typical space properties saying exists qecc achieves bound wondering proof extended epp,"[(3, 0.26759973), (5, 0.05618331), (7, 0.060998227), (9, 0.46960187), (13, 0.08515203), (17, 0.05843937)]"
31572,,2023-03-10 13:36:37,2,312,"<p>I was curious to whether the two logical qubits on the toric code can be entangled through, for instance, a logical CNOT operation. However, I cannot find any information on this, only how you can do this on the surface code through braiding defects. I was wondering if people already looked into this because I haven't been able to find anything yet in literature. Does lattice surgery provide an option?</p>
",Is there a way to perform a defect-free logical CNOT on the toric code?,<entanglement><error-correction><surface-code><topological-quantum-computing><toric-code>,1,1,,,"Is there a way to perform a defect-free logical CNOT on the toric code? <p>I was curious to whether the two logical qubits on the toric code can be entangled through, for instance, a logical CNOT operation. However, I cannot find any information on this, only how you can do this on the surface code through braiding defects. I was wondering if people already looked into this because I haven't been able to find anything yet in literature. Does lattice surgery provide an option?</p>
",qc,way perform logical cnot toric code p curious whether two logical qubits toric code entangled instance logical cnot operation however find information surface code braiding defects wondering people already looked able find anything yet literature lattice surgery provide option,"[(5, 0.3432273), (7, 0.22766945), (11, 0.02581153), (13, 0.07964531), (16, 0.066976756), (17, 0.05352013), (18, 0.199832)]"
31573,,2023-03-10 14:15:54,1,82,"<p>I have a few questions regarding dynamics rescaling for zero noise extrapolation. In the paper <a href=""https://arxiv.org/abs/1612.02058"" rel=""nofollow noreferrer"">Error mitigation for short-depth quantum circuits</a>, in equation (30), they write</p>
<p>We redefine <span class=""math-container"">$T \rightarrow T^{\prime}=c T$</span> as well as  <span class=""math-container"">$J_\alpha(t) \rightarrow J_\alpha^{\prime}(t)=c^{-1} J_\alpha\left(c^{-1} t\right) $</span> from which also <span class=""math-container"">$ \rho(t) \rightarrow \rho^{\prime}(t)=\rho\left(c^{-1} t\right)   (30)$</span></p>
<p>We claim that this rescaling maps <span class=""math-container"">$\rho_\lambda^{\prime}\left(T^{\prime}\right)=\rho_{c \lambda}(T)$</span> if the noise operator <span class=""math-container"">$\mathcal{L}$</span> does not depend on the Hamiltonian couplings <span class=""math-container"">$J_\alpha(t)$</span> and is constant in time.</p>
<p>Context:
<span class=""math-container"">$$
\rho_\lambda(T)=\rho(0)-i \int_0^T[K(t), \rho(t)] d t+\lambda \int_0^T \mathcal{L}(\rho(t)) d t .
$$</span></p>
<p>We can now choose a re-parametrization of the evolution <span class=""math-container"">$c^{-1} J_\alpha\left(c^{-1} t\right)$</span> and an increased runtime <span class=""math-container"">$c T$</span>, and write
<span class=""math-container"">$$
\rho_\lambda^{\prime}\left(T^{\prime}\right)=\rho(0)-i \int_0^{c T}\left[K^{\prime}(t), \rho^{\prime}(t)\right] d t+\lambda \int_0^{c T} \mathcal{L}\left(\rho^{\prime}(t)\right) d t
$$</span>
with <span class=""math-container"">$K^{\prime}(t)=\sum_\alpha c^{-1} J_\alpha\left(c^{-1} t\right) P_\alpha$</span>. If we now substitute the integration variable according to <span class=""math-container"">$t=c t^{\prime}$</span>, we have that <span class=""math-container"">$d t=c d t^{\prime}$</span>, which leads to
<span class=""math-container"">$$
\begin{aligned}
\rho_\lambda^{\prime}\left(T^{\prime}\right) &amp; =\rho(0)-i \int_0^T \sum_\alpha c^{-1} J_\alpha\left(t^{\prime}\right)\left[P_\alpha, \rho\left(t^{\prime}\right)\right] c d t^{\prime}+\lambda \int_0^T \mathcal{L}\left(\rho^{\prime}(t)\right) c d t^{\prime} \\
&amp; =\rho(0)-i \int_0^T \sum_\alpha\left[K\left(t^{\prime}\right), \rho\left(t^{\prime}\right)\right] d t^{\prime}+\lambda c \int_0^T \mathcal{L}\left(\rho\left(t^{\prime}\right)\right) d t^{\prime} \\
&amp; =\rho_{c \lambda}(T)
\end{aligned}
$$</span></p>
<p>My questions:</p>
<ol>
<li>Why is equation (30) justified? How does rescaling T and J accomplish density matrix rescaling (equation 30) when both commutator and dissipator terms are present? Their claim will only be right if in the integral representation, one makes the substitution for <span class=""math-container"">$\rho'(t)=\rho(t/c)$</span>.</li>
</ol>
<p>If I just have local hamiltonian (unitary evolution, assuming hamiltonians at different times commute), then one can show that <span class=""math-container"">$\rho(t)$</span> is also rescaled as <span class=""math-container"">$\rho(t/c)$</span>.</p>
<p><span class=""math-container"">$U(T,0)*\rho(0)*U^{\dagger}(T,0)=\rho(T)$</span></p>
<p><span class=""math-container"">$U'(T,0)*\rho(0)*U'^{\dagger}(T,0)=\rho'(T)=\rho(T/c)$</span> where</p>
<p><span class=""math-container"">$U(T,0)=exp(-i\int_0^T H(t)dt)$</span> and <span class=""math-container"">$U'(T,0)=exp(-i\int_0^T (1/c)*H(t/c)dt)=U(T/c,0)$</span></p>
<p>But here I have both Hamiltonian and noise term.</p>
<ol start=""2"">
<li>What if I don't have a local hamiltonian evolution and have just the dissipator term, can I still make this claim?</li>
</ol>
","Zero noise extrapolation for error mitigation: Meaning of rescaled density matrix, specifically when there is no local hamiltonian evolution",<qiskit><quantum-operation><noise><error-mitigation><dynamics>,0,0,,,"Zero noise extrapolation for error mitigation: Meaning of rescaled density matrix, specifically when there is no local hamiltonian evolution <p>I have a few questions regarding dynamics rescaling for zero noise extrapolation. In the paper <a href=""https://arxiv.org/abs/1612.02058"" rel=""nofollow noreferrer"">Error mitigation for short-depth quantum circuits</a>, in equation (30), they write</p>
<p>We redefine <span class=""math-container"">$T \rightarrow T^{\prime}=c T$</span> as well as  <span class=""math-container"">$J_\alpha(t) \rightarrow J_\alpha^{\prime}(t)=c^{-1} J_\alpha\left(c^{-1} t\right) $</span> from which also <span class=""math-container"">$ \rho(t) \rightarrow \rho^{\prime}(t)=\rho\left(c^{-1} t\right)   (30)$</span></p>
<p>We claim that this rescaling maps <span class=""math-container"">$\rho_\lambda^{\prime}\left(T^{\prime}\right)=\rho_{c \lambda}(T)$</span> if the noise operator <span class=""math-container"">$\mathcal{L}$</span> does not depend on the Hamiltonian couplings <span class=""math-container"">$J_\alpha(t)$</span> and is constant in time.</p>
<p>Context:
<span class=""math-container"">$$
\rho_\lambda(T)=\rho(0)-i \int_0^T[K(t), \rho(t)] d t+\lambda \int_0^T \mathcal{L}(\rho(t)) d t .
$$</span></p>
<p>We can now choose a re-parametrization of the evolution <span class=""math-container"">$c^{-1} J_\alpha\left(c^{-1} t\right)$</span> and an increased runtime <span class=""math-container"">$c T$</span>, and write
<span class=""math-container"">$$
\rho_\lambda^{\prime}\left(T^{\prime}\right)=\rho(0)-i \int_0^{c T}\left[K^{\prime}(t), \rho^{\prime}(t)\right] d t+\lambda \int_0^{c T} \mathcal{L}\left(\rho^{\prime}(t)\right) d t
$$</span>
with <span class=""math-container"">$K^{\prime}(t)=\sum_\alpha c^{-1} J_\alpha\left(c^{-1} t\right) P_\alpha$</span>. If we now substitute the integration variable according to <span class=""math-container"">$t=c t^{\prime}$</span>, we have that <span class=""math-container"">$d t=c d t^{\prime}$</span>, which leads to
<span class=""math-container"">$$
\begin{aligned}
\rho_\lambda^{\prime}\left(T^{\prime}\right) &amp; =\rho(0)-i \int_0^T \sum_\alpha c^{-1} J_\alpha\left(t^{\prime}\right)\left[P_\alpha, \rho\left(t^{\prime}\right)\right] c d t^{\prime}+\lambda \int_0^T \mathcal{L}\left(\rho^{\prime}(t)\right) c d t^{\prime} \\
&amp; =\rho(0)-i \int_0^T \sum_\alpha\left[K\left(t^{\prime}\right), \rho\left(t^{\prime}\right)\right] d t^{\prime}+\lambda c \int_0^T \mathcal{L}\left(\rho\left(t^{\prime}\right)\right) d t^{\prime} \\
&amp; =\rho_{c \lambda}(T)
\end{aligned}
$$</span></p>
<p>My questions:</p>
<ol>
<li>Why is equation (30) justified? How does rescaling T and J accomplish density matrix rescaling (equation 30) when both commutator and dissipator terms are present? Their claim will only be right if in the integral representation, one makes the substitution for <span class=""math-container"">$\rho'(t)=\rho(t/c)$</span>.</li>
</ol>
<p>If I just have local hamiltonian (unitary evolution, assuming hamiltonians at different times commute), then one can show that <span class=""math-container"">$\rho(t)$</span> is also rescaled as <span class=""math-container"">$\rho(t/c)$</span>.</p>
<p><span class=""math-container"">$U(T,0)*\rho(0)*U^{\dagger}(T,0)=\rho(T)$</span></p>
<p><span class=""math-container"">$U'(T,0)*\rho(0)*U'^{\dagger}(T,0)=\rho'(T)=\rho(T/c)$</span> where</p>
<p><span class=""math-container"">$U(T,0)=exp(-i\int_0^T H(t)dt)$</span> and <span class=""math-container"">$U'(T,0)=exp(-i\int_0^T (1/c)*H(t/c)dt)=U(T/c,0)$</span></p>
<p>But here I have both Hamiltonian and noise term.</p>
<ol start=""2"">
<li>What if I don't have a local hamiltonian evolution and have just the dissipator term, can I still make this claim?</li>
</ol>
",qc,zero noise extrapolation error mitigation meaning rescaled density matrix specifically local hamiltonian evolution p questions regarding dynamics rescaling zero noise extrapolation paper https nofollow noreferrer error mitigation quantum circuits equation 30 write p redefine span well span also span 30 p claim rescaling maps span c noise operator span l depend hamiltonian couplings span constant p context span 0 k l p choose evolution span increased runtime span c write span 0 c c l span substitute integration variable according span span leads span aligned amp 0 c l c amp 0 c l amp c aligned p questions ol li equation 30 justified rescaling j accomplish density matrix rescaling equation 30 commutator dissipator terms present claim right integral representation one makes substitution span p local hamiltonian unitary evolution assuming hamiltonians different times commute one show span also rescaled span p span u 0 p span u 0 p span u h dt span u h dt p hamiltonian noise ol 2 li local hamiltonian evolution dissipator term still make claim,"[(1, 0.07443249), (2, 0.0379825), (3, 0.5087095), (5, 0.02773575), (9, 0.16155571), (11, 0.021428918), (14, 0.06798213), (15, 0.05579382), (17, 0.037747193)]"
31584,31586.0,2023-03-11 06:36:44,3,191,"<p>I was recently attacked by the LockBit 3.0 ransomware. I researched it and found this article: <a href=""https://blogs.vmware.com/security/2022/10/lockbit-3-0-also-known-as-lockbit-black.html"" rel=""nofollow noreferrer"">LockBit 3.0 Ransomware Unlocked</a>. It said that &quot;files are encrypted using the Salsa-20 algorithm.&quot; I have the decryption ID and it also explains that &quot;the unencoded first eight bytes of the public key are converted to their hex values and saved to the DECRYPTION_ID.txt file.&quot; I wondered if I could make a program on a classical computer that could somehow brute-force the keys, but I realized that could take years, literally.</p>
<p>I then wondered if using a quantum computer would help. I saw something called the Grover algorithm that I might need to use. Instead of O(N) time, it makes it O(sqrt N) time. Since, I have the decryption ID, I would think the process would be a little shorter, but maybe not by much. After all this, could I brute force this in a reasonable amount of time? If so, how would I go about it with qiskit?</p>
",Is it possible to brute force the Salsa-20 algorithm with quantum computing in a reasonable amount of time?,<qiskit><programming><quantum-algorithms><grovers-algorithm>,1,0,,,"Is it possible to brute force the Salsa-20 algorithm with quantum computing in a reasonable amount of time? <p>I was recently attacked by the LockBit 3.0 ransomware. I researched it and found this article: <a href=""https://blogs.vmware.com/security/2022/10/lockbit-3-0-also-known-as-lockbit-black.html"" rel=""nofollow noreferrer"">LockBit 3.0 Ransomware Unlocked</a>. It said that &quot;files are encrypted using the Salsa-20 algorithm.&quot; I have the decryption ID and it also explains that &quot;the unencoded first eight bytes of the public key are converted to their hex values and saved to the DECRYPTION_ID.txt file.&quot; I wondered if I could make a program on a classical computer that could somehow brute-force the keys, but I realized that could take years, literally.</p>
<p>I then wondered if using a quantum computer would help. I saw something called the Grover algorithm that I might need to use. Instead of O(N) time, it makes it O(sqrt N) time. Since, I have the decryption ID, I would think the process would be a little shorter, but maybe not by much. After all this, could I brute force this in a reasonable amount of time? If so, how would I go about it with qiskit?</p>
",qc,possible brute force algorithm quantum computing reasonable amount time p recently attacked lockbit ransomware researched found article https nofollow noreferrer lockbit ransomware unlocked said quot files encrypted using quot decryption id also explains quot unencoded first eight bytes public key converted hex values saved quot wondered could make program classical computer could somehow keys realized could take years p wondered using quantum computer would help saw something called grover algorithm might need use instead n time makes sqrt n time since decryption id would think process would little shorter maybe much could brute force reasonable amount time would go qiskit,"[(0, 0.01812395), (5, 0.010255265), (7, 0.14001778), (8, 0.6793303), (9, 0.03674686), (14, 0.034266412), (17, 0.03240212), (19, 0.047565866)]"
31602,31605.0,2023-03-12 10:28:47,1,244,"<p>I am trying to compute the number of circuit layers in a UCC ansatz in Qiskit in order to estimate the circuit running time using CLOPS estimates on IBM quantum devices. Here is what I tried to do:</p>
<pre><code>from qiskit.transpiler import PassManager, StagedPassManager
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.second_q.circuit.library.ansatzes import UCC
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;H&quot;, &quot;Be&quot;, &quot;H&quot;], [(0., 0., -1.3264), (0., 0., 0.), (0., 0., 1.3264)],)
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()   
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

uccsdt_ansatz = UCC(int(num_spin_orbitals/2), num_particles, excitations=&quot;sdt&quot;, qubit_converter=qubit_converter)

# more info on pass managers here: https://qiskit.org/documentation/apidoc/transpiler.html
pm = StagedPassManager(stages=[&quot;init&quot;])
circuit = pm.run(uccsdt_ansatz)
print(circuit.depth())
</code></pre>
<p>However, the above does not work, an exception is thrown ('ListOp' object has no attribute 'to_circuit'). Here is the qiskit version I am using: <a href=""https://i.sstatic.net/nLHVN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nLHVN.png"" alt=""enter image description here"" /></a></p>
",Compute the number of circuit layers in an UCC type ansatz using Qiskit,<qiskit><clops>,2,0,,,"Compute the number of circuit layers in an UCC type ansatz using Qiskit <p>I am trying to compute the number of circuit layers in a UCC ansatz in Qiskit in order to estimate the circuit running time using CLOPS estimates on IBM quantum devices. Here is what I tried to do:</p>
<pre><code>from qiskit.transpiler import PassManager, StagedPassManager
from qiskit_nature.converters.second_quantization import QubitConverter
from qiskit_nature.second_q.circuit.library.ansatzes import UCC
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;H&quot;, &quot;Be&quot;, &quot;H&quot;], [(0., 0., -1.3264), (0., 0., 0.), (0., 0., 1.3264)],)
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()   
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

uccsdt_ansatz = UCC(int(num_spin_orbitals/2), num_particles, excitations=&quot;sdt&quot;, qubit_converter=qubit_converter)

# more info on pass managers here: https://qiskit.org/documentation/apidoc/transpiler.html
pm = StagedPassManager(stages=[&quot;init&quot;])
circuit = pm.run(uccsdt_ansatz)
print(circuit.depth())
</code></pre>
<p>However, the above does not work, an exception is thrown ('ListOp' object has no attribute 'to_circuit'). Here is the qiskit version I am using: <a href=""https://i.sstatic.net/nLHVN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nLHVN.png"" alt=""enter image description here"" /></a></p>
",qc,compute number circuit layers ucc type ansatz using qiskit p trying compute number circuit layers ucc ansatz qiskit order estimate circuit running time using clops estimates ibm quantum devices tried pre code import passmanager stagedpassmanager import qubitconverter import ucc import pyscfdriver import moleculeinfo import paritymapper qubitconverter paritymapper molecule moleculeinfo quot h quot quot quot quot h quot 0 driver molecule quot sto3g quot 0 ucc int quot sdt quot info pass managers https pm stagedpassmanager quot init quot circuit print p however work exception thrown object attribute qiskit version using https nofollow noreferrer img https enter image description,"[(0, 0.32731548), (2, 0.017084233), (4, 0.16185075), (8, 0.11558032), (12, 0.011556718), (14, 0.12077794), (17, 0.051779255), (19, 0.19267802)]"
75755628,,2023-03-16 11:27:09,1,1387,"<p>Ive been trying to solve this issue but this line is causing me trouble</p>
<pre><code>from qiskit.chemistry.core import Hamiltonian, TransformationType
</code></pre>
<p>I know that i have to use qiskit nature instead of qiskit chemistry but i dont know to what i have to migrade to for &quot;Hamiltonian&quot; and &quot;TransformationType&quot;.</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, Aer
from qiskit.aqua import aqua_globals, QuantumInstance
from qiskit.aqua.algorithms import VQE
from qiskit.aqua.components.optimizers import SLSQP
from qiskit.circuit.library import TwoLocal
from qiskit.chemistry.drivers import PySCFDriver
from qiskit.chemistry.core import Hamiltonian, TransformationType

# Set the number of qubits and optimization parameters
n_qubits = 4
depth = 3

# Set up the molecule and driver
molecule = 'H .0 .0 -{0}; H .0 .0 {0}'
distance = 0.74
driver = PySCFDriver(atom=molecule.format(distance/2), 
unit=TransformationType.ANGSTROM, charge=0, spin=0, basis='sto3g')
qmolecule = driver.run()
hamiltonian = qmolecule.get_molecular_hamiltonian()

# Define the ansatz circuit
ansatz = TwoLocal(n_qubits, ['ry', 'rz'], 'cz', reps=depth)

# Define the optimizer
optimizer = SLSQP(maxiter=1000)

# Define the VQE algorithm
vqe = VQE(ansatz, optimizer)

# Run the VQE algorithm
result = vqe.compute_minimum_eigenvalue(hamiltonian)

# Print the energy of the ground state
print('Ground state energy: ', result.eigenvalue.real)
</code></pre>
",ModuleNotFoundError: No module named 'qiskit.chemistry',<python><quantum-computing><qiskit>,2,2,,,"ModuleNotFoundError: No module named 'qiskit.chemistry' <p>Ive been trying to solve this issue but this line is causing me trouble</p>
<pre><code>from qiskit.chemistry.core import Hamiltonian, TransformationType
</code></pre>
<p>I know that i have to use qiskit nature instead of qiskit chemistry but i dont know to what i have to migrade to for &quot;Hamiltonian&quot; and &quot;TransformationType&quot;.</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, Aer
from qiskit.aqua import aqua_globals, QuantumInstance
from qiskit.aqua.algorithms import VQE
from qiskit.aqua.components.optimizers import SLSQP
from qiskit.circuit.library import TwoLocal
from qiskit.chemistry.drivers import PySCFDriver
from qiskit.chemistry.core import Hamiltonian, TransformationType

# Set the number of qubits and optimization parameters
n_qubits = 4
depth = 3

# Set up the molecule and driver
molecule = 'H .0 .0 -{0}; H .0 .0 {0}'
distance = 0.74
driver = PySCFDriver(atom=molecule.format(distance/2), 
unit=TransformationType.ANGSTROM, charge=0, spin=0, basis='sto3g')
qmolecule = driver.run()
hamiltonian = qmolecule.get_molecular_hamiltonian()

# Define the ansatz circuit
ansatz = TwoLocal(n_qubits, ['ry', 'rz'], 'cz', reps=depth)

# Define the optimizer
optimizer = SLSQP(maxiter=1000)

# Define the VQE algorithm
vqe = VQE(ansatz, optimizer)

# Run the VQE algorithm
result = vqe.compute_minimum_eigenvalue(hamiltonian)

# Print the energy of the ground state
print('Ground state energy: ', result.eigenvalue.real)
</code></pre>
",so_new,modulenotfounderror module named p ive trying solve issue line causing trouble pre code import hamiltonian transformationtype p know use qiskit nature instead qiskit chemistry dont know migrade quot hamiltonian quot quot transformationtype quot pre code import numpy np qiskit import quantumcircuit aer import quantuminstance import vqe import slsqp import twolocal import pyscfdriver import hamiltonian transformationtype set number qubits optimization parameters 4 depth 3 set molecule driver molecule h 0 h 0 distance driver pyscfdriver qmolecule hamiltonian define ansatz circuit ansatz twolocal define optimizer optimizer slsqp define vqe algorithm vqe vqe ansatz optimizer run vqe algorithm result hamiltonian print energy ground state print state energy,"[(0, 0.59745526), (1, 0.07810933), (8, 0.05616897), (17, 0.22595307), (19, 0.040872853)]"
31697,,2023-03-16 13:20:51,0,600,"<p>Say I have a quantum circuit like this</p>
<p><a href=""https://i.sstatic.net/h1pqN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/h1pqN.png"" alt=""Circuit"" /></a></p>
<p>This is an ansatz for solving linear equation provided in the <a href=""https://qiskit.org/textbook/ch-paper-implementations/vqls.html#2.-The-Algorithm"" rel=""nofollow noreferrer"">Qiskit's textbook</a></p>
<p>In the textbook, it was shown how to find the optimal parameters of this ansatz such that the cost function is minimized. I want to assign the array of optimal parameters to this ansatz. How do I do it?</p>
",How to assign new parameters to an existing quantum circuit?,<qiskit><quantum-circuit><vqe>,1,0,,,"How to assign new parameters to an existing quantum circuit? <p>Say I have a quantum circuit like this</p>
<p><a href=""https://i.sstatic.net/h1pqN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/h1pqN.png"" alt=""Circuit"" /></a></p>
<p>This is an ansatz for solving linear equation provided in the <a href=""https://qiskit.org/textbook/ch-paper-implementations/vqls.html#2.-The-Algorithm"" rel=""nofollow noreferrer"">Qiskit's textbook</a></p>
<p>In the textbook, it was shown how to find the optimal parameters of this ansatz such that the cost function is minimized. I want to assign the array of optimal parameters to this ansatz. How do I do it?</p>
",qc,assign new parameters existing quantum circuit p say quantum circuit like p https nofollow noreferrer img https circuit p ansatz solving linear equation provided https nofollow noreferrer qiskit textbook p textbook shown find optimal parameters ansatz cost function minimized want assign array optimal parameters ansatz,"[(0, 0.23585145), (4, 0.4427702), (8, 0.2936951), (17, 0.024062518)]"
31713,,2023-03-17 14:09:05,1,127,"<p>I have wrote some code using Qiskit in Jupyter notebook using Microsoft Visual Studio Code. Is there any way to run directly on an IBM quantum computer through Visual Studio?</p>
",Execute using circuits on IBM hardware using visual studio code,<ibm-q-experience><ibm-quantum-devices>,0,0,,,"Execute using circuits on IBM hardware using visual studio code <p>I have wrote some code using Qiskit in Jupyter notebook using Microsoft Visual Studio Code. Is there any way to run directly on an IBM quantum computer through Visual Studio?</p>
",qc,execute using circuits ibm hardware using visual studio code p wrote code using qiskit jupyter notebook using microsoft visual studio code way run directly ibm quantum computer visual studio,"[(12, 0.206603), (14, 0.7526098), (17, 0.034964174)]"
31729,31732.0,2023-03-18 18:18:45,2,179,"<p>Consider the blow four-qubit W state</p>
<p><span class=""math-container"">$\frac12(\left| 1000 \right&gt;+\left| 0100 \right&gt;+\left| 0010 \right&gt;+\left| 0001 \right&gt;)$</span></p>
<p>I know if we remove any qubit the rest state stay entangled.</p>
<p>So if we remove arbitrary two qubits, the rest two qubits state entangled as well?</p>
<p>Based on it, can we say the graph of a W state is as below? where the points stand for qubits and the lines stand for entanglement between any two qubits.</p>
<p><a href=""https://i.sstatic.net/L3J4s.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/L3J4s.png"" alt=""enter image description here"" /></a></p>
",What does the graph of a W state look like?,<entanglement><w-state>,1,0,,,"What does the graph of a W state look like? <p>Consider the blow four-qubit W state</p>
<p><span class=""math-container"">$\frac12(\left| 1000 \right&gt;+\left| 0100 \right&gt;+\left| 0010 \right&gt;+\left| 0001 \right&gt;)$</span></p>
<p>I know if we remove any qubit the rest state stay entangled.</p>
<p>So if we remove arbitrary two qubits, the rest two qubits state entangled as well?</p>
<p>Based on it, can we say the graph of a W state is as below? where the points stand for qubits and the lines stand for entanglement between any two qubits.</p>
<p><a href=""https://i.sstatic.net/L3J4s.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/L3J4s.png"" alt=""enter image description here"" /></a></p>
",qc,graph w state look like p consider blow w state p span 1000 gt 0100 gt 0010 gt 0001 gt p know remove qubit rest state stay p remove arbitrary two qubits rest two qubits state entangled well p based say graph w state points stand qubits lines stand entanglement two p https nofollow noreferrer img https enter image description,"[(0, 0.048924994), (3, 0.09287651), (4, 0.19858854), (13, 0.18823455), (17, 0.020815639), (18, 0.44811028)]"
31761,,2023-03-22 12:45:43,1,418,"<p>In Stim, logical observable has to be deterministic. To calculate the logical error rate, we compare the <code>actual_observables</code> sampled with stim circuit and <code>predicted_observables</code> which is the prediction from PyMatching.</p>
<p>I wander if we can analyze logical error rate for non-deterministic observable. For example we have a logical state |0&gt;+2|1&gt; (up to a normalization factor), we perform d rounds of error correction and measure in logical X basis. Is it possible to do this? (Though probably it would be tricky to define what logical error rate is in this case).</p>
<p>A more useful application of analyzing non-deterministic observable is lattice surgery, in which we perform logical XX or ZZ measurement on two patches of surface code. However, the joint measurement result is generally random. We perform d rounds of error correction after the merging operation and decode the defect graph to get the predicted value of joint measurement outcome (which is given by the parity of the new stabilizers in the first round of error correction after merging). So how could we determine the measurement outcome of this non-deterministic joint observable fault-tolerantly in this case?</p>
<p>Thanks very much!</p>
",Can Stim and PyMatching analyze logical error rate of non-deterministic observable?,<stim><pymatching>,1,0,,,"Can Stim and PyMatching analyze logical error rate of non-deterministic observable? <p>In Stim, logical observable has to be deterministic. To calculate the logical error rate, we compare the <code>actual_observables</code> sampled with stim circuit and <code>predicted_observables</code> which is the prediction from PyMatching.</p>
<p>I wander if we can analyze logical error rate for non-deterministic observable. For example we have a logical state |0&gt;+2|1&gt; (up to a normalization factor), we perform d rounds of error correction and measure in logical X basis. Is it possible to do this? (Though probably it would be tricky to define what logical error rate is in this case).</p>
<p>A more useful application of analyzing non-deterministic observable is lattice surgery, in which we perform logical XX or ZZ measurement on two patches of surface code. However, the joint measurement result is generally random. We perform d rounds of error correction after the merging operation and decode the defect graph to get the predicted value of joint measurement outcome (which is given by the parity of the new stabilizers in the first round of error correction after merging). So how could we determine the measurement outcome of this non-deterministic joint observable fault-tolerantly in this case?</p>
<p>Thanks very much!</p>
",qc,stim pymatching analyze logical error rate observable p stim logical observable deterministic calculate logical error rate compare code sampled stim circuit code prediction p wander analyze logical error rate observable example logical state gt gt normalization factor perform rounds error correction measure logical x basis possible though probably would tricky define logical error rate case p useful application analyzing observable lattice surgery perform logical xx zz measurement two patches surface code however joint measurement result generally random perform rounds error correction merging operation decode defect graph get predicted value joint measurement outcome given parity new stabilizers first round error correction merging could determine measurement outcome joint observable case p thanks much,"[(3, 0.092956305), (5, 0.49479204), (11, 0.019095689), (13, 0.019552879), (14, 0.1996986), (16, 0.04216774), (17, 0.011725981), (18, 0.11891998)]"
31833,31834.0,2023-03-26 13:10:30,3,762,"<p>When performing a VQE algorithm, the electronic problem Hamiltonian of the physical system under study needs to be mapped to a qubit Hamiltonian written as a sum of tensor products of Pauli operators (X, Y, Z) and the Identity operator forming the so-called Pauli strings. When measuring the expectation value of a Hamiltonian during running VQE calculation, it is desirable to group the list of Pauli strings into commuting subsets in order to minimize the number of measurements. I am trying to understand how this can be achieved in Qiskit. I have looked over the Qiskit code and the conclusions, to me at least, are a bit surprising. Here is the code I have used to run a VQE calculation:</p>
<pre><code>from qiskit.algorithms.optimizers import SLSQP
from qiskit.primitives import Estimator
from qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory
from qiskit_nature.second_q.circuit.library.ansatzes import UCC
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import JordanWignerMapper, ParityMapper, QubitConverter
from qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)

molecule = MoleculeInfo([&quot;H&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 0.74)])

driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()
second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals

ucc = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter)
vqe_factory = VQEUCCFactory(Estimator(), ucc, SLSQP(), initial_point = HFInitialPoint())  
gse = GroundStateEigensolver(qubit_converter, vqe_factory)

# comment out line where solve method is invoked:
# result = gse.solve(electronic_structure_problem)

# the commented line above is actually calling:
main_operator, aux_ops = gse.get_qubit_operators(electronic_structure_problem)
raw_mes_result = gse.solver.compute_minimum_eigenvalue(main_operator, aux_ops)
print(&quot;\n grouping type: &quot;, main_operator.grouping_type)
</code></pre>
<p>This is pretty much generic Qiskit code. I might be wrong here but, it looks to me that when running this piece of code, no grouping algorithm is applied by default to the Pauli strings. The last print statement in the code above outputs: 'None'. Also, I cannot find an obvious way to select a grouping method. How can one do that? It would be great if somebody could provide an answer along with some pointers to the Qiskit code in order to understand what is actually going on.</p>
<p>After a grouping method is applied when measuring the expectation value of Pauli terms, a rotation must be made to a basis where X and Y operators are changed into Zs in order to perform measurements on a real quantum computer, which typically makes measurements only in the Z basis. From looking at Qiskit code, I see two options for grouping: qubit-wise and a second graph based approach. After using the qubit-wise method, finding a rotation basis is rather easy. The downside is that the number of Pauli groups is relatively large. The other method produces a significantly smaller number of Pauli groups but finding a rotation basis is not so easy. I am wondering what is the computational cost for the second approach? Is it feasible for large molecules (100 orbitals) or is it one of those problems that grow exponentially with the Pauli weight of the list of Pauli strings (the maximum number of non-identity elements in a given spin operator)?</p>
<p>Qiskit code also makes reference to a so-called TPB (Tensor Product Basis) grouping method. What is this and how it relates to the discussion above?</p>
<p>Here is the software version I am using:
<a href=""https://i.sstatic.net/n7FvG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/n7FvG.png"" alt=""enter image description here"" /></a></p>
",How grouping of Pauli strings is handled in Qiskit when running VQE?,<qiskit><vqe><pauli-group>,1,0,,,"How grouping of Pauli strings is handled in Qiskit when running VQE? <p>When performing a VQE algorithm, the electronic problem Hamiltonian of the physical system under study needs to be mapped to a qubit Hamiltonian written as a sum of tensor products of Pauli operators (X, Y, Z) and the Identity operator forming the so-called Pauli strings. When measuring the expectation value of a Hamiltonian during running VQE calculation, it is desirable to group the list of Pauli strings into commuting subsets in order to minimize the number of measurements. I am trying to understand how this can be achieved in Qiskit. I have looked over the Qiskit code and the conclusions, to me at least, are a bit surprising. Here is the code I have used to run a VQE calculation:</p>
<pre><code>from qiskit.algorithms.optimizers import SLSQP
from qiskit.primitives import Estimator
from qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory
from qiskit_nature.second_q.circuit.library.ansatzes import UCC
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import JordanWignerMapper, ParityMapper, QubitConverter
from qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)

molecule = MoleculeInfo([&quot;H&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 0.74)])

driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()
second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals

ucc = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter)
vqe_factory = VQEUCCFactory(Estimator(), ucc, SLSQP(), initial_point = HFInitialPoint())  
gse = GroundStateEigensolver(qubit_converter, vqe_factory)

# comment out line where solve method is invoked:
# result = gse.solve(electronic_structure_problem)

# the commented line above is actually calling:
main_operator, aux_ops = gse.get_qubit_operators(electronic_structure_problem)
raw_mes_result = gse.solver.compute_minimum_eigenvalue(main_operator, aux_ops)
print(&quot;\n grouping type: &quot;, main_operator.grouping_type)
</code></pre>
<p>This is pretty much generic Qiskit code. I might be wrong here but, it looks to me that when running this piece of code, no grouping algorithm is applied by default to the Pauli strings. The last print statement in the code above outputs: 'None'. Also, I cannot find an obvious way to select a grouping method. How can one do that? It would be great if somebody could provide an answer along with some pointers to the Qiskit code in order to understand what is actually going on.</p>
<p>After a grouping method is applied when measuring the expectation value of Pauli terms, a rotation must be made to a basis where X and Y operators are changed into Zs in order to perform measurements on a real quantum computer, which typically makes measurements only in the Z basis. From looking at Qiskit code, I see two options for grouping: qubit-wise and a second graph based approach. After using the qubit-wise method, finding a rotation basis is rather easy. The downside is that the number of Pauli groups is relatively large. The other method produces a significantly smaller number of Pauli groups but finding a rotation basis is not so easy. I am wondering what is the computational cost for the second approach? Is it feasible for large molecules (100 orbitals) or is it one of those problems that grow exponentially with the Pauli weight of the list of Pauli strings (the maximum number of non-identity elements in a given spin operator)?</p>
<p>Qiskit code also makes reference to a so-called TPB (Tensor Product Basis) grouping method. What is this and how it relates to the discussion above?</p>
<p>Here is the software version I am using:
<a href=""https://i.sstatic.net/n7FvG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/n7FvG.png"" alt=""enter image description here"" /></a></p>
",qc,grouping pauli strings handled qiskit running vqe p performing vqe algorithm electronic problem hamiltonian physical system study needs mapped qubit hamiltonian written sum tensor products pauli operators x z identity operator forming pauli strings measuring expectation value hamiltonian running vqe calculation desirable group list pauli strings commuting subsets order minimize number measurements trying understand achieved qiskit looked qiskit code conclusions least bit surprising code used run vqe calculation pre code import slsqp import estimator import groundstateeigensolver vqeuccfactory import ucc import pyscfdriver import moleculeinfo import jordanwignermapper paritymapper qubitconverter import hfinitialpoint qubitconverter paritymapper molecule moleculeinfo quot h quot quot h quot driver molecule quot sto3g quot 0 ucc ucc vqeuccfactory estimator ucc slsqp hfinitialpoint gse groundstateeigensolver comment line solve method invoked result commented line actually calling print quot grouping type quot p pretty much generic qiskit code might wrong looks running piece code grouping algorithm applied default pauli strings last print statement code outputs also find obvious way select grouping method one would great somebody could provide answer along pointers qiskit code order understand actually going p grouping method applied measuring expectation value pauli terms rotation must made basis x operators changed zs order perform measurements real quantum computer typically makes measurements z basis looking qiskit code see two options grouping second graph based approach using method finding rotation basis rather easy downside number pauli groups relatively large method produces significantly smaller number pauli groups finding rotation basis easy wondering computational cost second approach feasible large molecules 100 orbitals one problems grow exponentially pauli weight list pauli strings maximum number elements given spin operator p qiskit code also makes reference tpb tensor product basis grouping method relates discussion p software version using https nofollow noreferrer img https enter image description,"[(0, 0.14349411), (1, 0.056133755), (3, 0.088858224), (4, 0.043964848), (5, 0.071557455), (7, 0.071347564), (8, 0.112069204), (9, 0.067291334), (14, 0.2614625), (17, 0.025488038), (19, 0.04417054)]"
31841,31843.0,2023-03-26 23:33:03,0,271,"<p>I am trying to decompose the following circuit using just the CX gate and U3 gate.
<a href=""https://i.sstatic.net/PVgDG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PVgDG.png"" alt=""enter image description here"" /></a></p>
<p>This is because IBM uses CX and U3 gates as basis states and trying to understand the same. Is there a function that decomposes based on the backend configuration?</p>
",How to decompose the following circuit using just CX and U3 gate?,<quantum-gate><programming><quantum-state>,1,0,,,"How to decompose the following circuit using just CX and U3 gate? <p>I am trying to decompose the following circuit using just the CX gate and U3 gate.
<a href=""https://i.sstatic.net/PVgDG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/PVgDG.png"" alt=""enter image description here"" /></a></p>
<p>This is because IBM uses CX and U3 gates as basis states and trying to understand the same. Is there a function that decomposes based on the backend configuration?</p>
",qc,decompose following circuit using cx u3 gate p trying decompose following circuit using cx gate u3 gate https nofollow noreferrer img https enter image description p ibm uses cx u3 gates basis states trying understand function decomposes based backend configuration,"[(4, 0.46074778), (6, 0.06870317), (14, 0.34959334), (17, 0.06604649), (18, 0.051176924)]"
31854,,2023-03-27 14:51:21,5,164,"<p>The <span class=""math-container"">$ [[23,1,7]] $</span> Golay code is an excellent code. It is a doubly even CSS code with <span class=""math-container"">$ H_X=H_Z $</span> and allows transversal implementation of all Clifford gates.</p>
<p>One way in which it is not optimal is that it can only correct <span class=""math-container"">$ 3 $</span> errors ( i.e. <span class=""math-container"">$ d=7 $</span> ). However <a href=""https://arxiv.org/abs/quant-ph/9608006"" rel=""nofollow noreferrer"">existing linear programming bounds</a> suggest that with <span class=""math-container"">$ n=6t-1 $</span> qubits it is possible to correct <span class=""math-container"">$ t $</span> errors . So <span class=""math-container"">$ n=23 $</span> is the first number of qubits for which it may be possible to correct <span class=""math-container"">$ 4 $</span> errors ( i.e. <span class=""math-container"">$ d=9 $</span>).</p>
<p>That leads to my question: Does a <span class=""math-container"">$ [[23,1,9]] $</span> code exist?</p>
","Does a $ [[23,1,9]] $ code exist?",<error-correction>,0,1,,,"Does a $ [[23,1,9]] $ code exist? <p>The <span class=""math-container"">$ [[23,1,7]] $</span> Golay code is an excellent code. It is a doubly even CSS code with <span class=""math-container"">$ H_X=H_Z $</span> and allows transversal implementation of all Clifford gates.</p>
<p>One way in which it is not optimal is that it can only correct <span class=""math-container"">$ 3 $</span> errors ( i.e. <span class=""math-container"">$ d=7 $</span> ). However <a href=""https://arxiv.org/abs/quant-ph/9608006"" rel=""nofollow noreferrer"">existing linear programming bounds</a> suggest that with <span class=""math-container"">$ n=6t-1 $</span> qubits it is possible to correct <span class=""math-container"">$ t $</span> errors . So <span class=""math-container"">$ n=23 $</span> is the first number of qubits for which it may be possible to correct <span class=""math-container"">$ 4 $</span> errors ( i.e. <span class=""math-container"">$ d=9 $</span>).</p>
<p>That leads to my question: Does a <span class=""math-container"">$ [[23,1,9]] $</span> code exist?</p>
",qc,code exist p span golay code excellent code doubly even css code span allows transversal implementation clifford p one way optimal correct span 3 errors span however https nofollow noreferrer existing linear programming bounds suggest span qubits possible correct span errors span first number qubits may possible correct span 4 errors span p leads question span code exist,"[(3, 0.33099777), (5, 0.35559645), (6, 0.019938907), (8, 0.06685682), (9, 0.19742079), (17, 0.026781818)]"
31874,32444.0,2023-03-28 16:58:06,0,271,"<p>I'm trying to study QPE with the motivation of obtaining eigenvalues of Hamiltonian, i.e. energies of a system. My problem is, that while <a href=""https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html"" rel=""nofollow noreferrer"">np.linalg.eig</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.minimum_eigensolvers.VQE.html#qiskit.algorithms.minimum_eigensolvers.VQE"" rel=""nofollow noreferrer"">VQE</a> are agreeing on the lowest energy, energy obtained via QPE is completely off.</p>
<p>My Hamiltonian looks like this
<span class=""math-container"">$$
\widehat{H} = -II + 0.3IZ -0.01ZY + 0.1YX
$$</span></p>
<p>and I'd expect its eigenvalues to be (roughly) <code>[-0.39328755, -0.89, -1.11, -1.60671245]</code>. Using VQE I'm obtaining <code>-1.6067123508302064</code>, i.e. the number very close to the lowest eigenvalue.</p>
<p>On the other hand, when I run my QPE code, I'm getting number like <code>-0.392699</code>, not knowing, where is the problem.</p>
<hr />
<h3>My code</h3>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, execute
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import PhaseEstimation, TwoLocal
from qiskit.extensions import HamiltonianGate
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator

H = SparsePauliOp.from_list([('II', -1), ('IZ', 0.3), ('XI', -0.3), ('ZY', -0.01), ('YX', 0.1)])
Hmat = H.to_matrix()

eig = np.linalg.eigvals(Hmat)
print(eig)

estimator = Estimator()
optimizer = SLSQP()
ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks='cz')

vqe = VQE(estimator, ansatz, optimizer)
result = vqe.compute_minimum_eigenvalue(operator=H)
print(result.eigenvalue)

n_qpe_qbits = 10

U = HamiltonianGate(Hmat, 1, label='H')

# Obtain a solution via QPE
total_qbits = U.num_qubits + n_qpe_qbits
measure_circ = QuantumCircuit(total_qbits, n_qpe_qbits)
qpe = PhaseEstimation(n_qpe_qbits, U)

measure_circ = measure_circ.compose(qpe)
measure_circ.measure(range(n_qpe_qbits), range(n_qpe_qbits))
print(measure_circ.decompose())

backend = AerSimulator(method='statevector')
job = execute(measure_circ, backend, shots=2048)
counts = job.result().get_counts()
print(counts)

max_count = max(counts.items(), key=lambda x: x[1])
print(f'MAX count: {max_count}')

theta = int(max_count[0][::-1], 2) / 2**n_qpe_qbits
print(f'Theta value: {theta}')
print(f'QPE-approximated U-eigenvalue: {np.exp(2*1j*np.pi * theta)}')
print(f'QPE-approximated H-eigenvalue: {-2 * np.pi * theta}')
<span class=""math-container"">```</span>
</code></pre>
",Qiskit - Approximation of Hamiltonian energy via QPE,<qiskit><programming><hamiltonian-simulation><quantum-phase-estimation><chemistry>,1,0,,,"Qiskit - Approximation of Hamiltonian energy via QPE <p>I'm trying to study QPE with the motivation of obtaining eigenvalues of Hamiltonian, i.e. energies of a system. My problem is, that while <a href=""https://numpy.org/doc/stable/reference/generated/numpy.linalg.eig.html"" rel=""nofollow noreferrer"">np.linalg.eig</a> and <a href=""https://qiskit.org/documentation/stubs/qiskit.algorithms.minimum_eigensolvers.VQE.html#qiskit.algorithms.minimum_eigensolvers.VQE"" rel=""nofollow noreferrer"">VQE</a> are agreeing on the lowest energy, energy obtained via QPE is completely off.</p>
<p>My Hamiltonian looks like this
<span class=""math-container"">$$
\widehat{H} = -II + 0.3IZ -0.01ZY + 0.1YX
$$</span></p>
<p>and I'd expect its eigenvalues to be (roughly) <code>[-0.39328755, -0.89, -1.11, -1.60671245]</code>. Using VQE I'm obtaining <code>-1.6067123508302064</code>, i.e. the number very close to the lowest eigenvalue.</p>
<p>On the other hand, when I run my QPE code, I'm getting number like <code>-0.392699</code>, not knowing, where is the problem.</p>
<hr />
<h3>My code</h3>
<pre><code>import numpy as np
from qiskit import QuantumCircuit, execute
from qiskit.algorithms.minimum_eigensolvers import VQE
from qiskit.algorithms.optimizers import SLSQP
from qiskit.circuit.library import PhaseEstimation, TwoLocal
from qiskit.extensions import HamiltonianGate
from qiskit.primitives import Estimator
from qiskit.quantum_info import SparsePauliOp
from qiskit_aer import AerSimulator

H = SparsePauliOp.from_list([('II', -1), ('IZ', 0.3), ('XI', -0.3), ('ZY', -0.01), ('YX', 0.1)])
Hmat = H.to_matrix()

eig = np.linalg.eigvals(Hmat)
print(eig)

estimator = Estimator()
optimizer = SLSQP()
ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks='cz')

vqe = VQE(estimator, ansatz, optimizer)
result = vqe.compute_minimum_eigenvalue(operator=H)
print(result.eigenvalue)

n_qpe_qbits = 10

U = HamiltonianGate(Hmat, 1, label='H')

# Obtain a solution via QPE
total_qbits = U.num_qubits + n_qpe_qbits
measure_circ = QuantumCircuit(total_qbits, n_qpe_qbits)
qpe = PhaseEstimation(n_qpe_qbits, U)

measure_circ = measure_circ.compose(qpe)
measure_circ.measure(range(n_qpe_qbits), range(n_qpe_qbits))
print(measure_circ.decompose())

backend = AerSimulator(method='statevector')
job = execute(measure_circ, backend, shots=2048)
counts = job.result().get_counts()
print(counts)

max_count = max(counts.items(), key=lambda x: x[1])
print(f'MAX count: {max_count}')

theta = int(max_count[0][::-1], 2) / 2**n_qpe_qbits
print(f'Theta value: {theta}')
print(f'QPE-approximated U-eigenvalue: {np.exp(2*1j*np.pi * theta)}')
print(f'QPE-approximated H-eigenvalue: {-2 * np.pi * theta}')
<span class=""math-container"">```</span>
</code></pre>
",qc,qiskit approximation hamiltonian energy via qpe p trying study qpe motivation obtaining eigenvalues hamiltonian energies system problem https nofollow noreferrer https nofollow noreferrer vqe agreeing lowest energy energy obtained via qpe completely p hamiltonian looks like span h p expect eigenvalues roughly code using vqe obtaining code number close lowest p hand run qpe code getting number like code knowing hr h3 code pre code import numpy np qiskit import quantumcircuit execute import vqe import slsqp import phaseestimation twolocal import hamiltoniangate import estimator import sparsepauliop import aersimulator h hmat eig hmat print eig estimator estimator optimizer slsqp ansatz twolocal vqe vqe estimator ansatz optimizer result print 10 u hamiltoniangate hmat 1 h obtain solution via qpe quantumcircuit qpe phaseestimation u qpe range range print backend aersimulator job execute backend counts print counts max x x 1 print count theta int 0 2 2 print value theta print 2 1j theta print theta span,"[(0, 0.6186037), (1, 0.043738313), (3, 0.09431775), (4, 0.049370613), (7, 0.12568103), (10, 0.013244933), (12, 0.029274542), (17, 0.02495833)]"
31899,,2023-03-29 14:38:31,2,28,"<p><strong>Question:</strong> imagine that Alice and Bob share, say, one ebit <span class=""math-container"">$\lvert\Phi_+\rangle_\text{AB}$</span>, and that they are only able to carry out local operations and classical communication. Is there an algorithm that allows them to &quot;spread the entanglement&quot; of their maximally entangled pair over two ancillary subsystems without entangling those two subsystems with each other? To be precise, if we suppose that Alice and Bob have the ancillary states <span class=""math-container"">$\lvert 00\rangle_\text{A1A2}$</span> and <span class=""math-container"">$\lvert 00\rangle_\text{B1B2}$</span> respectively, is there a protocol in which Alice and Bob spend their ebit, and the following hold?</p>
<ul>
<li>System A1 is entangled with system B1.</li>
<li>System A2 is entangled with system B2.</li>
<li>The bipartite system A1B1 is <em>not</em> entangled with system A2B2.</li>
</ul>
<p><strong>Motivation:</strong> I've been playing with variations of the CHSH game. We may consider a variation of the CHSH game in which Alice and Bob must play the game twice, they win the overall game if and only if they win <em>both</em> CHSH subgames, but they only have <em>one</em> shared ebit to make use of in their two-subgame game.</p>
<p>An obvious strategy that would clearly outperform any classical strategy would be to spend the ebit on one of the two games, and play the other game classically. But I'm wondering if there's a way to &quot;split&quot; the entanglement of a Bell state over two subsystems in such a way that allows <em>both subgames</em> to be slightly improved by spending one of the two non-maximally entangled subsystems on each of them.</p>
",Spreading entanglement over multiple systems,<entanglement><bell-experiment><nonlocal-games>,0,2,,,"Spreading entanglement over multiple systems <p><strong>Question:</strong> imagine that Alice and Bob share, say, one ebit <span class=""math-container"">$\lvert\Phi_+\rangle_\text{AB}$</span>, and that they are only able to carry out local operations and classical communication. Is there an algorithm that allows them to &quot;spread the entanglement&quot; of their maximally entangled pair over two ancillary subsystems without entangling those two subsystems with each other? To be precise, if we suppose that Alice and Bob have the ancillary states <span class=""math-container"">$\lvert 00\rangle_\text{A1A2}$</span> and <span class=""math-container"">$\lvert 00\rangle_\text{B1B2}$</span> respectively, is there a protocol in which Alice and Bob spend their ebit, and the following hold?</p>
<ul>
<li>System A1 is entangled with system B1.</li>
<li>System A2 is entangled with system B2.</li>
<li>The bipartite system A1B1 is <em>not</em> entangled with system A2B2.</li>
</ul>
<p><strong>Motivation:</strong> I've been playing with variations of the CHSH game. We may consider a variation of the CHSH game in which Alice and Bob must play the game twice, they win the overall game if and only if they win <em>both</em> CHSH subgames, but they only have <em>one</em> shared ebit to make use of in their two-subgame game.</p>
<p>An obvious strategy that would clearly outperform any classical strategy would be to spend the ebit on one of the two games, and play the other game classically. But I'm wondering if there's a way to &quot;split&quot; the entanglement of a Bell state over two subsystems in such a way that allows <em>both subgames</em> to be slightly improved by spending one of the two non-maximally entangled subsystems on each of them.</p>
",qc,spreading entanglement multiple systems p strong question imagine alice bob share say one ebit span ab able carry local operations classical communication algorithm allows quot spread entanglement quot maximally entangled pair two ancillary subsystems without entangling two subsystems precise suppose alice bob ancillary states span a1a2 span b1b2 respectively protocol alice bob spend ebit following hold ul li system a1 entangled system li system a2 entangled system li bipartite system a1b1 em entangled system p strong motivation playing variations chsh game may consider variation chsh game alice bob must play game twice win overall game win em chsh subgames em one shared ebit make use p obvious strategy would clearly outperform classical strategy would spend ebit one two games play game classically wondering way quot split quot entanglement bell state two subsystems way allows em subgames slightly improved spending one two entangled subsystems,"[(3, 0.058476493), (9, 0.19969408), (17, 0.01126109), (18, 0.68938255), (19, 0.032121878)]"
31915,31916.0,2023-03-30 14:47:22,1,176,"<p>I am new to quantum information theory and have been reading Mark Wilde's notes on quantum relative entropy.
<a href=""http://www.markwilde.com/teaching/2015-fall-qit/lectures/lecture-19.pdf"" rel=""nofollow noreferrer"">http://www.markwilde.com/teaching/2015-fall-qit/lectures/lecture-19.pdf</a></p>
<p>I have three basic questions here.</p>
<ol>
<li><p>Why does <span class=""math-container"">$\sigma$</span> belong to the space of bounded linear operators when <span class=""math-container"">$\rho$</span> belongs to the space of density operators? All density operators are anyway bounded operators with trace 1. So why is this distinction between the spaces that <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> belong to? If I look at Watrous's notes (<a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/TQI.5.pdf"" rel=""nofollow noreferrer"">https://cs.uwaterloo.ca/~watrous/TQI/TQI.5.pdf</a>) he refers to both <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> as belonging to the space of positive semidefinite operators and doesn't draw the distinction that Wilde does.</p>
</li>
<li><p>How does the condition <span class=""math-container"">$supp(\rho)\subseteq  supp(\sigma)$</span> figure into the relative entropy being defined in this way? in other words where are we using this condition to form our definition?</p>
</li>
<li><p>What is the intuition behind quantum relative entropy? Why is it exactly defined this way? specifically the second term  <span class=""math-container"">$Tr(\rho(log\sigma))$</span> of the relative entropy expression.</p>
</li>
</ol>
",Quantum Relative entropy- the math and intuition,<density-matrix><information-theory><entropy><linear-algebra><relative-entropy>,1,2,,,"Quantum Relative entropy- the math and intuition <p>I am new to quantum information theory and have been reading Mark Wilde's notes on quantum relative entropy.
<a href=""http://www.markwilde.com/teaching/2015-fall-qit/lectures/lecture-19.pdf"" rel=""nofollow noreferrer"">http://www.markwilde.com/teaching/2015-fall-qit/lectures/lecture-19.pdf</a></p>
<p>I have three basic questions here.</p>
<ol>
<li><p>Why does <span class=""math-container"">$\sigma$</span> belong to the space of bounded linear operators when <span class=""math-container"">$\rho$</span> belongs to the space of density operators? All density operators are anyway bounded operators with trace 1. So why is this distinction between the spaces that <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> belong to? If I look at Watrous's notes (<a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/TQI.5.pdf"" rel=""nofollow noreferrer"">https://cs.uwaterloo.ca/~watrous/TQI/TQI.5.pdf</a>) he refers to both <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> as belonging to the space of positive semidefinite operators and doesn't draw the distinction that Wilde does.</p>
</li>
<li><p>How does the condition <span class=""math-container"">$supp(\rho)\subseteq  supp(\sigma)$</span> figure into the relative entropy being defined in this way? in other words where are we using this condition to form our definition?</p>
</li>
<li><p>What is the intuition behind quantum relative entropy? Why is it exactly defined this way? specifically the second term  <span class=""math-container"">$Tr(\rho(log\sigma))$</span> of the relative entropy expression.</p>
</li>
</ol>
",qc,quantum relative math intuition p new quantum information theory reading mark wilde notes quantum relative entropy http nofollow noreferrer http p three basic questions ol li p span belong space bounded linear operators span belongs space density operators density operators anyway bounded operators trace distinction spaces span span belong look watrous notes https nofollow noreferrer https refers span span belonging space positive semidefinite operators draw distinction wilde li p condition span supp supp figure relative entropy defined way words using condition form definition li p intuition behind quantum relative entropy exactly defined way specifically second term span tr relative entropy,"[(3, 0.6998067), (4, 0.10766581), (7, 0.089685306), (9, 0.03970485), (11, 0.039595574), (17, 0.022143302)]"
31931,31932.0,2023-03-31 18:57:56,1,271,"<p>I have been reading Delfosse's &quot;Almost-linear time decoding algorithm for topological codes&quot; and I understand how to perform syndrome validation and the posterior erasure decoding in toric codes. Nevertheless, I do not understand how this can work in non-periodic surface codes such as rotated planar codes. Since the Union-Find erasure decoder consists in using the information of the non-trivial syndrome elements in order to find the error-chains, if an error chain finishes on certain boundaries of the rotated planar code, one of the two error-chain boundaries can be missing.</p>
<p>An idea which comes to my mind is using the same tactic adopted by the Minimum Weight Perfect Matching decoder, which consists in considering additional checks adjacent to the boundary of the rotated planar code. These checks would be considered as additional non-trivial syndrome elements, thus affecting the parity of the clusters at which they are involved. Nevertheless, this consideration prevents the use of the erasure decoder.</p>
<p>Consider the plots of the slide:</p>
<p>(1) A rotated planar code experiences an error and, upon measurement, the code outcomes a syndrome.</p>
<p>(2-4) A cluster is produced and grows until it reaches even parity (recall that non-trivial syndrome elements have odd parity and so do the additional boundary checks).</p>
<p>Performing the erasure decoder on the final cluster (4) will not return the maximum likelihood error. I have been looking for a possible answer to this question but have not found anything. Is there an answer? Where could I read about it?</p>
<p>Thank you for your help in advance.</p>
<p><a href=""https://i.sstatic.net/ETwbf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ETwbf.png"" alt=""(1) An <span class=""math-container"">$X$</span>-error affects a 3x3 rotated planar code."" /></a></p>
<p><a href=""https://i.sstatic.net/lcG1R.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lcG1R.png"" alt=""(2) First cluster growth from one of the triggered checks denoted with red lines."" /></a></p>
<p><a href=""https://i.sstatic.net/UuZIx.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UuZIx.png"" alt=""(3)Second cluster growth, denoted with purple lines."" /></a></p>
<p><a href=""https://i.sstatic.net/tvIBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/tvIBM.png"" alt=""(4)Third and last cluster growth."" /></a></p>
",How do you solve Union-Find for non-periodic surface codes?,<error-correction><surface-code>,1,0,,,"How do you solve Union-Find for non-periodic surface codes? <p>I have been reading Delfosse's &quot;Almost-linear time decoding algorithm for topological codes&quot; and I understand how to perform syndrome validation and the posterior erasure decoding in toric codes. Nevertheless, I do not understand how this can work in non-periodic surface codes such as rotated planar codes. Since the Union-Find erasure decoder consists in using the information of the non-trivial syndrome elements in order to find the error-chains, if an error chain finishes on certain boundaries of the rotated planar code, one of the two error-chain boundaries can be missing.</p>
<p>An idea which comes to my mind is using the same tactic adopted by the Minimum Weight Perfect Matching decoder, which consists in considering additional checks adjacent to the boundary of the rotated planar code. These checks would be considered as additional non-trivial syndrome elements, thus affecting the parity of the clusters at which they are involved. Nevertheless, this consideration prevents the use of the erasure decoder.</p>
<p>Consider the plots of the slide:</p>
<p>(1) A rotated planar code experiences an error and, upon measurement, the code outcomes a syndrome.</p>
<p>(2-4) A cluster is produced and grows until it reaches even parity (recall that non-trivial syndrome elements have odd parity and so do the additional boundary checks).</p>
<p>Performing the erasure decoder on the final cluster (4) will not return the maximum likelihood error. I have been looking for a possible answer to this question but have not found anything. Is there an answer? Where could I read about it?</p>
<p>Thank you for your help in advance.</p>
<p><a href=""https://i.sstatic.net/ETwbf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ETwbf.png"" alt=""(1) An <span class=""math-container"">$X$</span>-error affects a 3x3 rotated planar code."" /></a></p>
<p><a href=""https://i.sstatic.net/lcG1R.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lcG1R.png"" alt=""(2) First cluster growth from one of the triggered checks denoted with red lines."" /></a></p>
<p><a href=""https://i.sstatic.net/UuZIx.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/UuZIx.png"" alt=""(3)Second cluster growth, denoted with purple lines."" /></a></p>
<p><a href=""https://i.sstatic.net/tvIBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/tvIBM.png"" alt=""(4)Third and last cluster growth."" /></a></p>
",qc,solve surface codes p reading delfosse quot time decoding algorithm topological codes quot understand perform syndrome validation posterior erasure decoding toric codes nevertheless understand work surface codes rotated planar codes since erasure decoder consists using information syndrome elements order find error chain finishes certain boundaries rotated planar code one two boundaries p idea comes mind using tactic adopted minimum weight perfect matching decoder consists considering additional checks adjacent boundary rotated planar code checks would considered additional syndrome elements thus affecting parity clusters involved nevertheless consideration prevents use erasure p consider plots slide p 1 rotated planar code experiences error upon measurement code outcomes p cluster produced grows reaches even parity recall syndrome elements odd parity additional boundary checks p performing erasure decoder final cluster 4 return maximum likelihood error looking possible answer question found anything answer could read p thank help p https nofollow noreferrer img https 1 span x affects 3x3 rotated planar code p https nofollow noreferrer img https 2 first cluster growth one triggered checks denoted red lines p https nofollow noreferrer img https 3 second cluster growth denoted purple lines p https nofollow noreferrer img https 4 third last cluster growth,"[(3, 0.040185582), (4, 0.124032915), (5, 0.2625203), (6, 0.022572748), (7, 0.060596988), (9, 0.14412116), (13, 0.23867485), (14, 0.025884546), (17, 0.04836112), (19, 0.024148472)]"
31996,31997.0,2023-04-05 09:43:28,0,224,"<p>I want to understand how the number of function evaluation is calculated by Qiskit when running VQE algorithms. Here is some code I used in order to test this:</p>
<pre><code>from qiskit.primitives import Estimator
from qiskit.providers.aer import QasmSimulator, AerSimulator
from qiskit.algorithms.optimizers import SLSQP
from qiskit.utils import QuantumInstance
from qiskit_nature.second_q.algorithms import NumPyMinimumEigensolverFactory
from qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint
from qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import QubitConverter
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.circuit.library.ansatzes import UCC

objective_function_tolerance = 1e-6
slsqp = SLSQP(maxiter=10000, tol=objective_function_tolerance)

numpy_solver = NumPyMinimumEigensolverFactory()
quantum_instance = QuantumInstance(AerSimulator(method='statevector', device=&quot;CPU&quot;))

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])

driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(electronic_structure_problem)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
uccsd = UCC(num_spatial_orbitals, num_particles, excitations='sd')

def callback(eval_count, parameters, mean, std): print(eval_count)

vqe_factory = VQEUCCFactory(Estimator(), uccsd, slsqp, initial_point = HFInitialPoint()) 
vqe_factory.minimum_eigensolver.callback = callback
converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction=None)
gse = GroundStateEigensolver(converter, vqe_factory)
result = gse.solve(electronic_structure_problem)

print(&quot;function evaluations: &quot;, result.raw_result.cost_function_evals)
</code></pre>
<p>From inspecting the Qiskit code, it seems to me that the number of function evaluations is incremented once after each expectation value of the Hamiltonian is measured or calculated in case of running a simulation on a classical computer. This might appear quite reasonable, except that I was somehow expecting/hoping that the number of function evaluation is incremented after each Pauli string (or group of Pauli strings in case those are grouped in commuting sets) is evaluated during a VQE calculation. Could someone please confirm if my conclusion is correct or not? If possible, some pointers towards the relevant Qiskit code would help.</p>
<p>My Qiskit version:</p>
<p><a href=""https://i.sstatic.net/4lar3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4lar3.png"" alt=""enter image description here"" /></a></p>
",How the number of function evaluations is calculated in Qiskit when running VQE,<qiskit><vqe>,1,0,,,"How the number of function evaluations is calculated in Qiskit when running VQE <p>I want to understand how the number of function evaluation is calculated by Qiskit when running VQE algorithms. Here is some code I used in order to test this:</p>
<pre><code>from qiskit.primitives import Estimator
from qiskit.providers.aer import QasmSimulator, AerSimulator
from qiskit.algorithms.optimizers import SLSQP
from qiskit.utils import QuantumInstance
from qiskit_nature.second_q.algorithms import NumPyMinimumEigensolverFactory
from qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint
from qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import QubitConverter
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit_nature.second_q.circuit.library.ansatzes import UCC

objective_function_tolerance = 1e-6
slsqp = SLSQP(maxiter=10000, tol=objective_function_tolerance)

numpy_solver = NumPyMinimumEigensolverFactory()
quantum_instance = QuantumInstance(AerSimulator(method='statevector', device=&quot;CPU&quot;))

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])

driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)
electronic_structure_problem = driver.run()

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(electronic_structure_problem)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
uccsd = UCC(num_spatial_orbitals, num_particles, excitations='sd')

def callback(eval_count, parameters, mean, std): print(eval_count)

vqe_factory = VQEUCCFactory(Estimator(), uccsd, slsqp, initial_point = HFInitialPoint()) 
vqe_factory.minimum_eigensolver.callback = callback
converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction=None)
gse = GroundStateEigensolver(converter, vqe_factory)
result = gse.solve(electronic_structure_problem)

print(&quot;function evaluations: &quot;, result.raw_result.cost_function_evals)
</code></pre>
<p>From inspecting the Qiskit code, it seems to me that the number of function evaluations is incremented once after each expectation value of the Hamiltonian is measured or calculated in case of running a simulation on a classical computer. This might appear quite reasonable, except that I was somehow expecting/hoping that the number of function evaluation is incremented after each Pauli string (or group of Pauli strings in case those are grouped in commuting sets) is evaluated during a VQE calculation. Could someone please confirm if my conclusion is correct or not? If possible, some pointers towards the relevant Qiskit code would help.</p>
<p>My Qiskit version:</p>
<p><a href=""https://i.sstatic.net/4lar3.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4lar3.png"" alt=""enter image description here"" /></a></p>
",qc,number function evaluations calculated qiskit running vqe p want understand number function evaluation calculated qiskit running vqe algorithms code used order test pre code import estimator import qasmsimulator aersimulator import slsqp import quantuminstance import numpyminimumeigensolverfactory import hfinitialpoint import groundstateeigensolver vqeuccfactory import moleculeinfo import qubitconverter import pyscfdriver import freezecoretransformer import ucc slsqp slsqp numpyminimumeigensolverfactory quantuminstance aersimulator quot cpu quot molecule moleculeinfo quot li quot quot h quot driver molecule quot sto3g quot transformer freezecoretransformer uccsd ucc def callback parameters mean std print vqeuccfactory estimator uccsd slsqp hfinitialpoint callback converter qubitconverter paritymapper gse groundstateeigensolver converter result print quot function evaluations quot p inspecting qiskit code seems number function evaluations incremented expectation value hamiltonian measured calculated case running simulation classical computer might appear quite reasonable except somehow number function evaluation incremented pauli string group pauli strings case grouped commuting sets evaluated vqe calculation could someone please confirm conclusion correct possible pointers towards relevant qiskit code would p qiskit version p https nofollow noreferrer img https enter image description,"[(0, 0.40390372), (1, 0.019122208), (4, 0.084457904), (7, 0.045171663), (8, 0.21606302), (9, 0.017507192), (12, 0.020265782), (17, 0.055504046), (19, 0.13726632)]"
32001,,2023-04-05 17:03:42,1,42,"<p>Suppose I have some ground state <span class=""math-container"">$a^\dagger_{k_1,\sigma_1}a^\dagger_{k_2,\sigma_2}a^\dagger_{k_3,\sigma_3}|\emptyset\rangle$</span> where <span class=""math-container"">$|\emptyset\rangle$</span> is the vacuum, <span class=""math-container"">$k_i$</span> is some quantum number and <span class=""math-container"">$\sigma_i$</span> are the spins.</p>
<p>Now suppose I want to calculate, for example something like this</p>
<p><span class=""math-container"">$$\langle A|\sum_{\sigma\sigma'\lambda\lambda'}\sum_{kk'p'p'qq' rr'}a^\dagger_{p\lambda}a^\dagger_{p'\lambda'}a_{q'\lambda'}a_{q'\lambda}a^\dagger_{q\sigma}a^\dagger_{q'\sigma'}a_{k'\sigma'}a_{k\sigma}|A\rangle$$</span>
Clearly there are many ways to simplify this equation.</p>
<p>What would be the best software (Mathematica or Python based) to ALGEBRAICALLY do so? If not how could I code something to simplify such an expression.</p>
",Any good software for fermionic operator algebra manipulation?,<programming><linear-algebra>,0,1,,,"Any good software for fermionic operator algebra manipulation? <p>Suppose I have some ground state <span class=""math-container"">$a^\dagger_{k_1,\sigma_1}a^\dagger_{k_2,\sigma_2}a^\dagger_{k_3,\sigma_3}|\emptyset\rangle$</span> where <span class=""math-container"">$|\emptyset\rangle$</span> is the vacuum, <span class=""math-container"">$k_i$</span> is some quantum number and <span class=""math-container"">$\sigma_i$</span> are the spins.</p>
<p>Now suppose I want to calculate, for example something like this</p>
<p><span class=""math-container"">$$\langle A|\sum_{\sigma\sigma'\lambda\lambda'}\sum_{kk'p'p'qq' rr'}a^\dagger_{p\lambda}a^\dagger_{p'\lambda'}a_{q'\lambda'}a_{q'\lambda}a^\dagger_{q\sigma}a^\dagger_{q'\sigma'}a_{k'\sigma'}a_{k\sigma}|A\rangle$$</span>
Clearly there are many ways to simplify this equation.</p>
<p>What would be the best software (Mathematica or Python based) to ALGEBRAICALLY do so? If not how could I code something to simplify such an expression.</p>
",qc,good software fermionic operator algebra manipulation p suppose ground state span span vacuum span quantum number span p suppose want calculate example something like p span kk p rr clearly many ways simplify p would best software mathematica python based algebraically could code something simplify,"[(1, 0.13003331), (3, 0.4588353), (8, 0.11750244), (11, 0.026849749), (14, 0.21780702), (17, 0.04572956)]"
32072,,2023-04-10 18:20:51,1,60,"<p>Suppose I have a classical or quantum channel <span class=""math-container"">$\mathcal{N}$</span>. I wish to use it for some communication task in the one-shot setting i.e. where I have <span class=""math-container"">$n$</span> i.i.d. copies of <span class=""math-container"">$\mathcal{N}$</span> denoted by <span class=""math-container"">$\mathcal{N}^{\otimes n}$</span>. The result is usually some entropic quantity evaluated on an optimal input probability distribution/quantum state <span class=""math-container"">$\rho^{n}$</span>.</p>
<p>Notice that <span class=""math-container"">$\rho^n$</span> is invariant under permutations among the <span class=""math-container"">$n$</span> registers. This is because if <span class=""math-container"">$\rho^n$</span> is permuted, there exists a decoder that just undoes the permutation after the action of <span class=""math-container"">$\mathcal{N}^{\otimes n}$</span>.</p>
<p>Suppose I now have fewer copies of the channel <span class=""math-container"">$\mathcal{N}^{\otimes k}$</span> for <span class=""math-container"">$k&lt; n$</span>. There exists again a permutation invariant <span class=""math-container"">$\rho^k$</span> that is the optimal input distribution/input quantum state.</p>
<p>Is <span class=""math-container"">$\rho^k$</span> related to <span class=""math-container"">$\rho^n$</span> in some way? For instance, is it obtained by just tracing out the remaining <span class=""math-container"">$n-k$</span> registers? My goal is to use some finite de Finetti theorems to express <span class=""math-container"">$\rho^k$</span> and in order to this, I need to express <span class=""math-container"">$\rho^k$</span> as the marginal of some permutation-invariant state in higher dimension.</p>
",Optimal one-shot input for $\mathcal{N}^{\otimes n}$ and optimal one-shot input for $\mathcal{N}^{\otimes k}$ where $k< n$?,<information-theory><channel-capacity><max-entropy>,0,0,,,"Optimal one-shot input for $\mathcal{N}^{\otimes n}$ and optimal one-shot input for $\mathcal{N}^{\otimes k}$ where $k< n$? <p>Suppose I have a classical or quantum channel <span class=""math-container"">$\mathcal{N}$</span>. I wish to use it for some communication task in the one-shot setting i.e. where I have <span class=""math-container"">$n$</span> i.i.d. copies of <span class=""math-container"">$\mathcal{N}$</span> denoted by <span class=""math-container"">$\mathcal{N}^{\otimes n}$</span>. The result is usually some entropic quantity evaluated on an optimal input probability distribution/quantum state <span class=""math-container"">$\rho^{n}$</span>.</p>
<p>Notice that <span class=""math-container"">$\rho^n$</span> is invariant under permutations among the <span class=""math-container"">$n$</span> registers. This is because if <span class=""math-container"">$\rho^n$</span> is permuted, there exists a decoder that just undoes the permutation after the action of <span class=""math-container"">$\mathcal{N}^{\otimes n}$</span>.</p>
<p>Suppose I now have fewer copies of the channel <span class=""math-container"">$\mathcal{N}^{\otimes k}$</span> for <span class=""math-container"">$k&lt; n$</span>. There exists again a permutation invariant <span class=""math-container"">$\rho^k$</span> that is the optimal input distribution/input quantum state.</p>
<p>Is <span class=""math-container"">$\rho^k$</span> related to <span class=""math-container"">$\rho^n$</span> in some way? For instance, is it obtained by just tracing out the remaining <span class=""math-container"">$n-k$</span> registers? My goal is to use some finite de Finetti theorems to express <span class=""math-container"">$\rho^k$</span> and in order to this, I need to express <span class=""math-container"">$\rho^k$</span> as the marginal of some permutation-invariant state in higher dimension.</p>
",qc,optimal input n n optimal input n k k n p suppose classical quantum channel span n wish use communication task setting span n copies span n denoted span n n result usually entropic quantity evaluated optimal input probability state span n p notice span invariant permutations among span n registers span permuted exists decoder undoes permutation action span n n p suppose fewer copies channel span n k span k lt n exists permutation invariant span optimal input quantum p span related span way instance obtained tracing remaining span registers goal use finite de finetti theorems express span order need express span marginal state higher,"[(3, 0.85907364), (7, 0.021696728), (9, 0.02982765), (10, 0.01990293), (17, 0.034414586), (18, 0.033725172)]"
32080,,2023-04-11 06:37:31,2,461,"<p>I have NVIDIA GeForce GT740 Graphics card installed on my host machine with Windows 10 OS. I have to simulate a cluster environment in order to run qiskit codes in parallel fashion. Before actual Clustering, as POC I have created three ubuntu 20.04 VMs (one head and two compute nodes) on my host machine since qiskit-aer-gpu can be easily installed on Linux. I have used VMWare Workstation Pro for the purpose.</p>
<p>Now on my head node I have created a venv and installed qiskit-aer-gpu along with CUDA</p>
<ul>
<li><p>python version: 3.8.10</p>
</li>
<li><p>qiskit-aer-gpu version: 0.11.2</p>
</li>
<li><p>nvcc version: Cuda compilation tools, release 10.1, V10.1.243</p>
</li>
</ul>
<p>I am running following code as an example just to verify cuda installation on my VM but it generates error</p>
<pre><code>from qiskit import *
from qiskit.circuit.library import *
from qiskit.providers.aer import *
sim = AerSimulator(method= 'statevector', device='GPU')
shots = 100
depth=10
qubits = 25
circuit = transpile(QuantumVolume(qubits, depth, seed=0), backend=sim, optimization_level=0)
circuit.measure_all()
result = execute(circuit,sim,shots=shots,seed_simulator=12345).result()
</code></pre>
<p>Error is</p>
<pre><code>Simulation failed and returned the following error message:
ERROR: Failed to load qobj: No CUDA device available!
</code></pre>
<p>Ubuntu VM sees host GPU like <code>sudo lshw -C display</code></p>
<pre><code>-display                 
   description: VGA compatible controller
   product: SVGA II Adapter
   vendor: VMware
   physical id: f
   bus info: pci@0000:00:0f.0
   version: 00
   width: 32 bits
   clock: 33MHz
   capabilities: vga_controller bus_master cap_list rom
   configuration: driver=vmwgfx latency=64
   resources: irq:16 ioport:1070(size=16) 
   memory:e8000000-efffffff memory:fe000000-fe7fffff 
   memory:c0000-dffff
</code></pre>
<p>I have seen some article in which VM doesnot have direct access to host GPU <a href=""https://superuser.com/questions/299333/vmware-how-to-directly-access-the-gpu"">1</a> and <a href=""https://communities.vmware.com/t5/VMware-Workstation-Pro/VM-have-direct-connection-to-the-host-GPU/td-p/1860425"" rel=""nofollow noreferrer"">2</a>. Am I getting this no device error due to this reason?</p>
<p>Any help will be appreciated.</p>
",GPU Access for qiskit-aer-gpu from Ubuntu VM,<qiskit><programming><simulation>,3,0,,,"GPU Access for qiskit-aer-gpu from Ubuntu VM <p>I have NVIDIA GeForce GT740 Graphics card installed on my host machine with Windows 10 OS. I have to simulate a cluster environment in order to run qiskit codes in parallel fashion. Before actual Clustering, as POC I have created three ubuntu 20.04 VMs (one head and two compute nodes) on my host machine since qiskit-aer-gpu can be easily installed on Linux. I have used VMWare Workstation Pro for the purpose.</p>
<p>Now on my head node I have created a venv and installed qiskit-aer-gpu along with CUDA</p>
<ul>
<li><p>python version: 3.8.10</p>
</li>
<li><p>qiskit-aer-gpu version: 0.11.2</p>
</li>
<li><p>nvcc version: Cuda compilation tools, release 10.1, V10.1.243</p>
</li>
</ul>
<p>I am running following code as an example just to verify cuda installation on my VM but it generates error</p>
<pre><code>from qiskit import *
from qiskit.circuit.library import *
from qiskit.providers.aer import *
sim = AerSimulator(method= 'statevector', device='GPU')
shots = 100
depth=10
qubits = 25
circuit = transpile(QuantumVolume(qubits, depth, seed=0), backend=sim, optimization_level=0)
circuit.measure_all()
result = execute(circuit,sim,shots=shots,seed_simulator=12345).result()
</code></pre>
<p>Error is</p>
<pre><code>Simulation failed and returned the following error message:
ERROR: Failed to load qobj: No CUDA device available!
</code></pre>
<p>Ubuntu VM sees host GPU like <code>sudo lshw -C display</code></p>
<pre><code>-display                 
   description: VGA compatible controller
   product: SVGA II Adapter
   vendor: VMware
   physical id: f
   bus info: pci@0000:00:0f.0
   version: 00
   width: 32 bits
   clock: 33MHz
   capabilities: vga_controller bus_master cap_list rom
   configuration: driver=vmwgfx latency=64
   resources: irq:16 ioport:1070(size=16) 
   memory:e8000000-efffffff memory:fe000000-fe7fffff 
   memory:c0000-dffff
</code></pre>
<p>I have seen some article in which VM doesnot have direct access to host GPU <a href=""https://superuser.com/questions/299333/vmware-how-to-directly-access-the-gpu"">1</a> and <a href=""https://communities.vmware.com/t5/VMware-Workstation-Pro/VM-have-direct-connection-to-the-host-GPU/td-p/1860425"" rel=""nofollow noreferrer"">2</a>. Am I getting this no device error due to this reason?</p>
<p>Any help will be appreciated.</p>
",qc,gpu access ubuntu vm p nvidia geforce gt740 graphics card installed host machine windows 10 os simulate cluster environment order run qiskit codes parallel fashion actual clustering poc created three ubuntu vms one head two compute nodes host machine since easily installed linux used vmware workstation pro p head node created venv installed along cuda ul li p python version li p version li p nvcc version cuda compilation tools release p running following code example verify cuda installation vm generates error pre code qiskit import import import sim aersimulator shots 100 qubits 25 circuit transpile quantumvolume qubits depth result execute circuit sim p error pre code simulation failed returned following error message error failed load qobj cuda device available p ubuntu vm sees host gpu like code sudo lshw display pre code description vga compatible controller product svga ii adapter vendor vmware physical id f bus info pci version 00 width 32 bits clock 33mhz capabilities rom configuration resources memory memory memory p seen article vm doesnot direct access host gpu https 1 https nofollow noreferrer 2 getting device error due reason p help,"[(0, 0.26948217), (4, 0.07416965), (5, 0.034928232), (7, 0.040930532), (8, 0.06508173), (13, 0.0647025), (14, 0.37586856), (15, 0.049607668), (17, 0.015813248)]"
32096,,2023-04-12 07:29:11,6,103,"<p>I am very new to Quantum Information. I had the following question on two no-go theorems:</p>
<p>The No cloning theorem states there is no unitary operator <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U|\psi\rangle|0\rangle=|\psi\rangle|\psi\rangle$</span> for all state <span class=""math-container"">$|\psi\rangle$</span>. The No deletion states there is no unitary operator <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U|\psi\rangle|\psi\rangle=|\psi\rangle|0\rangle$</span> for all state <span class=""math-container"">$|\psi\rangle$</span>. Doesn't the last statement follows from the first after taking <span class=""math-container"">$U^*$</span> on both sides. Also the corresponding wikipedia article mentions it is a time-reversed dual to the no-cloning theorem, so is there some categorical implication?</p>
",Do no-cloning and no-deletion theorems follow one from the other?,<quantum-state><no-cloning-theorem>,2,1,,,"Do no-cloning and no-deletion theorems follow one from the other? <p>I am very new to Quantum Information. I had the following question on two no-go theorems:</p>
<p>The No cloning theorem states there is no unitary operator <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U|\psi\rangle|0\rangle=|\psi\rangle|\psi\rangle$</span> for all state <span class=""math-container"">$|\psi\rangle$</span>. The No deletion states there is no unitary operator <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U|\psi\rangle|\psi\rangle=|\psi\rangle|0\rangle$</span> for all state <span class=""math-container"">$|\psi\rangle$</span>. Doesn't the last statement follows from the first after taking <span class=""math-container"">$U^*$</span> on both sides. Also the corresponding wikipedia article mentions it is a time-reversed dual to the no-cloning theorem, so is there some categorical implication?</p>
",qc,theorems follow one p new quantum information following question two theorems p cloning theorem states unitary operator span u span state span deletion states unitary operator span u span state span last statement follows first taking span sides also corresponding wikipedia article mentions dual theorem categorical implication,"[(3, 0.8967134), (7, 0.075612016), (17, 0.023911668)]"
32116,32118.0,2023-04-13 15:05:32,0,69,"<p>Following Qiskit code throws: AttributeError: 'ListOp' object has no attribute 'to_circuit'. This seems to be related to: z2symmetry_reduction='auto'. If the z2symmetry_reduction argument in QubitConverter is set to 'None', the code runs fine.</p>
<pre><code>from qiskit import transpile
from qiskit.transpiler import PassManager, StagedPassManager
from qiskit.providers.fake_provider import FakeWashington

from qiskit_nature.converters.second_quantization import QubitConverter
# from qiskit_nature.second_q.mappers import QubitConverter (same result)
from qiskit_nature.second_q.circuit.library.ansatzes import UCC, UCCSD
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper
from qiskit_nature.second_q.transformers import FreezeCoreTransformer

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(driver.run())

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

ucc_ansatz = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter, 
                 alpha_spin=True, beta_spin=True, max_spin_excitation=1, generalized=True, preserve_spin=True, reps=5)

decomposed_circuit = ucc_ansatz.decompose().decompose().decompose()
print(&quot;depth: &quot;, decomposed_circuit.depth())

transpiled_circuit = transpile(ucc_ansatz, FakeWashington(), optimization_level=3)
print(&quot;depth transpiled: &quot;, transpiled_circuit.depth())
print(dict(transpiled_circuit.count_ops()))

print(&quot;ansatz parameters: &quot;, len(ucc_ansatz.parameters.data))
</code></pre>
<p>My software version:</p>
<p><a href=""https://i.sstatic.net/lcR4p.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lcR4p.png"" alt=""enter image description here"" /></a></p>
",Qiskit code throws when z2symmetry_reduction argument in QubitConverter is set to 'auto',<qiskit>,1,0,,,"Qiskit code throws when z2symmetry_reduction argument in QubitConverter is set to 'auto' <p>Following Qiskit code throws: AttributeError: 'ListOp' object has no attribute 'to_circuit'. This seems to be related to: z2symmetry_reduction='auto'. If the z2symmetry_reduction argument in QubitConverter is set to 'None', the code runs fine.</p>
<pre><code>from qiskit import transpile
from qiskit.transpiler import PassManager, StagedPassManager
from qiskit.providers.fake_provider import FakeWashington

from qiskit_nature.converters.second_quantization import QubitConverter
# from qiskit_nature.second_q.mappers import QubitConverter (same result)
from qiskit_nature.second_q.circuit.library.ansatzes import UCC, UCCSD
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.mappers import ParityMapper
from qiskit_nature.second_q.transformers import FreezeCoreTransformer

qubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True, z2symmetry_reduction='auto')

molecule = MoleculeInfo([&quot;Li&quot;, &quot;H&quot;], [(0.0, 0.0, 0.0), (0.0, 0.0, 1.595)])
driver = PySCFDriver.from_molecule(molecule, basis=&quot;sto3g&quot;)

transformer = FreezeCoreTransformer()
electronic_structure_problem = transformer.transform(driver.run())

second_quantized_hamiltonian = electronic_structure_problem.second_q_ops()
pauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)

num_particles = electronic_structure_problem.num_particles
num_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals
num_spin_orbitals = electronic_structure_problem.num_spin_orbitals

ucc_ansatz = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter, 
                 alpha_spin=True, beta_spin=True, max_spin_excitation=1, generalized=True, preserve_spin=True, reps=5)

decomposed_circuit = ucc_ansatz.decompose().decompose().decompose()
print(&quot;depth: &quot;, decomposed_circuit.depth())

transpiled_circuit = transpile(ucc_ansatz, FakeWashington(), optimization_level=3)
print(&quot;depth transpiled: &quot;, transpiled_circuit.depth())
print(dict(transpiled_circuit.count_ops()))

print(&quot;ansatz parameters: &quot;, len(ucc_ansatz.parameters.data))
</code></pre>
<p>My software version:</p>
<p><a href=""https://i.sstatic.net/lcR4p.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lcR4p.png"" alt=""enter image description here"" /></a></p>
",qc,qiskit code throws argument qubitconverter set p following qiskit code throws attributeerror object attribute seems related argument qubitconverter set code runs pre code qiskit import transpile import passmanager stagedpassmanager import fakewashington import qubitconverter import qubitconverter result import ucc uccsd import pyscfdriver import moleculeinfo import paritymapper import freezecoretransformer qubitconverter paritymapper molecule moleculeinfo quot li quot quot h quot driver molecule quot sto3g quot transformer freezecoretransformer 0 ucc print quot depth quot transpile fakewashington print quot depth transpiled quot print dict print quot ansatz parameters quot len p software version p https nofollow noreferrer img https enter image description,"[(0, 0.5011487), (4, 0.1174299), (8, 0.1132172), (12, 0.011635635), (14, 0.049508065), (17, 0.05221258), (19, 0.15333857)]"
32129,,2023-04-14 07:14:32,1,79,"<p>Recently I am trying to do some simulations on the surface code to get the empirical curve of logical error(P_L) corresponding with physical error rate(p) and code distance(d) as <a href=""https://arxiv.org/abs/1110.5133v2"" rel=""nofollow noreferrer"">Towards practical classical processing for the surface code</a> do. However, after several rounds of simulation, I found something weird happened in my work. I can't get the result of threshold theorem do! No matter how low the physical error rate is, adding more qubits always introduce more errors.</p>
<p>So I want to know which part of my simulation is wrong.</p>
<p>The following is my simulation route. Let's take d=5 as example.</p>
<p>Step1: First in my program, I will generate a 5*5 lattice of physical qubits. And in each round of stabilizer measurement simulation, I randomly put errors using the standard Depolarizing noise model on each qubits in the lattice, which means every qubits in the lattice will store an information of one of ['I', 'X', 'Y', 'Z'] with the probability [1 - 8p, 8p/3, 8p/3, 8p/3].</p>
<p>Step2: In this step, I perform stabilizer measurement on the measure qubit to get the &quot;-1&quot; syndrome outcome.(Suppose the measure qubit is to measure the &quot;Z&quot; type stabilizer, then one neighbouring physical qubits containing &quot;X&quot; or &quot;Y&quot; will flip the outcome.) Now, I just consider the perfect measurement case to simpilify the simulation. As a consequence, I just need to do one round of stabilizer measurement, and ignore the time boundary.</p>
<p>Step3: Once I get all of the &quot;-1&quot; syndrome in the stabilizer measurement step, I just perform MWPM algorithm using the library of &quot;networkX&quot;. And the distance of two stabilizer is defined as the Manhattan distance.</p>
<p>Step4: With all &quot;-1&quot; pairs as the outcome of MWPM, I generate the operators of the qubits in the shortest path of these pairs. And applying these operators is the error correction step.</p>
<p>Step5: After recovering the error. I combined the simulated error in step1 and the recovery operator in step4 to detect if this round of simulation occurs a logical error. If it does, count it. Return to step1.</p>
<p>The simulation result of my work is:</p>
<p><a href=""https://i.sstatic.net/taWTu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/taWTu.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>I possiblly find out where the problem is. Seems like there are some weird results in the usage of the <code>nx.min_weigh_matching</code> <a href=""https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.matching.min_weight_matching.html#networkx.algorithms.matching.min_weight_matching"" rel=""nofollow noreferrer"">min_weight_matching implemented by the networkX lib</a>.</p>
<p>Here is the proof. The code is running in the python.</p>
<pre><code>import networkx as nx

G = nx.Graph()
edges = [(0, 1, {'weight': 3}), (1, 2, {'weight': 1}), (0, 3, {'weight': 1}), (2, 3, {'weight': 0})]
G.add_edges_from(edges)
print(nx.min_weight_matching(G))
</code></pre>
<p>I generate a complete graph of 4 nodes with the above weight. However, the result is:</p>
<pre><code>{(0, 1), (2, 3)}
</code></pre>
<p>And the total weight(3) of this matching is larger than the total weight(2) of matching {(0, 3), (1, 2)}.</p>
",Some problems when trying to reproduce the threshold result of simulation of surface code,<surface-code><minimum-weight-perfect-matching>,0,4,,,"Some problems when trying to reproduce the threshold result of simulation of surface code <p>Recently I am trying to do some simulations on the surface code to get the empirical curve of logical error(P_L) corresponding with physical error rate(p) and code distance(d) as <a href=""https://arxiv.org/abs/1110.5133v2"" rel=""nofollow noreferrer"">Towards practical classical processing for the surface code</a> do. However, after several rounds of simulation, I found something weird happened in my work. I can't get the result of threshold theorem do! No matter how low the physical error rate is, adding more qubits always introduce more errors.</p>
<p>So I want to know which part of my simulation is wrong.</p>
<p>The following is my simulation route. Let's take d=5 as example.</p>
<p>Step1: First in my program, I will generate a 5*5 lattice of physical qubits. And in each round of stabilizer measurement simulation, I randomly put errors using the standard Depolarizing noise model on each qubits in the lattice, which means every qubits in the lattice will store an information of one of ['I', 'X', 'Y', 'Z'] with the probability [1 - 8p, 8p/3, 8p/3, 8p/3].</p>
<p>Step2: In this step, I perform stabilizer measurement on the measure qubit to get the &quot;-1&quot; syndrome outcome.(Suppose the measure qubit is to measure the &quot;Z&quot; type stabilizer, then one neighbouring physical qubits containing &quot;X&quot; or &quot;Y&quot; will flip the outcome.) Now, I just consider the perfect measurement case to simpilify the simulation. As a consequence, I just need to do one round of stabilizer measurement, and ignore the time boundary.</p>
<p>Step3: Once I get all of the &quot;-1&quot; syndrome in the stabilizer measurement step, I just perform MWPM algorithm using the library of &quot;networkX&quot;. And the distance of two stabilizer is defined as the Manhattan distance.</p>
<p>Step4: With all &quot;-1&quot; pairs as the outcome of MWPM, I generate the operators of the qubits in the shortest path of these pairs. And applying these operators is the error correction step.</p>
<p>Step5: After recovering the error. I combined the simulated error in step1 and the recovery operator in step4 to detect if this round of simulation occurs a logical error. If it does, count it. Return to step1.</p>
<p>The simulation result of my work is:</p>
<p><a href=""https://i.sstatic.net/taWTu.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/taWTu.png"" alt=""enter image description here"" /></a></p>
<hr />
<p>I possiblly find out where the problem is. Seems like there are some weird results in the usage of the <code>nx.min_weigh_matching</code> <a href=""https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.matching.min_weight_matching.html#networkx.algorithms.matching.min_weight_matching"" rel=""nofollow noreferrer"">min_weight_matching implemented by the networkX lib</a>.</p>
<p>Here is the proof. The code is running in the python.</p>
<pre><code>import networkx as nx

G = nx.Graph()
edges = [(0, 1, {'weight': 3}), (1, 2, {'weight': 1}), (0, 3, {'weight': 1}), (2, 3, {'weight': 0})]
G.add_edges_from(edges)
print(nx.min_weight_matching(G))
</code></pre>
<p>I generate a complete graph of 4 nodes with the above weight. However, the result is:</p>
<pre><code>{(0, 1), (2, 3)}
</code></pre>
<p>And the total weight(3) of this matching is larger than the total weight(2) of matching {(0, 3), (1, 2)}.</p>
",qc,problems trying reproduce threshold result simulation surface code p recently trying simulations surface code get empirical curve logical error corresponding physical error rate p code distance https nofollow noreferrer towards practical classical processing surface code however several rounds simulation found something weird happened work ca get result threshold theorem matter low physical error rate adding qubits always introduce p want know part simulation p following simulation route let take p step1 first program generate 5 5 lattice physical qubits round stabilizer measurement simulation randomly put errors using standard depolarizing noise model qubits lattice means every qubits lattice store information one x z probability 1 8p p step2 step perform stabilizer measurement measure qubit get quot quot syndrome outcome suppose measure qubit measure quot z quot type stabilizer one neighbouring physical qubits containing quot x quot quot quot flip outcome consider perfect measurement case simpilify simulation consequence need one round stabilizer measurement ignore time p step3 get quot quot syndrome stabilizer measurement step perform mwpm algorithm using library quot networkx quot distance two stabilizer defined manhattan p step4 quot quot pairs outcome mwpm generate operators qubits shortest path pairs applying operators error correction p step5 recovering error combined simulated error step1 recovery operator step4 detect round simulation occurs logical error count return p simulation result work p https nofollow noreferrer img https enter image description hr p possiblly find problem seems like weird results usage code https nofollow noreferrer implemented networkx lib p proof code running pre code import networkx nx g edges 0 1 3 1 2 1 0 3 1 2 3 0 edges print g p generate complete graph 4 nodes weight however result pre code 0 1 2 3 p total weight 3 matching larger total weight 2 matching 0 3 1 2,"[(0, 0.078964725), (1, 0.025137883), (2, 0.08172856), (4, 0.081903115), (5, 0.29353544), (9, 0.036451224), (13, 0.053529684), (14, 0.15260537), (16, 0.01296794), (17, 0.013126897), (18, 0.100965366), (19, 0.06880115)]"
32161,,2023-04-16 18:20:38,0,429,"<p>I am using a quantum circuit simulator &quot;Stim&quot; to simulate the logical error probability of color code under circuit-level noise.</p>
<p>In the code capacity noise and the phenomenological noise, the Pauli errors to the data qubits that occur with probability p are kept as a list (this is called actual error), and the information of the actual error is used to perform syndrome measurement, and the error is estimated by decoding from the obtained syndrome (this is called the estimated error). Then, the actual error and the estimated error are XORed, and if the resulting error is a logical operator, it is judged to be a logical error.</p>
<p>Now I want to calculate the logical error probability by the similar procedure with circuit-level noise. In this case, I understand the procedure for obtaining the estimated error, since it is almost the same as the phenomenological noise model, except that the syndrome measurement is performed by a syndrome measurement circuit. However, I do not know how to know the actual error. Simply, I am thinking that it might be possible to determine the actual error by considering what Pauli error generated in the circuit result in at the end of the circuit. Is this correct? Also, is there a function in Stim to realize this and find out the actual error?</p>
",How can I extract actual Pauli error in Stim?,<measurement><error-correction><noise><stabilizer-code><stim>,1,0,,,"How can I extract actual Pauli error in Stim? <p>I am using a quantum circuit simulator &quot;Stim&quot; to simulate the logical error probability of color code under circuit-level noise.</p>
<p>In the code capacity noise and the phenomenological noise, the Pauli errors to the data qubits that occur with probability p are kept as a list (this is called actual error), and the information of the actual error is used to perform syndrome measurement, and the error is estimated by decoding from the obtained syndrome (this is called the estimated error). Then, the actual error and the estimated error are XORed, and if the resulting error is a logical operator, it is judged to be a logical error.</p>
<p>Now I want to calculate the logical error probability by the similar procedure with circuit-level noise. In this case, I understand the procedure for obtaining the estimated error, since it is almost the same as the phenomenological noise model, except that the syndrome measurement is performed by a syndrome measurement circuit. However, I do not know how to know the actual error. Simply, I am thinking that it might be possible to determine the actual error by considering what Pauli error generated in the circuit result in at the end of the circuit. Is this correct? Also, is there a function in Stim to realize this and find out the actual error?</p>
",qc,extract actual pauli error stim p using quantum circuit simulator quot stim quot simulate logical error probability color code p code capacity noise phenomenological noise pauli errors data qubits occur probability p kept list called actual error information actual error used perform syndrome measurement error estimated decoding obtained syndrome called estimated error actual error estimated error xored resulting error logical operator judged logical p want calculate logical error probability similar procedure noise case understand procedure obtaining estimated error since almost phenomenological noise model except syndrome measurement performed syndrome measurement circuit however know know actual error simply thinking might possible determine actual error considering pauli error generated circuit result end circuit correct also function stim realize find actual error,"[(5, 0.68048376), (14, 0.25041273), (17, 0.025606385), (19, 0.042119656)]"
32164,,2023-04-17 04:04:43,0,170,"<p>I am trying to simulate the logical error probability of color code under circuit-level noise.</p>
<p>In the code capacity noise and the phenomenological noise, the Pauli errors to the data qubits that occur with probability p are kept as a list (this is called actual error), and the information of the actual error is used to perform syndrome measurement, and the error is estimated by decoding from the obtained syndrome (this is called the estimated error). Then, the actual error and the estimated error are XORed, and if the resulting error is a logical operator, it is judged to be a logical error.</p>
<p>Now I want to calculate the logical error probability by the similar procedure with circuit-level noise. In this case, I understand the procedure for obtaining the estimated error, since it is almost the same as the phenomenological noise model, except that the syndrome measurement is performed by a syndrome measurement circuit. However, I do not know how to determine if the error correction by this estimated error results in a logical error. Is there a way to know actual errors in the same way as code capacity noise and the phenomenological noise? Also, I would like to know if there is a way to achieve this, especially in Stim.</p>
",How can I determine if the error correction by estimated error results in a logical error in circuit-level noise?,<measurement><error-correction><noise><stabilizer-code><stim>,1,0,,,"How can I determine if the error correction by estimated error results in a logical error in circuit-level noise? <p>I am trying to simulate the logical error probability of color code under circuit-level noise.</p>
<p>In the code capacity noise and the phenomenological noise, the Pauli errors to the data qubits that occur with probability p are kept as a list (this is called actual error), and the information of the actual error is used to perform syndrome measurement, and the error is estimated by decoding from the obtained syndrome (this is called the estimated error). Then, the actual error and the estimated error are XORed, and if the resulting error is a logical operator, it is judged to be a logical error.</p>
<p>Now I want to calculate the logical error probability by the similar procedure with circuit-level noise. In this case, I understand the procedure for obtaining the estimated error, since it is almost the same as the phenomenological noise model, except that the syndrome measurement is performed by a syndrome measurement circuit. However, I do not know how to determine if the error correction by this estimated error results in a logical error. Is there a way to know actual errors in the same way as code capacity noise and the phenomenological noise? Also, I would like to know if there is a way to achieve this, especially in Stim.</p>
",qc,determine error correction estimated error results logical error noise p trying simulate logical error probability color code p code capacity noise phenomenological noise pauli errors data qubits occur probability p kept list called actual error information actual error used perform syndrome measurement error estimated decoding obtained syndrome called estimated error actual error estimated error xored resulting error logical operator judged logical p want calculate logical error probability similar procedure noise case understand procedure obtaining estimated error since almost phenomenological noise model except syndrome measurement performed syndrome measurement circuit however know determine error correction estimated error results logical error way know actual errors way code capacity noise phenomenological noise also would like know way achieve especially,"[(5, 0.71633726), (8, 0.0694989), (14, 0.1671101), (17, 0.045639742)]"
32246,32257.0,2023-04-20 10:52:14,5,212,"<p>I am trying to implement a decoder for a quantum non-CSS code, where the syndrome defects are always created in pairs.</p>
<p>First question is more theoretical:
Why and how does MWPM work for non-CSS codes? In CSS codes the X and Z stabilizers are decoded separately, but this wouldn't work for non-CSS codes, since we do not know in advance if X or Z flips are needed to correct for each stabilizer. And so the two graphs would be highly connected. Or is a single graph built from both X and Z stabilizers together?</p>
<p>The second question relates to implementation:
Does PyMatching work for non-CSS codes?
If not, are there other packages I can use to implement MWPM efficiently on a non-CSS code?
Thanks!</p>
",Decoding of quantum non CSS code using Minimum Weight Perfect Matching (MWPM),<error-correction><programming>,2,0,,,"Decoding of quantum non CSS code using Minimum Weight Perfect Matching (MWPM) <p>I am trying to implement a decoder for a quantum non-CSS code, where the syndrome defects are always created in pairs.</p>
<p>First question is more theoretical:
Why and how does MWPM work for non-CSS codes? In CSS codes the X and Z stabilizers are decoded separately, but this wouldn't work for non-CSS codes, since we do not know in advance if X or Z flips are needed to correct for each stabilizer. And so the two graphs would be highly connected. Or is a single graph built from both X and Z stabilizers together?</p>
<p>The second question relates to implementation:
Does PyMatching work for non-CSS codes?
If not, are there other packages I can use to implement MWPM efficiently on a non-CSS code?
Thanks!</p>
",qc,decoding quantum non css code using minimum weight perfect matching mwpm p trying implement decoder quantum code syndrome defects always created p first question theoretical mwpm work codes css codes x z stabilizers decoded separately would work codes since know advance x z flips needed correct stabilizer two graphs would highly connected single graph built x z stabilizers together p second question relates implementation pymatching work codes packages use implement mwpm efficiently code thanks,"[(1, 0.053446084), (5, 0.46062553), (8, 0.10650797), (10, 0.044749606), (13, 0.22161898), (17, 0.027008379), (19, 0.08429061)]"
32259,,2023-04-21 07:33:09,1,277,"<p>Explain the swap test for 2 qubits to find the distance between qubits. Extend the swap test for 3 and 4 qubits. Will the design differ from each other and share the design for both the swap tests?</p>
",Is it possible to design a swap test for three qubits? If it is possible how is it different from 2 and 4 qubits? share the design of the swap test?,<qiskit><circuit-construction><quantum-circuit><swap-test>,0,3,,,"Is it possible to design a swap test for three qubits? If it is possible how is it different from 2 and 4 qubits? share the design of the swap test? <p>Explain the swap test for 2 qubits to find the distance between qubits. Extend the swap test for 3 and 4 qubits. Will the design differ from each other and share the design for both the swap tests?</p>
",qc,possible design swap test three qubits possible different 2 4 qubits share design swap test p explain swap test 2 qubits find distance qubits extend swap test 3 4 qubits design differ share design swap tests,"[(2, 0.15310729), (8, 0.20619366), (13, 0.4210805), (17, 0.028979352), (18, 0.18649465)]"
32267,,2023-04-21 21:48:09,2,40,"<p>What percentage of superconducting QPU chips are discarded after fabrication because of high error rate? Are some physical qubits significantly bad in state of the art superconducting QPUs? Are these two problems going to be a significant challenge to scaling up QPUs? How are people addressing these two problems?</p>
",Low yield rate of superconducting QPU fabrication?,<superconducting-quantum-computing>,0,1,,,"Low yield rate of superconducting QPU fabrication? <p>What percentage of superconducting QPU chips are discarded after fabrication because of high error rate? Are some physical qubits significantly bad in state of the art superconducting QPUs? Are these two problems going to be a significant challenge to scaling up QPUs? How are people addressing these two problems?</p>
",qc,low yield rate superconducting qpu fabrication p percentage superconducting qpu chips discarded fabrication high error rate physical qubits significantly bad state art superconducting qpus two problems going significant challenge scaling qpus people addressing two problems,"[(5, 0.26094556), (8, 0.55583346), (9, 0.08518903), (15, 0.06637734), (17, 0.027262017)]"
445188,445202.0,2023-04-23 17:35:46,0,459,"<p>Suppose today I'm designing a new application that will employ asymmetric cryptography to allow users to securely exchange data with one another. As far as I can tell there are no quantum-safe algorithms yet generally accepted, let alone that are ready to be used in production. (Please correct me if I'm wrong!) Thus I'm assuming I'm still looking at RSA as the gold standard. Estimates for when RSA can be cracked vary from 5 to 15 years or more. 15 years doesn't bother me too much, but 5 years does, especially for a new application.</p>
<p>So, if I'm starting from scratch, what would be considered the best practices to be as prepared as possible for a post-quantum world? And to explain what I mean by prepared, I don't simply mean ready to change algorithms, but rather to best ensure that data transmitted today won't be vulnerable in the future.</p>
<p>Two things I've considered -</p>
<ul>
<li>Using 4096-bit keys. However I don't see a consensus on whether this actually makes much of a difference even for classical attacks, let alone quantum ones.</li>
<li>Keeping public keys effectively private. My idea here is to keep even public keys within the confines of the secure application servers and unavailable to users. We would not allow clients to encrypt or verify sender signatures directly, but rather servers would hold public keys as closely as they hold their other secrets. Encrypting and verifying signatures would thus require client API calls.</li>
</ul>
<p>I'm wondering if these ideas add any genuine security value, or if not why not, and if there are other measures that experts would recommend at this time to architect a new application to be as resilient as possible to the so-called quantum apocalypse.</p>
",Best practices for a new application to be ready for post-quantum cryptography,<security><encryption>,2,2,,,"Best practices for a new application to be ready for post-quantum cryptography <p>Suppose today I'm designing a new application that will employ asymmetric cryptography to allow users to securely exchange data with one another. As far as I can tell there are no quantum-safe algorithms yet generally accepted, let alone that are ready to be used in production. (Please correct me if I'm wrong!) Thus I'm assuming I'm still looking at RSA as the gold standard. Estimates for when RSA can be cracked vary from 5 to 15 years or more. 15 years doesn't bother me too much, but 5 years does, especially for a new application.</p>
<p>So, if I'm starting from scratch, what would be considered the best practices to be as prepared as possible for a post-quantum world? And to explain what I mean by prepared, I don't simply mean ready to change algorithms, but rather to best ensure that data transmitted today won't be vulnerable in the future.</p>
<p>Two things I've considered -</p>
<ul>
<li>Using 4096-bit keys. However I don't see a consensus on whether this actually makes much of a difference even for classical attacks, let alone quantum ones.</li>
<li>Keeping public keys effectively private. My idea here is to keep even public keys within the confines of the secure application servers and unavailable to users. We would not allow clients to encrypt or verify sender signatures directly, but rather servers would hold public keys as closely as they hold their other secrets. Encrypting and verifying signatures would thus require client API calls.</li>
</ul>
<p>I'm wondering if these ideas add any genuine security value, or if not why not, and if there are other measures that experts would recommend at this time to architect a new application to be as resilient as possible to the so-called quantum apocalypse.</p>
",se,best practices new application ready cryptography p suppose today designing new application employ asymmetric cryptography allow users securely exchange data one another far tell algorithms yet generally accepted let alone ready used production please correct wrong thus assuming still looking rsa gold standard estimates rsa cracked vary 5 15 years 15 years bother much 5 years especially new p starting scratch would considered best practices prepared possible world explain mean prepared simply mean ready change algorithms rather best ensure data transmitted today wo vulnerable p two things considered ul li using keys however see consensus whether actually makes much difference even classical attacks let alone quantum li keeping public keys effectively private idea keep even public keys within confines secure application servers unavailable users would allow clients encrypt verify sender signatures directly rather servers would hold public keys closely hold secrets encrypting verifying signatures would thus require client api p wondering ideas add genuine security value measures experts would recommend time architect new application resilient possible quantum,"[(3, 0.02188669), (6, 0.026365018), (7, 0.20552272), (8, 0.5724005), (14, 0.08600333), (17, 0.078644305)]"
445188,445202.0,2023-04-23 17:35:46,0,459,"<p>Suppose today I'm designing a new application that will employ asymmetric cryptography to allow users to securely exchange data with one another. As far as I can tell there are no quantum-safe algorithms yet generally accepted, let alone that are ready to be used in production. (Please correct me if I'm wrong!) Thus I'm assuming I'm still looking at RSA as the gold standard. Estimates for when RSA can be cracked vary from 5 to 15 years or more. 15 years doesn't bother me too much, but 5 years does, especially for a new application.</p>
<p>So, if I'm starting from scratch, what would be considered the best practices to be as prepared as possible for a post-quantum world? And to explain what I mean by prepared, I don't simply mean ready to change algorithms, but rather to best ensure that data transmitted today won't be vulnerable in the future.</p>
<p>Two things I've considered -</p>
<ul>
<li>Using 4096-bit keys. However I don't see a consensus on whether this actually makes much of a difference even for classical attacks, let alone quantum ones.</li>
<li>Keeping public keys effectively private. My idea here is to keep even public keys within the confines of the secure application servers and unavailable to users. We would not allow clients to encrypt or verify sender signatures directly, but rather servers would hold public keys as closely as they hold their other secrets. Encrypting and verifying signatures would thus require client API calls.</li>
</ul>
<p>I'm wondering if these ideas add any genuine security value, or if not why not, and if there are other measures that experts would recommend at this time to architect a new application to be as resilient as possible to the so-called quantum apocalypse.</p>
",Best practices for a new application to be ready for post-quantum cryptography,<security><encryption>,2,2,,,"Best practices for a new application to be ready for post-quantum cryptography <p>Suppose today I'm designing a new application that will employ asymmetric cryptography to allow users to securely exchange data with one another. As far as I can tell there are no quantum-safe algorithms yet generally accepted, let alone that are ready to be used in production. (Please correct me if I'm wrong!) Thus I'm assuming I'm still looking at RSA as the gold standard. Estimates for when RSA can be cracked vary from 5 to 15 years or more. 15 years doesn't bother me too much, but 5 years does, especially for a new application.</p>
<p>So, if I'm starting from scratch, what would be considered the best practices to be as prepared as possible for a post-quantum world? And to explain what I mean by prepared, I don't simply mean ready to change algorithms, but rather to best ensure that data transmitted today won't be vulnerable in the future.</p>
<p>Two things I've considered -</p>
<ul>
<li>Using 4096-bit keys. However I don't see a consensus on whether this actually makes much of a difference even for classical attacks, let alone quantum ones.</li>
<li>Keeping public keys effectively private. My idea here is to keep even public keys within the confines of the secure application servers and unavailable to users. We would not allow clients to encrypt or verify sender signatures directly, but rather servers would hold public keys as closely as they hold their other secrets. Encrypting and verifying signatures would thus require client API calls.</li>
</ul>
<p>I'm wondering if these ideas add any genuine security value, or if not why not, and if there are other measures that experts would recommend at this time to architect a new application to be as resilient as possible to the so-called quantum apocalypse.</p>
",cr,best practices new application ready cryptography p suppose today designing new application employ asymmetric cryptography allow users securely exchange data one another far tell algorithms yet generally accepted let alone ready used production please correct wrong thus assuming still looking rsa gold standard estimates rsa cracked vary 5 15 years 15 years bother much 5 years especially new p starting scratch would considered best practices prepared possible world explain mean prepared simply mean ready change algorithms rather best ensure data transmitted today wo vulnerable p two things considered ul li using keys however see consensus whether actually makes much difference even classical attacks let alone quantum li keeping public keys effectively private idea keep even public keys within confines secure application servers unavailable users would allow clients encrypt verify sender signatures directly rather servers would hold public keys closely hold secrets encrypting verifying signatures would thus require client api p wondering ideas add genuine security value measures experts would recommend time architect new application resilient possible quantum,"[(3, 0.021893268), (6, 0.026365044), (7, 0.20551854), (8, 0.57240415), (14, 0.08600009), (17, 0.078643896)]"
32281,,2023-04-23 18:38:05,0,149,"<p>I have a TableauSimulator initialised (which is a some 3D code) called TS. I am copying TS and then applying a set of Pauli Z-errors before using measure_many(*set_of_measured_qubits) to get syndromes results. I am looping this many times to compute some sort of psuedo-threshold. This is currently quite slow and more than 90% of the runtime resides in the measure_many function alone. I wanted to ask if anyone knows how I can sample the Tableau simulator better if all I am doing is independent X or Z errors on the qubits?</p>
<p>Thank you very much in advanced!</p>
",Better way of using stim.TableauSimulator.measure_many to sample the code,<stim>,1,0,,,"Better way of using stim.TableauSimulator.measure_many to sample the code <p>I have a TableauSimulator initialised (which is a some 3D code) called TS. I am copying TS and then applying a set of Pauli Z-errors before using measure_many(*set_of_measured_qubits) to get syndromes results. I am looping this many times to compute some sort of psuedo-threshold. This is currently quite slow and more than 90% of the runtime resides in the measure_many function alone. I wanted to ask if anyone knows how I can sample the Tableau simulator better if all I am doing is independent X or Z errors on the qubits?</p>
<p>Thank you very much in advanced!</p>
",qc,better way using sample code p tableausimulator initialised 3d code called ts copying ts applying set pauli using get syndromes results looping many times compute sort currently quite slow 90 runtime resides function alone wanted ask anyone knows sample tableau simulator better independent x z errors qubits p thank much advanced,"[(0, 0.11446185), (5, 0.06585873), (8, 0.15853047), (10, 0.022115318), (14, 0.56093293), (17, 0.03890824), (18, 0.036595404)]"
32298,,2023-04-24 18:08:23,0,205,"<p>I am trying to find threshold estimates for the rotated surface code for depolarizing phenomenological/circuit-level noise with and without measurement errors (I am aware that those might be implementation dependent).</p>
<p>For error rate <span class=""math-container"">$p$</span> and measurement error rate <span class=""math-container"">$q$</span>, I was able to find the following data:</p>
<p><strong>Toric code</strong> [<a href=""https://arxiv.org/abs/1302.3428"" rel=""nofollow noreferrer"">1</a>]:</p>
<ul>
<li>For <span class=""math-container"">$q=0$</span> (phenomenological): 18.9%</li>
<li>For <span class=""math-container"">$p=q$</span> (phenomenological): 2.9%</li>
<li>For <span class=""math-container"">$p=q$</span> (circuit-level): 1.1 - 1.4%</li>
</ul>
<p><strong>(Rotated) surface code</strong>:</p>
<ul>
<li>For <span class=""math-container"">$p=q$</span> (phenomenological, X-Z errors): 3.2% [<a href=""https://arxiv.org/pdf/1612.04795.pdf"" rel=""nofollow noreferrer"">2</a>]</li>
<li>For <span class=""math-container"">$p=q$</span> (circuit-level): 0.4 - 1.1% [<a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">3</a>, <a href=""https://arxiv.org/abs/1404.3747"" rel=""nofollow noreferrer"">4</a>]</li>
</ul>
<p><strong>Question:</strong> Are there papers that explicitly evaluate the rotated surface code and provide numbers? I expected that the values would be easier to find, given the recent experiments by the Google Quantum team [<a href=""https://arxiv.org/abs/2207.06431"" rel=""nofollow noreferrer"">5</a>]. Would it be correct to assume that the values are not too far off from the actual thresholds?</p>
<p><a href=""https://arxiv.org/abs/1302.3428"" rel=""nofollow noreferrer"">1</a> Terhal (2015), <a href=""https://arxiv.org/abs/1302.3428"" rel=""nofollow noreferrer"">Quantum Error Correction for Quantum Memories</a><br />
<a href=""https://arxiv.org/pdf/1612.04795.pdf"" rel=""nofollow noreferrer"">2</a> Yoder and Kim (2017), <a href=""https://arxiv.org/pdf/1612.04795.pdf"" rel=""nofollow noreferrer"">The surface code with a twist</a><br />
<a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">3</a> Fowler et al. (2012), <a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">Surface codes: Towards practical large-scale quantum computation</a><br />
<a href=""https://arxiv.org/abs/1404.3747"" rel=""nofollow noreferrer"">4</a> Tomita and Svore (2014), <a href=""https://arxiv.org/abs/1404.3747"" rel=""nofollow noreferrer"">Low-distance Surface Codes under Realistic Quantum Noise</a><br />
<a href=""https://arxiv.org/abs/2207.06431"" rel=""nofollow noreferrer"">5</a> Google (2022), <a href=""https://arxiv.org/abs/2207.06431"" rel=""nofollow noreferrer"">Suppressing quantum errors by scaling a surface code logical qubit</a></p>
",Phenomenological threshold estimates for rotated surface code,<error-correction><surface-code>,0,3,,,"Phenomenological threshold estimates for rotated surface code <p>I am trying to find threshold estimates for the rotated surface code for depolarizing phenomenological/circuit-level noise with and without measurement errors (I am aware that those might be implementation dependent).</p>
<p>For error rate <span class=""math-container"">$p$</span> and measurement error rate <span class=""math-container"">$q$</span>, I was able to find the following data:</p>
<p><strong>Toric code</strong> [<a href=""https://arxiv.org/abs/1302.3428"" rel=""nofollow noreferrer"">1</a>]:</p>
<ul>
<li>For <span class=""math-container"">$q=0$</span> (phenomenological): 18.9%</li>
<li>For <span class=""math-container"">$p=q$</span> (phenomenological): 2.9%</li>
<li>For <span class=""math-container"">$p=q$</span> (circuit-level): 1.1 - 1.4%</li>
</ul>
<p><strong>(Rotated) surface code</strong>:</p>
<ul>
<li>For <span class=""math-container"">$p=q$</span> (phenomenological, X-Z errors): 3.2% [<a href=""https://arxiv.org/pdf/1612.04795.pdf"" rel=""nofollow noreferrer"">2</a>]</li>
<li>For <span class=""math-container"">$p=q$</span> (circuit-level): 0.4 - 1.1% [<a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">3</a>, <a href=""https://arxiv.org/abs/1404.3747"" rel=""nofollow noreferrer"">4</a>]</li>
</ul>
<p><strong>Question:</strong> Are there papers that explicitly evaluate the rotated surface code and provide numbers? I expected that the values would be easier to find, given the recent experiments by the Google Quantum team [<a href=""https://arxiv.org/abs/2207.06431"" rel=""nofollow noreferrer"">5</a>]. Would it be correct to assume that the values are not too far off from the actual thresholds?</p>
<p><a href=""https://arxiv.org/abs/1302.3428"" rel=""nofollow noreferrer"">1</a> Terhal (2015), <a href=""https://arxiv.org/abs/1302.3428"" rel=""nofollow noreferrer"">Quantum Error Correction for Quantum Memories</a><br />
<a href=""https://arxiv.org/pdf/1612.04795.pdf"" rel=""nofollow noreferrer"">2</a> Yoder and Kim (2017), <a href=""https://arxiv.org/pdf/1612.04795.pdf"" rel=""nofollow noreferrer"">The surface code with a twist</a><br />
<a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">3</a> Fowler et al. (2012), <a href=""https://arxiv.org/abs/1208.0928"" rel=""nofollow noreferrer"">Surface codes: Towards practical large-scale quantum computation</a><br />
<a href=""https://arxiv.org/abs/1404.3747"" rel=""nofollow noreferrer"">4</a> Tomita and Svore (2014), <a href=""https://arxiv.org/abs/1404.3747"" rel=""nofollow noreferrer"">Low-distance Surface Codes under Realistic Quantum Noise</a><br />
<a href=""https://arxiv.org/abs/2207.06431"" rel=""nofollow noreferrer"">5</a> Google (2022), <a href=""https://arxiv.org/abs/2207.06431"" rel=""nofollow noreferrer"">Suppressing quantum errors by scaling a surface code logical qubit</a></p>
",qc,phenomenological threshold estimates rotated surface code p trying find threshold estimates rotated surface code depolarizing noise without measurement errors aware might implementation dependent p error rate span p measurement error rate span q able find following data p strong toric code https nofollow noreferrer 1 ul li span phenomenological li span phenomenological li span p strong rotated surface code ul li span phenomenological errors https nofollow noreferrer 2 li span https nofollow noreferrer 3 https nofollow noreferrer 4 p strong question papers explicitly evaluate rotated surface code provide numbers expected values would easier find given recent experiments google quantum team https nofollow noreferrer 5 would correct assume values far actual thresholds p https nofollow noreferrer 1 terhal 2015 https nofollow noreferrer quantum error correction quantum memories br https nofollow noreferrer 2 yoder kim 2017 https nofollow noreferrer surface code twist br https nofollow noreferrer 3 fowler et al 2012 https nofollow noreferrer surface codes towards practical quantum computation br https nofollow noreferrer 4 tomita svore 2014 https nofollow noreferrer surface codes realistic quantum noise br https nofollow noreferrer 5 google 2022 https nofollow noreferrer suppressing quantum errors scaling surface code logical qubit,"[(3, 0.03626142), (4, 0.28272226), (5, 0.24940732), (6, 0.042767823), (7, 0.05536317), (8, 0.10101477), (9, 0.14268036), (13, 0.055110425), (17, 0.034090523)]"
32304,,2023-04-25 07:44:24,2,152,"<p>I was quite confused about the definition of physical error rate in the paper <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""nofollow noreferrer"">Topological quantum memory</a>, which is famous because it estimate the accurate threshold by using Ising model.</p>
<p>In this paper, the author said that Let us imagine that, in a single time step, we will execute
a measurement of each stabilizer operator at each site and each plaquette of the lattice. During each time step, new qubit errors might occur. To be concrete and to simplify the discussion, we assume that all qubit errors are stochastic, and so can be assigned probabilities. (For example, errors that arise from decoherence have this property.) We will also assume that the errors acting
on different qubits are independent, that bit-flip (X) errors and phase (Z) errors are uncorrelated with one another, and that X and Z errors are equally likely. Thus the error in each time step acting on a qubit with state ρ can be represented by the quantum channel. [located in Sec4.A]</p>
<p>And the result of this paper is 11% if perfect measurement and 1.1% if imperfect measurement.</p>
<p>So, my question is:</p>
<p>What does this error rate mean? The probability of occuring error in the whole stabilizer measurement or the probability of occuring error in just one gate time which might be in the order of 1/8 less than the previous one if using the standard X(Z) stabilizer measurement circuit.</p>
",The definition of physical error rate in the threshold theorem,<surface-code>,1,0,,,"The definition of physical error rate in the threshold theorem <p>I was quite confused about the definition of physical error rate in the paper <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""nofollow noreferrer"">Topological quantum memory</a>, which is famous because it estimate the accurate threshold by using Ising model.</p>
<p>In this paper, the author said that Let us imagine that, in a single time step, we will execute
a measurement of each stabilizer operator at each site and each plaquette of the lattice. During each time step, new qubit errors might occur. To be concrete and to simplify the discussion, we assume that all qubit errors are stochastic, and so can be assigned probabilities. (For example, errors that arise from decoherence have this property.) We will also assume that the errors acting
on different qubits are independent, that bit-flip (X) errors and phase (Z) errors are uncorrelated with one another, and that X and Z errors are equally likely. Thus the error in each time step acting on a qubit with state ρ can be represented by the quantum channel. [located in Sec4.A]</p>
<p>And the result of this paper is 11% if perfect measurement and 1.1% if imperfect measurement.</p>
<p>So, my question is:</p>
<p>What does this error rate mean? The probability of occuring error in the whole stabilizer measurement or the probability of occuring error in just one gate time which might be in the order of 1/8 less than the previous one if using the standard X(Z) stabilizer measurement circuit.</p>
",qc,definition physical error rate threshold theorem p quite confused definition physical error rate paper https nofollow noreferrer topological quantum memory famous estimate accurate threshold using ising p paper author said let us imagine single time step execute measurement stabilizer operator site plaquette lattice time step new qubit errors might occur concrete simplify discussion assume qubit errors stochastic assigned probabilities example errors arise decoherence property also assume errors acting different qubits independent x errors phase z errors uncorrelated one another x z errors equally likely thus error time step acting qubit state ρ represented quantum channel located p result paper 11 perfect measurement imperfect p question p error rate mean probability occuring error whole stabilizer measurement probability occuring error one gate time might order less previous one using standard x z stabilizer measurement,"[(1, 0.032089613), (5, 0.42110643), (8, 0.06392825), (9, 0.2629501), (10, 0.025158295), (13, 0.043846384), (14, 0.02789898), (16, 0.010915757), (17, 0.012357036), (18, 0.09130391)]"
32310,,2023-04-25 12:44:51,0,268,"<p>I would like to simulate the logical error rate of the surface code under depolarizing noise using Stim. The decoder I am using decodes from both X-type and Z-type stabilizer syndrome values. Specifically, if an X error occurs on one data qubit, the syndrome value of the Z-type stabilizer flips. If a Z error occurs, the syndrome value of the X-type stabilizer flips. If a Y error occurs, both the X-type and Z-type stabilizer syndrome values flip.</p>
<p>I am considering the situation where both X-type and Z-type stabilizer syndrome measurements are performed. However, in the <code>surface_code:rotated_memory_z</code> instruction, even though depolarizing noise is generated, it seems that only the Z-type stabilizer measurement is performed. Why is that? Also, how can I perform syndrome measurements for both X-type and Z-type stabilizers?</p>
",How can I perform syndrome measurements for both X-type and Z-type stabilizers in Stim?,<measurement><error-correction><stabilizer-code><noise><stim>,0,9,,,"How can I perform syndrome measurements for both X-type and Z-type stabilizers in Stim? <p>I would like to simulate the logical error rate of the surface code under depolarizing noise using Stim. The decoder I am using decodes from both X-type and Z-type stabilizer syndrome values. Specifically, if an X error occurs on one data qubit, the syndrome value of the Z-type stabilizer flips. If a Z error occurs, the syndrome value of the X-type stabilizer flips. If a Y error occurs, both the X-type and Z-type stabilizer syndrome values flip.</p>
<p>I am considering the situation where both X-type and Z-type stabilizer syndrome measurements are performed. However, in the <code>surface_code:rotated_memory_z</code> instruction, even though depolarizing noise is generated, it seems that only the Z-type stabilizer measurement is performed. Why is that? Also, how can I perform syndrome measurements for both X-type and Z-type stabilizers?</p>
",qc,perform syndrome measurements stabilizers stim p would like simulate logical error rate surface code depolarizing noise using stim decoder using decodes stabilizer syndrome values specifically x error occurs one data qubit syndrome value stabilizer flips z error occurs syndrome value stabilizer flips error occurs stabilizer syndrome values p considering situation stabilizer syndrome measurements performed however code instruction even though depolarizing noise generated seems stabilizer measurement performed also perform syndrome measurements stabilizers,"[(5, 0.8241293), (14, 0.10440815), (17, 0.052268576), (19, 0.016945424)]"
32345,,2023-04-27 18:06:33,0,321,"<p>Are there any quantum error-correction codes which have been found to exhibit high thresholds for either Pauli-based depolarizing noise or Erasure noise channels, but not for both? Are there reasons to suspect that an error-correction code would perform better or worse under either of these channels?</p>
<p>A naive example could perhaps be the repetition code family, which can correct for erasure, but not general Pauli-based depolarizing noise.</p>
",Comparing the Erasure and Depolarizing Noise Channels in QEC,<error-correction><stabilizer-code><noise>,1,2,,,"Comparing the Erasure and Depolarizing Noise Channels in QEC <p>Are there any quantum error-correction codes which have been found to exhibit high thresholds for either Pauli-based depolarizing noise or Erasure noise channels, but not for both? Are there reasons to suspect that an error-correction code would perform better or worse under either of these channels?</p>
<p>A naive example could perhaps be the repetition code family, which can correct for erasure, but not general Pauli-based depolarizing noise.</p>
",qc,comparing erasure depolarizing noise channels qec p quantum codes found exhibit high thresholds either depolarizing noise erasure noise channels reasons suspect code would perform better worse either channels p naive example could perhaps repetition code family correct erasure general depolarizing,"[(3, 0.16018082), (5, 0.42149612), (8, 0.145461), (9, 0.11822112), (17, 0.15090664)]"
32383,,2023-05-01 11:54:39,1,94,"<p>I am performing many repetitions of a memory experiment in a stabilizer code using <a href=""https://github.com/quantumlib/Stim/blob/08f968e4201f2f5238f6923a8f2583f0ea247a22/glue/sample/README.md"" rel=""nofollow noreferrer"">sinter</a> to take many samples of different <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> circuits. I am following the <a href=""https://github.com/quantumlib/Stim/blob/08f968e4201f2f5238f6923a8f2583f0ea247a22/glue/sample/README.md#how-to-use-linux-command-line"" rel=""nofollow noreferrer"">example</a> in sinter's README file on how to perform this in the linux command line, namely by creating stim circuits in a directory ('circuits') and then running:</p>
<pre><code>sinter collect \
    --processes 4 \
    --circuits circuits/*.stim \
    --metadata_func &quot;sinter.comma_separated_key_values(path)&quot; \
    --decoders pymatching \
    --max_shots 1_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<p>I would like to run this for a very long time (using a very large number for <code>--max_shots</code>) but be able to dedicate a certain number of processor cores to different groupings of circuits. I tried creating groups of circuits in different directories (e.g. circuits1 &amp; circuits2), then creating a linux screen for each group and running the above command but it did not seem to be working at full capacity. I say this because on the 64 core machine I have access to if I run <code>sinter collect</code> on one screen with <code>--processes 32</code>  while working on circuits1, my computer's resource estimator shows that I am using about 50% of the CPU. If I then create another screen and run <code>sinter collect</code> on that, also with <code>--processes 32</code>, my resource estimator still shows that I am only using about 50% of my CPU. Both of the stats.csv files are updating, so they are both working, but if I am only using 50% of the CPU it seems like they could be working faster. Additionally, if I run <code>sinter collect</code> on one screen with <code>--processes 64</code> it shows 100% usage of the CPU, and if I try to start another screen with <code>--processes 64</code> I get an error.</p>
",How to sample multiple groups of stim circuits in parallel with stim on linux?,<stabilizer-code><stim>,1,0,,,"How to sample multiple groups of stim circuits in parallel with stim on linux? <p>I am performing many repetitions of a memory experiment in a stabilizer code using <a href=""https://github.com/quantumlib/Stim/blob/08f968e4201f2f5238f6923a8f2583f0ea247a22/glue/sample/README.md"" rel=""nofollow noreferrer"">sinter</a> to take many samples of different <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> circuits. I am following the <a href=""https://github.com/quantumlib/Stim/blob/08f968e4201f2f5238f6923a8f2583f0ea247a22/glue/sample/README.md#how-to-use-linux-command-line"" rel=""nofollow noreferrer"">example</a> in sinter's README file on how to perform this in the linux command line, namely by creating stim circuits in a directory ('circuits') and then running:</p>
<pre><code>sinter collect \
    --processes 4 \
    --circuits circuits/*.stim \
    --metadata_func &quot;sinter.comma_separated_key_values(path)&quot; \
    --decoders pymatching \
    --max_shots 1_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<p>I would like to run this for a very long time (using a very large number for <code>--max_shots</code>) but be able to dedicate a certain number of processor cores to different groupings of circuits. I tried creating groups of circuits in different directories (e.g. circuits1 &amp; circuits2), then creating a linux screen for each group and running the above command but it did not seem to be working at full capacity. I say this because on the 64 core machine I have access to if I run <code>sinter collect</code> on one screen with <code>--processes 32</code>  while working on circuits1, my computer's resource estimator shows that I am using about 50% of the CPU. If I then create another screen and run <code>sinter collect</code> on that, also with <code>--processes 32</code>, my resource estimator still shows that I am only using about 50% of my CPU. Both of the stats.csv files are updating, so they are both working, but if I am only using 50% of the CPU it seems like they could be working faster. Additionally, if I run <code>sinter collect</code> on one screen with <code>--processes 64</code> it shows 100% usage of the CPU, and if I try to start another screen with <code>--processes 64</code> I get an error.</p>
",qc,sample multiple groups stim circuits parallel stim linux p performing many repetitions memory experiment stabilizer code using https nofollow noreferrer sinter take many samples different https nofollow noreferrer stim circuits following https nofollow noreferrer example sinter readme file perform linux command line namely creating stim circuits directory running pre code sinter collect processes 4 circuits quot path quot decoders pymatching 1000 p would like run long time using large number code able dedicate certain number processor cores different groupings circuits tried creating groups circuits different directories circuits1 amp circuits2 creating linux screen group running command seem working full capacity say 64 core machine access run code sinter collect one screen code processes 32 working circuits1 computer resource estimator shows using 50 cpu create another screen run code sinter collect also code processes 32 resource estimator still shows using 50 cpu files updating working using 50 cpu seems like could working faster additionally run code sinter collect one screen code processes 64 shows 100 usage cpu try start another screen code processes 64 get,"[(4, 0.07354719), (5, 0.027089229), (8, 0.11407766), (9, 0.029798027), (14, 0.631428), (17, 0.01197235), (19, 0.104737975)]"
32468,,2023-05-06 05:34:00,0,126,"<p>The following is a part of the syndrome measurement circuit for Steane's seven qubit code in Stim(For ease of viewing, the TICK is omitted.). Since we are considering the detection of X errors, we use the measurement results of the Z stabilizers' ancilla. Circuit_1 is a circuit that constructs the CNOTs of the Z stabilizer circuit after configuring the CNOTs of the X stabilizer circuit, and since it is a circuit with no errors, the results of DETECTOR in circuit_1 will always be False, which is the desired result. On the other hand, when considering circuit_2, which is a circuit designed to reduce the overall circuit depth by cleverly arranging the order of CNOTs, the CNOT operations are the same as in circuit_1, but the result of qubit 12 becomes random. Why is this happening?</p>
<pre><code>circuit_1=stim.Circuit('''

    #encode into code state
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6
    
    #ancilla of X stabilizers
    RX 7 8 9 
    
    #ancilla of Z stabilizers
    R 10 11 12 
    
    #CNOT of X stabilizers
    CX 7 6 8 5
    CX 7 2 8 1
    CX 7 4 8 6
    CX 7 0 8 2 9 5
    CX 9 6
    CX 9 3
    CX 9 4
    
    #CNOT of Z stabilizers
    CX 6 12
    CX 3 12
    CX 4 12
    CX 6 10 5 11
    CX 2 10 1 11
    CX 4 10 6 11    
    CX 0 10 2 11 5 12
    
    #measurement of stabilizers
    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
</code></pre>
<pre><code>circuit_2=stim.Circuit('''

    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6

    RX 7 8 9 
    R 10 11 12 

    CX 7 6 8 5
    CX 7 2 8 1 6 12
    CX 7 4 8 6 3 12
    CX 7 0 8 2 9 5 4 12
    CX 6 10 5 11
    CX 9 6 2 10 1 11
    CX 9 3 4 10 6 11    
    CX 9 4 0 10 2 11 5 12

    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
<span class=""math-container"">```</span>
</code></pre>
",Why does the qubit give random results in the circuit with rearranged CNOTs for Steane's seven qubit code in Stim?,<measurement><error-correction><stabilizer-code><stim><stabilizer-state>,2,0,,,"Why does the qubit give random results in the circuit with rearranged CNOTs for Steane's seven qubit code in Stim? <p>The following is a part of the syndrome measurement circuit for Steane's seven qubit code in Stim(For ease of viewing, the TICK is omitted.). Since we are considering the detection of X errors, we use the measurement results of the Z stabilizers' ancilla. Circuit_1 is a circuit that constructs the CNOTs of the Z stabilizer circuit after configuring the CNOTs of the X stabilizer circuit, and since it is a circuit with no errors, the results of DETECTOR in circuit_1 will always be False, which is the desired result. On the other hand, when considering circuit_2, which is a circuit designed to reduce the overall circuit depth by cleverly arranging the order of CNOTs, the CNOT operations are the same as in circuit_1, but the result of qubit 12 becomes random. Why is this happening?</p>
<pre><code>circuit_1=stim.Circuit('''

    #encode into code state
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6
    
    #ancilla of X stabilizers
    RX 7 8 9 
    
    #ancilla of Z stabilizers
    R 10 11 12 
    
    #CNOT of X stabilizers
    CX 7 6 8 5
    CX 7 2 8 1
    CX 7 4 8 6
    CX 7 0 8 2 9 5
    CX 9 6
    CX 9 3
    CX 9 4
    
    #CNOT of Z stabilizers
    CX 6 12
    CX 3 12
    CX 4 12
    CX 6 10 5 11
    CX 2 10 1 11
    CX 4 10 6 11    
    CX 0 10 2 11 5 12
    
    #measurement of stabilizers
    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
</code></pre>
<pre><code>circuit_2=stim.Circuit('''

    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    MPP X0*X2*X4*X6

    RX 7 8 9 
    R 10 11 12 

    CX 7 6 8 5
    CX 7 2 8 1 6 12
    CX 7 4 8 6 3 12
    CX 7 0 8 2 9 5 4 12
    CX 6 10 5 11
    CX 9 6 2 10 1 11
    CX 9 3 4 10 6 11    
    CX 9 4 0 10 2 11 5 12

    MRX 7 8 9
    MR 10 11 12
    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]

''')
<span class=""math-container"">```</span>
</code></pre>
",qc,qubit give random results circuit rearranged cnots steane seven qubit code stim p following part syndrome measurement circuit steane seven qubit code stim ease viewing tick since considering detection x errors use measurement results z stabilizers ancilla circuit constructs cnots z stabilizer circuit configuring cnots x stabilizer circuit since circuit errors results detector always false desired result hand considering circuit designed reduce overall circuit depth cleverly arranging order cnots cnot operations result qubit 12 becomes random happening pre code encode code state mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp x0 x2 x4 x6 ancilla x stabilizers rx 7 8 9 ancilla z stabilizers r 10 11 12 cnot x stabilizers cx 7 6 8 5 cx 7 2 8 1 cx 7 4 8 6 cx 7 0 8 2 9 5 cx 9 6 cx 9 3 cx 9 4 cnot z stabilizers cx 6 12 cx 3 12 cx 4 12 cx 6 10 5 11 cx 2 10 1 11 cx 4 10 6 11 cx 0 10 2 11 5 12 measurement stabilizers mrx 7 8 9 mr 10 11 12 detector rec detector rec detector rec pre code mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp x0 x2 x4 x6 rx 7 8 9 r 10 11 12 cx 7 6 8 5 cx 7 2 8 1 6 12 cx 7 4 8 6 3 12 cx 7 0 8 2 9 5 4 12 cx 6 10 5 11 cx 9 6 2 10 1 11 cx 9 3 4 10 6 11 cx 9 4 0 10 2 11 5 12 mrx 7 8 9 mr 10 11 12 detector rec detector rec detector rec span,"[(4, 0.010423158), (5, 0.11730933), (6, 0.6755729), (9, 0.030547796), (10, 0.014155013), (12, 0.021320641), (14, 0.06402523), (17, 0.02413691), (18, 0.034258336)]"
32482,,2023-05-07 19:10:27,2,131,"<p>I am looking for a quantum gate (or a circuit) that operates on two quantum registers of equal size and in states <span class=""math-container"">$|a \rangle$</span> and <span class=""math-container"">$| b \rangle$</span>, respectively, and prepares the state: <span class=""math-container"">$\frac{1}{\sqrt{2}} |0, a \rangle + \frac{1}{\sqrt{2}} | 1, b \rangle$</span>.</p>
<p>Let's say that <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> are <span class=""math-container"">$N$</span> qubit registers. This means that we are going from an <span class=""math-container"">$2N$</span> qubit system to an <span class=""math-container"">$N + 1$</span> qubit system. So it may be best to use an output register like so, where <span class=""math-container"">$U$</span> is a quantum circuit:</p>
<p><span class=""math-container"">$$
U |a, b \rangle |0 \rangle | 0 ^ {\otimes N} \rangle = \frac{1}{\sqrt{2}} |a, b \rangle (|0, a \rangle + |1, b \rangle).
$$</span></p>
<p>But I think that is impossible by the no-cloning theorem; there exists no <span class=""math-container"">$V$</span> such that <span class=""math-container"">$V |x, 0 \rangle = | x, x \rangle$</span>. We would need to clone both the <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> register in my <span class=""math-container"">$U$</span> circuit.</p>
<p>So is this possible some other way?</p>
","Can a quantum gate send $|a,b\rangle$ to $|0,a\rangle+|1,b\rangle$?",<quantum-state><quantum-circuit><no-cloning-theorem>,1,0,,,"Can a quantum gate send $|a,b\rangle$ to $|0,a\rangle+|1,b\rangle$? <p>I am looking for a quantum gate (or a circuit) that operates on two quantum registers of equal size and in states <span class=""math-container"">$|a \rangle$</span> and <span class=""math-container"">$| b \rangle$</span>, respectively, and prepares the state: <span class=""math-container"">$\frac{1}{\sqrt{2}} |0, a \rangle + \frac{1}{\sqrt{2}} | 1, b \rangle$</span>.</p>
<p>Let's say that <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> are <span class=""math-container"">$N$</span> qubit registers. This means that we are going from an <span class=""math-container"">$2N$</span> qubit system to an <span class=""math-container"">$N + 1$</span> qubit system. So it may be best to use an output register like so, where <span class=""math-container"">$U$</span> is a quantum circuit:</p>
<p><span class=""math-container"">$$
U |a, b \rangle |0 \rangle | 0 ^ {\otimes N} \rangle = \frac{1}{\sqrt{2}} |a, b \rangle (|0, a \rangle + |1, b \rangle).
$$</span></p>
<p>But I think that is impossible by the no-cloning theorem; there exists no <span class=""math-container"">$V$</span> such that <span class=""math-container"">$V |x, 0 \rangle = | x, x \rangle$</span>. We would need to clone both the <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> register in my <span class=""math-container"">$U$</span> circuit.</p>
<p>So is this possible some other way?</p>
",qc,quantum gate send p looking quantum gate circuit operates two quantum registers equal size states span span b respectively prepares state span 1 2 1 2 1 b p let say span span b span n qubit registers means going span 2n qubit system span n 1 qubit system may best use output register like span u quantum circuit p span u b 0 n 1 2 b b p think impossible theorem exists span v span v 0 x x would need clone span span b register span u p possible way,"[(2, 0.112448335), (3, 0.5929571), (10, 0.0325323), (14, 0.038595233), (17, 0.013372957), (18, 0.20859168)]"
32501,32507.0,2023-05-08 23:50:12,8,1341,"<p>The Minimum Weight Perfect Matching (MWPM) decoder seems to be the most popular choice for decoding error syndromes in Surface Code quantum error correction. Can anyone give an intuitive idea of how it works, with an example?</p>
",Can you give an intuitive idea behind how the Minimum Weight Perfect Matching (MWPM) decoder work?,<error-correction><surface-code><fault-tolerance><minimum-weight-perfect-matching>,2,0,,,"Can you give an intuitive idea behind how the Minimum Weight Perfect Matching (MWPM) decoder work? <p>The Minimum Weight Perfect Matching (MWPM) decoder seems to be the most popular choice for decoding error syndromes in Surface Code quantum error correction. Can anyone give an intuitive idea of how it works, with an example?</p>
",qc,give intuitive idea behind minimum weight perfect matching mwpm decoder work p minimum weight perfect matching mwpm decoder seems popular choice decoding error syndromes surface code quantum error correction anyone give intuitive idea works example,"[(5, 0.49692467), (7, 0.37796053), (17, 0.061561313), (19, 0.059005536)]"
32532,,2023-05-11 09:24:05,2,32,"<p>We can think of an entangled state as a resource for accomplishing various tasks. For example, passing a CHSH test, performing a dense coding operation (when enhanced by transmission of a single qubit), teleporting a quantum state (when enhanced by two classical bits of communication).</p>
<p>When it comes to the CHSH test, a quantum resource cannot give the maximum possible theoretical value of <span class=""math-container"">$S=4$</span>. Instead, it can achieve up to <span class=""math-container"">$S=2\sqrt{2}$</span> (which is better than the classical limit of <span class=""math-container"">$S=2$</span>). However, theorists have suggested examining the consequences of a &quot;PR-box&quot;, which is a hypothetical resource which achieves this value of <span class=""math-container"">$S=4$</span>.</p>
<p>If I had such a PR box, would I be able to use it for dense coding? How dense is the coding - the same, better, or worse than quantum? I'm guessing that it's not sufficient to talk about a PR box in the abstract: one needs to have a theory in which you can write an equivalent of a state (&quot;generalised probabilistic theory&quot;?) <em>and</em> a detailed mechanism for measuring those state equivalents. I know such formalisms exist, but am not familiar with the details.</p>
",Dense coding for PR boxes,<information-theory><superdense-coding>,0,2,,,"Dense coding for PR boxes <p>We can think of an entangled state as a resource for accomplishing various tasks. For example, passing a CHSH test, performing a dense coding operation (when enhanced by transmission of a single qubit), teleporting a quantum state (when enhanced by two classical bits of communication).</p>
<p>When it comes to the CHSH test, a quantum resource cannot give the maximum possible theoretical value of <span class=""math-container"">$S=4$</span>. Instead, it can achieve up to <span class=""math-container"">$S=2\sqrt{2}$</span> (which is better than the classical limit of <span class=""math-container"">$S=2$</span>). However, theorists have suggested examining the consequences of a &quot;PR-box&quot;, which is a hypothetical resource which achieves this value of <span class=""math-container"">$S=4$</span>.</p>
<p>If I had such a PR box, would I be able to use it for dense coding? How dense is the coding - the same, better, or worse than quantum? I'm guessing that it's not sufficient to talk about a PR box in the abstract: one needs to have a theory in which you can write an equivalent of a state (&quot;generalised probabilistic theory&quot;?) <em>and</em> a detailed mechanism for measuring those state equivalents. I know such formalisms exist, but am not familiar with the details.</p>
",qc,dense coding pr boxes p think entangled state resource accomplishing various tasks example passing chsh test performing dense coding operation enhanced transmission single qubit teleporting quantum state enhanced two classical bits communication p comes chsh test quantum resource give maximum possible theoretical value span instead achieve span 2 better classical limit span however theorists suggested examining consequences quot quot hypothetical resource achieves value span p pr box would able use dense coding dense coding better worse quantum guessing sufficient talk pr box abstract one needs theory write equivalent state quot generalised probabilistic theory quot em detailed mechanism measuring state equivalents know formalisms exist familiar,"[(3, 0.091443904), (5, 0.01067873), (8, 0.43563142), (13, 0.12141068), (17, 0.02230585), (18, 0.2632516), (19, 0.05394903)]"
32560,,2023-05-12 17:35:52,0,193,"<h4>the Question</h4>
<p>Is there a standard way to use deterministic errors (so, for instance, <code>X_ERROR(1)</code>) in Stim with PyMatching? Currently, sometimes if I use <code>X_ERROR(1)</code> in my circuit, my pymatching decoder fails with <code>ValueError: maximum absolute edge weight of 16777215 exceeded.</code></p>
<p>I apologize if there is an obvious solution in the docs. I wasn't able to find one.</p>
<h4>I think this failure makes sense because...</h4>
<p>So using <code>X_ERROR(1)</code> sets 𝑝  = 1.</p>
<p>Reading what Craig explains <a href=""https://quantumcomputing.stackexchange.com/questions/30062/how-is-the-match-graph-extracted-from-a-stim-circuit-detector-error-model"">here</a>, <em>&quot;Ultimately the ... error probability 𝑝 becomes a weight <code>𝑤=lg(𝑝/(1−𝑝))</code>&quot;</em>, it makes sense <code>X_ERROR(1)</code> would cause problems given that <code>lg(1/(1-1))</code> is a weird divide-by-zero edge case*.</p>
<p>And it looks like this is what is happening because, indeed, my matching graphs end up with an edge of weight: <code>-inf</code>.
Example: <code>[(0, None, {'fault_ids': set(), 'weight': -inf, 'error_probability': 1.0})]</code> error.</p>
<p>And I think this is why I get the <code>ValueError: maximum absolute edge weight of 16777215 exceeded</code></p>
<p>(In fact, I'm now confused why there are some circuits I can write with <code>X_ERROR(1)</code> that don't fail in pymatching.)</p>
<p>*<em>Technically, in that post, he's talking about how pymatching combines edges. I'm making the assumption that even a single edge probability will be converted into weight: <code>𝑤=lg(𝑝/(1−𝑝))</code></em></p>
<h4>Hack-arounds ...</h4>
<ul>
<li><p>Running <code>X_ERROR(0.99)</code> does stop the error message but it makes doing fault enumeration a little weirder so I was hoping there would be another solution I just wasn't aware of.</p>
</li>
<li><p>I can't use a normal <code>X</code> gate because I'm using <code>DETECTOR</code>s (per <a href=""https://github.com/quantumlib/Stim/blob/main/doc/gates.md#DETECTOR"" rel=""nofollow noreferrer"">documentation</a> <code>DETECTOR</code>s will treat <code>X</code> differently from <code>X_ERROR(1)</code>)</p>
</li>
</ul>
<h3>A minimum failing example:</h3>
<pre><code>###### imports 
import stim 
import pymatching 
import numpy as np

###### Boilerplate decompose, run, and decode circuit function 
def run_decode(circuit, num_shots):
    model = circuit.detector_error_model(decompose_errors=True)
    matching = pymatching.Matching.from_detector_error_model(model)
    sampler = circuit.compile_detector_sampler()
    syndrome, actual_observables = sampler.sample(
        shots=num_shots, separate_observables=True)
    predicted_observables = matching.decode_batch(syndrome)
    error_rate = np.sum(np.any(predicted_observables !=
                        actual_observables, axis=1))/num_shots

    return error_rate


###### FAILING FUNCTION 
circ = stim.Circuit(&quot;&quot;&quot;R 0
X 0
X_ERROR(1) 0
M 0 
DETECTOR rec[-1]&quot;&quot;&quot;)

run_decode(circ, 10_000)

</code></pre>
<p>The edges of the matching graph here look like:
<code>[(0, None, {'fault_ids': set(), 'weight': -inf, 'error_probability': 1.0})]</code> and the code fails with:
<code>ValueError: maximum absolute edge weight of 16777215 exceeded.</code></p>
<h6>Please let me know if you need anymore information. I'll be happy to respond.</h6>
",Using Deterministic Errors in Stim Detector Circuit and decoding with Pymatching: X_ERROR(1) failing in PyMatching,<error-correction><stim><pymatching>,1,0,,,"Using Deterministic Errors in Stim Detector Circuit and decoding with Pymatching: X_ERROR(1) failing in PyMatching <h4>the Question</h4>
<p>Is there a standard way to use deterministic errors (so, for instance, <code>X_ERROR(1)</code>) in Stim with PyMatching? Currently, sometimes if I use <code>X_ERROR(1)</code> in my circuit, my pymatching decoder fails with <code>ValueError: maximum absolute edge weight of 16777215 exceeded.</code></p>
<p>I apologize if there is an obvious solution in the docs. I wasn't able to find one.</p>
<h4>I think this failure makes sense because...</h4>
<p>So using <code>X_ERROR(1)</code> sets 𝑝  = 1.</p>
<p>Reading what Craig explains <a href=""https://quantumcomputing.stackexchange.com/questions/30062/how-is-the-match-graph-extracted-from-a-stim-circuit-detector-error-model"">here</a>, <em>&quot;Ultimately the ... error probability 𝑝 becomes a weight <code>𝑤=lg(𝑝/(1−𝑝))</code>&quot;</em>, it makes sense <code>X_ERROR(1)</code> would cause problems given that <code>lg(1/(1-1))</code> is a weird divide-by-zero edge case*.</p>
<p>And it looks like this is what is happening because, indeed, my matching graphs end up with an edge of weight: <code>-inf</code>.
Example: <code>[(0, None, {'fault_ids': set(), 'weight': -inf, 'error_probability': 1.0})]</code> error.</p>
<p>And I think this is why I get the <code>ValueError: maximum absolute edge weight of 16777215 exceeded</code></p>
<p>(In fact, I'm now confused why there are some circuits I can write with <code>X_ERROR(1)</code> that don't fail in pymatching.)</p>
<p>*<em>Technically, in that post, he's talking about how pymatching combines edges. I'm making the assumption that even a single edge probability will be converted into weight: <code>𝑤=lg(𝑝/(1−𝑝))</code></em></p>
<h4>Hack-arounds ...</h4>
<ul>
<li><p>Running <code>X_ERROR(0.99)</code> does stop the error message but it makes doing fault enumeration a little weirder so I was hoping there would be another solution I just wasn't aware of.</p>
</li>
<li><p>I can't use a normal <code>X</code> gate because I'm using <code>DETECTOR</code>s (per <a href=""https://github.com/quantumlib/Stim/blob/main/doc/gates.md#DETECTOR"" rel=""nofollow noreferrer"">documentation</a> <code>DETECTOR</code>s will treat <code>X</code> differently from <code>X_ERROR(1)</code>)</p>
</li>
</ul>
<h3>A minimum failing example:</h3>
<pre><code>###### imports 
import stim 
import pymatching 
import numpy as np

###### Boilerplate decompose, run, and decode circuit function 
def run_decode(circuit, num_shots):
    model = circuit.detector_error_model(decompose_errors=True)
    matching = pymatching.Matching.from_detector_error_model(model)
    sampler = circuit.compile_detector_sampler()
    syndrome, actual_observables = sampler.sample(
        shots=num_shots, separate_observables=True)
    predicted_observables = matching.decode_batch(syndrome)
    error_rate = np.sum(np.any(predicted_observables !=
                        actual_observables, axis=1))/num_shots

    return error_rate


###### FAILING FUNCTION 
circ = stim.Circuit(&quot;&quot;&quot;R 0
X 0
X_ERROR(1) 0
M 0 
DETECTOR rec[-1]&quot;&quot;&quot;)

run_decode(circ, 10_000)

</code></pre>
<p>The edges of the matching graph here look like:
<code>[(0, None, {'fault_ids': set(), 'weight': -inf, 'error_probability': 1.0})]</code> and the code fails with:
<code>ValueError: maximum absolute edge weight of 16777215 exceeded.</code></p>
<h6>Please let me know if you need anymore information. I'll be happy to respond.</h6>
",qc,using deterministic errors stim detector circuit decoding pymatching 1 failing pymatching h4 question p standard way use deterministic errors instance code 1 stim pymatching currently sometimes use code 1 circuit pymatching decoder fails code valueerror maximum absolute edge weight 16777215 p apologize obvious solution docs able find h4 think failure makes sense p using code 1 sets 𝑝 p reading craig explains https em quot ultimately error probability 𝑝 becomes weight code quot makes sense code 1 would cause problems given code lg weird edge case p looks like happening indeed matching graphs end edge weight code example code 0 none set p think get code valueerror maximum absolute edge weight 16777215 exceeded p fact confused circuits write code 1 fail pymatching p em technically post talking pymatching combines edges making assumption even single edge probability converted weight code h4 ul li p running code stop error message makes fault enumeration little weirder hoping would another solution aware li p ca use normal code x gate using code detector per https detector nofollow noreferrer documentation code detector treat code x differently code 1 h3 minimum failing example pre code imports import stim import pymatching import numpy np boilerplate decompose run decode circuit function def circuit model matching model sampler syndrome syndrome return failing function circ quot quot quot r 0 x 0 1 0 0 detector rec quot quot quot circ p edges matching graph look like code 0 none set code fails code valueerror maximum absolute edge weight 16777215 h6 please let know need anymore information happy,"[(0, 0.10199267), (2, 0.049047925), (4, 0.036731493), (5, 0.22529927), (6, 0.0262109), (7, 0.011742442), (8, 0.015736353), (10, 0.012774943), (13, 0.18194465), (14, 0.2104803), (15, 0.019315159), (17, 0.04388727), (19, 0.06455743)]"
32570,,2023-05-13 13:53:56,2,80,"<p>I've read a lot about the Grover algorithm, and even got beyond the point of understanding the &quot;magic&quot; beyond the oracle function.
What is yet unclear to me is, given an oracle function which searches for the correct input over a certain field (for example, ID), how do we get information about the other fields?</p>
<p>A more detailed example: Let's say I have a database which encodes ID to full names. I want to use Grover's algorithm to search the ID 1111 in the database, and so I provide the following oracle:</p>
<p><span class=""math-container"">$f((ID,name))=\begin{cases}0,ID\neq1111\\1,ID=1111\end{cases}$</span></p>
<p>Now I use Grover's algorithm, which builds the entire input set and amplifies the amplitude for the correct vector. Allegedly, at least.</p>
<p>My concern is the following:</p>
<ul>
<li>If i do not provide any details about the name, then the entire name space is also a valid solution to return. The name space is not manipulated during the algorithm, and thus I do not get a result which is necessarily in the database.</li>
<li>If I do provide details about the name, that defeats the purpose of the search, since I obviously know the answer.</li>
<li>If there is some intrinsic relation between the ID field and the name field, then why not use this relation in order to deduce the name from my request instead of performing the query?</li>
</ul>
<p>I feel like I'm missing the final piece which makes Grover's algorithm as useful as it is claimed to be, but for now it really does feel like either providing a query too broad to get a meaningful answer, or providing an exact query which defeats the purpose of a search.</p>
<p>Thanks in advance.</p>
","In Grover's algorithm for database search, how are non-queried fields handled?",<quantum-algorithms><grovers-algorithm>,1,3,,,"In Grover's algorithm for database search, how are non-queried fields handled? <p>I've read a lot about the Grover algorithm, and even got beyond the point of understanding the &quot;magic&quot; beyond the oracle function.
What is yet unclear to me is, given an oracle function which searches for the correct input over a certain field (for example, ID), how do we get information about the other fields?</p>
<p>A more detailed example: Let's say I have a database which encodes ID to full names. I want to use Grover's algorithm to search the ID 1111 in the database, and so I provide the following oracle:</p>
<p><span class=""math-container"">$f((ID,name))=\begin{cases}0,ID\neq1111\\1,ID=1111\end{cases}$</span></p>
<p>Now I use Grover's algorithm, which builds the entire input set and amplifies the amplitude for the correct vector. Allegedly, at least.</p>
<p>My concern is the following:</p>
<ul>
<li>If i do not provide any details about the name, then the entire name space is also a valid solution to return. The name space is not manipulated during the algorithm, and thus I do not get a result which is necessarily in the database.</li>
<li>If I do provide details about the name, that defeats the purpose of the search, since I obviously know the answer.</li>
<li>If there is some intrinsic relation between the ID field and the name field, then why not use this relation in order to deduce the name from my request instead of performing the query?</li>
</ul>
<p>I feel like I'm missing the final piece which makes Grover's algorithm as useful as it is claimed to be, but for now it really does feel like either providing a query too broad to get a meaningful answer, or providing an exact query which defeats the purpose of a search.</p>
<p>Thanks in advance.</p>
",qc,grover algorithm database search fields handled p read lot grover algorithm even got beyond point understanding quot magic quot beyond oracle function yet unclear given oracle function searches correct input certain field example id get information fields p detailed example let say database encodes id full names want use grover algorithm search id 1111 database provide following oracle p span f id name cases 0 cases p use grover algorithm builds entire input set amplifies amplitude correct vector allegedly p concern following ul li provide details name entire name space also valid solution return name space manipulated algorithm thus get result necessarily li provide details name defeats purpose search since obviously know li intrinsic relation id field name field use relation order deduce name request instead performing query p feel like missing final piece makes grover algorithm useful claimed really feel like either providing query broad get meaningful answer providing exact query defeats purpose p thanks,"[(3, 0.056297544), (7, 0.38669175), (8, 0.16015236), (9, 0.061955087), (10, 0.02392669), (13, 0.21958612), (17, 0.03907117), (19, 0.035758164)]"
32586,,2023-05-15 08:34:14,2,242,"<p>In the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/gates.md#DEPOLARIZE2"" rel=""nofollow noreferrer"">definition of two-qubit depolarizing error in Stim</a>, it is defined that operations such as <span class=""math-container"">$IX, XX, YI$</span> (excluding <span class=""math-container"">$II$</span>) act with a probability of p/15, while <span class=""math-container"">$II$</span> acts with a probability of 1-p. Now, I want to use two-qubit depolarizing error where operations such as <span class=""math-container"">$IX, XX, YI$</span> (<strong>including</strong> <span class=""math-container"">$II$</span>) all act with a probability of p/16. Is it possible to achieve this kind of noise using Stim?</p>
",Two-qubit depolarizing error convention in Stim,<stim>,1,0,,,"Two-qubit depolarizing error convention in Stim <p>In the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/gates.md#DEPOLARIZE2"" rel=""nofollow noreferrer"">definition of two-qubit depolarizing error in Stim</a>, it is defined that operations such as <span class=""math-container"">$IX, XX, YI$</span> (excluding <span class=""math-container"">$II$</span>) act with a probability of p/15, while <span class=""math-container"">$II$</span> acts with a probability of 1-p. Now, I want to use two-qubit depolarizing error where operations such as <span class=""math-container"">$IX, XX, YI$</span> (<strong>including</strong> <span class=""math-container"">$II$</span>) all act with a probability of p/16. Is it possible to achieve this kind of noise using Stim?</p>
",qc,depolarizing error convention stim p https depolarize2 nofollow noreferrer definition depolarizing error stim defined operations span ix xx yi excluding span ii act probability span ii acts probability want use depolarizing error operations span ix xx yi strong including span ii act probability possible achieve kind noise using stim,"[(3, 0.375274), (5, 0.20058583), (6, 0.022422591), (9, 0.2506369), (10, 0.04491154), (11, 0.049372483), (17, 0.054151982)]"
32618,,2023-05-17 14:51:10,1,93,"<p><a href=""https://i.sstatic.net/zAozN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zAozN.png"" alt=""toric code grid"" /></a></p>
<p>I understand that if we have, for example, the blue path doesn't make any check operator detect any error, but what about the red path? We have the check operator detecting since there is just one qubit afect for each operator.</p>
",How horizontal loops on the toric code are all undetectable?,<error-correction><toric-code>,1,3,,,"How horizontal loops on the toric code are all undetectable? <p><a href=""https://i.sstatic.net/zAozN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zAozN.png"" alt=""toric code grid"" /></a></p>
<p>I understand that if we have, for example, the blue path doesn't make any check operator detect any error, but what about the red path? We have the check operator detecting since there is just one qubit afect for each operator.</p>
",qc,horizontal loops toric code undetectable p https nofollow noreferrer img https toric code grid p understand example blue path make check operator detect error red path check operator detecting since one qubit afect,"[(4, 0.23587565), (5, 0.403435), (8, 0.0363666), (13, 0.21714266), (17, 0.10251335)]"
32667,32668.0,2023-05-20 14:57:58,2,1383,"<p>Recently, I have been completing a VQE code and implementing the VQE algorithm for noisy models. However, during this process, I discovered that there are two types of Estimators provided in different tutorials.</p>
<pre><code>from qiskit_aer.primitives import Estimator as AerEstimator
from qiskit.primitives import Estimator
</code></pre>
<p>I tested them separately and encountered the following confusion:
A shortened version of my code is as follows:</p>
<pre><code>def UCCSD_VQE(hamiltonian, n_particles, num_qubits....):
    seed = 170
    algorithm_globals.random_seed = seed    
    num_particles = [n_particles // 2, n_particles // 2]
    mapper = JordanWignerMapper()
    converter = QubitConverter(mapper=mapper)
    hf = HartreeFock(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2)
    ansatz = UCCSD(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2, initial_state=hf, generalized=False, preserve_spin=True)
    optimizer = COBYLA(maxiter=1000)
    estimator = Estimator()
    vqe = VQE(estimator, ansatz=ansatz, optimizer=optimizer)
    vqe.initial_point = np.zeros(ansatz.num_parameters)
    result = vqe.compute_minimum_eigenvalue(hamiltonian)
    circ = result.optimal_circuit.bind_parameters(result.optimal_parameters)
   
    print(result)
    print(f&quot;VQE on Aer qasm simulator (no noise): {result.optimal_value.real:.8f}&quot;)
    print(f&quot;Delta from reference energy value is {(result.optimal_value.real - ref_value):.8f}&quot;)
</code></pre>
<p>If this is the setting, the result is relatively good. I calculated LiH with a molecular spacing of 2.8, and the returned result is as follows:</p>
<pre><code> 'optimizer_time': 25.174492597579956}
VQE on Aer qasm simulator (no noise): -7.80622948
Delta from reference energy value is 0.00000008
</code></pre>
<p>You can find time is approximately 25 seconds, and the error from the reference value is also within 0.00000008.</p>
<p>When I switch the simulator &quot;from qiskit_aer.primitives import Estimator&quot;, my setting is：</p>
<pre><code>try:
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)
   noiseless_estimator.set_options(device='GPU')
except AerError as e:
   print(&quot;Failed to initialize GPU estimator in creating no_Real_Noisy_model:&quot;, str(e))
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)

vqe = VQE(noiseless_estimator, ansatz=ansatz, optimizer=optimizer)
</code></pre>
<p>The rest of the code remains unchanged.</p>
<p>I have two pieces of NVIDIA GTX3090Ti, but the results after modifying this code are very poor.</p>
<pre><code>'optimizer_time': 899.3149755001068}
VQE on Aer qasm simulator (no noise): -7.81485699
Delta from reference energy value is -0.00862743
</code></pre>
<p>You can see that not only has the running time of the program increased, but also the accuracy has decreased.</p>
<p>My question is:</p>
<ol>
<li>Why does this phenomenon occur?</li>
<li>How can I set it up to fix this problem?</li>
</ol>
<p>My Virtual Environment Settings：</p>
<pre><code>qiskit                   0.39.2
qiskit-aer               0.11.1
qiskit-aer-gpu           0.11.2
qiskit-ibmq-provider     0.19.2
qiskit-nature            0.5.0
qiskit-terra             0.22.2
</code></pre>
<p>Thanks!!</p>
",What are the differences between the two Estimator in the qiskit,<qiskit>,1,0,,,"What are the differences between the two Estimator in the qiskit <p>Recently, I have been completing a VQE code and implementing the VQE algorithm for noisy models. However, during this process, I discovered that there are two types of Estimators provided in different tutorials.</p>
<pre><code>from qiskit_aer.primitives import Estimator as AerEstimator
from qiskit.primitives import Estimator
</code></pre>
<p>I tested them separately and encountered the following confusion:
A shortened version of my code is as follows:</p>
<pre><code>def UCCSD_VQE(hamiltonian, n_particles, num_qubits....):
    seed = 170
    algorithm_globals.random_seed = seed    
    num_particles = [n_particles // 2, n_particles // 2]
    mapper = JordanWignerMapper()
    converter = QubitConverter(mapper=mapper)
    hf = HartreeFock(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2)
    ansatz = UCCSD(qubit_converter=converter, num_particles=num_particles, num_spatial_orbitals=num_qubits // 2, initial_state=hf, generalized=False, preserve_spin=True)
    optimizer = COBYLA(maxiter=1000)
    estimator = Estimator()
    vqe = VQE(estimator, ansatz=ansatz, optimizer=optimizer)
    vqe.initial_point = np.zeros(ansatz.num_parameters)
    result = vqe.compute_minimum_eigenvalue(hamiltonian)
    circ = result.optimal_circuit.bind_parameters(result.optimal_parameters)
   
    print(result)
    print(f&quot;VQE on Aer qasm simulator (no noise): {result.optimal_value.real:.8f}&quot;)
    print(f&quot;Delta from reference energy value is {(result.optimal_value.real - ref_value):.8f}&quot;)
</code></pre>
<p>If this is the setting, the result is relatively good. I calculated LiH with a molecular spacing of 2.8, and the returned result is as follows:</p>
<pre><code> 'optimizer_time': 25.174492597579956}
VQE on Aer qasm simulator (no noise): -7.80622948
Delta from reference energy value is 0.00000008
</code></pre>
<p>You can find time is approximately 25 seconds, and the error from the reference value is also within 0.00000008.</p>
<p>When I switch the simulator &quot;from qiskit_aer.primitives import Estimator&quot;, my setting is：</p>
<pre><code>try:
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)
   noiseless_estimator.set_options(device='GPU')
except AerError as e:
   print(&quot;Failed to initialize GPU estimator in creating no_Real_Noisy_model:&quot;, str(e))
   noiseless_estimator = AerEstimator(
                            run_options={&quot;seed&quot;: seed},
                            transpile_options={&quot;seed_transpiler&quot;: seed},)

vqe = VQE(noiseless_estimator, ansatz=ansatz, optimizer=optimizer)
</code></pre>
<p>The rest of the code remains unchanged.</p>
<p>I have two pieces of NVIDIA GTX3090Ti, but the results after modifying this code are very poor.</p>
<pre><code>'optimizer_time': 899.3149755001068}
VQE on Aer qasm simulator (no noise): -7.81485699
Delta from reference energy value is -0.00862743
</code></pre>
<p>You can see that not only has the running time of the program increased, but also the accuracy has decreased.</p>
<p>My question is:</p>
<ol>
<li>Why does this phenomenon occur?</li>
<li>How can I set it up to fix this problem?</li>
</ol>
<p>My Virtual Environment Settings：</p>
<pre><code>qiskit                   0.39.2
qiskit-aer               0.11.1
qiskit-aer-gpu           0.11.2
qiskit-ibmq-provider     0.19.2
qiskit-nature            0.5.0
qiskit-terra             0.22.2
</code></pre>
<p>Thanks!!</p>
",qc,differences two estimator qiskit p recently completing vqe code implementing vqe algorithm noisy models however process discovered two types estimators provided different pre code import estimator aerestimator import estimator p tested separately encountered following confusion shortened version code follows pre code def hamiltonian seed 170 seed 2 2 mapper jordanwignermapper converter qubitconverter hf hartreefock 2 ansatz uccsd 2 optimizer cobyla estimator estimator vqe vqe estimator result hamiltonian circ print result print f quot vqe aer qasm simulator noise quot print f quot delta reference energy value quot p setting result relatively good calculated lih molecular spacing returned result follows pre code vqe aer qasm simulator noise delta reference energy value p find time approximately 25 seconds error reference value also within p switch simulator quot import estimator quot setting pre code try aerestimator quot seed quot seed quot quot seed except aererror e print quot failed initialize gpu estimator creating quot str e aerestimator quot seed quot seed quot quot seed vqe vqe p rest code remains p two pieces nvidia gtx3090ti results modifying code pre code vqe aer qasm simulator noise delta reference energy value p see running time program increased also accuracy p question ol li phenomenon occur li set fix problem p virtual environment pre code qiskit p thanks,"[(0, 0.47300208), (4, 0.01881341), (7, 0.04614793), (8, 0.089510344), (9, 0.044240538), (12, 0.019544492), (14, 0.09280325), (17, 0.056560222), (19, 0.15883301)]"
32748,,2023-05-27 14:35:27,0,46,"<p>Define the operator on a qudit system as
<span class=""math-container"">\begin{align}
o
&amp;= \sum_{s, s^\prime=1}^d o_{s,s^\prime}\vert s\rangle\langle s \vert \otimes \vert s^\prime\rangle \langle s^\prime \vert.
\tag{1}
\end{align}</span>
Then I want to compute the composite operator of <span class=""math-container"">$N$</span> qudit systems, which is
<span class=""math-container"">\begin{align}
O
&amp;= o^{\otimes N} = \sum_{\textbf{s}, \textbf{s}^\prime} O_{\textbf{s}, \textbf{s}^\prime} \vert \textbf{s} \rangle \langle \textbf{s} \vert \otimes \vert \textbf{s}^\prime \rangle \langle \textbf{s}^\prime \vert,
\tag{2}
\end{align}</span>
where
<span class=""math-container"">\begin{align}
\vert \textbf{s} \rangle = \bigotimes_{i=1}^N \vert s_i \rangle, \vert \textbf{s}^\prime \rangle = \bigotimes_{i=1}^N \vert s_i^\prime \rangle
\tag{3}
\end{align}</span>
are the computational basis states and <span class=""math-container"">$i$</span> is the index of the qudit system.</p>
<p>I derive a result that is different from eq. (2). How to obtain eq. (2)? This problem originates in eq. (30) of <a href=""https://doi.org/10.1103/PhysRevA.99.052323"" rel=""nofollow noreferrer"">this paper</a></p>
",The operator of the composite system given the operator of the single system,<linear-algebra><quantum-state>,1,0,,,"The operator of the composite system given the operator of the single system <p>Define the operator on a qudit system as
<span class=""math-container"">\begin{align}
o
&amp;= \sum_{s, s^\prime=1}^d o_{s,s^\prime}\vert s\rangle\langle s \vert \otimes \vert s^\prime\rangle \langle s^\prime \vert.
\tag{1}
\end{align}</span>
Then I want to compute the composite operator of <span class=""math-container"">$N$</span> qudit systems, which is
<span class=""math-container"">\begin{align}
O
&amp;= o^{\otimes N} = \sum_{\textbf{s}, \textbf{s}^\prime} O_{\textbf{s}, \textbf{s}^\prime} \vert \textbf{s} \rangle \langle \textbf{s} \vert \otimes \vert \textbf{s}^\prime \rangle \langle \textbf{s}^\prime \vert,
\tag{2}
\end{align}</span>
where
<span class=""math-container"">\begin{align}
\vert \textbf{s} \rangle = \bigotimes_{i=1}^N \vert s_i \rangle, \vert \textbf{s}^\prime \rangle = \bigotimes_{i=1}^N \vert s_i^\prime \rangle
\tag{3}
\end{align}</span>
are the computational basis states and <span class=""math-container"">$i$</span> is the index of the qudit system.</p>
<p>I derive a result that is different from eq. (2). How to obtain eq. (2)? This problem originates in eq. (30) of <a href=""https://doi.org/10.1103/PhysRevA.99.052323"" rel=""nofollow noreferrer"">this paper</a></p>
",qc,operator composite system given operator single system p define operator qudit system span align amp 1 align want compute composite operator span n qudit systems span align amp n 2 align span align 3 align computational basis states span index qudit p derive result different eq 2 obtain eq 2 problem originates eq 30 https nofollow noreferrer paper,"[(2, 0.053828813), (3, 0.68945473), (4, 0.05351144), (7, 0.0248129), (15, 0.15787025), (17, 0.018111436)]"
32854,32855.0,2023-06-05 02:06:45,0,48,"<p>I am trying to run the example from documentation: <a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">pymatching docs</a></p>
<p>Here is my code:</p>
<pre><code>from pymatching import Matching
H = toric_code_x_stabilisers(3)
logicals = toric_code_x_logicals(3)
print(&quot;logicals :&quot;,logicals)
p=0.04
matching=Matching(H)
print(&quot;Matching :&quot;,matching)
noise = np.random.binomial(1, p, H.shape[1])
print(&quot;noise :&quot;,noise)
syndrome = H@noise % 2
print(&quot;syndrome :&quot;, syndrome)
prediction = matching.decode(syndrome)
print(&quot;prediction :&quot;, prediction)
predicted_logicals_flipped = logicals@prediction % 2
print(&quot;predicted_logicals_flipped :&quot;, predicted_logicals_flipped)
actual_logicals_flipped = logicals@noise % 2
print(&quot;actual_logicals_flipped :&quot;, actual_logicals_flipped)



def num_decoding_failures_vectorised(H, logicals, error_probability, num_shots):
    matching = Matching.from_check_matrix(H, weights=np.log((1-p)/p), faults_matrix=logicals)
    noise = (np.random.random((num_shots, H.shape[1])) &lt; error_probability).astype(np.uint8)
    shots = (noise @ H.T) % 2
    actual_observables = (noise @ logicals.T) % 2
    predicted_observables = matching.decode_batch(shots)
    num_errors = np.sum(np.any(predicted_observables != actual_observables, axis=1))
    return num_errors
    
result = num_decoding_failures_vectorised(H,logicals,p,100)
print(results)
</code></pre>
<p>where <code>toric_code_x_stabilisers</code> and <code>toric_code_x_logicals</code> directly taken from the following page: <a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">toric code</a></p>
<p>However, I am having the error: &quot;AttributeError: 'Matching' object has no attribute 'decode_batch'&quot;
I am assuming the code should be correct since it is taken from the documentation and I do not know what causes to this error.</p>
<p>Any help regarding this issue?</p>
",Pymatching: 'Matching' object has no attribute 'decode_batch',<toric-code><pymatching>,1,0,,,"Pymatching: 'Matching' object has no attribute 'decode_batch' <p>I am trying to run the example from documentation: <a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">pymatching docs</a></p>
<p>Here is my code:</p>
<pre><code>from pymatching import Matching
H = toric_code_x_stabilisers(3)
logicals = toric_code_x_logicals(3)
print(&quot;logicals :&quot;,logicals)
p=0.04
matching=Matching(H)
print(&quot;Matching :&quot;,matching)
noise = np.random.binomial(1, p, H.shape[1])
print(&quot;noise :&quot;,noise)
syndrome = H@noise % 2
print(&quot;syndrome :&quot;, syndrome)
prediction = matching.decode(syndrome)
print(&quot;prediction :&quot;, prediction)
predicted_logicals_flipped = logicals@prediction % 2
print(&quot;predicted_logicals_flipped :&quot;, predicted_logicals_flipped)
actual_logicals_flipped = logicals@noise % 2
print(&quot;actual_logicals_flipped :&quot;, actual_logicals_flipped)



def num_decoding_failures_vectorised(H, logicals, error_probability, num_shots):
    matching = Matching.from_check_matrix(H, weights=np.log((1-p)/p), faults_matrix=logicals)
    noise = (np.random.random((num_shots, H.shape[1])) &lt; error_probability).astype(np.uint8)
    shots = (noise @ H.T) % 2
    actual_observables = (noise @ logicals.T) % 2
    predicted_observables = matching.decode_batch(shots)
    num_errors = np.sum(np.any(predicted_observables != actual_observables, axis=1))
    return num_errors
    
result = num_decoding_failures_vectorised(H,logicals,p,100)
print(results)
</code></pre>
<p>where <code>toric_code_x_stabilisers</code> and <code>toric_code_x_logicals</code> directly taken from the following page: <a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">toric code</a></p>
<p>However, I am having the error: &quot;AttributeError: 'Matching' object has no attribute 'decode_batch'&quot;
I am assuming the code should be correct since it is taken from the documentation and I do not know what causes to this error.</p>
<p>Any help regarding this issue?</p>
",qc,pymatching object attribute p trying run example documentation https nofollow noreferrer pymatching docs p code pre code pymatching import matching h 3 logicals 3 print quot logicals quot logicals h print quot matching quot matching noise 1 p 1 print quot noise quot noise syndrome h noise 2 print quot syndrome quot syndrome prediction syndrome print quot prediction quot prediction logicals prediction 2 print quot quot logicals noise 2 print quot quot def h logicals matching h noise 1 lt shots noise 2 noise 2 shots return result h logicals print results p code code directly taken following page https nofollow noreferrer toric code p however error quot attributeerror object attribute quot assuming code correct since taken documentation know causes p help regarding issue,"[(0, 0.24299234), (2, 0.072304204), (4, 0.08186042), (5, 0.13286681), (6, 0.020589126), (11, 0.05815612), (14, 0.13677204), (17, 0.07798878), (19, 0.175584)]"
32857,,2023-06-05 05:33:21,2,338,"<p>The full density matrix of 30 qubits contain <span class=""math-container"">$2^{30}$</span> states. How does qiskit/qasm implement this without storing and computing the full <span class=""math-container"">$2^{30}$</span> density matrix of possible state coefficients?</p>
",How does Qiskit/Qasm simulate the density matrix of up to 30 qubits?,<qiskit><density-matrix>,1,2,,,"How does Qiskit/Qasm simulate the density matrix of up to 30 qubits? <p>The full density matrix of 30 qubits contain <span class=""math-container"">$2^{30}$</span> states. How does qiskit/qasm implement this without storing and computing the full <span class=""math-container"">$2^{30}$</span> density matrix of possible state coefficients?</p>
",qc,simulate density matrix 30 qubits p full density matrix 30 qubits contain span 30 states implement without storing computing full span 30 density matrix possible state coefficients,"[(1, 0.04938498), (3, 0.12852287), (11, 0.22146471), (17, 0.26884842), (18, 0.32626274)]"
32869,,2023-06-06 15:41:17,2,169,"<p>I have implemented the following 8 qubit QFT circuit similar to the following:</p>
<p><a href=""https://i.sstatic.net/zyEK8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zyEK8.png"" alt=""enter image description here"" /></a></p>
<p>and loaded the coefficients as follows:</p>
<p><a href=""https://i.sstatic.net/jXcuH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jXcuH.png"" alt=""enter image description here"" /></a></p>
<p>The output of the QFT is as follows:</p>
<p><a href=""https://i.sstatic.net/bhdyD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/bhdyD.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/GrJRb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GrJRb.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/jAReH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jAReH.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/QZHmH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QZHmH.png"" alt=""enter image description here"" /></a></p>
<p>Could anyone help interpret the above result?</p>
<hr />
<p>With particularly nice values of wavelength,</p>
<p><a href=""https://i.sstatic.net/0tD5h.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0tD5h.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/Fc0Jr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Fc0Jr.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/lvQQP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lvQQP.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/brl4Q.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/brl4Q.png"" alt=""enter image description here"" /></a></p>
<p>so the circuit seems to be filtering frequencies in some way, but how to read the &quot;frequency&quot; value from the above result?</p>
<hr />
<p>Analogous case for discrete fourier transform (300 data points):</p>
<p><a href=""https://i.sstatic.net/emojb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/emojb.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/5DhDr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5DhDr.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/29O2T.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/29O2T.png"" alt=""enter image description here"" /></a></p>
<p>The frequency burst at <span class=""math-container"">$X_{18}=120$</span> can be read straight off the result.</p>
<p>I am unclear what will happen when this exact same case is implemented using quantum Fourier transform on 300 qubits?  What will <span class=""math-container"">$X_{18}=120$</span> be manifested in (probability amplitude?) in the output measurement of quantum fourier transform?</p>
",How to understand Quantum Fourier Transform measurement output?,<quantum-fourier-transform>,1,5,,,"How to understand Quantum Fourier Transform measurement output? <p>I have implemented the following 8 qubit QFT circuit similar to the following:</p>
<p><a href=""https://i.sstatic.net/zyEK8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/zyEK8.png"" alt=""enter image description here"" /></a></p>
<p>and loaded the coefficients as follows:</p>
<p><a href=""https://i.sstatic.net/jXcuH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jXcuH.png"" alt=""enter image description here"" /></a></p>
<p>The output of the QFT is as follows:</p>
<p><a href=""https://i.sstatic.net/bhdyD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/bhdyD.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/GrJRb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/GrJRb.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/jAReH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jAReH.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/QZHmH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/QZHmH.png"" alt=""enter image description here"" /></a></p>
<p>Could anyone help interpret the above result?</p>
<hr />
<p>With particularly nice values of wavelength,</p>
<p><a href=""https://i.sstatic.net/0tD5h.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0tD5h.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/Fc0Jr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Fc0Jr.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/lvQQP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lvQQP.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/brl4Q.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/brl4Q.png"" alt=""enter image description here"" /></a></p>
<p>so the circuit seems to be filtering frequencies in some way, but how to read the &quot;frequency&quot; value from the above result?</p>
<hr />
<p>Analogous case for discrete fourier transform (300 data points):</p>
<p><a href=""https://i.sstatic.net/emojb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/emojb.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/5DhDr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/5DhDr.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/29O2T.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/29O2T.png"" alt=""enter image description here"" /></a></p>
<p>The frequency burst at <span class=""math-container"">$X_{18}=120$</span> can be read straight off the result.</p>
<p>I am unclear what will happen when this exact same case is implemented using quantum Fourier transform on 300 qubits?  What will <span class=""math-container"">$X_{18}=120$</span> be manifested in (probability amplitude?) in the output measurement of quantum fourier transform?</p>
",qc,understand quantum fourier transform measurement output p implemented following 8 qubit qft circuit similar following p https nofollow noreferrer img https enter image description p loaded coefficients follows p https nofollow noreferrer img https enter image description p output qft follows p https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description p could anyone help interpret result hr p particularly nice values wavelength p https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description p circuit seems filtering frequencies way read quot frequency quot value result hr p analogous case discrete fourier transform 300 data points p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p frequency burst span 18 read straight p unclear happen exact case implemented using quantum fourier transform 300 qubits span 18 manifested probability amplitude output measurement quantum fourier transform,"[(3, 0.024892407), (4, 0.796671), (6, 0.01573754), (7, 0.10072914), (8, 0.011424684), (9, 0.026501717), (17, 0.01310499), (19, 0.010323356)]"
32872,,2023-06-07 04:07:25,0,106,"<p>The parity check matrix is 5x13. I run a distance three surface code with 3 rounds for each shot.</p>
<p>The syndrome measurement results are as follows for the first shot:</p>
<pre><code>x_syndrome_1st_round = [0, 0, 0, 1, 1, 1]
x_syndrome_2nd_round = [1, 1, 0, 1, 1, 1]
x_syndrome_3rd_round = [1, 1, 1, 0, 1, 0]
</code></pre>
<p>So, the detection events are:</p>
<pre><code>detection1 = [1, 1, 0, 0, 0, 0]
detection2 = [0, 0, 1, 1, 0, 1]
</code></pre>
<p>The error rate is 0.08.</p>
<p>I simply start coding with following script:
<code>matching = Matching.from_check_matrix(H_d3x, weights=np.log((1 - p) / p))  # H_d3x is the x parity check matrix</code> where H_d3x is the parity_check matrix for x stabilizer in distance-3 surface code</p>
<p>We have a function in pymatching called decode_batch, and we can provide syndrome measurements for each shot as a 2D array input to decode_batch. However, for each shot, I am taking multiple syndrome measurements, and I do not know how to input this into pymatching.</p>
<p>Thank you in advance.</p>
<p>P.S. I have edited the question since I have understood the language conflict. I believe now the question is in better shape.</p>
",How can I decode errors in the multiple rounds of the surface code in pymatching?,<pymatching>,0,10,,,"How can I decode errors in the multiple rounds of the surface code in pymatching? <p>The parity check matrix is 5x13. I run a distance three surface code with 3 rounds for each shot.</p>
<p>The syndrome measurement results are as follows for the first shot:</p>
<pre><code>x_syndrome_1st_round = [0, 0, 0, 1, 1, 1]
x_syndrome_2nd_round = [1, 1, 0, 1, 1, 1]
x_syndrome_3rd_round = [1, 1, 1, 0, 1, 0]
</code></pre>
<p>So, the detection events are:</p>
<pre><code>detection1 = [1, 1, 0, 0, 0, 0]
detection2 = [0, 0, 1, 1, 0, 1]
</code></pre>
<p>The error rate is 0.08.</p>
<p>I simply start coding with following script:
<code>matching = Matching.from_check_matrix(H_d3x, weights=np.log((1 - p) / p))  # H_d3x is the x parity check matrix</code> where H_d3x is the parity_check matrix for x stabilizer in distance-3 surface code</p>
<p>We have a function in pymatching called decode_batch, and we can provide syndrome measurements for each shot as a 2D array input to decode_batch. However, for each shot, I am taking multiple syndrome measurements, and I do not know how to input this into pymatching.</p>
<p>Thank you in advance.</p>
<p>P.S. I have edited the question since I have understood the language conflict. I believe now the question is in better shape.</p>
",qc,decode errors multiple rounds surface code pymatching p parity check matrix 5x13 run distance three surface code 3 rounds p syndrome measurement results follows first shot pre code 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 0 1 0 p detection events pre code detection1 1 1 0 0 0 0 detection2 0 0 1 1 0 1 p error rate p simply start coding following script code matching 1 p p x parity check matrix matrix x stabilizer surface code p function pymatching called provide syndrome measurements shot 2d array input however shot taking multiple syndrome measurements know input p thank p edited question since understood language conflict believe question better,"[(2, 0.32178253), (5, 0.29094002), (8, 0.052795947), (10, 0.025183562), (11, 0.017430741), (14, 0.26305592), (17, 0.0276826)]"
32877,,2023-06-07 13:41:41,0,95,"<p>The circuit which measures a Z-type stabilisers in the surface code is:</p>
<p><a href=""https://i.sstatic.net/qETW0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qETW0.png"" alt=""enter image description here"" /></a></p>
<p>whereas for X-type stabilisers it's:</p>
<p><a href=""https://i.sstatic.net/SMzJO.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/SMzJO.png"" alt=""enter image description here"" /></a></p>
<p>Both types of stabilisers are measured in a memory experiment in the inbuilt surface code circuits of <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim</a>, which I am using by following the linux command line instructions for <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">Sinter</a>. Even though both types of stabilisers are measured for each memory experiment, the two extra hadamards for X-type stabiliser measurements (which detect Z errors) means they have higher depth. This causes a higher logical error rate in a memory experiment for memory X (preserving <span class=""math-container"">$|+\rangle_L$</span> which is more affected by <span class=""math-container"">$Z$</span> errors) than for memory Z (preserving <span class=""math-container"">$|0\rangle_L$</span> which is more affected by <span class=""math-container"">$X$</span> errors). That is <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span>.</p>
<p>The circuits I am using are stim's inbuilt surface code circuits. These measure both types of stabilisers for both types of memory experiment. See a distance 2, unrotated surface code with 1 round of stabiliser measurements below as an example (though for my simulations I am doing odd distances and <span class=""math-container"">$d$</span> rounds of stabiliser measurements).</p>
<p>Memory Z prepares the data qubits in <span class=""math-container"">$|0\rangle ^{\otimes n}$</span> and measures them in the Z basis at the end (preserving <span class=""math-container"">$|0\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/jisGr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jisGr.png"" alt=""enter image description here"" /></a></p>
<p>Whereas Memory X prepares the data qubits in <span class=""math-container"">$|+\rangle ^{\otimes n}$</span> and measures them in the X basis at the end (preserving <span class=""math-container"">$|+\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/AcZe7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AcZe7.png"" alt=""enter image description here"" /></a></p>
<p>Note that these diagrams are without noise but for my simulations I am using a circuit noise model (setting all of Stim's inbuilt errors to <span class=""math-container"">$p$</span>).</p>
<p>When making threshold curves for the rotated surface code using <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim's</a> inbuilt circuits I see, as expected, that <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span>. For example for distance 7 and 9 below <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> for each distance:
<a href=""https://i.sstatic.net/RG5XG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RG5XG.png"" alt=""enter image description here"" /></a></p>
<p>On the other hand for the <em>unrotated</em> surface code I am seeing the opposite. Instead of <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> I am seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span> I have triple checked that I am running and plotting the correct memory experiment type and can not figure out what is causing it. I have simulated every odd distance up to 15 and keep seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span>, as per the plots below:</p>
<p><a href=""https://i.sstatic.net/gLJbm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/gLJbm.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/Ar0tP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ar0tP.png"" alt=""enter image description here"" /></a></p>
<p>I am running the memory experiments from a linux command line following the instructions for Sinter <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">here</a> which are:</p>
<pre><code>mkdir -p circuits
python -c &quot;

import stim

for p in [0.001, 0.005, 0.01]:
    for d in [3, 5]:
        with open(f'circuits/d={d},p={p},b=X,type=rotated_surface_memory.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_x')
            print(c, file=f)
&quot;
</code></pre>
<pre><code>sinter collect \
    --processes 4 \
    --circuits circuits/*.stim \
    --metadata_func &quot;sinter.comma_separated_key_values(path)&quot; \
    --decoders pymatching \
    --max_shots 1_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<pre><code>sinter plot \
    --in stats.csv \
    --group_func &quot;'Rotated Surface Code d=' + str(metadata['d'])&quot; \
    --x_func &quot;metadata['p']&quot; \
    --fig_size 1024 1024 \
    --xaxis &quot;[log]Physical Error Rate&quot; \
    --out surface_code_figure.png \
    --show
</code></pre>
",Inverted memory X and memory Z logical error rates for unrotated surface code in Stim?,<stabilizer-code><stim><surface-code>,1,0,,,"Inverted memory X and memory Z logical error rates for unrotated surface code in Stim? <p>The circuit which measures a Z-type stabilisers in the surface code is:</p>
<p><a href=""https://i.sstatic.net/qETW0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qETW0.png"" alt=""enter image description here"" /></a></p>
<p>whereas for X-type stabilisers it's:</p>
<p><a href=""https://i.sstatic.net/SMzJO.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/SMzJO.png"" alt=""enter image description here"" /></a></p>
<p>Both types of stabilisers are measured in a memory experiment in the inbuilt surface code circuits of <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim</a>, which I am using by following the linux command line instructions for <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">Sinter</a>. Even though both types of stabilisers are measured for each memory experiment, the two extra hadamards for X-type stabiliser measurements (which detect Z errors) means they have higher depth. This causes a higher logical error rate in a memory experiment for memory X (preserving <span class=""math-container"">$|+\rangle_L$</span> which is more affected by <span class=""math-container"">$Z$</span> errors) than for memory Z (preserving <span class=""math-container"">$|0\rangle_L$</span> which is more affected by <span class=""math-container"">$X$</span> errors). That is <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span>.</p>
<p>The circuits I am using are stim's inbuilt surface code circuits. These measure both types of stabilisers for both types of memory experiment. See a distance 2, unrotated surface code with 1 round of stabiliser measurements below as an example (though for my simulations I am doing odd distances and <span class=""math-container"">$d$</span> rounds of stabiliser measurements).</p>
<p>Memory Z prepares the data qubits in <span class=""math-container"">$|0\rangle ^{\otimes n}$</span> and measures them in the Z basis at the end (preserving <span class=""math-container"">$|0\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/jisGr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jisGr.png"" alt=""enter image description here"" /></a></p>
<p>Whereas Memory X prepares the data qubits in <span class=""math-container"">$|+\rangle ^{\otimes n}$</span> and measures them in the X basis at the end (preserving <span class=""math-container"">$|+\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/AcZe7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AcZe7.png"" alt=""enter image description here"" /></a></p>
<p>Note that these diagrams are without noise but for my simulations I am using a circuit noise model (setting all of Stim's inbuilt errors to <span class=""math-container"">$p$</span>).</p>
<p>When making threshold curves for the rotated surface code using <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim's</a> inbuilt circuits I see, as expected, that <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span>. For example for distance 7 and 9 below <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> for each distance:
<a href=""https://i.sstatic.net/RG5XG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RG5XG.png"" alt=""enter image description here"" /></a></p>
<p>On the other hand for the <em>unrotated</em> surface code I am seeing the opposite. Instead of <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> I am seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span> I have triple checked that I am running and plotting the correct memory experiment type and can not figure out what is causing it. I have simulated every odd distance up to 15 and keep seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span>, as per the plots below:</p>
<p><a href=""https://i.sstatic.net/gLJbm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/gLJbm.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/Ar0tP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ar0tP.png"" alt=""enter image description here"" /></a></p>
<p>I am running the memory experiments from a linux command line following the instructions for Sinter <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">here</a> which are:</p>
<pre><code>mkdir -p circuits
python -c &quot;

import stim

for p in [0.001, 0.005, 0.01]:
    for d in [3, 5]:
        with open(f'circuits/d={d},p={p},b=X,type=rotated_surface_memory.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_x')
            print(c, file=f)
&quot;
</code></pre>
<pre><code>sinter collect \
    --processes 4 \
    --circuits circuits/*.stim \
    --metadata_func &quot;sinter.comma_separated_key_values(path)&quot; \
    --decoders pymatching \
    --max_shots 1_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<pre><code>sinter plot \
    --in stats.csv \
    --group_func &quot;'Rotated Surface Code d=' + str(metadata['d'])&quot; \
    --x_func &quot;metadata['p']&quot; \
    --fig_size 1024 1024 \
    --xaxis &quot;[log]Physical Error Rate&quot; \
    --out surface_code_figure.png \
    --show
</code></pre>
",qc,inverted memory x memory z logical error rates unrotated surface code stim p circuit measures stabilisers surface code p https nofollow noreferrer img https enter image description p whereas stabilisers p https nofollow noreferrer img https enter image description p types stabilisers measured memory experiment inbuilt surface code circuits https nofollow noreferrer stim using following linux command line instructions https nofollow noreferrer sinter even though types stabilisers measured memory experiment two extra hadamards stabiliser measurements detect z errors means higher depth causes higher logical error rate memory experiment memory x preserving span affected span z errors memory z preserving span affected span x errors span gt p circuits using stim inbuilt surface code circuits measure types stabilisers types memory experiment see distance 2 unrotated surface code 1 round stabiliser measurements example though simulations odd distances span rounds stabiliser measurements p memory z prepares data qubits span n measures z basis end preserving span p https nofollow noreferrer img https enter image description p whereas memory x prepares data qubits span n measures x basis end preserving span p https nofollow noreferrer img https enter image description p note diagrams without noise simulations using circuit noise model setting stim inbuilt errors span p p making threshold curves rotated surface code using https nofollow noreferrer stim inbuilt circuits see expected span gt example distance 7 9 span gt distance https nofollow noreferrer img https enter image description p hand em unrotated surface code seeing opposite instead span gt seeing span lt triple checked running plotting correct memory experiment type figure causing simulated every odd distance 15 keep seeing span lt per plots p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p running memory experiments linux command line following instructions sinter https nofollow noreferrer pre code mkdir circuits python quot import stim p 3 5 open p w f c print c quot pre code sinter collect processes 4 circuits quot path quot decoders pymatching 1000 pre code sinter plot quot surface code str metadata quot quot metadata p quot 1024 1024 xaxis quot log physical error rate quot show,"[(0, 0.04223358), (3, 0.07696574), (4, 0.27048177), (5, 0.21685229), (6, 0.022349248), (9, 0.081800856), (10, 0.018387781), (11, 0.01224074), (14, 0.17123303), (17, 0.02044556), (19, 0.0667544)]"
32898,,2023-06-09 07:10:45,0,120,"<p>There are things I do not understand about the following circuit, and I would appreciate it if you could explain.</p>
<pre><code>circuit=stim.Circuit(f'''
    MPP X0*X1*X2*X3
    CX 1 0 2 0 3 0 
    M 0
    DETECTOR rec[-1]
''')
dem = circuit.detector_error_model()
print(repr(dem))
</code></pre>
<p>This circuit initially prepares a stabilizer state stabilized by <span class=""math-container"">$XXXX$</span> through <code>MPP X0*X1*X2*X3</code>. I understand that part, but I do not understand what the subsequent operations imply.</p>
<p>One interpretation is that, by measuring <span class=""math-container"">$ZZZZ$</span> with three CNOTs, since <span class=""math-container"">$XXXX$</span> and <span class=""math-container"">$ZZZZ$</span> commute, the state after the measurement is thought to remain stabilized by <span class=""math-container"">$XXXX$</span>. However, another interpretation is that we are actually measuring <span class=""math-container"">$ZIII$</span> at the end of the circuit, which anti-commutes with <span class=""math-container"">$XXXX$</span>, so the state after the measurement could be considered to be in a state that is not stabilized by <span class=""math-container"">$XXXX$</span>. Which interpretation is correct? In fact, simulations by Stim consistently return trivial measurement results, which suggests the former interpretation is correct. However, I do not understand why it's not appropriate to consider that we're measuring <span class=""math-container"">$ZIII$</span>, which anti-commutes with <span class=""math-container"">$XXXX$</span>.</p>
",Commutation relationship and measurement results,<error-correction><measurement><stabilizer-code><pauli-gates><stim>,1,0,,,"Commutation relationship and measurement results <p>There are things I do not understand about the following circuit, and I would appreciate it if you could explain.</p>
<pre><code>circuit=stim.Circuit(f'''
    MPP X0*X1*X2*X3
    CX 1 0 2 0 3 0 
    M 0
    DETECTOR rec[-1]
''')
dem = circuit.detector_error_model()
print(repr(dem))
</code></pre>
<p>This circuit initially prepares a stabilizer state stabilized by <span class=""math-container"">$XXXX$</span> through <code>MPP X0*X1*X2*X3</code>. I understand that part, but I do not understand what the subsequent operations imply.</p>
<p>One interpretation is that, by measuring <span class=""math-container"">$ZZZZ$</span> with three CNOTs, since <span class=""math-container"">$XXXX$</span> and <span class=""math-container"">$ZZZZ$</span> commute, the state after the measurement is thought to remain stabilized by <span class=""math-container"">$XXXX$</span>. However, another interpretation is that we are actually measuring <span class=""math-container"">$ZIII$</span> at the end of the circuit, which anti-commutes with <span class=""math-container"">$XXXX$</span>, so the state after the measurement could be considered to be in a state that is not stabilized by <span class=""math-container"">$XXXX$</span>. Which interpretation is correct? In fact, simulations by Stim consistently return trivial measurement results, which suggests the former interpretation is correct. However, I do not understand why it's not appropriate to consider that we're measuring <span class=""math-container"">$ZIII$</span>, which anti-commutes with <span class=""math-container"">$XXXX$</span>.</p>
",qc,commutation relationship measurement results p things understand following circuit would appreciate could pre code f mpp x0 x1 x2 x3 cx 1 0 2 0 3 0 0 detector rec dem print repr dem p circuit initially prepares stabilizer state stabilized span xxxx code mpp x0 x1 x2 x3 understand part understand subsequent operations p one interpretation measuring span zzzz three cnots since span xxxx span zzzz commute state measurement thought remain stabilized span xxxx however another interpretation actually measuring span ziii end circuit span xxxx state measurement could considered state stabilized span xxxx interpretation correct fact simulations stim consistently return trivial measurement results suggests former interpretation correct however understand appropriate consider measuring span ziii span xxxx,"[(0, 0.028756283), (2, 0.026397346), (3, 0.32174316), (5, 0.13551073), (6, 0.1669987), (10, 0.012374159), (12, 0.017614314), (14, 0.057081863), (17, 0.041536205), (18, 0.19112568)]"
32925,32950.0,2023-06-10 21:45:50,2,252,"<p>I've only recently, and still only haphazardly and rather poorly, begun to understand Ising models with local interactions.  I'm interested in particular in the simple one-dimensional Ising model with nearest <em>and next-nearest</em> neighbor interactions, which have been referred to in the literature as ANNNI Hamiltonians, or anisotropic, next-nearest neighbor interactions (with none, either, or both a transverse and longitudinal external magnetic field).</p>
<p>Depending on the strengths of the nearest-neighbor interactions relative to the next-nearest neighbor interactions (and also to the external magnetic fields) there could be very lovely and dynamic frustration going on - the nearest neighbor might favor parallel spins <span class=""math-container"">$\mid\uparrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\downarrow\downarrow\rangle$</span> but the next-nearest neighbor interactions might force antiparallel spins <span class=""math-container"">$\mid\downarrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\uparrow\downarrow\rangle$</span>, or <em>vice-versa</em>.</p>
<ul>
<li><strong>Can we say anything about if and when frustration leads to an entangled ground state?</strong></li>
</ul>
<p>The answer might be related to so-called area laws, which consider the amount of entanglement relative to the dimension of the chain.  For a one-dimensional chain an area law suggests that there may be little entanglement, but is there any additional entanglement borne out of frustration?</p>
<hr />
<p>This was also partly inspired by Sandy Irani's presentation at the Israeli Institute for Advanced Studies <a href=""https://www.youtube.com/watch?v=L8o_M8twaOs"" rel=""nofollow noreferrer"">here</a>, where she mentions frustration in the context of a <a href=""https://www.manybody.phy.cam.ac.uk/Research/kagome#:%7E:text=The%20Kagome%20lattice%20consists%20of,both%20possible%20configurations%20will%20always"" rel=""nofollow noreferrer"">Kagome lattice</a>.</p>
<p><a href=""https://i.sstatic.net/coxqj.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/coxqj.jpg"" alt=""Kagome Lattice"" /></a></p>
<p>I gathered from her talk that the Kagome lattice puts some stress on naive implementations of classical many-body algorithms like DMRG, but nonetheless from clever DMRG simulations there's some evidence that the lattice does indeed have a uniquely quantum (non-degenerate and highly entangled) ground state.</p>
",(When) must the ground state of a frustrated Hamiltonian be entangled?,<entanglement><hamiltonian-simulation><ion-trap-quantum-computing><ising-model>,1,1,,,"(When) must the ground state of a frustrated Hamiltonian be entangled? <p>I've only recently, and still only haphazardly and rather poorly, begun to understand Ising models with local interactions.  I'm interested in particular in the simple one-dimensional Ising model with nearest <em>and next-nearest</em> neighbor interactions, which have been referred to in the literature as ANNNI Hamiltonians, or anisotropic, next-nearest neighbor interactions (with none, either, or both a transverse and longitudinal external magnetic field).</p>
<p>Depending on the strengths of the nearest-neighbor interactions relative to the next-nearest neighbor interactions (and also to the external magnetic fields) there could be very lovely and dynamic frustration going on - the nearest neighbor might favor parallel spins <span class=""math-container"">$\mid\uparrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\downarrow\downarrow\rangle$</span> but the next-nearest neighbor interactions might force antiparallel spins <span class=""math-container"">$\mid\downarrow\uparrow\rangle$</span> or <span class=""math-container"">$\mid\uparrow\downarrow\rangle$</span>, or <em>vice-versa</em>.</p>
<ul>
<li><strong>Can we say anything about if and when frustration leads to an entangled ground state?</strong></li>
</ul>
<p>The answer might be related to so-called area laws, which consider the amount of entanglement relative to the dimension of the chain.  For a one-dimensional chain an area law suggests that there may be little entanglement, but is there any additional entanglement borne out of frustration?</p>
<hr />
<p>This was also partly inspired by Sandy Irani's presentation at the Israeli Institute for Advanced Studies <a href=""https://www.youtube.com/watch?v=L8o_M8twaOs"" rel=""nofollow noreferrer"">here</a>, where she mentions frustration in the context of a <a href=""https://www.manybody.phy.cam.ac.uk/Research/kagome#:%7E:text=The%20Kagome%20lattice%20consists%20of,both%20possible%20configurations%20will%20always"" rel=""nofollow noreferrer"">Kagome lattice</a>.</p>
<p><a href=""https://i.sstatic.net/coxqj.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/coxqj.jpg"" alt=""Kagome Lattice"" /></a></p>
<p>I gathered from her talk that the Kagome lattice puts some stress on naive implementations of classical many-body algorithms like DMRG, but nonetheless from clever DMRG simulations there's some evidence that the lattice does indeed have a uniquely quantum (non-degenerate and highly entangled) ground state.</p>
",qc,must ground state frustrated hamiltonian entangled p recently still haphazardly rather poorly begun understand ising models local interactions interested particular simple ising model nearest em neighbor interactions referred literature annni hamiltonians anisotropic neighbor interactions none either transverse longitudinal external magnetic field p depending strengths interactions relative neighbor interactions also external magnetic fields could lovely dynamic frustration going nearest neighbor might favor parallel spins span span neighbor interactions might force antiparallel spins span span em ul li strong say anything frustration leads entangled ground state p answer might related area laws consider amount entanglement relative dimension chain chain area law suggests may little entanglement additional entanglement borne frustration hr p also partly inspired sandy irani presentation israeli institute advanced studies https nofollow noreferrer mentions frustration context https 7e 20kagome 20lattice 20consists 20of 20possible 20configurations 20will 20always nofollow noreferrer kagome lattice p https nofollow noreferrer img https kagome lattice p gathered talk kagome lattice puts stress naive implementations classical algorithms like dmrg nonetheless clever dmrg simulations evidence lattice indeed uniquely quantum highly entangled ground,"[(1, 0.10728454), (4, 0.015326524), (8, 0.09365161), (9, 0.5426447), (13, 0.1013161), (15, 0.0128625315), (16, 0.033076875), (17, 0.014590369), (18, 0.06956488)]"
32941,32959.0,2023-06-12 09:58:13,1,246,"<p>When running memory experiments using <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim</a>’s inbuilt unrotated surface code circuits to generate thresholds, I am getting the opposite behaviour to the rotated surface code for memory X and memory Z logical error rates.</p>
<p>For each type of memory experiment -  which I am running by following the linux command line instructions for <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">Sinter</a> - both types of stabilisers are measured. Despite this, the two extra hadamards for X-type stabiliser measurements (which detect Z errors) means they have higher depth than the Z-type stabilisers in the overall circuit. This causes a higher logical error rate in a memory experiment for memory X (preserving <span class=""math-container"">$|+\rangle_L$</span> which is more affected by <span class=""math-container"">$Z$</span> errors) than for memory Z (preserving <span class=""math-container"">$|0\rangle_L$</span> which is more affected by <span class=""math-container"">$X$</span> errors). That is <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> (as shown in this <a href=""https://arxiv.org/abs/1311.5003"" rel=""nofollow noreferrer"">paper</a>).</p>
<p>The circuits I am using are stim's inbuilt surface code circuits. These measure both types of stabilisers for both types of memory experiment. See a distance 2, unrotated surface code with 1 round of stabiliser measurements below as an example (though for my simulations I am doing odd distances and <span class=""math-container"">$d$</span> rounds of stabiliser measurements).</p>
<p>Memory Z prepares the data qubits in <span class=""math-container"">$|0\rangle ^{\otimes n}$</span> and measures them in the Z basis at the end (preserving <span class=""math-container"">$|0\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/jisGr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jisGr.png"" alt=""enter image description here"" /></a></p>
<p>Whereas Memory X prepares the data qubits in <span class=""math-container"">$|+\rangle ^{\otimes n}$</span> and measures them in the X basis at the end (preserving <span class=""math-container"">$|+\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/AcZe7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AcZe7.png"" alt=""enter image description here"" /></a></p>
<p>Note that these diagrams are without noise but for my simulations I am using a circuit noise model (setting all of Stim's inbuilt errors to <span class=""math-container"">$p$</span>).</p>
<p>When making threshold curves for the rotated surface code using <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim's</a> inbuilt circuits I see, as expected, that <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span>. For example for distance 7 and 9 below <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> for each distance:
<a href=""https://i.sstatic.net/RG5XG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RG5XG.png"" alt=""enter image description here"" /></a></p>
<p>On the other hand for the <em>unrotated</em> surface code I am seeing the opposite. Instead of <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> I am seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span> I have triple checked that I am running and plotting the correct memory experiment type and can not figure out what is causing it. I have simulated every odd distance up to 15 and keep seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span>, as per the plots below:</p>
<p><a href=""https://i.sstatic.net/gLJbm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/gLJbm.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/Ar0tP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ar0tP.png"" alt=""enter image description here"" /></a></p>
<p>I am running the memory experiments from a linux command line following the instructions for Sinter <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">here</a> which are:</p>
<pre><code>mkdir -p circuits
python -c &quot;

import stim

for p in [0.001, 0.005, 0.01]:
    for d in [3, 5]:
        with open(f'circuits/d={d},p={p},b=X,type=rotated_surface_memory.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_x')
            print(c, file=f)
&quot;
</code></pre>
<pre><code>sinter collect \
    --processes 4 \
    --circuits circuits/*.stim \
    --metadata_func &quot;sinter.comma_separated_key_values(path)&quot; \
    --decoders pymatching \
    --max_shots 1_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<pre><code>sinter plot \
    --in stats.csv \
    --group_func &quot;'Rotated Surface Code d=' + str(metadata['d'])&quot; \
    --x_func &quot;metadata['p']&quot; \
    --fig_size 1024 1024 \
    --xaxis &quot;[log]Physical Error Rate&quot; \
    --out surface_code_figure.png \
    --show
</code></pre>
",Inbuilt Stim circuits showing unexpected Memory X and Memory Z logical error rates for unrotated surface code,<stim>,2,0,,,"Inbuilt Stim circuits showing unexpected Memory X and Memory Z logical error rates for unrotated surface code <p>When running memory experiments using <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim</a>’s inbuilt unrotated surface code circuits to generate thresholds, I am getting the opposite behaviour to the rotated surface code for memory X and memory Z logical error rates.</p>
<p>For each type of memory experiment -  which I am running by following the linux command line instructions for <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">Sinter</a> - both types of stabilisers are measured. Despite this, the two extra hadamards for X-type stabiliser measurements (which detect Z errors) means they have higher depth than the Z-type stabilisers in the overall circuit. This causes a higher logical error rate in a memory experiment for memory X (preserving <span class=""math-container"">$|+\rangle_L$</span> which is more affected by <span class=""math-container"">$Z$</span> errors) than for memory Z (preserving <span class=""math-container"">$|0\rangle_L$</span> which is more affected by <span class=""math-container"">$X$</span> errors). That is <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> (as shown in this <a href=""https://arxiv.org/abs/1311.5003"" rel=""nofollow noreferrer"">paper</a>).</p>
<p>The circuits I am using are stim's inbuilt surface code circuits. These measure both types of stabilisers for both types of memory experiment. See a distance 2, unrotated surface code with 1 round of stabiliser measurements below as an example (though for my simulations I am doing odd distances and <span class=""math-container"">$d$</span> rounds of stabiliser measurements).</p>
<p>Memory Z prepares the data qubits in <span class=""math-container"">$|0\rangle ^{\otimes n}$</span> and measures them in the Z basis at the end (preserving <span class=""math-container"">$|0\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/jisGr.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jisGr.png"" alt=""enter image description here"" /></a></p>
<p>Whereas Memory X prepares the data qubits in <span class=""math-container"">$|+\rangle ^{\otimes n}$</span> and measures them in the X basis at the end (preserving <span class=""math-container"">$|+\rangle_L$</span>):</p>
<p><a href=""https://i.sstatic.net/AcZe7.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AcZe7.png"" alt=""enter image description here"" /></a></p>
<p>Note that these diagrams are without noise but for my simulations I am using a circuit noise model (setting all of Stim's inbuilt errors to <span class=""math-container"">$p$</span>).</p>
<p>When making threshold curves for the rotated surface code using <a href=""https://arxiv.org/abs/2103.02202v3"" rel=""nofollow noreferrer"">Stim's</a> inbuilt circuits I see, as expected, that <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span>. For example for distance 7 and 9 below <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> for each distance:
<a href=""https://i.sstatic.net/RG5XG.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/RG5XG.png"" alt=""enter image description here"" /></a></p>
<p>On the other hand for the <em>unrotated</em> surface code I am seeing the opposite. Instead of <span class=""math-container"">${p_L}_X &gt; {p_L}_Z$</span> I am seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span> I have triple checked that I am running and plotting the correct memory experiment type and can not figure out what is causing it. I have simulated every odd distance up to 15 and keep seeing <span class=""math-container"">${p_L}_X &lt; {p_L}_Z$</span>, as per the plots below:</p>
<p><a href=""https://i.sstatic.net/gLJbm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/gLJbm.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/Ar0tP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Ar0tP.png"" alt=""enter image description here"" /></a></p>
<p>I am running the memory experiments from a linux command line following the instructions for Sinter <a href=""https://pypi.org/project/sinter/"" rel=""nofollow noreferrer"">here</a> which are:</p>
<pre><code>mkdir -p circuits
python -c &quot;

import stim

for p in [0.001, 0.005, 0.01]:
    for d in [3, 5]:
        with open(f'circuits/d={d},p={p},b=X,type=rotated_surface_memory.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_x')
            print(c, file=f)
&quot;
</code></pre>
<pre><code>sinter collect \
    --processes 4 \
    --circuits circuits/*.stim \
    --metadata_func &quot;sinter.comma_separated_key_values(path)&quot; \
    --decoders pymatching \
    --max_shots 1_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<pre><code>sinter plot \
    --in stats.csv \
    --group_func &quot;'Rotated Surface Code d=' + str(metadata['d'])&quot; \
    --x_func &quot;metadata['p']&quot; \
    --fig_size 1024 1024 \
    --xaxis &quot;[log]Physical Error Rate&quot; \
    --out surface_code_figure.png \
    --show
</code></pre>
",qc,inbuilt stim circuits showing unexpected memory x memory z logical error rates unrotated surface code p running memory experiments using https nofollow noreferrer stim inbuilt unrotated surface code circuits generate thresholds getting opposite behaviour rotated surface code memory x memory z logical error p type memory experiment running following linux command line instructions https nofollow noreferrer sinter types stabilisers measured despite two extra hadamards stabiliser measurements detect z errors means higher depth stabilisers overall circuit causes higher logical error rate memory experiment memory x preserving span affected span z errors memory z preserving span affected span x errors span gt shown https nofollow noreferrer paper p circuits using stim inbuilt surface code circuits measure types stabilisers types memory experiment see distance 2 unrotated surface code 1 round stabiliser measurements example though simulations odd distances span rounds stabiliser measurements p memory z prepares data qubits span n measures z basis end preserving span p https nofollow noreferrer img https enter image description p whereas memory x prepares data qubits span n measures x basis end preserving span p https nofollow noreferrer img https enter image description p note diagrams without noise simulations using circuit noise model setting stim inbuilt errors span p p making threshold curves rotated surface code using https nofollow noreferrer stim inbuilt circuits see expected span gt example distance 7 9 span gt distance https nofollow noreferrer img https enter image description p hand em unrotated surface code seeing opposite instead span gt seeing span lt triple checked running plotting correct memory experiment type figure causing simulated every odd distance 15 keep seeing span lt per plots p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description p running memory experiments linux command line following instructions sinter https nofollow noreferrer pre code mkdir circuits python quot import stim p 3 5 open p w f c print c quot pre code sinter collect processes 4 circuits quot path quot decoders pymatching 1000 pre code sinter plot quot surface code str metadata quot quot metadata p quot 1024 1024 xaxis quot log physical error rate quot show,"[(0, 0.048365887), (3, 0.07276601), (4, 0.23236915), (5, 0.22819635), (6, 0.022251775), (9, 0.0800651), (10, 0.022037962), (11, 0.012273046), (14, 0.19119492), (17, 0.018118747), (19, 0.07210533)]"
32980,,2023-06-14 12:19:42,1,73,"<p>I am trying to reproduce this paper: <a href=""https://arxiv.org/pdf/2211.02302.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2211.02302.pdf</a>. However, I am having problems in getting the singlet first excited state (S1). The authors in the paper, they use the SSVQE algorithm with a penalty term in the cost function to obtain the S1 of the H2 molecule. I am using <a href=""http://docs.qulacs.org/en/latest/apply/6.3_ssvqe.html"" rel=""nofollow noreferrer"">Qulacs</a> (as in the paper) and the same parameters for the cost function. However, when using the SSVQE with the penalty term, I get all the time the ground state and the triplet first excited state (S0 and T1), instead of getting S0 and S1 as in the paper. Can someone help me with that? I attach my cost function:</p>
<pre><code>def cost(theta_list):

    mu = 10**5
    s0=0
    s1=0
    gamma = 0.6

    state0 = QuantumState(n_qubit) 
    state1 = QuantumState(n_qubit); state1.set_computational_basis(1) 

    cost_function = get_exp(state0, theta_list) + gamma *get_exp(state1, theta_list) + mu*abs(get_exp_s2(state0, theta_list)-s0*(s0+1) + (get_exp_s2(state1, theta_list)-s1*(s1+1)))**2 

    return cost_function
</code></pre>
<p>I have also compared my observables (H and S²) with the ones in the paper and they are exactly the same, so I am guessing the problem is in how I implement the cost function with the penalty term... Thank you a lot for the help!</p>
",Subespace Search Variational Quantum Eigensolver (SSVQE) with contraints,<simulation><chemistry><variational-quantum-algorithms>,0,0,,,"Subespace Search Variational Quantum Eigensolver (SSVQE) with contraints <p>I am trying to reproduce this paper: <a href=""https://arxiv.org/pdf/2211.02302.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/2211.02302.pdf</a>. However, I am having problems in getting the singlet first excited state (S1). The authors in the paper, they use the SSVQE algorithm with a penalty term in the cost function to obtain the S1 of the H2 molecule. I am using <a href=""http://docs.qulacs.org/en/latest/apply/6.3_ssvqe.html"" rel=""nofollow noreferrer"">Qulacs</a> (as in the paper) and the same parameters for the cost function. However, when using the SSVQE with the penalty term, I get all the time the ground state and the triplet first excited state (S0 and T1), instead of getting S0 and S1 as in the paper. Can someone help me with that? I attach my cost function:</p>
<pre><code>def cost(theta_list):

    mu = 10**5
    s0=0
    s1=0
    gamma = 0.6

    state0 = QuantumState(n_qubit) 
    state1 = QuantumState(n_qubit); state1.set_computational_basis(1) 

    cost_function = get_exp(state0, theta_list) + gamma *get_exp(state1, theta_list) + mu*abs(get_exp_s2(state0, theta_list)-s0*(s0+1) + (get_exp_s2(state1, theta_list)-s1*(s1+1)))**2 

    return cost_function
</code></pre>
<p>I have also compared my observables (H and S²) with the ones in the paper and they are exactly the same, so I am guessing the problem is in how I implement the cost function with the penalty term... Thank you a lot for the help!</p>
",qc,subespace search variational quantum eigensolver ssvqe contraints p trying reproduce paper https nofollow noreferrer https however problems getting singlet first excited state s1 authors paper use ssvqe algorithm penalty term cost function obtain s1 h2 molecule using http nofollow noreferrer qulacs paper parameters cost function however using ssvqe penalty term get time ground state triplet first excited state s0 t1 instead getting s0 s1 paper someone help attach cost function pre code def cost mu 10 5 gamma state0 quantumstate state1 quantumstate 1 state0 gamma state1 mu abs state0 state1 2 return p also compared observables h s² ones paper exactly guessing problem implement cost function penalty term thank lot help,"[(0, 0.32371938), (4, 0.10955454), (7, 0.057689924), (8, 0.2958132), (9, 0.09719515), (11, 0.025553472), (17, 0.021816412), (18, 0.06739614)]"
33045,,2023-06-19 14:19:46,2,61,"<p>In Cirq <a href=""https://quantumai.google/cirq/google/best_practices#align_single-qubit_and_two-qubit_layers"" rel=""nofollow noreferrer"">document</a> that describes 'best practices' for manually optimizing circuits, they recommend to construct a circuit in a pattern that alternate 'single-qubit gates with two-qubit gates in each layer'.</p>
<p>Regarding this, I have few questions:</p>
<p>(1) The reason for such recommendation, appeared in the document, is because they calibrated devices optimally to such pattern. Yet, why such specific pattern must have been considered as calibration object?</p>
<p>(2) Will there be any other patterns in circuit layers to be considered for optimal circuit runs?</p>
",Reasons for Google's calibration policy of fitting to Alternating Single/Two-qubit gate pattern,<circuit-construction>,0,0,,,"Reasons for Google's calibration policy of fitting to Alternating Single/Two-qubit gate pattern <p>In Cirq <a href=""https://quantumai.google/cirq/google/best_practices#align_single-qubit_and_two-qubit_layers"" rel=""nofollow noreferrer"">document</a> that describes 'best practices' for manually optimizing circuits, they recommend to construct a circuit in a pattern that alternate 'single-qubit gates with two-qubit gates in each layer'.</p>
<p>Regarding this, I have few questions:</p>
<p>(1) The reason for such recommendation, appeared in the document, is because they calibrated devices optimally to such pattern. Yet, why such specific pattern must have been considered as calibration object?</p>
<p>(2) Will there be any other patterns in circuit layers to be considered for optimal circuit runs?</p>
",qc,reasons google calibration policy fitting alternating gate pattern p cirq https nofollow noreferrer document describes practices manually optimizing circuits recommend construct circuit pattern alternate gates gates p regarding questions p 1 reason recommendation appeared document calibrated devices optimally pattern yet specific pattern must considered calibration object p 2 patterns circuit layers considered optimal circuit runs,"[(2, 0.03579936), (4, 0.10241901), (8, 0.18949077), (13, 0.1045998), (14, 0.43715215), (16, 0.070467606), (17, 0.03698596), (19, 0.020783592)]"
33063,,2023-06-20 15:11:38,2,87,"<p>How does error correction disentangle the environment from the encoded state after the quantum erasure channel?
For example; the paper <em><a href=""https://arxiv.org/abs/quant-ph/9610042"" rel=""nofollow noreferrer"">Codes for the Quantum Erasure Channel</a></em> introduces a 4 qubit code for the erasure channel, with the first codeword: <span class=""math-container"">$$|\bar{0}\rangle=|0000\rangle +|1111\rangle,$$</span>
If we assume that an erasure occurs on the fourth qubit, then applying the channel isometry, the state becomes <span class=""math-container"">$$|000e\rangle \otimes |0\rangle_E +|111e\rangle\otimes |1\rangle_E .$$</span> The reduced state accessible by the decoder is <span class=""math-container"">$$|000e\rangle\langle 000e| +|111e\rangle\langle 111e|.$$</span> If the decoder map preserves even parity of vectors, then it will map <span class=""math-container"">$$|000e\rangle \rightarrow |0000\rangle$$</span> and <span class=""math-container"">$$|111e\rangle \rightarrow |1111\rangle.$$</span> Then the reduced state is mapped to <span class=""math-container"">$$|0000\rangle\langle 0000| +|1111\rangle\langle 1111| \neq |\bar{0}\rangle\langle\bar{0}|,$$</span> which is not the original state? What am I missing about the decoder operation?</p>
",How to disentangle the environment after the quantum erasure channel?,<error-correction>,1,0,,,"How to disentangle the environment after the quantum erasure channel? <p>How does error correction disentangle the environment from the encoded state after the quantum erasure channel?
For example; the paper <em><a href=""https://arxiv.org/abs/quant-ph/9610042"" rel=""nofollow noreferrer"">Codes for the Quantum Erasure Channel</a></em> introduces a 4 qubit code for the erasure channel, with the first codeword: <span class=""math-container"">$$|\bar{0}\rangle=|0000\rangle +|1111\rangle,$$</span>
If we assume that an erasure occurs on the fourth qubit, then applying the channel isometry, the state becomes <span class=""math-container"">$$|000e\rangle \otimes |0\rangle_E +|111e\rangle\otimes |1\rangle_E .$$</span> The reduced state accessible by the decoder is <span class=""math-container"">$$|000e\rangle\langle 000e| +|111e\rangle\langle 111e|.$$</span> If the decoder map preserves even parity of vectors, then it will map <span class=""math-container"">$$|000e\rangle \rightarrow |0000\rangle$$</span> and <span class=""math-container"">$$|111e\rangle \rightarrow |1111\rangle.$$</span> Then the reduced state is mapped to <span class=""math-container"">$$|0000\rangle\langle 0000| +|1111\rangle\langle 1111| \neq |\bar{0}\rangle\langle\bar{0}|,$$</span> which is not the original state? What am I missing about the decoder operation?</p>
",qc,disentangle environment quantum erasure channel p error correction disentangle environment encoded state quantum erasure channel example paper em https nofollow noreferrer codes quantum erasure channel introduces 4 qubit code erasure channel first codeword span 0 assume erasure occurs fourth qubit applying channel isometry state becomes span reduced state accessible decoder span decoder map preserves even parity vectors map span span reduced state mapped span 0 0 original state missing decoder operation,"[(1, 0.053734194), (2, 0.055257116), (3, 0.36080948), (4, 0.05408945), (5, 0.19759683), (11, 0.018309893), (17, 0.11198887), (18, 0.14647937)]"
33064,,2023-06-20 16:00:17,1,112,"<p>Considering Bell basis measurement, we have that the ideal POVMs are four Bell states, which can be obtained by reversing the following quantum circuits. Now, we add depolarizing errors to CX gate and H gate. This becomes a noisy Bell basis measurement. So can we derive the <span class=""math-container"">$\textbf{noisy}$</span> POVMs given the the parameters of the depolarizing errors?</p>
<p><a href=""https://i.sstatic.net/Fzng1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Fzng1.png"" alt=""Bell basis measurement: from wiki"" /></a></p>
",Recover the noisy POVMs of Bell basis measurement,<measurement><bell-basis><povm><depolarizing-channel>,1,0,,,"Recover the noisy POVMs of Bell basis measurement <p>Considering Bell basis measurement, we have that the ideal POVMs are four Bell states, which can be obtained by reversing the following quantum circuits. Now, we add depolarizing errors to CX gate and H gate. This becomes a noisy Bell basis measurement. So can we derive the <span class=""math-container"">$\textbf{noisy}$</span> POVMs given the the parameters of the depolarizing errors?</p>
<p><a href=""https://i.sstatic.net/Fzng1.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Fzng1.png"" alt=""Bell basis measurement: from wiki"" /></a></p>
",qc,recover noisy povms bell basis measurement p considering bell basis measurement ideal povms four bell states obtained reversing following quantum circuits add depolarizing errors cx gate h gate becomes noisy bell basis measurement derive span noisy povms given parameters depolarizing errors p https nofollow noreferrer img https bell basis measurement wiki,"[(3, 0.1938182), (4, 0.12785015), (5, 0.07653834), (6, 0.015103828), (9, 0.032619737), (14, 0.17828616), (17, 0.035222538), (18, 0.3382143)]"
33065,,2023-06-20 17:01:40,1,122,"<p>I was reading this <a href=""https://pubs.aip.org/avs/aqs/article-abstract/5/1/013801/2879052/Description-of-reaction-and-vibrational-energetics?redirectedFrom=fulltext"" rel=""nofollow noreferrer"">article</a>. In this article, they calculated the vibrational energy of CO2 and NH3 molecules using VQE, and I checked qiskit documentation for finding Vibrational energy using qiskit. Their code is not working.Anyone can help me how to get vibrational energy using Qiskits's VQE? I have attached the script along with the error. I got the logfile using gaussian software.</p>
<pre><code>driver = GaussianForcesDriver(logfile=&quot;CO2-FREQ.LOG&quot;)
basis = HarmonicBasis([2, 2, 2, 2])
vibrational_problem = driver.run(basis=basis)
vibrational_problem.hamiltonian.truncation_order = 2
main_op, aux_ops = vibrational_problem.second_q_ops()
print(main_op)
</code></pre>
<hr />
<pre><code>ValueError                                Traceback (most recent call last)
Cell In[19], line 3
      1 driver = GaussianForcesDriver(logfile=&quot;CO2-FREQ.LOG&quot;)
      2 basis = HarmonicBasis([2, 2, 2, 2])
----&gt; 3 vibrational_problem = driver.run(basis=basis)
      4 vibrational_problem.hamiltonian.truncation_order = 2
      5 main_op, aux_ops = vibrational_problem.second_q_ops()

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py:153, in GaussianForcesDriver.run(self, basis)
    150 else:
    151     glr = GaussianLogDriver(jcf=self._jcf).run()
--&gt; 153 watson = glr.get_watson_hamiltonian(normalize=self._normalize)
    155 problem = watson_to_problem(watson, basis=basis)
    156 return problem

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py:287, in GaussianLogResult.get_watson_hamiltonian(self, normalize)
    280     watson = WatsonHamiltonian(
    281         as_coo(quadratic_data, shape=(max_index,) * 2),
    282         as_coo(cubic_data, shape=(max_index,) * 3),
    283         as_coo(quartic_data, shape=(max_index,) * 4),
    284         -as_coo(quadratic_data, shape=(max_index,) * 2),
    285     )
    286 else:
--&gt; 287     quadratic_numpy = np.zeros((max_index,) * 2)
    288     for coord, value in quadratic_data.items():
    289         quadratic_numpy[coord] = value

ValueError: negative dimensions are not allowed
</code></pre>
",VQE for Vibrational ground state energy,<qiskit><vqe>,0,1,,,"VQE for Vibrational ground state energy <p>I was reading this <a href=""https://pubs.aip.org/avs/aqs/article-abstract/5/1/013801/2879052/Description-of-reaction-and-vibrational-energetics?redirectedFrom=fulltext"" rel=""nofollow noreferrer"">article</a>. In this article, they calculated the vibrational energy of CO2 and NH3 molecules using VQE, and I checked qiskit documentation for finding Vibrational energy using qiskit. Their code is not working.Anyone can help me how to get vibrational energy using Qiskits's VQE? I have attached the script along with the error. I got the logfile using gaussian software.</p>
<pre><code>driver = GaussianForcesDriver(logfile=&quot;CO2-FREQ.LOG&quot;)
basis = HarmonicBasis([2, 2, 2, 2])
vibrational_problem = driver.run(basis=basis)
vibrational_problem.hamiltonian.truncation_order = 2
main_op, aux_ops = vibrational_problem.second_q_ops()
print(main_op)
</code></pre>
<hr />
<pre><code>ValueError                                Traceback (most recent call last)
Cell In[19], line 3
      1 driver = GaussianForcesDriver(logfile=&quot;CO2-FREQ.LOG&quot;)
      2 basis = HarmonicBasis([2, 2, 2, 2])
----&gt; 3 vibrational_problem = driver.run(basis=basis)
      4 vibrational_problem.hamiltonian.truncation_order = 2
      5 main_op, aux_ops = vibrational_problem.second_q_ops()

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py:153, in GaussianForcesDriver.run(self, basis)
    150 else:
    151     glr = GaussianLogDriver(jcf=self._jcf).run()
--&gt; 153 watson = glr.get_watson_hamiltonian(normalize=self._normalize)
    155 problem = watson_to_problem(watson, basis=basis)
    156 return problem

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py:287, in GaussianLogResult.get_watson_hamiltonian(self, normalize)
    280     watson = WatsonHamiltonian(
    281         as_coo(quadratic_data, shape=(max_index,) * 2),
    282         as_coo(cubic_data, shape=(max_index,) * 3),
    283         as_coo(quartic_data, shape=(max_index,) * 4),
    284         -as_coo(quadratic_data, shape=(max_index,) * 2),
    285     )
    286 else:
--&gt; 287     quadratic_numpy = np.zeros((max_index,) * 2)
    288     for coord, value in quadratic_data.items():
    289         quadratic_numpy[coord] = value

ValueError: negative dimensions are not allowed
</code></pre>
",qc,vqe vibrational ground state energy p reading https nofollow noreferrer article article calculated vibrational energy co2 nh3 molecules using vqe checked qiskit documentation finding vibrational energy using qiskit code help get vibrational energy using qiskits vqe attached script along error got logfile using gaussian pre code driver gaussianforcesdriver quot quot basis harmonicbasis 2 2 2 2 2 print hr pre code valueerror traceback recent call last cell 19 line 3 1 driver gaussianforcesdriver quot quot 2 basis harmonicbasis 2 2 2 2 gt 3 4 2 5 file self basis 150 else 151 glr gaussianlogdriver gt 153 watson 155 problem watson 156 return problem file self normalize 280 watson watsonhamiltonian 281 2 282 3 283 4 284 2 285 286 else gt 287 2 288 coord value 289 coord value valueerror negative dimensions allowed,"[(0, 0.47649068), (2, 0.09836399), (4, 0.031204037), (6, 0.13394539), (13, 0.0660642), (17, 0.13523966), (19, 0.05751171)]"
33068,33079.0,2023-06-20 19:19:55,0,102,"<p>Is there a gate that can perform the matrix exponential operation</p>
<p><span class=""math-container"">$$e^{iA}|\Psi\rangle$$</span></p>
<p>in IBM quantum experience API?</p>
<p><a href=""https://i.sstatic.net/2nl09.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2nl09.png"" alt=""enter image description here"" /></a></p>
<p>What is the name and symbol for this type of gate (or some other gates that can perform operations like the matrix exponential)?</p>
<hr />
<p>I need a 2nd opinion that can confirm whether or not</p>
<p><span class=""math-container"">$$ e^{i\begin{bmatrix} 8 &amp; 6+i \\ 6-i &amp; -1\end{bmatrix}} = \begin{bmatrix} -0.06558 -0.63357i &amp; 0.38542 -0.66763i \\ 0.14805  -0.75654i &amp; -0.46568 + 0.43456i \end{bmatrix}$$</span></p>
<p>is correct?</p>
",Is there a matrix exponential $e^{iA}$ gate in IBM Quantum Experience?,<ibm-q-experience><gate-synthesis>,2,6,,,"Is there a matrix exponential $e^{iA}$ gate in IBM Quantum Experience? <p>Is there a gate that can perform the matrix exponential operation</p>
<p><span class=""math-container"">$$e^{iA}|\Psi\rangle$$</span></p>
<p>in IBM quantum experience API?</p>
<p><a href=""https://i.sstatic.net/2nl09.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/2nl09.png"" alt=""enter image description here"" /></a></p>
<p>What is the name and symbol for this type of gate (or some other gates that can perform operations like the matrix exponential)?</p>
<hr />
<p>I need a 2nd opinion that can confirm whether or not</p>
<p><span class=""math-container"">$$ e^{i\begin{bmatrix} 8 &amp; 6+i \\ 6-i &amp; -1\end{bmatrix}} = \begin{bmatrix} -0.06558 -0.63357i &amp; 0.38542 -0.66763i \\ 0.14805  -0.75654i &amp; -0.46568 + 0.43456i \end{bmatrix}$$</span></p>
<p>is correct?</p>
",qc,matrix exponential ia gate ibm quantum experience p gate perform matrix exponential operation p span ia p ibm quantum experience api p https nofollow noreferrer img https enter image description p name symbol type gate gates perform operations like matrix exponential hr p need 2nd opinion confirm whether p span bmatrix 8 amp amp bmatrix bmatrix amp amp bmatrix p correct,"[(4, 0.26131353), (7, 0.21901514), (9, 0.09531464), (11, 0.025127096), (15, 0.2424893), (16, 0.035397604), (17, 0.017265182), (18, 0.10211617)]"
33122,33157.0,2023-06-23 16:05:02,2,566,"<p>I'm currently working with the continuity result by <a href=""https://doi.org/10.1109/TIT.2008.917696"" rel=""nofollow noreferrer"">Kretschmann-Schlingemann-Werner</a> (<a href=""https://arxiv.org/abs/quant-ph/0605009"" rel=""nofollow noreferrer"">arXiv version</a>) for Stinespring isometries (more precisely, the following corollary to their result, cf. Appendix C in <a href=""https://arxiv.org/abs/2306.03667"" rel=""nofollow noreferrer"">this paper</a>):</p>
<blockquote>
<p>Given channels <span class=""math-container"">$\Phi_1,\Phi_2\in\mathcal L(\mathbb C^{d\times d})$</span> with respective Kraus rank <span class=""math-container"">$r_1,r_2$</span>, as well as any <span class=""math-container"">$m\in\mathbb N$</span> with <span class=""math-container"">$m\geq2\max\{r_1,r_2\}$</span>, for all Stinespring isometries <span class=""math-container"">$V_1,V_2:\mathbb C^d\to\mathbb C^d\otimes\mathbb C^m$</span> of <span class=""math-container"">$\Phi_1,\Phi_2$</span> there exists <span class=""math-container"">$U \in\mathsf U(m)$</span> such
that
<span class=""math-container"">$$
\|V_1-({\bf 1}\otimes U)V_2\|_\infty\leq \sqrt{\|\Phi_1-\Phi_2\|_\diamond}\,.
$$</span></p>
</blockquote>
<p>I was interested in how good this bound is in general, which is why I got interested in finding examples of channels where <span class=""math-container"">$\|\Phi_1-\Phi_2\|_\diamond$</span> is known. However, the only literature I know of in this direction are:</p>
<ul>
<li><a href=""https://doi.org/10.26421/QIC9.1-2-2"" rel=""nofollow noreferrer"">the paper of Johnston et al.</a> (<a href=""https://arxiv.org/abs/0711.3636"" rel=""nofollow noreferrer"">arXiv version</a>) on the (diamond norm-)distance between unitary channels.</li>
<li><a href=""https://doi.org/10.1063/1.5019322"" rel=""nofollow noreferrer"">the paper of Nechita et al.</a> (<a href=""https://arxiv.org/abs/1612.00401"" rel=""nofollow noreferrer"">arXiv version</a>) on the distance between random channels.
Therein they give an upper bound on the diamond norm in terms of the
partial trace of the absolute value of the Choi-Jamiołkowski matrix, and they even characterize when this bound is saturated.
Moreover, they study the distance between random channels and the maximally depolarizing channel <span class=""math-container"">$X\mapsto{\rm tr}(X)d^{-1}{\bf 1}_d$</span>—as well as distances involving random unitary channels—in the asymptotic limit <span class=""math-container"">$d\to\infty$</span>.</li>
<li>more general results on <em>bounding</em> the diamond norm, e.g., the inequality <span class=""math-container"">$\|\Phi-{\rm id}\|_\diamond\leq 2\sqrt{\|\Phi-{\rm id}\|_{1\to 1}}$</span> between diamond norm and the operator norm induced by the trace norm from <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/"" rel=""nofollow noreferrer"">Watrous's book</a>.</li>
</ul>
<p>From these, the only analytic result on channel distances seems to be Theorem 12 in the Johnston paper which states that <span class=""math-container"">$\|{\rm id}-U(\cdot)U^*\|_\diamond$</span> is equal to &quot;the diameter of the smallest closed disc that contains all of the eigenvalues of <span class=""math-container"">$U$</span>&quot;.</p>
<p>Beyond that I proved the following distance results myself (but I am not yet aware of any paper or book that features them):</p>
<blockquote>
<p>Let <span class=""math-container"">$\Phi_d$</span> denote the dephasing channel (i.e. <span class=""math-container"">$\Phi_d$</span> sets all off-diagonal elements of the input to zero)
and let <span class=""math-container"">$\Phi_{\bf 1}:X\mapsto{\rm tr}(X)d^{-1}{\bf 1}$</span> denote the depolarization channel in dimension <span class=""math-container"">$d$</span>. Then
<span class=""math-container"">$$\|{\rm id}-\Phi_{\bf 1}\|_{1\to 1}=\|{\rm id}-\Phi_d\|_{1\to 1}=\|{\rm id}-\Phi_d\|_\diamond=2-\frac2d\leq2-\frac2{d^2}=\|{\rm id}-\Phi_{\bf 1}\|_\diamond \,.$$</span></p>
</blockquote>
<p>Now my question is twofold:</p>
<blockquote>
<ol>
<li>Are these distance results regarding dephasing and depolarization known, and if so, in what paper/book can I find them?</li>
<li>Beyond what I listed above, are there any resources which contain distance results of this type (i.e. analytic expressions for <span class=""math-container"">$\|{\rm id}-\Phi\|_\diamond$</span> for specific channels <span class=""math-container"">$\Phi$</span>)? For example, a generalization of the depolarization-result would be to consider arbitrary reset channels <span class=""math-container"">$\Phi_\rho:X\mapsto {\rm tr}(X)\rho$</span> (with <span class=""math-container"">$\rho$</span> some state). While numerics suggest a closed-form expression of <span class=""math-container"">$\|{\rm id}-\Phi_\rho\|_\diamond$</span>, my proof of the depolarization result breaks down when replacing <span class=""math-container"">${\bf 1}/d$</span> by an arbitrary state.</li>
</ol>
</blockquote>
",Diamond norm distances between some channel and the identity,<quantum-operation><resource-request><depolarizing-channel><diamond-norm>,1,1,,,"Diamond norm distances between some channel and the identity <p>I'm currently working with the continuity result by <a href=""https://doi.org/10.1109/TIT.2008.917696"" rel=""nofollow noreferrer"">Kretschmann-Schlingemann-Werner</a> (<a href=""https://arxiv.org/abs/quant-ph/0605009"" rel=""nofollow noreferrer"">arXiv version</a>) for Stinespring isometries (more precisely, the following corollary to their result, cf. Appendix C in <a href=""https://arxiv.org/abs/2306.03667"" rel=""nofollow noreferrer"">this paper</a>):</p>
<blockquote>
<p>Given channels <span class=""math-container"">$\Phi_1,\Phi_2\in\mathcal L(\mathbb C^{d\times d})$</span> with respective Kraus rank <span class=""math-container"">$r_1,r_2$</span>, as well as any <span class=""math-container"">$m\in\mathbb N$</span> with <span class=""math-container"">$m\geq2\max\{r_1,r_2\}$</span>, for all Stinespring isometries <span class=""math-container"">$V_1,V_2:\mathbb C^d\to\mathbb C^d\otimes\mathbb C^m$</span> of <span class=""math-container"">$\Phi_1,\Phi_2$</span> there exists <span class=""math-container"">$U \in\mathsf U(m)$</span> such
that
<span class=""math-container"">$$
\|V_1-({\bf 1}\otimes U)V_2\|_\infty\leq \sqrt{\|\Phi_1-\Phi_2\|_\diamond}\,.
$$</span></p>
</blockquote>
<p>I was interested in how good this bound is in general, which is why I got interested in finding examples of channels where <span class=""math-container"">$\|\Phi_1-\Phi_2\|_\diamond$</span> is known. However, the only literature I know of in this direction are:</p>
<ul>
<li><a href=""https://doi.org/10.26421/QIC9.1-2-2"" rel=""nofollow noreferrer"">the paper of Johnston et al.</a> (<a href=""https://arxiv.org/abs/0711.3636"" rel=""nofollow noreferrer"">arXiv version</a>) on the (diamond norm-)distance between unitary channels.</li>
<li><a href=""https://doi.org/10.1063/1.5019322"" rel=""nofollow noreferrer"">the paper of Nechita et al.</a> (<a href=""https://arxiv.org/abs/1612.00401"" rel=""nofollow noreferrer"">arXiv version</a>) on the distance between random channels.
Therein they give an upper bound on the diamond norm in terms of the
partial trace of the absolute value of the Choi-Jamiołkowski matrix, and they even characterize when this bound is saturated.
Moreover, they study the distance between random channels and the maximally depolarizing channel <span class=""math-container"">$X\mapsto{\rm tr}(X)d^{-1}{\bf 1}_d$</span>—as well as distances involving random unitary channels—in the asymptotic limit <span class=""math-container"">$d\to\infty$</span>.</li>
<li>more general results on <em>bounding</em> the diamond norm, e.g., the inequality <span class=""math-container"">$\|\Phi-{\rm id}\|_\diamond\leq 2\sqrt{\|\Phi-{\rm id}\|_{1\to 1}}$</span> between diamond norm and the operator norm induced by the trace norm from <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/"" rel=""nofollow noreferrer"">Watrous's book</a>.</li>
</ul>
<p>From these, the only analytic result on channel distances seems to be Theorem 12 in the Johnston paper which states that <span class=""math-container"">$\|{\rm id}-U(\cdot)U^*\|_\diamond$</span> is equal to &quot;the diameter of the smallest closed disc that contains all of the eigenvalues of <span class=""math-container"">$U$</span>&quot;.</p>
<p>Beyond that I proved the following distance results myself (but I am not yet aware of any paper or book that features them):</p>
<blockquote>
<p>Let <span class=""math-container"">$\Phi_d$</span> denote the dephasing channel (i.e. <span class=""math-container"">$\Phi_d$</span> sets all off-diagonal elements of the input to zero)
and let <span class=""math-container"">$\Phi_{\bf 1}:X\mapsto{\rm tr}(X)d^{-1}{\bf 1}$</span> denote the depolarization channel in dimension <span class=""math-container"">$d$</span>. Then
<span class=""math-container"">$$\|{\rm id}-\Phi_{\bf 1}\|_{1\to 1}=\|{\rm id}-\Phi_d\|_{1\to 1}=\|{\rm id}-\Phi_d\|_\diamond=2-\frac2d\leq2-\frac2{d^2}=\|{\rm id}-\Phi_{\bf 1}\|_\diamond \,.$$</span></p>
</blockquote>
<p>Now my question is twofold:</p>
<blockquote>
<ol>
<li>Are these distance results regarding dephasing and depolarization known, and if so, in what paper/book can I find them?</li>
<li>Beyond what I listed above, are there any resources which contain distance results of this type (i.e. analytic expressions for <span class=""math-container"">$\|{\rm id}-\Phi\|_\diamond$</span> for specific channels <span class=""math-container"">$\Phi$</span>)? For example, a generalization of the depolarization-result would be to consider arbitrary reset channels <span class=""math-container"">$\Phi_\rho:X\mapsto {\rm tr}(X)\rho$</span> (with <span class=""math-container"">$\rho$</span> some state). While numerics suggest a closed-form expression of <span class=""math-container"">$\|{\rm id}-\Phi_\rho\|_\diamond$</span>, my proof of the depolarization result breaks down when replacing <span class=""math-container"">${\bf 1}/d$</span> by an arbitrary state.</li>
</ol>
</blockquote>
",qc,diamond norm distances channel identity p currently working continuity result https nofollow noreferrer https nofollow noreferrer arxiv version stinespring isometries precisely following corollary result cf appendix c https nofollow noreferrer paper blockquote p given channels span l respective kraus rank span well span n span stinespring isometries span span exists span u u span 1 u p interested good bound general got interested finding examples channels span known however literature know direction ul li https nofollow noreferrer paper johnston et https nofollow noreferrer arxiv version diamond distance unitary li https nofollow noreferrer paper nechita et https nofollow noreferrer arxiv version distance random channels therein give upper bound diamond norm terms partial trace absolute value matrix even characterize bound saturated moreover study distance random channels maximally depolarizing channel span tr x 1 well distances involving random unitary asymptotic limit span li general results em bounding diamond norm inequality span id id 1 diamond norm operator norm induced trace norm https nofollow noreferrer watrous book p analytic result channel distances seems theorem 12 johnston paper states span id equal quot diameter smallest closed disc contains eigenvalues span u quot p beyond proved following distance results yet aware paper book features blockquote p let span denote dephasing channel span sets elements input zero let span 1 tr x 1 denote depolarization channel dimension span span id 1 1 id 1 id id 1 p question twofold blockquote ol li distance results regarding dephasing depolarization known find li beyond listed resources contain distance results type analytic expressions span id specific channels span example generalization would consider arbitrary reset channels span tr x span state numerics suggest expression span id proof depolarization result breaks replacing span 1 arbitrary,"[(3, 0.61169577), (4, 0.093613386), (6, 0.011577153), (7, 0.08464032), (9, 0.07275735), (10, 0.013779333), (17, 0.08462295)]"
33142,,2023-06-24 18:15:43,1,163,"<p>This is taken from Page 434 of Nielsen and Chuang:</p>
<blockquote>
<p>To simplify the analysis, suppose noise of an arbitrary type is occurring on the first
qubit only; we’ll come back to what happens when noise is affecting other qubits as well.<br />
Following Chapter 8 we describe the noise by a trace-preserving quantum operation E.
It is most convenient to analyze error-correction by expanding E in an operator-sum
representation with operation elements {Ei}.<br />
Supposing the state of the encoded qubit
is |ψ⟩ = α|0L⟩ + β|1L⟩.<br />
To analyze the effects of error-correction it’s easiest to
focus on the effect error-correction has on a single term in this sum, say Ei|ψ⟩⟨ψ|E†
i .<br />
As an operator on the first qubit alone Ei may be expanded as a linear combination of
the identity, I, the bit flip, X1, the phase flip, Z1, and the combined bit and phase flip,
X1Z1:
Ei = ei0I + ei1X1 + ei2Z1 + ei3X1Z1 .
(10.14)<br />
The (un-normalized) quantum state Ei|ψ⟩ can thus be written as a superposition of four
terms, |ψ⟩, X1|ψ⟩, Z1|ψ⟩, X1Z1|ψ⟩. Measuring the error syndrome collapses this super-
position into one of the four states |ψ⟩, X1|ψ⟩, Z1|ψ⟩ or X1Z1|ψ⟩ from which recovery
may then be performed by applying the appropriate inversion operation, resulting in the
final state |ψ⟩. The same is true for all the other operation elements Ei. Thus, error-
correction results in the original state |ψ⟩ being recovered, despite the fact that the error
on the first qubit was arbitrary.</p>
</blockquote>
<p>From my understanding, <span class=""math-container"">$H= \frac{1}{\sqrt{2}}(X+Z)$</span>
So if the error's operation is identical to that of the H-gate acting on the qubit, does this mean that on measurement of the error syndrome we have a 50% chance of measuring that the X gate has acted and a 50% chance of measuring that the Z gate has acted?<br />
If yes, doesn't this assume that we will have to pass the same input numerous times until we reach some level of confidence in our obtained probability distribution of <span class=""math-container"">$I,X,Z,XZ$</span> having acted?<br />
How would this work if we could send the bit only once?</p>
",Why can Shor code fix arbitrary errors?,<quantum-algorithms><error-correction><measurement><nielsen-and-chuang>,0,7,,,"Why can Shor code fix arbitrary errors? <p>This is taken from Page 434 of Nielsen and Chuang:</p>
<blockquote>
<p>To simplify the analysis, suppose noise of an arbitrary type is occurring on the first
qubit only; we’ll come back to what happens when noise is affecting other qubits as well.<br />
Following Chapter 8 we describe the noise by a trace-preserving quantum operation E.
It is most convenient to analyze error-correction by expanding E in an operator-sum
representation with operation elements {Ei}.<br />
Supposing the state of the encoded qubit
is |ψ⟩ = α|0L⟩ + β|1L⟩.<br />
To analyze the effects of error-correction it’s easiest to
focus on the effect error-correction has on a single term in this sum, say Ei|ψ⟩⟨ψ|E†
i .<br />
As an operator on the first qubit alone Ei may be expanded as a linear combination of
the identity, I, the bit flip, X1, the phase flip, Z1, and the combined bit and phase flip,
X1Z1:
Ei = ei0I + ei1X1 + ei2Z1 + ei3X1Z1 .
(10.14)<br />
The (un-normalized) quantum state Ei|ψ⟩ can thus be written as a superposition of four
terms, |ψ⟩, X1|ψ⟩, Z1|ψ⟩, X1Z1|ψ⟩. Measuring the error syndrome collapses this super-
position into one of the four states |ψ⟩, X1|ψ⟩, Z1|ψ⟩ or X1Z1|ψ⟩ from which recovery
may then be performed by applying the appropriate inversion operation, resulting in the
final state |ψ⟩. The same is true for all the other operation elements Ei. Thus, error-
correction results in the original state |ψ⟩ being recovered, despite the fact that the error
on the first qubit was arbitrary.</p>
</blockquote>
<p>From my understanding, <span class=""math-container"">$H= \frac{1}{\sqrt{2}}(X+Z)$</span>
So if the error's operation is identical to that of the H-gate acting on the qubit, does this mean that on measurement of the error syndrome we have a 50% chance of measuring that the X gate has acted and a 50% chance of measuring that the Z gate has acted?<br />
If yes, doesn't this assume that we will have to pass the same input numerous times until we reach some level of confidence in our obtained probability distribution of <span class=""math-container"">$I,X,Z,XZ$</span> having acted?<br />
How would this work if we could send the bit only once?</p>
",qc,shor code fix arbitrary errors p taken page 434 nielsen chuang blockquote p simplify analysis suppose noise arbitrary type occurring first qubit come back happens noise affecting qubits br following chapter 8 describe noise quantum operation convenient analyze expanding e representation operation elements ei br supposing state encoded qubit br analyze effects easiest focus effect single term sum say br operator first qubit alone ei may expanded linear combination identity bit flip x1 phase flip z1 combined bit phase flip x1z1 ei ei0i ei1x1 ei2z1 ei3x1z1 br quantum state thus written superposition four terms measuring error syndrome collapses position one four states recovery may performed applying appropriate inversion operation resulting final state true operation elements ei thus correction results original state recovered despite fact error first qubit p understanding span 1 2 error operation identical acting qubit mean measurement error syndrome 50 chance measuring x gate acted 50 chance measuring z gate acted br yes assume pass input numerous times reach level confidence obtained probability distribution span x z xz acted br would work could send bit,"[(3, 0.2456704), (5, 0.16100994), (8, 0.044769183), (10, 0.017302513), (13, 0.11796426), (17, 0.027181724), (18, 0.36765736), (19, 0.01773008)]"
33146,,2023-06-25 13:31:11,1,57,"<p>Currently, I’m studying these two papers:</p>
<p><a href=""https://arxiv.org/abs/1404.5320"" rel=""nofollow noreferrer"">“Efficient Synthesis of Universal Repeat-Until-Success Circuits”</a> and
<a href=""https://arxiv.org/abs/1409.3552"" rel=""nofollow noreferrer"">“Efficient synthesis of probabilistic quantum circuits with fallback”</a>.</p>
<p>I want the source code of these two papers to reimplement their experiments, but I can’t find the source in anywhere. Is there any method to get the source code?</p>
<p>Besides, on the website
<a href=""https://learn.microsoft.com/en-us/samples/microsoft/quantum/repeat-until-success/"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/samples/microsoft/quantum/repeat-until-success/</a>
They say the quantum programming language “Q#” provides the ”Repeat until success” function. Can this function transfer the arbitrary single qubit gate into a sequence of Clifford+T gates? Is the implementation of the function followed by the paper “Efficient Synthesis of Universal Repeat-Until-Success Circuits”?
Thanks for answering my question !!!!!</p>
",How can I get the source code of “RUS” and “PQF”,<q#><clifford-group>,1,0,,,"How can I get the source code of “RUS” and “PQF” <p>Currently, I’m studying these two papers:</p>
<p><a href=""https://arxiv.org/abs/1404.5320"" rel=""nofollow noreferrer"">“Efficient Synthesis of Universal Repeat-Until-Success Circuits”</a> and
<a href=""https://arxiv.org/abs/1409.3552"" rel=""nofollow noreferrer"">“Efficient synthesis of probabilistic quantum circuits with fallback”</a>.</p>
<p>I want the source code of these two papers to reimplement their experiments, but I can’t find the source in anywhere. Is there any method to get the source code?</p>
<p>Besides, on the website
<a href=""https://learn.microsoft.com/en-us/samples/microsoft/quantum/repeat-until-success/"" rel=""nofollow noreferrer"">https://learn.microsoft.com/en-us/samples/microsoft/quantum/repeat-until-success/</a>
They say the quantum programming language “Q#” provides the ”Repeat until success” function. Can this function transfer the arbitrary single qubit gate into a sequence of Clifford+T gates? Is the implementation of the function followed by the paper “Efficient Synthesis of Universal Repeat-Until-Success Circuits”?
Thanks for answering my question !!!!!</p>
",qc,get source code rus pqf p currently studying two papers p https nofollow noreferrer efficient synthesis universal circuits https nofollow noreferrer efficient synthesis probabilistic quantum circuits fallback p want source code two papers reimplement experiments find source anywhere method get source code p besides website https nofollow noreferrer https say quantum programming language q provides repeat success function function transfer arbitrary single qubit gate sequence gates implementation function followed paper efficient synthesis universal circuits thanks answering question,"[(4, 0.16590558), (8, 0.14427017), (9, 0.3756588), (10, 0.027249586), (11, 0.0153041035), (14, 0.25731722), (17, 0.0125396885)]"
33195,,2023-06-28 08:13:07,2,76,"<p>My question is a bit on the soft side, and basically asks if there is something between error mitigation and full error correction?</p>
<p>On the one hand, as far as I understand, trying to increase the quantum volume by error mitigation hits a wall based on the decoherence rates and gate errors. For instance, the recent 127-qubit simulation on IBM's chip was limited by what error mitigation can do. Adding more qubits wouldn't really help, because it was really the depth that was a key limitation.</p>
<p>On the other hand, having enough noisy qubits can get you to the full error correction, but the overhead is typically orders of magnitude.</p>
<p>Is there something in between? For example, by using codes with small distances, can we trade a dozen of physical qubits for a single composite one, which is still error-prone but less so than the original? Then we could expect a 1000-qubit chip to do things that a 100-qubit one could not. The way of packaging qubits need not even be an error-correcting code (e.g. it doesn't have to eliminate all errors up to a certain weight) but could be something like an error-suppression code, defined simply by the fact that a composite qubit is better than any individual one.</p>
<p>If these things have already been discussed somewhere, I'm happy to take references.</p>
",Is there something like error-suppression codes?,<quantum-algorithms><error-correction><decoherence><error-mitigation><quantum-volume>,1,0,,,"Is there something like error-suppression codes? <p>My question is a bit on the soft side, and basically asks if there is something between error mitigation and full error correction?</p>
<p>On the one hand, as far as I understand, trying to increase the quantum volume by error mitigation hits a wall based on the decoherence rates and gate errors. For instance, the recent 127-qubit simulation on IBM's chip was limited by what error mitigation can do. Adding more qubits wouldn't really help, because it was really the depth that was a key limitation.</p>
<p>On the other hand, having enough noisy qubits can get you to the full error correction, but the overhead is typically orders of magnitude.</p>
<p>Is there something in between? For example, by using codes with small distances, can we trade a dozen of physical qubits for a single composite one, which is still error-prone but less so than the original? Then we could expect a 1000-qubit chip to do things that a 100-qubit one could not. The way of packaging qubits need not even be an error-correcting code (e.g. it doesn't have to eliminate all errors up to a certain weight) but could be something like an error-suppression code, defined simply by the fact that a composite qubit is better than any individual one.</p>
<p>If these things have already been discussed somewhere, I'm happy to take references.</p>
",qc,something like codes p question bit soft side basically asks something error mitigation full error correction p one hand far understand trying increase quantum volume error mitigation hits wall based decoherence rates gate errors instance recent simulation ibm chip limited error mitigation adding qubits would really help really depth key p hand enough noisy qubits get full error correction overhead typically orders p something example using codes small distances trade dozen physical qubits single composite one still less original could expect chip things one could way packaging qubits need even code eliminate errors certain weight could something like code defined simply fact composite qubit better individual p things already discussed somewhere happy take,"[(4, 0.011350915), (5, 0.25101006), (8, 0.25283355), (9, 0.100505255), (14, 0.36316577), (17, 0.011531751)]"
33208,,2023-06-28 20:40:00,0,116,"<p>In the code below, I am using VQE without noise to calculate the minimum expectation value of the two-qubit operator X^X. I get the correct result when I use statevector_simulator but do not get the correct result most of the time with qasm_simulator. Please help me understand why that is the case.</p>
<pre><code>import numpy as np
import pylab

from qiskit import Aer
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.opflow import I, X, Y, Z
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter

ansatz = QuantumCircuit(2)
ansatz.x(0)
α = Parameter(f'α0')
ansatz.ry(-2.0*α, 1)
ansatz.cx(1, 0)

op = 1.0 * (X^X)
npme = NumPyMinimumEigensolver()
result = npme.compute_minimum_eigenvalue(operator=op)
ref_value = result.eigenvalue.real
print(f'Reference value: {ref_value:.5f}')


counts = []
values = []


def store_intermediate_result(eval_count, parameters, mean, std):
    counts.append(eval_count)
    values.append(mean)
    
backend = Aer.get_backend(&quot;qasm_simulator&quot;)

statevector_simulator = Aer.get_backend(&quot;statevector_simulator&quot;)
qasm_simulator = Aer.get_backend(&quot;qasm_simulator&quot;)

vqe = VQE(ansatz=ansatz, callback=store_intermediate_result, quantum_instance=qasm_simulator)
result = vqe.compute_minimum_eigenvalue(operator=op)

print(f&quot;VQE on Aer qasm simulator (no noise): {result.eigenvalue.real:.5f}&quot;)
print(
    f&quot;Delta from reference energy value is {(result.eigenvalue.real - ref_value):.5f}&quot;
)

pylab.rcParams[&quot;figure.figsize&quot;] = (12, 4)
pylab.plot(counts, values)
pylab.xlabel(&quot;Eval count&quot;)
pylab.ylabel(&quot;Energy&quot;)
pylab.title(&quot;Convergence with no noise&quot;)&lt;/code&gt;
</code></pre>
<p><a href=""https://i.sstatic.net/hVJyW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hVJyW.png"" alt=""enter image description here"" /></a></p>
",Why is Qiskit's QASM simulator giving me incorrect result with VQE?,<simulation><qiskit>,1,0,,,"Why is Qiskit's QASM simulator giving me incorrect result with VQE? <p>In the code below, I am using VQE without noise to calculate the minimum expectation value of the two-qubit operator X^X. I get the correct result when I use statevector_simulator but do not get the correct result most of the time with qasm_simulator. Please help me understand why that is the case.</p>
<pre><code>import numpy as np
import pylab

from qiskit import Aer
from qiskit.algorithms import VQE, NumPyMinimumEigensolver
from qiskit.opflow import I, X, Y, Z
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter

ansatz = QuantumCircuit(2)
ansatz.x(0)
α = Parameter(f'α0')
ansatz.ry(-2.0*α, 1)
ansatz.cx(1, 0)

op = 1.0 * (X^X)
npme = NumPyMinimumEigensolver()
result = npme.compute_minimum_eigenvalue(operator=op)
ref_value = result.eigenvalue.real
print(f'Reference value: {ref_value:.5f}')


counts = []
values = []


def store_intermediate_result(eval_count, parameters, mean, std):
    counts.append(eval_count)
    values.append(mean)
    
backend = Aer.get_backend(&quot;qasm_simulator&quot;)

statevector_simulator = Aer.get_backend(&quot;statevector_simulator&quot;)
qasm_simulator = Aer.get_backend(&quot;qasm_simulator&quot;)

vqe = VQE(ansatz=ansatz, callback=store_intermediate_result, quantum_instance=qasm_simulator)
result = vqe.compute_minimum_eigenvalue(operator=op)

print(f&quot;VQE on Aer qasm simulator (no noise): {result.eigenvalue.real:.5f}&quot;)
print(
    f&quot;Delta from reference energy value is {(result.eigenvalue.real - ref_value):.5f}&quot;
)

pylab.rcParams[&quot;figure.figsize&quot;] = (12, 4)
pylab.plot(counts, values)
pylab.xlabel(&quot;Eval count&quot;)
pylab.ylabel(&quot;Energy&quot;)
pylab.title(&quot;Convergence with no noise&quot;)&lt;/code&gt;
</code></pre>
<p><a href=""https://i.sstatic.net/hVJyW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hVJyW.png"" alt=""enter image description here"" /></a></p>
",qc,qiskit qasm simulator giving incorrect result vqe p code using vqe without noise calculate minimum expectation value operator get correct result use get correct result time please help understand pre code import numpy np import pylab qiskit import aer import vqe numpyminimumeigensolver import x z qiskit import quantumcircuit import parameter ansatz quantumcircuit 2 0 α parameter α 1 1 0 op npme numpyminimumeigensolver result print value counts values def parameters mean std mean backend quot quot quot quot quot quot vqe vqe result print f quot vqe aer qasm simulator noise quot print f quot delta reference energy value quot quot quot 12 4 counts values quot eval count quot quot energy quot quot convergence noise quot lt gt p https nofollow noreferrer img https enter image description,"[(0, 0.63196135), (2, 0.019841826), (4, 0.10791249), (6, 0.011533286), (17, 0.018149761), (19, 0.19979931)]"
33210,33212.0,2023-06-28 21:42:49,1,352,"<p>I'm looking through section 4 of the <a href=""https://quantum-journal.org/papers/q-2021-07-06-497/pdf/"" rel=""nofollow noreferrer"">Stim Paper</a> and am having trouble understanding two points:</p>
<ol>
<li>Why is it okay to insert Hadamards and random Xs at the beginning of computation and Hadamards? In the case of inserting CNOTs, it's clear that the measurement result will remain unchanged because of the all 0s input. But, inserting H, X (probabilistically) creates an entirely distinct circuit that could affect other observables; it's not obvious to me why the probabilities should stay the same.</li>
<li>Is it a typo in Section 4 to say that measuring <span class=""math-container"">$C Z_q C^{-1}$</span> at the start of time is the same as measuring <span class=""math-container"">$Z_q$</span> at the current time? Because isn't the relation <span class=""math-container"">$Z_q C |\psi \rangle= C Z_q' |\psi \rangle $</span> implies <span class=""math-container"">$Z_q' = C^{-1} Z_q C$</span>?</li>
</ol>
",Intuition behind Stabilizer Tableau Simulation in Stim,<stim>,1,0,,,"Intuition behind Stabilizer Tableau Simulation in Stim <p>I'm looking through section 4 of the <a href=""https://quantum-journal.org/papers/q-2021-07-06-497/pdf/"" rel=""nofollow noreferrer"">Stim Paper</a> and am having trouble understanding two points:</p>
<ol>
<li>Why is it okay to insert Hadamards and random Xs at the beginning of computation and Hadamards? In the case of inserting CNOTs, it's clear that the measurement result will remain unchanged because of the all 0s input. But, inserting H, X (probabilistically) creates an entirely distinct circuit that could affect other observables; it's not obvious to me why the probabilities should stay the same.</li>
<li>Is it a typo in Section 4 to say that measuring <span class=""math-container"">$C Z_q C^{-1}$</span> at the start of time is the same as measuring <span class=""math-container"">$Z_q$</span> at the current time? Because isn't the relation <span class=""math-container"">$Z_q C |\psi \rangle= C Z_q' |\psi \rangle $</span> implies <span class=""math-container"">$Z_q' = C^{-1} Z_q C$</span>?</li>
</ol>
",qc,intuition behind stabilizer tableau simulation stim p looking section 4 https nofollow noreferrer stim paper trouble understanding two points ol li okay insert hadamards random xs beginning computation hadamards case inserting cnots clear measurement result remain unchanged 0s input inserting h x probabilistically creates entirely distinct circuit could affect observables obvious probabilities stay li typo section 4 say measuring span c start time measuring span current time relation span c c implies span c,"[(3, 0.23978297), (5, 0.05716985), (6, 0.02689433), (8, 0.037313685), (9, 0.31969365), (10, 0.0133458385), (14, 0.2227302), (17, 0.024647927), (18, 0.05693754)]"
33217,,2023-06-29 12:18:31,1,129,"<p>I have a quantum circuit as the following picture. Now I add the depolarizing error on the Hadamard gate using the following code in <strong>Qiskit</strong>.</p>
<pre><code>prob_1 = 0.5
error_1 = noise.depolarizing_error(prob_1, 1)
noise_model = noise.NoiseModel()
noise_model.add_quantum_error(error_1, ['h'], [0])
</code></pre>
<p>The problem is that if I add depolarizing error on X gate instead on the same circuit, the output of the circuit is still noisy.</p>
<p><code>noise_model.add_quantum_error(error_1, ['x'], [0])</code></p>
<p>This makes me confused because I only have a Hadamard gate in the circuit. Why the output is noisy after I put the depolarizing error on X gate?</p>
<p>I am also confused about where the depolarizing error is added, before or after the Hadamard gate? I test both of these cases theoretically, but the results are not consistent with the outputs.</p>
<p><a href=""https://i.sstatic.net/KgK0L.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KgK0L.png"" alt=""enter image description here"" /></a></p>
",What does adding depolarizing error on a Hadamard gate mean mathematically?,<noise><depolarizing-channel><qiskit>,0,1,,,"What does adding depolarizing error on a Hadamard gate mean mathematically? <p>I have a quantum circuit as the following picture. Now I add the depolarizing error on the Hadamard gate using the following code in <strong>Qiskit</strong>.</p>
<pre><code>prob_1 = 0.5
error_1 = noise.depolarizing_error(prob_1, 1)
noise_model = noise.NoiseModel()
noise_model.add_quantum_error(error_1, ['h'], [0])
</code></pre>
<p>The problem is that if I add depolarizing error on X gate instead on the same circuit, the output of the circuit is still noisy.</p>
<p><code>noise_model.add_quantum_error(error_1, ['x'], [0])</code></p>
<p>This makes me confused because I only have a Hadamard gate in the circuit. Why the output is noisy after I put the depolarizing error on X gate?</p>
<p>I am also confused about where the depolarizing error is added, before or after the Hadamard gate? I test both of these cases theoretically, but the results are not consistent with the outputs.</p>
<p><a href=""https://i.sstatic.net/KgK0L.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/KgK0L.png"" alt=""enter image description here"" /></a></p>
",qc,adding depolarizing error hadamard gate mean mathematically p quantum circuit following picture add depolarizing error hadamard gate using following code strong qiskit pre code 1 h 0 p problem add depolarizing error x gate instead circuit output circuit still p code x 0 p makes confused hadamard gate circuit output noisy put depolarizing error x gate p also confused depolarizing error added hadamard gate test cases theoretically results consistent p https nofollow noreferrer img https enter image description,"[(2, 0.045808375), (4, 0.35636473), (5, 0.07832544), (9, 0.063692644), (10, 0.0472478), (13, 0.08063888), (14, 0.25882292), (17, 0.067564376)]"
33247,33257.0,2023-07-01 16:44:41,0,224,"<p>I am playing around with adding noise to quantum circuit simulation using <code>qiskit_aer.noise.NoiseModel()</code>. My code creates a quantum circuit and simulates it with noise, as in this very simple example:</p>
<pre><code>import matplotlib.pyplot as plt
import qiskit
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.tools.visualization import plot_histogram
from qiskit_aer.noise import (NoiseModel, pauli_error, depolarizing_error)

# make circuit
my_qubits = [0];
circ = QuantumCircuit(len(my_qubits));
circ.x(my_qubits);
circ.measure_all();

# simulate with noise
noise_prob = 0.2;
noise_model = NoiseModel();
error = pauli_error([('X', noise_prob), ('I', 1 - noise_prob)])
noise_model.add_quantum_error(error, ['X'], my_qubits);
sim = AerSimulator(noise_model=noise_model);

# transpile and run
circ_trans = transpile(circ, sim);
result = sim.run(circ_trans).result();
counts = result.get_counts(circ_trans)
plot_histogram(counts);
plt.show();
</code></pre>
<p>In this example, the noise is in the bit-flip channel and the effect of the noise can be seen in the qubit measurement histogram.</p>
<p>Now, I would like to make a similar routine with the noise in the depolarizing channel, i.e. call <code>depolarizing_error</code> instead of <code>pauli_error</code>. But when I do this, I can't think of a simple circuit where the measurement histogram is different with noise included than it is without noise. Generally, I think the problem is that as shown in Nielsen &amp; Chuang Fig. 8.11, the depolarizing channel shrinks the qubit along all axes simultaneously, so it doesn't affect the measurement probabilities.</p>
<p>The depolarizing channel does make the state more mixed, so that would be the most obvious way to see its effects. I thought of calculating the purity of the density matrix after it evolves under the noisy circuit, but apparently <code>AerSimulator</code> does not calculate a final state vector.</p>
<p>So, is there a roundabout way to determine the purity of the final state vector using <code>AerSimulator</code>? Alternatively, is there a way that the effects of the depolarizing channel can be revealed in the measurement probabilities alone?</p>
",How to see the effects of the depolarizing channel in qiskit?,<qiskit><error-correction><depolarizing-channel>,1,0,,,"How to see the effects of the depolarizing channel in qiskit? <p>I am playing around with adding noise to quantum circuit simulation using <code>qiskit_aer.noise.NoiseModel()</code>. My code creates a quantum circuit and simulates it with noise, as in this very simple example:</p>
<pre><code>import matplotlib.pyplot as plt
import qiskit
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.tools.visualization import plot_histogram
from qiskit_aer.noise import (NoiseModel, pauli_error, depolarizing_error)

# make circuit
my_qubits = [0];
circ = QuantumCircuit(len(my_qubits));
circ.x(my_qubits);
circ.measure_all();

# simulate with noise
noise_prob = 0.2;
noise_model = NoiseModel();
error = pauli_error([('X', noise_prob), ('I', 1 - noise_prob)])
noise_model.add_quantum_error(error, ['X'], my_qubits);
sim = AerSimulator(noise_model=noise_model);

# transpile and run
circ_trans = transpile(circ, sim);
result = sim.run(circ_trans).result();
counts = result.get_counts(circ_trans)
plot_histogram(counts);
plt.show();
</code></pre>
<p>In this example, the noise is in the bit-flip channel and the effect of the noise can be seen in the qubit measurement histogram.</p>
<p>Now, I would like to make a similar routine with the noise in the depolarizing channel, i.e. call <code>depolarizing_error</code> instead of <code>pauli_error</code>. But when I do this, I can't think of a simple circuit where the measurement histogram is different with noise included than it is without noise. Generally, I think the problem is that as shown in Nielsen &amp; Chuang Fig. 8.11, the depolarizing channel shrinks the qubit along all axes simultaneously, so it doesn't affect the measurement probabilities.</p>
<p>The depolarizing channel does make the state more mixed, so that would be the most obvious way to see its effects. I thought of calculating the purity of the density matrix after it evolves under the noisy circuit, but apparently <code>AerSimulator</code> does not calculate a final state vector.</p>
<p>So, is there a roundabout way to determine the purity of the final state vector using <code>AerSimulator</code>? Alternatively, is there a way that the effects of the depolarizing channel can be revealed in the measurement probabilities alone?</p>
",qc,see effects depolarizing channel qiskit p playing around adding noise quantum circuit simulation using code code creates quantum circuit simulates noise simple example pre code import plt import qiskit qiskit import quantumcircuit transpile import aersimulator import import noisemodel make circuit 0 circ quantumcircuit len simulate noise noisemodel error x 1 error x sim aersimulator transpile run transpile circ sim result counts counts p example noise channel effect noise seen qubit measurement p would like make similar routine noise depolarizing channel call code instead code ca think simple circuit measurement histogram different noise included without noise generally think problem shown nielsen amp chuang fig depolarizing channel shrinks qubit along axes simultaneously affect measurement p depolarizing channel make state mixed would obvious way see effects thought calculating purity density matrix evolves noisy circuit apparently code aersimulator calculate final state p roundabout way determine purity final state vector using code aersimulator alternatively way effects depolarizing channel revealed measurement probabilities alone,"[(0, 0.2428382), (3, 0.11590761), (10, 0.012381745), (11, 0.010362911), (14, 0.4931705), (17, 0.06088853), (18, 0.04509418)]"
33250,37823.0,2023-07-02 05:27:56,1,119,"<p>I was reading <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI-notes/"" rel=""nofollow noreferrer"">TQI-notes by Watrous</a> where they introduce different representations for quantum channels and wondering how to go from one to the other. I have:</p>
<p><span class=""math-container"">\begin{align}
&amp;|\Phi(\rho)\rangle\!\rangle \tag{1}
\\
&amp;= K(\Phi)|\rho\rangle\!\rangle \tag{2}
\\
&amp;=|\text{tr}_2[(I\otimes \rho^T) J(\Phi)]\rangle\!\rangle \tag{3}
\end{align}</span></p>
<p>where <span class=""math-container"">$\Phi$</span> is the channel,
<span class=""math-container"">$\rho$</span> is the density operator of the quantum state input into the channel,
<span class=""math-container"">$|\rangle\!\rangle$</span> represents vectorization,
<span class=""math-container"">$K(\Phi)$</span> is the normal representation of the channel
(<span class=""math-container"">$= \sum_i A_i \otimes \bar{A}_i$</span> where <span class=""math-container"">$A_i$</span> are the Kraus operators),
and <span class=""math-container"">$J(\Phi)$</span> is the Choi representation (<span class=""math-container"">$=\sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|$</span>) of the channel.</p>
<p>Questions:</p>
<ol>
<li>Are the equations correct?</li>
<li>Is there a more straightforward way to rewrite Eq. (3) in terms of <span class=""math-container"">$J(\Phi)$</span>? Choi representation seems very convoluted so where can this be useful?</li>
<li>I have omitted the Strinespring representation as I don't have a clear intuition for it but how can it be related to Eq.(1)?</li>
</ol>
",Interconversion between different representations of quantum channels,<quantum-operation><kraus-representation>,1,3,,,"Interconversion between different representations of quantum channels <p>I was reading <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI-notes/"" rel=""nofollow noreferrer"">TQI-notes by Watrous</a> where they introduce different representations for quantum channels and wondering how to go from one to the other. I have:</p>
<p><span class=""math-container"">\begin{align}
&amp;|\Phi(\rho)\rangle\!\rangle \tag{1}
\\
&amp;= K(\Phi)|\rho\rangle\!\rangle \tag{2}
\\
&amp;=|\text{tr}_2[(I\otimes \rho^T) J(\Phi)]\rangle\!\rangle \tag{3}
\end{align}</span></p>
<p>where <span class=""math-container"">$\Phi$</span> is the channel,
<span class=""math-container"">$\rho$</span> is the density operator of the quantum state input into the channel,
<span class=""math-container"">$|\rangle\!\rangle$</span> represents vectorization,
<span class=""math-container"">$K(\Phi)$</span> is the normal representation of the channel
(<span class=""math-container"">$= \sum_i A_i \otimes \bar{A}_i$</span> where <span class=""math-container"">$A_i$</span> are the Kraus operators),
and <span class=""math-container"">$J(\Phi)$</span> is the Choi representation (<span class=""math-container"">$=\sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|$</span>) of the channel.</p>
<p>Questions:</p>
<ol>
<li>Are the equations correct?</li>
<li>Is there a more straightforward way to rewrite Eq. (3) in terms of <span class=""math-container"">$J(\Phi)$</span>? Choi representation seems very convoluted so where can this be useful?</li>
<li>I have omitted the Strinespring representation as I don't have a clear intuition for it but how can it be related to Eq.(1)?</li>
</ol>
",qc,interconversion different representations quantum channels p reading https nofollow noreferrer watrous introduce different representations quantum channels wondering go one p span align amp 1 amp k 2 amp tr j 3 align p span channel span density operator quantum state input channel span represents vectorization span k normal representation channel span span kraus operators span j choi representation span p questions ol li equations correct li straightforward way rewrite eq 3 terms span j choi representation seems convoluted useful li omitted strinespring representation clear intuition related eq 1,"[(2, 0.028333887), (3, 0.76143706), (4, 0.032871064), (7, 0.08643969), (15, 0.076657504), (17, 0.012634659)]"
33267,33278.0,2023-07-03 19:57:03,0,130,"<p>I tried constructing a <code>cx</code> gate manually using tensor products and one using <code>QuantumCircuit</code> in qiskit followed by converting it to an <code>Operator</code>. The matrix from <code>Operator</code> does not match the manual construction, I believe this is due to the swap in the ordering of the qubits.</p>
<pre class=""lang-python prettyprint-override""><code>def test1():
    oneone = np.array([[0, 0], [0, 1]])
    zerozero = np.array([[1, 0], [0, 0]])
    eye = np.identity(2)

    unitary = np.array([[0, 1], [1, 0]])

    cx = np.kron(zerozero, eye) + np.kron(oneone, unitary)

    op_auto = UnitaryGate(unitary).control(1, ctrl_state='1')

    qc1 = QuantumCircuit(2)
    # Passes only due to reversed ordering of qubits.
    qc1.append(op_auto, [1, 0])
    op_auto = Operator.from_circuit(qc1)

    op_manual = UnitaryGate(cx)
    qc2 = QuantumCircuit(2)
    qc2.append(op_manual, [0, 1])
    op_manual = Operator.from_circuit(qc2)

    npt.assert_array_almost_equal(op_auto.data, op_manual.data)
</code></pre>
<p>Is there a way to force the layout to match the ordering of my choice? I did look into the <code>layout</code> parameter of the <code>Operator.from_circuit</code> method but I do not understand how to use it, there isn't any relevant documentation attached to the interface document either. Any leads would be helpful.</p>
",Operator qubit ordering not matching circuit qubit ordering,<qiskit><quantum-gate><density-matrix>,1,2,,,"Operator qubit ordering not matching circuit qubit ordering <p>I tried constructing a <code>cx</code> gate manually using tensor products and one using <code>QuantumCircuit</code> in qiskit followed by converting it to an <code>Operator</code>. The matrix from <code>Operator</code> does not match the manual construction, I believe this is due to the swap in the ordering of the qubits.</p>
<pre class=""lang-python prettyprint-override""><code>def test1():
    oneone = np.array([[0, 0], [0, 1]])
    zerozero = np.array([[1, 0], [0, 0]])
    eye = np.identity(2)

    unitary = np.array([[0, 1], [1, 0]])

    cx = np.kron(zerozero, eye) + np.kron(oneone, unitary)

    op_auto = UnitaryGate(unitary).control(1, ctrl_state='1')

    qc1 = QuantumCircuit(2)
    # Passes only due to reversed ordering of qubits.
    qc1.append(op_auto, [1, 0])
    op_auto = Operator.from_circuit(qc1)

    op_manual = UnitaryGate(cx)
    qc2 = QuantumCircuit(2)
    qc2.append(op_manual, [0, 1])
    op_manual = Operator.from_circuit(qc2)

    npt.assert_array_almost_equal(op_auto.data, op_manual.data)
</code></pre>
<p>Is there a way to force the layout to match the ordering of my choice? I did look into the <code>layout</code> parameter of the <code>Operator.from_circuit</code> method but I do not understand how to use it, there isn't any relevant documentation attached to the interface document either. Any leads would be helpful.</p>
",qc,operator qubit ordering matching circuit qubit ordering p tried constructing code cx gate manually using tensor products one using code quantumcircuit qiskit followed converting code operator matrix code operator match manual construction believe due swap ordering pre code def test1 oneone 0 0 0 1 zerozero 1 0 0 0 eye 2 unitary 0 1 1 0 cx zerozero eye oneone unitary unitarygate unitary 1 1 qc1 quantumcircuit 2 passes due reversed ordering qubits 1 0 qc1 unitarygate cx qc2 quantumcircuit 2 0 1 qc2 p way force layout match ordering choice look code layout parameter code method understand use relevant documentation attached interface document either leads would,"[(0, 0.2875281), (2, 0.3193461), (6, 0.028606763), (14, 0.33434397), (17, 0.02872076)]"
33269,33293.0,2023-07-03 23:10:44,1,284,"<p>I want to simulate a small-distance surface code with either STIM or Qiskit. I want individual control over all the qubits (including the ancillas) to induce controlled errors in my circuit. I want to also get the error syndromes and recovery operation prescribed by some sort of decoder i.e. the Minumum Weight Perfect Matching decoder. Overall, I want a dataset containing each controlled error (on the data qubits) with its error syndromes (on the ancilla qubits in a 2D grid) and the prescribed recovery operation.</p>
<p>What will be a good way to start tackling this problem, i.e. what combination of packages will be helpful and optimal for this thing?</p>
",Simulating a small distance surface code with individual qubit addressing,<qiskit><error-correction><stim><surface-code><toric-code>,1,2,,,"Simulating a small distance surface code with individual qubit addressing <p>I want to simulate a small-distance surface code with either STIM or Qiskit. I want individual control over all the qubits (including the ancillas) to induce controlled errors in my circuit. I want to also get the error syndromes and recovery operation prescribed by some sort of decoder i.e. the Minumum Weight Perfect Matching decoder. Overall, I want a dataset containing each controlled error (on the data qubits) with its error syndromes (on the ancilla qubits in a 2D grid) and the prescribed recovery operation.</p>
<p>What will be a good way to start tackling this problem, i.e. what combination of packages will be helpful and optimal for this thing?</p>
",qc,simulating small distance surface code individual qubit addressing p want simulate surface code either stim qiskit want individual control qubits including ancillas induce controlled errors circuit want also get error syndromes recovery operation prescribed sort decoder minumum weight perfect matching decoder overall want dataset containing controlled error data qubits error syndromes ancilla qubits 2d grid prescribed recovery p good way start tackling problem combination packages helpful optimal thing,"[(5, 0.36229697), (9, 0.11960686), (13, 0.02471569), (14, 0.4328025), (17, 0.058202833)]"
33282,33396.0,2023-07-05 10:08:46,2,463,"<p>I am working with a Tight Binding Hamiltonian with N sites and one orbital at each site in a closed chain. I have converted the fermionic expression to a spin expression using Jordan Wigner Transformation. I want to apply this as a gate in qiskit without using the built-in lattice model functions.<br />
This is the Hamiltonian in terms of fermionic operators :
<span class=""math-container"">$$ H_{\text{sys}} = \sum_{i} \epsilon_i c_{i }^{\dagger} c_{i } + t \sum_{i } (c_{i}^\dagger c_{i+1 } + c_{i+1}^\dagger c_{i } ) $$</span></p>
<p>This is the expression of the transformed Hamiltonian :<br />
<span class=""math-container"">$$ H_{\text{sys}} = \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \epsilon _k \big( \sigma ^- . \sigma ^+ \big)_k \otimes \textbf{I}^{\otimes(N-k)} + \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^- \big) _k \otimes \big( \sigma^+\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} \\ - \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^+ \big) _k \otimes \big( \sigma^-\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} $$</span></p>
<p><span class=""math-container"">$ \sigma _{\pm} = \frac{X \pm i Y}{2}$</span></p>
<p>I want to know how I can implement this as a gate in qiskit without creating the matrix first, and by simply tensoring the Pauli operators and summing them up using PauliSumOp.</p>
<p>What is the best way to implement it in general?</p>
",How can I implement a Hamiltonian which is sum of tensored pauli operators on qiskit?,<qiskit><quantum-gate><pauli-gates><hamiltonian>,2,0,,,"How can I implement a Hamiltonian which is sum of tensored pauli operators on qiskit? <p>I am working with a Tight Binding Hamiltonian with N sites and one orbital at each site in a closed chain. I have converted the fermionic expression to a spin expression using Jordan Wigner Transformation. I want to apply this as a gate in qiskit without using the built-in lattice model functions.<br />
This is the Hamiltonian in terms of fermionic operators :
<span class=""math-container"">$$ H_{\text{sys}} = \sum_{i} \epsilon_i c_{i }^{\dagger} c_{i } + t \sum_{i } (c_{i}^\dagger c_{i+1 } + c_{i+1}^\dagger c_{i } ) $$</span></p>
<p>This is the expression of the transformed Hamiltonian :<br />
<span class=""math-container"">$$ H_{\text{sys}} = \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \epsilon _k \big( \sigma ^- . \sigma ^+ \big)_k \otimes \textbf{I}^{\otimes(N-k)} + \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^- \big) _k \otimes \big( \sigma^+\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} \\ - \sum _{k=1}^{N} \textbf{I}^{\otimes (k-1)} \otimes \big( \sigma ^+ \big) _k \otimes \big( \sigma^-\big)_{k+1} \otimes \textbf{I}^{\otimes (N-k-1)} $$</span></p>
<p><span class=""math-container"">$ \sigma _{\pm} = \frac{X \pm i Y}{2}$</span></p>
<p>I want to know how I can implement this as a gate in qiskit without creating the matrix first, and by simply tensoring the Pauli operators and summing them up using PauliSumOp.</p>
<p>What is the best way to implement it in general?</p>
",qc,implement hamiltonian sum tensored pauli operators qiskit p working tight binding hamiltonian n sites one orbital site closed chain converted fermionic expression spin expression using jordan wigner transformation want apply gate qiskit without using lattice model br hamiltonian terms fermionic operators span sys p expression transformed hamiltonian br span sys n n n p span x 2 p want know implement gate qiskit without creating matrix first simply tensoring pauli operators summing using p best way implement general,"[(1, 0.09341689), (3, 0.42175797), (8, 0.040258978), (9, 0.04026785), (10, 0.049179416), (13, 0.04142811), (14, 0.28418684), (16, 0.013484624), (17, 0.0145543525)]"
33291,33301.0,2023-07-05 21:10:19,1,203,"<p>I'm going through <a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">pymatching tutorial</a> on constructing a toric code using hypergraph product of two repetition codes.
The hypergraph product code construction <span class=""math-container"">$H G P\left(H_1, H_2\right)$</span> takes as input the parity check matrices of two linear codes <span class=""math-container"">$C_1:=\operatorname{ker} H_1$</span> and <span class=""math-container"">$C_2:=\operatorname{ker} H_2$</span>. The code <span class=""math-container"">$H G P\left(H_1, H_2\right)$</span> is a CSS code with the  parity check matrix <span class=""math-container"">$H_X$</span>
corresponding to the
<span class=""math-container"">$X$</span>-type stabilisers
<span class=""math-container"">\begin{equation}
H_X=\left[H_1 \otimes I_{n_2}, I_{r_1} \otimes H_2^T\right]
\end{equation}</span>
and the parity check matrix <span class=""math-container"">$H_Z$</span>
corresponding to the
<span class=""math-container"">$Z$</span>-type stabilisers is
<span class=""math-container"">\begin{equation}
H_Z=\left[I_{n_1} \otimes H_2, H_1^T \otimes I_{r_2}\right]
\end{equation}</span>
where <span class=""math-container"">$H_1$</span> has dimensions <span class=""math-container"">$r_1 \times n_1, H_2$</span> has dimensions <span class=""math-container"">$r_2 \times n_2$</span> and <span class=""math-container"">$I_l$</span> denotes the <span class=""math-container"">$l \times l$</span> identity matrix.</p>
<p>So the full parity check matrix for the toric code is
<span class=""math-container"">\begin{equation}
H=\left(\begin{array}{cc}
H_X &amp; 0 \\
0 &amp; H_Z
\end{array}\right)
\end{equation}</span></p>
<p>From the Künneth theorem, the
logical <span class=""math-container"">$X$</span> operators of the toric code are given by
<span class=""math-container"">\begin{equation}
L_X=\left(\begin{array}{cc}
\mathcal{H}^1 \otimes \mathcal{H}^0 &amp; 0 \\
0 &amp; \mathcal{H}^0 \otimes \mathcal{H}^1
\end{array}\right)
\end{equation}</span>
where <span class=""math-container"">$\mathcal{H}^0$</span>
and  <span class=""math-container"">$\mathcal{H}^1$</span>
are the zeroth and first cohomology groups of the length-one chain complex that has the repetition code parity check matrix as its boundary operator.</p>
<p><strong>Question:</strong> Is <span class=""math-container"">$L_Z$</span> simply
<span class=""math-container"">\begin{equation}
L_Z=\left(\begin{array}{cc}
\mathcal{H}_1 \otimes \mathcal{H}_0 &amp; 0 \\
0 &amp; \mathcal{H}_0 \otimes \mathcal{H}_1
\end{array}\right)
\end{equation}</span>
where <span class=""math-container"">$\mathcal{H}_0$</span>
and  <span class=""math-container"">$\mathcal{H}_1$</span>
are the zeroth and first homology groups? How can I compute them? The cohomology groups for <span class=""math-container"">$L_X$</span> in the tutorial are: <span class=""math-container"">$\mathcal{H}^0$</span> is a vector of all <span class=""math-container"">$1$</span>'s and <span class=""math-container"">$\mathcal{H}^1$</span> is a vector of all <span class=""math-container"">$0$</span>'s but the first entry which is <span class=""math-container"">$1$</span> but I don't underastand why and how to get <span class=""math-container"">$\mathcal{H}_0$</span> and <span class=""math-container"">$\mathcal{H}_1$</span>.</p>
",How to compute Z logical operators of a toric code using Kunneth theorem?,<pymatching><toric-code>,1,0,,,"How to compute Z logical operators of a toric code using Kunneth theorem? <p>I'm going through <a href=""https://pymatching.readthedocs.io/en/latest/toric-code-example.html"" rel=""nofollow noreferrer"">pymatching tutorial</a> on constructing a toric code using hypergraph product of two repetition codes.
The hypergraph product code construction <span class=""math-container"">$H G P\left(H_1, H_2\right)$</span> takes as input the parity check matrices of two linear codes <span class=""math-container"">$C_1:=\operatorname{ker} H_1$</span> and <span class=""math-container"">$C_2:=\operatorname{ker} H_2$</span>. The code <span class=""math-container"">$H G P\left(H_1, H_2\right)$</span> is a CSS code with the  parity check matrix <span class=""math-container"">$H_X$</span>
corresponding to the
<span class=""math-container"">$X$</span>-type stabilisers
<span class=""math-container"">\begin{equation}
H_X=\left[H_1 \otimes I_{n_2}, I_{r_1} \otimes H_2^T\right]
\end{equation}</span>
and the parity check matrix <span class=""math-container"">$H_Z$</span>
corresponding to the
<span class=""math-container"">$Z$</span>-type stabilisers is
<span class=""math-container"">\begin{equation}
H_Z=\left[I_{n_1} \otimes H_2, H_1^T \otimes I_{r_2}\right]
\end{equation}</span>
where <span class=""math-container"">$H_1$</span> has dimensions <span class=""math-container"">$r_1 \times n_1, H_2$</span> has dimensions <span class=""math-container"">$r_2 \times n_2$</span> and <span class=""math-container"">$I_l$</span> denotes the <span class=""math-container"">$l \times l$</span> identity matrix.</p>
<p>So the full parity check matrix for the toric code is
<span class=""math-container"">\begin{equation}
H=\left(\begin{array}{cc}
H_X &amp; 0 \\
0 &amp; H_Z
\end{array}\right)
\end{equation}</span></p>
<p>From the Künneth theorem, the
logical <span class=""math-container"">$X$</span> operators of the toric code are given by
<span class=""math-container"">\begin{equation}
L_X=\left(\begin{array}{cc}
\mathcal{H}^1 \otimes \mathcal{H}^0 &amp; 0 \\
0 &amp; \mathcal{H}^0 \otimes \mathcal{H}^1
\end{array}\right)
\end{equation}</span>
where <span class=""math-container"">$\mathcal{H}^0$</span>
and  <span class=""math-container"">$\mathcal{H}^1$</span>
are the zeroth and first cohomology groups of the length-one chain complex that has the repetition code parity check matrix as its boundary operator.</p>
<p><strong>Question:</strong> Is <span class=""math-container"">$L_Z$</span> simply
<span class=""math-container"">\begin{equation}
L_Z=\left(\begin{array}{cc}
\mathcal{H}_1 \otimes \mathcal{H}_0 &amp; 0 \\
0 &amp; \mathcal{H}_0 \otimes \mathcal{H}_1
\end{array}\right)
\end{equation}</span>
where <span class=""math-container"">$\mathcal{H}_0$</span>
and  <span class=""math-container"">$\mathcal{H}_1$</span>
are the zeroth and first homology groups? How can I compute them? The cohomology groups for <span class=""math-container"">$L_X$</span> in the tutorial are: <span class=""math-container"">$\mathcal{H}^0$</span> is a vector of all <span class=""math-container"">$1$</span>'s and <span class=""math-container"">$\mathcal{H}^1$</span> is a vector of all <span class=""math-container"">$0$</span>'s but the first entry which is <span class=""math-container"">$1$</span> but I don't underastand why and how to get <span class=""math-container"">$\mathcal{H}_0$</span> and <span class=""math-container"">$\mathcal{H}_1$</span>.</p>
",qc,compute z logical operators toric code using kunneth theorem p going https nofollow noreferrer pymatching tutorial constructing toric code using hypergraph product two repetition codes hypergraph product code construction span h g takes input parity check matrices two linear codes span ker span ker code span h g css code parity check matrix span corresponding span x stabilisers span equation equation parity check matrix span corresponding span z stabilisers span equation equation span dimensions span dimensions span span denotes span l l identity p full parity check matrix toric code span equation array cc amp 0 0 amp array equation p künneth theorem logical span x operators toric code given span equation array cc h h amp 0 0 amp h h array equation span h span h zeroth first cohomology groups chain complex repetition code parity check matrix boundary p strong question span simply span equation array cc h h amp 0 0 amp h h array equation span h span h zeroth first homology groups compute cohomology groups span tutorial span h vector span 1 span h vector span 0 first entry span 1 underastand get span h span h,"[(2, 0.038775228), (3, 0.5207247), (5, 0.16452342), (6, 0.016248565), (7, 0.033845827), (15, 0.16887508), (17, 0.047369465)]"
33294,,2023-07-06 02:19:20,2,78,"<p>I executed the following code in a Jupyter notebook:</p>
<pre><code>from qiskit import QuantumCircuit, Aer, transpile

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

backend = Aer.get_backend(&quot;aer_simulator&quot;)
qc.save_statevector()

tqc = transpile(qc, backend)
job = backend.run(tqc)
result = job.result()
statevector = result.get_statevector(tqc, 4)
print(statevector)
</code></pre>
<p>and receive the output:</p>
<pre><code>Statevector([0.7071+0.j, 0.    +0.j, 0.    +0.j, 0.7071+0.j],
            dims=(2, 2))
</code></pre>
<p>But, according to the <code>get_statevector()</code> <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.get_statevector.html#qiskit.result.Result.get_statevector"" rel=""nofollow noreferrer"">documentation</a>, the <code>get_statevector()</code> method returns list of complex amplitudes. So, I would expect only a list of complex numbers in the output. What is the <code>dims=(2,2)</code> part of the output? Why is it appearing in the output and how can I get the output to reflect the documentation?</p>
",Qiskit: unexpected get_statevector output in Jupyter,<qiskit>,2,1,,,"Qiskit: unexpected get_statevector output in Jupyter <p>I executed the following code in a Jupyter notebook:</p>
<pre><code>from qiskit import QuantumCircuit, Aer, transpile

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)

backend = Aer.get_backend(&quot;aer_simulator&quot;)
qc.save_statevector()

tqc = transpile(qc, backend)
job = backend.run(tqc)
result = job.result()
statevector = result.get_statevector(tqc, 4)
print(statevector)
</code></pre>
<p>and receive the output:</p>
<pre><code>Statevector([0.7071+0.j, 0.    +0.j, 0.    +0.j, 0.7071+0.j],
            dims=(2, 2))
</code></pre>
<p>But, according to the <code>get_statevector()</code> <a href=""https://qiskit.org/documentation/stubs/qiskit.result.Result.get_statevector.html#qiskit.result.Result.get_statevector"" rel=""nofollow noreferrer"">documentation</a>, the <code>get_statevector()</code> method returns list of complex amplitudes. So, I would expect only a list of complex numbers in the output. What is the <code>dims=(2,2)</code> part of the output? Why is it appearing in the output and how can I get the output to reflect the documentation?</p>
",qc,qiskit unexpected output jupyter p executed following code jupyter notebook pre code qiskit import quantumcircuit aer transpile qc quantumcircuit 2 0 backend quot quot tqc transpile qc backend job tqc result statevector tqc 4 print statevector p receive output pre code statevector 0 0 2 2 p according code https nofollow noreferrer documentation code method returns list complex amplitudes would expect list complex numbers output code part output appearing output get output reflect documentation,"[(0, 0.59528595), (2, 0.07922495), (4, 0.11377258), (14, 0.17580308), (17, 0.013844966), (19, 0.02018042)]"
33328,,2023-07-09 11:44:52,0,91,"<p>Suppose there are n qubits each in the state <span class=""math-container"">$|+\rangle$</span> with equal probability of measurement as 0 and 1.
Set up a measurement of each qubit such that if we measure 1 it triggers a nuke which blows up the entire globe killing everyone on the planet.</p>
<p>If we do this experiment, what would be the actual outcome? Since measuring any of the qubits as 1 would spell doom for every conscious observer, would we actually measure a 1 or would we measure all the qubits as 0?</p>
",What would be the outcome if a quantum measurement has macroscopic consequences?,<measurement>,1,2,,,"What would be the outcome if a quantum measurement has macroscopic consequences? <p>Suppose there are n qubits each in the state <span class=""math-container"">$|+\rangle$</span> with equal probability of measurement as 0 and 1.
Set up a measurement of each qubit such that if we measure 1 it triggers a nuke which blows up the entire globe killing everyone on the planet.</p>
<p>If we do this experiment, what would be the actual outcome? Since measuring any of the qubits as 1 would spell doom for every conscious observer, would we actually measure a 1 or would we measure all the qubits as 0?</p>
",qc,would outcome quantum measurement macroscopic consequences p suppose n qubits state span equal probability measurement 0 set measurement qubit measure 1 triggers nuke blows entire globe killing everyone p experiment would actual outcome since measuring qubits 1 would spell doom every conscious observer would actually measure 1 would measure qubits 0,"[(2, 0.10887486), (10, 0.034448702), (13, 0.11189572), (14, 0.10210381), (17, 0.023517272), (18, 0.6159859)]"
33364,,2023-07-11 09:10:10,3,268,"<p>I am working with a tight binding model. I am looking for a way I can efficiently find the eigenvalues and eigenvectors of the Hamiltonian using a quantum algorithm. Can someone suggest some good resources?</p>
<p>I may proceed in the following two ways :</p>
<ol>
<li><p>Generate the Hamiltonian classically and use a quantum algorithm to solve the big,sparse, hermitian matrix.</p>
</li>
<li><p>Use a ferimionic to spin transformation, directly implement this Hamiltonian on a quantum circuit and use some quantum algorithm to solve it.</p>
</li>
</ol>
<p>Let me know if I'm thinking in the right direction or if there any other ways I can proceed. Resources/Algorithms for the suggested two ways would be highly appreciated. Thanks!</p>
",What quantum algorithms can be used to solve for eigenstates and eigenvalues of a hermitian matrix?,<quantum-algorithms><linear-algebra>,1,0,,,"What quantum algorithms can be used to solve for eigenstates and eigenvalues of a hermitian matrix? <p>I am working with a tight binding model. I am looking for a way I can efficiently find the eigenvalues and eigenvectors of the Hamiltonian using a quantum algorithm. Can someone suggest some good resources?</p>
<p>I may proceed in the following two ways :</p>
<ol>
<li><p>Generate the Hamiltonian classically and use a quantum algorithm to solve the big,sparse, hermitian matrix.</p>
</li>
<li><p>Use a ferimionic to spin transformation, directly implement this Hamiltonian on a quantum circuit and use some quantum algorithm to solve it.</p>
</li>
</ol>
<p>Let me know if I'm thinking in the right direction or if there any other ways I can proceed. Resources/Algorithms for the suggested two ways would be highly appreciated. Thanks!</p>
",qc,quantum algorithms used solve eigenstates eigenvalues hermitian matrix p working tight binding model looking way efficiently find eigenvalues eigenvectors hamiltonian using quantum algorithm someone suggest good resources p may proceed following two ways ol li p generate hamiltonian classically use quantum algorithm solve big sparse hermitian li p use ferimionic spin transformation directly implement hamiltonian quantum circuit use quantum algorithm solve p let know thinking right direction ways proceed suggested two ways would highly appreciated thanks,"[(1, 0.37530208), (3, 0.16762972), (7, 0.2740052), (11, 0.014286682), (14, 0.15353031), (17, 0.013382759)]"
33395,,2023-07-13 09:02:40,0,82,"<p>I have to compute the molecular vibrational energy of CO2 molecules using VQE, but I am not progressing; Code on the qiskit website does not work. Does anyone have any working code to find vibrational energy of any molecule using qiskit?</p>
<p>code source - <a href=""https://qiskit.org/ecosystem/nature/tutorials/02_vibrational_structure.html"" rel=""nofollow noreferrer"">qiskit</a>
Error-</p>
<pre><code>    from qiskit_nature.second_q.problems import VibrationalStructureProblem
    from qiskit_nature.second_q.mappers import DirectMapper
    
    vibrational_problem = driver.run(basis=basis)
    vibrational_problem.hamiltonian.truncation_order = 2
    main_op, aux_ops = vibrational_problem.second_q_ops()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[9], line 4
      1 from qiskit_nature.second_q.problems import VibrationalStructureProblem
      2 from qiskit_nature.second_q.mappers import DirectMapper
----&gt; 4 vibrational_problem = driver.run(basis=basis)
      5 vibrational_problem.hamiltonian.truncation_order = 2
      6 main_op, aux_ops = vibrational_problem.second_q_ops()

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py:153, in GaussianForcesDriver.run(self, basis)
    150 else:
    151     glr = GaussianLogDriver(jcf=self._jcf).run()
--&gt; 153 watson = glr.get_watson_hamiltonian(normalize=self._normalize)
    155 problem = watson_to_problem(watson, basis=basis)
    156 return problem

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py:287, in GaussianLogResult.get_watson_hamiltonian(self, normalize)
    280     watson = WatsonHamiltonian(
    281         as_coo(quadratic_data, shape=(max_index,) * 2),
    282         as_coo(cubic_data, shape=(max_index,) * 3),
    283         as_coo(quartic_data, shape=(max_index,) * 4),
    284         -as_coo(quadratic_data, shape=(max_index,) * 2),
    285     )
    286 else:
--&gt; 287     quadratic_numpy = np.zeros((max_index,) * 2)
    288     for coord, value in quadratic_data.items():
    289         quadratic_numpy[coord] = value

ValueError: negative dimensions are not allowed
</code></pre>
",Compute molecular vibrational energy of CO2 molecule using VQE,<qiskit><vqe>,0,2,,,"Compute molecular vibrational energy of CO2 molecule using VQE <p>I have to compute the molecular vibrational energy of CO2 molecules using VQE, but I am not progressing; Code on the qiskit website does not work. Does anyone have any working code to find vibrational energy of any molecule using qiskit?</p>
<p>code source - <a href=""https://qiskit.org/ecosystem/nature/tutorials/02_vibrational_structure.html"" rel=""nofollow noreferrer"">qiskit</a>
Error-</p>
<pre><code>    from qiskit_nature.second_q.problems import VibrationalStructureProblem
    from qiskit_nature.second_q.mappers import DirectMapper
    
    vibrational_problem = driver.run(basis=basis)
    vibrational_problem.hamiltonian.truncation_order = 2
    main_op, aux_ops = vibrational_problem.second_q_ops()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[9], line 4
      1 from qiskit_nature.second_q.problems import VibrationalStructureProblem
      2 from qiskit_nature.second_q.mappers import DirectMapper
----&gt; 4 vibrational_problem = driver.run(basis=basis)
      5 vibrational_problem.hamiltonian.truncation_order = 2
      6 main_op, aux_ops = vibrational_problem.second_q_ops()

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_forces_driver.py:153, in GaussianForcesDriver.run(self, basis)
    150 else:
    151     glr = GaussianLogDriver(jcf=self._jcf).run()
--&gt; 153 watson = glr.get_watson_hamiltonian(normalize=self._normalize)
    155 problem = watson_to_problem(watson, basis=basis)
    156 return problem

File /opt/homebrew/lib/python3.11/site-packages/qiskit_nature/second_q/drivers/gaussiand/gaussian_log_result.py:287, in GaussianLogResult.get_watson_hamiltonian(self, normalize)
    280     watson = WatsonHamiltonian(
    281         as_coo(quadratic_data, shape=(max_index,) * 2),
    282         as_coo(cubic_data, shape=(max_index,) * 3),
    283         as_coo(quartic_data, shape=(max_index,) * 4),
    284         -as_coo(quadratic_data, shape=(max_index,) * 2),
    285     )
    286 else:
--&gt; 287     quadratic_numpy = np.zeros((max_index,) * 2)
    288     for coord, value in quadratic_data.items():
    289         quadratic_numpy[coord] = value

ValueError: negative dimensions are not allowed
</code></pre>
",qc,compute molecular vibrational energy co2 molecule using vqe p compute molecular vibrational energy co2 molecules using vqe progressing code qiskit website work anyone working code find vibrational energy molecule using qiskit p code source https nofollow noreferrer qiskit pre code import vibrationalstructureproblem import directmapper 2 valueerror traceback recent call last cell 9 line 4 1 import vibrationalstructureproblem 2 import directmapper gt 4 5 2 6 file self basis 150 else 151 glr gaussianlogdriver gt 153 watson 155 problem watson 156 return problem file self normalize 280 watson watsonhamiltonian 281 2 282 3 283 4 284 2 285 286 else gt 287 2 288 coord value 289 coord value valueerror negative dimensions allowed,"[(0, 0.6321581), (4, 0.04917398), (6, 0.19101445), (17, 0.12585877)]"
33397,33405.0,2023-07-13 11:29:32,1,105,"<p>Assume I have a surface code with distance <span class=""math-container"">$d$</span> and an i.i.d error model with both single qubit depolarization and measurement errors, both with probability <span class=""math-container"">$p$</span>.</p>
<p>In this case, one usually repeats the syndrome measurement cycles <span class=""math-container"">$d$</span> times to get the threshold. But what happens if one repeats the syndrome measurement cycles for <span class=""math-container"">$m*d$</span> times, with <span class=""math-container"">$2\le m$</span>?</p>
<p>When I simulated this using stim, I found that the threshold decreases as <span class=""math-container"">$m$</span> increases, and the logical error rate increases with <span class=""math-container"">$m$</span>. Is this a known phenomenon, and why this happens? Or maybe I have a problem with my simulations? Where can I find a discussion of this topic in the literature?</p>
",Effect of too many syndrome measurement cycles on surface code threshold,<error-correction><stim><surface-code><fault-tolerance>,1,0,,,"Effect of too many syndrome measurement cycles on surface code threshold <p>Assume I have a surface code with distance <span class=""math-container"">$d$</span> and an i.i.d error model with both single qubit depolarization and measurement errors, both with probability <span class=""math-container"">$p$</span>.</p>
<p>In this case, one usually repeats the syndrome measurement cycles <span class=""math-container"">$d$</span> times to get the threshold. But what happens if one repeats the syndrome measurement cycles for <span class=""math-container"">$m*d$</span> times, with <span class=""math-container"">$2\le m$</span>?</p>
<p>When I simulated this using stim, I found that the threshold decreases as <span class=""math-container"">$m$</span> increases, and the logical error rate increases with <span class=""math-container"">$m$</span>. Is this a known phenomenon, and why this happens? Or maybe I have a problem with my simulations? Where can I find a discussion of this topic in the literature?</p>
",qc,effect many syndrome measurement cycles surface code threshold p assume surface code distance span error model single qubit depolarization measurement errors probability span p p case one usually repeats syndrome measurement cycles span times get threshold happens one repeats syndrome measurement cycles span times span p simulated using stim found threshold decreases span increases logical error rate increases span known phenomenon happens maybe problem simulations find discussion topic literature,"[(0, 0.03904187), (3, 0.106514975), (5, 0.45345652), (8, 0.12831126), (17, 0.028101847), (18, 0.24254774)]"
33423,,2023-07-15 10:05:35,1,34,"<p>I'm just getting into the baffling world of Quantum Computing so forgive me if this is straightforward...</p>
<p>I'm using Microsoft's Q# simulator so I know I'm allowed to peek into the internals of a Qubit in the way hardware would not allow. Specifically using <code>DumpRegister()</code> to look into the Qubit state - however, I think that's not telling me anything about entanglement:</p>
<ul>
<li>If I <code>CNOT</code> two bits, the <code>DumpRegister</code> output is the same before as after, but the state machine must know about that relationship beyond just the current probabilities of values for the register</li>
<li>If I <code>MultiplyI</code> two registers to a third, the <code>DumpRegister</code> output is entirely blank, it's not showing any Qubits at all</li>
</ul>
<p>Is there a way I can get a deeper snapshot view of the machine state? Why is it that <code>MultiplyI</code> causes the Qubits to be not reported at all by <code>DumpRegister</code>?</p>
<p>Example code:</p>
<pre><code>    operation CNot() : Unit
    {
        use reg=Qubit[2];
        ApplyToEachCA(H,reg); 
        DumpRegister((),reg);
        CNOT(reg[0],reg[1]);
        DumpRegister((),reg);
        ResetAll(reg);
    }

    operation Multiply() : Unit
    {
        use r1=Qubit[2];
        use r2=Qubit[2];
        use r3=Qubit[4];

        ApplyToEachCA(H,r1);
        ApplyToEachCA(H,r2);

        for q in r3
        {
            SetQubitState(Zero, q);
        }

        let le1=LittleEndian(r1);
        let le2=LittleEndian(r2);
        let le3=LittleEndian(r3);

        MultiplyI (le1,le2,le3);
    
        DumpRegister ((),r1);
        DumpRegister ((),r2);
        DumpRegister ((),r3);

        let m1=MeasureInteger (le1);
        let m2=MeasureInteger (le2);
        let m3=MeasureInteger (le3);

        Message($&quot;{m1} * {m2} = {m3}&quot;);

        ResetAll(r1);
        ResetAll(r2);
        ResetAll(r3);
    }
</code></pre>
<p><code>CNot()</code> produces <code>0.500000 +  0.000000 i</code> for each value before and after - I can see <code>DumpRegister()</code> is just showing the probabilities of values in the register which I guess is the same before and after, but there's some other state it's not showing. <code>DumpMachine()</code> is no more informative.</p>
<p><code>Multiply()</code> produces an output like <code>3 * 2 = 6</code> but each <code>DumpRegister()</code> line only produces a blank line.</p>
",DumpRegister sometimes blank?,<entanglement><q#>,1,2,,,"DumpRegister sometimes blank? <p>I'm just getting into the baffling world of Quantum Computing so forgive me if this is straightforward...</p>
<p>I'm using Microsoft's Q# simulator so I know I'm allowed to peek into the internals of a Qubit in the way hardware would not allow. Specifically using <code>DumpRegister()</code> to look into the Qubit state - however, I think that's not telling me anything about entanglement:</p>
<ul>
<li>If I <code>CNOT</code> two bits, the <code>DumpRegister</code> output is the same before as after, but the state machine must know about that relationship beyond just the current probabilities of values for the register</li>
<li>If I <code>MultiplyI</code> two registers to a third, the <code>DumpRegister</code> output is entirely blank, it's not showing any Qubits at all</li>
</ul>
<p>Is there a way I can get a deeper snapshot view of the machine state? Why is it that <code>MultiplyI</code> causes the Qubits to be not reported at all by <code>DumpRegister</code>?</p>
<p>Example code:</p>
<pre><code>    operation CNot() : Unit
    {
        use reg=Qubit[2];
        ApplyToEachCA(H,reg); 
        DumpRegister((),reg);
        CNOT(reg[0],reg[1]);
        DumpRegister((),reg);
        ResetAll(reg);
    }

    operation Multiply() : Unit
    {
        use r1=Qubit[2];
        use r2=Qubit[2];
        use r3=Qubit[4];

        ApplyToEachCA(H,r1);
        ApplyToEachCA(H,r2);

        for q in r3
        {
            SetQubitState(Zero, q);
        }

        let le1=LittleEndian(r1);
        let le2=LittleEndian(r2);
        let le3=LittleEndian(r3);

        MultiplyI (le1,le2,le3);
    
        DumpRegister ((),r1);
        DumpRegister ((),r2);
        DumpRegister ((),r3);

        let m1=MeasureInteger (le1);
        let m2=MeasureInteger (le2);
        let m3=MeasureInteger (le3);

        Message($&quot;{m1} * {m2} = {m3}&quot;);

        ResetAll(r1);
        ResetAll(r2);
        ResetAll(r3);
    }
</code></pre>
<p><code>CNot()</code> produces <code>0.500000 +  0.000000 i</code> for each value before and after - I can see <code>DumpRegister()</code> is just showing the probabilities of values in the register which I guess is the same before and after, but there's some other state it's not showing. <code>DumpMachine()</code> is no more informative.</p>
<p><code>Multiply()</code> produces an output like <code>3 * 2 = 6</code> but each <code>DumpRegister()</code> line only produces a blank line.</p>
",qc,dumpregister sometimes blank p getting baffling world quantum computing forgive straightforward p using microsoft q simulator know allowed peek internals qubit way hardware would allow specifically using code dumpregister look qubit state however think telling anything entanglement ul li code cnot two bits code dumpregister output state machine must know relationship beyond current probabilities values register li code multiplyi two registers third code dumpregister output entirely blank showing qubits p way get deeper snapshot view machine state code multiplyi causes qubits reported code dumpregister p example code pre code operation cnot unit use 2 applytoeachca h reg dumpregister reg cnot reg 0 reg 1 dumpregister reg resetall reg operation multiply unit use 2 use 2 use 4 applytoeachca h r1 applytoeachca h r2 q r3 setqubitstate zero q let r1 let r2 let r3 multiplyi le1 le2 le3 dumpregister r1 dumpregister r2 dumpregister r3 let le1 let le2 let le3 message quot m1 m2 m3 quot resetall r1 resetall r2 resetall r3 p code cnot produces code value see code dumpregister showing probabilities values register guess state showing code dumpmachine p code multiply produces output like code 3 2 6 code dumpregister line produces blank,"[(0, 0.16226725), (2, 0.07484208), (6, 0.013954582), (7, 0.057824336), (8, 0.09012422), (10, 0.015844133), (14, 0.24588718), (16, 0.09714987), (17, 0.04850738), (18, 0.17458373), (19, 0.012281772)]"
33440,33445.0,2023-07-17 02:47:47,3,106,"<p>Measurement operators for those that one creates for unambiguous state discrimination, <span class=""math-container"">$\Pi_0,~\Pi_1,~\Pi_?$</span>, are such that
<span class=""math-container"">$\Pi_0 + \Pi_1 + \Pi_? = \mathbb{1}$</span> and the probabilities for a measurement click are
<span class=""math-container"">$p_i = \langle E_i | \Pi_i | E_i \rangle$</span>.</p>
<p>From what I gather, the following table sums up the possibilities:</p>
<p><a href=""https://i.sstatic.net/crJKZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/crJKZ.png"" alt=""Possible outcomes from measuring two possible state"" /></a></p>
<p>Let's say we use <span class=""math-container"">$\Pi_1$</span> to measure either <span class=""math-container"">$E_0$</span> or <span class=""math-container"">$E_1$</span>. From what I read, a click tells us <span class=""math-container"">$E_1$</span> while no-click tells us nothing since both <span class=""math-container"">$E_0$</span> and <span class=""math-container"">$E_1$</span> can trigger non-clicks. That doesn't seem correct. Let's say <span class=""math-container"">$p_1$</span> is close to 1. Then a no-click is very unlikely to be from <span class=""math-container"">$E_1$</span> and we can say with some probability that the state was <span class=""math-container"">$E_0$</span> (unequal a priori probabilities would make this even more apparent). This wouldn't be an unambiguous determination but it wouldn't be a complete guess either. Am I on the right track? I hadn't seen any references bring this point up.</p>
",Making an ambiguous and unambiguous state determinations together,<state-discrimination>,2,0,,,"Making an ambiguous and unambiguous state determinations together <p>Measurement operators for those that one creates for unambiguous state discrimination, <span class=""math-container"">$\Pi_0,~\Pi_1,~\Pi_?$</span>, are such that
<span class=""math-container"">$\Pi_0 + \Pi_1 + \Pi_? = \mathbb{1}$</span> and the probabilities for a measurement click are
<span class=""math-container"">$p_i = \langle E_i | \Pi_i | E_i \rangle$</span>.</p>
<p>From what I gather, the following table sums up the possibilities:</p>
<p><a href=""https://i.sstatic.net/crJKZ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/crJKZ.png"" alt=""Possible outcomes from measuring two possible state"" /></a></p>
<p>Let's say we use <span class=""math-container"">$\Pi_1$</span> to measure either <span class=""math-container"">$E_0$</span> or <span class=""math-container"">$E_1$</span>. From what I read, a click tells us <span class=""math-container"">$E_1$</span> while no-click tells us nothing since both <span class=""math-container"">$E_0$</span> and <span class=""math-container"">$E_1$</span> can trigger non-clicks. That doesn't seem correct. Let's say <span class=""math-container"">$p_1$</span> is close to 1. Then a no-click is very unlikely to be from <span class=""math-container"">$E_1$</span> and we can say with some probability that the state was <span class=""math-container"">$E_0$</span> (unequal a priori probabilities would make this even more apparent). This wouldn't be an unambiguous determination but it wouldn't be a complete guess either. Am I on the right track? I hadn't seen any references bring this point up.</p>
",qc,making ambiguous unambiguous state determinations together p measurement operators one creates unambiguous state discrimination span span 1 probabilities measurement click span p gather following table sums possibilities p https nofollow noreferrer img https possible outcomes measuring two possible state p let say use span measure either span span read click tells us span tells us nothing since span span trigger seem correct let say span close unlikely span say probability state span unequal priori probabilities would make even apparent would unambiguous determination would complete guess either right track seen references bring point,"[(3, 0.41953486), (4, 0.07949088), (5, 0.028386595), (8, 0.03291444), (9, 0.042307213), (13, 0.10774792), (17, 0.012672918), (18, 0.27551624)]"
33460,33464.0,2023-07-18 06:15:15,2,268,"<p>You may be familiar with &quot;Klein's inequality&quot;; one form of it is
<span class=""math-container"">$$
-\operatorname{tr}(\rho \log \sigma) + \operatorname{tr}(\rho \log \rho) \ge 0,
$$</span>
stating that relative entropy is nonnegative (where <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> are density matrices). There are various other versions of it - some which are equivalent, and some which go by the same name but are inequivalent / more general. A rather general one is
<span class=""math-container"">$$
\operatorname{tr}(f(A)-f(B)-(A-B)f'(B)) \ge 0
$$</span>
(<span class=""math-container"">$f$</span> convex, such as <span class=""math-container"">$f(t) = t \log t$</span>), which is what <a href=""https://en.wikipedia.org/wiki/Trace_inequality"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Trace_inequality</a> calls Klein's inequality. I'm curious about the origins of the Klein inequality (or perhaps I should say, inequalities, plural).</p>
<p>I see Nielsen and Chuang, for example, cite a paper, O. Klein, <em>Zur quantenmechanischen Begründung des zweiten Hauptsatzes der Wärmelehre</em>, Zeitschrift für Physik A 72 (1931), 767 – 775. However - and maybe I'm just bad at reading German or the notation - I don't think I actually recognize &quot;Klein's inequality&quot; in there.</p>
<p>Did Oskar Klein prove what's now called Klein's inequality? Or if he didn't, then who did, and when?</p>
",Is Klein's inequality due to Klein?,<density-matrix><information-theory><entropy><history>,1,0,,,"Is Klein's inequality due to Klein? <p>You may be familiar with &quot;Klein's inequality&quot;; one form of it is
<span class=""math-container"">$$
-\operatorname{tr}(\rho \log \sigma) + \operatorname{tr}(\rho \log \rho) \ge 0,
$$</span>
stating that relative entropy is nonnegative (where <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\sigma$</span> are density matrices). There are various other versions of it - some which are equivalent, and some which go by the same name but are inequivalent / more general. A rather general one is
<span class=""math-container"">$$
\operatorname{tr}(f(A)-f(B)-(A-B)f'(B)) \ge 0
$$</span>
(<span class=""math-container"">$f$</span> convex, such as <span class=""math-container"">$f(t) = t \log t$</span>), which is what <a href=""https://en.wikipedia.org/wiki/Trace_inequality"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Trace_inequality</a> calls Klein's inequality. I'm curious about the origins of the Klein inequality (or perhaps I should say, inequalities, plural).</p>
<p>I see Nielsen and Chuang, for example, cite a paper, O. Klein, <em>Zur quantenmechanischen Begründung des zweiten Hauptsatzes der Wärmelehre</em>, Zeitschrift für Physik A 72 (1931), 767 – 775. However - and maybe I'm just bad at reading German or the notation - I don't think I actually recognize &quot;Klein's inequality&quot; in there.</p>
<p>Did Oskar Klein prove what's now called Klein's inequality? Or if he didn't, then who did, and when?</p>
",qc,klein inequality due klein p may familiar quot klein inequality quot one form span tr tr 0 stating relative entropy nonnegative span span density matrices various versions equivalent go name inequivalent general rather general one span tr f b f b 0 span f convex span f https nofollow noreferrer https calls klein inequality curious origins klein inequality perhaps say inequalities plural p see nielsen chuang example cite paper klein em zur quantenmechanischen begründung des zweiten hauptsatzes der wärmelehre zeitschrift für physik 72 1931 767 however maybe bad reading german notation think actually recognize quot klein inequality quot p oskar klein prove called klein inequality,"[(2, 0.027744394), (3, 0.5154309), (7, 0.018503953), (9, 0.27723762), (10, 0.050059665), (12, 0.011287337), (17, 0.014170819), (19, 0.084065326)]"
33467,33471.0,2023-07-18 13:07:42,0,42,"<p>I'm using <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> and <a href=""https://github.com/quantumlib/Stim/blob/81142ac2bf20a9a0a5b2edb6e81860cbe95844c9/glue/sample/README.md"" rel=""nofollow noreferrer"">sinter</a> and can't figure out how to pass multiple arguments to <code>sinter plot --filter_func</code>. A single argument works as</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot;</code>.</p>
<p>I've tried passing multiple arguments a few different ways, e.g.</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; &quot;metadata['b']=='x'&quot;</code></p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; --filter_func &quot;metadata['b']=='x'&quot;</code></p>
<p>But can't get it to work so I'm wondering how.</p>
<p>My whole process is: first I use the terminal to collect some statistics on different distance surface codes using stim and sinter:</p>
<pre><code>mkdir circuits;
python3 -c &quot;
import stim

for p in [0.002]:
    for d in [3, 5, 7, 9]:
      for b in 'xz':
        with open(f'circuits/d={d},p={p},b={b}.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_{b}')
            print(c, file=f)
&quot;;

sinter collect \
    --processes 4  \
    --circuits circuits/*.stim \
    --metadata_func &quot;auto&quot; \
    --decoders pymatching \
    --max_shots 100_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<p>And then I plot it using <code>sinter plot</code>. I could specify that I only want to plot up to distance 7 even though I collected data up to distance 9 using     <code>--filter_func &quot;metadata['d']&lt;8&quot; </code></p>
<pre><code>sinter plot  \
    --in  stats.csv \
    --group_func &quot;f'''p={metadata['p']} b={metadata['b']}'''&quot;\
    --x_func &quot;metadata['d']&quot;  \
    --xaxis &quot;Distance&quot; \
    --filter_func &quot;metadata['d']&lt;8&quot; \
    --show \
    --out plot.png
</code></pre>
<p>Which gives this plot:
<a href=""https://i.sstatic.net/wxXJc.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wxXJc.png"" alt=""enter image description here"" /></a></p>
<p>However I don't know how to specify two filters, like only plotting up to distance 7 and only plotting the b=x line.</p>
",How to pass multiple arguments to sinter plot --filter_func?,<stim>,1,0,,,"How to pass multiple arguments to sinter plot --filter_func? <p>I'm using <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> and <a href=""https://github.com/quantumlib/Stim/blob/81142ac2bf20a9a0a5b2edb6e81860cbe95844c9/glue/sample/README.md"" rel=""nofollow noreferrer"">sinter</a> and can't figure out how to pass multiple arguments to <code>sinter plot --filter_func</code>. A single argument works as</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot;</code>.</p>
<p>I've tried passing multiple arguments a few different ways, e.g.</p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; &quot;metadata['b']=='x'&quot;</code></p>
<p><code>--filter_func &quot;metadata['d']&lt;8&quot; --filter_func &quot;metadata['b']=='x'&quot;</code></p>
<p>But can't get it to work so I'm wondering how.</p>
<p>My whole process is: first I use the terminal to collect some statistics on different distance surface codes using stim and sinter:</p>
<pre><code>mkdir circuits;
python3 -c &quot;
import stim

for p in [0.002]:
    for d in [3, 5, 7, 9]:
      for b in 'xz':
        with open(f'circuits/d={d},p={p},b={b}.stim', 'w') as f:
            c = stim.Circuit.generated(
                rounds=d,
                distance=d,
                after_clifford_depolarization=p,
                after_reset_flip_probability=p,
                before_measure_flip_probability=p,
                before_round_data_depolarization=p,
                code_task=f'surface_code:rotated_memory_{b}')
            print(c, file=f)
&quot;;

sinter collect \
    --processes 4  \
    --circuits circuits/*.stim \
    --metadata_func &quot;auto&quot; \
    --decoders pymatching \
    --max_shots 100_000_000 \
    --max_errors 1000 \
    --save_resume_filepath stats.csv
</code></pre>
<p>And then I plot it using <code>sinter plot</code>. I could specify that I only want to plot up to distance 7 even though I collected data up to distance 9 using     <code>--filter_func &quot;metadata['d']&lt;8&quot; </code></p>
<pre><code>sinter plot  \
    --in  stats.csv \
    --group_func &quot;f'''p={metadata['p']} b={metadata['b']}'''&quot;\
    --x_func &quot;metadata['d']&quot;  \
    --xaxis &quot;Distance&quot; \
    --filter_func &quot;metadata['d']&lt;8&quot; \
    --show \
    --out plot.png
</code></pre>
<p>Which gives this plot:
<a href=""https://i.sstatic.net/wxXJc.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wxXJc.png"" alt=""enter image description here"" /></a></p>
<p>However I don't know how to specify two filters, like only plotting up to distance 7 and only plotting the b=x line.</p>
",qc,pass multiple arguments sinter plot p using https nofollow noreferrer stim https nofollow noreferrer sinter ca figure pass multiple arguments code sinter plot single argument works p code quot metadata lt 8 quot p tried passing multiple arguments different ways p code quot metadata lt 8 quot quot metadata b x quot p code quot metadata lt 8 quot quot metadata b x quot p ca get work wondering p whole process first use terminal collect statistics different distance surface codes using stim sinter pre code mkdir circuits python3 quot import stim p 3 5 7 9 b open p b w f c b print c quot sinter collect processes 4 circuits quot auto quot decoders pymatching 1000 p plot using code sinter plot could specify want plot distance 7 even though collected data distance 9 using code quot metadata lt 8 quot pre code sinter plot quot f metadata p metadata b quot quot metadata quot xaxis quot distance quot quot metadata lt 8 quot show p gives plot https nofollow noreferrer img https enter image description p however know specify two filters like plotting distance 7 plotting,"[(0, 0.11774067), (4, 0.19800736), (5, 0.071948946), (6, 0.126883), (10, 0.023131205), (12, 0.0106618935), (14, 0.20321003), (17, 0.040771544), (19, 0.20706055)]"
33538,33540.0,2023-07-22 22:50:25,2,57,"<p>We know for two real numbers a and b</p>
<p><span class=""math-container"">$$a^3 \times b^3=(ab)^3$$</span></p>
<p>What if a and b are ket and bra, respectively?</p>
<p>Can i write the below formula?</p>
<p><span class=""math-container"">$$(|0\rangle+|1\rangle)^2(\langle0|+\langle1|)^2=(|0\rangle\langle0|+|0\rangle\langle1|+|1\rangle\langle0|+|1\rangle\langle1|)^2$$</span></p>
",Do power laws work for kets and bras?,<quantum-state>,1,0,,,"Do power laws work for kets and bras? <p>We know for two real numbers a and b</p>
<p><span class=""math-container"">$$a^3 \times b^3=(ab)^3$$</span></p>
<p>What if a and b are ket and bra, respectively?</p>
<p>Can i write the below formula?</p>
<p><span class=""math-container"">$$(|0\rangle+|1\rangle)^2(\langle0|+\langle1|)^2=(|0\rangle\langle0|+|0\rangle\langle1|+|1\rangle\langle0|+|1\rangle\langle1|)^2$$</span></p>
",qc,power laws work kets bras p know two real numbers b p span ab p b ket bra respectively p write formula p span,"[(3, 0.9445918), (17, 0.04764659)]"
33555,33560.0,2023-07-24 13:50:20,2,127,"<p><a href=""https://i.sstatic.net/cUANP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cUANP.png"" alt=""enter image description here"" /></a></p>
<p>I was watching a presentation and I run into this example.</p>
<p>What does <span class=""math-container"">$\phi$</span> with the (x)t on the exponent mean?, similarly for the other symbol</p>
",Bra-ket notation in cryptography example,<terminology-and-notation>,2,0,,,"Bra-ket notation in cryptography example <p><a href=""https://i.sstatic.net/cUANP.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/cUANP.png"" alt=""enter image description here"" /></a></p>
<p>I was watching a presentation and I run into this example.</p>
<p>What does <span class=""math-container"">$\phi$</span> with the (x)t on the exponent mean?, similarly for the other symbol</p>
",qc,notation cryptography example p https nofollow noreferrer img https enter image description p watching presentation run p span x exponent mean similarly symbol,"[(4, 0.53764445), (7, 0.084787324), (10, 0.13986829), (13, 0.1875019), (17, 0.04372895)]"
33563,,2023-07-24 19:53:15,1,68,"<p>I try to make VQE optimizer, but something goes wrong at the optimization stage, more precisely, the parameters do not change and there is no gradient descent. Please tell me what I'm doing wrong?</p>
<pre><code>import pennylane as qml

from pennylane import qaoa
from pennylane import numpy as np
from matplotlib import pyplot as plt
import networkx as nx

numer_stability_const = 0.1
op_new = sparse.csr_matrix(op)
ham =  qml.SparseHamiltonian(op_new * numer_stability_const, wires=list(range(16)))
size = len(ham.wires)
dev = qml.device(&quot;default.qubit&quot;, wires=size)
def  circuit(params):

    for i in range(size):
        qml.RY(params[0][i][0], wires=i)
        qml.RZ(params[0][i][1], wires=i)

    for i in range(size - 1):
        qml.CZ(wires=[i, i + 1])
def layer(params):
    for i in range(size):
        qml.RY(params[i][0], wires=i)
        qml.RZ(params[i][1], wires=i)

    for i in range(size - 1):
        qml.CZ(wires=[i, i + 1])
device = qml.device(&quot;default.qubit&quot;, wires=size)
num_layers = 3

@qml.qnode(device, diff_method=&quot;parameter-shift&quot;)
def feed_forward(params, wires=size):
    for k in range(3):
        layer(params[k])

    for i in range(size):
        qml.RY(params[-1][i][0], wires=i)
        qml.RZ(params[-1][i][1], wires=i)
    
    return qml.expval(ham)
opt = qml.MomentumOptimizer()
params = tuple(
    tuple(
    (
        np.random.rand() * 2 * np.pi,
        np.random.rand() * 2 * np.pi,
    )
    for _ in range(size)
)
for _ in range(num_layers + 1)
)
energy = [
feed_forward(params),
]

for epoch in range(25):
    params, e = opt.step_and_cost(feed_forward, params)
    energy.append(e)

    if epoch % 5 == 0:
        print(epoch, energy[-1])
</code></pre>
",Why VQE don't work?,<pennylane>,0,2,,,"Why VQE don't work? <p>I try to make VQE optimizer, but something goes wrong at the optimization stage, more precisely, the parameters do not change and there is no gradient descent. Please tell me what I'm doing wrong?</p>
<pre><code>import pennylane as qml

from pennylane import qaoa
from pennylane import numpy as np
from matplotlib import pyplot as plt
import networkx as nx

numer_stability_const = 0.1
op_new = sparse.csr_matrix(op)
ham =  qml.SparseHamiltonian(op_new * numer_stability_const, wires=list(range(16)))
size = len(ham.wires)
dev = qml.device(&quot;default.qubit&quot;, wires=size)
def  circuit(params):

    for i in range(size):
        qml.RY(params[0][i][0], wires=i)
        qml.RZ(params[0][i][1], wires=i)

    for i in range(size - 1):
        qml.CZ(wires=[i, i + 1])
def layer(params):
    for i in range(size):
        qml.RY(params[i][0], wires=i)
        qml.RZ(params[i][1], wires=i)

    for i in range(size - 1):
        qml.CZ(wires=[i, i + 1])
device = qml.device(&quot;default.qubit&quot;, wires=size)
num_layers = 3

@qml.qnode(device, diff_method=&quot;parameter-shift&quot;)
def feed_forward(params, wires=size):
    for k in range(3):
        layer(params[k])

    for i in range(size):
        qml.RY(params[-1][i][0], wires=i)
        qml.RZ(params[-1][i][1], wires=i)
    
    return qml.expval(ham)
opt = qml.MomentumOptimizer()
params = tuple(
    tuple(
    (
        np.random.rand() * 2 * np.pi,
        np.random.rand() * 2 * np.pi,
    )
    for _ in range(size)
)
for _ in range(num_layers + 1)
)
energy = [
feed_forward(params),
]

for epoch in range(25):
    params, e = opt.step_and_cost(feed_forward, params)
    energy.append(e)

    if epoch % 5 == 0:
        print(epoch, energy[-1])
</code></pre>
",qc,vqe work p try make vqe optimizer something goes wrong optimization stage precisely parameters change gradient descent please tell wrong pre code import pennylane qml pennylane import qaoa pennylane import numpy np matplotlib import pyplot plt import networkx nx op ham range 16 size len dev quot quot def circuit params range size params 0 0 params 0 1 range size 1 1 def layer params range size params 0 params 1 range size 1 1 device quot quot 3 device quot quot def params k range 3 layer params k range size params 0 params 1 return ham opt params tuple tuple 2 2 range size range 1 energy params epoch range 25 params e params e epoch 5 0 print epoch energy,"[(0, 0.6925326), (2, 0.12624797), (6, 0.021714315), (8, 0.058166545), (17, 0.034977317), (19, 0.065195605)]"
33567,,2023-07-25 16:30:49,1,70,"<p>Has anyone tried to solve the continuous variable portfolio optimization in Qiskit? I see a lot of binary variable problems but none which solve and get the optimal weights.</p>
",Continuous variable portfolio optimization problem,<qiskit><optimization>,0,2,,,"Continuous variable portfolio optimization problem <p>Has anyone tried to solve the continuous variable portfolio optimization in Qiskit? I see a lot of binary variable problems but none which solve and get the optimal weights.</p>
",qc,continuous variable portfolio optimization problem p anyone tried solve continuous variable portfolio optimization qiskit see lot binary variable problems none solve get optimal,"[(0, 0.20658827), (1, 0.29705825), (8, 0.36790034), (17, 0.12155557)]"
33584,33590.0,2023-07-26 20:10:40,2,243,"<p>I am reading about phase damping channel from Preskill's notes. He writes off the unitary representation of the channel as</p>
<blockquote>
<p>Unitary representation. An isometric representation of the channel is
<span class=""math-container"">\begin{equation}
|0\rangle_{A} \rightarrow \sqrt{1-p}|0\rangle_{A}\otimes|0\rangle_{E}+\sqrt{p}|0\rangle_{A}\otimes|1\rangle_{E}
\end{equation}</span>
<span class=""math-container"">\begin{equation}
|1\rangle_{A} \rightarrow \sqrt{1-p}|1\rangle_{A}\otimes|0\rangle_{E}+\sqrt{p}|1\rangle_{A}\otimes|2\rangle_{E}
\end{equation}</span>
In this case, unlike the depolarizing channel, qubit <span class=""math-container"">$A$</span> does not make any
transitions in the <span class=""math-container"">$\left\{|0\rangle,|1\rangle\right\}$</span> basis. Instead, the environment &quot;scatters&quot; of the qubit occasionally (with probability <span class=""math-container"">$p$</span>), being kicked into the state
<span class=""math-container"">$|1\rangle_E$</span> if <span class=""math-container"">$A$</span> is in the state <span class=""math-container"">$|0\rangle_A$</span> and into the state <span class=""math-container"">$|2\rangle_E$</span> if <span class=""math-container"">$A$</span> is in the state <span class=""math-container"">$|1\rangle_A$</span>. Furthermore, also unlike the depolarizing channel, the channel picks out a preferred basis for qubit <span class=""math-container"">$A$</span>; the basis <span class=""math-container"">$\left\{|0\rangle,|1\rangle\right\}$</span> is the only basis in which bit flips never occur.</p>
</blockquote>
<p>However, I am unable to understand the reasoning behind writing off the isometric representation in this manner. Preskill does not explain why the isometric representation should be in this way. Also he claims that the channel &quot;picks out a preferred basis for qubit <span class=""math-container"">$A$</span>&quot; which too is not evident to me. It would be helpful if someone explains the reasoning behind these.</p>
",What's the reasoning behind writing the isometric representation of a channel?,<quantum-operation><unitarity>,1,0,,,"What's the reasoning behind writing the isometric representation of a channel? <p>I am reading about phase damping channel from Preskill's notes. He writes off the unitary representation of the channel as</p>
<blockquote>
<p>Unitary representation. An isometric representation of the channel is
<span class=""math-container"">\begin{equation}
|0\rangle_{A} \rightarrow \sqrt{1-p}|0\rangle_{A}\otimes|0\rangle_{E}+\sqrt{p}|0\rangle_{A}\otimes|1\rangle_{E}
\end{equation}</span>
<span class=""math-container"">\begin{equation}
|1\rangle_{A} \rightarrow \sqrt{1-p}|1\rangle_{A}\otimes|0\rangle_{E}+\sqrt{p}|1\rangle_{A}\otimes|2\rangle_{E}
\end{equation}</span>
In this case, unlike the depolarizing channel, qubit <span class=""math-container"">$A$</span> does not make any
transitions in the <span class=""math-container"">$\left\{|0\rangle,|1\rangle\right\}$</span> basis. Instead, the environment &quot;scatters&quot; of the qubit occasionally (with probability <span class=""math-container"">$p$</span>), being kicked into the state
<span class=""math-container"">$|1\rangle_E$</span> if <span class=""math-container"">$A$</span> is in the state <span class=""math-container"">$|0\rangle_A$</span> and into the state <span class=""math-container"">$|2\rangle_E$</span> if <span class=""math-container"">$A$</span> is in the state <span class=""math-container"">$|1\rangle_A$</span>. Furthermore, also unlike the depolarizing channel, the channel picks out a preferred basis for qubit <span class=""math-container"">$A$</span>; the basis <span class=""math-container"">$\left\{|0\rangle,|1\rangle\right\}$</span> is the only basis in which bit flips never occur.</p>
</blockquote>
<p>However, I am unable to understand the reasoning behind writing off the isometric representation in this manner. Preskill does not explain why the isometric representation should be in this way. Also he claims that the channel &quot;picks out a preferred basis for qubit <span class=""math-container"">$A$</span>&quot; which too is not evident to me. It would be helpful if someone explains the reasoning behind these.</p>
",qc,reasoning behind writing isometric representation channel p reading phase damping channel preskill notes writes unitary representation channel blockquote p unitary representation isometric representation channel span equation e p e equation span equation e p e equation case unlike depolarizing channel qubit span make transitions span basis instead environment quot scatters quot qubit occasionally probability span p kicked state span span state span state span span state span furthermore also unlike depolarizing channel channel picks preferred basis qubit span basis span basis bit flips never p however unable understand reasoning behind writing isometric representation manner preskill explain isometric representation way also claims channel quot picks preferred basis qubit span quot evident would helpful someone explains reasoning behind,"[(3, 0.70789486), (11, 0.10175311), (17, 0.047558848), (18, 0.105532035), (19, 0.03594682)]"
33616,,2023-07-29 16:46:42,4,190,"<p>I am using Qiskit's QAOA for optimization and I would like to extract the probabilities distribution obtained in the optimization loop when running the circuit with the optimal parameters set. To do this I have extrapolated the QAOA circuit and assigned the optimal parameters, however the result is different with respect to the expected one (i.e., the optimal state has different probability than the one reported at the end of the optimization loop).
To replicate the optimal circuit output exactly, I have set the seed_simulator parameter in the AerSampler to a fixed value, however, when doing this, the optimizer stops working, in the sense that all the QAOA parameters values give the same energy, so the optimization process does not let the solution evolve.</p>
<p>Below the code used to set the sampler and run the optimization:</p>
<pre><code>from qiskit_aer.primitives import Sampler as AerSampler
from qiskit.algorithms.optimizers import COBYLA

QAOA_LAYERS=1

SAMPLER_QAOA=AerSampler(backend_options={&quot;method&quot;: &quot;statevector&quot;, &quot;seed_simulator&quot;:SEED})
SAMPLER_QAOA.set_options(run_options={&quot;shots&quot;:1000, &quot;seed&quot;:SEED},  transpiler_options={&quot;seed&quot;: SEED})

QAOA_MES = QAOA(sampler=SAMPLER_QAOA, optimizer=COBYLA(), initial_point=INITIAL_GUESS, reps=QAOA_LAYERS, callback=callback)
QAOA_SOLVER = MinimumEigenOptimizer(QAOA_MES)
QAOA_RESULT = QAOA_SOLVER.solve(QUBO_OPT_PROBLEM)
</code></pre>
<p>Here's the optimizer solutions list with the parameters beta and gamma sampled mean value (which does not change anyway)
<a href=""https://i.sstatic.net/no3aW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/no3aW.png"" alt=""enter image description here"" /></a></p>
<p>Is there any way to set the seed without destroying the optimization or to recover the optimal (and not the last) probability distribution?</p>
",Qiskit QAOA optimization does not work when setting simulation seed in AerSampler,<optimization><qaoa><qiskit>,0,1,,,"Qiskit QAOA optimization does not work when setting simulation seed in AerSampler <p>I am using Qiskit's QAOA for optimization and I would like to extract the probabilities distribution obtained in the optimization loop when running the circuit with the optimal parameters set. To do this I have extrapolated the QAOA circuit and assigned the optimal parameters, however the result is different with respect to the expected one (i.e., the optimal state has different probability than the one reported at the end of the optimization loop).
To replicate the optimal circuit output exactly, I have set the seed_simulator parameter in the AerSampler to a fixed value, however, when doing this, the optimizer stops working, in the sense that all the QAOA parameters values give the same energy, so the optimization process does not let the solution evolve.</p>
<p>Below the code used to set the sampler and run the optimization:</p>
<pre><code>from qiskit_aer.primitives import Sampler as AerSampler
from qiskit.algorithms.optimizers import COBYLA

QAOA_LAYERS=1

SAMPLER_QAOA=AerSampler(backend_options={&quot;method&quot;: &quot;statevector&quot;, &quot;seed_simulator&quot;:SEED})
SAMPLER_QAOA.set_options(run_options={&quot;shots&quot;:1000, &quot;seed&quot;:SEED},  transpiler_options={&quot;seed&quot;: SEED})

QAOA_MES = QAOA(sampler=SAMPLER_QAOA, optimizer=COBYLA(), initial_point=INITIAL_GUESS, reps=QAOA_LAYERS, callback=callback)
QAOA_SOLVER = MinimumEigenOptimizer(QAOA_MES)
QAOA_RESULT = QAOA_SOLVER.solve(QUBO_OPT_PROBLEM)
</code></pre>
<p>Here's the optimizer solutions list with the parameters beta and gamma sampled mean value (which does not change anyway)
<a href=""https://i.sstatic.net/no3aW.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/no3aW.png"" alt=""enter image description here"" /></a></p>
<p>Is there any way to set the seed without destroying the optimization or to recover the optimal (and not the last) probability distribution?</p>
",qc,qiskit qaoa optimization work setting simulation seed aersampler p using qiskit qaoa optimization would like extract probabilities distribution obtained optimization loop running circuit optimal parameters set extrapolated qaoa circuit assigned optimal parameters however result different respect expected one optimal state different probability one reported end optimization loop replicate optimal circuit output exactly set parameter aersampler fixed value however optimizer stops working sense qaoa parameters values give energy optimization process let solution p code used set sampler run optimization pre code import sampler aersampler import cobyla quot method quot quot statevector quot quot quot seed quot shots quot quot seed quot seed quot seed quot seed qaoa minimumeigenoptimizer p optimizer solutions list parameters beta gamma sampled mean value change anyway https nofollow noreferrer img https enter image description p way set seed without destroying optimization recover optimal last probability distribution,"[(0, 0.33897576), (1, 0.05914652), (3, 0.034617167), (4, 0.0922391), (14, 0.3123351), (17, 0.040879406), (19, 0.12084417)]"
33630,33634.0,2023-07-31 11:46:47,0,128,"<p>Stim's surface code implementation example includes additional detectors after the final round to measure data qubits.</p>
<pre><code>MX 1 3 5 8 10 12 15 17 19
DETECTOR(2, 0, 1) rec[-8] rec[-9] rec[-17] # L8 L15 Z14
DETECTOR(2, 4, 1) rec[-2] rec[-3] rec[-5] rec[-6] rec[-12] # d12 d19 d10 d17 Z18
DETECTOR(4, 2, 1) rec[-4] rec[-5] rec[-7] rec[-8] rec[-15] # d3 d10 L1 L8 Z9
DETECTOR(4, 6, 1) rec[-1] rec[-2] rec[-10] # d5 d12 Z13
</code></pre>
<p>Why are these detectors necessary? I understand that the decoder's role is to identify error locations based on measurements of the measurement qubits within each round, but would it also be acceptable to decode using measurements of the data qubits? Thank you very much in advance.</p>
",About detectors after final round of surface code,<stim><surface-code>,1,0,,,"About detectors after final round of surface code <p>Stim's surface code implementation example includes additional detectors after the final round to measure data qubits.</p>
<pre><code>MX 1 3 5 8 10 12 15 17 19
DETECTOR(2, 0, 1) rec[-8] rec[-9] rec[-17] # L8 L15 Z14
DETECTOR(2, 4, 1) rec[-2] rec[-3] rec[-5] rec[-6] rec[-12] # d12 d19 d10 d17 Z18
DETECTOR(4, 2, 1) rec[-4] rec[-5] rec[-7] rec[-8] rec[-15] # d3 d10 L1 L8 Z9
DETECTOR(4, 6, 1) rec[-1] rec[-2] rec[-10] # d5 d12 Z13
</code></pre>
<p>Why are these detectors necessary? I understand that the decoder's role is to identify error locations based on measurements of the measurement qubits within each round, but would it also be acceptable to decode using measurements of the data qubits? Thank you very much in advance.</p>
",qc,detectors final round surface code p stim surface code implementation example includes additional detectors final round measure data pre code mx 1 3 5 8 10 12 15 17 19 detector 2 0 1 rec rec rec l8 l15 z14 detector 2 4 1 rec rec rec rec rec d12 d19 d10 d17 z18 detector 4 2 1 rec rec rec rec rec d3 d10 l1 l8 z9 detector 4 6 1 rec rec rec d5 d12 z13 p detectors necessary understand decoder role identify error locations based measurements measurement qubits within round would also acceptable decode using measurements data qubits thank much,"[(1, 0.013133276), (5, 0.23689447), (6, 0.58220375), (10, 0.011456178), (14, 0.12611854), (15, 0.012114193), (17, 0.016668506)]"
33649,33652.0,2023-08-01 15:52:21,2,209,"<p>We are trying to simulate the erasure channel in stim, but it is a biased erasure - meaning that the replaced qubit doesn't have a depolarizing channel but a biased channel.
We saw that there is a function in stim &quot;HERALDED_ERASE&quot; channel, but here the replaced qubit has a depolarizing channel.
Can we use it to have another error channel on the replaced qubit?</p>
<p>Also, when we use MWPM to decode, is the weight of the edge (in the matching graph) associated with the erased qubit updated appropriately?</p>
<p>Thank you!</p>
",Implementing biased erasure error in stim,<stim>,2,0,,,"Implementing biased erasure error in stim <p>We are trying to simulate the erasure channel in stim, but it is a biased erasure - meaning that the replaced qubit doesn't have a depolarizing channel but a biased channel.
We saw that there is a function in stim &quot;HERALDED_ERASE&quot; channel, but here the replaced qubit has a depolarizing channel.
Can we use it to have another error channel on the replaced qubit?</p>
<p>Also, when we use MWPM to decode, is the weight of the edge (in the matching graph) associated with the erased qubit updated appropriately?</p>
<p>Thank you!</p>
",qc,implementing biased erasure error stim p trying simulate erasure channel stim biased erasure meaning replaced qubit depolarizing channel biased channel saw function stim quot quot channel replaced qubit depolarizing channel use another error channel replaced qubit p also use mwpm decode weight edge matching graph associated erased qubit updated appropriately p thank,"[(3, 0.13856171), (5, 0.20524889), (13, 0.06206588), (14, 0.27053806), (17, 0.23883897), (19, 0.08206127)]"
33657,,2023-08-02 10:15:44,1,330,"<p>I am working on QECC and, differently from classical ECC where everything is generally described by the parity-check matrices, QECC generally involves the low-level description of the circuit instead, enabling different kinds of noises.</p>
<p>I am interested in extracting the binary parity-check matrix from a given Stim circuit.</p>
<p>For example, given:</p>
<pre><code>import stim
L=5
p=0.005    
circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_x&quot;,
                                distance=L,
                                rounds=L,
                                after_clifford_depolarization=p,
                                before_round_data_depolarization=p,
                                after_reset_flip_probability=p,
                                before_measure_flip_probability=p)
</code></pre>
<p>how can we obtain the parity-check matrix H from circuit, i.e., <code>H = get_pc_matrix(circuit)</code>.</p>
<p>PS: I am aware of the nice other way around described <a href=""https://quantumcomputing.stackexchange.com/questions/27326/how-to-go-from-matrix-to-tableau-to-circuit-in-qiskit-or-stim"">here</a></p>
<p><strong>EDIT</strong>
I think I found a solution from the <a href=""https://github.com/oscarhiggott/BeliefMatching/tree/main"" rel=""nofollow noreferrer"">BeliefMatching</a> git repo, by using the function <code>detector_error_model_to_check_matrices</code></p>
",How to get parity check matrix from a circuit in stim,<error-correction><matrix-representation><stim>,0,4,,,"How to get parity check matrix from a circuit in stim <p>I am working on QECC and, differently from classical ECC where everything is generally described by the parity-check matrices, QECC generally involves the low-level description of the circuit instead, enabling different kinds of noises.</p>
<p>I am interested in extracting the binary parity-check matrix from a given Stim circuit.</p>
<p>For example, given:</p>
<pre><code>import stim
L=5
p=0.005    
circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_x&quot;,
                                distance=L,
                                rounds=L,
                                after_clifford_depolarization=p,
                                before_round_data_depolarization=p,
                                after_reset_flip_probability=p,
                                before_measure_flip_probability=p)
</code></pre>
<p>how can we obtain the parity-check matrix H from circuit, i.e., <code>H = get_pc_matrix(circuit)</code>.</p>
<p>PS: I am aware of the nice other way around described <a href=""https://quantumcomputing.stackexchange.com/questions/27326/how-to-go-from-matrix-to-tableau-to-circuit-in-qiskit-or-stim"">here</a></p>
<p><strong>EDIT</strong>
I think I found a solution from the <a href=""https://github.com/oscarhiggott/BeliefMatching/tree/main"" rel=""nofollow noreferrer"">BeliefMatching</a> git repo, by using the function <code>detector_error_model_to_check_matrices</code></p>
",qc,get parity check matrix circuit stim p working qecc differently classical ecc everything generally described matrices qecc generally involves description circuit instead enabling different kinds p interested extracting binary matrix given stim p example given pre code import stim circuit quot quot p obtain matrix h circuit code h circuit p ps aware nice way around described https p strong edit think found solution https nofollow noreferrer beliefmatching git repo using function code,"[(4, 0.15817438), (5, 0.078923985), (7, 0.16076559), (8, 0.07766994), (11, 0.05451777), (14, 0.3338036), (17, 0.080984876), (19, 0.053473286)]"
33667,,2023-08-03 15:37:13,1,111,"<p>Months or years ago, in a remote part of the globe, someone accessed an IBM Quantum computer online to perform a real experiment. She saved the resulting measurement outcomes of the algorithm in csv format on her computer, and she doesn't have access to IBM's experimental data files or job IDs anymore. She was cautious with her methods, so while she took the steps to perform measurement error mitigation, she kept raw measurement data separate from the data used to calibrate the error mitigation fitter. As a result, she now has two tables in her computer, which can be imported as Pandas dataframes: <code>calibration_df</code> and <code>raw_results_df</code>.</p>
<p>In both dataframes, each row represents a circuit, and there are only two columns: 0 and 1, containing the counts of each possible output of the single qubit measured. Naturally, the <code>calibration_df</code> contains only two rows: &quot;Prep 0&quot; and &quot;Prep 1&quot;, the circuits used to gather the data for calibration of measurement error mitigation. The <code>raw_results_df</code> contains the results of the circuits used for the actual experiment. Let's say it has 10 rows.</p>
<p>Since she only has access to these two dataframes and she knows that, in principle, the data in <code>calibration_df</code> could be used to mitigate the <code>raw_results_df</code> and produce the corresponding <code>mitigated_results_df</code>, she would like to do just that using the latest <code>Qiskit</code> methods.  All the measurement error mitigation tutorials she has been able to find seem to require the calibration results in the form of a <code>Result</code> object, however, which she doesn't have access to anymore. Furthermore, trying to import and use <code>CompleteMeasFitter</code>, she runs into <code>DeprecationWarning: The class ``qiskit.utils.mitigation.fitters.CompleteMeasFitter`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi_migration.</code>.</p>
<p>Do you have an idea how she could achieve that? Some help would be appreciated.</p>
<pre><code>import pandas as pd
calibration_df = pd.DataFrame([{'0':9293,'1':707},{'0':434,'1':9566}], index=[['Prep 0','Prep 1']])
raw_results_df = pd.DataFrame([{'0':1500,'1':8500},{'0':6234,'1':3766},{'0':4213,'1':5787},{'0':8124,'1':1876},{'0':3198,'1':6802},
                               {'0':8462,'1':1538},{'0':5791,'1':4209},{'0':2443,'1':7557},{'0':4897,'1':5103},{'0':9001,'1':999}])
</code></pre>
","Qiskit's measurement error mitigation from counts data only, in 2023",<qiskit><ibm-q-experience><error-mitigation>,1,0,,,"Qiskit's measurement error mitigation from counts data only, in 2023 <p>Months or years ago, in a remote part of the globe, someone accessed an IBM Quantum computer online to perform a real experiment. She saved the resulting measurement outcomes of the algorithm in csv format on her computer, and she doesn't have access to IBM's experimental data files or job IDs anymore. She was cautious with her methods, so while she took the steps to perform measurement error mitigation, she kept raw measurement data separate from the data used to calibrate the error mitigation fitter. As a result, she now has two tables in her computer, which can be imported as Pandas dataframes: <code>calibration_df</code> and <code>raw_results_df</code>.</p>
<p>In both dataframes, each row represents a circuit, and there are only two columns: 0 and 1, containing the counts of each possible output of the single qubit measured. Naturally, the <code>calibration_df</code> contains only two rows: &quot;Prep 0&quot; and &quot;Prep 1&quot;, the circuits used to gather the data for calibration of measurement error mitigation. The <code>raw_results_df</code> contains the results of the circuits used for the actual experiment. Let's say it has 10 rows.</p>
<p>Since she only has access to these two dataframes and she knows that, in principle, the data in <code>calibration_df</code> could be used to mitigate the <code>raw_results_df</code> and produce the corresponding <code>mitigated_results_df</code>, she would like to do just that using the latest <code>Qiskit</code> methods.  All the measurement error mitigation tutorials she has been able to find seem to require the calibration results in the form of a <code>Result</code> object, however, which she doesn't have access to anymore. Furthermore, trying to import and use <code>CompleteMeasFitter</code>, she runs into <code>DeprecationWarning: The class ``qiskit.utils.mitigation.fitters.CompleteMeasFitter`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi_migration.</code>.</p>
<p>Do you have an idea how she could achieve that? Some help would be appreciated.</p>
<pre><code>import pandas as pd
calibration_df = pd.DataFrame([{'0':9293,'1':707},{'0':434,'1':9566}], index=[['Prep 0','Prep 1']])
raw_results_df = pd.DataFrame([{'0':1500,'1':8500},{'0':6234,'1':3766},{'0':4213,'1':5787},{'0':8124,'1':1876},{'0':3198,'1':6802},
                               {'0':8462,'1':1538},{'0':5791,'1':4209},{'0':2443,'1':7557},{'0':4897,'1':5103},{'0':9001,'1':999}])
</code></pre>
",qc,qiskit measurement error mitigation counts data 2023 p months years ago remote part globe someone accessed ibm quantum computer online perform real experiment saved resulting measurement outcomes algorithm csv format computer access ibm experimental data files job ids anymore cautious methods took steps perform measurement error mitigation kept raw measurement data separate data used calibrate error mitigation fitter result two tables computer imported pandas dataframes code code p dataframes row represents circuit two columns 0 1 containing counts possible output single qubit measured naturally code contains two rows quot prep 0 quot quot prep 1 quot circuits used gather data calibration measurement error mitigation code contains results circuits used actual experiment let say 10 p since access two dataframes knows principle data code could used mitigate code produce corresponding code would like using latest code qiskit methods measurement error mitigation tutorials able find seem require calibration results form code result object however access anymore furthermore trying import use code completemeasfitter runs code deprecationwarning class deprecated removed earlier 3 months release date code migration guidelines visit https p idea could achieve help would pre code import pandas pd 0 1,"[(0, 0.12535465), (2, 0.036341686), (8, 0.15372951), (13, 0.04199205), (14, 0.5758412), (16, 0.019053284), (17, 0.020814713), (19, 0.026209459)]"
33700,33703.0,2023-08-06 11:27:01,1,155,"<p>I want to simulate the error correction procedure for a CNOT gate on surface code and RHG cube, made by the lattice surgery process of &quot;merge and split&quot;.</p>
<p>In this case, the code has an H-shape, with four &quot;Z&quot; (smooth) surface boundaries (two in spatial directions and two in the time direction), four &quot;X&quot; (rough) surface boundaries in the time direction, and two &quot;X&quot; (rough) surface boundaries in the spatial direction.</p>
<p>How should I define the logical error chains in this situation? Can I use Pymatching in this situation? How can I verify whether the decoding produced a logical error?</p>
",Using Pymatching to decode lattice surgery process,<surface-code><pymatching><measurement-based-qc><lattice-surgery><logical-gates>,1,0,,,"Using Pymatching to decode lattice surgery process <p>I want to simulate the error correction procedure for a CNOT gate on surface code and RHG cube, made by the lattice surgery process of &quot;merge and split&quot;.</p>
<p>In this case, the code has an H-shape, with four &quot;Z&quot; (smooth) surface boundaries (two in spatial directions and two in the time direction), four &quot;X&quot; (rough) surface boundaries in the time direction, and two &quot;X&quot; (rough) surface boundaries in the spatial direction.</p>
<p>How should I define the logical error chains in this situation? Can I use Pymatching in this situation? How can I verify whether the decoding produced a logical error?</p>
",qc,using pymatching decode lattice surgery process p want simulate error correction procedure cnot gate surface code rhg cube made lattice surgery process quot merge split quot p case code four quot z quot smooth surface boundaries two spatial directions two time direction four quot x quot rough surface boundaries time direction two quot x quot rough surface boundaries spatial p define logical error chains situation use pymatching situation verify whether decoding produced logical error,"[(5, 0.33371723), (7, 0.07862895), (10, 0.025237098), (13, 0.22461347), (14, 0.044949774), (16, 0.054625783), (17, 0.050158355), (18, 0.06140853), (19, 0.12517501)]"
33709,,2023-08-07 01:30:08,3,106,"<p>A single qubit is represented with a bloch sphere and  implemented on an electron with only two energy values from lots of them. <BR>
So, I am confused about why  an energy range is represented as a vector on a sphere, and also with the relation between the spin vector from Dirac or Pauli equation and the Bloch Vector. I think the first is a SO3 vector on real space, and the bloch one is SU2 on internal space. So Bloch sphere is not the  real spin?
When we rotate that spin with microwaves are we rotating the real spin?</p>
",Is the Bloch sphere the same as the electron spin?,<bloch-sphere><spin>,0,1,,,"Is the Bloch sphere the same as the electron spin? <p>A single qubit is represented with a bloch sphere and  implemented on an electron with only two energy values from lots of them. <BR>
So, I am confused about why  an energy range is represented as a vector on a sphere, and also with the relation between the spin vector from Dirac or Pauli equation and the Bloch Vector. I think the first is a SO3 vector on real space, and the bloch one is SU2 on internal space. So Bloch sphere is not the  real spin?
When we rotate that spin with microwaves are we rotating the real spin?</p>
",qc,bloch sphere electron spin p single qubit represented bloch sphere implemented electron two energy values lots br confused energy range represented vector sphere also relation spin vector dirac pauli equation bloch vector think first so3 vector real space bloch one su2 internal space bloch sphere real spin rotate spin microwaves rotating real spin,"[(0, 0.024059016), (3, 0.08528084), (8, 0.105648585), (9, 0.056891978), (13, 0.6495554), (17, 0.07587923)]"
33714,33715.0,2023-08-07 18:33:19,5,209,"<p>I've been reading about quantum channels from a couple of sources and have some doubts regarding some mathematical perspectives and properties of quantum channels. I've listed them below:</p>
<ol>
<li><p>It is known that quantum channels map density operators on Hilbert space (say <span class=""math-container"">$\mathcal{H}_A$</span> to another space (say, <span class=""math-container"">$\mathcal{H}_B$</span>). Is it the standard convention to express any channel as a liner map <span class=""math-container"">$\mathcal{N}:D(\mathcal{H}_A) \rightarrow D(\mathcal{H}_B)$</span> or is <span class=""math-container"">$\mathcal{N}:B(\mathcal{H}_A) \rightarrow B(\mathcal{H}_B)$</span> more appropriate? Here <span class=""math-container"">$D(\mathcal{H})$</span> is the set of density operators on Hilbert space <span class=""math-container"">$\mathcal{H}$</span> while <span class=""math-container"">$B(\mathcal{H}$</span> is the space of bounded linear operators.</p>
</li>
<li><p>In some texts, some effort is made to differentiate channels as linear maps instead of linear operators. But aren't linear maps the same as linear operators acting on a higher dimension? Or are there some properties unique to linear maps to require such an emphasis?</p>
</li>
<li><p>Finally, are quantum channels bounded maps? Based on my naive reasoning, I think they should be bounded, given that they map density operators to density operators (which are known to be bounded). I wanted to know if there is a situation or an example for which this would fail.</p>
</li>
</ol>
<p>It would be great if you could drop the link to those questions that have been answered already. Thanks!</p>
",Are quantum channels bounded linear maps?,<quantum-operation><terminology-and-notation>,2,0,,,"Are quantum channels bounded linear maps? <p>I've been reading about quantum channels from a couple of sources and have some doubts regarding some mathematical perspectives and properties of quantum channels. I've listed them below:</p>
<ol>
<li><p>It is known that quantum channels map density operators on Hilbert space (say <span class=""math-container"">$\mathcal{H}_A$</span> to another space (say, <span class=""math-container"">$\mathcal{H}_B$</span>). Is it the standard convention to express any channel as a liner map <span class=""math-container"">$\mathcal{N}:D(\mathcal{H}_A) \rightarrow D(\mathcal{H}_B)$</span> or is <span class=""math-container"">$\mathcal{N}:B(\mathcal{H}_A) \rightarrow B(\mathcal{H}_B)$</span> more appropriate? Here <span class=""math-container"">$D(\mathcal{H})$</span> is the set of density operators on Hilbert space <span class=""math-container"">$\mathcal{H}$</span> while <span class=""math-container"">$B(\mathcal{H}$</span> is the space of bounded linear operators.</p>
</li>
<li><p>In some texts, some effort is made to differentiate channels as linear maps instead of linear operators. But aren't linear maps the same as linear operators acting on a higher dimension? Or are there some properties unique to linear maps to require such an emphasis?</p>
</li>
<li><p>Finally, are quantum channels bounded maps? Based on my naive reasoning, I think they should be bounded, given that they map density operators to density operators (which are known to be bounded). I wanted to know if there is a situation or an example for which this would fail.</p>
</li>
</ol>
<p>It would be great if you could drop the link to those questions that have been answered already. Thanks!</p>
",qc,quantum channels bounded linear maps p reading quantum channels couple sources doubts regarding mathematical perspectives properties quantum channels listed ol li p known quantum channels map density operators hilbert space say span h another space say span h standard convention express channel liner map span n h h span n b h b h appropriate span h set density operators hilbert space span h span b h space bounded linear li p texts effort made differentiate channels linear maps instead linear operators linear maps linear operators acting higher dimension properties unique linear maps require emphasis li p finally quantum channels bounded maps based naive reasoning think bounded given map density operators density operators known bounded wanted know situation example would p would great could drop link questions answered already thanks,"[(3, 0.7402341), (7, 0.142728), (9, 0.050616466), (11, 0.04298132), (17, 0.014639701)]"
33720,,2023-08-08 09:26:05,1,470,"<p><a href=""https://i.sstatic.net/uob8y.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uob8y.png"" alt=""enter image description here"" /></a>I am trying to draw the circuit in pennylane but even after my hours of trying I am completely unsuccessful.
Below is my code. Any little guidance of yours can help me a lot.</p>
<pre><code>from keras.datasets import mnist

import matplotlib as mpl
import matplotlib.pyplot as plt

import pennylane as qml
from pennylane import numpy as np



## device and circuit characteristics
width = 4
depth = 8

dev = qml.device(&quot;default.qubit&quot;, wires=width)
wires = list(range(width))


def layer(x1, params, wires, i0=0, inc=1):
    i = i0
    
    for j, wire in enumerate(wires):
       
        qml.Hadamard(wires=[wire])
        
        qml.RZ(x1[i % len(x1)], wires=[wire])
        i += inc
        qml.RY(params[0, j], wires=[wire])
        
    qml.broadcast(unitary=qml.CRZ, pattern=&quot;ring&quot;, wires=wires, parameters=params[1])


@qml.template
def ansatz(x1, params, wires):   
    
    for j, layer_params in enumerate(params):
        layer(x1, layer_params, wires, i0=j * len(wires))
        
        



@qml.qnode(dev)
def kernel(x1, x2, params):
    ansatz(x1, params, wires)
    qml.adjoint(ansatz)(x2, params, wires)                      
    return qml.expval(qml.Projector([0]*width, wires=wires))


x1 = np.array([0.5, 0.25])

x2 = np.array([0.28571429, 0.53571429])

params = np.array([[[5.27502056, 1.47427201, 4.93076496, 2.46091687],
  [5.31970254, 3.72079515, 5.23318151, 3.6141986 ]],

 [[4.56873422, 4.71736634, 3.74526732, 4.03018843],
  [2.50768043, 6.05648213, 0.15691596, 4.6339621 ]],

 [[3.13801229, 4.06608748, 3.67299568, 0.56942335],
  [3.7249661,  0.21089213, 1.81957038, 5.11239481]],

 [[0.23371406, 0.38418188, 1.57283641, 2.1281051 ],
  [4.82044232, 2.29357766, 2.28309303, 1.36251918]],

 [[3.81316379, 1.72378489, 5.33909833, 1.99670676],
  [0.95241059, 4.91302177, 5.11174524, 0.50581628]],

 [[2.93171839, 4.72425322, 4.13123708, 2.1082139 ],
  [3.44454441, 3.57751799, 4.82533803, 3.01520779]],

 [[4.82192352, 4.9103957,  5.62978572, 2.72576366],
  [2.52244612, 2.06081289, 6.28092847, 4.55329168]],

 [[5.67932649, 1.43286835, 6.13243934, 3.72696941],
  [5.50192702, 1.69022441, 3.61985605, 4.94172026]]])


print(qml.draw(kernel(x1, x2, params), charset=&quot;unicode&quot;)) # PROBLEM AREA

#   print(qml.draw(circuit_qnode)(X_train_dist_zero_not_zero[0], params))

# plt.show()
</code></pre>
<p><strong>Edit</strong>
I am finally able to draw the circuit by using latest pennylane, commenting out the line<code>@qml.template</code> and adding the line fig, ax = <code>qml.draw_mpl(kernel)(x1, x2, params)</code>. I am still not able to understand the circuit. Please guide me how to understand this circuit? Also, is there any better way to draw the circuit?</p>
<pre><code>    from keras.datasets import mnist
from keras.datasets import mnist

# import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import pennylane as qml
from pennylane import numpy as np


## device and circuit characteristics
width = 4
depth = 8

dev = qml.device(&quot;default.qubit&quot;, wires=width)
wires = list(range(width))
print(&quot;The value of wires= &quot;, wires)

# Our Ansatz
def layer(x1, params, wires, i0=0, inc=1):
    &quot;&quot;&quot;Building block of the embedding Ansatz&quot;&quot;&quot;
    i = i0
    
    for j, wire in enumerate(wires):
       
        qml.Hadamard(wires=[wire])
        
        qml.RZ(x1[i % len(x1)], wires=[wire])
        i += inc
        qml.RY(params[0, j], wires=[wire])
        
    qml.broadcast(unitary=qml.CRZ, pattern=&quot;ring&quot;, wires=wires, parameters=params[1])


# @qml.template # type: ignore
def ansatz(x1, params, wires):   
    &quot;&quot;&quot;The embedding Ansatz&quot;&quot;&quot;
    for j, layer_params in enumerate(params):
        layer(x1, layer_params, wires, i0=j * len(wires))
        
        


# init the embedding kernel
@qml.qnode(dev)
def kernel(x1, x2, params):
    ansatz(x1, params, wires)
    qml.adjoint(ansatz)(x2, params, wires)                      # type: ignore
    return qml.expval(qml.Projector([0]*width, wires=wires))


x1 = np.array([0.5, 0.25])

x2 = np.array([0.28571429, 0.53571429])

params = np.array([[[5.27502056, 1.47427201, 4.93076496, 2.46091687],
  [5.31970254, 3.72079515, 5.23318151, 3.6141986 ]],

 [[4.56873422, 4.71736634, 3.74526732, 4.03018843],
  [2.50768043, 6.05648213, 0.15691596, 4.6339621 ]],

 [[3.13801229, 4.06608748, 3.67299568, 0.56942335],
  [3.7249661,  0.21089213, 1.81957038, 5.11239481]],

 [[0.23371406, 0.38418188, 1.57283641, 2.1281051 ],
  [4.82044232, 2.29357766, 2.28309303, 1.36251918]],

 [[3.81316379, 1.72378489, 5.33909833, 1.99670676],
  [0.95241059, 4.91302177, 5.11174524, 0.50581628]],

 [[2.93171839, 4.72425322, 4.13123708, 2.1082139 ],
  [3.44454441, 3.57751799, 4.82533803, 3.01520779]],

 [[4.82192352, 4.9103957,  5.62978572, 2.72576366],
  [2.52244612, 2.06081289, 6.28092847, 4.55329168]],

 [[5.67932649, 1.43286835, 6.13243934, 3.72696941],
  [5.50192702, 1.69022441, 3.61985605, 4.94172026]]])


# print(qml.draw(kernel(x1, x2, params), charset=&quot;unicode&quot;)) # type: ignore

fig, ax = qml.draw_mpl(kernel)(x1, x2, params)

#   print(qml.draw(circuit_qnode)(X_train_dist_zero_not_zero[0], params))

plt.show()
</code></pre>
",Drawing circuit in pennylane,<pennylane><programming>,0,0,,,"Drawing circuit in pennylane <p><a href=""https://i.sstatic.net/uob8y.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/uob8y.png"" alt=""enter image description here"" /></a>I am trying to draw the circuit in pennylane but even after my hours of trying I am completely unsuccessful.
Below is my code. Any little guidance of yours can help me a lot.</p>
<pre><code>from keras.datasets import mnist

import matplotlib as mpl
import matplotlib.pyplot as plt

import pennylane as qml
from pennylane import numpy as np



## device and circuit characteristics
width = 4
depth = 8

dev = qml.device(&quot;default.qubit&quot;, wires=width)
wires = list(range(width))


def layer(x1, params, wires, i0=0, inc=1):
    i = i0
    
    for j, wire in enumerate(wires):
       
        qml.Hadamard(wires=[wire])
        
        qml.RZ(x1[i % len(x1)], wires=[wire])
        i += inc
        qml.RY(params[0, j], wires=[wire])
        
    qml.broadcast(unitary=qml.CRZ, pattern=&quot;ring&quot;, wires=wires, parameters=params[1])


@qml.template
def ansatz(x1, params, wires):   
    
    for j, layer_params in enumerate(params):
        layer(x1, layer_params, wires, i0=j * len(wires))
        
        



@qml.qnode(dev)
def kernel(x1, x2, params):
    ansatz(x1, params, wires)
    qml.adjoint(ansatz)(x2, params, wires)                      
    return qml.expval(qml.Projector([0]*width, wires=wires))


x1 = np.array([0.5, 0.25])

x2 = np.array([0.28571429, 0.53571429])

params = np.array([[[5.27502056, 1.47427201, 4.93076496, 2.46091687],
  [5.31970254, 3.72079515, 5.23318151, 3.6141986 ]],

 [[4.56873422, 4.71736634, 3.74526732, 4.03018843],
  [2.50768043, 6.05648213, 0.15691596, 4.6339621 ]],

 [[3.13801229, 4.06608748, 3.67299568, 0.56942335],
  [3.7249661,  0.21089213, 1.81957038, 5.11239481]],

 [[0.23371406, 0.38418188, 1.57283641, 2.1281051 ],
  [4.82044232, 2.29357766, 2.28309303, 1.36251918]],

 [[3.81316379, 1.72378489, 5.33909833, 1.99670676],
  [0.95241059, 4.91302177, 5.11174524, 0.50581628]],

 [[2.93171839, 4.72425322, 4.13123708, 2.1082139 ],
  [3.44454441, 3.57751799, 4.82533803, 3.01520779]],

 [[4.82192352, 4.9103957,  5.62978572, 2.72576366],
  [2.52244612, 2.06081289, 6.28092847, 4.55329168]],

 [[5.67932649, 1.43286835, 6.13243934, 3.72696941],
  [5.50192702, 1.69022441, 3.61985605, 4.94172026]]])


print(qml.draw(kernel(x1, x2, params), charset=&quot;unicode&quot;)) # PROBLEM AREA

#   print(qml.draw(circuit_qnode)(X_train_dist_zero_not_zero[0], params))

# plt.show()
</code></pre>
<p><strong>Edit</strong>
I am finally able to draw the circuit by using latest pennylane, commenting out the line<code>@qml.template</code> and adding the line fig, ax = <code>qml.draw_mpl(kernel)(x1, x2, params)</code>. I am still not able to understand the circuit. Please guide me how to understand this circuit? Also, is there any better way to draw the circuit?</p>
<pre><code>    from keras.datasets import mnist
from keras.datasets import mnist

# import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

import pennylane as qml
from pennylane import numpy as np


## device and circuit characteristics
width = 4
depth = 8

dev = qml.device(&quot;default.qubit&quot;, wires=width)
wires = list(range(width))
print(&quot;The value of wires= &quot;, wires)

# Our Ansatz
def layer(x1, params, wires, i0=0, inc=1):
    &quot;&quot;&quot;Building block of the embedding Ansatz&quot;&quot;&quot;
    i = i0
    
    for j, wire in enumerate(wires):
       
        qml.Hadamard(wires=[wire])
        
        qml.RZ(x1[i % len(x1)], wires=[wire])
        i += inc
        qml.RY(params[0, j], wires=[wire])
        
    qml.broadcast(unitary=qml.CRZ, pattern=&quot;ring&quot;, wires=wires, parameters=params[1])


# @qml.template # type: ignore
def ansatz(x1, params, wires):   
    &quot;&quot;&quot;The embedding Ansatz&quot;&quot;&quot;
    for j, layer_params in enumerate(params):
        layer(x1, layer_params, wires, i0=j * len(wires))
        
        


# init the embedding kernel
@qml.qnode(dev)
def kernel(x1, x2, params):
    ansatz(x1, params, wires)
    qml.adjoint(ansatz)(x2, params, wires)                      # type: ignore
    return qml.expval(qml.Projector([0]*width, wires=wires))


x1 = np.array([0.5, 0.25])

x2 = np.array([0.28571429, 0.53571429])

params = np.array([[[5.27502056, 1.47427201, 4.93076496, 2.46091687],
  [5.31970254, 3.72079515, 5.23318151, 3.6141986 ]],

 [[4.56873422, 4.71736634, 3.74526732, 4.03018843],
  [2.50768043, 6.05648213, 0.15691596, 4.6339621 ]],

 [[3.13801229, 4.06608748, 3.67299568, 0.56942335],
  [3.7249661,  0.21089213, 1.81957038, 5.11239481]],

 [[0.23371406, 0.38418188, 1.57283641, 2.1281051 ],
  [4.82044232, 2.29357766, 2.28309303, 1.36251918]],

 [[3.81316379, 1.72378489, 5.33909833, 1.99670676],
  [0.95241059, 4.91302177, 5.11174524, 0.50581628]],

 [[2.93171839, 4.72425322, 4.13123708, 2.1082139 ],
  [3.44454441, 3.57751799, 4.82533803, 3.01520779]],

 [[4.82192352, 4.9103957,  5.62978572, 2.72576366],
  [2.52244612, 2.06081289, 6.28092847, 4.55329168]],

 [[5.67932649, 1.43286835, 6.13243934, 3.72696941],
  [5.50192702, 1.69022441, 3.61985605, 4.94172026]]])


# print(qml.draw(kernel(x1, x2, params), charset=&quot;unicode&quot;)) # type: ignore

fig, ax = qml.draw_mpl(kernel)(x1, x2, params)

#   print(qml.draw(circuit_qnode)(X_train_dist_zero_not_zero[0], params))

plt.show()
</code></pre>
",qc,drawing circuit pennylane p https nofollow noreferrer img https enter image description trying draw circuit pennylane even hours trying completely unsuccessful code little guidance help pre code import mnist import matplotlib mpl import plt import pennylane qml pennylane import numpy np device circuit characteristics width 4 depth 8 dev quot quot wires list range width def layer x1 params wires i0 j wire enumerate wires wire x1 len x1 wire inc params 0 j wire quot ring quot 1 def ansatz x1 params wires j enumerate params layer x1 wires len wires dev def kernel x1 x2 params ansatz x1 params wires ansatz x2 params wires return 0 width x1 x2 params print kernel x1 x2 params quot unicode quot problem area print 0 params p strong edit finally able draw circuit using latest pennylane commenting line code adding line fig ax code kernel x1 x2 params still able understand circuit please guide understand circuit also better way draw circuit pre code import mnist import mnist import numpy np import matplotlib mpl import plt import pennylane qml pennylane import numpy np device circuit characteristics width 4 depth 8 dev quot quot wires list range width print quot value quot wires ansatz def layer x1 params wires quot quot quot building block embedding ansatz quot quot quot i0 j wire enumerate wires wire x1 len x1 wire inc params 0 j wire quot ring quot 1 type ignore def ansatz x1 params wires quot quot quot embedding ansatz quot quot quot j enumerate params layer x1 wires len wires init embedding kernel dev def kernel x1 x2 params ansatz x1 params wires ansatz x2 params wires type ignore return 0 width x1 x2 params print kernel x1 x2 params quot unicode quot type ignore fig ax kernel x1 x2 params print 0 params,"[(0, 0.6290619), (2, 0.012282238), (4, 0.039717816), (13, 0.03931704), (14, 0.02309969), (15, 0.021151511), (17, 0.10408561), (19, 0.1213026)]"
33731,,2023-08-08 17:11:32,0,55,"<p>I'm currently grappling with a challenge in comprehending the inverse channel of the Pauli 4 POVM. The POVM elements are defined as follows:
<span class=""math-container"">$
M_0 = \frac{1}{3} |0\rangle\langle0|, \quad M_1 = \frac{1}{3} |1 \rangle\langle1|, \quad M_2 = \frac{1}{3} |l \rangle\langle l|, \quad M_3 = \frac{1}{3} (|1 \rangle\langle1| + |- \rangle\langle-| + |r \rangle\langle r|).
$</span>
In their paper [1], the authors claim that due to the rank-2 property of <span class=""math-container"">$M_3$</span>, we can deduce the following: &quot;When the outcome corresponds to index 3, we consider the eigenvector <span class=""math-container"">$|t\rangle$</span> associated with the eigenvalue <span class=""math-container"">$\frac{1}{2} (1 + \frac{1}{\sqrt{3}})$</span> instead of the other eigenvector associated with <span class=""math-container"">$\frac{1}{2} (1 - \frac{1}{\sqrt{3}})$</span>&quot;. However, I'm uncertain about the reasoning behind this assertion. I would greatly appreciate some clarification on this matter.
In addition, I am not sure how they did find the eigenvalue above.</p>
<p>Thank you.
Reference:
[1] <a href=""https://arxiv.org/abs/2105.05992"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2105.05992</a></p>
",Inverse channel of the Pauli 4 POVM,<quantum-gate><quantum-state><shadow-tomography>,1,0,,,"Inverse channel of the Pauli 4 POVM <p>I'm currently grappling with a challenge in comprehending the inverse channel of the Pauli 4 POVM. The POVM elements are defined as follows:
<span class=""math-container"">$
M_0 = \frac{1}{3} |0\rangle\langle0|, \quad M_1 = \frac{1}{3} |1 \rangle\langle1|, \quad M_2 = \frac{1}{3} |l \rangle\langle l|, \quad M_3 = \frac{1}{3} (|1 \rangle\langle1| + |- \rangle\langle-| + |r \rangle\langle r|).
$</span>
In their paper [1], the authors claim that due to the rank-2 property of <span class=""math-container"">$M_3$</span>, we can deduce the following: &quot;When the outcome corresponds to index 3, we consider the eigenvector <span class=""math-container"">$|t\rangle$</span> associated with the eigenvalue <span class=""math-container"">$\frac{1}{2} (1 + \frac{1}{\sqrt{3}})$</span> instead of the other eigenvector associated with <span class=""math-container"">$\frac{1}{2} (1 - \frac{1}{\sqrt{3}})$</span>&quot;. However, I'm uncertain about the reasoning behind this assertion. I would greatly appreciate some clarification on this matter.
In addition, I am not sure how they did find the eigenvalue above.</p>
<p>Thank you.
Reference:
[1] <a href=""https://arxiv.org/abs/2105.05992"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2105.05992</a></p>
",qc,inverse channel pauli 4 povm p currently grappling challenge comprehending inverse channel pauli 4 povm povm elements defined follows span 1 3 1 3 1 3 1 3 paper 1 authors claim due property span deduce following quot outcome corresponds index 3 consider eigenvector span associated eigenvalue span 1 2 1 1 3 instead eigenvector associated span 1 2 1 1 3 quot however uncertain reasoning behind assertion would greatly appreciate clarification matter addition sure find eigenvalue p thank reference 1 https nofollow noreferrer https,"[(2, 0.27776036), (3, 0.60081726), (4, 0.080978446), (17, 0.012911428), (19, 0.025706805)]"
33732,,2023-08-08 19:48:31,3,273,"<p>We're trying to simulate erasure errors on the surface code using Stim. The threshold for erasure errors on the data qubits (after initialization) is 50%.</p>
<p>We followed the following post: <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a></p>
<p>However, we end up with a threshold of ~20%. This is the same as this post: <a href=""https://quantumcomputing.stackexchange.com/questions/30074/threshold-value-when-simulating-erasures-with-stim?noredirect=1&amp;lq=1"">Threshold value when simulating erasures with stim</a></p>
<p>That post did not get an answer and so we bring it up again here.</p>
<hr />
<p>This is our circuit for the unrotated <span class=""math-container"">$d=3$</span> surface code</p>
<pre><code>RX 0 2 4 10 12 14 20 22 24 6 8 16 18 1 3 5 7 9 11 13 15 17 19 21 23
TICK
R 999
E(0.025) X999
E(0.025) X0 X999
E(0.025) Y0 X999
E(0.025) Z0 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X2 X999
E(0.025) Y2 X999
E(0.025) Z2 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X4 X999
E(0.025) Y4 X999
E(0.025) Z4 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X10 X999
E(0.025) Y10 X999
E(0.025) Z10 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X12 X999
E(0.025) Y12 X999
E(0.025) Z12 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X14 X999
E(0.025) Y14 X999
E(0.025) Z14 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X20 X999
E(0.025) Y20 X999
E(0.025) Z20 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X22 X999
E(0.025) Y22 X999
E(0.025) Z22 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X24 X999
E(0.025) Y24 X999
E(0.025) Z24 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X6 X999
E(0.025) Y6 X999
E(0.025) Z6 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X8 X999
E(0.025) Y8 X999
E(0.025) Z8 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X16 X999
E(0.025) Y16 X999
E(0.025) Z16 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X18 X999
E(0.025) Y18 X999
E(0.025) Z18 X999
M 999
DETECTOR rec[-1]
CZ 6 1 8 3 16 11 18 13
CX 5 10 7 12 9 14 15 20 17 22 19 24
TICK
CZ 2 1 4 3 12 11 14 13 22 21 24 23
CX 5 6 7 8 15 16 17 18
TICK
CZ 0 1 2 3 10 11 12 13 20 21 22 23
CX 7 6 9 8 17 16 19 18
TICK
CZ 6 11 8 13 16 21 18 23
CX 5 0 7 2 9 4 15 10 17 12 19 14
TICK
MRX 1 3 5 7 9 11 13 15 17 19 21 23
DETECTOR rec[-10]
DETECTOR rec[-9]
DETECTOR rec[-8]
DETECTOR rec[-5]
DETECTOR rec[-4]
DETECTOR rec[-3]
REPEAT 2 {
    TICK
    CZ 6 1 8 3 16 11 18 13
    CX 5 10 7 12 9 14 15 20 17 22 19 24
    TICK
    CZ 2 1 4 3 12 11 14 13 22 21 24 23
    CX 5 6 7 8 15 16 17 18
    TICK
    CZ 0 1 2 3 10 11 12 13 20 21 22 23
    CX 7 6 9 8 17 16 19 18
    TICK
    CZ 6 11 8 13 16 21 18 23
    CX 5 0 7 2 9 4 15 10 17 12 19 14
    TICK
    MRX 1 3 5 7 9 11 13 15 17 19 21 23
    DETECTOR rec[-1] rec[-53]
    DETECTOR rec[-2] rec[-54]
    DETECTOR rec[-3] rec[-55]
    DETECTOR rec[-4] rec[-56]
    DETECTOR rec[-5] rec[-57]
    DETECTOR rec[-6] rec[-58]
    DETECTOR rec[-7] rec[-59]
    DETECTOR rec[-8] rec[-60]
    DETECTOR rec[-9] rec[-61]
    DETECTOR rec[-10] rec[-62]
    DETECTOR rec[-11] rec[-63]
    DETECTOR rec[-12] rec[-64]
}
MX 0 2 4 6 8 10 12 14 16 18 20 22 24
DETECTOR rec[-23] rec[-8] rec[-10] rec[-13]
DETECTOR rec[-22] rec[-7] rec[-9] rec[-10] rec[-12]
DETECTOR rec[-21] rec[-6] rec[-9] rec[-11]
DETECTOR rec[-18] rec[-3] rec[-5] rec[-8]
DETECTOR rec[-17] rec[-2] rec[-4] rec[-5] rec[-7]
DETECTOR rec[-16] rec[-1] rec[-4] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-13] rec[-12] rec[-11]
</code></pre>
<hr />
<p>Note: If we simulate our codes under pauli data noise we recover the expected thresholds so the error is not in the circuit for the codes but instead in the way we are handling erasures.</p>
<hr />
<h2>Decoding</h2>
<p>Decoding is done using Sinter to call PyMatching, as shown in the Stim tutorial. We passed 2 new flags to the detector error model: <code>approximate_disjoint_errors=True</code> and <code>ignore_decomposition_failures=True</code>. See the code below.</p>
<pre><code>import stim
import numpy as np
import pymatching
import sinter


def count_logical_errors(circuit: stim.Circuit, num_shots: int) -&gt; int:
    # Sample the circuit.
    sampler = circuit.compile_detector_sampler()
    detection_events, observable_flips = sampler.sample(num_shots, separate_observables=True)

    # Extract decoder configuration data from the circuit.
    detector_error_model = circuit.detector_error_model(decompose_errors=True,
                                                        approximate_disjoint_errors=True,
                                                        ignore_decomposition_failures=True)
    # Run the decoder.
    predictions = sinter.predict_observables(
        dem=detector_error_model,
        dets=detection_events,
        decoder='pymatching',
    )
    # Count the mistakes.
    num_errors = 0
    for actual_flip, predicted_flip in zip(observable_flips, predictions):
        if not np.array_equal(actual_flip, predicted_flip):
            num_errors += 1
    return num_errors
<span class=""math-container"">```</span>
</code></pre>
",Simulating erasures with stim,<stim><error-correction>,1,7,,,"Simulating erasures with stim <p>We're trying to simulate erasure errors on the surface code using Stim. The threshold for erasure errors on the data qubits (after initialization) is 50%.</p>
<p>We followed the following post: <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a></p>
<p>However, we end up with a threshold of ~20%. This is the same as this post: <a href=""https://quantumcomputing.stackexchange.com/questions/30074/threshold-value-when-simulating-erasures-with-stim?noredirect=1&amp;lq=1"">Threshold value when simulating erasures with stim</a></p>
<p>That post did not get an answer and so we bring it up again here.</p>
<hr />
<p>This is our circuit for the unrotated <span class=""math-container"">$d=3$</span> surface code</p>
<pre><code>RX 0 2 4 10 12 14 20 22 24 6 8 16 18 1 3 5 7 9 11 13 15 17 19 21 23
TICK
R 999
E(0.025) X999
E(0.025) X0 X999
E(0.025) Y0 X999
E(0.025) Z0 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X2 X999
E(0.025) Y2 X999
E(0.025) Z2 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X4 X999
E(0.025) Y4 X999
E(0.025) Z4 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X10 X999
E(0.025) Y10 X999
E(0.025) Z10 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X12 X999
E(0.025) Y12 X999
E(0.025) Z12 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X14 X999
E(0.025) Y14 X999
E(0.025) Z14 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X20 X999
E(0.025) Y20 X999
E(0.025) Z20 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X22 X999
E(0.025) Y22 X999
E(0.025) Z22 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X24 X999
E(0.025) Y24 X999
E(0.025) Z24 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X6 X999
E(0.025) Y6 X999
E(0.025) Z6 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X8 X999
E(0.025) Y8 X999
E(0.025) Z8 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X16 X999
E(0.025) Y16 X999
E(0.025) Z16 X999
M 999
DETECTOR rec[-1]
R 999
E(0.025) X999
E(0.025) X18 X999
E(0.025) Y18 X999
E(0.025) Z18 X999
M 999
DETECTOR rec[-1]
CZ 6 1 8 3 16 11 18 13
CX 5 10 7 12 9 14 15 20 17 22 19 24
TICK
CZ 2 1 4 3 12 11 14 13 22 21 24 23
CX 5 6 7 8 15 16 17 18
TICK
CZ 0 1 2 3 10 11 12 13 20 21 22 23
CX 7 6 9 8 17 16 19 18
TICK
CZ 6 11 8 13 16 21 18 23
CX 5 0 7 2 9 4 15 10 17 12 19 14
TICK
MRX 1 3 5 7 9 11 13 15 17 19 21 23
DETECTOR rec[-10]
DETECTOR rec[-9]
DETECTOR rec[-8]
DETECTOR rec[-5]
DETECTOR rec[-4]
DETECTOR rec[-3]
REPEAT 2 {
    TICK
    CZ 6 1 8 3 16 11 18 13
    CX 5 10 7 12 9 14 15 20 17 22 19 24
    TICK
    CZ 2 1 4 3 12 11 14 13 22 21 24 23
    CX 5 6 7 8 15 16 17 18
    TICK
    CZ 0 1 2 3 10 11 12 13 20 21 22 23
    CX 7 6 9 8 17 16 19 18
    TICK
    CZ 6 11 8 13 16 21 18 23
    CX 5 0 7 2 9 4 15 10 17 12 19 14
    TICK
    MRX 1 3 5 7 9 11 13 15 17 19 21 23
    DETECTOR rec[-1] rec[-53]
    DETECTOR rec[-2] rec[-54]
    DETECTOR rec[-3] rec[-55]
    DETECTOR rec[-4] rec[-56]
    DETECTOR rec[-5] rec[-57]
    DETECTOR rec[-6] rec[-58]
    DETECTOR rec[-7] rec[-59]
    DETECTOR rec[-8] rec[-60]
    DETECTOR rec[-9] rec[-61]
    DETECTOR rec[-10] rec[-62]
    DETECTOR rec[-11] rec[-63]
    DETECTOR rec[-12] rec[-64]
}
MX 0 2 4 6 8 10 12 14 16 18 20 22 24
DETECTOR rec[-23] rec[-8] rec[-10] rec[-13]
DETECTOR rec[-22] rec[-7] rec[-9] rec[-10] rec[-12]
DETECTOR rec[-21] rec[-6] rec[-9] rec[-11]
DETECTOR rec[-18] rec[-3] rec[-5] rec[-8]
DETECTOR rec[-17] rec[-2] rec[-4] rec[-5] rec[-7]
DETECTOR rec[-16] rec[-1] rec[-4] rec[-6]
OBSERVABLE_INCLUDE(0) rec[-13] rec[-12] rec[-11]
</code></pre>
<hr />
<p>Note: If we simulate our codes under pauli data noise we recover the expected thresholds so the error is not in the circuit for the codes but instead in the way we are handling erasures.</p>
<hr />
<h2>Decoding</h2>
<p>Decoding is done using Sinter to call PyMatching, as shown in the Stim tutorial. We passed 2 new flags to the detector error model: <code>approximate_disjoint_errors=True</code> and <code>ignore_decomposition_failures=True</code>. See the code below.</p>
<pre><code>import stim
import numpy as np
import pymatching
import sinter


def count_logical_errors(circuit: stim.Circuit, num_shots: int) -&gt; int:
    # Sample the circuit.
    sampler = circuit.compile_detector_sampler()
    detection_events, observable_flips = sampler.sample(num_shots, separate_observables=True)

    # Extract decoder configuration data from the circuit.
    detector_error_model = circuit.detector_error_model(decompose_errors=True,
                                                        approximate_disjoint_errors=True,
                                                        ignore_decomposition_failures=True)
    # Run the decoder.
    predictions = sinter.predict_observables(
        dem=detector_error_model,
        dets=detection_events,
        decoder='pymatching',
    )
    # Count the mistakes.
    num_errors = 0
    for actual_flip, predicted_flip in zip(observable_flips, predictions):
        if not np.array_equal(actual_flip, predicted_flip):
            num_errors += 1
    return num_errors
<span class=""math-container"">```</span>
</code></pre>
",qc,simulating erasures stim p trying simulate erasure errors surface code using stim threshold erasure errors data qubits initialization 50 p followed following post https perform erasure error stim p however end threshold post https amp threshold value simulating erasures stim p post get answer bring hr p circuit unrotated span surface code pre code rx 0 2 4 10 12 14 20 22 24 6 8 16 18 1 3 5 7 9 11 13 15 17 19 21 23 tick r 999 e x999 e x0 x999 e y0 x999 e z0 x999 999 detector rec r 999 e x999 e x2 x999 e y2 x999 e z2 x999 999 detector rec r 999 e x999 e x4 x999 e y4 x999 e z4 x999 999 detector rec r 999 e x999 e x10 x999 e y10 x999 e z10 x999 999 detector rec r 999 e x999 e x12 x999 e y12 x999 e z12 x999 999 detector rec r 999 e x999 e x14 x999 e y14 x999 e z14 x999 999 detector rec r 999 e x999 e x20 x999 e y20 x999 e z20 x999 999 detector rec r 999 e x999 e x22 x999 e y22 x999 e z22 x999 999 detector rec r 999 e x999 e x24 x999 e y24 x999 e z24 x999 999 detector rec r 999 e x999 e x6 x999 e y6 x999 e z6 x999 999 detector rec r 999 e x999 e x8 x999 e y8 x999 e z8 x999 999 detector rec r 999 e x999 e x16 x999 e y16 x999 e z16 x999 999 detector rec r 999 e x999 e x18 x999 e y18 x999 e z18 x999 999 detector rec cz 6 1 8 3 16 11 18 13 cx 5 10 7 12 9 14 15 20 17 22 19 24 tick cz 2 1 4 3 12 11 14 13 22 21 24 23 cx 5 6 7 8 15 16 17 18 tick cz 0 1 2 3 10 11 12 13 20 21 22 23 cx 7 6 9 8 17 16 19 18 tick cz 6 11 8 13 16 21 18 23 cx 5 0 7 2 9 4 15 10 17 12 19 14 tick mrx 1 3 5 7 9 11 13 15 17 19 21 23 detector rec detector rec detector rec detector rec detector rec detector rec repeat 2 tick cz 6 1 8 3 16 11 18 13 cx 5 10 7 12 9 14 15 20 17 22 19 24 tick cz 2 1 4 3 12 11 14 13 22 21 24 23 cx 5 6 7 8 15 16 17 18 tick cz 0 1 2 3 10 11 12 13 20 21 22 23 cx 7 6 9 8 17 16 19 18 tick cz 6 11 8 13 16 21 18 23 cx 5 0 7 2 9 4 15 10 17 12 19 14 tick mrx 1 3 5 7 9 11 13 15 17 19 21 23 detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec mx 0 2 4 6 8 10 12 14 16 18 20 22 24 detector rec rec rec rec detector rec rec rec rec rec detector rec rec rec rec detector rec rec rec rec detector rec rec rec rec rec detector rec rec rec rec 0 rec rec rec hr p note simulate codes pauli data noise recover expected thresholds error circuit codes instead way handling hr h2 decoding p decoding done using sinter call pymatching shown stim tutorial passed 2 new flags detector error model code code see code pre code import stim import numpy np import pymatching import sinter def circuit int gt int sample circuit sampler extract decoder configuration data circuit run decoder predictions count mistakes 0 zip predictions 1 return span,"[(0, 0.029722769), (4, 0.010200254), (5, 0.025610445), (6, 0.6216934), (12, 0.018048225), (14, 0.026975812), (17, 0.26077944)]"
33751,,2023-08-10 19:22:30,2,89,"<p>Let <span class=""math-container"">$\rho, \sigma$</span> be two states of a qubit, and let <span class=""math-container"">$U$</span> be the <span class=""math-container"">$CX_{12}$</span>-gate (control on 1st qubit, target on 2nd qubit).
Prove that, for an arbitrary CPTP Map <span class=""math-container"">$\mathcal{E}$</span>,
<span class=""math-container"">$$
\|\mathcal{E}(\rho - \sigma)\|_1 \leq \|(\mathcal{E}\otimes{\rm id})\left(U\left\{(\rho - \sigma)\otimes |0\rangle\langle 0|\right\}U^{\dagger}\right)\|_1
$$</span></p>
<p>where, <span class=""math-container"">$\|A\|_1 = \rm{Tr}(|A|) = \rm{Tr}(\sqrt{A^{\dagger}A})$</span> is the Trace-Norm of <span class=""math-container"">$A$</span>.</p>
<p><em>Generalization</em>: <br/>
What conditions does <span class=""math-container"">$U$</span> need to satisfy in general so that this inequality holds for arbitrary states <span class=""math-container"">$\rho, \sigma$</span> and arbitrary CPTP Maps <span class=""math-container"">$\mathcal{E}$</span> ?</p>
",Prove $\|{\cal E}(\rho-\sigma)\|_1\leq\|({\cal E}\otimes{\rm id})(U\{(\rho - \sigma)\otimes |0⟩⟨ 0|\}U^{\dagger})\|_1$ with $U$ a CNOT,<quantum-operation><trace-norm>,1,0,,,"Prove $\|{\cal E}(\rho-\sigma)\|_1\leq\|({\cal E}\otimes{\rm id})(U\{(\rho - \sigma)\otimes |0⟩⟨ 0|\}U^{\dagger})\|_1$ with $U$ a CNOT <p>Let <span class=""math-container"">$\rho, \sigma$</span> be two states of a qubit, and let <span class=""math-container"">$U$</span> be the <span class=""math-container"">$CX_{12}$</span>-gate (control on 1st qubit, target on 2nd qubit).
Prove that, for an arbitrary CPTP Map <span class=""math-container"">$\mathcal{E}$</span>,
<span class=""math-container"">$$
\|\mathcal{E}(\rho - \sigma)\|_1 \leq \|(\mathcal{E}\otimes{\rm id})\left(U\left\{(\rho - \sigma)\otimes |0\rangle\langle 0|\right\}U^{\dagger}\right)\|_1
$$</span></p>
<p>where, <span class=""math-container"">$\|A\|_1 = \rm{Tr}(|A|) = \rm{Tr}(\sqrt{A^{\dagger}A})$</span> is the Trace-Norm of <span class=""math-container"">$A$</span>.</p>
<p><em>Generalization</em>: <br/>
What conditions does <span class=""math-container"">$U$</span> need to satisfy in general so that this inequality holds for arbitrary states <span class=""math-container"">$\rho, \sigma$</span> and arbitrary CPTP Maps <span class=""math-container"">$\mathcal{E}$</span> ?</p>
",qc,prove e e id u cnot p let span two states qubit let span u span 12 control 1st qubit target 2nd qubit prove arbitrary cptp map span e span e e id p span tr tr span p em generalization conditions span u need satisfy general inequality holds arbitrary states span arbitrary cptp maps span e,"[(3, 0.6959146), (6, 0.01753443), (17, 0.07278942), (18, 0.2109639)]"
33779,33811.0,2023-08-13 12:19:54,0,87,"<p>I am trying to examine the effect of weights on the performance of MWPM decoder on 5-repetition code as a simple example from <a href=""https://pymatching.readthedocs.io/en/latest/index.html"" rel=""nofollow noreferrer"">Pymatching2</a>. The idea is to vary the input weights by changing the error probability which while fixing the real error probability producing the syndrome:</p>
<pre><code>import numpy as np
from scipy.sparse import csc_matrix
import pymatching
import matplotlib.pyplot as plt

H = csc_matrix([[1, 1, 0, 0, 0],
                [0, 1, 1, 0, 0],
                [0, 0, 1, 1, 0],
                [0, 0, 0, 1, 1]]) #Parity check matrix
observables = csc_matrix([[1, 0, 0, 0, 0]]) #logical error check matrix




noise_propability=np.array([0.09,0.1,0.05,0.1,0.11]) #real errors producing the syndromes


error_probability = 0.3 #assumption of error rates (i.e. weights)
weights = np.ones(H.shape[1]) * np.log((1-error_probability)/error_probability)
matching = pymatching.Matching.from_check_matrix(H, weights=weights)
num_shots = 100000
num_errors = 0
for i in range(num_shots):
    noise = (np.random.random(H.shape[1]) &lt; noise_propability).astype(np.uint8)
    syndrome = H@noise % 2
    prediction, solution_weight = matching.decode(syndrome, return_weight=True)
    predicted_observables = observables@prediction % 2
    actual_observables = observables@noise % 2
    num_errors += not np.array_equal(predicted_observables, actual_observables)

Logical_error_rates = (num_errors/num_shots) 
</code></pre>
<p>Now, setting error_probability to 0.3 will yield Logical_error_rates= 0.00608
while setting it equal to noise_probability (i.e. knowing exactly what error is most likely) yields 0.00615
which is not very far away from the previous case! The logical error rate is actually a bit higher here but that's fine due to stochasticity.</p>
<p>My questions are:</p>
<ol>
<li>does this mean that input weights have no effect on the decoding process?</li>
<li>Is there a Bayesian update of weights since we have the option <code>return_weight=True</code>?</li>
</ol>
<p>Thank you!</p>
",Pymatching: Will starting with arbitrary weights affect the MWPM decoding process?,<pymatching>,1,0,,,"Pymatching: Will starting with arbitrary weights affect the MWPM decoding process? <p>I am trying to examine the effect of weights on the performance of MWPM decoder on 5-repetition code as a simple example from <a href=""https://pymatching.readthedocs.io/en/latest/index.html"" rel=""nofollow noreferrer"">Pymatching2</a>. The idea is to vary the input weights by changing the error probability which while fixing the real error probability producing the syndrome:</p>
<pre><code>import numpy as np
from scipy.sparse import csc_matrix
import pymatching
import matplotlib.pyplot as plt

H = csc_matrix([[1, 1, 0, 0, 0],
                [0, 1, 1, 0, 0],
                [0, 0, 1, 1, 0],
                [0, 0, 0, 1, 1]]) #Parity check matrix
observables = csc_matrix([[1, 0, 0, 0, 0]]) #logical error check matrix




noise_propability=np.array([0.09,0.1,0.05,0.1,0.11]) #real errors producing the syndromes


error_probability = 0.3 #assumption of error rates (i.e. weights)
weights = np.ones(H.shape[1]) * np.log((1-error_probability)/error_probability)
matching = pymatching.Matching.from_check_matrix(H, weights=weights)
num_shots = 100000
num_errors = 0
for i in range(num_shots):
    noise = (np.random.random(H.shape[1]) &lt; noise_propability).astype(np.uint8)
    syndrome = H@noise % 2
    prediction, solution_weight = matching.decode(syndrome, return_weight=True)
    predicted_observables = observables@prediction % 2
    actual_observables = observables@noise % 2
    num_errors += not np.array_equal(predicted_observables, actual_observables)

Logical_error_rates = (num_errors/num_shots) 
</code></pre>
<p>Now, setting error_probability to 0.3 will yield Logical_error_rates= 0.00608
while setting it equal to noise_probability (i.e. knowing exactly what error is most likely) yields 0.00615
which is not very far away from the previous case! The logical error rate is actually a bit higher here but that's fine due to stochasticity.</p>
<p>My questions are:</p>
<ol>
<li>does this mean that input weights have no effect on the decoding process?</li>
<li>Is there a Bayesian update of weights since we have the option <code>return_weight=True</code>?</li>
</ol>
<p>Thank you!</p>
",qc,pymatching starting arbitrary weights affect mwpm decoding process p trying examine effect weights performance mwpm decoder code simple example https nofollow noreferrer pymatching2 idea vary input weights changing error probability fixing real error probability producing syndrome pre code import numpy np import import pymatching import plt h 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 parity check matrix observables 1 0 0 0 0 logical error check matrix real errors producing syndromes assumption error rates weights weights 1 matching h 100000 0 range noise 1 lt syndrome h noise 2 prediction syndrome observables prediction 2 observables noise 2 p setting yield setting equal knowing exactly error likely yields far away previous case logical error rate actually bit higher fine due p questions ol li mean input weights effect decoding process li bayesian update weights since option code p thank,"[(0, 0.13554728), (2, 0.23361433), (4, 0.031872824), (5, 0.31422243), (8, 0.055578593), (11, 0.0107534025), (14, 0.16103514), (17, 0.030289818), (19, 0.026353244)]"
33800,,2023-08-14 17:08:23,0,122,"<p>For the toric code, the threshold error rate value for no measurement errors should be around <span class=""math-container"">$p_{th}\approx 0.109$</span>. If simulated with even distances, one finds that this is true. However, when I simulate it using odd distances, I find <span class=""math-container"">$p_{th}\approx 0.095$</span>: slightly lower. I find this strange considering odd distances are the more practical variant in experiment, and more deterministic than even distances since it always corrects below a certain integer number of errors <span class=""math-container"">$\lfloor\frac{d-1}{2}\rfloor$</span>. I wonder why the code gives 2 different outcomes depending on the parity of the code distance. (I used the code from the documentation and simply altered the code distance, so I am fairly sure it's not a coding mistake.)</p>
<p>Logical VS physical error rate for the toric code, for odd and even distances. For some reason, different behaviour is found, regardless of using PyMatching or other decoding programs.
<a href=""https://i.sstatic.net/qgN34.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qgN34.png"" alt="""" /></a></p>
<p>And here is a higher code distance plot window.</p>
<p><a href=""https://i.sstatic.net/3V5hM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/3V5hM.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/9VMWb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9VMWb.png"" alt=""enter image description here"" /></a></p>
",Why does Stim/PyMatching evaluate the threshold error rate differently for even and odd distances?,<stim><surface-code><toric-code><error-correction>,0,8,,,"Why does Stim/PyMatching evaluate the threshold error rate differently for even and odd distances? <p>For the toric code, the threshold error rate value for no measurement errors should be around <span class=""math-container"">$p_{th}\approx 0.109$</span>. If simulated with even distances, one finds that this is true. However, when I simulate it using odd distances, I find <span class=""math-container"">$p_{th}\approx 0.095$</span>: slightly lower. I find this strange considering odd distances are the more practical variant in experiment, and more deterministic than even distances since it always corrects below a certain integer number of errors <span class=""math-container"">$\lfloor\frac{d-1}{2}\rfloor$</span>. I wonder why the code gives 2 different outcomes depending on the parity of the code distance. (I used the code from the documentation and simply altered the code distance, so I am fairly sure it's not a coding mistake.)</p>
<p>Logical VS physical error rate for the toric code, for odd and even distances. For some reason, different behaviour is found, regardless of using PyMatching or other decoding programs.
<a href=""https://i.sstatic.net/qgN34.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qgN34.png"" alt="""" /></a></p>
<p>And here is a higher code distance plot window.</p>
<p><a href=""https://i.sstatic.net/3V5hM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/3V5hM.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/9VMWb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9VMWb.png"" alt=""enter image description here"" /></a></p>
",qc,evaluate threshold error rate differently even odd distances p toric code threshold error rate value measurement errors around span th simulated even distances one finds true however simulate using odd distances find span th slightly lower find strange considering odd distances practical variant experiment deterministic even distances since always corrects certain integer number errors span 2 wonder code gives 2 different outcomes depending parity code distance used code documentation simply altered code distance fairly sure coding mistake p logical vs physical error rate toric code odd even distances reason different behaviour found regardless using pymatching decoding programs https nofollow noreferrer img https p higher code distance plot p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description,"[(3, 0.06941158), (4, 0.2701332), (5, 0.28616792), (7, 0.048457254), (8, 0.07827706), (13, 0.035937), (14, 0.07331896), (17, 0.13733773)]"
33817,,2023-08-15 15:22:01,2,252,"<p>I’m Aurelio, a computer engeneering student and I would propose a new quantum gate that maybe could be interesting to implement and use. I don’t know if such idea is already known but I have not found nothing similar in the internet and I would talk about it. I started trying to obtain a quantum version of classical AND gate. Soon I understood that is impossible to obtain a quantum AND with only 2 bit because of the irreversibility of this kind of functions. Then I introduced another bit and come to this result:</p>
<p>I would name this gate M gate and it respondes to this logic table:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th style=""text-align: left;"">Z</th>
<th style=""text-align: left;"">A</th>
<th style=""text-align: left;"">B</th>
<th style=""text-align: left;""></th>
<th style=""text-align: left;"">Z'</th>
<th style=""text-align: left;"">A'</th>
<th style=""text-align: left;"">B'</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
</tr>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
</tr>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
</tr>
</tbody>
</table>
</div>
<p>Z,A and B are the inputs qbits while Z',A',B' are the output qbits:</p>
<ul>
<li>when Z qubit in input is in state |0&gt; , the output will be : {Z' = A xor B, A' = A and B, B' = B}</li>
</ul>
<p>-when Z qubit is equal in |1&gt;, the output of the gate will be : {Z' = A xor B, A' = A or B, B' = not B}</p>
<p><a href=""https://i.sstatic.net/hNwn0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hNwn0.png"" alt=""enter image description here"" /></a></p>
<p>As you can see Z qbit act as a control bit and with only this gate we can express all principal logic operations in one time.(XOR,AND,OR,NOT)
Implementing this gate we could resume the behaviour of all this operations.</p>
<p>The corrisponding matrix of the M gate will be:
|X |X |X |X |X |X |X |X |
|:--|:--|:--|:--|:--|:--|:--|:--|
|1|0|0|0|0|0|0|0|
|0|0|0|0|0|1|0|0|
|0|0|0|0|1|0|0|0|
|0|0|0|1|0|0|0|0|
|0|1|0|0|0|0|0|0|
|0|0|0|0|0|0|1|0|
|0|0|0|0|0|0|0|1|
|0|0|1|0|0|0|0|0|</p>
<p>Is simple to verify that the matrix is unitary and so it rappresents a valid reversible function.</p>
<p>Can this gate be usefull in order to add a layer of abstraction to quantum computing? Was it already known or I found something new? Can it be used to solve some known problem ? What appens if Z is in a super position?</p>
",New mode of Quantum and - or gate,<quantum-gate><programming>,1,0,,,"New mode of Quantum and - or gate <p>I’m Aurelio, a computer engeneering student and I would propose a new quantum gate that maybe could be interesting to implement and use. I don’t know if such idea is already known but I have not found nothing similar in the internet and I would talk about it. I started trying to obtain a quantum version of classical AND gate. Soon I understood that is impossible to obtain a quantum AND with only 2 bit because of the irreversibility of this kind of functions. Then I introduced another bit and come to this result:</p>
<p>I would name this gate M gate and it respondes to this logic table:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th style=""text-align: left;"">Z</th>
<th style=""text-align: left;"">A</th>
<th style=""text-align: left;"">B</th>
<th style=""text-align: left;""></th>
<th style=""text-align: left;"">Z'</th>
<th style=""text-align: left;"">A'</th>
<th style=""text-align: left;"">B'</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
</tr>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
</tr>
<tr>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
</tr>
<tr>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;""></td>
<td style=""text-align: left;"">0</td>
<td style=""text-align: left;"">1</td>
<td style=""text-align: left;"">0</td>
</tr>
</tbody>
</table>
</div>
<p>Z,A and B are the inputs qbits while Z',A',B' are the output qbits:</p>
<ul>
<li>when Z qubit in input is in state |0&gt; , the output will be : {Z' = A xor B, A' = A and B, B' = B}</li>
</ul>
<p>-when Z qubit is equal in |1&gt;, the output of the gate will be : {Z' = A xor B, A' = A or B, B' = not B}</p>
<p><a href=""https://i.sstatic.net/hNwn0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/hNwn0.png"" alt=""enter image description here"" /></a></p>
<p>As you can see Z qbit act as a control bit and with only this gate we can express all principal logic operations in one time.(XOR,AND,OR,NOT)
Implementing this gate we could resume the behaviour of all this operations.</p>
<p>The corrisponding matrix of the M gate will be:
|X |X |X |X |X |X |X |X |
|:--|:--|:--|:--|:--|:--|:--|:--|
|1|0|0|0|0|0|0|0|
|0|0|0|0|0|1|0|0|
|0|0|0|0|1|0|0|0|
|0|0|0|1|0|0|0|0|
|0|1|0|0|0|0|0|0|
|0|0|0|0|0|0|1|0|
|0|0|0|0|0|0|0|1|
|0|0|1|0|0|0|0|0|</p>
<p>Is simple to verify that the matrix is unitary and so it rappresents a valid reversible function.</p>
<p>Can this gate be usefull in order to add a layer of abstraction to quantum computing? Was it already known or I found something new? Can it be used to solve some known problem ? What appens if Z is in a super position?</p>
",qc,new mode quantum gate p aurelio computer engeneering student would propose new quantum gate maybe could interesting implement use know idea already known found nothing similar internet would talk started trying obtain quantum version classical gate soon understood impossible obtain quantum 2 bit irreversibility kind functions introduced another bit come result p would name gate gate respondes logic table div table thead tr th left z th left th left b th left th left z th left th left b tbody tr td left 0 td left 0 td left 0 td left td left 0 td left 0 td left 0 tr td left 0 td left 0 td left 1 td left td left 1 td left 0 td left 1 tr td left 0 td left 1 td left 0 td left td left 1 td left 0 td left 0 tr td left 0 td left 1 td left 1 td left td left 0 td left 1 td left 1 tr td left 1 td left 0 td left 0 td left td left 0 td left 0 td left 1 tr td left 1 td left 0 td left 1 td left td left 1 td left 1 td left 0 tr td left 1 td left 1 td left 0 td left td left 1 td left 1 td left 1 tr td left 1 td left 1 td left 1 td left td left 0 td left 1 td left 0 p z b inputs qbits z b output qbits ul li z qubit input state gt output z xor b b b b p z qubit equal gt output gate z xor b b b b p https nofollow noreferrer img https enter image description p see z qbit act control bit gate express principal logic operations one time xor implementing gate could resume behaviour p corrisponding matrix gate p simple verify matrix unitary rappresents valid reversible p gate usefull order add layer abstraction quantum computing already known found something new used solve known problem appens z super position,"[(1, 0.018490095), (2, 0.17844166), (4, 0.042523805), (7, 0.027080467), (8, 0.07693838), (9, 0.059368826), (13, 0.060009606), (17, 0.48142752), (18, 0.05539525)]"
33834,,2023-08-17 08:12:59,2,326,"<p>Where can I find a numerical or analytical comparison of the effect of open and closed boundaries on surface code error correction power, such as the logical error rate at the threshold, logical error rate scaling, etc?</p>
<p>In general, which code has a better error correction performance, the toric or the surface code?</p>
<p>It seems that in the toric code, there are fewer possible logical error chains per logical qubit, but there are two qubits while in the planar surface code, there is only one. So which of the effects will win in which regime (near the threshold, far from the threshold)?</p>
",The planar surface code vs the toric code,<error-correction><surface-code><topological-quantum-computing>,0,3,,,"The planar surface code vs the toric code <p>Where can I find a numerical or analytical comparison of the effect of open and closed boundaries on surface code error correction power, such as the logical error rate at the threshold, logical error rate scaling, etc?</p>
<p>In general, which code has a better error correction performance, the toric or the surface code?</p>
<p>It seems that in the toric code, there are fewer possible logical error chains per logical qubit, but there are two qubits while in the planar surface code, there is only one. So which of the effects will win in which regime (near the threshold, far from the threshold)?</p>
",qc,planar surface code vs toric code p find numerical analytical comparison effect open closed boundaries surface code error correction power logical error rate threshold logical error rate scaling etc p general code better error correction performance toric surface code p seems toric code fewer possible logical error chains per logical qubit two qubits planar surface code one effects win regime near threshold far threshold,"[(5, 0.6094202), (7, 0.09697021), (8, 0.044468336), (9, 0.04683026), (13, 0.11751014), (17, 0.051295917), (18, 0.031477712)]"
33856,,2023-08-19 20:05:28,1,141,"<p>To solve the knapsack problem, I translate it into a QUBO. But the solutions obtained on the simulator are incorrect. Are there ways to make the answers correct?
The picture shows the cost function, where the first expression means the condition for the maximum filling of each backpack. The second condition means that each item can only be put in one backpack
<a href=""https://i.sstatic.net/AkTf0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AkTf0.png"" alt=""enter image description here"" /></a></p>
<pre><code>from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit.utils import algorithm_globals
from qiskit.algorithms.minimum_eigensolvers import SamplingVQE
from qiskit.algorithms.optimizers import SPSA
from qiskit.circuit.library import RealAmplitudes
from qiskit.primitives import Sampler
from qiskit.algorithms import VQE
from qiskit.algorithms.optimizers import COBYLA
from qiskit import IBMQ
class QuantumOptimizer_knpack:
    def __init__(self, cost, pack):

        self.cost = cost  #cost of items
        self.pack = pack  #capacity of backpacks
        self.n = len(cost)
        self.m = len(pack)

    #create cost function
    def binary_representation(self, x_sol=0):

        cost = np.array([self.cost])
        pack = self.pack
        n = self.n
        m = self.m

        # Some variables I will use
        a = 1   
        b = 1  
        Id_n = np.eye(m)
        for i in range(len(pack)):
            Id_n[i][i] = (1 / (pack[i] * a)) ** 2
        Im_n_1 = np.matmul(np.transpose(cost), cost)
        Iv_n_1 = np.array([1 / (i * a) for i in pack])
        Iv_n = cost[0]

        I_on = np.eye(n)
        Im_on = np.ones([m, m])
        I_on_1 = np.ones(n)
        Im_on_1 = np.ones(m)

        Q = np.kron(Id_n, Im_n_1) + b * np.kron(I_on, Im_on)
        g = (

            - 2 * np.kron(Iv_n_1, Iv_n)
            - 2 * b * np.kron(I_on_1, Im_on_1)

        )
        c = (1 + b) * m

        try:
            max(x_sol)
            fun = (
            lambda x: np.dot(np.around(x), np.dot(Q, np.around(x)))
                      + np.dot(g, np.around(x))
                      + c
            )
            cost = fun(x_sol)
        except:
            cost = 0

        return Q, g, c, cost

    def construct_problem(self, Q, g, c) -&gt; QuadraticProgram:
        qp = QuadraticProgram()
        for i in range(self.n * self.m):
            qp.binary_var(str(i))
        qp.objective.quadratic = Q
        qp.objective.linear = g
        qp.objective.constant = c
        return qp

    def solve_problem(self, qp):
        algorithm_globals.random_seed = 10598
        vqe = SamplingVQE(sampler=Sampler(), optimizer=SPSA(), ansatz=RealAmplitudes())
        optimizer = MinimumEigenOptimizer(min_eigen_solver=vqe)
        result = optimizer.solve(qp)
        _, _, _, level = self.binary_representation(x_sol=result.x)
        return result.x, level

    def solve_problem_to_server(self, qp):
        global a
        global conect_flag
        if conect_flag == False:
            conect()
        op, offset = qp.to_ising()
        provider = IBMQ.get_provider(hub='ibm-q')
        backend = provider.get_backend('ibmq_qasm_simulator')
        optimizer = COBYLA(maxiter=200)
        ansatz = RealAmplitudes()
        vqe = VQE(ansatz=ansatz, optimizer=optimizer, quantum_instance=backend)
        result = vqe.compute_minimum_eigenvalue(operator=op)
   

        return result 
 def conect():
     token = &quot;IBMQ_token&quot;
     IBMQ.save_account(token)
     IBMQ.load_account()
#example task
points_cost = [10,7,4,4,3]
pack = [25, 3]
quantum_optimizer = QuantumOptimizer_knpack(points_cost, pack)
Q, g, c, binary_cost = quantum_optimizer.binary_representation()
qp = quantum_optimizer.construct_problem(Q, g, c)
result = quantum_optimizer.solve_problem_to_server(qp)
'''
the result must contain the string &quot;1111000001&quot; which means that the first four items are put 
in the first backpack, and the last one in the second
'''
</code></pre>
",bad solution to the knapsack problem on Qiskit,<qiskit><qubo>,0,0,,,"bad solution to the knapsack problem on Qiskit <p>To solve the knapsack problem, I translate it into a QUBO. But the solutions obtained on the simulator are incorrect. Are there ways to make the answers correct?
The picture shows the cost function, where the first expression means the condition for the maximum filling of each backpack. The second condition means that each item can only be put in one backpack
<a href=""https://i.sstatic.net/AkTf0.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/AkTf0.png"" alt=""enter image description here"" /></a></p>
<pre><code>from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit.utils import algorithm_globals
from qiskit.algorithms.minimum_eigensolvers import SamplingVQE
from qiskit.algorithms.optimizers import SPSA
from qiskit.circuit.library import RealAmplitudes
from qiskit.primitives import Sampler
from qiskit.algorithms import VQE
from qiskit.algorithms.optimizers import COBYLA
from qiskit import IBMQ
class QuantumOptimizer_knpack:
    def __init__(self, cost, pack):

        self.cost = cost  #cost of items
        self.pack = pack  #capacity of backpacks
        self.n = len(cost)
        self.m = len(pack)

    #create cost function
    def binary_representation(self, x_sol=0):

        cost = np.array([self.cost])
        pack = self.pack
        n = self.n
        m = self.m

        # Some variables I will use
        a = 1   
        b = 1  
        Id_n = np.eye(m)
        for i in range(len(pack)):
            Id_n[i][i] = (1 / (pack[i] * a)) ** 2
        Im_n_1 = np.matmul(np.transpose(cost), cost)
        Iv_n_1 = np.array([1 / (i * a) for i in pack])
        Iv_n = cost[0]

        I_on = np.eye(n)
        Im_on = np.ones([m, m])
        I_on_1 = np.ones(n)
        Im_on_1 = np.ones(m)

        Q = np.kron(Id_n, Im_n_1) + b * np.kron(I_on, Im_on)
        g = (

            - 2 * np.kron(Iv_n_1, Iv_n)
            - 2 * b * np.kron(I_on_1, Im_on_1)

        )
        c = (1 + b) * m

        try:
            max(x_sol)
            fun = (
            lambda x: np.dot(np.around(x), np.dot(Q, np.around(x)))
                      + np.dot(g, np.around(x))
                      + c
            )
            cost = fun(x_sol)
        except:
            cost = 0

        return Q, g, c, cost

    def construct_problem(self, Q, g, c) -&gt; QuadraticProgram:
        qp = QuadraticProgram()
        for i in range(self.n * self.m):
            qp.binary_var(str(i))
        qp.objective.quadratic = Q
        qp.objective.linear = g
        qp.objective.constant = c
        return qp

    def solve_problem(self, qp):
        algorithm_globals.random_seed = 10598
        vqe = SamplingVQE(sampler=Sampler(), optimizer=SPSA(), ansatz=RealAmplitudes())
        optimizer = MinimumEigenOptimizer(min_eigen_solver=vqe)
        result = optimizer.solve(qp)
        _, _, _, level = self.binary_representation(x_sol=result.x)
        return result.x, level

    def solve_problem_to_server(self, qp):
        global a
        global conect_flag
        if conect_flag == False:
            conect()
        op, offset = qp.to_ising()
        provider = IBMQ.get_provider(hub='ibm-q')
        backend = provider.get_backend('ibmq_qasm_simulator')
        optimizer = COBYLA(maxiter=200)
        ansatz = RealAmplitudes()
        vqe = VQE(ansatz=ansatz, optimizer=optimizer, quantum_instance=backend)
        result = vqe.compute_minimum_eigenvalue(operator=op)
   

        return result 
 def conect():
     token = &quot;IBMQ_token&quot;
     IBMQ.save_account(token)
     IBMQ.load_account()
#example task
points_cost = [10,7,4,4,3]
pack = [25, 3]
quantum_optimizer = QuantumOptimizer_knpack(points_cost, pack)
Q, g, c, binary_cost = quantum_optimizer.binary_representation()
qp = quantum_optimizer.construct_problem(Q, g, c)
result = quantum_optimizer.solve_problem_to_server(qp)
'''
the result must contain the string &quot;1111000001&quot; which means that the first four items are put 
in the first backpack, and the last one in the second
'''
</code></pre>
",qc,bad solution knapsack problem qiskit p solve knapsack problem translate qubo solutions obtained simulator incorrect ways make answers correct picture shows cost function first expression means condition maximum filling backpack second condition means item put one backpack https nofollow noreferrer img https enter image description pre code import quadraticprogram import minimumeigenoptimizer import import samplingvqe import spsa import realamplitudes import sampler import vqe import cobyla qiskit import ibmq class def self cost pack cost cost items pack capacity backpacks len cost len pack create cost function def self cost pack n variables use 1 b 1 range len pack 1 pack 2 cost cost 1 pack cost 0 n n q b g 2 2 b c 1 b try max fun lambda x x q x g x c cost fun except cost 0 return q g c cost def self q g c gt quadraticprogram qp quadraticprogram range str q g c return qp def self qp 10598 vqe samplingvqe optimizer minimumeigenoptimizer result qp level return level def self qp global global false conect op offset provider backend optimizer cobyla ansatz realamplitudes vqe vqe result return result def conect token quot quot token example task pack 25 3 pack q g c qp q g c result qp result must contain string quot 1111000001 quot means first four items put first backpack last one second,"[(0, 0.47199872), (1, 0.011937544), (2, 0.059115805), (4, 0.07353695), (10, 0.06845041), (14, 0.041224025), (17, 0.013158085), (18, 0.020576814), (19, 0.23514594)]"
33891,,2023-08-23 22:21:54,1,81,"<p>UIn page 6 of the following paper: <a href=""https://arxiv.org/pdf/0904.2557.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/0904.2557.pdf</a>, in the proof of theorem 3:&quot;Suppose equation (30) holds. We can diagonalize <span class=""math-container"">$C_{ab}$</span>. This involves choosing new basis <span class=""math-container"">$\{F_a\}$</span> for <span class=""math-container"">$\mathcal{E}$</span>...&quot;.</p>
<p>Does this mean the matrix representation of the bilinear form <span class=""math-container"">$b(E)=\langle\psi|E^{\dagger}E|\psi\rangle$</span> with respect to the basis that diagonalizes it? (Here, <span class=""math-container"">$\psi$</span> is a fixed codeword.)</p>
",How is a quantum error correcting code $C(E)=\langle\psi|E^\dagger E|\psi\rangle$ diagonalized?,<error-correction><quantum-operation><stabilizer-code>,1,2,,,"How is a quantum error correcting code $C(E)=\langle\psi|E^\dagger E|\psi\rangle$ diagonalized? <p>UIn page 6 of the following paper: <a href=""https://arxiv.org/pdf/0904.2557.pdf"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/0904.2557.pdf</a>, in the proof of theorem 3:&quot;Suppose equation (30) holds. We can diagonalize <span class=""math-container"">$C_{ab}$</span>. This involves choosing new basis <span class=""math-container"">$\{F_a\}$</span> for <span class=""math-container"">$\mathcal{E}$</span>...&quot;.</p>
<p>Does this mean the matrix representation of the bilinear form <span class=""math-container"">$b(E)=\langle\psi|E^{\dagger}E|\psi\rangle$</span> with respect to the basis that diagonalizes it? (Here, <span class=""math-container"">$\psi$</span> is a fixed codeword.)</p>
",qc,quantum error correcting code c e diagonalized p uin page 6 following paper https nofollow noreferrer https proof theorem 3 quot suppose equation 30 holds diagonalize span ab involves choosing new basis span span e quot p mean matrix representation bilinear form span b e respect basis diagonalizes span fixed codeword,"[(3, 0.58640295), (4, 0.10828877), (5, 0.09488851), (6, 0.033088073), (9, 0.048389886), (17, 0.03765854), (19, 0.08863729)]"
33916,,2023-08-25 07:30:13,1,118,"<p>I think I am missing something in my understanding of the amplitude damping and erasure channels when it comes to the dual-rail encoding.</p>
<p>I have the following dual-rail photonic qubit labeled by system <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>:</p>
<p><span class=""math-container"">$$
|\psi\rangle = \alpha|01\rangle_{AB} + \beta|10\rangle_{AB} \\
\hat{\rho}_{AB} = |\psi\rangle\langle\psi|=|\alpha|^2 |01\rangle\langle01| + |\beta|^2|10\rangle\langle10| + \alpha^*\beta|10\rangle\langle01| + \alpha\beta^*|01\rangle\langle10|
$$</span></p>
<p>and the amplitude damping channel is given by a beamsplitter with the qubit input on one port and vacuum input on the other.</p>
<p>If the beamsplitter acts independently on each system, I can send system <span class=""math-container"">$A$</span> through the amplitude damping channel followed by system <span class=""math-container"">$B$</span>.</p>
<p>If the first system passed through the beamsplitter results in the photon being lost, its output state will be <span class=""math-container"">$\hat{\rho}_{A^\prime} =|0\rangle\langle0|$</span>. Then if no photon is lost when I pass system <span class=""math-container"">$B$</span> through the beamsplitter it will result in the state <span class=""math-container"">$\hat{\rho}_{B^\prime} =|\alpha|^2 |0\rangle\langle0| + |\beta|^2|1\rangle\langle1| + \alpha^*\beta|1\rangle\langle0| + \alpha\beta^*|0\rangle\langle1|
$</span></p>
<p>Then <span class=""math-container"">$\hat{\rho}_{A^\prime B^\prime} =|\alpha|^2 |00\rangle\langle00| + |\beta|^2|10\rangle\langle10| + \alpha^*\beta|10\rangle\langle00| + \alpha\beta^*|00\rangle\langle10|$</span></p>
<p>So then its unclear to me how you would detect an erasure happening in this case since the <span class=""math-container"">$|01\rangle\langle01|$</span> is in the hilbert space of the original qubit still.</p>
<p>I understand that if neither photon was lost, you would end up in the original state, and if both photons were lost you would end up in the <span class=""math-container"">$|00\rangle\langle00|$</span> state where measurement in the <span class=""math-container"">$\{|01\rangle, |10\rangle\}$</span> basis would detect the erasure. But the single photon loss plus no photon loss case is confusing.</p>
",How does the dual rail qubit conceptually detect erasures for the amplitude damping channel?,<quantum-operation>,0,6,,,"How does the dual rail qubit conceptually detect erasures for the amplitude damping channel? <p>I think I am missing something in my understanding of the amplitude damping and erasure channels when it comes to the dual-rail encoding.</p>
<p>I have the following dual-rail photonic qubit labeled by system <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span>:</p>
<p><span class=""math-container"">$$
|\psi\rangle = \alpha|01\rangle_{AB} + \beta|10\rangle_{AB} \\
\hat{\rho}_{AB} = |\psi\rangle\langle\psi|=|\alpha|^2 |01\rangle\langle01| + |\beta|^2|10\rangle\langle10| + \alpha^*\beta|10\rangle\langle01| + \alpha\beta^*|01\rangle\langle10|
$$</span></p>
<p>and the amplitude damping channel is given by a beamsplitter with the qubit input on one port and vacuum input on the other.</p>
<p>If the beamsplitter acts independently on each system, I can send system <span class=""math-container"">$A$</span> through the amplitude damping channel followed by system <span class=""math-container"">$B$</span>.</p>
<p>If the first system passed through the beamsplitter results in the photon being lost, its output state will be <span class=""math-container"">$\hat{\rho}_{A^\prime} =|0\rangle\langle0|$</span>. Then if no photon is lost when I pass system <span class=""math-container"">$B$</span> through the beamsplitter it will result in the state <span class=""math-container"">$\hat{\rho}_{B^\prime} =|\alpha|^2 |0\rangle\langle0| + |\beta|^2|1\rangle\langle1| + \alpha^*\beta|1\rangle\langle0| + \alpha\beta^*|0\rangle\langle1|
$</span></p>
<p>Then <span class=""math-container"">$\hat{\rho}_{A^\prime B^\prime} =|\alpha|^2 |00\rangle\langle00| + |\beta|^2|10\rangle\langle10| + \alpha^*\beta|10\rangle\langle00| + \alpha\beta^*|00\rangle\langle10|$</span></p>
<p>So then its unclear to me how you would detect an erasure happening in this case since the <span class=""math-container"">$|01\rangle\langle01|$</span> is in the hilbert space of the original qubit still.</p>
<p>I understand that if neither photon was lost, you would end up in the original state, and if both photons were lost you would end up in the <span class=""math-container"">$|00\rangle\langle00|$</span> state where measurement in the <span class=""math-container"">$\{|01\rangle, |10\rangle\}$</span> basis would detect the erasure. But the single photon loss plus no photon loss case is confusing.</p>
",qc,dual rail qubit conceptually detect erasures amplitude damping channel p think missing something understanding amplitude damping erasure channels comes p following photonic qubit labeled system span span b p span ab ab ab p amplitude damping channel given beamsplitter qubit input one port vacuum input p beamsplitter acts independently system send system span amplitude damping channel followed system span b p first system passed beamsplitter results photon lost output state span photon lost pass system span b beamsplitter result state span p span p unclear would detect erasure happening case since span hilbert space original qubit p understand neither photon lost would end original state photons lost would end span state measurement span basis would detect erasure single photon loss plus photon loss case,"[(3, 0.4132655), (8, 0.1105674), (13, 0.023183372), (14, 0.02759953), (17, 0.08247657), (18, 0.34176987)]"
33994,,2023-08-31 07:27:55,1,634,"<p>I was trying to install the tensor flow quantum module using the one given in their official website but it is showing these errors while installing.</p>
<pre><code>ERROR: Could not find a version that satisfies the requirement tensorflow-quantum (from versions: none)
ERROR: No matching distribution found for tensorflow-quantum
</code></pre>
<p>Can you please let me know how to solve this issue?</p>
<p><a href=""https://i.sstatic.net/Eo75z.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Eo75z.png"" alt=""enter image description here"" /></a></p>
",Cannot import tensorflow_quantum module in Colab,<machine-learning><quantum-enhanced-machine-learning><programming><tfq>,2,0,,,"Cannot import tensorflow_quantum module in Colab <p>I was trying to install the tensor flow quantum module using the one given in their official website but it is showing these errors while installing.</p>
<pre><code>ERROR: Could not find a version that satisfies the requirement tensorflow-quantum (from versions: none)
ERROR: No matching distribution found for tensorflow-quantum
</code></pre>
<p>Can you please let me know how to solve this issue?</p>
<p><a href=""https://i.sstatic.net/Eo75z.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Eo75z.png"" alt=""enter image description here"" /></a></p>
",qc,import module colab p trying install tensor flow quantum module using one given official website showing errors pre code error could find version satisfies requirement versions none error matching distribution found p please let know solve issue p https nofollow noreferrer img https enter image description,"[(0, 0.24630912), (4, 0.37788892), (5, 0.06112491), (13, 0.16464631), (14, 0.124354705), (17, 0.022643954)]"
33996,34120.0,2023-08-31 09:24:35,0,116,"<p>I'd like to adjust the characteristics of a pymatching graph (specifically the edge weights of individual edges) to explore the effects on the decoding process.</p>
<p>While the <code>pymatching.Matching</code> has an <code>.add_edge()</code> method to add an edge, I cannot find anything to adjust parameters of existing edges or remove an edge (to then replace it with the add method). I'm curious if there is any way of doing this without having to create a whole new <code>Matching</code> object.</p>
",Is it possible to adjust the weights of a pymatching graph after it is created?,<error-correction><pymatching>,1,0,,,"Is it possible to adjust the weights of a pymatching graph after it is created? <p>I'd like to adjust the characteristics of a pymatching graph (specifically the edge weights of individual edges) to explore the effects on the decoding process.</p>
<p>While the <code>pymatching.Matching</code> has an <code>.add_edge()</code> method to add an edge, I cannot find anything to adjust parameters of existing edges or remove an edge (to then replace it with the add method). I'm curious if there is any way of doing this without having to create a whole new <code>Matching</code> object.</p>
",qc,possible adjust weights pymatching graph created p like adjust characteristics pymatching graph specifically edge weights individual edges explore effects decoding p code code method add edge find anything adjust parameters existing edges remove edge replace add method curious way without create whole new code matching,"[(5, 0.035536923), (9, 0.05600254), (13, 0.22303241), (14, 0.61383396), (17, 0.06827334)]"
33997,,2023-08-31 11:22:29,3,346,"<p>Recently, IBM proposed a new high-threshold and high-encoding-rate LDPC code family called <a href=""https://arxiv.org/abs/2308.07915"" rel=""nofollow noreferrer"">quasi-cyclic code</a>. In the paper, they give the examples with the smallest [[72, 12, 6]] code.</p>
<p>My question is that whether there are [[<span class=""math-container"">$n$</span>, <span class=""math-container"">$k$</span>, <span class=""math-container"">$d$</span>]] quasi-cyclic code with <span class=""math-container"">$n$</span> smaller than 72 as well as promising <span class=""math-container"">$k$</span>, <span class=""math-container"">$d$</span> that can outperform surface code in the near-term hardware condition in which available number of physical qubits are around 100.</p>
",Smaller quasi-cyclic LDPC code,<error-correction>,1,1,,,"Smaller quasi-cyclic LDPC code <p>Recently, IBM proposed a new high-threshold and high-encoding-rate LDPC code family called <a href=""https://arxiv.org/abs/2308.07915"" rel=""nofollow noreferrer"">quasi-cyclic code</a>. In the paper, they give the examples with the smallest [[72, 12, 6]] code.</p>
<p>My question is that whether there are [[<span class=""math-container"">$n$</span>, <span class=""math-container"">$k$</span>, <span class=""math-container"">$d$</span>]] quasi-cyclic code with <span class=""math-container"">$n$</span> smaller than 72 as well as promising <span class=""math-container"">$k$</span>, <span class=""math-container"">$d$</span> that can outperform surface code in the near-term hardware condition in which available number of physical qubits are around 100.</p>
",qc,smaller ldpc code p recently ibm proposed new ldpc code family called https nofollow noreferrer code paper give examples smallest 72 12 6 p question whether span n span k span code span n smaller 72 well promising span k span outperform surface code hardware condition available number physical qubits around,"[(3, 0.26537833), (5, 0.16583078), (6, 0.040712696), (7, 0.047098137), (9, 0.3069649), (14, 0.11753141), (17, 0.053893045)]"
34058,,2023-09-07 03:39:20,0,290,"<p>So far, I have used surface codes on Stim simulations only. The simulation is for a surface code and I want to understand how surface codes work when I comes to quantum circuit. How is this done for a full quantum circuit with multiple qubits and gates? How are the qubits encoded? Where is the QECC circuit placed? When are the errors corrected? How are the rounds increased? Do all qubits need to have the same distance surface code? Can someone refer me to some papers or articles related to this?</p>
<p>Lastly, is there anyway of simulating this? For example: can I use STIM to simulate surface codes on an entire circuit? If yes, how? If not, can someone suggest a doable idea?</p>
",How to use surface codes on a quantum circuit?,<error-correction><stim><surface-code>,1,2,,,"How to use surface codes on a quantum circuit? <p>So far, I have used surface codes on Stim simulations only. The simulation is for a surface code and I want to understand how surface codes work when I comes to quantum circuit. How is this done for a full quantum circuit with multiple qubits and gates? How are the qubits encoded? Where is the QECC circuit placed? When are the errors corrected? How are the rounds increased? Do all qubits need to have the same distance surface code? Can someone refer me to some papers or articles related to this?</p>
<p>Lastly, is there anyway of simulating this? For example: can I use STIM to simulate surface codes on an entire circuit? If yes, how? If not, can someone suggest a doable idea?</p>
",qc,use surface codes quantum circuit p far used surface codes stim simulations simulation surface code want understand surface codes work comes quantum circuit done full quantum circuit multiple qubits gates qubits encoded qecc circuit placed errors corrected rounds increased qubits need distance surface code someone refer papers articles related p lastly anyway simulating example use stim simulate surface codes entire circuit yes someone suggest doable idea,"[(5, 0.33222535), (7, 0.026587464), (8, 0.2258009), (14, 0.37419596), (17, 0.018507635), (18, 0.020564036)]"
34090,,2023-09-08 19:14:10,1,33,"<p>I am working with a quantum circuit consisting of 30 qubits, and for each qubit, I have allocated a dedicated classical register to record individual measurement results. When I execute this circuit and perform these measurements, I obtain a sequence of 30 bits as output. My primary objective is to determine the probabilities associated with each measurement, which essentially involves calculating the frequency of the state 1 for each qubit.</p>
<p>After obtaining these probabilities, my intention is to compare them to identify the qubit with the highest probability of being in the state 1. Once this qubit is identified, I want to keep it in the state 1, while setting the other qubits to the state 0.</p>
<p>Could you guide me on how to accomplish this task efficiently and accurately within the context of a 30-qubit quantum circuit?</p>
",Optimizing Selection of the Optimal Qubit in a 30-Qubit Quantum Circuit,<qiskit><quantum-state><measurement><quantum-circuit>,0,0,,,"Optimizing Selection of the Optimal Qubit in a 30-Qubit Quantum Circuit <p>I am working with a quantum circuit consisting of 30 qubits, and for each qubit, I have allocated a dedicated classical register to record individual measurement results. When I execute this circuit and perform these measurements, I obtain a sequence of 30 bits as output. My primary objective is to determine the probabilities associated with each measurement, which essentially involves calculating the frequency of the state 1 for each qubit.</p>
<p>After obtaining these probabilities, my intention is to compare them to identify the qubit with the highest probability of being in the state 1. Once this qubit is identified, I want to keep it in the state 1, while setting the other qubits to the state 0.</p>
<p>Could you guide me on how to accomplish this task efficiently and accurately within the context of a 30-qubit quantum circuit?</p>
",qc,optimizing selection optimal qubit quantum circuit p working quantum circuit consisting 30 qubits qubit allocated dedicated classical register record individual measurement results execute circuit perform measurements obtain sequence 30 bits output primary objective determine probabilities associated measurement essentially involves calculating frequency state 1 p obtaining probabilities intention compare identify qubit highest probability state qubit identified want keep state 1 setting qubits state p could guide accomplish task efficiently accurately within context quantum circuit,"[(2, 0.014561633), (4, 0.036815662), (8, 0.12293847), (9, 0.057644427), (13, 0.053949162), (14, 0.3783679), (17, 0.031660896), (18, 0.30239746)]"
34146,,2023-09-13 09:32:59,3,177,"<p>Forgive me if this question was already asked somewhere on this site-I haven't found it but it is possible that I've overlooked it. So basically, I would like to summarize different notions of quantum models of computations, namely:</p>
<ol>
<li>Quantum circuits</li>
<li>Quantum Turing machine</li>
<li>Universal quantum computer as described in Deutsch's paper: <a href=""https://royalsocietypublishing.org/doi/10.1098/rspa.1985.0070"" rel=""nofollow noreferrer"">Quantum Theory, Church-Turing Principle and the Universal Quantum Computer</a>.</li>
</ol>
<p>As far as I know, every quantum computer can be simulated on a classical computer: I suppose that this refers to ,,quantum circuit'' model of computation: it would mean that the class of problems which can be solved (theoretically) on a quantum computer coincides with the class of problems which can be solved by a classical computer. However, Deutsch in his paper argues that the are problems which cannot be solved by a classical computer yet can be solved by his (universal) quantum computer which suggest that his notion of computability would be different.</p>
<p>For the puropose of this discussion call <span class=""math-container"">$QC,QTM,QUC$</span> the classes of problems which can be solved (assuming unbounded time and memory resources) by quantum circuit model of computation, by quantum Turing machines and by universal quantum computer of Deutsch respectively. Let <span class=""math-container"">$RE$</span> be a class of problems solvable by a classical computer.</p>
<blockquote>
<p><strong>Question: What are the inclusions between those classes?</strong></p>
</blockquote>
<p>If comparing complexity classes is usually very difficult subject, I also welcome answers of the sort ,,it is not known but widely believed that some of these two classes coincide''.</p>
","Quantum circuits, quantum Turing machine and universal quantum computer-comparing different models of quantum computations",<quantum-circuit><complexity-theory><computational-models><quantum-turing-machine><church-turing-thesis>,1,2,,,"Quantum circuits, quantum Turing machine and universal quantum computer-comparing different models of quantum computations <p>Forgive me if this question was already asked somewhere on this site-I haven't found it but it is possible that I've overlooked it. So basically, I would like to summarize different notions of quantum models of computations, namely:</p>
<ol>
<li>Quantum circuits</li>
<li>Quantum Turing machine</li>
<li>Universal quantum computer as described in Deutsch's paper: <a href=""https://royalsocietypublishing.org/doi/10.1098/rspa.1985.0070"" rel=""nofollow noreferrer"">Quantum Theory, Church-Turing Principle and the Universal Quantum Computer</a>.</li>
</ol>
<p>As far as I know, every quantum computer can be simulated on a classical computer: I suppose that this refers to ,,quantum circuit'' model of computation: it would mean that the class of problems which can be solved (theoretically) on a quantum computer coincides with the class of problems which can be solved by a classical computer. However, Deutsch in his paper argues that the are problems which cannot be solved by a classical computer yet can be solved by his (universal) quantum computer which suggest that his notion of computability would be different.</p>
<p>For the puropose of this discussion call <span class=""math-container"">$QC,QTM,QUC$</span> the classes of problems which can be solved (assuming unbounded time and memory resources) by quantum circuit model of computation, by quantum Turing machines and by universal quantum computer of Deutsch respectively. Let <span class=""math-container"">$RE$</span> be a class of problems solvable by a classical computer.</p>
<blockquote>
<p><strong>Question: What are the inclusions between those classes?</strong></p>
</blockquote>
<p>If comparing complexity classes is usually very difficult subject, I also welcome answers of the sort ,,it is not known but widely believed that some of these two classes coincide''.</p>
",qc,quantum circuits quantum turing machine universal quantum different models quantum computations p forgive question already asked somewhere found possible overlooked basically would like summarize different notions quantum models computations namely ol li quantum circuits li quantum turing machine li universal quantum computer described deutsch paper https nofollow noreferrer quantum theory principle universal quantum computer p far know every quantum computer simulated classical computer suppose refers circuit model computation would mean class problems solved theoretically quantum computer coincides class problems solved classical computer however deutsch paper argues problems solved classical computer yet solved universal quantum computer suggest notion computability would p puropose discussion call span qc qtm quc classes problems solved assuming unbounded time memory resources quantum circuit model computation quantum turing machines universal quantum computer deutsch respectively let span class problems solvable classical blockquote p strong question inclusions classes p comparing complexity classes usually difficult subject also welcome answers sort known widely believed two classes coincide,"[(1, 0.35718805), (3, 0.04447367), (8, 0.3501881), (9, 0.21167974), (10, 0.021672506), (17, 0.013876075)]"
34166,34168.0,2023-09-14 12:25:56,2,433,"<p>I have a question about the role of OBSERVABLE_INCLUDE  within Stim circuits and how Pymatching uses it in order to decode syndromes. As far as I have understood from the documentation, OBSERVABLE_INCLUDE contains the value of the logical operator of the code. For example, for a distance-3 surface code which is measured in the Z-basis, the <span class=""math-container"">$X_L$</span> operator. Nevertheless, upon observing some of the circuits facilitated by Stim, I do not find it to be the case. Consider the aforementioned Stim circuit which can be constructed as:</p>
<pre><code>circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_z&quot;, 
                             distance=3, 
                             rounds=3, 
                             after_clifford_depolarization=0.005)
</code></pre>
<p>For this circuit, the OBSERVABLE_INCLUDE considers the overall parity of the measurements of the qubits 1, 3 and 5 (figure attached). Why is that the case? For such a code, the <span class=""math-container"">$X_L$</span>
operator can be constructed by any vertical set of <span class=""math-container"">$X$</span> operators going from the bottom boundary to the top one.</p>
<p>I have thought that maybe it was so as to aid the absence of pairs of non-trivial syndrome elements. Nevertheless, were that to be the case, the overall parity of the top three data qubits should also be measured, since only considering the bottom one may produce logical errors. For example, consider in the surface code from the figure, an <span class=""math-container"">$X$</span>-error in data qubit 15 which triggers the check 14. Provided that the decoder only considers the qubits from the bottom to be on the boundary, it may recover an error consisting in <span class=""math-container"">$X$</span> errors in 8 and 1, producing a logical error and not being able to successfully decode syndromes produced from all weight 1 errors.</p>
<p>Either if the motive of OBSERVABLE_INCLUDE is to include a logical operator or to consider boundary data qubits, I also do not understand how can Pymatching only use this value so as to check if the decoding algorithm was correct. I understand the process of Pymatching for measurement error syndromes consists in receiving the detector error model upon which a Tanner graph is built and used for reweighting the detector graph upon which the Blossom algorithm is implemented given a syndrome, which returns the flipped data qubits. I do not understand why we can assume that the decoding process has been successful when the overall parity of qubits 1, 3 and 5 is correct.</p>
<p><a href=""https://i.sstatic.net/IudDp.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IudDp.png"" alt=""Distance 3 surface code, green and orange circles act as <span class=""math-container"">$X$</span>-checks and <span class=""math-container"">$Z$</span>-checks respectively. "" /></a></p>
",What is OBSERVABLE_INCLUDE in Stim and what is usefulness Pymatching,<stim><surface-code><pymatching>,1,1,,,"What is OBSERVABLE_INCLUDE in Stim and what is usefulness Pymatching <p>I have a question about the role of OBSERVABLE_INCLUDE  within Stim circuits and how Pymatching uses it in order to decode syndromes. As far as I have understood from the documentation, OBSERVABLE_INCLUDE contains the value of the logical operator of the code. For example, for a distance-3 surface code which is measured in the Z-basis, the <span class=""math-container"">$X_L$</span> operator. Nevertheless, upon observing some of the circuits facilitated by Stim, I do not find it to be the case. Consider the aforementioned Stim circuit which can be constructed as:</p>
<pre><code>circuit = stim.Circuit.generated(&quot;surface_code:rotated_memory_z&quot;, 
                             distance=3, 
                             rounds=3, 
                             after_clifford_depolarization=0.005)
</code></pre>
<p>For this circuit, the OBSERVABLE_INCLUDE considers the overall parity of the measurements of the qubits 1, 3 and 5 (figure attached). Why is that the case? For such a code, the <span class=""math-container"">$X_L$</span>
operator can be constructed by any vertical set of <span class=""math-container"">$X$</span> operators going from the bottom boundary to the top one.</p>
<p>I have thought that maybe it was so as to aid the absence of pairs of non-trivial syndrome elements. Nevertheless, were that to be the case, the overall parity of the top three data qubits should also be measured, since only considering the bottom one may produce logical errors. For example, consider in the surface code from the figure, an <span class=""math-container"">$X$</span>-error in data qubit 15 which triggers the check 14. Provided that the decoder only considers the qubits from the bottom to be on the boundary, it may recover an error consisting in <span class=""math-container"">$X$</span> errors in 8 and 1, producing a logical error and not being able to successfully decode syndromes produced from all weight 1 errors.</p>
<p>Either if the motive of OBSERVABLE_INCLUDE is to include a logical operator or to consider boundary data qubits, I also do not understand how can Pymatching only use this value so as to check if the decoding algorithm was correct. I understand the process of Pymatching for measurement error syndromes consists in receiving the detector error model upon which a Tanner graph is built and used for reweighting the detector graph upon which the Blossom algorithm is implemented given a syndrome, which returns the flipped data qubits. I do not understand why we can assume that the decoding process has been successful when the overall parity of qubits 1, 3 and 5 is correct.</p>
<p><a href=""https://i.sstatic.net/IudDp.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IudDp.png"" alt=""Distance 3 surface code, green and orange circles act as <span class=""math-container"">$X$</span>-checks and <span class=""math-container"">$Z$</span>-checks respectively. "" /></a></p>
",qc,stim usefulness pymatching p question role within stim circuits pymatching uses order decode syndromes far understood documentation contains value logical operator code example surface code measured span operator nevertheless upon observing circuits facilitated stim find case consider aforementioned stim circuit constructed pre code circuit quot quot p circuit considers overall parity measurements qubits 1 3 5 figure attached case code span operator constructed vertical set span x operators going bottom boundary top p thought maybe aid absence pairs syndrome elements nevertheless case overall parity top three data qubits also measured since considering bottom one may produce logical errors example consider surface code figure span x data qubit 15 triggers check provided decoder considers qubits bottom boundary may recover error consisting span x errors 8 1 producing logical error able successfully decode syndromes produced weight 1 p either motive include logical operator consider boundary data qubits also understand pymatching use value check decoding algorithm correct understand process pymatching measurement error syndromes consists receiving detector error model upon tanner graph built used reweighting detector graph upon blossom algorithm implemented given syndrome returns flipped data qubits understand assume decoding process successful overall parity qubits 1 3 5 p https nofollow noreferrer img https distance 3 surface code green orange circles act span x span z,"[(3, 0.079042226), (4, 0.036362186), (5, 0.3911953), (6, 0.08018421), (9, 0.035184037), (10, 0.030709924), (13, 0.16683595), (14, 0.13619395), (17, 0.02186947), (19, 0.021941975)]"
34182,,2023-09-15 23:27:00,2,28,"<p>I'm looking for a compendium/look-up table for a relationship between binary variables, and corresponding QUBO penalty functions.  I'm aware of a few from DWave docs, <a href=""https://quantumcomputing.stackexchange.com/questions/18265/penalty-function-for-xor-gate"">this question</a>, but I can't find a comprehensive single resource.  Here's an example of what I'm looking for:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>logic</th>
<th>penalty</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class=""math-container"">$x_i \rightarrow x_j$</span></td>
<td><span class=""math-container"">$(x_i -x_j)x_i$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$\bar{x_i} \rightarrow x_j$</span></td>
<td><span class=""math-container"">$1-x_i x_j - x_i -x_j$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$\bar{x_i} \rightarrow \bar{x_j}$</span></td>
<td><span class=""math-container"">$ x_j - x_j x_i $</span></td>
</tr>
</tbody>
</table>
</div>
<p>Such a table would be tremendously helpful for other logical relationships involving other logical relationship, etc.</p>
<p>Does anyone know if such a thing exists?</p>
",Is there a compendium of quadratic penalties for logic relationships between binary variables?,<qubo>,0,0,,,"Is there a compendium of quadratic penalties for logic relationships between binary variables? <p>I'm looking for a compendium/look-up table for a relationship between binary variables, and corresponding QUBO penalty functions.  I'm aware of a few from DWave docs, <a href=""https://quantumcomputing.stackexchange.com/questions/18265/penalty-function-for-xor-gate"">this question</a>, but I can't find a comprehensive single resource.  Here's an example of what I'm looking for:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>logic</th>
<th>penalty</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class=""math-container"">$x_i \rightarrow x_j$</span></td>
<td><span class=""math-container"">$(x_i -x_j)x_i$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$\bar{x_i} \rightarrow x_j$</span></td>
<td><span class=""math-container"">$1-x_i x_j - x_i -x_j$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$\bar{x_i} \rightarrow \bar{x_j}$</span></td>
<td><span class=""math-container"">$ x_j - x_j x_i $</span></td>
</tr>
</tbody>
</table>
</div>
<p>Such a table would be tremendously helpful for other logical relationships involving other logical relationship, etc.</p>
<p>Does anyone know if such a thing exists?</p>
",qc,compendium quadratic penalties logic relationships binary variables p looking table relationship binary variables corresponding qubo penalty functions aware dwave docs https question ca find comprehensive single resource example looking div table thead tr th logic th penalty tbody tr td span td span tr td span td span tr td span td span p table would tremendously helpful logical relationships involving logical relationship p anyone know thing exists,"[(1, 0.09186366), (3, 0.21394119), (5, 0.04717402), (7, 0.14423539), (8, 0.1496128), (11, 0.033201147), (13, 0.04872569), (17, 0.26940456)]"
34202,,2023-09-18 02:14:05,2,85,"<p>I've been playing around with vacuum Rabi oscillation on QuTip and found an odd behavior.</p>
<p>My Hamiltonian is as follows:</p>
<p><span class=""math-container"">$$ H=\omega_n n^\dagger n + \omega_c c^\dagger c -6K(n+n^\dagger)^4 - g(n^\dagger-n)(c^\dagger-c). $$</span>
where <span class=""math-container"">$w_c=w_n=1 \cdot 2 \cdot \pi$</span>, <span class=""math-container"">$ g= 0.05 \cdot 2 \cdot \pi$</span>, and <span class=""math-container"">$ K=0.001 \cdot 2 \cdot \pi $</span> in which all units are in GHz.</p>
<p>When I truncate the Hilbert space into any dimensions other than 15 x 15 or 30 x 30, I get an expected vacuum Rabi oscillation for an initial state of <span class=""math-container"">$ |0\rangle|1\rangle $</span> in the Fock basis. However, for 15 x 15 truncation of the Hilbert space, I get <a href=""https://i.sstatic.net/No482.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/No482.png"" alt=""enter image description here"" /></a> and for 30 x 30 truncation of the Hilbert space, I get <a href=""https://i.sstatic.net/Kxd6S.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Kxd6S.png"" alt=""enter image description here"" /></a>.</p>
<p>Could anyone familiar with QuTip give any insight on why this bug is happening?</p>
",Weird behavior when simulating vacuum Rabi oscillation on QuTip,<hamiltonian-simulation><qutip>,0,0,,,"Weird behavior when simulating vacuum Rabi oscillation on QuTip <p>I've been playing around with vacuum Rabi oscillation on QuTip and found an odd behavior.</p>
<p>My Hamiltonian is as follows:</p>
<p><span class=""math-container"">$$ H=\omega_n n^\dagger n + \omega_c c^\dagger c -6K(n+n^\dagger)^4 - g(n^\dagger-n)(c^\dagger-c). $$</span>
where <span class=""math-container"">$w_c=w_n=1 \cdot 2 \cdot \pi$</span>, <span class=""math-container"">$ g= 0.05 \cdot 2 \cdot \pi$</span>, and <span class=""math-container"">$ K=0.001 \cdot 2 \cdot \pi $</span> in which all units are in GHz.</p>
<p>When I truncate the Hilbert space into any dimensions other than 15 x 15 or 30 x 30, I get an expected vacuum Rabi oscillation for an initial state of <span class=""math-container"">$ |0\rangle|1\rangle $</span> in the Fock basis. However, for 15 x 15 truncation of the Hilbert space, I get <a href=""https://i.sstatic.net/No482.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/No482.png"" alt=""enter image description here"" /></a> and for 30 x 30 truncation of the Hilbert space, I get <a href=""https://i.sstatic.net/Kxd6S.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Kxd6S.png"" alt=""enter image description here"" /></a>.</p>
<p>Could anyone familiar with QuTip give any insight on why this bug is happening?</p>
",qc,weird behavior simulating vacuum rabi oscillation qutip p playing around vacuum rabi oscillation qutip found odd p hamiltonian follows p span n c g span 2 span 2 span 2 units p truncate hilbert space dimensions 15 x 15 30 x 30 get expected vacuum rabi oscillation initial state span fock basis however 15 x 15 truncation hilbert space get https nofollow noreferrer img https enter image description 30 x 30 truncation hilbert space get https nofollow noreferrer img https enter image description p could anyone familiar qutip give insight bug happening,"[(1, 0.011640099), (3, 0.27154768), (4, 0.3529673), (6, 0.060637213), (10, 0.049096256), (11, 0.035125278), (14, 0.14277987), (15, 0.026043423), (17, 0.04896695)]"
34249,,2023-09-21 22:20:24,1,206,"<p>For the simplest case, consider a single qubit state <span class=""math-container"">$|\psi\rangle$</span>, and assume access to a state preparation unitary <span class=""math-container"">$V$</span> satisfying
<span class=""math-container"">$$
V|0\rangle = |\psi\rangle
$$</span>
and
<span class=""math-container"">$$
V|1\rangle  = |\perp\rangle.
$$</span></p>
<p>In the computational basis, we will write <span class=""math-container"">$|\psi\rangle$</span> as
<span class=""math-container"">$$
|\psi\rangle = \begin{pmatrix}
a + i b,\newline
c + id
\end{pmatrix}.
$$</span></p>
<p>Now, consider a new state <span class=""math-container"">$|\phi\rangle$</span> where <span class=""math-container"">$\phi$</span> has as amplitudes the real and imaginary components of of <span class=""math-container"">$|\psi\rangle$</span> as
<span class=""math-container"">$$
|\phi\rangle = \begin{pmatrix}
a\newline
b\newline
c\newline
d
\end{pmatrix}
$$</span></p>
<p>Clearly <span class=""math-container"">$|\phi\rangle$</span> is still a normalized state, and there has been no &quot;change&quot; in information content to prepare, just a slightly different representation.</p>
<p>Does there exist a unitary matrix <span class=""math-container"">$U$</span> satisfying
<span class=""math-container"">\begin{equation}
U:|\psi\rangle|0\rangle \rightarrow |\phi\rangle?
\end{equation}</span></p>
<p>If so, is there a construction of it with elementary quantum gates?</p>
<p>I've tried a few calculations, but I'm getting stuck on the fact that using say controlled applications of <span class=""math-container"">$V$</span> depends only on the norm of amplitude, not it's real and imaginary components, so it's not clear how to separate them out this way in a coherent fashion. I also tried implementing something like an LCU of <span class=""math-container"">$V$</span> with <span class=""math-container"">$V^\dagger$</span> to see if that gave me what I wanted, but not quite.</p>
<p>Does anyone have suggestions on where to look? Is this possible? Is there a violation of no-cloning possibly happening somewhere preventing this? Much appreciated.</p>
",Map $n$ qubit state with complex amplitudes to $n+1$ qubit state with real amplitudes,<circuit-construction><unitarity>,3,0,,,"Map $n$ qubit state with complex amplitudes to $n+1$ qubit state with real amplitudes <p>For the simplest case, consider a single qubit state <span class=""math-container"">$|\psi\rangle$</span>, and assume access to a state preparation unitary <span class=""math-container"">$V$</span> satisfying
<span class=""math-container"">$$
V|0\rangle = |\psi\rangle
$$</span>
and
<span class=""math-container"">$$
V|1\rangle  = |\perp\rangle.
$$</span></p>
<p>In the computational basis, we will write <span class=""math-container"">$|\psi\rangle$</span> as
<span class=""math-container"">$$
|\psi\rangle = \begin{pmatrix}
a + i b,\newline
c + id
\end{pmatrix}.
$$</span></p>
<p>Now, consider a new state <span class=""math-container"">$|\phi\rangle$</span> where <span class=""math-container"">$\phi$</span> has as amplitudes the real and imaginary components of of <span class=""math-container"">$|\psi\rangle$</span> as
<span class=""math-container"">$$
|\phi\rangle = \begin{pmatrix}
a\newline
b\newline
c\newline
d
\end{pmatrix}
$$</span></p>
<p>Clearly <span class=""math-container"">$|\phi\rangle$</span> is still a normalized state, and there has been no &quot;change&quot; in information content to prepare, just a slightly different representation.</p>
<p>Does there exist a unitary matrix <span class=""math-container"">$U$</span> satisfying
<span class=""math-container"">\begin{equation}
U:|\psi\rangle|0\rangle \rightarrow |\phi\rangle?
\end{equation}</span></p>
<p>If so, is there a construction of it with elementary quantum gates?</p>
<p>I've tried a few calculations, but I'm getting stuck on the fact that using say controlled applications of <span class=""math-container"">$V$</span> depends only on the norm of amplitude, not it's real and imaginary components, so it's not clear how to separate them out this way in a coherent fashion. I also tried implementing something like an LCU of <span class=""math-container"">$V$</span> with <span class=""math-container"">$V^\dagger$</span> to see if that gave me what I wanted, but not quite.</p>
<p>Does anyone have suggestions on where to look? Is this possible? Is there a violation of no-cloning possibly happening somewhere preventing this? Much appreciated.</p>
",qc,map n qubit state complex amplitudes qubit state real amplitudes p simplest case consider single qubit state span assume access state preparation unitary span v satisfying span span p computational basis write span span pmatrix b c id pmatrix p consider new state span span amplitudes real imaginary components span span pmatrix pmatrix p clearly span still normalized state quot change quot information content prepare slightly different p exist unitary matrix span u satisfying span equation u equation p construction elementary quantum gates p tried calculations getting stuck fact using say controlled applications span v depends norm amplitude real imaginary components clear separate way coherent fashion also tried implementing something like lcu span v span see gave wanted p anyone suggestions look possible violation possibly happening somewhere preventing much,"[(3, 0.58996516), (13, 0.029765477), (14, 0.13202208), (15, 0.05454377), (17, 0.018835807), (18, 0.1572643), (19, 0.01659636)]"
34258,,2023-09-22 20:40:08,1,96,"<p>BB84 is a key quantum distribution scheme, which is supposed to be &quot;provably secure&quot; and resistant to an individual eavesdropper. However, from what I can tell, is seems as if one could implement a successful eavesdropping protocol that leverages quantum teleportation. Let me explain my reasoning at a high level:</p>
<p>First, the steps of BB84 at a very high level:</p>
<ul>
<li><p>(1) Alice generates a sequence of N qubits, each of which are randomly selected to be one of <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|+\rangle$</span>, or <span class=""math-container"">$|-\rangle$</span>. The <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span> are meant to be measured using the z-basis, yielding a 0 or 1 with certainty when measured. <span class=""math-container"">$|+\rangle$</span>, or <span class=""math-container"">$|-\rangle$</span> are meant to be measured using the x-basis, also yielding a 0 or 1 with certainty when measured.</p>
</li>
<li><p>(2) This sequence of qubits is transmitted to Bob over some quantum communication channel, that may or may not have an eavesdropper (Eve) on it.</p>
</li>
<li><p>(3) Bob measures each of his qubits with a random choice of the z or x basis state, announces this to Alice, and Alice sends Bob the list of the basis states that was to be used on each Qubit.</p>
</li>
<li><p>(4) Alice and Bob both discard the (approximately) N/2 qubits that Bob measured with the &quot;wrong&quot; basis state.</p>
</li>
<li><p>(5) Of the remaining matching qubits, Bob and Alice share the first half of the sequence with each-other. If the sequence is the same, then they can achieve some level of confidence that nobody eavesdropped, because eavesdropping would have required reading the qubits on either the x or z basis, which would have a 1/2 chance of disturbing each one. The larger the original N, the higher the confidence of a secure transmission can be.</p>
</li>
</ul>
<p>We know that quantum cloning is not possible, and thus the transmission between Alice and Bob could not have been cloned by Eve mid-flight. However, quantum teleportation <em>does</em> exist, but it requires measuring (potentially collapsing) the state of the qubit being cloned. Could this not be used to eavesdrop while still allowing &quot;clean&quot; transmission of qubits between Alice and Bob?</p>
<p>Say that Eve is eavesdropping on the communication channel between Alice and Bob. For each Qubit that passes through this channel from Alice to Bob, Eve does the following:</p>
<ul>
<li>Run the input qubit through a quantum teleportation algorithm repeatedly, alternating between using the z-basis and the x-basis for the measurement step of the teleportation.
<ul>
<li>This of course will require reading this qubit and thus collapse it to a 0 or 1. However, the original superposition of this qubit will be preserved, in another qubit on her local quantum computer. (Eve &quot;teleported&quot; the qubit to herself).</li>
<li>Repeat these teleportation steps, giving the output qubit from the last round of teleportation as the input qubit to the next round. Do this until one of the z-basis or x-basis measurements disagree with a previous measurement on that basis. When this occurs for one of the bases, we know that it must have been meant to be measured in the other basis.</li>
</ul>
</li>
<li>Now that Eve knows both the correct basis and what the readout for the qubit in that basis was, pass the remaining teleported qubit over the network along to Bob, which should have the same superposition as it was when originally sent from Alice.</li>
</ul>
<p>Does this break BB84?</p>
",Can quantum teleportation be used to break BB84?,<teleportation><bb84>,0,5,,,"Can quantum teleportation be used to break BB84? <p>BB84 is a key quantum distribution scheme, which is supposed to be &quot;provably secure&quot; and resistant to an individual eavesdropper. However, from what I can tell, is seems as if one could implement a successful eavesdropping protocol that leverages quantum teleportation. Let me explain my reasoning at a high level:</p>
<p>First, the steps of BB84 at a very high level:</p>
<ul>
<li><p>(1) Alice generates a sequence of N qubits, each of which are randomly selected to be one of <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|+\rangle$</span>, or <span class=""math-container"">$|-\rangle$</span>. The <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span> are meant to be measured using the z-basis, yielding a 0 or 1 with certainty when measured. <span class=""math-container"">$|+\rangle$</span>, or <span class=""math-container"">$|-\rangle$</span> are meant to be measured using the x-basis, also yielding a 0 or 1 with certainty when measured.</p>
</li>
<li><p>(2) This sequence of qubits is transmitted to Bob over some quantum communication channel, that may or may not have an eavesdropper (Eve) on it.</p>
</li>
<li><p>(3) Bob measures each of his qubits with a random choice of the z or x basis state, announces this to Alice, and Alice sends Bob the list of the basis states that was to be used on each Qubit.</p>
</li>
<li><p>(4) Alice and Bob both discard the (approximately) N/2 qubits that Bob measured with the &quot;wrong&quot; basis state.</p>
</li>
<li><p>(5) Of the remaining matching qubits, Bob and Alice share the first half of the sequence with each-other. If the sequence is the same, then they can achieve some level of confidence that nobody eavesdropped, because eavesdropping would have required reading the qubits on either the x or z basis, which would have a 1/2 chance of disturbing each one. The larger the original N, the higher the confidence of a secure transmission can be.</p>
</li>
</ul>
<p>We know that quantum cloning is not possible, and thus the transmission between Alice and Bob could not have been cloned by Eve mid-flight. However, quantum teleportation <em>does</em> exist, but it requires measuring (potentially collapsing) the state of the qubit being cloned. Could this not be used to eavesdrop while still allowing &quot;clean&quot; transmission of qubits between Alice and Bob?</p>
<p>Say that Eve is eavesdropping on the communication channel between Alice and Bob. For each Qubit that passes through this channel from Alice to Bob, Eve does the following:</p>
<ul>
<li>Run the input qubit through a quantum teleportation algorithm repeatedly, alternating between using the z-basis and the x-basis for the measurement step of the teleportation.
<ul>
<li>This of course will require reading this qubit and thus collapse it to a 0 or 1. However, the original superposition of this qubit will be preserved, in another qubit on her local quantum computer. (Eve &quot;teleported&quot; the qubit to herself).</li>
<li>Repeat these teleportation steps, giving the output qubit from the last round of teleportation as the input qubit to the next round. Do this until one of the z-basis or x-basis measurements disagree with a previous measurement on that basis. When this occurs for one of the bases, we know that it must have been meant to be measured in the other basis.</li>
</ul>
</li>
<li>Now that Eve knows both the correct basis and what the readout for the qubit in that basis was, pass the remaining teleported qubit over the network along to Bob, which should have the same superposition as it was when originally sent from Alice.</li>
</ul>
<p>Does this break BB84?</p>
",qc,quantum teleportation used break bb84 p bb84 key quantum distribution scheme supposed quot provably secure quot resistant individual eavesdropper however tell seems one could implement successful eavesdropping protocol leverages quantum teleportation let explain reasoning high level p first steps bb84 high level ul li p 1 alice generates sequence n qubits randomly selected one span span span span span span meant measured using yielding 0 1 certainty measured span span meant measured using also yielding 0 1 certainty li p 2 sequence qubits transmitted bob quantum communication channel may may eavesdropper eve li p 3 bob measures qubits random choice z x basis state announces alice alice sends bob list basis states used li p 4 alice bob discard approximately qubits bob measured quot wrong quot basis li p 5 remaining matching qubits bob alice share first half sequence sequence achieve level confidence nobody eavesdropped eavesdropping would required reading qubits either x z basis would chance disturbing one larger original n higher confidence secure transmission p know quantum cloning possible thus transmission alice bob could cloned eve however quantum teleportation em exist requires measuring potentially collapsing state qubit cloned could used eavesdrop still allowing quot clean quot transmission qubits alice bob p say eve eavesdropping communication channel alice bob qubit passes channel alice bob eve following ul li run input qubit quantum teleportation algorithm repeatedly alternating using measurement step teleportation ul li course require reading qubit thus collapse 0 however original superposition qubit preserved another qubit local quantum computer eve quot teleported quot qubit li repeat teleportation steps giving output qubit last round teleportation input qubit next round one measurements disagree previous measurement basis occurs one bases know must meant measured li eve knows correct basis readout qubit basis pass remaining teleported qubit network along bob superposition originally sent p break bb84,"[(2, 0.02207134), (3, 0.123014785), (8, 0.0633502), (9, 0.017417707), (14, 0.0216567), (17, 0.031466626), (18, 0.66608423), (19, 0.04137382)]"
34263,34294.0,2023-09-23 13:39:46,3,161,"<p>I am stuck in simplyfing the following cNOT teleportation in ZX-calculus. I don't know how to proceed further. The circuit I start from is taken from <a href=""https://arxiv.org/abs/2307.07908"" rel=""nofollow noreferrer"">this thesis</a> (Fig 2.14, page 22).</p>
<p>Which property can I use to simplify the circuit further? Am I forced to sit down and compute the matrix product?</p>
<p>In case the image is not super clear, in d), the element in the bottom green Z spider is <span class=""math-container"">$(-1)^{b_1} \pi b_2$</span> (I could have removed the <span class=""math-container"">$(-1)^{b_1}$</span> already as it is multiplied by <span class=""math-container"">$\pi$</span> but I kept it to be sure you see my step-by-step calculation).</p>
<p><a href=""https://i.sstatic.net/HiX4J.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HiX4J.jpg"" alt=""enter image description here"" /></a></p>
",$CNOT$ teleportation in ZX-calculus: how to simplify my circuit further?,<teleportation><zx-calculus>,1,0,,,"$CNOT$ teleportation in ZX-calculus: how to simplify my circuit further? <p>I am stuck in simplyfing the following cNOT teleportation in ZX-calculus. I don't know how to proceed further. The circuit I start from is taken from <a href=""https://arxiv.org/abs/2307.07908"" rel=""nofollow noreferrer"">this thesis</a> (Fig 2.14, page 22).</p>
<p>Which property can I use to simplify the circuit further? Am I forced to sit down and compute the matrix product?</p>
<p>In case the image is not super clear, in d), the element in the bottom green Z spider is <span class=""math-container"">$(-1)^{b_1} \pi b_2$</span> (I could have removed the <span class=""math-container"">$(-1)^{b_1}$</span> already as it is multiplied by <span class=""math-container"">$\pi$</span> but I kept it to be sure you see my step-by-step calculation).</p>
<p><a href=""https://i.sstatic.net/HiX4J.jpg"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HiX4J.jpg"" alt=""enter image description here"" /></a></p>
",qc,cnot teleportation simplify circuit p stuck simplyfing following cnot teleportation know proceed circuit start taken https nofollow noreferrer thesis fig page 22 p property use simplify circuit forced sit compute matrix product p case image super clear element bottom green z spider span could removed span already multiplied span kept sure see calculation p https nofollow noreferrer img https enter image description,"[(3, 0.26912078), (4, 0.45753166), (8, 0.1620824), (12, 0.018552002), (13, 0.066718966), (17, 0.02366372)]"
34292,,2023-09-26 19:04:24,1,302,"<p>I would like to use a knapsack problem formulation based on Lucas <a href=""https://www.frontiersin.org/articles/10.3389/fphy.2014.00005"" rel=""nofollow noreferrer"">paper</a>. Namely, I try to implement the following math formula for Hamiltonian <span class=""math-container"">$H =H_A + H_B$</span>, where
<span class=""math-container"">$$H_{B} = -B\sum_{i=1}^{n}v_{i}x_{i};
H_{A} = A(1-\sum_{j=0}^{M-1}2^{j}y_{j}+(c+1-2^{M})y_{M}-\sum_{i=1}^{n}w_{i}x_{i})^{2}\,.$$</span></p>
<p>I implemented it using sympy (imported as sp):</p>
<pre class=""lang-python prettyprint-override""><code>
    def knapsack(values, weights, capacity, A, B):  
    
    n = len(values)
    M = math.ceil(math.log2(capacity))
    
    # Define the variables
    x = [sp.Symbol(f'x{i}') for i in range(n)]
    y = [sp.Symbol(f'y{i}') for i in range(M+1)]
    
    # Define the objective function
    HB = -B * sum(values[i] * x[i] for i in range(n))
    HA = A * (1 - sum(2**j * y[j] for j in range(M)) + (capacity+1-2**M)*y[M] - sum(weights[i] * x[i] for i in range(n)))**2
    H = HA + HB
    
    # Expand the objective function
    expanded_H = H.expand()
    
    # Extract linear, quadratic, and constant terms from the expanded objective function
    linear_terms = {str(symbol): coeff for symbol, coeff in expanded_H.as_coefficients_dict().items() if symbol.is_symbol}
    
    # Extract quadratic terms
    quadratic_terms = {}
    for term, coeff in expanded_H.as_coefficients_dict().items():
        if isinstance(term, sp.Mul) and len(term.args) == 2:
            v1, v2 = sorted([str(a) for a in term.args])
            if (v1, v2) not in quadratic_terms:
                quadratic_terms[(v1, v2)] = coeff
            else:
                quadratic_terms[(v1, v2)] += coeff
    
    constant = expanded_H.as_coefficients_dict().get(1, 0)
    
    # Create a QuadraticProgram
    qp = QuadraticProgram()
    
    # Add binary variables to the QuadraticProgram
    for var in x + y:
        qp.binary_var(name=str(var))
    
    # Set the objective in QuadraticProgram
    qp.minimize(linear=linear_terms, quadratic=quadratic_terms, constant=constant)
    
    return qp
</code></pre>
<p>Next, I convert it to the Ising model to get an operator to pass to VQE. Next, I set up VQE to compute the minimum eigenvalue. My question is if the above formulation of the knapsack is correct. When running VQE (on <code>statevector_simulator</code>), I get solutions that are more or less random, sometimes suboptimal, sometimes incorrect (breaking capacity constraint). I suppose I missed something in the formulation of the problem.</p>
",Knapsack problem formulation,<vqe><optimization><hamiltonian>,1,0,,,"Knapsack problem formulation <p>I would like to use a knapsack problem formulation based on Lucas <a href=""https://www.frontiersin.org/articles/10.3389/fphy.2014.00005"" rel=""nofollow noreferrer"">paper</a>. Namely, I try to implement the following math formula for Hamiltonian <span class=""math-container"">$H =H_A + H_B$</span>, where
<span class=""math-container"">$$H_{B} = -B\sum_{i=1}^{n}v_{i}x_{i};
H_{A} = A(1-\sum_{j=0}^{M-1}2^{j}y_{j}+(c+1-2^{M})y_{M}-\sum_{i=1}^{n}w_{i}x_{i})^{2}\,.$$</span></p>
<p>I implemented it using sympy (imported as sp):</p>
<pre class=""lang-python prettyprint-override""><code>
    def knapsack(values, weights, capacity, A, B):  
    
    n = len(values)
    M = math.ceil(math.log2(capacity))
    
    # Define the variables
    x = [sp.Symbol(f'x{i}') for i in range(n)]
    y = [sp.Symbol(f'y{i}') for i in range(M+1)]
    
    # Define the objective function
    HB = -B * sum(values[i] * x[i] for i in range(n))
    HA = A * (1 - sum(2**j * y[j] for j in range(M)) + (capacity+1-2**M)*y[M] - sum(weights[i] * x[i] for i in range(n)))**2
    H = HA + HB
    
    # Expand the objective function
    expanded_H = H.expand()
    
    # Extract linear, quadratic, and constant terms from the expanded objective function
    linear_terms = {str(symbol): coeff for symbol, coeff in expanded_H.as_coefficients_dict().items() if symbol.is_symbol}
    
    # Extract quadratic terms
    quadratic_terms = {}
    for term, coeff in expanded_H.as_coefficients_dict().items():
        if isinstance(term, sp.Mul) and len(term.args) == 2:
            v1, v2 = sorted([str(a) for a in term.args])
            if (v1, v2) not in quadratic_terms:
                quadratic_terms[(v1, v2)] = coeff
            else:
                quadratic_terms[(v1, v2)] += coeff
    
    constant = expanded_H.as_coefficients_dict().get(1, 0)
    
    # Create a QuadraticProgram
    qp = QuadraticProgram()
    
    # Add binary variables to the QuadraticProgram
    for var in x + y:
        qp.binary_var(name=str(var))
    
    # Set the objective in QuadraticProgram
    qp.minimize(linear=linear_terms, quadratic=quadratic_terms, constant=constant)
    
    return qp
</code></pre>
<p>Next, I convert it to the Ising model to get an operator to pass to VQE. Next, I set up VQE to compute the minimum eigenvalue. My question is if the above formulation of the knapsack is correct. When running VQE (on <code>statevector_simulator</code>), I get solutions that are more or less random, sometimes suboptimal, sometimes incorrect (breaking capacity constraint). I suppose I missed something in the formulation of the problem.</p>
",qc,knapsack problem formulation p would like use knapsack problem formulation based lucas https nofollow noreferrer paper namely try implement following math formula hamiltonian span h span b n j j n 2 p implemented using sympy imported sp pre code def knapsack values weights capacity b n len values capacity define variables x f x range n f range define objective function hb sum values x range n ha 1 sum 2 j j j range sum weights x range n 2 h ha hb expand objective function extract linear quadratic constant terms expanded objective function str symbol coeff symbol coeff extract quadratic terms term coeff isinstance term len 2 v1 v2 sorted str v1 v2 v1 v2 coeff else v1 v2 coeff constant 1 0 create quadraticprogram qp quadraticprogram add binary variables quadraticprogram var x var set objective quadraticprogram return qp p next convert ising model get operator pass vqe next set vqe compute minimum eigenvalue question formulation knapsack correct running vqe code get solutions less random sometimes suboptimal sometimes incorrect breaking capacity constraint suppose missed something formulation,"[(0, 0.40686265), (1, 0.08866372), (2, 0.022860572), (3, 0.1167123), (4, 0.026054947), (9, 0.030403085), (10, 0.115405), (14, 0.083971426), (17, 0.050979014), (19, 0.052092217)]"
34334,,2023-10-02 05:23:42,4,367,"<p>If we have two quantum error-correcting qubit <span class=""math-container"">$[[n_1, 1, d_1]]$</span> and <span class=""math-container"">$[[n_2,1,d_2]]$</span> codes then <a href=""http://theory.caltech.edu/%7Epreskill/ph229/notes/chap7.pdf"" rel=""nofollow noreferrer"">the notes of Preskill</a> says that the concatenation of the codes is a code of distance at least <span class=""math-container"">$d_1d_2.$</span></p>
<p>Could someone prove it mathematically?</p>
<p>By concatenation, I mean the code given by the encoding map <span class=""math-container"">$\phi_2^{\otimes n_1}\circ \phi_1,$</span> where <span class=""math-container"">$\phi_i$</span> is the encoding map of <span class=""math-container"">$[[n_i, 1, d_i]]$</span> code.</p>
",Distance of the concatenated quantum error correcting code,<quantum-state><error-correction>,2,1,,,"Distance of the concatenated quantum error correcting code <p>If we have two quantum error-correcting qubit <span class=""math-container"">$[[n_1, 1, d_1]]$</span> and <span class=""math-container"">$[[n_2,1,d_2]]$</span> codes then <a href=""http://theory.caltech.edu/%7Epreskill/ph229/notes/chap7.pdf"" rel=""nofollow noreferrer"">the notes of Preskill</a> says that the concatenation of the codes is a code of distance at least <span class=""math-container"">$d_1d_2.$</span></p>
<p>Could someone prove it mathematically?</p>
<p>By concatenation, I mean the code given by the encoding map <span class=""math-container"">$\phi_2^{\otimes n_1}\circ \phi_1,$</span> where <span class=""math-container"">$\phi_i$</span> is the encoding map of <span class=""math-container"">$[[n_i, 1, d_i]]$</span> code.</p>
",qc,distance concatenated quantum error correcting code p two quantum qubit span 1 span codes http nofollow noreferrer notes preskill says concatenation codes code distance least span p could someone prove mathematically p concatenation mean code given encoding map span span encoding map span 1,"[(3, 0.50129366), (4, 0.047369957), (5, 0.30300435), (9, 0.06652353), (11, 0.029658876), (17, 0.048980962)]"
34350,,2023-10-03 17:13:26,2,383,"<p>I am very new to quantum circuits and am unsure how to simplify them. Say I'm given a very simple circuit:</p>
<p><a href=""https://i.sstatic.net/oiizC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/oiizC.png"" alt=""circuit"" /></a></p>
<p>and I want to simplify it using basic quantum gates. I'm not looking for an answer, but more just how to go about it. I started by computing the outputs with <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|+\rangle$</span> and <span class=""math-container"">$|-\rangle$</span> states and thought that a simple NOT gate would suffice because <span class=""math-container"">$|0\rangle \rightarrow |1\rangle$</span>, <span class=""math-container"">$|1\rangle \rightarrow |0\rangle$</span>, <span class=""math-container"">$|+\rangle \rightarrow |+\rangle$</span>. However, when it comes to the <span class=""math-container"">$|-\rangle$</span> state, the output is <span class=""math-container"">$-|-\rangle$</span>, and I don't know how to account for that when doing the simplification.</p>
<p>Very basic question but any help is appreciated.</p>
",Simplifying quantum circuits,<quantum-circuit>,1,0,,,"Simplifying quantum circuits <p>I am very new to quantum circuits and am unsure how to simplify them. Say I'm given a very simple circuit:</p>
<p><a href=""https://i.sstatic.net/oiizC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/oiizC.png"" alt=""circuit"" /></a></p>
<p>and I want to simplify it using basic quantum gates. I'm not looking for an answer, but more just how to go about it. I started by computing the outputs with <span class=""math-container"">$|0\rangle$</span>, <span class=""math-container"">$|1\rangle$</span>, <span class=""math-container"">$|+\rangle$</span> and <span class=""math-container"">$|-\rangle$</span> states and thought that a simple NOT gate would suffice because <span class=""math-container"">$|0\rangle \rightarrow |1\rangle$</span>, <span class=""math-container"">$|1\rangle \rightarrow |0\rangle$</span>, <span class=""math-container"">$|+\rangle \rightarrow |+\rangle$</span>. However, when it comes to the <span class=""math-container"">$|-\rangle$</span> state, the output is <span class=""math-container"">$-|-\rangle$</span>, and I don't know how to account for that when doing the simplification.</p>
<p>Very basic question but any help is appreciated.</p>
",qc,simplifying quantum circuits p new quantum circuits unsure simplify say given simple circuit p https nofollow noreferrer img https circuit p want simplify using basic quantum gates looking answer go started computing outputs span span span span states thought simple gate would suffice span span span however comes span state output span know account p basic question help,"[(3, 0.3126791), (4, 0.15233408), (13, 0.1651413), (14, 0.32624626), (17, 0.041021094)]"
34371,,2023-10-05 07:39:29,1,59,"<p>I am trying to QCNN for MNIST classification equivalent to that <a href=""https://qiskit.org/ecosystem/machine-learning/tutorials/05_torch_connector.html#Part-2:-MNIST-Classification,-Hybrid-QNNs"" rel=""nofollow noreferrer"">built in</a>.
I’m having problems trying to pass my quantum circuit built with cirq as a Keras layer. Here’s what I have:</p>
<pre><code># Parameters that the classical NN will feed values into.
control_params = sympy.symbols('theta_1 theta_2 theta_3 theta_4')

# Create the parameterized circuit.
qubits = cirq.GridQubit.rect(2,1)
model_circuit = cirq.Circuit(
    cirq.rx(control_params[0])(qubits[0]),
    cirq.rx(control_params[1])(qubits[1]),
    cirq.rx(control_params[2])(qubits[0]),
    cirq.rx(control_params[3])(qubits[1]),
    cirq.CNOT(qubits[0],qubits[1]))

qlayer = tfq.convert_to_tensor([model_circuit])

SVGCircuit(model_circuit)
</code></pre>
<pre><code>width = np.shape(x_train)[1]
height = np.shape(x_train)[2]



model = tf.keras.Sequential([
    tf.keras.layers.Input(shape=(width, height, 1)),  # Specify the input shape correctly
    tf.keras.layers.Conv2D(filters=2, kernel_size=5),
    tf.keras.layers.Conv2D(filters=16, kernel_size=5),
    tf.keras.layers.SpatialDropout2D(rate=0.2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(2, activation='relu'),
    tfq.layers.PQC(model_circuit, [cirq.Z(qubits[1])])  # Use qubits[1] for measurement
])
</code></pre>
<p>Which returns the error:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[72], line 26
      2 height = np.shape(x_train)[2]
      7 # model = tf.keras.Sequential([
      8     
      9 # # tf.keras.layers.Input(shape=(()), dtype=tf.string), #, dtype=tf.string (28,28,1)
   (...)
     23     
     24 # ])
---&gt; 26 model = tf.keras.Sequential([
     27     tf.keras.layers.Input(shape=(width, height, 1)),  # Specify the input shape correctly
     28     tf.keras.layers.Conv2D(filters=2, kernel_size=5),
     29     tf.keras.layers.Conv2D(filters=16, kernel_size=5),
     30     tf.keras.layers.SpatialDropout2D(rate=0.2),
     31     tf.keras.layers.Flatten(),
     32     tf.keras.layers.Dense(64, activation='relu'),
     33     tf.keras.layers.Dense(2, activation='relu'),
     34     tfq.layers.PQC(model_circuit, [cirq.Z(qubits[1])])  # Use qubits[1] for measurement
     35 ])

File ~/.local/lib/python3.8/site-packages/tensorflow/python/training/tracking/base.py:530, in no_automatic_dependency_tracking.&lt;locals&gt;._method_wrapper(self, *args, **kwargs)
    528 self._self_setattr_tracking = False  # pylint: disable=protected-access
    529 try:
--&gt; 530   result = method(self, *args, **kwargs)
    531 finally:
    532   self._self_setattr_tracking = previous_value  # pylint: disable=protected-access

File ~/.local/lib/python3.8/site-packages/keras/utils/traceback_utils.py:67, in filter_traceback.&lt;locals&gt;.error_handler(*args, **kwargs)
     65 except Exception as e:  # pylint: disable=broad-except
     66   filtered_tb = _process_traceback_frames(e.__traceback__)
---&gt; 67   raise e.with_traceback(filtered_tb) from None
     68 finally:
     69   del filtered_tb

File ~/.local/lib/python3.8/site-packages/tensorflow/python/autograph/impl/api.py:699, in convert.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
    697 except Exception as e:  # pylint:disable=broad-except
    698   if hasattr(e, 'ag_error_metadata'):
--&gt; 699     raise e.ag_error_metadata.to_exception(e)
    700   else:
    701     raise

TypeError: Exception encountered when calling layer &quot;pqc_38&quot; (type PQC).

in user code:

    File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/tensorflow_quantum/python/layers/high_level/pqc.py&quot;, line 299, in call  *
        model_appended = self._append_layer(inputs, append=tiled_up_model)
    File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/keras/utils/traceback_utils.py&quot;, line 67, in error_handler  **
        raise e.with_traceback(filtered_tb) from None

    TypeError: Exception encountered when calling layer &quot;add_circuit_40&quot; (type AddCircuit).
    
    in user code:
    
        File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/tensorflow_quantum/python/layers/circuit_construction/elementary.py&quot;, line 128, in call  *
            return tfq_utility_ops.append_circuit(inputs, append)
        File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/tensorflow_quantum/core/ops/tfq_utility_ops.py&quot;, line 65, in append_circuit  *
            return UTILITY_OP_MODULE.tfq_append_circuit(programs, programs_to_append)
        File &quot;&lt;string&gt;&quot;, line 73, in tfq_append_circuit  **
            
    
        TypeError: Input 'programs' of 'TfqAppendCircuit' Op has type float32 that does not match expected type of string.
    
    
    Call arguments received:
      • inputs=tf.Tensor(shape=(None, 2), dtype=float32)
      • append=tf.Tensor(shape=(None,), dtype=string)
      • prepend=None


Call arguments received:
  • inputs=tf.Tensor(shape=(None, 2), dtype=float32)
</code></pre>
<p>The documentation on QCNNs using TensorFlow is pretty limited, and instead <a href=""https://www.tensorflow.org/quantum/tutorials/qcnn"" rel=""nofollow noreferrer"">here</a> they are actually using the quantum layer to reduce dimensionality, which I’m not trying to do.</p>
<p>Any help would be greatly appreciated.</p>
",Tensorflow_quantum hybrid models tf-quantum,<cirq><machine-learning><quantum-enhanced-machine-learning><tfq>,0,0,,,"Tensorflow_quantum hybrid models tf-quantum <p>I am trying to QCNN for MNIST classification equivalent to that <a href=""https://qiskit.org/ecosystem/machine-learning/tutorials/05_torch_connector.html#Part-2:-MNIST-Classification,-Hybrid-QNNs"" rel=""nofollow noreferrer"">built in</a>.
I’m having problems trying to pass my quantum circuit built with cirq as a Keras layer. Here’s what I have:</p>
<pre><code># Parameters that the classical NN will feed values into.
control_params = sympy.symbols('theta_1 theta_2 theta_3 theta_4')

# Create the parameterized circuit.
qubits = cirq.GridQubit.rect(2,1)
model_circuit = cirq.Circuit(
    cirq.rx(control_params[0])(qubits[0]),
    cirq.rx(control_params[1])(qubits[1]),
    cirq.rx(control_params[2])(qubits[0]),
    cirq.rx(control_params[3])(qubits[1]),
    cirq.CNOT(qubits[0],qubits[1]))

qlayer = tfq.convert_to_tensor([model_circuit])

SVGCircuit(model_circuit)
</code></pre>
<pre><code>width = np.shape(x_train)[1]
height = np.shape(x_train)[2]



model = tf.keras.Sequential([
    tf.keras.layers.Input(shape=(width, height, 1)),  # Specify the input shape correctly
    tf.keras.layers.Conv2D(filters=2, kernel_size=5),
    tf.keras.layers.Conv2D(filters=16, kernel_size=5),
    tf.keras.layers.SpatialDropout2D(rate=0.2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(2, activation='relu'),
    tfq.layers.PQC(model_circuit, [cirq.Z(qubits[1])])  # Use qubits[1] for measurement
])
</code></pre>
<p>Which returns the error:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[72], line 26
      2 height = np.shape(x_train)[2]
      7 # model = tf.keras.Sequential([
      8     
      9 # # tf.keras.layers.Input(shape=(()), dtype=tf.string), #, dtype=tf.string (28,28,1)
   (...)
     23     
     24 # ])
---&gt; 26 model = tf.keras.Sequential([
     27     tf.keras.layers.Input(shape=(width, height, 1)),  # Specify the input shape correctly
     28     tf.keras.layers.Conv2D(filters=2, kernel_size=5),
     29     tf.keras.layers.Conv2D(filters=16, kernel_size=5),
     30     tf.keras.layers.SpatialDropout2D(rate=0.2),
     31     tf.keras.layers.Flatten(),
     32     tf.keras.layers.Dense(64, activation='relu'),
     33     tf.keras.layers.Dense(2, activation='relu'),
     34     tfq.layers.PQC(model_circuit, [cirq.Z(qubits[1])])  # Use qubits[1] for measurement
     35 ])

File ~/.local/lib/python3.8/site-packages/tensorflow/python/training/tracking/base.py:530, in no_automatic_dependency_tracking.&lt;locals&gt;._method_wrapper(self, *args, **kwargs)
    528 self._self_setattr_tracking = False  # pylint: disable=protected-access
    529 try:
--&gt; 530   result = method(self, *args, **kwargs)
    531 finally:
    532   self._self_setattr_tracking = previous_value  # pylint: disable=protected-access

File ~/.local/lib/python3.8/site-packages/keras/utils/traceback_utils.py:67, in filter_traceback.&lt;locals&gt;.error_handler(*args, **kwargs)
     65 except Exception as e:  # pylint: disable=broad-except
     66   filtered_tb = _process_traceback_frames(e.__traceback__)
---&gt; 67   raise e.with_traceback(filtered_tb) from None
     68 finally:
     69   del filtered_tb

File ~/.local/lib/python3.8/site-packages/tensorflow/python/autograph/impl/api.py:699, in convert.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(*args, **kwargs)
    697 except Exception as e:  # pylint:disable=broad-except
    698   if hasattr(e, 'ag_error_metadata'):
--&gt; 699     raise e.ag_error_metadata.to_exception(e)
    700   else:
    701     raise

TypeError: Exception encountered when calling layer &quot;pqc_38&quot; (type PQC).

in user code:

    File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/tensorflow_quantum/python/layers/high_level/pqc.py&quot;, line 299, in call  *
        model_appended = self._append_layer(inputs, append=tiled_up_model)
    File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/keras/utils/traceback_utils.py&quot;, line 67, in error_handler  **
        raise e.with_traceback(filtered_tb) from None

    TypeError: Exception encountered when calling layer &quot;add_circuit_40&quot; (type AddCircuit).
    
    in user code:
    
        File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/tensorflow_quantum/python/layers/circuit_construction/elementary.py&quot;, line 128, in call  *
            return tfq_utility_ops.append_circuit(inputs, append)
        File &quot;/home/zhk26714/.local/lib/python3.8/site-packages/tensorflow_quantum/core/ops/tfq_utility_ops.py&quot;, line 65, in append_circuit  *
            return UTILITY_OP_MODULE.tfq_append_circuit(programs, programs_to_append)
        File &quot;&lt;string&gt;&quot;, line 73, in tfq_append_circuit  **
            
    
        TypeError: Input 'programs' of 'TfqAppendCircuit' Op has type float32 that does not match expected type of string.
    
    
    Call arguments received:
      • inputs=tf.Tensor(shape=(None, 2), dtype=float32)
      • append=tf.Tensor(shape=(None,), dtype=string)
      • prepend=None


Call arguments received:
  • inputs=tf.Tensor(shape=(None, 2), dtype=float32)
</code></pre>
<p>The documentation on QCNNs using TensorFlow is pretty limited, and instead <a href=""https://www.tensorflow.org/quantum/tutorials/qcnn"" rel=""nofollow noreferrer"">here</a> they are actually using the quantum layer to reduce dimensionality, which I’m not trying to do.</p>
<p>Any help would be greatly appreciated.</p>
",qc,hybrid models p trying qcnn mnist classification equivalent https nofollow noreferrer built problems trying pass quantum circuit built cirq keras layer pre code parameters classical nn feed values create parameterized circuit qubits 0 qubits 0 1 qubits 1 2 qubits 0 3 qubits 1 qubits 0 qubits 1 qlayer svgcircuit pre code width 1 height 2 model width height 1 specify input shape correctly 64 2 qubits 1 use qubits 1 measurement p returns error pre code typeerror traceback recent call last cell 72 line 26 2 height 2 7 model 8 9 23 24 gt 26 model 27 width height 1 specify input shape correctly 28 29 30 31 32 64 33 2 34 qubits 1 use qubits 1 measurement 35 file lt locals gt self args kwargs 528 false pylint 529 try gt 530 result method self args kwargs 531 finally 532 pylint file lt locals gt args kwargs 65 except exception e pylint 66 gt 67 raise none 68 finally 69 del file lt locals gt lt locals gt args kwargs 697 except exception e pylint 698 hasattr e gt 699 raise e 700 else 701 raise typeerror exception encountered calling layer quot quot type pqc user code file quot quot line 299 call inputs file quot quot line 67 raise none typeerror exception encountered calling layer quot quot type addcircuit user code file quot quot line 128 call return inputs append file quot quot line 65 return programs file quot lt string gt quot line 73 typeerror input op type float32 match expected type string call arguments received none 2 none call arguments received none 2 p documentation qcnns using tensorflow pretty limited instead https nofollow noreferrer actually using quantum layer reduce dimensionality trying p help would greatly,"[(0, 0.4150193), (2, 0.07900056), (4, 0.0263174), (6, 0.05175392), (14, 0.14889655), (15, 0.019086147), (17, 0.011752752), (19, 0.24436325)]"
34443,,2023-10-11 15:35:08,1,306,"<p>Here's my code to define the depolarization error using Qiskit, which included both one and two-qubit errors:</p>
<pre class=""lang-python prettyprint-override""><code>def depo_error(one_qubit_error, two_qubit_error):
    
    noise_model = NoiseModel()

    error_1q = depolarizing_error(one_qubit_error, 1)
    noise_model.add_all_qubit_quantum_error(error_1q, ['u1', 'u2', 'u3'])

    error_2q = depolarizing_error(two_qubit_error, 2)
    noise_model.add_all_qubit_quantum_error(error_2q, ['cx'])

    return noise_model
</code></pre>
<p>My question is that after setting up the error rates for one and two-qubit gates, how does the error accumulate? Suppose I have a circuit that looks pretty similar to the Hadamard test:</p>
<p><a href=""https://i.sstatic.net/fth31.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fth31.png"" alt=""enter image description here"" /></a></p>
<p>And I set <code>one_qubit_error = two_qubit_error = 0.5</code>. Is there a way we can estimate how the error accumulates and its effect on the measurement?</p>
",How does depolarization error accumulate?,<qiskit><simulation><depolarizing-channel>,1,2,,,"How does depolarization error accumulate? <p>Here's my code to define the depolarization error using Qiskit, which included both one and two-qubit errors:</p>
<pre class=""lang-python prettyprint-override""><code>def depo_error(one_qubit_error, two_qubit_error):
    
    noise_model = NoiseModel()

    error_1q = depolarizing_error(one_qubit_error, 1)
    noise_model.add_all_qubit_quantum_error(error_1q, ['u1', 'u2', 'u3'])

    error_2q = depolarizing_error(two_qubit_error, 2)
    noise_model.add_all_qubit_quantum_error(error_2q, ['cx'])

    return noise_model
</code></pre>
<p>My question is that after setting up the error rates for one and two-qubit gates, how does the error accumulate? Suppose I have a circuit that looks pretty similar to the Hadamard test:</p>
<p><a href=""https://i.sstatic.net/fth31.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/fth31.png"" alt=""enter image description here"" /></a></p>
<p>And I set <code>one_qubit_error = two_qubit_error = 0.5</code>. Is there a way we can estimate how the error accumulates and its effect on the measurement?</p>
",qc,depolarization error accumulate p code define depolarization error using qiskit included one errors pre code def noisemodel 1 2 return p question setting error rates one gates error accumulate suppose circuit looks pretty similar hadamard test p https nofollow noreferrer img https enter image description p set code way estimate error accumulates effect measurement,"[(0, 0.09529293), (2, 0.029021872), (4, 0.2454171), (5, 0.21852982), (14, 0.3703599), (17, 0.038745835)]"
34450,35114.0,2023-10-12 11:04:12,3,228,"<p>In the <a href=""https://quantumcomputing.stackexchange.com/a/34335/1837"">following answer</a> to a recent question, it is claimed that when we concatenate two error correcting codes of distances <span class=""math-container"">$d_1$</span> and <span class=""math-container"">$d_2$</span>, the greatest distance that we can prove without assuming any structure of the code is <span class=""math-container"">$d_1d_2/2$</span> while if we know something about the structure, e.g. that it's a CSS code, the distance is at least <span class=""math-container"">$d_1d_2$</span>.</p>
<p>Are there any known examples of pairs of codes for which the combined distance is less than <span class=""math-container"">$d_1d_2$</span>? For preference, the codes should be on qubits and expressed within the stabilizer formalism, if that is even possible. The smaller the better!</p>
",Distance of concatenated codes: a counter example?,<error-correction>,1,2,,,"Distance of concatenated codes: a counter example? <p>In the <a href=""https://quantumcomputing.stackexchange.com/a/34335/1837"">following answer</a> to a recent question, it is claimed that when we concatenate two error correcting codes of distances <span class=""math-container"">$d_1$</span> and <span class=""math-container"">$d_2$</span>, the greatest distance that we can prove without assuming any structure of the code is <span class=""math-container"">$d_1d_2/2$</span> while if we know something about the structure, e.g. that it's a CSS code, the distance is at least <span class=""math-container"">$d_1d_2$</span>.</p>
<p>Are there any known examples of pairs of codes for which the combined distance is less than <span class=""math-container"">$d_1d_2$</span>? For preference, the codes should be on qubits and expressed within the stabilizer formalism, if that is even possible. The smaller the better!</p>
",qc,distance concatenated codes counter example p https following answer recent question claimed concatenate two error correcting codes distances span span greatest distance prove without assuming structure code span know something structure css code distance least span p known examples pairs codes combined distance less span preference codes qubits expressed within stabilizer formalism even possible smaller better,"[(0, 0.025387667), (3, 0.21020012), (5, 0.41585216), (9, 0.2691014), (13, 0.029858893), (14, 0.02528747), (17, 0.021988211)]"
34455,34461.0,2023-10-12 16:34:29,2,79,"<p>I am doing some analysis from a  now retired device (<code>lima</code>) and I would like to access its &quot;logic&quot; construction in qiskit. Specifically, I would like to print the circuits in the specific transpilation for the device, print the circuits to external files, and make use of callbacks in order to check the flow of the circuit during the transpilation procedure. How can I access this?</p>
<p>Note that I don't want to retrieve jobs (a.k.a. numerical data).</p>
<p>The error arises in the code</p>
<pre><code>provider = IBMProvider(instance=&quot;ibm-q/open/main&quot;)
backend = provider.get_backend('ibmq_lima')
(...)
# The error:
QiskitBackendNotFoundError: 'No backend matches the criteria'
</code></pre>
<p>What is the &quot;backend access&quot; for retired devices?</p>
",Retrieve backend functionality of retired qiskit device,<qiskit>,1,0,,,"Retrieve backend functionality of retired qiskit device <p>I am doing some analysis from a  now retired device (<code>lima</code>) and I would like to access its &quot;logic&quot; construction in qiskit. Specifically, I would like to print the circuits in the specific transpilation for the device, print the circuits to external files, and make use of callbacks in order to check the flow of the circuit during the transpilation procedure. How can I access this?</p>
<p>Note that I don't want to retrieve jobs (a.k.a. numerical data).</p>
<p>The error arises in the code</p>
<pre><code>provider = IBMProvider(instance=&quot;ibm-q/open/main&quot;)
backend = provider.get_backend('ibmq_lima')
(...)
# The error:
QiskitBackendNotFoundError: 'No backend matches the criteria'
</code></pre>
<p>What is the &quot;backend access&quot; for retired devices?</p>
",qc,retrieve backend functionality retired qiskit device p analysis retired device code lima would like access quot logic quot construction qiskit specifically would like print circuits specific transpilation device print circuits external files make use callbacks order check flow circuit transpilation procedure access p note want retrieve jobs numerical data p error arises code pre code provider ibmprovider quot quot backend error qiskitbackendnotfounderror backend matches criteria p quot backend access quot retired devices,"[(0, 0.09002673), (9, 0.023902338), (14, 0.61283123), (15, 0.06392981), (16, 0.032236267), (17, 0.014724542), (19, 0.16052142)]"
34477,34478.0,2023-10-15 02:58:46,3,1020,"<p>Notation: <span class=""math-container"">$|\text{qubit}_{1}, ..., \text{qubit}_{N}\rangle$</span>.</p>
<p>The goal of quantum teleportation is to send quantum information using classical bits.</p>
<p>A source transmits a state <span class=""math-container"">$|\psi\rangle_{A_{0}} = \alpha|0\rangle + \beta|1\rangle$</span> to Alice. Alice has no knowledge of what this state is and is forbidden from measuring this state as the laws of quantum mechanics result in the collapse of the state.</p>
<p>At this point, quantum teleportation protocol dictates the introduction of a Bell state, say <span class=""math-container"">$|\Phi_{+}\rangle = \frac{1}{\sqrt{2}}[|00\rangle + |11\rangle]$</span>, that tensors with <span class=""math-container"">$|\psi\rangle_{A_{0}}$</span> to give</p>
<p><span class=""math-container"">$|\psi\rangle_{A_{0}}|\Psi_{+}\rangle = \frac{1}{\sqrt{2}}[\alpha (|000\rangle + |011\rangle) + \beta(|100\rangle + |111\rangle)]$</span>.</p>
<p>What is the physical (or mathematical) motivation behind which the above Bell state is introduced?</p>
",Why is a Bell state involved in quantum teleportation?,<quantum-state><entanglement><teleportation><bell-basis>,1,0,,,"Why is a Bell state involved in quantum teleportation? <p>Notation: <span class=""math-container"">$|\text{qubit}_{1}, ..., \text{qubit}_{N}\rangle$</span>.</p>
<p>The goal of quantum teleportation is to send quantum information using classical bits.</p>
<p>A source transmits a state <span class=""math-container"">$|\psi\rangle_{A_{0}} = \alpha|0\rangle + \beta|1\rangle$</span> to Alice. Alice has no knowledge of what this state is and is forbidden from measuring this state as the laws of quantum mechanics result in the collapse of the state.</p>
<p>At this point, quantum teleportation protocol dictates the introduction of a Bell state, say <span class=""math-container"">$|\Phi_{+}\rangle = \frac{1}{\sqrt{2}}[|00\rangle + |11\rangle]$</span>, that tensors with <span class=""math-container"">$|\psi\rangle_{A_{0}}$</span> to give</p>
<p><span class=""math-container"">$|\psi\rangle_{A_{0}}|\Psi_{+}\rangle = \frac{1}{\sqrt{2}}[\alpha (|000\rangle + |011\rangle) + \beta(|100\rangle + |111\rangle)]$</span>.</p>
<p>What is the physical (or mathematical) motivation behind which the above Bell state is introduced?</p>
",qc,bell state involved quantum teleportation p notation span qubit 1 qubit n p goal quantum teleportation send quantum information using classical p source transmits state span 0 alice alice knowledge state forbidden measuring state laws quantum mechanics result collapse p point quantum teleportation protocol dictates introduction bell state say span 1 2 tensors span 0 give p span 0 1 2 p physical mathematical motivation behind bell state introduced,"[(0, 0.011406447), (2, 0.11312768), (3, 0.16560254), (8, 0.14132547), (13, 0.036808863), (17, 0.015631322), (18, 0.51415163)]"
34486,,2023-10-15 16:29:03,1,46,"<p>I have a problem with my code. I would like to try multiple embeddings in my kernel (I'm using the adjoint method). My idea is to pass them to the function and use them depending on what I pass. Unfortunately, it doesn't work as I think, or I can't program it. Help would be nice :)</p>
<p>Code:</p>
<pre><code>
from pennylane.templates import SqueezingEmbedding,QAOAEmbedding,IQPEmbedding,DisplacementEmbedding,AngleEmbedding, StronglyEntanglingLayers,BasisEmbedding,AmplitudeEmbedding,DisplacementEmbedding

def kernel_matrix(A, B):
    &quot;&quot;&quot;Compute the matrix whose entries are the kernel
       evaluated on pairwise data from sets A and B.&quot;&quot;&quot;
    
    kernel = np.array([[kernel(a, b) for b in B] for a in A]) #how can I pass on the method?
    return kernel


def Quantum_Kernel_pennylane(train_X, test_X, train_y, test_y, method):
   
    n_qubits = len(train_X[0])
    
    dev_kernel = qml.device('lightning.qubit', wires=n_qubits)
        
    projector = np.zeros((2**n_qubits, 2**n_qubits))
    projector[0, 0] = 1

    @qml.qnode(dev_kernel, interface=&quot;autograd&quot;)
    def kernel(x1, x2):
        &quot;&quot;&quot;The quantum kernel.
           We use the adjoint method.
        &quot;&quot;&quot; 
        if method == qml.templates.embeddings.AmplitudeEmbedding:
            method(x1, wires=range(n_qubits), pad_with=0.4)  
            qml.adjoint(method)(x2, wires=range(n_qubits), pad_with=0.4)   
            return qml.expval(qml.Hermitian(projector, wires=range(n_qubits)))
        
        method(x1, wires=range(n_qubits))
        qml.adjoint(method)(x2, wires=range(n_qubits))   
        return qml.expval(qml.Hermitian(projector, wires=range(n_qubits)))
    
    svm = SVC(kernel=kernel_matrix).fit(train_X, train_y) # here is the problem how can I pass on the method?
    predictions = svm.predict(test_X)
    print(accuracy_score(predictions, test_y))





def main():
 methods = [IQPEmbedding,
           AngleEmbedding,
           AmplitudeEmbedding
          ]

 for method in methods:
    print(method)
    Quantum_Kernel_pennylane(train_X, test_X, train_y, test_y, method)# I want to pass on the Method
</code></pre>
",How can I pass multiple embeddings in my function?,<programming><pennylane><kernel-methods><quantum-kernel>,0,1,,,"How can I pass multiple embeddings in my function? <p>I have a problem with my code. I would like to try multiple embeddings in my kernel (I'm using the adjoint method). My idea is to pass them to the function and use them depending on what I pass. Unfortunately, it doesn't work as I think, or I can't program it. Help would be nice :)</p>
<p>Code:</p>
<pre><code>
from pennylane.templates import SqueezingEmbedding,QAOAEmbedding,IQPEmbedding,DisplacementEmbedding,AngleEmbedding, StronglyEntanglingLayers,BasisEmbedding,AmplitudeEmbedding,DisplacementEmbedding

def kernel_matrix(A, B):
    &quot;&quot;&quot;Compute the matrix whose entries are the kernel
       evaluated on pairwise data from sets A and B.&quot;&quot;&quot;
    
    kernel = np.array([[kernel(a, b) for b in B] for a in A]) #how can I pass on the method?
    return kernel


def Quantum_Kernel_pennylane(train_X, test_X, train_y, test_y, method):
   
    n_qubits = len(train_X[0])
    
    dev_kernel = qml.device('lightning.qubit', wires=n_qubits)
        
    projector = np.zeros((2**n_qubits, 2**n_qubits))
    projector[0, 0] = 1

    @qml.qnode(dev_kernel, interface=&quot;autograd&quot;)
    def kernel(x1, x2):
        &quot;&quot;&quot;The quantum kernel.
           We use the adjoint method.
        &quot;&quot;&quot; 
        if method == qml.templates.embeddings.AmplitudeEmbedding:
            method(x1, wires=range(n_qubits), pad_with=0.4)  
            qml.adjoint(method)(x2, wires=range(n_qubits), pad_with=0.4)   
            return qml.expval(qml.Hermitian(projector, wires=range(n_qubits)))
        
        method(x1, wires=range(n_qubits))
        qml.adjoint(method)(x2, wires=range(n_qubits))   
        return qml.expval(qml.Hermitian(projector, wires=range(n_qubits)))
    
    svm = SVC(kernel=kernel_matrix).fit(train_X, train_y) # here is the problem how can I pass on the method?
    predictions = svm.predict(test_X)
    print(accuracy_score(predictions, test_y))





def main():
 methods = [IQPEmbedding,
           AngleEmbedding,
           AmplitudeEmbedding
          ]

 for method in methods:
    print(method)
    Quantum_Kernel_pennylane(train_X, test_X, train_y, test_y, method)# I want to pass on the Method
</code></pre>
",qc,pass multiple embeddings function p problem code would like try multiple embeddings kernel using adjoint method idea pass function use depending pass unfortunately work think ca program help would nice p code pre code import squeezingembedding qaoaembedding iqpembedding displacementembedding angleembedding stronglyentanglinglayers basisembedding amplitudeembedding displacementembedding def b quot quot quot compute matrix whose entries kernel evaluated pairwise data sets quot quot quot kernel kernel b b b pass method return kernel def method len 0 projector 2 2 projector 0 0 1 quot autograd quot def kernel x1 x2 quot quot quot quantum kernel use adjoint method quot quot quot method method x1 method x2 return projector method x1 method x2 return projector svm svc problem pass method predictions print predictions def main methods iqpembedding angleembedding amplitudeembedding method methods print method method want pass method,"[(0, 0.13230547), (2, 0.06009742), (14, 0.39388293), (15, 0.029805671), (17, 0.10300662), (19, 0.27973604)]"
34511,34516.0,2023-10-18 09:23:22,0,61,"<p>Several months ago there is a paper appears calling <a href=""https://arxiv.org/pdf/2307.00523.pdf"" rel=""nofollow noreferrer"">Disentangling Hype from Practicality: On Realistically Achieving Quantum Advantage</a>. It seems it is a real challenge to transfer data from quantum to classical register faster than classical cpu/gpu does this with RAM.</p>
<p>Could it be the show stopper for quantum computation?</p>
",I/O problem in quantum computing,<technologies>,1,1,,,"I/O problem in quantum computing <p>Several months ago there is a paper appears calling <a href=""https://arxiv.org/pdf/2307.00523.pdf"" rel=""nofollow noreferrer"">Disentangling Hype from Practicality: On Realistically Achieving Quantum Advantage</a>. It seems it is a real challenge to transfer data from quantum to classical register faster than classical cpu/gpu does this with RAM.</p>
<p>Could it be the show stopper for quantum computation?</p>
",qc,problem quantum computing p several months ago paper appears calling https nofollow noreferrer disentangling hype practicality realistically achieving quantum advantage seems real challenge transfer data quantum classical register faster classical p could show stopper quantum computation,"[(1, 0.26713002), (4, 0.119729914), (7, 0.18507788), (8, 0.24716868), (13, 0.14417094), (17, 0.032365505)]"
34523,34527.0,2023-10-19 11:44:56,1,99,"<p>I have a question on circuit which constitutes the sydnrome measurement for the 5-qubit error correcting code. If I focus on just a portion of the circuit:</p>
<p><a href=""https://i.sstatic.net/EBapy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/EBapy.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://www.physics.unlv.edu/%7Ebernard/MATH_book/Chap9/Notebook9_3.pdf"" rel=""nofollow noreferrer"">Reference for image</a>. The full circuit can be found on page <span class=""math-container"">$3$</span> of the Notebook just referenced.</p>
<p>So I have a five qubit state <span class=""math-container"">$|\psi\rangle$</span> and an ancilla qubit in the <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>If, for example, we say the state <span class=""math-container"">$|\psi\rangle = |0_{5L}\rangle$</span>, I am a litte confused as to the circuit works.</p>
<p>My understanding would be (and please note I think I am quite wrong about this):</p>
<ol>
<li>We begin with the <span class=""math-container"">$|000000\rangle$</span> state</li>
<li>We apply the Hadamard operator to the first qubit, so the resulting state is <span class=""math-container"">$|+00000\rangle$</span></li>
<li>The 1st qubit is the control qubit and the 2nd qubit is the target qubit. But I am not quite sure how this works for the Pauli matrices? I know that for the CNOT operation, if the control qubit is in the <span class=""math-container"">$|1\rangle$</span> state, then the target qubit undergoes a bit flip. How does this work in this circuit with the Pauli matrices?</li>
<li>I have the same gap in understanding for the next few steps.</li>
</ol>
<hr />
<p>From Nielsen and Chuang's textbook, <span class=""math-container"">$$|c\rangle |t\rangle \rightarrow |c\rangle U^{c}|t\rangle$$</span> &quot;If the control qubit is set than <span class=""math-container"">$U$</span> is applied to the target, otherwise it is left alone.&quot;</p>
<p>So perhaps my question would be better summarised as, what does it mean for the control qubit to be &quot;set&quot;?</p>
",How to interpret the encoding circuit for the 5-qubit QECC,<circuit-construction><quantum-circuit><pauli-gates>,1,2,,,"How to interpret the encoding circuit for the 5-qubit QECC <p>I have a question on circuit which constitutes the sydnrome measurement for the 5-qubit error correcting code. If I focus on just a portion of the circuit:</p>
<p><a href=""https://i.sstatic.net/EBapy.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/EBapy.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://www.physics.unlv.edu/%7Ebernard/MATH_book/Chap9/Notebook9_3.pdf"" rel=""nofollow noreferrer"">Reference for image</a>. The full circuit can be found on page <span class=""math-container"">$3$</span> of the Notebook just referenced.</p>
<p>So I have a five qubit state <span class=""math-container"">$|\psi\rangle$</span> and an ancilla qubit in the <span class=""math-container"">$|0\rangle$</span> state.</p>
<p>If, for example, we say the state <span class=""math-container"">$|\psi\rangle = |0_{5L}\rangle$</span>, I am a litte confused as to the circuit works.</p>
<p>My understanding would be (and please note I think I am quite wrong about this):</p>
<ol>
<li>We begin with the <span class=""math-container"">$|000000\rangle$</span> state</li>
<li>We apply the Hadamard operator to the first qubit, so the resulting state is <span class=""math-container"">$|+00000\rangle$</span></li>
<li>The 1st qubit is the control qubit and the 2nd qubit is the target qubit. But I am not quite sure how this works for the Pauli matrices? I know that for the CNOT operation, if the control qubit is in the <span class=""math-container"">$|1\rangle$</span> state, then the target qubit undergoes a bit flip. How does this work in this circuit with the Pauli matrices?</li>
<li>I have the same gap in understanding for the next few steps.</li>
</ol>
<hr />
<p>From Nielsen and Chuang's textbook, <span class=""math-container"">$$|c\rangle |t\rangle \rightarrow |c\rangle U^{c}|t\rangle$$</span> &quot;If the control qubit is set than <span class=""math-container"">$U$</span> is applied to the target, otherwise it is left alone.&quot;</p>
<p>So perhaps my question would be better summarised as, what does it mean for the control qubit to be &quot;set&quot;?</p>
",qc,interpret encoding circuit qecc p question circuit constitutes sydnrome measurement error correcting code focus portion circuit p https nofollow noreferrer img https enter image description p https nofollow noreferrer reference image full circuit found page span 3 notebook p five qubit state span ancilla qubit span p example say state span 5l litte confused circuit p understanding would please note think quite wrong ol li begin span state li apply hadamard operator first qubit resulting state span li 1st qubit control qubit 2nd qubit target qubit quite sure works pauli matrices know cnot operation control qubit span state target qubit undergoes bit flip work circuit pauli matrices li gap understanding next hr p nielsen chuang textbook span c quot control qubit set span u applied target otherwise left quot p perhaps question would better summarised mean control qubit quot set quot,"[(3, 0.18839335), (4, 0.25382507), (5, 0.08225109), (7, 0.04306824), (9, 0.02935486), (17, 0.012682014), (18, 0.3576996), (19, 0.031856798)]"
34569,34578.0,2023-10-23 15:54:01,1,403,"<p>I would like to understand the exact role of the following circuit (<a href=""https://commons.wikimedia.org/w/index.php?curid=109116146"" rel=""nofollow noreferrer"">By Vtomole - Own work, CC BY-SA 4.0</a>) in the 5-qubit QECC. <a href=""https://i.sstatic.net/Mxirb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Mxirb.png"" alt=""enter image description here"" /></a></p>
<p>The image attached (from Wikipedia) is captioned &quot;Quantum Circuit that Measures Stabilizers in the Five Qubit Error Correcting Code&quot;.</p>
<p><strong>Background</strong>
According to Nielsen and Chuang, &quot;the five qubit code has the generators <span class=""math-container"">$$g_{1} = XZZXI$$</span> <span class=""math-container"">$$g_{2} = IXZZX$$</span> <span class=""math-container"">$$g_{3} = XIXZZ$$</span> <span class=""math-container"">$$g_{4} = ZXIXZ$$</span> and it has the logical <span class=""math-container"">$Z$</span> and logical <span class=""math-container"">$X$</span> operators <span class=""math-container"">$$\bar{Z} = ZZZZZ$$</span> <span class=""math-container"">$$\bar{X} = XXXXX$$</span> However, their textbook does not give explicit detail as to how this code works.</p>
<p><strong>My interpretation of the circuit</strong></p>
<p>My understanding is the the codewords are logical 0 and logical 1 qubits</p>
<p><span class=""math-container"">$|0\rangle _{5L} = \frac{1}{4} (I + g_{1})(I +g_{2})(I + g_{3})(I + g_{4})|0\rangle \otimes |0\rangle \otimes |0\rangle \otimes |0\rangle \otimes |0\rangle$</span></p>
<p>and the same idea for</p>
<p><span class=""math-container"">$|1\rangle_{5L} = \frac{1}{4} (I + g_{1})(I +g_{2})(I + g_{3})(I + g_{4})|1\rangle \otimes |1\rangle \otimes |1\rangle \otimes |1\rangle \otimes |1\rangle $</span> .</p>
<p>So these are the possible starting states of the 5-qubit state <span class=""math-container"">$|\psi\rangle$</span>.</p>
<p><strong>First question: Why do we do this to obtain the codewords?</strong></p>
<p>We go through the circuit and eventually measure the 4 ancillary qubits to output four pieces of information, (I assume these bits will correspond to the error that we may have in our codeword. For example, if there was an <span class=""math-container"">$X$</span> error on the first ancillary qubit then we will output <span class=""math-container"">$0001$</span> from the circuit?</p>
<p><strong>My question(s)</strong></p>
<p>But then where do the <span class=""math-container"">$\bar{X}$</span> and <span class=""math-container"">$\bar{Z}$</span> operators come in? Is this even a correct interpretation of the circuit? How does the circuit fit into the overall QECC?</p>
",How to interpret the circuit that measures stabilizers in the 5-qubit error correcting code,<circuit-construction><error-correction><quantum-circuit><stabilizer-code>,1,0,,,"How to interpret the circuit that measures stabilizers in the 5-qubit error correcting code <p>I would like to understand the exact role of the following circuit (<a href=""https://commons.wikimedia.org/w/index.php?curid=109116146"" rel=""nofollow noreferrer"">By Vtomole - Own work, CC BY-SA 4.0</a>) in the 5-qubit QECC. <a href=""https://i.sstatic.net/Mxirb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Mxirb.png"" alt=""enter image description here"" /></a></p>
<p>The image attached (from Wikipedia) is captioned &quot;Quantum Circuit that Measures Stabilizers in the Five Qubit Error Correcting Code&quot;.</p>
<p><strong>Background</strong>
According to Nielsen and Chuang, &quot;the five qubit code has the generators <span class=""math-container"">$$g_{1} = XZZXI$$</span> <span class=""math-container"">$$g_{2} = IXZZX$$</span> <span class=""math-container"">$$g_{3} = XIXZZ$$</span> <span class=""math-container"">$$g_{4} = ZXIXZ$$</span> and it has the logical <span class=""math-container"">$Z$</span> and logical <span class=""math-container"">$X$</span> operators <span class=""math-container"">$$\bar{Z} = ZZZZZ$$</span> <span class=""math-container"">$$\bar{X} = XXXXX$$</span> However, their textbook does not give explicit detail as to how this code works.</p>
<p><strong>My interpretation of the circuit</strong></p>
<p>My understanding is the the codewords are logical 0 and logical 1 qubits</p>
<p><span class=""math-container"">$|0\rangle _{5L} = \frac{1}{4} (I + g_{1})(I +g_{2})(I + g_{3})(I + g_{4})|0\rangle \otimes |0\rangle \otimes |0\rangle \otimes |0\rangle \otimes |0\rangle$</span></p>
<p>and the same idea for</p>
<p><span class=""math-container"">$|1\rangle_{5L} = \frac{1}{4} (I + g_{1})(I +g_{2})(I + g_{3})(I + g_{4})|1\rangle \otimes |1\rangle \otimes |1\rangle \otimes |1\rangle \otimes |1\rangle $</span> .</p>
<p>So these are the possible starting states of the 5-qubit state <span class=""math-container"">$|\psi\rangle$</span>.</p>
<p><strong>First question: Why do we do this to obtain the codewords?</strong></p>
<p>We go through the circuit and eventually measure the 4 ancillary qubits to output four pieces of information, (I assume these bits will correspond to the error that we may have in our codeword. For example, if there was an <span class=""math-container"">$X$</span> error on the first ancillary qubit then we will output <span class=""math-container"">$0001$</span> from the circuit?</p>
<p><strong>My question(s)</strong></p>
<p>But then where do the <span class=""math-container"">$\bar{X}$</span> and <span class=""math-container"">$\bar{Z}$</span> operators come in? Is this even a correct interpretation of the circuit? How does the circuit fit into the overall QECC?</p>
",qc,interpret circuit measures stabilizers error correcting code p would like understand exact role following circuit https nofollow noreferrer vtomole work cc qecc https nofollow noreferrer img https enter image description p image attached wikipedia captioned quot quantum circuit measures stabilizers five qubit error correcting code quot p strong background according nielsen chuang quot five qubit code generators span 1 xzzxi span 2 ixzzx span 3 xixzz span 4 zxixz logical span z logical span x operators span z zzzzz span x xxxxx however textbook give explicit detail code p strong interpretation circuit p understanding codewords logical 0 logical 1 qubits p span 5l 1 4 1 2 3 4 p idea p span 5l 1 4 1 2 3 4 p possible starting states state span p strong first question obtain codewords p go circuit eventually measure 4 ancillary qubits output four pieces information assume bits correspond error may codeword example span x error first ancillary qubit output span 0001 circuit p strong question p span x span z operators come even correct interpretation circuit circuit fit overall qecc,"[(2, 0.10022618), (3, 0.17705882), (4, 0.18901104), (5, 0.20872976), (9, 0.15332207), (10, 0.025626969), (17, 0.0120927235), (18, 0.11527253), (19, 0.018027935)]"
34630,,2023-10-28 09:52:34,3,148,"<p>In the research of quantum error correction, noise is often classified into code capacity noise, phenomenological noise, and circuit-level noise. Among these, circuit-level noise is considered the most realistic noise. However, I believe that there are actually noise sources that are not taken into account even with circuit-level noise. What are some examples of noise that are not considered even with circuit-level noise?</p>
",What are overlooked noise sources in circuit-level noise?,<error-correction><noise>,1,0,,,"What are overlooked noise sources in circuit-level noise? <p>In the research of quantum error correction, noise is often classified into code capacity noise, phenomenological noise, and circuit-level noise. Among these, circuit-level noise is considered the most realistic noise. However, I believe that there are actually noise sources that are not taken into account even with circuit-level noise. What are some examples of noise that are not considered even with circuit-level noise?</p>
",qc,overlooked noise sources noise p research quantum error correction noise often classified code capacity noise phenomenological noise noise among noise considered realistic noise however believe actually noise sources taken account even noise examples noise considered even noise,"[(5, 0.5144518), (8, 0.38511333), (17, 0.027379917), (19, 0.06874996)]"
34646,,2023-10-30 06:18:35,2,47,"<p>The POVM element <span class=""math-container"">$E_{i}$</span> is associated with the measurement outcome <span class=""math-container"">$i$</span>, such that the probability of obtaining it when making a measurement on the quantum state
<span class=""math-container"">$\rho$</span>  is given by: <span class=""math-container"">$p(i)=tr(\rho E_i)$</span>;</p>
<p>So what does the outcome <span class=""math-container"">$i$</span> refer to? It looks like it's just an index symbol and <span class=""math-container"">$\sum_{i=1}^n E_i=I$</span>.</p>
",What does the outcome $i$ mean when we measuring a quantum system?,<measurement><povm>,1,0,,,"What does the outcome $i$ mean when we measuring a quantum system? <p>The POVM element <span class=""math-container"">$E_{i}$</span> is associated with the measurement outcome <span class=""math-container"">$i$</span>, such that the probability of obtaining it when making a measurement on the quantum state
<span class=""math-container"">$\rho$</span>  is given by: <span class=""math-container"">$p(i)=tr(\rho E_i)$</span>;</p>
<p>So what does the outcome <span class=""math-container"">$i$</span> refer to? It looks like it's just an index symbol and <span class=""math-container"">$\sum_{i=1}^n E_i=I$</span>.</p>
",qc,outcome mean measuring quantum system p povm element span associated measurement outcome span probability obtaining making measurement quantum state span given span p p outcome span refer looks like index symbol span,"[(3, 0.6509984), (17, 0.02318236), (18, 0.3205386)]"
34669,,2023-10-31 19:26:09,2,83,"<p>I am trying to run a simple VQE calculation on H2 using FakeManila noise model and ZNE for error mitigation; see code below. The problem is that I can never reach not even close the ground electronic state energy (~-1.8551550878043606 Eh) at this geometry (as obtained at FCI/sto-3g level and also with ibm_qasm_simulator). I was wondering whether someboby more experience could help me in spotting any possible problem.</p>
<pre><code>import numpy as np

from qiskit_nature.units import DistanceUnit
from qiskit_nature.second_q.drivers import PySCFDriver

import qiskit_nature
from qiskit_nature.second_q.circuit.library import HartreeFock, UCCSD
from qiskit_nature.second_q.mappers import JordanWignerMapper
from qiskit.algorithms.optimizers import COBYLA

from qiskit.providers.fake_provider import FakeManila
from qiskit_aer.noise import NoiseModel

from qiskit_ibm_runtime import (
    QiskitRuntimeService,
    Estimator,
    Options,
    Session
)

# Avoid using the deprecated `PauliSumOp` object
qiskit_nature.settings.use_pauli_sum_op = False

# using qiskit runtime service
service = QiskitRuntimeService()

# run on simulator
backend = service.backend(&quot;ibmq_qasm_simulator&quot;)

# Import a noise model
fake_backend = FakeManila()
noise_model = NoiseModel.from_backend(fake_backend)

options = Options()
# simulator options
options.simulator = {
    &quot;noise_model&quot;: noise_model,
    &quot;seed_simulator&quot;: 42
}
# error supression options
options.optimization_level = 3
# error mitigation options
options.resilience_level = 2  # ZNE
# zne options
# options.resilience.noise_amplifier = 'CxAmplifier'
# options.resilience.noise_factors = tuple(range(1, 9, 2))
# options.resilience.extrapolator = 'LinearExtrapolator'
# execution options
options.execution.shots = 6000

# Use estimator to get the expected values
estimator = Estimator(backend=backend, options=options)

# Calculate qubit hamiltonian
driver = PySCFDriver(
    atom=&quot;H 0 0 0; H 0 0 0.737166&quot;,
    basis=&quot;sto3g&quot;,
    charge=0,
    spin=0,
    unit=DistanceUnit.ANGSTROM,
)

problem = driver.run()
print(f&quot;Reference energy: {problem.reference_energy}&quot;)

nuc_rep_energy = problem.nuclear_repulsion_energy
print(f&quot;Nuclear repulsion energy: {nuc_rep_energy}&quot;)

hamiltonian = problem.hamiltonian
second_q_op = hamiltonian.second_q_op()

mapper = JordanWignerMapper()
qubit_op = mapper.map(second_q_op)

# Set up the variational form/ansatz
n_active_electrons = (1, 1)  # =&gt; (n_alpha, n_beta)
n_active_spatial_orbitals = 2

reference_state = HartreeFock(
    n_active_spatial_orbitals,
    n_active_electrons,
    mapper,
)

# print(reference_state.draw())

ansatz = UCCSD(
    n_active_spatial_orbitals,
    n_active_electrons,
    mapper,
    initial_state=reference_state
)

# print(ansatz.decompose().draw())


def cost_func(params):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    job = estimator.run(ansatz, qubit_op, parameter_values=params)
    result = job.result()
    energy = result.values[0]
    print(&quot;=== COST FUNCTION SUMMARY ===&quot;)
    print(f&quot;&gt;&gt;&gt; Job ID: {job.job_id()}&quot;)
    print(f&quot;&gt;&gt;&gt; Job Status: {job.status()}&quot;)
    print(&quot;=============================&quot;)
    print(f&quot;&gt;&gt;&gt; Job Input: {job.inputs}&quot;)
    print(&quot;=============================&quot;)
    print(f&quot;&gt;&gt;&gt; Backend: {job.backend()}&quot;)
    print(f&quot;&gt;&gt;&gt; {result}&quot;)
    print(&quot;=============================&quot;)
    print(f&quot;&gt;&gt;&gt; Expectation value (Hartree): {energy}&quot;)
    print(f&quot;&gt;&gt;&gt; Total ground state energy (Hartree): {energy+nuc_rep_energy}&quot;)
    print(&quot;=============================\n&quot;)
    return energy


with Session(service=service, backend=backend) as session:

    initial_theta = np.array([1.57079357, 1.57087253, 1.45852109])
    # cost_func(initial_theta)

    optimizer = COBYLA()
    res = optimizer.minimize(
        cost_func,
        x0=initial_theta
    )
    print(res)

    session.close()

<span class=""math-container"">```</span>
</code></pre>
",Qiskit noisy FakeManila simulator + ZNE,<qiskit><simulation><vqe><noise>,0,0,,,"Qiskit noisy FakeManila simulator + ZNE <p>I am trying to run a simple VQE calculation on H2 using FakeManila noise model and ZNE for error mitigation; see code below. The problem is that I can never reach not even close the ground electronic state energy (~-1.8551550878043606 Eh) at this geometry (as obtained at FCI/sto-3g level and also with ibm_qasm_simulator). I was wondering whether someboby more experience could help me in spotting any possible problem.</p>
<pre><code>import numpy as np

from qiskit_nature.units import DistanceUnit
from qiskit_nature.second_q.drivers import PySCFDriver

import qiskit_nature
from qiskit_nature.second_q.circuit.library import HartreeFock, UCCSD
from qiskit_nature.second_q.mappers import JordanWignerMapper
from qiskit.algorithms.optimizers import COBYLA

from qiskit.providers.fake_provider import FakeManila
from qiskit_aer.noise import NoiseModel

from qiskit_ibm_runtime import (
    QiskitRuntimeService,
    Estimator,
    Options,
    Session
)

# Avoid using the deprecated `PauliSumOp` object
qiskit_nature.settings.use_pauli_sum_op = False

# using qiskit runtime service
service = QiskitRuntimeService()

# run on simulator
backend = service.backend(&quot;ibmq_qasm_simulator&quot;)

# Import a noise model
fake_backend = FakeManila()
noise_model = NoiseModel.from_backend(fake_backend)

options = Options()
# simulator options
options.simulator = {
    &quot;noise_model&quot;: noise_model,
    &quot;seed_simulator&quot;: 42
}
# error supression options
options.optimization_level = 3
# error mitigation options
options.resilience_level = 2  # ZNE
# zne options
# options.resilience.noise_amplifier = 'CxAmplifier'
# options.resilience.noise_factors = tuple(range(1, 9, 2))
# options.resilience.extrapolator = 'LinearExtrapolator'
# execution options
options.execution.shots = 6000

# Use estimator to get the expected values
estimator = Estimator(backend=backend, options=options)

# Calculate qubit hamiltonian
driver = PySCFDriver(
    atom=&quot;H 0 0 0; H 0 0 0.737166&quot;,
    basis=&quot;sto3g&quot;,
    charge=0,
    spin=0,
    unit=DistanceUnit.ANGSTROM,
)

problem = driver.run()
print(f&quot;Reference energy: {problem.reference_energy}&quot;)

nuc_rep_energy = problem.nuclear_repulsion_energy
print(f&quot;Nuclear repulsion energy: {nuc_rep_energy}&quot;)

hamiltonian = problem.hamiltonian
second_q_op = hamiltonian.second_q_op()

mapper = JordanWignerMapper()
qubit_op = mapper.map(second_q_op)

# Set up the variational form/ansatz
n_active_electrons = (1, 1)  # =&gt; (n_alpha, n_beta)
n_active_spatial_orbitals = 2

reference_state = HartreeFock(
    n_active_spatial_orbitals,
    n_active_electrons,
    mapper,
)

# print(reference_state.draw())

ansatz = UCCSD(
    n_active_spatial_orbitals,
    n_active_electrons,
    mapper,
    initial_state=reference_state
)

# print(ansatz.decompose().draw())


def cost_func(params):
    &quot;&quot;&quot;Return estimate of energy from estimator

    Parameters:
        params (ndarray): Array of ansatz parameters

    Returns:
        float: Energy estimate
    &quot;&quot;&quot;
    job = estimator.run(ansatz, qubit_op, parameter_values=params)
    result = job.result()
    energy = result.values[0]
    print(&quot;=== COST FUNCTION SUMMARY ===&quot;)
    print(f&quot;&gt;&gt;&gt; Job ID: {job.job_id()}&quot;)
    print(f&quot;&gt;&gt;&gt; Job Status: {job.status()}&quot;)
    print(&quot;=============================&quot;)
    print(f&quot;&gt;&gt;&gt; Job Input: {job.inputs}&quot;)
    print(&quot;=============================&quot;)
    print(f&quot;&gt;&gt;&gt; Backend: {job.backend()}&quot;)
    print(f&quot;&gt;&gt;&gt; {result}&quot;)
    print(&quot;=============================&quot;)
    print(f&quot;&gt;&gt;&gt; Expectation value (Hartree): {energy}&quot;)
    print(f&quot;&gt;&gt;&gt; Total ground state energy (Hartree): {energy+nuc_rep_energy}&quot;)
    print(&quot;=============================\n&quot;)
    return energy


with Session(service=service, backend=backend) as session:

    initial_theta = np.array([1.57079357, 1.57087253, 1.45852109])
    # cost_func(initial_theta)

    optimizer = COBYLA()
    res = optimizer.minimize(
        cost_func,
        x0=initial_theta
    )
    print(res)

    session.close()

<span class=""math-container"">```</span>
</code></pre>
",qc,qiskit noisy fakemanila simulator zne p trying run simple vqe calculation h2 using fakemanila noise model zne error mitigation see code problem never reach even close ground electronic state energy eh geometry obtained level also wondering whether someboby experience could help spotting possible pre code import numpy np import distanceunit import pyscfdriver import import hartreefock uccsd import jordanwignermapper import cobyla import fakemanila import noisemodel import qiskitruntimeservice estimator options session avoid using deprecated paulisumop object false using qiskit runtime service service qiskitruntimeservice run simulator backend quot quot import noise model fakemanila options options simulator options quot quot quot quot 42 error supression options 3 error mitigation options 2 zne zne options tuple range 1 9 2 execution options 6000 use estimator get expected values estimator estimator calculate qubit hamiltonian driver pyscfdriver quot h 0 0 0 h 0 0 quot quot sto3g quot problem print f quot reference energy quot print f quot nuclear repulsion energy quot hamiltonian mapper jordanwignermapper set variational 1 1 gt 2 hartreefock mapper print ansatz uccsd mapper print def params quot quot quot return estimate energy estimator parameters params ndarray array ansatz parameters returns float energy estimate quot quot quot job ansatz result energy 0 print quot cost function summary quot print f quot gt gt gt job id quot print f quot gt gt gt job status quot print quot quot print f quot gt gt gt job input quot print quot quot print f quot gt gt gt backend quot print f quot gt gt gt result quot print quot quot print f quot gt gt gt expectation value hartree energy quot print f quot gt gt gt total ground state energy hartree quot print quot quot return energy session session optimizer cobyla res print res span,"[(0, 0.45820737), (1, 0.03034676), (2, 0.041090664), (8, 0.06598054), (10, 0.015645152), (17, 0.060325686), (19, 0.31999344)]"
34688,34695.0,2023-11-02 10:00:44,1,55,"<p>I know that Stim has the option to play a conditioned pulse based on a previous measurment by writing <code>CZ rec[-1] 1</code> which does a Z gate on qb1 if the last measurment is 1. Now I am wondering whether you could do feedback based on two previous measurments, say if the last two readouts gave 1, play a conditioned pulse on qb1. I tried something like <code>CZ rec[-1]*rec[-2] 1</code>, but this isn't supported unfortunately.
Does anyone have an idea if this is possible in Stim?
Any help is much appreachiated!</p>
",feedback based on multiple measurments,<stim>,1,0,,,"feedback based on multiple measurments <p>I know that Stim has the option to play a conditioned pulse based on a previous measurment by writing <code>CZ rec[-1] 1</code> which does a Z gate on qb1 if the last measurment is 1. Now I am wondering whether you could do feedback based on two previous measurments, say if the last two readouts gave 1, play a conditioned pulse on qb1. I tried something like <code>CZ rec[-1]*rec[-2] 1</code>, but this isn't supported unfortunately.
Does anyone have an idea if this is possible in Stim?
Any help is much appreachiated!</p>
",qc,feedback based multiple measurments p know stim option play conditioned pulse based previous measurment writing code cz rec 1 z gate qb1 last measurment wondering whether could feedback based two previous measurments say last two readouts gave 1 play conditioned pulse qb1 tried something like code cz rec rec 1 supported unfortunately anyone idea possible stim help much appreachiated,"[(2, 0.056871843), (5, 0.19719534), (6, 0.12156507), (14, 0.58254415), (17, 0.039152283)]"
34712,,2023-11-04 16:15:22,4,113,"<p>Let <span class=""math-container"">$\mathcal{X} \in {\rm CP}(\mathcal{H}, \mathcal{K})$</span> and unital (compositive positive and unital maps). Let <span class=""math-container"">$\mathcal{Y} \in {\rm CPT}(\mathcal{H}, \mathcal{K})$</span>(complete positive and trace preserving). We can derive
<span class=""math-container"">$$
\langle {\rm id}, \mathcal{Y} \rangle \leq \Vert {\rm id} \Vert_F \Vert \mathcal{Y} \Vert_F \leq d^2,\tag1
$$</span>
where the equality holds when <span class=""math-container"">${\rm id}=\mathcal{Y}$</span> (This can be found in the <a href=""https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.2.010201"" rel=""nofollow noreferrer"">proof of lemma 48</a>). Now we aim to use the above inequality to evaluate
<span class=""math-container"">$$
\langle \mathcal{X}, \mathcal{Y} \rangle = \langle {\rm id}, \mathcal{X}^\dagger\circ \mathcal{Y} \rangle \leq d^2,\tag2
$$</span>
where the inequality is due to the fact that <span class=""math-container"">$\mathcal{X}$</span> is unital and CP, so <span class=""math-container"">$\mathcal{X}^\dagger$</span> is CPT, then <span class=""math-container"">$\mathcal{X}^\dagger \circ \mathcal{Y}$</span> is CPT. By Cauchy-Schwarz inequality, the equality holds when <span class=""math-container"">$\mathcal{X}^\dagger \circ \mathcal{Y}={\rm id}$</span>. Also, if we directly use Cauchy-Schwarz inequality for <span class=""math-container"">$\langle \mathcal{X}, \mathcal{Y} \rangle$</span>, the equality holds when <span class=""math-container"">$\mathcal{X}=\mathcal{Y}$</span>. Then we can deduce that <span class=""math-container"">$\mathcal{X} = \mathcal{Y}$</span> is equavalent to <span class=""math-container"">$\mathcal{X}^\dagger \circ \mathcal{Y}={\rm id}$</span>. However, it is not generally true. So, what are the problems of these derivations?</p>
",Infidelity as distance measure,<quantum-operation><fidelity>,1,2,,,"Infidelity as distance measure <p>Let <span class=""math-container"">$\mathcal{X} \in {\rm CP}(\mathcal{H}, \mathcal{K})$</span> and unital (compositive positive and unital maps). Let <span class=""math-container"">$\mathcal{Y} \in {\rm CPT}(\mathcal{H}, \mathcal{K})$</span>(complete positive and trace preserving). We can derive
<span class=""math-container"">$$
\langle {\rm id}, \mathcal{Y} \rangle \leq \Vert {\rm id} \Vert_F \Vert \mathcal{Y} \Vert_F \leq d^2,\tag1
$$</span>
where the equality holds when <span class=""math-container"">${\rm id}=\mathcal{Y}$</span> (This can be found in the <a href=""https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.2.010201"" rel=""nofollow noreferrer"">proof of lemma 48</a>). Now we aim to use the above inequality to evaluate
<span class=""math-container"">$$
\langle \mathcal{X}, \mathcal{Y} \rangle = \langle {\rm id}, \mathcal{X}^\dagger\circ \mathcal{Y} \rangle \leq d^2,\tag2
$$</span>
where the inequality is due to the fact that <span class=""math-container"">$\mathcal{X}$</span> is unital and CP, so <span class=""math-container"">$\mathcal{X}^\dagger$</span> is CPT, then <span class=""math-container"">$\mathcal{X}^\dagger \circ \mathcal{Y}$</span> is CPT. By Cauchy-Schwarz inequality, the equality holds when <span class=""math-container"">$\mathcal{X}^\dagger \circ \mathcal{Y}={\rm id}$</span>. Also, if we directly use Cauchy-Schwarz inequality for <span class=""math-container"">$\langle \mathcal{X}, \mathcal{Y} \rangle$</span>, the equality holds when <span class=""math-container"">$\mathcal{X}=\mathcal{Y}$</span>. Then we can deduce that <span class=""math-container"">$\mathcal{X} = \mathcal{Y}$</span> is equavalent to <span class=""math-container"">$\mathcal{X}^\dagger \circ \mathcal{Y}={\rm id}$</span>. However, it is not generally true. So, what are the problems of these derivations?</p>
",qc,infidelity distance measure p let span x cp h k unital compositive positive unital maps let span cpt h k complete positive trace preserving derive span id id equality holds span id found https nofollow noreferrer proof lemma 48 aim use inequality evaluate span x id x inequality due fact span x unital cp span x cpt span x cpt inequality equality holds span x id also directly use inequality span x equality holds span x deduce span x equavalent span x id however generally true problems derivations,"[(1, 0.012833754), (3, 0.5969727), (4, 0.029699566), (9, 0.019222308), (10, 0.15870997), (11, 0.06283199), (15, 0.038655657), (17, 0.07966282)]"
34727,,2023-11-05 21:16:12,2,36,"<p>The decompose() function decomposes the encapsulated quantum module into sets of elementary quantum gates. But what is the math behind its operation? For example how is a diag[1,1,1,1,1-1,1,1,1,1] decomposed into the following circuit? If I also want to decompose diag[1,-1,-1,1,1,1,1,-1,1] what will be its laws?</p>
<p><a href=""https://i.sstatic.net/MnjqQ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MnjqQ.png"" alt=""enter image description here"" /></a></p>
",What is the mathematical rationale for the decompose() function of qiskit?,<qiskit><circuit-construction>,0,0,,,"What is the mathematical rationale for the decompose() function of qiskit? <p>The decompose() function decomposes the encapsulated quantum module into sets of elementary quantum gates. But what is the math behind its operation? For example how is a diag[1,1,1,1,1-1,1,1,1,1] decomposed into the following circuit? If I also want to decompose diag[1,-1,-1,1,1,1,1,-1,1] what will be its laws?</p>
<p><a href=""https://i.sstatic.net/MnjqQ.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/MnjqQ.png"" alt=""enter image description here"" /></a></p>
",qc,mathematical rationale decompose function qiskit p decompose function decomposes encapsulated quantum module sets elementary quantum gates math behind operation example diag decomposed following circuit also want decompose diag 1 laws p https nofollow noreferrer img https enter image description,"[(4, 0.5173518), (9, 0.26962027), (10, 0.031644735), (14, 0.14998068), (17, 0.027473351)]"
34756,,2023-11-07 20:20:18,3,78,"<p>Suppose I have a <span class=""math-container"">$[[n,k,d]]$</span>-quantum error correction code. Let us take the toric code <span class=""math-container"">$(T^2=S^1 \times S^1)$</span> as an example. We have 2 logical qubits whose logical operators lie along the different circles <span class=""math-container"">$S^1$</span>. How do we engineer interactions that manipulate only one of the degrees of freedom or distinguish them as target and control? For example, how do we implement <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U:|00\rangle\mapsto|10\rangle$</span> and CNOT such that CNOT: <span class=""math-container"">$|10\rangle\mapsto|11\rangle$</span>?</p>
","How to address the 2 logical qubits on the toric code individually? In general, how to address $k$ logical qubits in a $[[n,k,d]]$ code independently?",<error-correction><surface-code><toric-code>,0,0,,,"How to address the 2 logical qubits on the toric code individually? In general, how to address $k$ logical qubits in a $[[n,k,d]]$ code independently? <p>Suppose I have a <span class=""math-container"">$[[n,k,d]]$</span>-quantum error correction code. Let us take the toric code <span class=""math-container"">$(T^2=S^1 \times S^1)$</span> as an example. We have 2 logical qubits whose logical operators lie along the different circles <span class=""math-container"">$S^1$</span>. How do we engineer interactions that manipulate only one of the degrees of freedom or distinguish them as target and control? For example, how do we implement <span class=""math-container"">$U$</span> such that <span class=""math-container"">$U:|00\rangle\mapsto|10\rangle$</span> and CNOT such that CNOT: <span class=""math-container"">$|10\rangle\mapsto|11\rangle$</span>?</p>
",qc,address 2 logical qubits toric code individually general address k logical qubits n k code independently p suppose span n k error correction code let us take toric code span example 2 logical qubits whose logical operators lie along different circles span engineer interactions manipulate one degrees freedom distinguish target control example implement span u span u cnot cnot span,"[(3, 0.37535262), (4, 0.019198317), (5, 0.23099986), (9, 0.08011633), (13, 0.020860305), (17, 0.037104886), (18, 0.2342021)]"
34791,,2023-11-10 13:23:43,1,27,"<p>As far as I understand, transforming and maintaining states of qubit devices in quantum computers is associated with all sort of problems such as transformation errors and decoherence. At the same time, quantum mechanics describes states of a quantum system always relatively to the basis states of some measurement apparatus. This implies that, at least in principle, it should be possible to transform the measurement system, rather than the qubits, in performing &quot;quantum&quot; computation. The advantage of this approach would be that measurement instruments are macroscopic, can be controlled by classical computers, and can be described by laws of classical physics accurately. In fact, this line of reasoning suggests that some form of computing based on classical physics should be equivalent to quantum computation. So, here is my question: Is there anything wrong with this logic? Did anyone pursue this reasoning to try to construct classical analogs of quantum computers?</p>
",Can transformations of qubits in quantum computing be carried out instead by transformations of the measurement instrument?,<quantum-state><measurement><deferred-measurement>,0,1,,,"Can transformations of qubits in quantum computing be carried out instead by transformations of the measurement instrument? <p>As far as I understand, transforming and maintaining states of qubit devices in quantum computers is associated with all sort of problems such as transformation errors and decoherence. At the same time, quantum mechanics describes states of a quantum system always relatively to the basis states of some measurement apparatus. This implies that, at least in principle, it should be possible to transform the measurement system, rather than the qubits, in performing &quot;quantum&quot; computation. The advantage of this approach would be that measurement instruments are macroscopic, can be controlled by classical computers, and can be described by laws of classical physics accurately. In fact, this line of reasoning suggests that some form of computing based on classical physics should be equivalent to quantum computation. So, here is my question: Is there anything wrong with this logic? Did anyone pursue this reasoning to try to construct classical analogs of quantum computers?</p>
",qc,transformations qubits quantum computing carried instead transformations measurement instrument p far understand transforming maintaining states qubit devices quantum computers associated sort problems transformation errors decoherence time quantum mechanics describes states quantum system always relatively basis states measurement apparatus implies least principle possible transform measurement system rather qubits performing quot quantum quot computation advantage approach would measurement instruments macroscopic controlled classical computers described laws classical physics accurately fact line reasoning suggests form computing based classical physics equivalent quantum computation question anything wrong logic anyone pursue reasoning try construct classical analogs quantum computers,"[(1, 0.28146386), (5, 0.015053936), (7, 0.052651383), (8, 0.15706524), (9, 0.17766336), (13, 0.06314349), (17, 0.02426153), (18, 0.19396761), (19, 0.03348042)]"
34807,,2023-11-11 13:12:15,2,65,"<p>I am currently looking into 3D surface codes and was wondering if there are open-source implementations for decoders like MWPM or the Union Find decoder. I found quite a lot of different GitHub repos using 2D toric codes for both MWPM and Union Find, but none with a 3D implementation.</p>
<p>That is a bit odd, so I figured I just did not look good enough. Do you maybe have a tip where I could find such an implementation?</p>
",MWPM / Union Find Implementations for 3D Toric Code,<surface-code><topological-quantum-computing>,0,1,,,"MWPM / Union Find Implementations for 3D Toric Code <p>I am currently looking into 3D surface codes and was wondering if there are open-source implementations for decoders like MWPM or the Union Find decoder. I found quite a lot of different GitHub repos using 2D toric codes for both MWPM and Union Find, but none with a 3D implementation.</p>
<p>That is a bit odd, so I figured I just did not look good enough. Do you maybe have a tip where I could find such an implementation?</p>
",qc,mwpm union find implementations 3d toric code p currently looking 3d surface codes wondering implementations decoders like mwpm union find decoder found quite lot different github repos using 2d toric codes mwpm union find none 3d p bit odd figured look good enough maybe tip could find implementation,"[(5, 0.15202498), (7, 0.19021285), (8, 0.4014741), (13, 0.09621835), (17, 0.0463082), (19, 0.11079397)]"
34812,,2023-11-11 18:43:26,2,188,"<p>I understand the following code on why the specific swaps take place, but when I try to replicate it with <span class=""math-container"">$N=35$</span>, I get confused.</p>
<pre><code>def c_amod15(a, x):
if a not in [2,4,7,8,11,13]:
    raise ValueError(&quot;'a' must be 2,7,8,11,13&quot;)
U = QuantumCircuit(4)    

for iteration in range(x):
    if a in [2,13]:
        U.swap(0,1)
        U.swap(1,2)
        U.swap(2,3)
    if a in [7,8]:
        U.swap(2,3)
        U.swap(1,2)
        U.swap(0,1)
    if a == 11:
        U.swap(1,3)
        U.swap(0,2)
    if a in [7,11,13]:
        for q in range(4):
            U.x(q)
            
U = U.to_gate()
U.name = &quot;%i^%i mod 15&quot; % (a, x)
c_U = U.control()

return c_U

for x in range(n):
    exponent = 2**x
    circuit.append(c_amod15(a, exponent), 
                 [x] + list(range(n, n+m)))
</code></pre>
<p>For example, if <span class=""math-container"">$a=8\,,$</span></p>
<ul>
<li>0001 (start)</li>
<li>(1st swap) 0010</li>
<li>(2nd) 0100</li>
<li>(3rd) 1000</li>
<li>2nd iteration = 0100</li>
<li>3rd iteration = 0010</li>
<li>4th iteration = 0001</li>
</ul>
<p>This loops back to 1 with a period of 4.</p>
<p><a href=""https://i.sstatic.net/IRI7I.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IRI7I.png"" alt=""table of modular exponentiation"" /></a></p>
<p>When I try to repeat this with <span class=""math-container"">$N=35$</span> and, let's say, <span class=""math-container"">$a=8$</span>, I get the following values.</p>
<p><a href=""https://i.sstatic.net/6Rd4S.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6Rd4S.png"" alt=""Modular exponentiation for N=35 a=8"" /></a></p>
<p>1= 000001</p>
<p>8= 001000</p>
<p>29= 011101</p>
<p>22= 010110</p>
<p>The problem I'm having is I don't know how to loop through those numbers with just <span class=""math-container"">$SWAP$</span> and <span class=""math-container"">$X$</span> gates.</p>
",How to do modular exponentiation in qiskit with gates?,<qiskit><quantum-gate><shors-algorithm><modular-exponentiation>,0,0,,,"How to do modular exponentiation in qiskit with gates? <p>I understand the following code on why the specific swaps take place, but when I try to replicate it with <span class=""math-container"">$N=35$</span>, I get confused.</p>
<pre><code>def c_amod15(a, x):
if a not in [2,4,7,8,11,13]:
    raise ValueError(&quot;'a' must be 2,7,8,11,13&quot;)
U = QuantumCircuit(4)    

for iteration in range(x):
    if a in [2,13]:
        U.swap(0,1)
        U.swap(1,2)
        U.swap(2,3)
    if a in [7,8]:
        U.swap(2,3)
        U.swap(1,2)
        U.swap(0,1)
    if a == 11:
        U.swap(1,3)
        U.swap(0,2)
    if a in [7,11,13]:
        for q in range(4):
            U.x(q)
            
U = U.to_gate()
U.name = &quot;%i^%i mod 15&quot; % (a, x)
c_U = U.control()

return c_U

for x in range(n):
    exponent = 2**x
    circuit.append(c_amod15(a, exponent), 
                 [x] + list(range(n, n+m)))
</code></pre>
<p>For example, if <span class=""math-container"">$a=8\,,$</span></p>
<ul>
<li>0001 (start)</li>
<li>(1st swap) 0010</li>
<li>(2nd) 0100</li>
<li>(3rd) 1000</li>
<li>2nd iteration = 0100</li>
<li>3rd iteration = 0010</li>
<li>4th iteration = 0001</li>
</ul>
<p>This loops back to 1 with a period of 4.</p>
<p><a href=""https://i.sstatic.net/IRI7I.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/IRI7I.png"" alt=""table of modular exponentiation"" /></a></p>
<p>When I try to repeat this with <span class=""math-container"">$N=35$</span> and, let's say, <span class=""math-container"">$a=8$</span>, I get the following values.</p>
<p><a href=""https://i.sstatic.net/6Rd4S.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6Rd4S.png"" alt=""Modular exponentiation for N=35 a=8"" /></a></p>
<p>1= 000001</p>
<p>8= 001000</p>
<p>29= 011101</p>
<p>22= 010110</p>
<p>The problem I'm having is I don't know how to loop through those numbers with just <span class=""math-container"">$SWAP$</span> and <span class=""math-container"">$X$</span> gates.</p>
",qc,modular exponentiation qiskit gates p understand following code specific swaps take place try replicate span get pre code def x raise valueerror quot must quot u quantumcircuit 4 iteration range x 11 q range 4 q u quot mod 15 quot x return x range n exponent 2 x exponent x list range n p example span ul li 0001 start li 1st swap 0010 li 2nd 0100 li 3rd 1000 li 2nd iteration 0100 li 3rd iteration 0010 li 4th iteration 0001 p loops back 1 period p https nofollow noreferrer img https table modular exponentiation p try repeat span let say span get following p https nofollow noreferrer img https modular exponentiation p 000001 p 001000 p 011101 p 010110 p problem know loop numbers span swap span x,"[(0, 0.18043491), (3, 0.10053551), (4, 0.24314035), (6, 0.033047583), (7, 0.07813127), (10, 0.12421776), (14, 0.02980493), (17, 0.01734127), (18, 0.12990095), (19, 0.06263329)]"
34823,34831.0,2023-11-12 18:35:05,2,86,"<p>I have a Hamiltonian <span class=""math-container"">$$H = aH_1 + bH_2\,,\tag{1}$$</span> with <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> being coefficients, and I want to apply each term/evolution <strong>separately</strong>, then recombine the measurement results to get the result for the original.</p>
<p>Is there any way to do that, like classical post-processing? Or am I breaking the laws of physics?</p>
<p>Please suggest some useful resources so I can read and understand this better.</p>
",How to combine measurement of each term in Hamiltonian $H = aH_1 + bH_2$ to get final results?,<quantum-state><resource-request><hamiltonian>,1,4,,,"How to combine measurement of each term in Hamiltonian $H = aH_1 + bH_2$ to get final results? <p>I have a Hamiltonian <span class=""math-container"">$$H = aH_1 + bH_2\,,\tag{1}$$</span> with <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> being coefficients, and I want to apply each term/evolution <strong>separately</strong>, then recombine the measurement results to get the result for the original.</p>
<p>Is there any way to do that, like classical post-processing? Or am I breaking the laws of physics?</p>
<p>Please suggest some useful resources so I can read and understand this better.</p>
",qc,combine measurement term hamiltonian h get final results p hamiltonian span h 1 span span b coefficients want apply strong separately recombine measurement results get result p way like classical breaking laws physics p please suggest useful resources read understand,"[(1, 0.13270016), (3, 0.37550056), (8, 0.13086721), (14, 0.32496318), (17, 0.032141406)]"
34853,,2023-11-15 10:16:32,1,31,"<p>In the article <a href=""https://pubmed.ncbi.nlm.nih.gov/37440648/"" rel=""nofollow noreferrer""><em>&quot;Biasing the quantum vacuum to control macroscopic probability distributions&quot;</em></a>[<a href=""https://arxiv.org/abs/2303.03455"" rel=""nofollow noreferrer"">arXiv:2303.03455</a>],
authors present what they call a &quot;p-bit&quot; i.e., a probabilistic bit. It is a photon whose
probability for its phase to be <span class=""math-container"">$0$</span> or <span class=""math-container"">$\pi$</span> can be controlled.</p>
<p>In short, authors foresee
that this would be the cornerstone for a Probabilistic Power Unit which could
handle stochastic simulations much better than CPU, because (it is unclear actually to understand how) the p-bits would stand for the probability laws involved in stochastic simulations, instead of being compelled to perform Monte Carlo simulations on a CPU.</p>
<p><strong>Which leads to my question, can QPU perform stochastic simulations in a smarter way than a CPU ?</strong></p>
<p>To my opinion, this would mean to encode probability laws directly on qubit registers.</p>
<p>As an example, say a stochastic variable <span class=""math-container"">$X$</span> which can take real values <span class=""math-container"">$x_1,\dots,x_N$</span> with
probabilities <span class=""math-container"">$P(X=x_i)=p_i$</span> :
<span class=""math-container"">\begin{equation}\tag{1}
\sum_{i=1}^n p_i=1
\end{equation}</span></p>
<p>Assume we have several qubits <span class=""math-container"">$q_1,\dots,q_n$</span> such that <span class=""math-container"">$2^n = N$</span>. The register is
<span class=""math-container"">\begin{equation}\tag{2}
|q_1\dots q_n\rangle = a_1|0\dots 0\rangle + a_2|0\dots 01\rangle + \dots + a_N|1\dots 1\rangle
\end{equation}</span></p>
<p>The first problem I see is that the norm corresponding to (1) is the norm1 (absolute value)
whereas the function state (2) is normalized with respect to the Hilbert space norm.</p>
",Can you perform stochastic simulations on a quantum computer?,<quantum-state>,0,0,,,"Can you perform stochastic simulations on a quantum computer? <p>In the article <a href=""https://pubmed.ncbi.nlm.nih.gov/37440648/"" rel=""nofollow noreferrer""><em>&quot;Biasing the quantum vacuum to control macroscopic probability distributions&quot;</em></a>[<a href=""https://arxiv.org/abs/2303.03455"" rel=""nofollow noreferrer"">arXiv:2303.03455</a>],
authors present what they call a &quot;p-bit&quot; i.e., a probabilistic bit. It is a photon whose
probability for its phase to be <span class=""math-container"">$0$</span> or <span class=""math-container"">$\pi$</span> can be controlled.</p>
<p>In short, authors foresee
that this would be the cornerstone for a Probabilistic Power Unit which could
handle stochastic simulations much better than CPU, because (it is unclear actually to understand how) the p-bits would stand for the probability laws involved in stochastic simulations, instead of being compelled to perform Monte Carlo simulations on a CPU.</p>
<p><strong>Which leads to my question, can QPU perform stochastic simulations in a smarter way than a CPU ?</strong></p>
<p>To my opinion, this would mean to encode probability laws directly on qubit registers.</p>
<p>As an example, say a stochastic variable <span class=""math-container"">$X$</span> which can take real values <span class=""math-container"">$x_1,\dots,x_N$</span> with
probabilities <span class=""math-container"">$P(X=x_i)=p_i$</span> :
<span class=""math-container"">\begin{equation}\tag{1}
\sum_{i=1}^n p_i=1
\end{equation}</span></p>
<p>Assume we have several qubits <span class=""math-container"">$q_1,\dots,q_n$</span> such that <span class=""math-container"">$2^n = N$</span>. The register is
<span class=""math-container"">\begin{equation}\tag{2}
|q_1\dots q_n\rangle = a_1|0\dots 0\rangle + a_2|0\dots 01\rangle + \dots + a_N|1\dots 1\rangle
\end{equation}</span></p>
<p>The first problem I see is that the norm corresponding to (1) is the norm1 (absolute value)
whereas the function state (2) is normalized with respect to the Hilbert space norm.</p>
",qc,perform stochastic simulations quantum computer p article https nofollow noreferrer em quot biasing quantum vacuum control macroscopic probability distributions quot https nofollow noreferrer authors present call quot quot probabilistic bit photon whose probability phase span 0 span p short authors foresee would cornerstone probabilistic power unit could handle stochastic simulations much better cpu unclear actually understand would stand probability laws involved stochastic simulations instead compelled perform monte carlo simulations p strong leads question qpu perform stochastic simulations smarter way cpu p opinion would mean encode probability laws directly qubit p example say stochastic variable span x take real values span probabilities span p span equation 1 equation p assume several qubits span span n register span equation 2 equation p first problem see norm corresponding 1 norm1 absolute value whereas function state 2 normalized respect hilbert space,"[(2, 0.024080303), (3, 0.42152938), (4, 0.052820742), (8, 0.25270846), (14, 0.09272588), (17, 0.02705682), (18, 0.07791628), (19, 0.0417274)]"
34875,34890.0,2023-11-16 14:20:06,1,138,"<p>I'm reading the <a href=""https://arxiv.org/abs/2310.05900"" rel=""nofollow noreferrer"">paper</a> of Google's neural network decoder for surface code, and I'm confused about how to generate the measurement results for pre-training dataset.</p>
<p>If I understand it correctly, the dataset for pre-training stage was drawn from detector error models derived from correlation analysis of even subsets of experimental data. However, we can only sample the detection events instead of the raw measurements given the DEM, and the map between the detection events and measurements is not a bijection obviously. While the pre-training stage leveraged both the measurements and detection events, how was the measurements generated properly from the DEMs?</p>
<hr />
<p>EDITED:</p>
<p>I realized that they did not use the measurements of data qubits at the final round in the model to avoid leaking labels. Given the initial state, then the map between the measurements and dets is truly a bijection.</p>
",How to properly generate circuit measurement results from detector error model,<error-correction><stim>,1,0,,,"How to properly generate circuit measurement results from detector error model <p>I'm reading the <a href=""https://arxiv.org/abs/2310.05900"" rel=""nofollow noreferrer"">paper</a> of Google's neural network decoder for surface code, and I'm confused about how to generate the measurement results for pre-training dataset.</p>
<p>If I understand it correctly, the dataset for pre-training stage was drawn from detector error models derived from correlation analysis of even subsets of experimental data. However, we can only sample the detection events instead of the raw measurements given the DEM, and the map between the detection events and measurements is not a bijection obviously. While the pre-training stage leveraged both the measurements and detection events, how was the measurements generated properly from the DEMs?</p>
<hr />
<p>EDITED:</p>
<p>I realized that they did not use the measurements of data qubits at the final round in the model to avoid leaking labels. Given the initial state, then the map between the measurements and dets is truly a bijection.</p>
",qc,properly generate circuit measurement results detector error model p reading https nofollow noreferrer paper google neural network decoder surface code confused generate measurement results p understand correctly dataset stage drawn detector error models derived correlation analysis even subsets experimental data however sample detection events instead raw measurements given dem map detection events measurements bijection obviously stage leveraged measurements detection events measurements generated properly dems hr p edited p realized use measurements data qubits final round model avoid leaking labels given initial state map measurements dets truly,"[(3, 0.06917869), (4, 0.058442492), (5, 0.24869983), (6, 0.04228262), (8, 0.24248336), (11, 0.01817839), (14, 0.30359766), (17, 0.015708784)]"
34881,,2023-11-16 21:20:27,2,50,"<p>In the context of quantum computational chemistry, the Qiskit VQE (Variational Quantum Eigensolver) code is often used to calculate the vibrational energies of molecules, including the zero-point vibrational energy (ZPE), or ground state vibrational energy. Given that the input for the Qiskit VQE code typically includes a Gaussian file, which already has the ZPE calculated, what is the specific advantage or purpose of using the Qiskit VQE code for this task? Is there an added value or different perspective that the Qiskit approach brings to calculating vibrational energies, considering the Gaussian file provides the same information?&quot;</p>
<p>Reference: <a href=""https://qiskit.org/ecosystem/nature/tutorials/02_vibrational_structure.html"" rel=""nofollow noreferrer"">Qiskit Vibrational Structure Tutorial</a></p>
",Understanding the Role of Qiskit's VQE Code in Light of Pre-calculated Zero-Point Vibrational Energy in Gaussian Files,<qiskit><vqe><chemistry>,0,0,,,"Understanding the Role of Qiskit's VQE Code in Light of Pre-calculated Zero-Point Vibrational Energy in Gaussian Files <p>In the context of quantum computational chemistry, the Qiskit VQE (Variational Quantum Eigensolver) code is often used to calculate the vibrational energies of molecules, including the zero-point vibrational energy (ZPE), or ground state vibrational energy. Given that the input for the Qiskit VQE code typically includes a Gaussian file, which already has the ZPE calculated, what is the specific advantage or purpose of using the Qiskit VQE code for this task? Is there an added value or different perspective that the Qiskit approach brings to calculating vibrational energies, considering the Gaussian file provides the same information?&quot;</p>
<p>Reference: <a href=""https://qiskit.org/ecosystem/nature/tutorials/02_vibrational_structure.html"" rel=""nofollow noreferrer"">Qiskit Vibrational Structure Tutorial</a></p>
",qc,understanding role qiskit vqe code light vibrational energy gaussian files p context quantum computational chemistry qiskit vqe variational quantum eigensolver code often used calculate vibrational energies molecules including vibrational energy zpe ground state vibrational energy given input qiskit vqe code typically includes gaussian file already zpe calculated specific advantage purpose using qiskit vqe code task added value different perspective qiskit approach brings calculating vibrational energies considering gaussian file provides information quot p reference https nofollow noreferrer qiskit vibrational structure tutorial,"[(4, 0.03382038), (6, 0.013005018), (8, 0.31095532), (9, 0.06618501), (14, 0.28908405), (17, 0.2561236), (19, 0.029163355)]"
34916,34939.0,2023-11-19 22:59:43,1,207,"<p>I'm creating a hybrid model consisting of classical convolutional layers and a quantum output using Tensorflow. I can save the model in either .h5 or .keras format, but when I load them with the code <code>keras.models.load_model('MODEL_PATH')</code>
they give</p>
<pre><code>ValueError: Unknown layer: 'KerasLayer'. Please ensure you are using a &quot;keras.utils.custom_object_scope&quot; and that this object is included in the scope. See https://www.tensorflow.org/guide/keras/save_and_serialize#registering_the_custom_object for details.
</code></pre>
<p>The full error log is here:</p>
<pre><code> ValueError                                Traceback (most recent call last)
/Users/raheyo/Research/SpookyEngine/model.ipynb Cell 30 line 1
----&gt; 1 loadedHybrid = keras.models.load_model('./models/hybrid3232.keras')

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/saving_api.py:230, in load_model(filepath, custom_objects, compile, safe_mode, **kwargs)
    225     if kwargs:
    226         raise ValueError(
    227             &quot;The following argument(s) are not supported &quot;
    228             f&quot;with the native Keras format: {list(kwargs.keys())}&quot;
    229         )
--&gt; 230     return saving_lib.load_model(
    231         filepath,
    232         custom_objects=custom_objects,
    233         compile=compile,
    234         safe_mode=safe_mode,
    235     )
    237 # Legacy case.
    238 return legacy_sm_saving_lib.load_model(
    239     filepath, custom_objects=custom_objects, compile=compile, **kwargs
    240 )

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/saving_lib.py:275, in load_model(filepath, custom_objects, compile, safe_mode)
    272             asset_store.close()
    274 except Exception as e:
--&gt; 275     raise e
    276 else:
    277     return model

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/saving_lib.py:240, in load_model(filepath, custom_objects, compile, safe_mode)
    238 # Construct the model from the configuration file in the archive.
    239 with ObjectSharingScope():
--&gt; 240     model = deserialize_keras_object(
    241         config_dict, custom_objects, safe_mode=safe_mode
    242     )
    244 all_filenames = zf.namelist()
    245 if _VARS_FNAME + &quot;.h5&quot; in all_filenames:

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/serialization_lib.py:704, in deserialize_keras_object(config, custom_objects, safe_mode, **kwargs)
    702 safe_mode_scope = SafeModeScope(safe_mode)
    703 with custom_obj_scope, safe_mode_scope:
--&gt; 704     instance = cls.from_config(inner_config)
    705     build_config = config.get(&quot;build_config&quot;, None)
    706     if build_config:

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/engine/sequential.py:473, in Sequential.from_config(cls, config, custom_objects)
    471 for layer_config in layer_configs:
    472     use_legacy_format = &quot;module&quot; not in layer_config
--&gt; 473     layer = layer_module.deserialize(
    474         layer_config,
    475         custom_objects=custom_objects,
    476         use_legacy_format=use_legacy_format,
    477     )
    478     model.add(layer)
    480 if (
    481     not model.inputs
    482     and build_input_shape
    483     and isinstance(build_input_shape, (tuple, list))
    484 ):

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/layers/serialization.py:269, in deserialize(config, custom_objects, use_legacy_format)
    265     raise ValueError(
    266         f&quot;Cannot deserialize empty config. Received: config={config}&quot;
    267     )
    268 if use_legacy_format:
--&gt; 269     return legacy_serialization.deserialize_keras_object(
    270         config,
    271         module_objects=LOCAL.ALL_OBJECTS,
    272         custom_objects=custom_objects,
    273         printable_module_name=&quot;layer&quot;,
    274     )
    276 return serialization_lib.deserialize_keras_object(
    277     config,
    278     module_objects=LOCAL.ALL_OBJECTS,
    279     custom_objects=custom_objects,
    280     printable_module_name=&quot;layer&quot;,
    281 )

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/legacy/serialization.py:480, in deserialize_keras_object(identifier, module_objects, custom_objects, printable_module_name)
    477 if isinstance(identifier, dict):
    478     # In this case we are dealing with a Keras config dictionary.
    479     config = identifier
--&gt; 480     (cls, cls_config) = class_and_config_for_serialized_keras_object(
    481         config, module_objects, custom_objects, printable_module_name
    482     )
    484     # If this object has already been loaded (i.e. it's shared between
    485     # multiple objects), return the already-loaded object.
    486     shared_object_id = config.get(SHARED_OBJECT_KEY)

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/legacy/serialization.py:365, in class_and_config_for_serialized_keras_object(config, module_objects, custom_objects, printable_module_name)
    361 cls = object_registration.get_registered_object(
    362     class_name, custom_objects, module_objects
    363 )
    364 if cls is None:
--&gt; 365     raise ValueError(
    366         f&quot;Unknown {printable_module_name}: '{class_name}'. &quot;
    367         &quot;Please ensure you are using a `keras.utils.custom_object_scope` &quot;
    368         &quot;and that this object is included in the scope. See &quot;
    369         &quot;https://www.tensorflow.org/guide/keras/save_and_serialize&quot;
    370         &quot;#registering_the_custom_object for details.&quot;
    371     )
    373 cls_config = config[&quot;config&quot;]
    374 # Check if `cls_config` is a list. If it is a list, return the class and the
    375 # associated class configs for recursively deserialization. This case will
    376 # happen on the old version of sequential model (e.g. `keras_version` ==
    377 # &quot;2.0.6&quot;), which is serialized in a different structure, for example
    378 # &quot;{'class_name': 'Sequential',
    379 #   'config': [{'class_name': 'Embedding', 'config': ...}, {}, ...]}&quot;.
</code></pre>
<p>Is it that because tensorflow doesn't fully support quantum integration yet?</p>
",Error loading saved hybrid quantum (pennylane + tensorflow keras) model: Unknown layer: 'KerasLayer',<machine-learning><quantum-enhanced-machine-learning><pennylane>,1,0,,,"Error loading saved hybrid quantum (pennylane + tensorflow keras) model: Unknown layer: 'KerasLayer' <p>I'm creating a hybrid model consisting of classical convolutional layers and a quantum output using Tensorflow. I can save the model in either .h5 or .keras format, but when I load them with the code <code>keras.models.load_model('MODEL_PATH')</code>
they give</p>
<pre><code>ValueError: Unknown layer: 'KerasLayer'. Please ensure you are using a &quot;keras.utils.custom_object_scope&quot; and that this object is included in the scope. See https://www.tensorflow.org/guide/keras/save_and_serialize#registering_the_custom_object for details.
</code></pre>
<p>The full error log is here:</p>
<pre><code> ValueError                                Traceback (most recent call last)
/Users/raheyo/Research/SpookyEngine/model.ipynb Cell 30 line 1
----&gt; 1 loadedHybrid = keras.models.load_model('./models/hybrid3232.keras')

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/saving_api.py:230, in load_model(filepath, custom_objects, compile, safe_mode, **kwargs)
    225     if kwargs:
    226         raise ValueError(
    227             &quot;The following argument(s) are not supported &quot;
    228             f&quot;with the native Keras format: {list(kwargs.keys())}&quot;
    229         )
--&gt; 230     return saving_lib.load_model(
    231         filepath,
    232         custom_objects=custom_objects,
    233         compile=compile,
    234         safe_mode=safe_mode,
    235     )
    237 # Legacy case.
    238 return legacy_sm_saving_lib.load_model(
    239     filepath, custom_objects=custom_objects, compile=compile, **kwargs
    240 )

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/saving_lib.py:275, in load_model(filepath, custom_objects, compile, safe_mode)
    272             asset_store.close()
    274 except Exception as e:
--&gt; 275     raise e
    276 else:
    277     return model

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/saving_lib.py:240, in load_model(filepath, custom_objects, compile, safe_mode)
    238 # Construct the model from the configuration file in the archive.
    239 with ObjectSharingScope():
--&gt; 240     model = deserialize_keras_object(
    241         config_dict, custom_objects, safe_mode=safe_mode
    242     )
    244 all_filenames = zf.namelist()
    245 if _VARS_FNAME + &quot;.h5&quot; in all_filenames:

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/serialization_lib.py:704, in deserialize_keras_object(config, custom_objects, safe_mode, **kwargs)
    702 safe_mode_scope = SafeModeScope(safe_mode)
    703 with custom_obj_scope, safe_mode_scope:
--&gt; 704     instance = cls.from_config(inner_config)
    705     build_config = config.get(&quot;build_config&quot;, None)
    706     if build_config:

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/engine/sequential.py:473, in Sequential.from_config(cls, config, custom_objects)
    471 for layer_config in layer_configs:
    472     use_legacy_format = &quot;module&quot; not in layer_config
--&gt; 473     layer = layer_module.deserialize(
    474         layer_config,
    475         custom_objects=custom_objects,
    476         use_legacy_format=use_legacy_format,
    477     )
    478     model.add(layer)
    480 if (
    481     not model.inputs
    482     and build_input_shape
    483     and isinstance(build_input_shape, (tuple, list))
    484 ):

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/layers/serialization.py:269, in deserialize(config, custom_objects, use_legacy_format)
    265     raise ValueError(
    266         f&quot;Cannot deserialize empty config. Received: config={config}&quot;
    267     )
    268 if use_legacy_format:
--&gt; 269     return legacy_serialization.deserialize_keras_object(
    270         config,
    271         module_objects=LOCAL.ALL_OBJECTS,
    272         custom_objects=custom_objects,
    273         printable_module_name=&quot;layer&quot;,
    274     )
    276 return serialization_lib.deserialize_keras_object(
    277     config,
    278     module_objects=LOCAL.ALL_OBJECTS,
    279     custom_objects=custom_objects,
    280     printable_module_name=&quot;layer&quot;,
    281 )

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/legacy/serialization.py:480, in deserialize_keras_object(identifier, module_objects, custom_objects, printable_module_name)
    477 if isinstance(identifier, dict):
    478     # In this case we are dealing with a Keras config dictionary.
    479     config = identifier
--&gt; 480     (cls, cls_config) = class_and_config_for_serialized_keras_object(
    481         config, module_objects, custom_objects, printable_module_name
    482     )
    484     # If this object has already been loaded (i.e. it's shared between
    485     # multiple objects), return the already-loaded object.
    486     shared_object_id = config.get(SHARED_OBJECT_KEY)

File /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/keras/src/saving/legacy/serialization.py:365, in class_and_config_for_serialized_keras_object(config, module_objects, custom_objects, printable_module_name)
    361 cls = object_registration.get_registered_object(
    362     class_name, custom_objects, module_objects
    363 )
    364 if cls is None:
--&gt; 365     raise ValueError(
    366         f&quot;Unknown {printable_module_name}: '{class_name}'. &quot;
    367         &quot;Please ensure you are using a `keras.utils.custom_object_scope` &quot;
    368         &quot;and that this object is included in the scope. See &quot;
    369         &quot;https://www.tensorflow.org/guide/keras/save_and_serialize&quot;
    370         &quot;#registering_the_custom_object for details.&quot;
    371     )
    373 cls_config = config[&quot;config&quot;]
    374 # Check if `cls_config` is a list. If it is a list, return the class and the
    375 # associated class configs for recursively deserialization. This case will
    376 # happen on the old version of sequential model (e.g. `keras_version` ==
    377 # &quot;2.0.6&quot;), which is serialized in a different structure, for example
    378 # &quot;{'class_name': 'Sequential',
    379 #   'config': [{'class_name': 'Embedding', 'config': ...}, {}, ...]}&quot;.
</code></pre>
<p>Is it that because tensorflow doesn't fully support quantum integration yet?</p>
",qc,error loading saved hybrid quantum pennylane tensorflow keras model unknown layer p creating hybrid model consisting classical convolutional layers quantum output using tensorflow save model either format load code code give pre code valueerror unknown layer please ensure using quot quot object included scope see https details p full error log pre code valueerror traceback recent call last cell 30 line 1 gt 1 loadedhybrid file filepath compile kwargs 225 kwargs 226 raise valueerror 227 quot following argument supported quot 228 f quot native keras format list quot 229 gt 230 return 231 filepath 232 233 234 235 237 legacy case 238 return 239 filepath kwargs 240 file filepath compile 272 274 except exception e gt 275 raise e 276 else 277 return model file filepath compile 238 construct model configuration file archive 239 objectsharingscope gt 240 model 241 242 244 245 quot quot file config kwargs 702 safemodescope 703 gt 704 instance 705 quot quot none 706 file cls config 471 472 quot module quot gt 473 layer 474 475 476 477 478 layer 480 481 482 483 isinstance tuple list 484 file deserialize config 265 raise valueerror 266 f quot deserialize empty config received config quot 267 268 gt 269 return 270 config 271 272 273 quot layer quot 274 276 return 277 config 278 279 280 quot layer quot 281 file identifier 477 isinstance identifier dict 478 case dealing keras config dictionary 479 config identifier gt 480 cls 481 config 482 484 object already loaded shared 485 multiple objects return object 486 file config 361 cls 362 363 364 cls none gt 365 raise valueerror 366 f quot unknown quot 367 quot please ensure using quot 368 quot object included scope see quot 369 quot https quot 370 quot quot 371 373 config quot config quot 374 check list list return class 375 associated class configs recursively deserialization case 376 happen old version sequential model 377 quot quot serialized different structure example 378 quot 379 quot p tensorflow fully support quantum integration yet,"[(0, 0.27265918), (5, 0.1950451), (6, 0.013137166), (8, 0.06046323), (14, 0.023753723), (17, 0.012351302), (19, 0.42216492)]"
34954,,2023-11-23 01:34:20,1,27,"<p>Consider the following: you are a network device that is in charge of assigning unique identifiers (consisting of <span class=""math-container"">$b$</span> bits) to new devices as they join the network. However, you do not have very much persistent memory. In particular, you <span class=""math-container"">$k &lt; b$</span> bits of persistent memory. This means that although there are <span class=""math-container"">$2^b$</span> unique identifiers, you cannot <em>reliably</em> assign unique identifiers to <span class=""math-container"">$2^b$</span> different devices, since you would need <span class=""math-container"">$b$</span> bits of memory to keep track of which identifiers you've assigned so far.</p>
<p>However, you can make use of randomness to help reduce the risk of collisions. For instance, if <span class=""math-container"">$b=2$</span> and <span class=""math-container"">$k=0$</span>, you could assign identifiers to new devices by choosing their bits randomly. In this case, there is a probability of <span class=""math-container"">$3/32\approx 0.09375$</span> that you will successfully assign <span class=""math-container"">$4$</span> IDs without collisions. However, if <span class=""math-container"">$k=1$</span>, you can repeatedly toggle your single bit of memory to achieve a success probability of as high as <span class=""math-container"">$1/4 = 0.25$</span>.</p>
<p><strong>My question:</strong> does quantum computation offer an advantage in this problem? That is, if I am allowed <span class=""math-container"">$k &lt; b$</span> <em>qubits</em> of persistent memory rather than <span class=""math-container"">$k$</span> <em>classical</em> bits of persistent memory, can I achieve a higher probability of a collision-free assignment? This question has left me completely stumped, and I would be delighted just to see an answer to the simple <span class=""math-container"">$b=2, k=1$</span> case.</p>
",Quantum improvement in collision-free ID assignment problem?,<quantum-algorithms>,1,0,,,"Quantum improvement in collision-free ID assignment problem? <p>Consider the following: you are a network device that is in charge of assigning unique identifiers (consisting of <span class=""math-container"">$b$</span> bits) to new devices as they join the network. However, you do not have very much persistent memory. In particular, you <span class=""math-container"">$k &lt; b$</span> bits of persistent memory. This means that although there are <span class=""math-container"">$2^b$</span> unique identifiers, you cannot <em>reliably</em> assign unique identifiers to <span class=""math-container"">$2^b$</span> different devices, since you would need <span class=""math-container"">$b$</span> bits of memory to keep track of which identifiers you've assigned so far.</p>
<p>However, you can make use of randomness to help reduce the risk of collisions. For instance, if <span class=""math-container"">$b=2$</span> and <span class=""math-container"">$k=0$</span>, you could assign identifiers to new devices by choosing their bits randomly. In this case, there is a probability of <span class=""math-container"">$3/32\approx 0.09375$</span> that you will successfully assign <span class=""math-container"">$4$</span> IDs without collisions. However, if <span class=""math-container"">$k=1$</span>, you can repeatedly toggle your single bit of memory to achieve a success probability of as high as <span class=""math-container"">$1/4 = 0.25$</span>.</p>
<p><strong>My question:</strong> does quantum computation offer an advantage in this problem? That is, if I am allowed <span class=""math-container"">$k &lt; b$</span> <em>qubits</em> of persistent memory rather than <span class=""math-container"">$k$</span> <em>classical</em> bits of persistent memory, can I achieve a higher probability of a collision-free assignment? This question has left me completely stumped, and I would be delighted just to see an answer to the simple <span class=""math-container"">$b=2, k=1$</span> case.</p>
",qc,quantum improvement id assignment problem p consider following network device charge assigning unique identifiers consisting span b bits new devices join network however much persistent memory particular span k lt b bits persistent memory means although span unique identifiers em reliably assign unique identifiers span different devices since would need span b bits memory keep track identifiers assigned p however make use randomness help reduce risk collisions instance span span could assign identifiers new devices choosing bits randomly case probability span successfully assign span 4 ids without collisions however span repeatedly toggle single bit memory achieve success probability high span p strong question quantum computation offer advantage problem allowed span k lt b em qubits persistent memory rather span k em classical bits persistent memory achieve higher probability assignment question left completely stumped would delighted see answer simple span,"[(1, 0.044487692), (3, 0.51071274), (8, 0.223192), (14, 0.15133607), (17, 0.02790436), (18, 0.030122321), (19, 0.011301637)]"
35042,35045.0,2023-11-30 16:56:10,4,156,"<p>Tried this simple example where initializing two qubits in <span class=""math-container"">$|0\rangle$</span> state, performing biased bit flip erasure on qubit 1 using <code>HERALDED_PAULI_CHANNEL_1</code> while measuring qubit 0:</p>
<pre class=""lang-python prettyprint-override""><code>import stim
    import numpy as np
    circuit = stim.Circuit()
    circuit.append_operation(&quot;R&quot;, (0, 1))
    p = 0.2
    circuit.append_operation(&quot;HERALDED_PAULI_CHANNEL_1&quot;, 1, (p, p, 0, 0))
    circuit.append_operation(&quot;M&quot;,0)
    N = 1000
    result = circuit.compile_sampler().sample(shots = N)
    one_num = np.sum([int(True == j[-1]) for j in result])
    print('%s/%s' %(one_num, N))
    display(circuit.diagram(&quot;timeline-svg&quot;))
</code></pre>
<p>I get around 200/1000 measurement error on the qubit 0 as if the error is on qubit 0. What is wrong here? Thank you.</p>
",Bug in stim HERALDED_PAULI_CHANNEL_1?,<stim>,1,0,,,"Bug in stim HERALDED_PAULI_CHANNEL_1? <p>Tried this simple example where initializing two qubits in <span class=""math-container"">$|0\rangle$</span> state, performing biased bit flip erasure on qubit 1 using <code>HERALDED_PAULI_CHANNEL_1</code> while measuring qubit 0:</p>
<pre class=""lang-python prettyprint-override""><code>import stim
    import numpy as np
    circuit = stim.Circuit()
    circuit.append_operation(&quot;R&quot;, (0, 1))
    p = 0.2
    circuit.append_operation(&quot;HERALDED_PAULI_CHANNEL_1&quot;, 1, (p, p, 0, 0))
    circuit.append_operation(&quot;M&quot;,0)
    N = 1000
    result = circuit.compile_sampler().sample(shots = N)
    one_num = np.sum([int(True == j[-1]) for j in result])
    print('%s/%s' %(one_num, N))
    display(circuit.diagram(&quot;timeline-svg&quot;))
</code></pre>
<p>I get around 200/1000 measurement error on the qubit 0 as if the error is on qubit 0. What is wrong here? Thank you.</p>
",qc,bug stim p tried simple example initializing two qubits span state performing biased bit flip erasure qubit 1 using code measuring qubit 0 pre code import stim import numpy np circuit quot r quot 0 1 p quot quot 1 p p 0 0 quot quot n 1000 result shots n int true j j result print n display quot quot p get around measurement error qubit 0 error qubit wrong thank,"[(0, 0.31396416), (2, 0.118058145), (3, 0.07256346), (5, 0.08603614), (14, 0.12236876), (17, 0.015410537), (18, 0.1489117), (19, 0.121024214)]"
35092,35095.0,2023-12-04 22:58:34,0,119,"<p>I have an exercise in QEC, where I have given a hexagonal lattice with periodic boundary conditions (wrapped around a torus), with a qubit at each vertex. I have also given the Stabilizer generators <span class=""math-container"">$X \otimes Y \otimes Z \otimes X \otimes Y \otimes Z$</span> and <span class=""math-container"">$Z \otimes Z$</span> on the vertical lines of the hexagon. So how is it possible to deduce the logical operator <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> on both logical qubits. Or a in a more general way, how can I find by a given lattice and stabilizer generators the logical operations?</p>
<p>In the lecture we have just looked at some QEC like the surface Code (and a version of the surface Code where it is wrapped around the torus) and we have put some lines through the lattice and named it the logical X and Z. If I understood it right we used some stabilizers to change some of the code-qubit values such that it represents the same logical value in the logical qubits. So how can I use this Information to create the logical X and Z operation?</p>
",Quantum Error Correction on a hexagonal lattice,<error-correction><surface-code>,1,0,,,"Quantum Error Correction on a hexagonal lattice <p>I have an exercise in QEC, where I have given a hexagonal lattice with periodic boundary conditions (wrapped around a torus), with a qubit at each vertex. I have also given the Stabilizer generators <span class=""math-container"">$X \otimes Y \otimes Z \otimes X \otimes Y \otimes Z$</span> and <span class=""math-container"">$Z \otimes Z$</span> on the vertical lines of the hexagon. So how is it possible to deduce the logical operator <span class=""math-container"">$X$</span> and <span class=""math-container"">$Z$</span> on both logical qubits. Or a in a more general way, how can I find by a given lattice and stabilizer generators the logical operations?</p>
<p>In the lecture we have just looked at some QEC like the surface Code (and a version of the surface Code where it is wrapped around the torus) and we have put some lines through the lattice and named it the logical X and Z. If I understood it right we used some stabilizers to change some of the code-qubit values such that it represents the same logical value in the logical qubits. So how can I use this Information to create the logical X and Z operation?</p>
",qc,quantum error correction hexagonal lattice p exercise qec given hexagonal lattice periodic boundary conditions wrapped around torus qubit vertex also given stabilizer generators span x z x z span z z vertical lines hexagon possible deduce logical operator span x span z logical qubits general way find given lattice stabilizer generators logical operations p lecture looked qec like surface code version surface code wrapped around torus put lines lattice named logical x understood right used stabilizers change values represents logical value logical qubits use information create logical x z operation,"[(3, 0.1541958), (5, 0.41903675), (9, 0.039968163), (10, 0.0679471), (13, 0.10605539), (15, 0.042194247), (16, 0.050985392), (17, 0.025396211), (18, 0.092998244)]"
35108,,2023-12-06 12:44:12,0,32,"<p>In &quot;Data re-uploading for a universal quantum classifier&quot; paper the U(phi1,phi2,phi3) U(x1,x2,x3) is derived as U(theta + w *x) in compact state.
How to derive the above equation ?</p>
<p><a href=""https://i.sstatic.net/sap7W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/sap7W.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/0EIzD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0EIzD.png"" alt=""enter image description here"" /></a></p>
","Deriving a equation in ""Data re-uploading for a universal quantum classifier"" paper: U(phi1,phi2,phi3) U(x1,x2,x3) = U(theta + w *x)",<textbook-and-exercises><pennylane>,0,1,,,"Deriving a equation in ""Data re-uploading for a universal quantum classifier"" paper: U(phi1,phi2,phi3) U(x1,x2,x3) = U(theta + w *x) <p>In &quot;Data re-uploading for a universal quantum classifier&quot; paper the U(phi1,phi2,phi3) U(x1,x2,x3) is derived as U(theta + w *x) in compact state.
How to derive the above equation ?</p>
<p><a href=""https://i.sstatic.net/sap7W.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/sap7W.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/0EIzD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0EIzD.png"" alt=""enter image description here"" /></a></p>
",qc,deriving equation data universal quantum classifier paper u phi1 phi2 phi3 u x1 x2 x3 u theta w x p quot data universal quantum classifier quot paper u phi1 phi2 phi3 u x1 x2 x3 derived u theta w x compact state derive equation p https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description,"[(0, 0.035477594), (3, 0.20293353), (4, 0.30852652), (9, 0.04200164), (10, 0.067568004), (13, 0.24046274), (17, 0.06913669), (19, 0.03195851)]"
35138,,2023-12-08 18:17:52,0,35,"<p>Is it correct to say that an entanglement state is entangled in any basis, but this fact may not be evident (like in the state <span class=""math-container"">$ \frac{1}{ 2} | 00 \rangle + \frac{1}{ 2}| 01 \rangle + \frac{1}{ 2}| 10 \rangle -\frac{1}{ 2}| 11 \rangle$</span>), so performing a Schmidt decomposition may help to visualize the entanglement ( <span class=""math-container"">$\frac{1}{ \sqrt{2}} | 0+ \rangle + \frac{1}{ \sqrt{2}}| 1- \rangle $</span>)?</p>
<p>Is the main purpose of Schmidt decomposition to visualize entanglement or are there other uses for it?</p>
",is the main purpose of using Schmidt decompositon to visualize entanglement?,<schmidt-decomposition>,0,1,,,"is the main purpose of using Schmidt decompositon to visualize entanglement? <p>Is it correct to say that an entanglement state is entangled in any basis, but this fact may not be evident (like in the state <span class=""math-container"">$ \frac{1}{ 2} | 00 \rangle + \frac{1}{ 2}| 01 \rangle + \frac{1}{ 2}| 10 \rangle -\frac{1}{ 2}| 11 \rangle$</span>), so performing a Schmidt decomposition may help to visualize the entanglement ( <span class=""math-container"">$\frac{1}{ \sqrt{2}} | 0+ \rangle + \frac{1}{ \sqrt{2}}| 1- \rangle $</span>)?</p>
<p>Is the main purpose of Schmidt decomposition to visualize entanglement or are there other uses for it?</p>
",qc,main purpose using schmidt decompositon visualize entanglement p correct say entanglement state entangled basis fact may evident like state span 1 2 00 1 2 01 1 2 10 1 2 11 performing schmidt decomposition may help visualize entanglement span 1 2 1 2 p main purpose schmidt decomposition visualize entanglement uses,"[(2, 0.21343899), (3, 0.21404399), (6, 0.058506053), (8, 0.07381975), (13, 0.1148853), (17, 0.019412467), (18, 0.30335248)]"
35204,,2023-12-15 13:12:09,0,50,"<p>I have a <span class=""math-container"">$|+\rangle$</span> state qubit and I measure it in a random basis. The random basis is made with random <span class=""math-container"">$\theta$</span>, <span class=""math-container"">$\varphi$</span> and <span class=""math-container"">$\lambda$</span> of <span class=""math-container"">$U3$</span> gate. How can I calculate the theoretical probabilities for this basis.</p>
",Calculate of theoretical probabilities for the outcomes,<quantum-state><measurement><textbook-and-exercises><probability>,1,0,,,"Calculate of theoretical probabilities for the outcomes <p>I have a <span class=""math-container"">$|+\rangle$</span> state qubit and I measure it in a random basis. The random basis is made with random <span class=""math-container"">$\theta$</span>, <span class=""math-container"">$\varphi$</span> and <span class=""math-container"">$\lambda$</span> of <span class=""math-container"">$U3$</span> gate. How can I calculate the theoretical probabilities for this basis.</p>
",qc,calculate theoretical probabilities outcomes p span state qubit measure random basis random basis made random span span span span u3 gate calculate theoretical probabilities,"[(3, 0.52037644), (8, 0.106548406), (17, 0.062985264), (18, 0.30347708)]"
35209,,2023-12-15 21:50:41,1,123,"<p>In order to understand Grover’s algorithm, we need to be able to implement <span class=""math-container"">$U_f$</span> from a black box implementing <span class=""math-container"">$f$</span>, which we know how to do. Suppose you have this black box</p>
<p><a href=""https://i.sstatic.net/jrLFM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jrLFM.png"" alt=""enter image description here"" /></a>
as we can find in some notes, then we want to prove that the following implements <span class=""math-container"">$U_f$</span> :
<a href=""https://i.sstatic.net/s1vaj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/s1vaj.png"" alt=""enter image description here"" /></a></p>
<p>I don’t recognize what does the symbol <span class=""math-container"">$\oplus$</span> on the bottom wire mean, it seems like a CNOT gate or a serie of CNOT gates being controlled by the upper wires.</p>
<p>Is there a reference where I can check that this circuit works?</p>
<p>Another question is: why do we call <span class=""math-container"">$U_f$</span> an oracle?</p>
",Preparation of Grover’s algorithm: How to implement the oracle $U_f$?,<quantum-algorithms><grovers-algorithm>,1,0,,,"Preparation of Grover’s algorithm: How to implement the oracle $U_f$? <p>In order to understand Grover’s algorithm, we need to be able to implement <span class=""math-container"">$U_f$</span> from a black box implementing <span class=""math-container"">$f$</span>, which we know how to do. Suppose you have this black box</p>
<p><a href=""https://i.sstatic.net/jrLFM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jrLFM.png"" alt=""enter image description here"" /></a>
as we can find in some notes, then we want to prove that the following implements <span class=""math-container"">$U_f$</span> :
<a href=""https://i.sstatic.net/s1vaj.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/s1vaj.png"" alt=""enter image description here"" /></a></p>
<p>I don’t recognize what does the symbol <span class=""math-container"">$\oplus$</span> on the bottom wire mean, it seems like a CNOT gate or a serie of CNOT gates being controlled by the upper wires.</p>
<p>Is there a reference where I can check that this circuit works?</p>
<p>Another question is: why do we call <span class=""math-container"">$U_f$</span> an oracle?</p>
",qc,preparation grover algorithm implement oracle p order understand grover algorithm need able implement span black box implementing span f know suppose black box p https nofollow noreferrer img https enter image description find notes want prove following implements span https nofollow noreferrer img https enter image description p recognize symbol span bottom wire mean seems like cnot gate serie cnot gates controlled upper p reference check circuit works p another question call span oracle,"[(3, 0.14551616), (4, 0.49550363), (7, 0.13141863), (9, 0.12520593), (10, 0.088216096), (17, 0.012225767)]"
35249,35251.0,2023-12-19 11:49:16,3,706,"<p>Consider an <span class=""math-container"">$[n, k, d]$</span> classical code. This code can correct up to <span class=""math-container"">$d-1$</span> erasures. For example, if we have the code that maps <span class=""math-container"">$0\rightarrow 00$</span> and <span class=""math-container"">$1\rightarrow 11$</span>, this code has distance <span class=""math-container"">$2$</span>. Indeed, if we observe a symbol <span class=""math-container"">$0X$</span> where <span class=""math-container"">$X$</span> is an erased bit, then the decoder will output <span class=""math-container"">$0$</span>.</p>
<p>In the quantum case, this seems like a problem. A typical encoding uses CNOT gates to entangle the logical qubit with redundant qubits. Let's assume a two-qubit quantum code although adding more qubits doesn't really help. We have that</p>
<p><span class=""math-container"">$$\sqrt{\alpha}\vert 0\rangle + \sqrt{1-\alpha}\vert 1\rangle \rightarrow \sqrt{\alpha}\vert 00\rangle + \sqrt{1-\alpha}\vert 11\rangle$$</span></p>
<p>An erasure error should be thought of as partial tracing the second register. This leaves us with the state</p>
<p><span class=""math-container"">$$\alpha\vert 0\rangle\langle 0\vert + (1-\alpha)\vert 1\rangle\langle 1\vert$$</span></p>
<p>This state no longer has coherence. If <span class=""math-container"">$\alpha = \frac{1}{2}$</span>, we have gone from a <span class=""math-container"">$\vert +\rangle$</span> state to a maximally mixed state after the erasure error.</p>
<p>So how do quantum error correction protocols deal with this?</p>
<p><strong>EDIT based on comment:</strong></p>
<p>I see that the above code doesn't work, nor does any repetition code alone. The general principle is that an error on a physical qubit should be thought of as a physical channel <span class=""math-container"">$\mathcal{E}$</span> with Kraus operators <span class=""math-container"">$\{E_i\}$</span>. In the case of qubits, one then writes the Kraus operators in the Pauli basis (see Nielsen and Chuang (10.14))</p>
<p><span class=""math-container"">$$E_i=e_{i 0} I+e_{i 1} X+e_{i 2} Z+e_{i 3} XZ$$</span></p>
<p>For the partial trace, the Kraus operators are <span class=""math-container"">$E_i=\langle i|$</span> where the bra is on the register we are tracing out. It's not clear to me how the Pauli decomposition works since the dimension of the Kraus operator is <span class=""math-container"">$2\times 1$</span> while the linear combination of Pauli matrices gives us a <span class=""math-container"">$2\times 2$</span> matrix.</p>
<p>My question is still - how are erasures dealt with in QEC?</p>
",Erasure errors in quantum error correction,<error-correction><information-theory><decoherence><error-mitigation>,1,2,,,"Erasure errors in quantum error correction <p>Consider an <span class=""math-container"">$[n, k, d]$</span> classical code. This code can correct up to <span class=""math-container"">$d-1$</span> erasures. For example, if we have the code that maps <span class=""math-container"">$0\rightarrow 00$</span> and <span class=""math-container"">$1\rightarrow 11$</span>, this code has distance <span class=""math-container"">$2$</span>. Indeed, if we observe a symbol <span class=""math-container"">$0X$</span> where <span class=""math-container"">$X$</span> is an erased bit, then the decoder will output <span class=""math-container"">$0$</span>.</p>
<p>In the quantum case, this seems like a problem. A typical encoding uses CNOT gates to entangle the logical qubit with redundant qubits. Let's assume a two-qubit quantum code although adding more qubits doesn't really help. We have that</p>
<p><span class=""math-container"">$$\sqrt{\alpha}\vert 0\rangle + \sqrt{1-\alpha}\vert 1\rangle \rightarrow \sqrt{\alpha}\vert 00\rangle + \sqrt{1-\alpha}\vert 11\rangle$$</span></p>
<p>An erasure error should be thought of as partial tracing the second register. This leaves us with the state</p>
<p><span class=""math-container"">$$\alpha\vert 0\rangle\langle 0\vert + (1-\alpha)\vert 1\rangle\langle 1\vert$$</span></p>
<p>This state no longer has coherence. If <span class=""math-container"">$\alpha = \frac{1}{2}$</span>, we have gone from a <span class=""math-container"">$\vert +\rangle$</span> state to a maximally mixed state after the erasure error.</p>
<p>So how do quantum error correction protocols deal with this?</p>
<p><strong>EDIT based on comment:</strong></p>
<p>I see that the above code doesn't work, nor does any repetition code alone. The general principle is that an error on a physical qubit should be thought of as a physical channel <span class=""math-container"">$\mathcal{E}$</span> with Kraus operators <span class=""math-container"">$\{E_i\}$</span>. In the case of qubits, one then writes the Kraus operators in the Pauli basis (see Nielsen and Chuang (10.14))</p>
<p><span class=""math-container"">$$E_i=e_{i 0} I+e_{i 1} X+e_{i 2} Z+e_{i 3} XZ$$</span></p>
<p>For the partial trace, the Kraus operators are <span class=""math-container"">$E_i=\langle i|$</span> where the bra is on the register we are tracing out. It's not clear to me how the Pauli decomposition works since the dimension of the Kraus operator is <span class=""math-container"">$2\times 1$</span> while the linear combination of Pauli matrices gives us a <span class=""math-container"">$2\times 2$</span> matrix.</p>
<p>My question is still - how are erasures dealt with in QEC?</p>
",qc,erasure errors quantum error correction p consider span n k classical code code correct span erasures example code maps span 00 span 11 code distance span 2 indeed observe symbol span 0x span x erased bit decoder output span 0 p quantum case seems like problem typical encoding uses cnot gates entangle logical qubit redundant qubits let assume quantum code although adding qubits really help p span p erasure error thought partial tracing second register leaves us state p span p state longer coherence span 1 2 gone span state maximally mixed state erasure p quantum error correction protocols deal p strong edit based comment p see code work repetition code alone general principle error physical qubit thought physical channel span e kraus operators span case qubits one writes kraus operators pauli basis see nielsen chuang p span 0 1 2 3 xz p partial trace kraus operators span bra register tracing clear pauli decomposition works since dimension kraus operator span 1 linear combination pauli matrices gives us span 2 p question still erasures dealt qec,"[(2, 0.040974535), (3, 0.5240568), (5, 0.23666725), (17, 0.05643473), (18, 0.13359554)]"
35272,35277.0,2023-12-21 18:14:17,2,79,"<p>I have a quantum circuit with 4 input qubits, A, B, C, and D. A is at the top, D is at the bottom.</p>
<p>If I wanted to do a CNOT between B and C and leave A and D alone, I know the gate matrix for this would be computed as <span class=""math-container"">$$I \otimes CNOT \otimes I$$</span> where <span class=""math-container"">$I$</span> is the 2x2 identity matrix, <span class=""math-container"">$CNOT$</span> is the controlled not gate matrix, and <span class=""math-container"">$\otimes$</span> is tensor product.</p>
<p>But how do I compute the gate matrix if I want to CNOT A and D and leave B and C alone?</p>
<p>I've looked at <a href=""https://quantumcomputing.stackexchange.com/questions/34996/can-you-apply-a-cnot-gate-on-qubits-in-mbqc-that-aren%C2%B4t-next-to-each-other"">this question</a> and it seems close, but the MBQC terminology seems to be confusing everyone (including me).</p>
",How to compute the gate matrix for an operation on qubits not next to each other,<quantum-gate><quantum-circuit><matrix-representation>,1,0,,,"How to compute the gate matrix for an operation on qubits not next to each other <p>I have a quantum circuit with 4 input qubits, A, B, C, and D. A is at the top, D is at the bottom.</p>
<p>If I wanted to do a CNOT between B and C and leave A and D alone, I know the gate matrix for this would be computed as <span class=""math-container"">$$I \otimes CNOT \otimes I$$</span> where <span class=""math-container"">$I$</span> is the 2x2 identity matrix, <span class=""math-container"">$CNOT$</span> is the controlled not gate matrix, and <span class=""math-container"">$\otimes$</span> is tensor product.</p>
<p>But how do I compute the gate matrix if I want to CNOT A and D and leave B and C alone?</p>
<p>I've looked at <a href=""https://quantumcomputing.stackexchange.com/questions/34996/can-you-apply-a-cnot-gate-on-qubits-in-mbqc-that-aren%C2%B4t-next-to-each-other"">this question</a> and it seems close, but the MBQC terminology seems to be confusing everyone (including me).</p>
",qc,compute gate matrix operation qubits next p quantum circuit 4 input qubits b c top p wanted cnot b c leave alone know gate matrix would computed span cnot span 2x2 identity matrix span cnot controlled gate matrix span tensor p compute gate matrix want cnot leave b c alone p looked https c2 question seems close mbqc terminology seems confusing everyone including,"[(3, 0.3112547), (4, 0.090605006), (7, 0.022677168), (9, 0.18125004), (11, 0.09677839), (12, 0.016177824), (13, 0.062626585), (17, 0.04089548), (18, 0.17599341)]"
35287,35300.0,2023-12-22 15:49:29,1,132,"<p>I was looking into the stim library (very new to it) and was wondering if someone who has been using it or has experience with DEMs could explain a little of the following.</p>
<ul>
<li>What exactly are detector error models within the <code>stim</code> library?</li>
<li>What are the scope of use for DEMs?</li>
</ul>
",On DEMs in stim,<error-correction><stim>,1,1,,,"On DEMs in stim <p>I was looking into the stim library (very new to it) and was wondering if someone who has been using it or has experience with DEMs could explain a little of the following.</p>
<ul>
<li>What exactly are detector error models within the <code>stim</code> library?</li>
<li>What are the scope of use for DEMs?</li>
</ul>
",qc,dems stim p looking stim library new wondering someone using experience dems could explain little ul li exactly detector error models within code stim library li scope use dems,"[(5, 0.30327255), (7, 0.109872855), (8, 0.4698237), (17, 0.11154866)]"
35302,,2023-12-24 02:36:59,0,28,"<p>The <a href=""https://www.tensorflow.org/datasets/catalog/radon"" rel=""nofollow noreferrer"">Radon dataset</a> is a well-known hierarchical/multilevel dataset. It contains Radon samples from houses in counties across the United States. The goal of the model is to estimate the (log) Radon level in each county based on reading from either the basement or first floor of houses in the county.</p>
<p>The <a href=""https://www.cambridge.org/highereducation/books/data-analysis-using-regression-and-multilevel-hierarchical-models/32A29531C7FD730C3A68951A17C9D983"" rel=""nofollow noreferrer"">book</a>, which presented this dataset, suggests using either maximum likelihood or Bayesian inference methods to combine data from the various counties, building individual (but dependent) models for each county.</p>
<p>Is there a quantum algorithm that can be applied to this problem?<br />
The features are:</p>
<ul>
<li>floor of Radon measurement: 0 - basement; 1 - first floor</li>
<li>county id: a categorical/nominal feature</li>
</ul>
<p>The label is the logarithm of the Radon level.</p>
<p>Ignoring the county ID and training a single model is trivial, as is training a separate model for each county. I am looking for a mixture model that combines data from all counties to build estimates for each county.</p>
",quantum algorithm for multilevel/hierarchical dataset,<quantum-algorithms><machine-learning><quantum-enhanced-machine-learning>,0,0,,,"quantum algorithm for multilevel/hierarchical dataset <p>The <a href=""https://www.tensorflow.org/datasets/catalog/radon"" rel=""nofollow noreferrer"">Radon dataset</a> is a well-known hierarchical/multilevel dataset. It contains Radon samples from houses in counties across the United States. The goal of the model is to estimate the (log) Radon level in each county based on reading from either the basement or first floor of houses in the county.</p>
<p>The <a href=""https://www.cambridge.org/highereducation/books/data-analysis-using-regression-and-multilevel-hierarchical-models/32A29531C7FD730C3A68951A17C9D983"" rel=""nofollow noreferrer"">book</a>, which presented this dataset, suggests using either maximum likelihood or Bayesian inference methods to combine data from the various counties, building individual (but dependent) models for each county.</p>
<p>Is there a quantum algorithm that can be applied to this problem?<br />
The features are:</p>
<ul>
<li>floor of Radon measurement: 0 - basement; 1 - first floor</li>
<li>county id: a categorical/nominal feature</li>
</ul>
<p>The label is the logarithm of the Radon level.</p>
<p>Ignoring the county ID and training a single model is trivial, as is training a separate model for each county. I am looking for a mixture model that combines data from all counties to build estimates for each county.</p>
",qc,quantum algorithm dataset p https nofollow noreferrer radon dataset dataset contains radon samples houses counties across united states goal model estimate log radon level county based reading either basement first floor houses p https nofollow noreferrer book presented dataset suggests using either maximum likelihood bayesian inference methods combine data various counties building individual dependent models p quantum algorithm applied problem br features ul li floor radon measurement 0 basement 1 first floor li county id feature p label logarithm radon p ignoring county id training single model trivial training separate model county looking mixture model combines data counties build estimates,"[(2, 0.020411177), (4, 0.05874968), (5, 0.43273368), (7, 0.094679534), (8, 0.2970252), (13, 0.015634907), (14, 0.058392208), (17, 0.021161363)]"
35306,,2023-12-25 18:15:50,3,90,"<p>I recently saw a piece of code that computes molecular bond energy with respect to bond length. I am trying to update the code to the newer qiskit framework (I'm running qiskit 0.45.1 and <code>qiskit-nature</code> instead of the depricated <code>qiskit.chemistry</code>). The complete original code is available as a <a href=""https://www.youtube.com/watch?v=Z-A6G0WVI9w&amp;t=1291s"" rel=""nofollow noreferrer"">video</a>, but I have extracted the relevant parts below.</p>
<p>In order to generate a qubit operator associated with the Hamiltonian in the process of finding the eigen energy, the older version of qiskit uses the class <code>qiskit.chemistry.core.Hamiltonian</code>, which does not exist anymore in <code>qiskit_nature</code>.</p>
<p>I'm wondering if there is an alternative way to generate the <code>qubitOp</code> such that I can use <code>NumPyMinimumEigensolver().run()</code> to find the exact bond energy? In other words, how can I make the following piece of code run correctly using <code>qiskit-nature</code>?</p>
<pre><code>driver = PySCFDriver(atom=moleculeRepr.format(dist/2), basis=&quot;sto3g&quot;)
molecule = driver.run()
operator = Hamiltonian(qubit_mapping=QubitMappingtype.PARITY, two_qubit_reduction=True, freeze_core=True,orbital_reduction=[-3, -2])
qubitOp, aux_ops = operator.run(molecule)

#classical result
exactResult = NumPyMinimumEigensolver(qubitOp, aux_operators=aux_ops).run()
exactResult = operator.process_algorithm_result(exactResult)
</code></pre>
<p>Any help or insights into this question would be greatly appreciated.</p>
",Updating qiskit.chemistry.core.Hamiltonian to qiskit-nature Framework,<qiskit><chemistry>,0,1,,,"Updating qiskit.chemistry.core.Hamiltonian to qiskit-nature Framework <p>I recently saw a piece of code that computes molecular bond energy with respect to bond length. I am trying to update the code to the newer qiskit framework (I'm running qiskit 0.45.1 and <code>qiskit-nature</code> instead of the depricated <code>qiskit.chemistry</code>). The complete original code is available as a <a href=""https://www.youtube.com/watch?v=Z-A6G0WVI9w&amp;t=1291s"" rel=""nofollow noreferrer"">video</a>, but I have extracted the relevant parts below.</p>
<p>In order to generate a qubit operator associated with the Hamiltonian in the process of finding the eigen energy, the older version of qiskit uses the class <code>qiskit.chemistry.core.Hamiltonian</code>, which does not exist anymore in <code>qiskit_nature</code>.</p>
<p>I'm wondering if there is an alternative way to generate the <code>qubitOp</code> such that I can use <code>NumPyMinimumEigensolver().run()</code> to find the exact bond energy? In other words, how can I make the following piece of code run correctly using <code>qiskit-nature</code>?</p>
<pre><code>driver = PySCFDriver(atom=moleculeRepr.format(dist/2), basis=&quot;sto3g&quot;)
molecule = driver.run()
operator = Hamiltonian(qubit_mapping=QubitMappingtype.PARITY, two_qubit_reduction=True, freeze_core=True,orbital_reduction=[-3, -2])
qubitOp, aux_ops = operator.run(molecule)

#classical result
exactResult = NumPyMinimumEigensolver(qubitOp, aux_operators=aux_ops).run()
exactResult = operator.process_algorithm_result(exactResult)
</code></pre>
<p>Any help or insights into this question would be greatly appreciated.</p>
",qc,updating framework p recently saw piece code computes molecular bond energy respect bond length trying update code newer qiskit framework running qiskit code instead depricated code complete original code available https amp nofollow noreferrer video extracted relevant parts p order generate qubit operator associated hamiltonian process finding eigen energy older version qiskit uses class code exist anymore code p wondering alternative way generate code qubitop use code numpyminimumeigensolver find exact bond energy words make following piece code run correctly using code pre code driver pyscfdriver quot sto3g quot molecule operator hamiltonian qubitop molecule classical result exactresult numpyminimumeigensolver qubitop exactresult exactresult p help insights question would greatly,"[(0, 0.1359077), (1, 0.04710412), (4, 0.031442836), (8, 0.15776142), (12, 0.06951162), (13, 0.06248302), (14, 0.3654815), (15, 0.010275818), (17, 0.09309772), (19, 0.025982445)]"
35319,35320.0,2023-12-27 08:15:46,1,207,"<p>I am studying how to decompose a <span class=""math-container"">$4 \times 4$</span> unitary matrix into multiple 2-level unitary matrices.</p>
<p>I have found a total of six 2-level unitary matrices, and they are as follows.</p>
<p><a href=""https://i.sstatic.net/qjgbF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qjgbF.png"" alt=""enter image description here"" /></a></p>
<p>At this point, I realized that (1,2) corresponds to <span class=""math-container"">$0V$</span>, (3,4) corresponds to <span class=""math-container"">$1V$</span>, (1,3) is <span class=""math-container"">$V0$</span>, and (2,4) is <span class=""math-container"">$V1$</span>, similar to a controlled-<span class=""math-container"">$V$</span> gate.
<a href=""https://i.sstatic.net/INLAF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/INLAF.png"" alt=""enter image description here"" /></a></p>
<p>When considering the decomposition using six 2-level unitary matrices, it is known that while the controlled V gate can be further decomposed using single-qubit gates and <span class=""math-container"">$\text{CNOT}$</span> gates, the (1,4) and (2,3) combinations are more challenging to decompose because they simultaneously affect two qubits.</p>
<p>My question is, when you have an arbitrary <span class=""math-container"">$4 \times 4$</span> unitary matrix and decompose it using these six 2-level unitary matrices, there seems to be no issue with not using (1,4) and (2,3).</p>
<p>Does that mean you don't need to use them at all? I'm curious about the reason behind this.</p>
",Decomposing a $4 \times 4$ unitary matrix into 2-level unitary matrices,<quantum-gate><unitarity><universal-gates>,1,0,,,"Decomposing a $4 \times 4$ unitary matrix into 2-level unitary matrices <p>I am studying how to decompose a <span class=""math-container"">$4 \times 4$</span> unitary matrix into multiple 2-level unitary matrices.</p>
<p>I have found a total of six 2-level unitary matrices, and they are as follows.</p>
<p><a href=""https://i.sstatic.net/qjgbF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/qjgbF.png"" alt=""enter image description here"" /></a></p>
<p>At this point, I realized that (1,2) corresponds to <span class=""math-container"">$0V$</span>, (3,4) corresponds to <span class=""math-container"">$1V$</span>, (1,3) is <span class=""math-container"">$V0$</span>, and (2,4) is <span class=""math-container"">$V1$</span>, similar to a controlled-<span class=""math-container"">$V$</span> gate.
<a href=""https://i.sstatic.net/INLAF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/INLAF.png"" alt=""enter image description here"" /></a></p>
<p>When considering the decomposition using six 2-level unitary matrices, it is known that while the controlled V gate can be further decomposed using single-qubit gates and <span class=""math-container"">$\text{CNOT}$</span> gates, the (1,4) and (2,3) combinations are more challenging to decompose because they simultaneously affect two qubits.</p>
<p>My question is, when you have an arbitrary <span class=""math-container"">$4 \times 4$</span> unitary matrix and decompose it using these six 2-level unitary matrices, there seems to be no issue with not using (1,4) and (2,3).</p>
<p>Does that mean you don't need to use them at all? I'm curious about the reason behind this.</p>
",qc,decomposing 4 4 unitary matrix unitary matrices p studying decompose span 4 4 unitary matrix multiple unitary p found total six unitary matrices p https nofollow noreferrer img https enter image description p point realized corresponds span 0v corresponds span 1v span v0 span v1 similar span v gate https nofollow noreferrer img https enter image description p considering decomposition using six unitary matrices known controlled v gate decomposed using gates span cnot gates combinations challenging decompose simultaneously affect two p question arbitrary span 4 4 unitary matrix decompose using six unitary matrices seems issue using p mean need use curious reason behind,"[(3, 0.33731434), (4, 0.33902568), (6, 0.043009974), (7, 0.033584803), (9, 0.19094284), (11, 0.044495393), (17, 0.010328438)]"
35330,,2023-12-28 01:11:59,2,249,"<p>New to quantum computing.</p>
<p>How do quantum computers represent a string at the hardware level?</p>
<p>For example, if Classical computers wanted to encode &quot;Hello world!&quot;, they would use UTF-8 to represent &quot;H&quot; as 01001000, &quot;e&quot; as 01100101, and so on.</p>
<p>Can qubits store information like this? Is there a UTF-8 equivalent for quantum computers?</p>
",How do quantum computers encode a string?,<quantum-state>,1,0,,,"How do quantum computers encode a string? <p>New to quantum computing.</p>
<p>How do quantum computers represent a string at the hardware level?</p>
<p>For example, if Classical computers wanted to encode &quot;Hello world!&quot;, they would use UTF-8 to represent &quot;H&quot; as 01001000, &quot;e&quot; as 01100101, and so on.</p>
<p>Can qubits store information like this? Is there a UTF-8 equivalent for quantum computers?</p>
",qc,quantum computers encode string p new quantum p quantum computers represent string hardware level p example classical computers wanted encode quot hello world quot would use represent quot h quot 01001000 quot e quot 01100101 p qubits store information like equivalent quantum computers,"[(1, 0.23897545), (8, 0.24724042), (13, 0.29952914), (17, 0.04306854), (19, 0.16754483)]"
35337,,2023-12-29 10:23:05,0,28,"<p>I was reading some papers about the UnionFind Decoder but I don't get how matching can be used to decode on a 3D surface code. If I understood correctly every layer in our 3D surface code corresponds to a different syndrome measurement at different time steps. My question is, if I apply the UnionFind decoder and I find a matching between levels how do I interpret this? Is there even a correction to apply between layers?</p>
",3D surface code and unionfind,<error-correction><surface-code>,0,0,,,"3D surface code and unionfind <p>I was reading some papers about the UnionFind Decoder but I don't get how matching can be used to decode on a 3D surface code. If I understood correctly every layer in our 3D surface code corresponds to a different syndrome measurement at different time steps. My question is, if I apply the UnionFind decoder and I find a matching between levels how do I interpret this? Is there even a correction to apply between layers?</p>
",qc,3d surface code unionfind p reading papers unionfind decoder get matching used decode 3d surface code understood correctly every layer 3d surface code corresponds different syndrome measurement different time steps question apply unionfind decoder find matching levels interpret even correction apply layers,"[(5, 0.39957735), (10, 0.07397859), (13, 0.3265846), (14, 0.14473736), (17, 0.051563304)]"
35342,,2023-12-29 21:23:43,5,109,"<p>I am currently trying to find a mathematically elegant way to describe the construction of a 3D toric code. Since most literature is on 2D toric codes I was looking there for potential clues on how to annotate this properly, but mostly I only found a textual description of taking the hyper graph product. I was wondering if there is a general notation for such construction.</p>
",Construction of 3D Toric Code,<resource-request><toric-code>,1,0,,,"Construction of 3D Toric Code <p>I am currently trying to find a mathematically elegant way to describe the construction of a 3D toric code. Since most literature is on 2D toric codes I was looking there for potential clues on how to annotate this properly, but mostly I only found a textual description of taking the hyper graph product. I was wondering if there is a general notation for such construction.</p>
",qc,construction 3d toric code p currently trying find mathematically elegant way describe construction 3d toric code since literature 2d toric codes looking potential clues annotate properly mostly found textual description taking hyper graph product wondering general notation,"[(4, 0.08823106), (5, 0.13818023), (8, 0.47619158), (13, 0.21072729), (17, 0.08263313)]"
35373,,2024-01-04 06:48:04,2,129,"<p>I want to optimize a variational quantum circuit to maximize the Hilbert-Schmidt Distance between the different classes of the UCI breast cancer data set. When I choose to use batched optimization, the circuit does not really get optimized. That means the values cost function does not really decrease and always stay randomly on an interval of approximately [0.8, 0.9].</p>
<p>I don't think that the problem is a barren plateau, because the gradients are not too small and when I instead use a small sample of the data and try to run all optimization steps on the same data, instead of randomly sampled batches, the evaluations of the cost function are decreasing in a reasonable manner.</p>
<p>Does anybody here see, what is the problem of the batched optimization?</p>
<p>All my code available here: <a href=""https://github.com/Rlag1998/Embedding_Generalization/blob/main/tutorial_embedding_generalization.ipynb"" rel=""nofollow noreferrer"">https://github.com/Rlag1998/Embedding_Generalization/blob/main/tutorial_embedding_generalization.ipynb</a></p>
<p>I made some changes to adjust the code to the most recent version of Pennylane. I also deleted the classical linear layer before the circuit, as i was thinking that most of the training took place in there instead inside the quantum circuit.</p>
<p>This is my code:</p>
<pre class=""lang-python prettyprint-override""><code>import pennylane as qml
from pennylane import numpy as np
from pennylane import RX, RY, RZ, CNOT

np.random.seed(seed=1234)

n_features = 2
n_qubits = 2 * n_features + 1

dev = qml.device(&quot;default.qubit&quot;, wires=n_qubits)


def feature_encoding_hamiltonian(features, wires):

    for idx, w in enumerate(wires):
        RX(features[idx], wires=w)


def ising_hamiltonian(weights, wires, l):

    # ZZ coupling
    CNOT(wires=[wires[1], wires[0]])
    RZ(weights[l, 0], wires=wires[0])
    CNOT(wires=[wires[1], wires[0]])
    # local fields
    for idx, w in enumerate(wires):
        RY(weights[l, idx + 1], wires=w)


def QAOAEmbedding(features, weights, wires):

    repeat = len(weights)
    for l in range(repeat):
        # apply alternating Hamiltonians
        feature_encoding_hamiltonian(features, wires)
        ising_hamiltonian(weights, wires, l)
    # repeat the feature encoding once more at the end
    feature_encoding_hamiltonian(features, wires)

@qml.qnode(dev, argnum=0)
def swap_test(q_weights, x1, x2):

    # load the two inputs into two different registers
    QAOAEmbedding(features=x1, weights=q_weights, wires=[1, 2])
    QAOAEmbedding(features=x2, weights=q_weights, wires=[3, 4])

    # perform the SWAP test
    qml.Hadamard(wires=0)
    for k in range(n_features):
        qml.CSWAP(wires=[0, k + 1, 2 + k + 1])
    qml.Hadamard(wires=0)

    return qml.expval(qml.PauliZ(0))


def overlaps(weights, X1=None, X2=None):
    overlap = 0
    for x1 in X1:
        for x2 in X2:
            # overlap of embedded intermediate features
            overlap += swap_test(q_weights=weights, x1=x1, x2=x2)

    mean_overlap = overlap / (len(X1) * len(X2))

    return mean_overlap

def cost(weights, A=None, B=None):
    aa = overlaps(weights, X1=A, X2=A)
    bb = overlaps(weights, X1=B, X2=B)
    ab = overlaps(weights, X1=A, X2=B)

    d_hs = -2 * ab + (aa + bb)
    #print(&quot;print cost in cost func: &quot;, 1-0.5 * d_hs)
    return 1 - 0.5 * d_hs

from sklearn.datasets import load_breast_cancer
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
# Load and preprocess the dataset
data = load_breast_cancer()
X = data.data
y = data.target

# Standardize the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Reduce dimensions with PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Split the dataset into two classes
A = X_pca[y == 0]
B = X_pca[y == 1]

# size=(x, y) x defines the number of layers of the circuit and y the no of 
# trainable parameters in each layer
init_pars = np.random.normal(loc=0, scale=0.1, size=(1, 3), requires_grad=True)

optimizer = qml.AdamOptimizer(stepsize=0.05)
batch_size = 10
pars = init_pars

for i in range(100):
    # Sample a batch of training inputs from each class
    selectA = np.random.choice(range(len(A)), size=(batch_size,), replace=True)
    selectB = np.random.choice(range(len(B)), size=(batch_size,), replace=True)
    A_batch = [A[s] for s in selectA]
    B_batch = [B[s] for s in selectB]

    #grad = qml.grad(cost)(pars, A_batch, B_batch)
    flat_pars = pars.flatten()
    new_flat_pars, cost_val = optimizer.step_and_cost(lambda w: cost(w.reshape(init_pars.shape), A=A_batch, B=B_batch), flat_pars)
    #print(f&quot;cost = {cost_val}, gradient norm = {np.linalg.norm(grad):.4f}&quot;)
    print(f&quot;Step {i+1} cost = {cost_val}&quot;)
    # reshape
    pars = new_flat_pars.reshape(init_pars.shape)
<span class=""math-container"">```</span>
</code></pre>
",Optimizing a parametrized Quantum Circuit in batches does not decrease the cost function while unbatched optimization does,<machine-learning><quantum-enhanced-machine-learning><pennylane>,1,0,,,"Optimizing a parametrized Quantum Circuit in batches does not decrease the cost function while unbatched optimization does <p>I want to optimize a variational quantum circuit to maximize the Hilbert-Schmidt Distance between the different classes of the UCI breast cancer data set. When I choose to use batched optimization, the circuit does not really get optimized. That means the values cost function does not really decrease and always stay randomly on an interval of approximately [0.8, 0.9].</p>
<p>I don't think that the problem is a barren plateau, because the gradients are not too small and when I instead use a small sample of the data and try to run all optimization steps on the same data, instead of randomly sampled batches, the evaluations of the cost function are decreasing in a reasonable manner.</p>
<p>Does anybody here see, what is the problem of the batched optimization?</p>
<p>All my code available here: <a href=""https://github.com/Rlag1998/Embedding_Generalization/blob/main/tutorial_embedding_generalization.ipynb"" rel=""nofollow noreferrer"">https://github.com/Rlag1998/Embedding_Generalization/blob/main/tutorial_embedding_generalization.ipynb</a></p>
<p>I made some changes to adjust the code to the most recent version of Pennylane. I also deleted the classical linear layer before the circuit, as i was thinking that most of the training took place in there instead inside the quantum circuit.</p>
<p>This is my code:</p>
<pre class=""lang-python prettyprint-override""><code>import pennylane as qml
from pennylane import numpy as np
from pennylane import RX, RY, RZ, CNOT

np.random.seed(seed=1234)

n_features = 2
n_qubits = 2 * n_features + 1

dev = qml.device(&quot;default.qubit&quot;, wires=n_qubits)


def feature_encoding_hamiltonian(features, wires):

    for idx, w in enumerate(wires):
        RX(features[idx], wires=w)


def ising_hamiltonian(weights, wires, l):

    # ZZ coupling
    CNOT(wires=[wires[1], wires[0]])
    RZ(weights[l, 0], wires=wires[0])
    CNOT(wires=[wires[1], wires[0]])
    # local fields
    for idx, w in enumerate(wires):
        RY(weights[l, idx + 1], wires=w)


def QAOAEmbedding(features, weights, wires):

    repeat = len(weights)
    for l in range(repeat):
        # apply alternating Hamiltonians
        feature_encoding_hamiltonian(features, wires)
        ising_hamiltonian(weights, wires, l)
    # repeat the feature encoding once more at the end
    feature_encoding_hamiltonian(features, wires)

@qml.qnode(dev, argnum=0)
def swap_test(q_weights, x1, x2):

    # load the two inputs into two different registers
    QAOAEmbedding(features=x1, weights=q_weights, wires=[1, 2])
    QAOAEmbedding(features=x2, weights=q_weights, wires=[3, 4])

    # perform the SWAP test
    qml.Hadamard(wires=0)
    for k in range(n_features):
        qml.CSWAP(wires=[0, k + 1, 2 + k + 1])
    qml.Hadamard(wires=0)

    return qml.expval(qml.PauliZ(0))


def overlaps(weights, X1=None, X2=None):
    overlap = 0
    for x1 in X1:
        for x2 in X2:
            # overlap of embedded intermediate features
            overlap += swap_test(q_weights=weights, x1=x1, x2=x2)

    mean_overlap = overlap / (len(X1) * len(X2))

    return mean_overlap

def cost(weights, A=None, B=None):
    aa = overlaps(weights, X1=A, X2=A)
    bb = overlaps(weights, X1=B, X2=B)
    ab = overlaps(weights, X1=A, X2=B)

    d_hs = -2 * ab + (aa + bb)
    #print(&quot;print cost in cost func: &quot;, 1-0.5 * d_hs)
    return 1 - 0.5 * d_hs

from sklearn.datasets import load_breast_cancer
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
# Load and preprocess the dataset
data = load_breast_cancer()
X = data.data
y = data.target

# Standardize the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Reduce dimensions with PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Split the dataset into two classes
A = X_pca[y == 0]
B = X_pca[y == 1]

# size=(x, y) x defines the number of layers of the circuit and y the no of 
# trainable parameters in each layer
init_pars = np.random.normal(loc=0, scale=0.1, size=(1, 3), requires_grad=True)

optimizer = qml.AdamOptimizer(stepsize=0.05)
batch_size = 10
pars = init_pars

for i in range(100):
    # Sample a batch of training inputs from each class
    selectA = np.random.choice(range(len(A)), size=(batch_size,), replace=True)
    selectB = np.random.choice(range(len(B)), size=(batch_size,), replace=True)
    A_batch = [A[s] for s in selectA]
    B_batch = [B[s] for s in selectB]

    #grad = qml.grad(cost)(pars, A_batch, B_batch)
    flat_pars = pars.flatten()
    new_flat_pars, cost_val = optimizer.step_and_cost(lambda w: cost(w.reshape(init_pars.shape), A=A_batch, B=B_batch), flat_pars)
    #print(f&quot;cost = {cost_val}, gradient norm = {np.linalg.norm(grad):.4f}&quot;)
    print(f&quot;Step {i+1} cost = {cost_val}&quot;)
    # reshape
    pars = new_flat_pars.reshape(init_pars.shape)
<span class=""math-container"">```</span>
</code></pre>
",qc,optimizing parametrized quantum circuit batches decrease cost function unbatched optimization p want optimize variational quantum circuit maximize distance different classes uci breast cancer data set choose use batched optimization circuit really get optimized means values cost function really decrease always stay randomly interval approximately p think problem barren plateau gradients small instead use small sample data try run optimization steps data instead randomly sampled batches evaluations cost function decreasing reasonable p anybody see problem batched optimization p code available https nofollow noreferrer https p made changes adjust code recent version pennylane also deleted classical linear layer circuit thinking training took place instead inside quantum p code pre code import pennylane qml pennylane import numpy np pennylane import rx ry rz cnot 2 2 1 dev quot quot def features wires idx w enumerate wires rx features idx def weights wires l zz coupling cnot wires 1 wires 0 rz weights l 0 0 cnot wires 1 wires 0 local fields idx w enumerate wires ry weights l idx 1 def qaoaembedding features weights wires repeat len weights l range repeat apply alternating hamiltonians features wires weights wires l repeat feature encoding end features wires dev def x1 x2 load two inputs two different registers qaoaembedding 1 2 qaoaembedding 3 4 perform swap test k range 0 k 1 2 k 1 return 0 def overlaps weights overlap 0 x1 x1 x2 x2 overlap embedded intermediate features overlap overlap len x1 len x2 return def cost weights aa overlaps weights bb overlaps weights ab overlaps weights ab aa bb print quot print cost cost func quot return 1 import import standardscaler import pca load preprocess dataset data x standardize features scaler standardscaler x reduce dimensions pca pca pca split dataset two classes 0 b 1 x x defines number layers circuit trainable parameters layer 1 3 optimizer 10 pars range 100 sample batch training inputs class selecta range len selectb range len b selecta b selectb grad cost pars lambda w cost print f quot cost gradient norm grad quot print f quot step cost quot reshape pars span,"[(0, 0.38812777), (2, 0.09102906), (3, 0.03430313), (5, 0.010906544), (8, 0.12569943), (9, 0.035782512), (10, 0.02328032), (14, 0.1764232), (15, 0.011330461), (17, 0.036642604), (19, 0.057178278)]"
35385,,2024-01-05 14:21:50,1,73,"<p>I would like to use the analysis capabilities of qiskit, i.e. <code>StateTomographyAnalysis</code> of qiskit_experiments on data that were previously measured on a system not using Qiskit.</p>
<p>So what I have is a quantum state with an unknown state preparation (I know the goal, but not what actually happened) and can therefore not model a circuit to prepare the state.</p>
<p>After receiving that state, I measured, using different rotations, to get a measurement in all Pauli bases.</p>
<p>So the circuits would look like this:</p>
<pre><code>cZ = QuantumCircuit(1)
# unknown part here
cZ.save_statevector()
cZ.measure_all()

cX = QuantumCircuit(1)
# unknown part here
cX.save_statevector()
cX.ry(-np.pi/2,0)
cX.measure_all()

cY = QuantumCircuit(1)
# unknown part here
cY.save_statevector()
cY.rx(np.pi/2,0)
cY.measure_all()
</code></pre>
<p>The 'unknown part' is the same in all circuits, the <code>save_statevector()</code> is where I would like to reconstruct the density matrix.</p>
<p>Now these circuits were actually measured on a real quantum computer that does not use qiskit and all i am left with is the final data, like this:</p>
<p>Shots: 1k</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th style=""text-align: left;"">Basis</th>
<th style=""text-align: left;"">0</th>
<th style=""text-align: left;"">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""text-align: left;""><span class=""math-container"">$\sigma_Z$</span></td>
<td style=""text-align: left;"">0.49</td>
<td style=""text-align: left;"">0.51</td>
</tr>
<tr>
<td style=""text-align: left;""><span class=""math-container"">$\sigma_X$</span></td>
<td style=""text-align: left;"">0.98</td>
<td style=""text-align: left;"">0.02</td>
</tr>
<tr>
<td style=""text-align: left;""><span class=""math-container"">$\sigma_Y$</span></td>
<td style=""text-align: left;"">0.51</td>
<td style=""text-align: left;"">0.49</td>
</tr>
</tbody>
</table>
</div>
<p>On these sample data I can immediately see that this must be close to <span class=""math-container"">$|+\rangle$</span>, the real world example is a bit more complicated (and involves 2 qubits).</p>
<p>I would like to use the <code>StateTomographyAnalysis</code> to fit a density matrix to the given results and further process the data, and tried this approach:</p>
<pre><code>from qiskit_experiments.library.tomography import StateTomographyAnalysis
from qiskit_experiments.framework.experiment_data import ExperimentData

outcomes = {
    'X': {'0':0.98, '1':0.02},
    'Y': {'0':0.51, '1':0.49},
    'Z': {'0':0.49, '1':0.51},
}

exData = ExperimentData().add_data(outcomes)

tomo = StateTomographyAnalysis().run(exData)
</code></pre>
<p>This gives an error about 'NoneType' object has no attribute '_created_in_db', but also found the documentation hard to understand.</p>
<p>How could I do this? I guess adding the data to an <code>ExperimentData</code> object is not as simple as I tried it....</p>
<p>I'm using qiskit-experiments-0.5.1.</p>
",Use qiskit-experiments StateTomographyAnalysis on data previously recorded without qiskit,<qiskit><state-tomography>,1,0,,,"Use qiskit-experiments StateTomographyAnalysis on data previously recorded without qiskit <p>I would like to use the analysis capabilities of qiskit, i.e. <code>StateTomographyAnalysis</code> of qiskit_experiments on data that were previously measured on a system not using Qiskit.</p>
<p>So what I have is a quantum state with an unknown state preparation (I know the goal, but not what actually happened) and can therefore not model a circuit to prepare the state.</p>
<p>After receiving that state, I measured, using different rotations, to get a measurement in all Pauli bases.</p>
<p>So the circuits would look like this:</p>
<pre><code>cZ = QuantumCircuit(1)
# unknown part here
cZ.save_statevector()
cZ.measure_all()

cX = QuantumCircuit(1)
# unknown part here
cX.save_statevector()
cX.ry(-np.pi/2,0)
cX.measure_all()

cY = QuantumCircuit(1)
# unknown part here
cY.save_statevector()
cY.rx(np.pi/2,0)
cY.measure_all()
</code></pre>
<p>The 'unknown part' is the same in all circuits, the <code>save_statevector()</code> is where I would like to reconstruct the density matrix.</p>
<p>Now these circuits were actually measured on a real quantum computer that does not use qiskit and all i am left with is the final data, like this:</p>
<p>Shots: 1k</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th style=""text-align: left;"">Basis</th>
<th style=""text-align: left;"">0</th>
<th style=""text-align: left;"">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style=""text-align: left;""><span class=""math-container"">$\sigma_Z$</span></td>
<td style=""text-align: left;"">0.49</td>
<td style=""text-align: left;"">0.51</td>
</tr>
<tr>
<td style=""text-align: left;""><span class=""math-container"">$\sigma_X$</span></td>
<td style=""text-align: left;"">0.98</td>
<td style=""text-align: left;"">0.02</td>
</tr>
<tr>
<td style=""text-align: left;""><span class=""math-container"">$\sigma_Y$</span></td>
<td style=""text-align: left;"">0.51</td>
<td style=""text-align: left;"">0.49</td>
</tr>
</tbody>
</table>
</div>
<p>On these sample data I can immediately see that this must be close to <span class=""math-container"">$|+\rangle$</span>, the real world example is a bit more complicated (and involves 2 qubits).</p>
<p>I would like to use the <code>StateTomographyAnalysis</code> to fit a density matrix to the given results and further process the data, and tried this approach:</p>
<pre><code>from qiskit_experiments.library.tomography import StateTomographyAnalysis
from qiskit_experiments.framework.experiment_data import ExperimentData

outcomes = {
    'X': {'0':0.98, '1':0.02},
    'Y': {'0':0.51, '1':0.49},
    'Z': {'0':0.49, '1':0.51},
}

exData = ExperimentData().add_data(outcomes)

tomo = StateTomographyAnalysis().run(exData)
</code></pre>
<p>This gives an error about 'NoneType' object has no attribute '_created_in_db', but also found the documentation hard to understand.</p>
<p>How could I do this? I guess adding the data to an <code>ExperimentData</code> object is not as simple as I tried it....</p>
<p>I'm using qiskit-experiments-0.5.1.</p>
",qc,use statetomographyanalysis data previously recorded without qiskit p would like use analysis capabilities qiskit code statetomographyanalysis data previously measured system using p quantum state unknown state preparation know goal actually happened therefore model circuit prepare p receiving state measured using different rotations get measurement pauli p circuits would look like pre code cz quantumcircuit 1 unknown part cx quantumcircuit 1 unknown part cy quantumcircuit 1 unknown part p part circuits code would like reconstruct density p circuits actually measured real quantum computer use qiskit left final data like p shots 1k div table thead tr th left basis th left 0 th left 1 tbody tr td left span td left td left tr td left span td left td left tr td left span td left td left p sample data immediately see must close span real world example bit complicated involves 2 qubits p would like use code statetomographyanalysis fit density matrix given results process data tried approach pre code import statetomographyanalysis import experimentdata outcomes x z exdata experimentdata outcomes tomo statetomographyanalysis exdata p gives error object attribute also found documentation hard p could guess adding data code experimentdata object simple tried p using,"[(0, 0.047231916), (2, 0.027107803), (3, 0.054125097), (11, 0.020885538), (13, 0.31733575), (14, 0.33631185), (17, 0.15975396), (18, 0.031458493)]"
35443,,2024-01-11 07:26:36,0,302,"<p>Pymatching doesn't seems to be working for Steane's code on STIM. I am wondering is there any other decoder that I could possibly use? I am trying to simulate circuit-level noise in syndrome extraction circuit for Steane's Code. I am having issues integrating BPOSD into STIM.</p>
",Integrating BPOSD into STIM,<error-correction><stabilizer-code><stim>,2,1,,,"Integrating BPOSD into STIM <p>Pymatching doesn't seems to be working for Steane's code on STIM. I am wondering is there any other decoder that I could possibly use? I am trying to simulate circuit-level noise in syndrome extraction circuit for Steane's Code. I am having issues integrating BPOSD into STIM.</p>
",qc,integrating bposd stim p pymatching seems working steane code stim wondering decoder could possibly use trying simulate noise syndrome extraction circuit steane code issues integrating bposd,"[(5, 0.4020182), (14, 0.3673853), (17, 0.043126132), (19, 0.18135703)]"
35478,35481.0,2024-01-14 07:58:19,0,51,"<p>How the shots belonging to the same job are scheduled to run on IBM quantum devices? Suppose my job has 1000 shots. Will all shots be executed in series, or is it possible they will be interleaved with shots corresponding to jobs submitted by other users?</p>
",How the shots belonging to the same job are scheduled to run on IBM quantum devices?,<ibm-q-experience>,1,0,,,"How the shots belonging to the same job are scheduled to run on IBM quantum devices? <p>How the shots belonging to the same job are scheduled to run on IBM quantum devices? Suppose my job has 1000 shots. Will all shots be executed in series, or is it possible they will be interleaved with shots corresponding to jobs submitted by other users?</p>
",qc,shots belonging job scheduled run ibm quantum devices p shots belonging job scheduled run ibm quantum devices suppose job 1000 shots shots executed series possible interleaved shots corresponding jobs submitted users,"[(9, 0.069089256), (11, 0.03262401), (14, 0.7924354), (16, 0.068565816), (17, 0.032469507)]"
35479,,2024-01-14 11:08:16,1,21,"<p>Speically, how to calculate the volume of the set <span class=""math-container"">$\{(|\langle\psi|M_1|\psi\rangle|^2,...,|\langle\psi|M_s|\psi\rangle|^2)|\rho \in \mathbb{H}^n\}$</span> in the space <span class=""math-container"">$\mathbb{R}^{s}$</span>, in which <span class=""math-container"">$\mathbb{H}^n$</span> is the set of all <span class=""math-container"">$n$</span>-qubit pure states, and <span class=""math-container"">$\{M_i\}$</span> is a set of <span class=""math-container"">$s$</span> Hermitian matrices?</p>
<p>I think it might be the integration
<span class=""math-container"">\begin{align}
  &amp;\int_{\text{the set}} d|\langle\psi|M_1|\psi\rangle|^2...d|\langle\psi|M_s|\psi\rangle|^2,\\
  =&amp;\int_{\mathbb{H}^n} F(\psi,M_1,...,M_s) d\psi,
\end{align}</span>
but I really don't know what's the function <span class=""math-container"">$F$</span> here.</p>
",How to calculate the volume of a point set with parameters go over the Haar distribution?,<haar-distribution>,0,0,,,"How to calculate the volume of a point set with parameters go over the Haar distribution? <p>Speically, how to calculate the volume of the set <span class=""math-container"">$\{(|\langle\psi|M_1|\psi\rangle|^2,...,|\langle\psi|M_s|\psi\rangle|^2)|\rho \in \mathbb{H}^n\}$</span> in the space <span class=""math-container"">$\mathbb{R}^{s}$</span>, in which <span class=""math-container"">$\mathbb{H}^n$</span> is the set of all <span class=""math-container"">$n$</span>-qubit pure states, and <span class=""math-container"">$\{M_i\}$</span> is a set of <span class=""math-container"">$s$</span> Hermitian matrices?</p>
<p>I think it might be the integration
<span class=""math-container"">\begin{align}
  &amp;\int_{\text{the set}} d|\langle\psi|M_1|\psi\rangle|^2...d|\langle\psi|M_s|\psi\rangle|^2,\\
  =&amp;\int_{\mathbb{H}^n} F(\psi,M_1,...,M_s) d\psi,
\end{align}</span>
but I really don't know what's the function <span class=""math-container"">$F$</span> here.</p>
",qc,calculate volume point set parameters go haar distribution p speically calculate volume set span h space span r span h set span n pure states span set span hermitian matrices p think might integration span align amp set amp h f align really know function span f,"[(3, 0.7403564), (10, 0.07078515), (15, 0.09792447), (17, 0.08747001)]"
35505,,2024-01-17 10:56:27,1,70,"<p>I am doing simulations of the toric code using the statistical mapping worked out by <a href=""https://doi.org/10.1063/1.1499754"" rel=""nofollow noreferrer"">Preskill et al., <em>Topological Quantum Memory</em></a>, [<a href=""https://arxiv.org/pdf/quant-ph/0110143.pdf"" rel=""nofollow noreferrer"">arXiv:quant-ph/0110143</a>], where we find the phase boundary of an Ising model and use the Nishimori condition to find a crossover that corresponds to the critical error rate <span class=""math-container"">$p_\text{th}$</span> below which quantum error correction works.</p>
<p>However, I find that introducing measurement errors to the system makes <span class=""math-container"">$p_\text{th}$</span> higher, because a 3D Ising model takes higher temperatures for long-range disorder to occur. This makes no sense as measurement errors should impose a more stringent requirement on the fidelity of the qubits. Plotting the phase boundary and the Nishimori condition indeed gives me a higher <span class=""math-container"">$p_\text{th}$</span>. Where am I wrong in my thinking?</p>
",3D toric code (2D + measurement errors) has higher threshold error rate $p_{\text{th}}$ than 2D?,<error-correction><toric-code><ising-model>,1,0,,,"3D toric code (2D + measurement errors) has higher threshold error rate $p_{\text{th}}$ than 2D? <p>I am doing simulations of the toric code using the statistical mapping worked out by <a href=""https://doi.org/10.1063/1.1499754"" rel=""nofollow noreferrer"">Preskill et al., <em>Topological Quantum Memory</em></a>, [<a href=""https://arxiv.org/pdf/quant-ph/0110143.pdf"" rel=""nofollow noreferrer"">arXiv:quant-ph/0110143</a>], where we find the phase boundary of an Ising model and use the Nishimori condition to find a crossover that corresponds to the critical error rate <span class=""math-container"">$p_\text{th}$</span> below which quantum error correction works.</p>
<p>However, I find that introducing measurement errors to the system makes <span class=""math-container"">$p_\text{th}$</span> higher, because a 3D Ising model takes higher temperatures for long-range disorder to occur. This makes no sense as measurement errors should impose a more stringent requirement on the fidelity of the qubits. Plotting the phase boundary and the Nishimori condition indeed gives me a higher <span class=""math-container"">$p_\text{th}$</span>. Where am I wrong in my thinking?</p>
",qc,3d toric code 2d measurement errors higher threshold error rate th 2d p simulations toric code using statistical mapping worked https nofollow noreferrer preskill et em topological quantum memory https nofollow noreferrer arxiv find phase boundary ising model use nishimori condition find crossover corresponds critical error rate span th quantum error correction p however find introducing measurement errors system makes span th higher 3d ising model takes higher temperatures disorder occur makes sense measurement errors impose stringent requirement fidelity qubits plotting phase boundary nishimori condition indeed gives higher span th wrong thinking,"[(1, 0.06463315), (3, 0.30894706), (4, 0.06413873), (5, 0.25972703), (13, 0.18081225), (17, 0.12019926)]"
35559,,2024-01-23 03:48:04,1,74,"<p>Consider a Haar random state on <span class=""math-container"">$n$</span> qubits, and denote it by <span class=""math-container"">$|\psi\rangle$</span>. Now consider the following state</p>
<p><span class=""math-container"">$$|\phi\rangle = \frac{1}{\sqrt{k}} \sum_{i=1}^{k} |\phi_{1, i} \rangle \otimes |\phi_{2, i} \rangle,$$</span></p>
<p>where each <span class=""math-container"">$|\phi_{i,k}\rangle$</span>, for each choice of <span class=""math-container"">$k$</span> is a Haar random state over <span class=""math-container"">$n/2$</span> qubits.</p>
<p>What is the expected trace distance between these two ensembles (denoted by <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi\rangle$</span>)?</p>
<p>It clearly is very large when <span class=""math-container"">$k$</span> is <span class=""math-container"">$1$</span>, but my hope is that it decreases with increasing <span class=""math-container"">$k$</span>. How large of a <span class=""math-container"">$k$</span> suffices?</p>
",Expected trace distance between two types of random ensembles,<quantum-state><random-quantum-circuit><haar-distribution><state-discrimination>,1,2,,,"Expected trace distance between two types of random ensembles <p>Consider a Haar random state on <span class=""math-container"">$n$</span> qubits, and denote it by <span class=""math-container"">$|\psi\rangle$</span>. Now consider the following state</p>
<p><span class=""math-container"">$$|\phi\rangle = \frac{1}{\sqrt{k}} \sum_{i=1}^{k} |\phi_{1, i} \rangle \otimes |\phi_{2, i} \rangle,$$</span></p>
<p>where each <span class=""math-container"">$|\phi_{i,k}\rangle$</span>, for each choice of <span class=""math-container"">$k$</span> is a Haar random state over <span class=""math-container"">$n/2$</span> qubits.</p>
<p>What is the expected trace distance between these two ensembles (denoted by <span class=""math-container"">$|\psi\rangle$</span> and <span class=""math-container"">$|\phi\rangle$</span>)?</p>
<p>It clearly is very large when <span class=""math-container"">$k$</span> is <span class=""math-container"">$1$</span>, but my hope is that it decreases with increasing <span class=""math-container"">$k$</span>. How large of a <span class=""math-container"">$k$</span> suffices?</p>
",qc,expected trace distance two types random ensembles p consider haar random state span n qubits denote span consider following state p span 1 k k 1 2 p span k choice span k haar random state span p expected trace distance two ensembles denoted span span p clearly large span k span 1 hope decreases increasing span k large span k suffices,"[(3, 0.932977), (17, 0.064126894)]"
35568,,2024-01-23 20:04:19,0,27,"<p>I am trying to use qml to do physics informed quantum machine learning within Tensorflow. I know with TF, to get derivatives of the network's inputs (df/dx, for example), you can use with tf.GradientTape() as tape and define a function representing a partial differential equation as:</p>
<pre><code>@tf.function
  def physic_loss(t, x):
    u0 = u(t, x)
    u_t = tf.gradients(u0, t)[0]
    u_x = tf.gradients(u0, x)[0]
    u_xx = tf.gradients(u_x, x)[0]
    F = u_t + u0*u_x - (0.01/np.pi)*u_xx
    return tf.reduce_mean(tf.square(F))
</code></pre>
<p>It doesn’t seem like the qnode components are contributing to this loss. My guess is that I need to use quantum grad tape somehow to get derivatives w.r.t x and t. Any guidance would be great!!!</p>
",Qnode model gradient of inputs (not parameters!) question,<programming><entanglement><machine-learning><pennylane><variational-quantum-algorithms>,0,0,,,"Qnode model gradient of inputs (not parameters!) question <p>I am trying to use qml to do physics informed quantum machine learning within Tensorflow. I know with TF, to get derivatives of the network's inputs (df/dx, for example), you can use with tf.GradientTape() as tape and define a function representing a partial differential equation as:</p>
<pre><code>@tf.function
  def physic_loss(t, x):
    u0 = u(t, x)
    u_t = tf.gradients(u0, t)[0]
    u_x = tf.gradients(u0, x)[0]
    u_xx = tf.gradients(u_x, x)[0]
    F = u_t + u0*u_x - (0.01/np.pi)*u_xx
    return tf.reduce_mean(tf.square(F))
</code></pre>
<p>It doesn’t seem like the qnode components are contributing to this loss. My guess is that I need to use quantum grad tape somehow to get derivatives w.r.t x and t. Any guidance would be great!!!</p>
",qc,qnode model gradient inputs parameters question p trying use qml physics informed quantum machine learning within tensorflow know tf get derivatives network inputs example use tape define function representing partial differential equation pre code def x u0 u x u0 0 u0 x 0 x 0 f u0 return f p seem like qnode components contributing loss guess need use quantum grad tape somehow get derivatives x guidance would great,"[(0, 0.29761872), (1, 0.05193355), (2, 0.038917635), (3, 0.06797491), (7, 0.028558774), (8, 0.31348008), (10, 0.14153579), (17, 0.058268998)]"
35572,35582.0,2024-01-24 08:52:06,1,227,"<p>PyMatching finds the minimum weight matching, which will belong to a particular equivalence class. But sometimes it is useful to know the minimum matching of each equivalence class.</p>
<p>In the olden days, when we build our own matching decoders with lots of virtual nodes, <a href=""https://arxiv.org/abs/1302.2669"" rel=""nofollow noreferrer"">this could be done by suitably tweaking the graph</a>. I'm not sure how those methods can be ported over to PyMatching though.</p>
<p>Is there an easy trick I'm missing?</p>
",How to force PyMatching into the opposite equivalence class,<error-correction><pymatching>,2,0,,,"How to force PyMatching into the opposite equivalence class <p>PyMatching finds the minimum weight matching, which will belong to a particular equivalence class. But sometimes it is useful to know the minimum matching of each equivalence class.</p>
<p>In the olden days, when we build our own matching decoders with lots of virtual nodes, <a href=""https://arxiv.org/abs/1302.2669"" rel=""nofollow noreferrer"">this could be done by suitably tweaking the graph</a>. I'm not sure how those methods can be ported over to PyMatching though.</p>
<p>Is there an easy trick I'm missing?</p>
",qc,force pymatching opposite equivalence class p pymatching finds minimum weight matching belong particular equivalence class sometimes useful know minimum matching equivalence p olden days build matching decoders lots virtual nodes https nofollow noreferrer could done suitably tweaking graph sure methods ported pymatching p easy trick missing,"[(4, 0.085398816), (5, 0.057846427), (7, 0.29653388), (8, 0.10250317), (9, 0.23012596), (13, 0.08745977), (17, 0.1371884)]"
35595,,2024-01-25 14:51:01,6,149,"<p>I am wondering if it is possible to generalize the Hadamard test for computing <span class=""math-container"">$\text{Re} \langle \phi | U | \psi \rangle$</span> (different states for left and right operands).</p>
",Generalized version of the Hadamard test for $\text{Re} \langle \phi | U | \psi \rangle$,<hadamard-test>,1,0,,,"Generalized version of the Hadamard test for $\text{Re} \langle \phi | U | \psi \rangle$ <p>I am wondering if it is possible to generalize the Hadamard test for computing <span class=""math-container"">$\text{Re} \langle \phi | U | \psi \rangle$</span> (different states for left and right operands).</p>
",qc,generalized version hadamard test u p wondering possible generalize hadamard test computing span u different states left right operands,"[(3, 0.40693238), (13, 0.52096254), (17, 0.0632457)]"
35645,,2024-01-29 23:07:34,1,47,"<p>I am confused about how the VQE is able to print out a decimal number for the ground state energy of a molecule.</p>
<p>For example, for <span class=""math-container"">$\text{LiH}$</span>, the ground state energy I get for an interatomic distance of <span class=""math-container"">$1.5$</span> was <span class=""math-container"">$-7.88210$</span>. What I know is that after a quantum algorithm, it measures the qubit state, and therefore, it would read the state <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> from a qubit.</p>
<p>So I would like to know how does by measuring a qubit state of <span class=""math-container"">$|1\rangle$</span> or <span class=""math-container"">$|0\rangle$</span> turns into a decimal number to represent a ground state energy?</p>
",Getting a numeric result from the variational quantum eigensolver,<measurement><vqe>,1,0,,,"Getting a numeric result from the variational quantum eigensolver <p>I am confused about how the VQE is able to print out a decimal number for the ground state energy of a molecule.</p>
<p>For example, for <span class=""math-container"">$\text{LiH}$</span>, the ground state energy I get for an interatomic distance of <span class=""math-container"">$1.5$</span> was <span class=""math-container"">$-7.88210$</span>. What I know is that after a quantum algorithm, it measures the qubit state, and therefore, it would read the state <span class=""math-container"">$|0\rangle$</span> or <span class=""math-container"">$|1\rangle$</span> from a qubit.</p>
<p>So I would like to know how does by measuring a qubit state of <span class=""math-container"">$|1\rangle$</span> or <span class=""math-container"">$|0\rangle$</span> turns into a decimal number to represent a ground state energy?</p>
",qc,getting numeric result variational quantum eigensolver p confused vqe able print decimal number ground state energy p example span lih ground state energy get interatomic distance span span know quantum algorithm measures qubit state therefore would read state span span p would like know measuring qubit state span span turns decimal number represent ground state energy,"[(0, 0.013687637), (1, 0.11338157), (3, 0.19103774), (7, 0.09061249), (13, 0.10220248), (17, 0.1793106), (18, 0.30745316)]"
35669,,2024-01-31 06:18:51,1,49,"<p>Pennylane's dataset has a lot of systems, including Quantum Chemistry molecules. Can I extract the spectral gap of the molecule from the dataset (assuming it contains the number). In the case that this value is not readily available, is there a pennylane tutorial to find this?</p>
<p>I do not imagine it would be feasible to run simulation on my computer or even google colab to calculate the spectral gap of such large molecules. Is there any other repository/database from where we can get the spectral gap of popular molecules mentioned in pennylane?</p>
",Pennylane Spectral gap for Molecules,<pennylane><chemistry>,0,0,,,"Pennylane Spectral gap for Molecules <p>Pennylane's dataset has a lot of systems, including Quantum Chemistry molecules. Can I extract the spectral gap of the molecule from the dataset (assuming it contains the number). In the case that this value is not readily available, is there a pennylane tutorial to find this?</p>
<p>I do not imagine it would be feasible to run simulation on my computer or even google colab to calculate the spectral gap of such large molecules. Is there any other repository/database from where we can get the spectral gap of popular molecules mentioned in pennylane?</p>
",qc,pennylane spectral gap molecules p pennylane dataset lot systems including quantum chemistry molecules extract spectral gap molecule dataset assuming contains number case value readily available pennylane tutorial find p imagine would feasible run simulation computer even google colab calculate spectral gap large molecules get spectral gap popular molecules mentioned pennylane,"[(0, 0.118541755), (1, 0.104585126), (6, 0.09029376), (7, 0.34987047), (8, 0.30498263), (17, 0.028879229)]"
35673,35680.0,2024-01-31 09:37:26,1,114,"<p>I built a complex time-space dependent error model with Qiskit, and I am simulating surface codes with such error model to test their error correction capabilities. Qiskit supplies measurement data as a dictionary of counts for each bitstring that has been observed at least once.</p>
<p>By reading the documentation, I noted that PyMatching can be easily interfaced with Stim to test a plethora of pre-buit surface codes, however I am reluctant to switch to that simulator, since stabiliser-based simulation does not fit my needs.</p>
<p>How can I extract the error syndromes from Qiskit measurement data and create a syndrome graph compatible with matching algorithms such as PyMatching?</p>
",How can I use surface code measurement data produced with Qiskit to run matching algorithms (e.g. PyMatching)?,<qiskit><stim><surface-code><pymatching>,1,0,,,"How can I use surface code measurement data produced with Qiskit to run matching algorithms (e.g. PyMatching)? <p>I built a complex time-space dependent error model with Qiskit, and I am simulating surface codes with such error model to test their error correction capabilities. Qiskit supplies measurement data as a dictionary of counts for each bitstring that has been observed at least once.</p>
<p>By reading the documentation, I noted that PyMatching can be easily interfaced with Stim to test a plethora of pre-buit surface codes, however I am reluctant to switch to that simulator, since stabiliser-based simulation does not fit my needs.</p>
<p>How can I extract the error syndromes from Qiskit measurement data and create a syndrome graph compatible with matching algorithms such as PyMatching?</p>
",qc,use surface code measurement data produced qiskit run matching algorithms pymatching p built complex dependent error model qiskit simulating surface codes error model test error correction capabilities qiskit supplies measurement data dictionary counts bitstring observed least p reading documentation noted pymatching easily interfaced stim test plethora surface codes however reluctant switch simulator since simulation fit p extract error syndromes qiskit measurement data create syndrome graph compatible matching algorithms pymatching,"[(5, 0.2851349), (6, 0.029965105), (8, 0.06539644), (13, 0.1618088), (14, 0.37935692), (17, 0.07627973)]"
35700,35703.0,2024-02-02 13:35:00,4,152,"<p>If I'm not mistaken, the <span class=""math-container"">$\{H,T,CNOT\}$</span> set of gates is universal in the sense that any unitary can be approximated arbiratrily close by a combination of these gates.</p>
<p>The <code>transpile</code> function of Qiskit allows to decompose a quantum circuit into a universal set of gates. But it seems that it fails to do so for basic circuits:</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit.circuit import QuantumCircuit
from qiskit import transpile

qc = QuantumCircuit(2)
qc.h(0)
qc.s(0)
qc.cx(0, 1)

basis_gates = [&quot;h&quot;, &quot;t&quot;, &quot;cx&quot;, &quot;id&quot;]

qc_transpiled = transpile(qc, basis_gates=basis_gates)
</code></pre>
<p>This code results in a <code>TranspilerError: &quot;Unable to translate the operations in the circuit: ['h', 's', 'cx'] to the backend's (or manually specified) target basis: ['reset', 'cx', 'delay', 'barrier', 't', 'snapshot', 'h', 'measure', 'id']. This likely means the target basis is not universal or there are additional equivalence rules needed in the EquivalenceLibrary being used.</code>.</p>
<p>This is neither the same problem as in <a href=""https://quantumcomputing.stackexchange.com/q/29873/10454"">this question</a>, since I've added the <code>&quot;id&quot;</code> gate to my set, nor as <a href=""https://quantumcomputing.stackexchange.com/q/28789/10454"">this one</a> since this gate set is supposed to approximate any unitary.</p>
<p>Is there something I can do to help Qiskit transpile this circuit? Of course, the one I've linked as an example is easy enough, but I'd like it to transpile more complex gates, like arbitrary <span class=""math-container"">$RX$</span> gates for instance.</p>
<p>If it helps, the version of Qiskit I'm using is:</p>
<pre><code>{'qiskit': '0.45.1', 'qiskit-aer': '0.13.0', 'qiskit-ignis': None, 'qiskit-ibmq-provider': None, 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}
</code></pre>
","How to transpile a quantum circuit using the $\{H,T,CNOT\}$ universal set of gates?",<qiskit><universal-gates><transpile>,1,0,,,"How to transpile a quantum circuit using the $\{H,T,CNOT\}$ universal set of gates? <p>If I'm not mistaken, the <span class=""math-container"">$\{H,T,CNOT\}$</span> set of gates is universal in the sense that any unitary can be approximated arbiratrily close by a combination of these gates.</p>
<p>The <code>transpile</code> function of Qiskit allows to decompose a quantum circuit into a universal set of gates. But it seems that it fails to do so for basic circuits:</p>
<pre class=""lang-python prettyprint-override""><code>from qiskit.circuit import QuantumCircuit
from qiskit import transpile

qc = QuantumCircuit(2)
qc.h(0)
qc.s(0)
qc.cx(0, 1)

basis_gates = [&quot;h&quot;, &quot;t&quot;, &quot;cx&quot;, &quot;id&quot;]

qc_transpiled = transpile(qc, basis_gates=basis_gates)
</code></pre>
<p>This code results in a <code>TranspilerError: &quot;Unable to translate the operations in the circuit: ['h', 's', 'cx'] to the backend's (or manually specified) target basis: ['reset', 'cx', 'delay', 'barrier', 't', 'snapshot', 'h', 'measure', 'id']. This likely means the target basis is not universal or there are additional equivalence rules needed in the EquivalenceLibrary being used.</code>.</p>
<p>This is neither the same problem as in <a href=""https://quantumcomputing.stackexchange.com/q/29873/10454"">this question</a>, since I've added the <code>&quot;id&quot;</code> gate to my set, nor as <a href=""https://quantumcomputing.stackexchange.com/q/28789/10454"">this one</a> since this gate set is supposed to approximate any unitary.</p>
<p>Is there something I can do to help Qiskit transpile this circuit? Of course, the one I've linked as an example is easy enough, but I'd like it to transpile more complex gates, like arbitrary <span class=""math-container"">$RX$</span> gates for instance.</p>
<p>If it helps, the version of Qiskit I'm using is:</p>
<pre><code>{'qiskit': '0.45.1', 'qiskit-aer': '0.13.0', 'qiskit-ignis': None, 'qiskit-ibmq-provider': None, 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}
</code></pre>
",qc,transpile quantum circuit using h universal set gates p mistaken span h set gates universal sense unitary approximated arbiratrily close combination p code transpile function qiskit allows decompose quantum circuit universal set gates seems fails basic circuits pre code import quantumcircuit qiskit import transpile qc quantumcircuit 2 0 0 0 1 quot h quot quot quot quot cx quot quot id quot transpile qc p code results code transpilererror quot unable translate operations circuit h backend manually specified target basis h likely means target basis universal additional equivalence rules needed equivalencelibrary p neither problem https question since added code quot id quot gate set https one since gate set supposed approximate p something help qiskit transpile circuit course one linked example easy enough like transpile complex gates like arbitrary span rx gates p helps version qiskit using pre code none none none none none none,"[(0, 0.30572847), (2, 0.032806598), (3, 0.07060818), (9, 0.2666944), (14, 0.21943948), (17, 0.015119197), (19, 0.08870178)]"
35737,,2024-02-06 16:34:50,0,36,"<p>Following the qiskit tutorial on <a href=""https://qiskit-community.github.io/qiskit-algorithms/tutorials/11_VarQTE.html"" rel=""nofollow noreferrer"">Variational Time Evolution</a>, I've changed the ansatz for VarQRTE from</p>
<pre><code>ansatz = EfficientSU2(hamiltonian.num_qubits, reps=1)
</code></pre>
<p>to</p>
<pre><code>from qiskit.circuit.library import EfficientSU2, TwoLocal    
ansatz = TwoLocal(hamiltonian.num_qubits, 'ry', 'cz', reps=1)
</code></pre>
<p>Plotting the magnetization, I get</p>
<p><a href=""https://i.sstatic.net/lJoxX.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lJoxX.png"" alt=""Plot of magnetization against time for SU2(blue) and TwoLocal (Orange) ansatze"" /></a>.</p>
<p>Looking at how the variational parameters change during evolution by</p>
<pre><code>for i in range(0, len(evolution_result_TwoLocal.parameter_values)):
    print(&quot;parameters&quot;, i, evolution_result_TwoLocal.parameter_values[i])
</code></pre>
<p>I note that the parameters are not changing.</p>
<pre><code>parameters 0 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 1 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 2 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 3 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 4 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 5 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 6 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 7 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 8 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 9 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 10 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 11 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 12 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 13 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 14 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 15 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 16 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 17 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 18 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 19 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 20 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 21 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 22 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 23 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 24 [1.57079633 1.57079633 1.57079633 1.57079633]
...
parameters 998 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 999 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 1000 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 1001 [1.57079633 1.57079633 1.57079633 1.57079633]
</code></pre>
<p>Is there an easy resolution?</p>
",Why are the variational parameters not changing in VarQRTE runs for TwoLocal ansatz?,<qiskit><variational-quantum-algorithms>,0,0,,,"Why are the variational parameters not changing in VarQRTE runs for TwoLocal ansatz? <p>Following the qiskit tutorial on <a href=""https://qiskit-community.github.io/qiskit-algorithms/tutorials/11_VarQTE.html"" rel=""nofollow noreferrer"">Variational Time Evolution</a>, I've changed the ansatz for VarQRTE from</p>
<pre><code>ansatz = EfficientSU2(hamiltonian.num_qubits, reps=1)
</code></pre>
<p>to</p>
<pre><code>from qiskit.circuit.library import EfficientSU2, TwoLocal    
ansatz = TwoLocal(hamiltonian.num_qubits, 'ry', 'cz', reps=1)
</code></pre>
<p>Plotting the magnetization, I get</p>
<p><a href=""https://i.sstatic.net/lJoxX.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/lJoxX.png"" alt=""Plot of magnetization against time for SU2(blue) and TwoLocal (Orange) ansatze"" /></a>.</p>
<p>Looking at how the variational parameters change during evolution by</p>
<pre><code>for i in range(0, len(evolution_result_TwoLocal.parameter_values)):
    print(&quot;parameters&quot;, i, evolution_result_TwoLocal.parameter_values[i])
</code></pre>
<p>I note that the parameters are not changing.</p>
<pre><code>parameters 0 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 1 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 2 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 3 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 4 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 5 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 6 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 7 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 8 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 9 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 10 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 11 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 12 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 13 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 14 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 15 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 16 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 17 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 18 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 19 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 20 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 21 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 22 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 23 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 24 [1.57079633 1.57079633 1.57079633 1.57079633]
...
parameters 998 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 999 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 1000 [1.57079633 1.57079633 1.57079633 1.57079633]
parameters 1001 [1.57079633 1.57079633 1.57079633 1.57079633]
</code></pre>
<p>Is there an easy resolution?</p>
",qc,variational parameters changing varqrte runs twolocal ansatz p following qiskit tutorial https nofollow noreferrer variational time evolution changed ansatz varqrte pre code ansatz efficientsu2 p pre code import efficientsu2 twolocal ansatz twolocal p plotting magnetization get p https nofollow noreferrer img https plot magnetization time su2 blue twolocal orange ansatze p looking variational parameters change evolution pre code range 0 len print quot parameters quot p note parameters pre code parameters 0 parameters 1 parameters 2 parameters 3 parameters 4 parameters 5 parameters 6 parameters 7 parameters 8 parameters 9 parameters 10 parameters 11 parameters 12 parameters 13 parameters 14 parameters 15 parameters 16 parameters 17 parameters 18 parameters 19 parameters 20 parameters 21 parameters 22 parameters 23 parameters 24 parameters 998 parameters 999 parameters 1000 parameters 1001 p easy resolution,"[(0, 0.6185252), (1, 0.023579746), (4, 0.1384316), (6, 0.19493376), (17, 0.01557912)]"
35788,35792.0,2024-02-11 13:19:17,1,140,"<p>I am trying to use Pymatching to decode some non CSS codes like the XZZX code. Pymatching is a perfect decoder for CSS codes, which can work effectively even of a large code distance. I have tried to decode XZZX code with Pymatching (circuits written with stim language), and certainly it gives wrong results (as d increases, logical error increases). I have learned that the algorithm in Pymatching (Sparse Blossom MWPM) performs well dealing with graph-like errors, while the correction operation of XZZX differs from that of CSS code, which leads to a wrong outcome. So my question is more technically:How could I modify the error-correction part in the Pymatching package and make it suitable for non CSS codes (e.g. XZZX code)?</p>
",How can we decode non CSS codes like XZZX code with Pymatching?,<surface-code><pymatching><minimum-weight-perfect-matching>,1,0,,,"How can we decode non CSS codes like XZZX code with Pymatching? <p>I am trying to use Pymatching to decode some non CSS codes like the XZZX code. Pymatching is a perfect decoder for CSS codes, which can work effectively even of a large code distance. I have tried to decode XZZX code with Pymatching (circuits written with stim language), and certainly it gives wrong results (as d increases, logical error increases). I have learned that the algorithm in Pymatching (Sparse Blossom MWPM) performs well dealing with graph-like errors, while the correction operation of XZZX differs from that of CSS code, which leads to a wrong outcome. So my question is more technically:How could I modify the error-correction part in the Pymatching package and make it suitable for non CSS codes (e.g. XZZX code)?</p>
",qc,decode non css codes like xzzx code pymatching p trying use pymatching decode non css codes like xzzx code pymatching perfect decoder css codes work effectively even large code distance tried decode xzzx code pymatching circuits written stim language certainly gives wrong results increases logical error increases learned algorithm pymatching sparse blossom mwpm performs well dealing errors correction operation xzzx differs css code leads wrong outcome question technically could modify part pymatching package make suitable non css codes xzzx code,"[(5, 0.4224801), (7, 0.040940158), (8, 0.12851672), (14, 0.13893811), (17, 0.08242066), (19, 0.18495695)]"
35799,35807.0,2024-02-12 09:45:20,1,27,"<p>I want to measure the time spent for simulation of different algorithms to make some assumption about their efficiency.</p>
<p>I use Microsoft Azure Quantum SDK and VS Code setup.</p>
",Is there a way to measure a time spent for simulation? Does Q# support something like this?,<q#>,1,0,,,"Is there a way to measure a time spent for simulation? Does Q# support something like this? <p>I want to measure the time spent for simulation of different algorithms to make some assumption about their efficiency.</p>
<p>I use Microsoft Azure Quantum SDK and VS Code setup.</p>
",qc,way measure time spent simulation q support something like p want measure time spent simulation different algorithms make assumption p use microsoft azure quantum sdk vs code,"[(1, 0.2690759), (10, 0.039350536), (14, 0.6483208), (17, 0.037368078)]"
35813,35816.0,2024-02-13 04:44:45,0,76,"<p>I am studying quantum decoding, especially for minimum weight perfect matching. I wonder after finding perfect matching (syndrome graph referred by sparse Blossom), why do we need to select minimum weight? Is there any specific reason for selecting minimum weight?</p>
",Why minimum weight in the minimum weight perfect matching?,<error-correction><minimum-weight-perfect-matching>,1,0,,,"Why minimum weight in the minimum weight perfect matching? <p>I am studying quantum decoding, especially for minimum weight perfect matching. I wonder after finding perfect matching (syndrome graph referred by sparse Blossom), why do we need to select minimum weight? Is there any specific reason for selecting minimum weight?</p>
",qc,minimum weight minimum weight perfect matching p studying quantum decoding especially minimum weight perfect matching wonder finding perfect matching syndrome graph referred sparse blossom need select minimum weight specific reason selecting minimum weight,"[(5, 0.52682143), (7, 0.344709), (17, 0.093589276), (19, 0.030051561)]"
35815,35817.0,2024-02-13 09:43:17,2,177,"<p>I'm currently investigating Shor's algorithm and especially Smolin's variant, that he described in his article: <a href=""https://arxiv.org/abs/1301.7007"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1301.7007</a></p>
<p>My applied changes according to Smolin's variant are here:
<a href=""https://github.com/Sage-Cat/quantum_shors_algorithm"" rel=""nofollow noreferrer"">https://github.com/Sage-Cat/quantum_shors_algorithm</a></p>
<p>The paper I read you can find in repository <code>docs/Smolin_pretending_large_numbers.pdf</code>.</p>
<p>To be concise, he suggests to make this changes:</p>
<ol>
<li>Find <code>a</code>, such as <code>a^2 = 1 mod N</code>, using Extended Euclidean Algorithm</li>
<li>Set period <code>r = 2</code></li>
<li>And somehow use 2 qubits to simulate finding <code>a</code> and <code>r</code> or smth. (I don't understand the actual use of 2 qubits). From his paper I got only that he uses 2 qubits to get specific CNOT entanglement like this:</li>
</ol>
<pre class=""lang-cs prettyprint-override""><code>    operation ValidateAUsingQuantumSubroutine(a : Int, N : Int, r : Int) : Result {
        use qubits = Qubit[2];
        // Prepare qubits
        H(qubits[0]);
        CNOT(qubits[0], qubits[1]);

        // Measurement could be used to validate assumptions or effects
        let measurement = M(qubits[0]);

        ResetAll(qubits);
        return measurement;
    }
</code></pre>
<p>But how it helps to validate a, I don't understand.</p>
",Is there a way to implement Smolin's variant of Shor's algorithm?,<shors-algorithm><q#>,1,0,,,"Is there a way to implement Smolin's variant of Shor's algorithm? <p>I'm currently investigating Shor's algorithm and especially Smolin's variant, that he described in his article: <a href=""https://arxiv.org/abs/1301.7007"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1301.7007</a></p>
<p>My applied changes according to Smolin's variant are here:
<a href=""https://github.com/Sage-Cat/quantum_shors_algorithm"" rel=""nofollow noreferrer"">https://github.com/Sage-Cat/quantum_shors_algorithm</a></p>
<p>The paper I read you can find in repository <code>docs/Smolin_pretending_large_numbers.pdf</code>.</p>
<p>To be concise, he suggests to make this changes:</p>
<ol>
<li>Find <code>a</code>, such as <code>a^2 = 1 mod N</code>, using Extended Euclidean Algorithm</li>
<li>Set period <code>r = 2</code></li>
<li>And somehow use 2 qubits to simulate finding <code>a</code> and <code>r</code> or smth. (I don't understand the actual use of 2 qubits). From his paper I got only that he uses 2 qubits to get specific CNOT entanglement like this:</li>
</ol>
<pre class=""lang-cs prettyprint-override""><code>    operation ValidateAUsingQuantumSubroutine(a : Int, N : Int, r : Int) : Result {
        use qubits = Qubit[2];
        // Prepare qubits
        H(qubits[0]);
        CNOT(qubits[0], qubits[1]);

        // Measurement could be used to validate assumptions or effects
        let measurement = M(qubits[0]);

        ResetAll(qubits);
        return measurement;
    }
</code></pre>
<p>But how it helps to validate a, I don't understand.</p>
",qc,way implement smolin variant shor algorithm p currently investigating shor algorithm especially smolin variant described article https nofollow noreferrer https p applied changes according smolin variant https nofollow noreferrer https p paper read find repository code p concise suggests make changes ol li find code code 1 mod n using extended euclidean algorithm li set period code r 2 li somehow use 2 qubits simulate finding code code r smth understand actual use 2 qubits paper got uses 2 qubits get specific cnot entanglement like pre code operation validateausingquantumsubroutine int n int r int result use qubits qubit 2 prepare qubits h qubits 0 cnot qubits 0 qubits 1 measurement could used validate assumptions effects let measurement qubits 0 resetall qubits return measurement p helps validate,"[(0, 0.068383165), (2, 0.08391343), (3, 0.046996877), (4, 0.10955253), (7, 0.15723287), (13, 0.082245015), (14, 0.28872326), (17, 0.0110302195), (18, 0.15104187)]"
35819,35820.0,2024-02-14 04:15:21,3,185,"<p>I am currently trying to compute logical error rates for the surface code using Stim's detector error models and PyMatching for different distances and noise strengths.</p>
<p><strong>tl;dr</strong> : What is the best strategy for parallelising this process over different cores?</p>
<p>In doing so, I am trying to optimise the number of cores at my disposal by parallelising the different computations across multiple cores. My current workflow leverages <code>joblib</code> for this task</p>
<pre class=""lang-python prettyprint-override""><code>from joblib import Parallel, delayed, parallel_backend

distances = [...] # A set of distances
noise_strengths = [...] # A set of noise strengths
num_shots = ... # Some number of shots to sample
num_cycles = ... # Number of cycles over which to perform syndrome extraction

threads = ... # Maximum number of threads allowed
jobs = ... # Maximum number of jobs allowed

with parallel_backend(&quot;loky&quot;, inner_max_num_threads=threads):
        joblib_results = Parallel(n_jobs=jobs)(delayed(compute_logical_error_rate)(distance,noise,n_shots) for distance in distances for noise in noise_strengths)

</code></pre>
<p>where the logical error rate is computed using stim and pymatching in the following way</p>
<pre class=""lang-python prettyprint-override""><code>def compute_logical_error_rate(distance,noise,num_shots,num_cycles):

       sc_circuit = surface_code(distance,noise,num_cycles) # Define circuit
       sc_model = sc_circuit.detector_error_model(decompose_errors=True) # Detector error model
       
       sampler = sc_circuit.compile_detector_sampler() # Define sampler
       syndrome, measured_obs = sampler.sample(shots=num_shots, separate_observables=True) # Extract samples

       matching = Matching.from_detector_error_model(sc_model) # Matching graph
       expected_obs = matching.decode_batch(syndrome) # Perform decoding

       num_errors = np.sum(np.any(expected_obs != measured_obs, axis=1)) # Compute errors
       logical_error_rate = num_errors/num_shots # Compute logical error rate

       return logical_error_rate

</code></pre>
<p>This workflow allows me to assign a different simulation to each core, i.e. each core will perform the computation of the logical error rate for a given distance and noise strength. However, upon increasing the number of samples that I take, defined as <code>num_shots</code>, I start running into memory problems. I have identified the reason to be the <code>syndrome</code> variable, which is a numpy array whose size scales linearly with number of samples considered <code>syndrome.shape = (num_shots,...)</code>. The way I am parallelising naturally results in storing this variable multiple times (once for each job/core), thus leading to a memory overload.</p>
<p>I am interested in understanding how I can best leverage multiple cores to make this whole set of simulations more efficient. Would it make more sense to tackle one job at a time (fixed distance and noise strength) and parallelise the sampling across different cores? (If so, how can that be done?) - There seems to be a comment about this approach on the original Stim paper, but I do not see how to replicate this behaviour with my code.</p>
",What is the best way to parallelise processes across multiple cores when computing logical error rates with Stim and PyMatching?,<error-correction><simulation><stim><surface-code><pymatching>,1,0,,,"What is the best way to parallelise processes across multiple cores when computing logical error rates with Stim and PyMatching? <p>I am currently trying to compute logical error rates for the surface code using Stim's detector error models and PyMatching for different distances and noise strengths.</p>
<p><strong>tl;dr</strong> : What is the best strategy for parallelising this process over different cores?</p>
<p>In doing so, I am trying to optimise the number of cores at my disposal by parallelising the different computations across multiple cores. My current workflow leverages <code>joblib</code> for this task</p>
<pre class=""lang-python prettyprint-override""><code>from joblib import Parallel, delayed, parallel_backend

distances = [...] # A set of distances
noise_strengths = [...] # A set of noise strengths
num_shots = ... # Some number of shots to sample
num_cycles = ... # Number of cycles over which to perform syndrome extraction

threads = ... # Maximum number of threads allowed
jobs = ... # Maximum number of jobs allowed

with parallel_backend(&quot;loky&quot;, inner_max_num_threads=threads):
        joblib_results = Parallel(n_jobs=jobs)(delayed(compute_logical_error_rate)(distance,noise,n_shots) for distance in distances for noise in noise_strengths)

</code></pre>
<p>where the logical error rate is computed using stim and pymatching in the following way</p>
<pre class=""lang-python prettyprint-override""><code>def compute_logical_error_rate(distance,noise,num_shots,num_cycles):

       sc_circuit = surface_code(distance,noise,num_cycles) # Define circuit
       sc_model = sc_circuit.detector_error_model(decompose_errors=True) # Detector error model
       
       sampler = sc_circuit.compile_detector_sampler() # Define sampler
       syndrome, measured_obs = sampler.sample(shots=num_shots, separate_observables=True) # Extract samples

       matching = Matching.from_detector_error_model(sc_model) # Matching graph
       expected_obs = matching.decode_batch(syndrome) # Perform decoding

       num_errors = np.sum(np.any(expected_obs != measured_obs, axis=1)) # Compute errors
       logical_error_rate = num_errors/num_shots # Compute logical error rate

       return logical_error_rate

</code></pre>
<p>This workflow allows me to assign a different simulation to each core, i.e. each core will perform the computation of the logical error rate for a given distance and noise strength. However, upon increasing the number of samples that I take, defined as <code>num_shots</code>, I start running into memory problems. I have identified the reason to be the <code>syndrome</code> variable, which is a numpy array whose size scales linearly with number of samples considered <code>syndrome.shape = (num_shots,...)</code>. The way I am parallelising naturally results in storing this variable multiple times (once for each job/core), thus leading to a memory overload.</p>
<p>I am interested in understanding how I can best leverage multiple cores to make this whole set of simulations more efficient. Would it make more sense to tackle one job at a time (fixed distance and noise strength) and parallelise the sampling across different cores? (If so, how can that be done?) - There seems to be a comment about this approach on the original Stim paper, but I do not see how to replicate this behaviour with my code.</p>
",qc,best way parallelise processes across multiple cores computing logical error rates stim pymatching p currently trying compute logical error rates surface code using stim detector error models pymatching different distances noise p strong tl dr best strategy parallelising process different cores p trying optimise number cores disposal parallelising different computations across multiple cores current workflow leverages code joblib task pre code joblib import parallel delayed distances set distances set noise strengths number shots sample number cycles perform syndrome extraction threads maximum number threads allowed jobs maximum number jobs allowed quot loky quot parallel delayed distance noise distance distances noise p logical error rate computed using stim pymatching following way pre code def distance noise distance noise define circuit detector error model sampler define sampler syndrome extract samples matching matching graph syndrome perform decoding compute errors compute logical error rate return p workflow allows assign different simulation core core perform computation logical error rate given distance noise strength however upon increasing number samples take defined code start running memory problems identified reason code syndrome variable numpy array whose size scales linearly number samples considered code way parallelising naturally results storing variable multiple times thus leading memory p interested understanding best leverage multiple cores make whole set simulations efficient would make sense tackle one job time fixed distance noise strength parallelise sampling across different cores done seems comment approach original stim paper see replicate behaviour,"[(0, 0.024470704), (5, 0.23252863), (8, 0.1809923), (13, 0.039398674), (14, 0.40654314), (17, 0.072964914), (19, 0.042540662)]"
35864,35869.0,2024-02-18 23:33:24,4,169,"<p>In <a href=""https://quantumcomputing.stackexchange.com/a/23846/19679"">this neat answer by Markus Heinrich</a>, it is shown that twirling an arbitrary quantum channel <span class=""math-container"">$\Lambda$</span> over the unitary group <span class=""math-container"">$U(d)$</span> yields a depolarizing channel <span class=""math-container"">$\tilde{\Lambda}$</span> given by
<span class=""math-container"">$$
    \tilde{\Lambda}(M) = \Pi_{U(d)}(\Lambda)(M) = (1-p)\mathrm{Tr}(M) \frac{I}{d} + p M,
$$</span>
where <span class=""math-container"">$M$</span> is a linear operator on the Hilbert space (and <span class=""math-container"">$p$</span> is some function of <span class=""math-container"">$\Lambda$</span>, <span class=""math-container"">$M$</span>, and <span class=""math-container"">$d$</span>).</p>
<p><strong>1st question:</strong> Is this &quot;unitary twirling operation&quot; considered something physically realizable? For example, it often seems to be the case that the depolarizing channel is used in simulations and calculations, etc; is this because if we are given an arbitrary channel we can simply start any algorithm by unitary-twirling in some physical manner and therefore we may as well assume we started with the depolarizing channel to begin with? The <a href=""https://quantumcomputing.stackexchange.com/a/4083/19679"">comment by Norbert Schuch to this answer</a> seems to suggest that the answer is yes, but maybe someone can provide more details?</p>
<p><strong>2nd question:</strong> As Heinrich points out in his answer, one can replace <span class=""math-container"">$U(d)$</span> by any group <span class=""math-container"">$G$</span> and take the &quot;<span class=""math-container"">$G$</span>-twirl&quot; of a channel instead of the unitary twirl. Is the <span class=""math-container"">$G$</span>-twirl operation consider something physical?</p>
","Is the ""unitary twirling operation"" physically realizable?",<quantum-operation><depolarizing-channel><randomised-benchmarking>,1,0,,,"Is the ""unitary twirling operation"" physically realizable? <p>In <a href=""https://quantumcomputing.stackexchange.com/a/23846/19679"">this neat answer by Markus Heinrich</a>, it is shown that twirling an arbitrary quantum channel <span class=""math-container"">$\Lambda$</span> over the unitary group <span class=""math-container"">$U(d)$</span> yields a depolarizing channel <span class=""math-container"">$\tilde{\Lambda}$</span> given by
<span class=""math-container"">$$
    \tilde{\Lambda}(M) = \Pi_{U(d)}(\Lambda)(M) = (1-p)\mathrm{Tr}(M) \frac{I}{d} + p M,
$$</span>
where <span class=""math-container"">$M$</span> is a linear operator on the Hilbert space (and <span class=""math-container"">$p$</span> is some function of <span class=""math-container"">$\Lambda$</span>, <span class=""math-container"">$M$</span>, and <span class=""math-container"">$d$</span>).</p>
<p><strong>1st question:</strong> Is this &quot;unitary twirling operation&quot; considered something physically realizable? For example, it often seems to be the case that the depolarizing channel is used in simulations and calculations, etc; is this because if we are given an arbitrary channel we can simply start any algorithm by unitary-twirling in some physical manner and therefore we may as well assume we started with the depolarizing channel to begin with? The <a href=""https://quantumcomputing.stackexchange.com/a/4083/19679"">comment by Norbert Schuch to this answer</a> seems to suggest that the answer is yes, but maybe someone can provide more details?</p>
<p><strong>2nd question:</strong> As Heinrich points out in his answer, one can replace <span class=""math-container"">$U(d)$</span> by any group <span class=""math-container"">$G$</span> and take the &quot;<span class=""math-container"">$G$</span>-twirl&quot; of a channel instead of the unitary twirl. Is the <span class=""math-container"">$G$</span>-twirl operation consider something physical?</p>
",qc,unitary twirling operation physically realizable p https neat answer markus heinrich shown twirling arbitrary quantum channel span unitary group span u yields depolarizing channel span given span u tr p span linear operator hilbert space span p function span span span p strong 1st question quot unitary twirling operation quot considered something physically realizable example often seems case depolarizing channel used simulations calculations etc given arbitrary channel simply start algorithm physical manner therefore may well assume started depolarizing channel begin https comment norbert schuch answer seems suggest answer yes maybe someone provide details p strong 2nd question heinrich points answer one replace span u group span g take quot span g quot channel instead unitary twirl span g operation consider something physical,"[(3, 0.47928342), (8, 0.104655005), (9, 0.3578633), (17, 0.020360311), (19, 0.036609434)]"
35865,35868.0,2024-02-19 02:05:09,4,356,"<p>Consider Wiesner's quantum money scheme.  With today's devices and today's error correction and mitigation schemes, how long can we hold <span class=""math-container"">$n$</span> logical qubits such that they are all (logically) in a product state, with each logical qubit being drawn uniformly at random from one of the BB84 states <span class=""math-container"">$\{|0\rangle_L,|1\rangle_L,|+\rangle_L,|-\rangle_L\}$</span>, say, for <span class=""math-container"">$n=10$</span> or <span class=""math-container"">$20$</span> or <span class=""math-container"">$30?$</span></p>
<p>In Wiesner's scheme:</p>
<ol>
<li>We don't need to act fault-tolerantly on the logical qubits, as there's no two-qubit computation being done on the logical qubits in Wiesner's scheme;</li>
<li>In particular each qubit is prepared and measured in one of the four BB84 basis states - thus assuming easy preparation of <span class=""math-container"">$|0\rangle_L$</span>, the only relevant logical single-qubit gates are the Hadamard and the X/NOT gate (no arbitrary phases or T gates are needed); and</li>
<li>Because one whole bill can be written as a product state over all logical qubits, indeed, I can imagine that the <span class=""math-container"">$n$</span> qubits in a bill are prepared and distributed over multiple processors - one processor holding one (logical) qubit, another holding another, etc.</li>
</ol>
",Can Wiesner's quantum money be realized (with logical qubits) today?,<error-correction><fault-tolerance><nisq><quantum-money>,1,0,,,"Can Wiesner's quantum money be realized (with logical qubits) today? <p>Consider Wiesner's quantum money scheme.  With today's devices and today's error correction and mitigation schemes, how long can we hold <span class=""math-container"">$n$</span> logical qubits such that they are all (logically) in a product state, with each logical qubit being drawn uniformly at random from one of the BB84 states <span class=""math-container"">$\{|0\rangle_L,|1\rangle_L,|+\rangle_L,|-\rangle_L\}$</span>, say, for <span class=""math-container"">$n=10$</span> or <span class=""math-container"">$20$</span> or <span class=""math-container"">$30?$</span></p>
<p>In Wiesner's scheme:</p>
<ol>
<li>We don't need to act fault-tolerantly on the logical qubits, as there's no two-qubit computation being done on the logical qubits in Wiesner's scheme;</li>
<li>In particular each qubit is prepared and measured in one of the four BB84 basis states - thus assuming easy preparation of <span class=""math-container"">$|0\rangle_L$</span>, the only relevant logical single-qubit gates are the Hadamard and the X/NOT gate (no arbitrary phases or T gates are needed); and</li>
<li>Because one whole bill can be written as a product state over all logical qubits, indeed, I can imagine that the <span class=""math-container"">$n$</span> qubits in a bill are prepared and distributed over multiple processors - one processor holding one (logical) qubit, another holding another, etc.</li>
</ol>
",qc,wiesner quantum money realized logical qubits today p consider wiesner quantum money scheme today devices today error correction mitigation schemes long hold span n logical qubits logically product state logical qubit drawn uniformly random one bb84 states span say span span 20 span 30 p wiesner scheme ol li need act logical qubits computation done logical qubits wiesner scheme li particular qubit prepared measured one four bb84 basis states thus assuming easy preparation span relevant logical gates hadamard gate arbitrary phases gates needed li one whole bill written product state logical qubits indeed imagine span n qubits bill prepared distributed multiple processors one processor holding one logical qubit another holding another,"[(3, 0.11227216), (5, 0.15468927), (7, 0.16084546), (8, 0.06460884), (17, 0.0923281), (18, 0.41399592)]"
35873,,2024-02-19 15:31:37,3,355,"<h3>Background</h3>
<p>This question was triggered when I wanted to learn about <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> and how to use it to run simulations for error correction. The resources I used for learning about stim were basically Craig Gidney's YouTube videos and his <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">getting started-notebook</a>.</p>
<p>Before I state my questions, I want to provide some background information (Everything I write is 'as I understand it' - if my thought process does not make sense anywhere, I'm more than happy for feedback!): The standard example to evaluate 'how good a code' is always goes like this example with the repetition code:</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit.generated(
&quot;repetition_code:memory&quot;,
rounds=2,
distance=3,
before_round_data_depolarization=0.04,
before_measure_flip_probability=0.01)
</code></pre>
<p>The circuit looks like this:</p>
<p><a href=""https://i.sstatic.net/Dd4O8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Dd4O8.png"" alt=""enter image description here"" /></a></p>
<p>So, we are basically starting with the data qubits in state <span class=""math-container"">$|0\rangle^{\otimes 3}$</span>, and then measure the observables (in this case <span class=""math-container"">$Z_1Z_2$</span> and <span class=""math-container"">$Z_2Z_3$</span>) to get a logical <span class=""math-container"">$|0\rangle_L$</span> in repetition code (up to possible -1 outcomes which we don't care about). After performing as many error correction cycles as we feel like, we measure <span class=""math-container"">$Z_1$</span>, <span class=""math-container"">$Z_2$</span>, as well as <span class=""math-container"">$Z_3$</span>, which each are logical <span class=""math-container"">$Z$</span> observables.</p>
<p>The neat thing now is that by measuring not only one logical observable (which in the noiseless case gives exactly as much information as measuring all three of them) but all three, we get once more syndrome information: We know that the product of the outcomes of the <span class=""math-container"">$Z_1$</span> and <span class=""math-container"">$Z_2$</span> measurements in the noiseless case would be equal to the outcome of the <span class=""math-container"">$Z_1 Z_2$</span> stabiliser measurement in the last error correction round. This is crucial: If, for example, in the whole circuit, there was no error happening, but in the very end, right before the logical measurement of the first qubit, there was an X-error, we would be screwed if we'd only measured this first qubit to measure the logical observable. But since we basically get one more round of repetition code error syndromes from these three observables <span class=""math-container"">$Z_1$</span>, <span class=""math-container"">$Z_2$</span> and <span class=""math-container"">$Z_3$</span>, our decoding algorithm can understand that the whole error syndrome flips the value of the logical observable <span class=""math-container"">$Z_1$</span>.</p>
<hr />
<h3>My question</h3>
<p>Now, I tried as an exercise to implement the <a href=""https://errorcorrectionzoo.org/c/stab_5_1_3"" rel=""nofollow noreferrer""><span class=""math-container"">$[\![5,1,3]\!]$</span> five-qubit perfect code</a>.</p>
<p>It has stabiliser generators <span class=""math-container"">$XZZX\mathbb{1}$</span>, <span class=""math-container"">$\mathbb{1}XZZX$</span>, <span class=""math-container"">$X\mathbb{1}XZZ$</span> and <span class=""math-container"">$ZX\mathbb{1}XZ$</span>.</p>
<p>It is, of course, not hard to implement (I guess non-fault tolerantly, but that is not the topic of this question...) the <span class=""math-container"">$[\![5,1,3]\!]$</span> code in stim:</p>
<pre class=""lang-python prettyprint-override""><code>perfect_code = stim.Circuit('''
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3

CX 0 4
DEPOLARIZE2(0.01) 0 4
CZ 0 5
DEPOLARIZE2(0.01) 0 5
CZ 0 6
DEPOLARIZE2(0.01) 0 6
CX 0 7
DEPOLARIZE2(0.01) 0 7
CX 1 5
DEPOLARIZE2(0.01) 1 5
CZ 1 6
DEPOLARIZE2(0.01) 1 6
CZ 1 7
DEPOLARIZE2(0.01) 1 7
CX 1 8
DEPOLARIZE2(0.01) 1 8
CX 2 6
DEPOLARIZE2(0.01) 2 6
CZ 2 7
DEPOLARIZE2(0.01) 2 7
CZ 2 8
DEPOLARIZE2(0.01) 2 8
CX 2 4
DEPOLARIZE2(0.01) 2 4
CX 3 7
DEPOLARIZE2(0.01) 3 7
CZ 3 8
DEPOLARIZE2(0.01) 3 8
CZ 3 4
DEPOLARIZE2(0.01) 3 4
CX 3 5
DEPOLARIZE2(0.01) 3 5
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3
M 0 1 2 3
R 0 1 2 3
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3
CX 0 4
DEPOLARIZE2(0.01) 0 4
CZ 0 5
DEPOLARIZE2(0.01) 0 5
CZ 0 6
DEPOLARIZE2(0.01) 0 6
CX 0 7
DEPOLARIZE2(0.01) 0 7
CX 1 5
DEPOLARIZE2(0.01) 1 5
CZ 1 6
DEPOLARIZE2(0.01) 1 6
CZ 1 7
DEPOLARIZE2(0.01) 1 7
CX 1 8
DEPOLARIZE2(0.01) 1 8
CX 2 6
DEPOLARIZE2(0.01) 2 6
CZ 2 7
DEPOLARIZE2(0.01) 2 7
CZ 2 8
DEPOLARIZE2(0.01) 2 8
CX 2 4
DEPOLARIZE2(0.01) 2 4
CX 3 7
DEPOLARIZE2(0.01) 3 7
CZ 3 8
DEPOLARIZE2(0.01) 3 8
CZ 3 4
DEPOLARIZE2(0.01) 3 4
CX 3 5
DEPOLARIZE2(0.01) 3 5
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3
M 0
DETECTOR rec[-1] rec[-5]
M 1
DETECTOR rec[-1] rec[-5]
M 2
DETECTOR rec[-1] rec[-5]
M 3
DETECTOR rec[-1] rec[-5]

M 4 5 6 7 8
OBSERVABLE_INCLUDE(0) rec[-1] rec[-2] rec[-3] rec[-4] rec[-5]
</code></pre>
<p>The following screenshot is probably a bit hard to decipher, but I guess if one is used to <code>stim</code> it might still help to see the coarse structure..</p>
<p><a href=""https://i.sstatic.net/nPwRf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nPwRf.png"" alt=""enter image description here"" /></a></p>
<p>My problem/question is the following: I do not believe that we can apply a similar procedure as for the repetition code to protect ourselves from errors happening shortly before the final logical measurements. Here is a complete list of logical <span class=""math-container"">$Z$</span> operators on the [5,1,3] code (ignoring <span class=""math-container"">$\pm 1, \pm i$</span> prefactors).</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class=""math-container"">$IIYZY$</span></td>
<td><span class=""math-container"">$YIIYZ$</span></td>
<td><span class=""math-container"">$XIZIX$</span></td>
<td><span class=""math-container"">$ZIXXI$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$IXXIZ$</span></td>
<td><span class=""math-container"">$YXZXY$</span></td>
<td><span class=""math-container"">$XXIZI$</span></td>
<td><span class=""math-container"">$ZXYYX$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$IYZYI$</span></td>
<td><span class=""math-container"">$YYXZX$</span></td>
<td><span class=""math-container"">$XYYXZ$</span></td>
<td><span class=""math-container"">$ZYIIY$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$IZIXX$</span></td>
<td><span class=""math-container"">$YZYII$</span></td>
<td><span class=""math-container"">$XZXYY$</span></td>
<td><span class=""math-container"">$ZZZZZ$</span></td>
</tr>
</tbody>
</table></div>
<p>Looking at it, we can see that by picking <span class=""math-container"">$P_1, \dots , P_5$</span> single qubit Paulis that we measure on the data qubits, the best that we can achieve is that we get information about two different representatives of the logical operator and about one of the stabilisers, e.g.:</p>
<p><span class=""math-container"">$$ P_1 = X\,,\\ P_2 = Z\,, \\P_3 = X\,,\\ P_4 = Z\,,\\ P_5 = Z\,,$$</span></p>
<p>gives information about the representatives <span class=""math-container"">$IZXZI, XZIIZ$</span> of <span class=""math-container"">$Z_L$</span> as well as the stabiliser <span class=""math-container"">$XIXZZ$</span>. In this case, an X-error on the second system would screw everything up and would let us think the outcome is the opposite of what it was supposed to be (and it would be consistent with all other information we have!)</p>
<p>I also wrote some script that tries all possibilities of Paulis one can measure and this is indeed the best one can do I think.</p>
<p>I tried to find this 'phenomenon' in the literature but I never found it mentioned anywhere.</p>
<p>I would be super happy to get any feedback on this. A few precise questions I would be happy to get an answer for:</p>
<ul>
<li>I feel like there should be a theory about what I just described, like a theory of when it is possible to reliably measure logical operators (by measuring single Paulis) and when not. I would be very happy to get some references if this has been studied before.</li>
<li>My intuition is that for CSS codes, the described problems cannot occur. (Proof sketch: For CSS codes, the stabilisers and the logical operators can be chosen as products of only <span class=""math-container"">$Z$</span>s or of only <span class=""math-container"">$X$</span>s. So, if we measure all data qubits in <span class=""math-container"">$Z$</span> basis, we get another round of <span class=""math-container"">$Z$</span> type syndromes for free as well as the value of logical <span class=""math-container"">$Z$</span> operator we are interested in. If a <span class=""math-container"">$Z$</span>-type error would happen shortly before the final, logical measurement, this wouldn't affect the outcome of the single qubit <span class=""math-container"">$Z$</span> measurements. If an <span class=""math-container"">$X$</span>-error happens, it would affect the outcomes but it can be detected from the additional stabiliser syndromes.)</li>
<li>Are there non-CSS codes for which this problem can be avoided?</li>
</ul>
","Measuring observables in the $[\![5,3,1]\!]$ code with stim",<error-correction><stim>,1,0,,,"Measuring observables in the $[\![5,3,1]\!]$ code with stim <h3>Background</h3>
<p>This question was triggered when I wanted to learn about <a href=""https://github.com/quantumlib/Stim"" rel=""nofollow noreferrer"">stim</a> and how to use it to run simulations for error correction. The resources I used for learning about stim were basically Craig Gidney's YouTube videos and his <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">getting started-notebook</a>.</p>
<p>Before I state my questions, I want to provide some background information (Everything I write is 'as I understand it' - if my thought process does not make sense anywhere, I'm more than happy for feedback!): The standard example to evaluate 'how good a code' is always goes like this example with the repetition code:</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit.generated(
&quot;repetition_code:memory&quot;,
rounds=2,
distance=3,
before_round_data_depolarization=0.04,
before_measure_flip_probability=0.01)
</code></pre>
<p>The circuit looks like this:</p>
<p><a href=""https://i.sstatic.net/Dd4O8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Dd4O8.png"" alt=""enter image description here"" /></a></p>
<p>So, we are basically starting with the data qubits in state <span class=""math-container"">$|0\rangle^{\otimes 3}$</span>, and then measure the observables (in this case <span class=""math-container"">$Z_1Z_2$</span> and <span class=""math-container"">$Z_2Z_3$</span>) to get a logical <span class=""math-container"">$|0\rangle_L$</span> in repetition code (up to possible -1 outcomes which we don't care about). After performing as many error correction cycles as we feel like, we measure <span class=""math-container"">$Z_1$</span>, <span class=""math-container"">$Z_2$</span>, as well as <span class=""math-container"">$Z_3$</span>, which each are logical <span class=""math-container"">$Z$</span> observables.</p>
<p>The neat thing now is that by measuring not only one logical observable (which in the noiseless case gives exactly as much information as measuring all three of them) but all three, we get once more syndrome information: We know that the product of the outcomes of the <span class=""math-container"">$Z_1$</span> and <span class=""math-container"">$Z_2$</span> measurements in the noiseless case would be equal to the outcome of the <span class=""math-container"">$Z_1 Z_2$</span> stabiliser measurement in the last error correction round. This is crucial: If, for example, in the whole circuit, there was no error happening, but in the very end, right before the logical measurement of the first qubit, there was an X-error, we would be screwed if we'd only measured this first qubit to measure the logical observable. But since we basically get one more round of repetition code error syndromes from these three observables <span class=""math-container"">$Z_1$</span>, <span class=""math-container"">$Z_2$</span> and <span class=""math-container"">$Z_3$</span>, our decoding algorithm can understand that the whole error syndrome flips the value of the logical observable <span class=""math-container"">$Z_1$</span>.</p>
<hr />
<h3>My question</h3>
<p>Now, I tried as an exercise to implement the <a href=""https://errorcorrectionzoo.org/c/stab_5_1_3"" rel=""nofollow noreferrer""><span class=""math-container"">$[\![5,1,3]\!]$</span> five-qubit perfect code</a>.</p>
<p>It has stabiliser generators <span class=""math-container"">$XZZX\mathbb{1}$</span>, <span class=""math-container"">$\mathbb{1}XZZX$</span>, <span class=""math-container"">$X\mathbb{1}XZZ$</span> and <span class=""math-container"">$ZX\mathbb{1}XZ$</span>.</p>
<p>It is, of course, not hard to implement (I guess non-fault tolerantly, but that is not the topic of this question...) the <span class=""math-container"">$[\![5,1,3]\!]$</span> code in stim:</p>
<pre class=""lang-python prettyprint-override""><code>perfect_code = stim.Circuit('''
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3

CX 0 4
DEPOLARIZE2(0.01) 0 4
CZ 0 5
DEPOLARIZE2(0.01) 0 5
CZ 0 6
DEPOLARIZE2(0.01) 0 6
CX 0 7
DEPOLARIZE2(0.01) 0 7
CX 1 5
DEPOLARIZE2(0.01) 1 5
CZ 1 6
DEPOLARIZE2(0.01) 1 6
CZ 1 7
DEPOLARIZE2(0.01) 1 7
CX 1 8
DEPOLARIZE2(0.01) 1 8
CX 2 6
DEPOLARIZE2(0.01) 2 6
CZ 2 7
DEPOLARIZE2(0.01) 2 7
CZ 2 8
DEPOLARIZE2(0.01) 2 8
CX 2 4
DEPOLARIZE2(0.01) 2 4
CX 3 7
DEPOLARIZE2(0.01) 3 7
CZ 3 8
DEPOLARIZE2(0.01) 3 8
CZ 3 4
DEPOLARIZE2(0.01) 3 4
CX 3 5
DEPOLARIZE2(0.01) 3 5
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3
M 0 1 2 3
R 0 1 2 3
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3
CX 0 4
DEPOLARIZE2(0.01) 0 4
CZ 0 5
DEPOLARIZE2(0.01) 0 5
CZ 0 6
DEPOLARIZE2(0.01) 0 6
CX 0 7
DEPOLARIZE2(0.01) 0 7
CX 1 5
DEPOLARIZE2(0.01) 1 5
CZ 1 6
DEPOLARIZE2(0.01) 1 6
CZ 1 7
DEPOLARIZE2(0.01) 1 7
CX 1 8
DEPOLARIZE2(0.01) 1 8
CX 2 6
DEPOLARIZE2(0.01) 2 6
CZ 2 7
DEPOLARIZE2(0.01) 2 7
CZ 2 8
DEPOLARIZE2(0.01) 2 8
CX 2 4
DEPOLARIZE2(0.01) 2 4
CX 3 7
DEPOLARIZE2(0.01) 3 7
CZ 3 8
DEPOLARIZE2(0.01) 3 8
CZ 3 4
DEPOLARIZE2(0.01) 3 4
CX 3 5
DEPOLARIZE2(0.01) 3 5
H 0 1 2 3
DEPOLARIZE1(0.01) 0 1 2 3
M 0
DETECTOR rec[-1] rec[-5]
M 1
DETECTOR rec[-1] rec[-5]
M 2
DETECTOR rec[-1] rec[-5]
M 3
DETECTOR rec[-1] rec[-5]

M 4 5 6 7 8
OBSERVABLE_INCLUDE(0) rec[-1] rec[-2] rec[-3] rec[-4] rec[-5]
</code></pre>
<p>The following screenshot is probably a bit hard to decipher, but I guess if one is used to <code>stim</code> it might still help to see the coarse structure..</p>
<p><a href=""https://i.sstatic.net/nPwRf.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/nPwRf.png"" alt=""enter image description here"" /></a></p>
<p>My problem/question is the following: I do not believe that we can apply a similar procedure as for the repetition code to protect ourselves from errors happening shortly before the final logical measurements. Here is a complete list of logical <span class=""math-container"">$Z$</span> operators on the [5,1,3] code (ignoring <span class=""math-container"">$\pm 1, \pm i$</span> prefactors).</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class=""math-container"">$IIYZY$</span></td>
<td><span class=""math-container"">$YIIYZ$</span></td>
<td><span class=""math-container"">$XIZIX$</span></td>
<td><span class=""math-container"">$ZIXXI$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$IXXIZ$</span></td>
<td><span class=""math-container"">$YXZXY$</span></td>
<td><span class=""math-container"">$XXIZI$</span></td>
<td><span class=""math-container"">$ZXYYX$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$IYZYI$</span></td>
<td><span class=""math-container"">$YYXZX$</span></td>
<td><span class=""math-container"">$XYYXZ$</span></td>
<td><span class=""math-container"">$ZYIIY$</span></td>
</tr>
<tr>
<td><span class=""math-container"">$IZIXX$</span></td>
<td><span class=""math-container"">$YZYII$</span></td>
<td><span class=""math-container"">$XZXYY$</span></td>
<td><span class=""math-container"">$ZZZZZ$</span></td>
</tr>
</tbody>
</table></div>
<p>Looking at it, we can see that by picking <span class=""math-container"">$P_1, \dots , P_5$</span> single qubit Paulis that we measure on the data qubits, the best that we can achieve is that we get information about two different representatives of the logical operator and about one of the stabilisers, e.g.:</p>
<p><span class=""math-container"">$$ P_1 = X\,,\\ P_2 = Z\,, \\P_3 = X\,,\\ P_4 = Z\,,\\ P_5 = Z\,,$$</span></p>
<p>gives information about the representatives <span class=""math-container"">$IZXZI, XZIIZ$</span> of <span class=""math-container"">$Z_L$</span> as well as the stabiliser <span class=""math-container"">$XIXZZ$</span>. In this case, an X-error on the second system would screw everything up and would let us think the outcome is the opposite of what it was supposed to be (and it would be consistent with all other information we have!)</p>
<p>I also wrote some script that tries all possibilities of Paulis one can measure and this is indeed the best one can do I think.</p>
<p>I tried to find this 'phenomenon' in the literature but I never found it mentioned anywhere.</p>
<p>I would be super happy to get any feedback on this. A few precise questions I would be happy to get an answer for:</p>
<ul>
<li>I feel like there should be a theory about what I just described, like a theory of when it is possible to reliably measure logical operators (by measuring single Paulis) and when not. I would be very happy to get some references if this has been studied before.</li>
<li>My intuition is that for CSS codes, the described problems cannot occur. (Proof sketch: For CSS codes, the stabilisers and the logical operators can be chosen as products of only <span class=""math-container"">$Z$</span>s or of only <span class=""math-container"">$X$</span>s. So, if we measure all data qubits in <span class=""math-container"">$Z$</span> basis, we get another round of <span class=""math-container"">$Z$</span> type syndromes for free as well as the value of logical <span class=""math-container"">$Z$</span> operator we are interested in. If a <span class=""math-container"">$Z$</span>-type error would happen shortly before the final, logical measurement, this wouldn't affect the outcome of the single qubit <span class=""math-container"">$Z$</span> measurements. If an <span class=""math-container"">$X$</span>-error happens, it would affect the outcomes but it can be detected from the additional stabiliser syndromes.)</li>
<li>Are there non-CSS codes for which this problem can be avoided?</li>
</ul>
",qc,measuring observables code stim h3 background p question triggered wanted learn https nofollow noreferrer stim use run simulations error correction resources used learning stim basically craig gidney youtube videos https nofollow noreferrer getting p state questions want provide background information everything write understand thought process make sense anywhere happy feedback standard example evaluate good code always goes like example repetition code pre code circuit quot memory quot p circuit looks like p https nofollow noreferrer img https enter image description p basically starting data qubits state span 3 measure observables case span span get logical span repetition code possible outcomes care performing many error correction cycles feel like measure span span well span logical span z p neat thing measuring one logical observable noiseless case gives exactly much information measuring three three get syndrome information know product outcomes span span measurements noiseless case would equal outcome span stabiliser measurement last error correction round crucial example whole circuit error happening end right logical measurement first qubit would screwed measured first qubit measure logical observable since basically get one round repetition code error syndromes three observables span span span decoding algorithm understand whole error syndrome flips value logical observable span hr h3 question p tried exercise implement https nofollow noreferrer span perfect code p stabiliser generators span 1 span 1 xzzx span 1 xzz span 1 xz p course hard implement guess tolerantly topic question span code stim pre code h 0 1 2 3 depolarize1 0 1 2 3 cx 0 4 depolarize2 0 4 cz 0 5 depolarize2 0 5 cz 0 6 depolarize2 0 6 cx 0 7 depolarize2 0 7 cx 1 5 depolarize2 1 5 cz 1 6 depolarize2 1 6 cz 1 7 depolarize2 1 7 cx 1 8 depolarize2 1 8 cx 2 6 depolarize2 2 6 cz 2 7 depolarize2 2 7 cz 2 8 depolarize2 2 8 cx 2 4 depolarize2 2 4 cx 3 7 depolarize2 3 7 cz 3 8 depolarize2 3 8 cz 3 4 depolarize2 3 4 cx 3 5 depolarize2 3 5 h 0 1 2 3 depolarize1 0 1 2 3 0 1 2 3 r 0 1 2 3 h 0 1 2 3 depolarize1 0 1 2 3 cx 0 4 depolarize2 0 4 cz 0 5 depolarize2 0 5 cz 0 6 depolarize2 0 6 cx 0 7 depolarize2 0 7 cx 1 5 depolarize2 1 5 cz 1 6 depolarize2 1 6 cz 1 7 depolarize2 1 7 cx 1 8 depolarize2 1 8 cx 2 6 depolarize2 2 6 cz 2 7 depolarize2 2 7 cz 2 8 depolarize2 2 8 cx 2 4 depolarize2 2 4 cx 3 7 depolarize2 3 7 cz 3 8 depolarize2 3 8 cz 3 4 depolarize2 3 4 cx 3 5 depolarize2 3 5 h 0 1 2 3 depolarize1 0 1 2 3 0 detector rec rec 1 detector rec rec 2 detector rec rec 3 detector rec rec 4 5 6 7 8 0 rec rec rec rec rec p following screenshot probably bit hard decipher guess one used code stim might still help see coarse structure p https nofollow noreferrer img https enter image description p following believe apply similar procedure repetition code protect errors happening shortly final logical measurements complete list logical span z operators code ignoring span 1 prefactors div table thead tr th th th th tbody tr td span iiyzy td span yiiyz td span xizix td span zixxi tr td span ixxiz td span yxzxy td span xxizi td span zxyyx tr td span iyzyi td span yyxzx td span xyyxz td span zyiiy tr td span izixx td span yzyii td span xzxyy td span zzzzz p looking see picking span single qubit paulis measure data qubits best achieve get information two different representatives logical operator one stabilisers p span p gives information representatives span izxzi xziiz span well stabiliser span xixzz case second system would screw everything would let us think outcome opposite supposed would consistent information p also wrote script tries possibilities paulis one measure indeed best one p tried find literature never found mentioned p would super happy get feedback precise questions would happy get answer ul li feel like theory described like theory possible reliably measure logical operators measuring single paulis would happy get references studied li intuition css codes described problems occur proof sketch css codes stabilisers logical operators chosen products span z span x measure data qubits span z basis get another round span z type syndromes free well value logical span z operator interested span z error would happen shortly final logical measurement would affect outcome single qubit span z measurements span x happens would affect outcomes detected additional stabiliser syndromes li codes problem avoided,"[(2, 0.07368815), (3, 0.18772422), (4, 0.044924412), (5, 0.14575617), (6, 0.3007964), (7, 0.010069783), (8, 0.046142027), (9, 0.05026894), (14, 0.056760836), (17, 0.038744185), (18, 0.040666923)]"
35915,36987.0,2024-02-22 14:39:37,4,317,"<p>This problem is from a &quot;passing remark&quot; in <a href=""https://mediatum.ub.tum.de/node?id=1701036&amp;change_language=en"" rel=""nofollow noreferrer"">this lecture notes</a>. With the help of some colleagues I managed to find a way for this supposedly elementary fact, but I would like to see if there is an alternative the details of which I will explain at the end.</p>
<p>Let <span class=""math-container"">$V=\mathcal{M}_{d,d'}(\mathbb{C})$</span> be the space of <span class=""math-container"">$d\times d'$</span> complex matrices and upgrade this into a Hilbert space by using the inner product
<span class=""math-container"">\begin{align}
\langle A,B\rangle := \text{Tr}(PA^\dagger B)
\end{align}</span>
where <span class=""math-container"">$P&gt;0$</span> is any positive-definite <span class=""math-container"">$d' \times d'$</span> matrix. Now construct an orthonormal basis (ONB) of <span class=""math-container"">$V$</span> using the inner product so that we get <span class=""math-container"">$dd'$</span> operator basis elements.</p>
<p>The claim I would like to prove is this: the ONB <span class=""math-container"">$\{A_j\}$</span> defines a completely-positive (CP) map <span class=""math-container"">$\Phi$</span> such that
<span class=""math-container"">\begin{equation}
\Phi(\rho):= \sum_{k=1}^{dd'}A_k^\dagger\rho A_k = \text{Tr}(\rho)P^{-1}.
\end{equation}</span>
Although not necessary for the task, I believe this CP map is by construction maximum Kraus rank since the maximum rank of the Choi matrix is <span class=""math-container"">$dd'$</span>. If this were a quantum channel (i.e., if we impose trace-preserving property), it would be a replacement channel that outputs a constant state proportional to <span class=""math-container"">$P^{-1}$</span>.</p>
<p>This statement can be proven by drawing pictures using tensor network type language (not exactly obvious but once drawn it is straightforward to see why). For this it is easy to use a different set of Kraus operator <span class=""math-container"">$\\{B_k=A_k\sqrt{P}\\}$</span> for which the inner product becomes Hilbert-Schmidt which makes it easier.</p>
<p>The problem is as follows. First, since this appears in Chapter 2 of the lecture notes and is just a statement in passing, I would like to see if there is (1) straightforward and/or (2) transparent proof of this statement. By &quot;transparent&quot; I mean I should not, hopefully, need to rely on obscure facts in linear algebra. Second, this statement seems to be connected to the theory of fixed points of quantum channels (which the lecture notes discuss in Chapter 6). I am still learning about it, but if there is an insight or natural proof using Perron-Frobenius theory (irreducible maps, etc.), I would love to be inspired/enlightened. Last but not least, I am hoping for some intuition: in the case of qubits, this is the case of a completely depolarizing channel, but I am not sure if this intuition generalizes to higher dimensions or arbitrary <span class=""math-container"">$P$</span> (which needs not be diagonal). I guess by absorbing <span class=""math-container"">$P$</span> into the Kraus operators it does look like completely depolarizing channel anyway (though here we don't have yet trace-preserving property), but since the Kraus operators are not guaranteed to be unitary I am not sure if this is valid.</p>
",Prove that if Kraus operators of $\Phi$ form an ONB then $\Phi$ is the replacement map,<linear-algebra><quantum-operation><kraus-representation><foundations>,2,3,,,"Prove that if Kraus operators of $\Phi$ form an ONB then $\Phi$ is the replacement map <p>This problem is from a &quot;passing remark&quot; in <a href=""https://mediatum.ub.tum.de/node?id=1701036&amp;change_language=en"" rel=""nofollow noreferrer"">this lecture notes</a>. With the help of some colleagues I managed to find a way for this supposedly elementary fact, but I would like to see if there is an alternative the details of which I will explain at the end.</p>
<p>Let <span class=""math-container"">$V=\mathcal{M}_{d,d'}(\mathbb{C})$</span> be the space of <span class=""math-container"">$d\times d'$</span> complex matrices and upgrade this into a Hilbert space by using the inner product
<span class=""math-container"">\begin{align}
\langle A,B\rangle := \text{Tr}(PA^\dagger B)
\end{align}</span>
where <span class=""math-container"">$P&gt;0$</span> is any positive-definite <span class=""math-container"">$d' \times d'$</span> matrix. Now construct an orthonormal basis (ONB) of <span class=""math-container"">$V$</span> using the inner product so that we get <span class=""math-container"">$dd'$</span> operator basis elements.</p>
<p>The claim I would like to prove is this: the ONB <span class=""math-container"">$\{A_j\}$</span> defines a completely-positive (CP) map <span class=""math-container"">$\Phi$</span> such that
<span class=""math-container"">\begin{equation}
\Phi(\rho):= \sum_{k=1}^{dd'}A_k^\dagger\rho A_k = \text{Tr}(\rho)P^{-1}.
\end{equation}</span>
Although not necessary for the task, I believe this CP map is by construction maximum Kraus rank since the maximum rank of the Choi matrix is <span class=""math-container"">$dd'$</span>. If this were a quantum channel (i.e., if we impose trace-preserving property), it would be a replacement channel that outputs a constant state proportional to <span class=""math-container"">$P^{-1}$</span>.</p>
<p>This statement can be proven by drawing pictures using tensor network type language (not exactly obvious but once drawn it is straightforward to see why). For this it is easy to use a different set of Kraus operator <span class=""math-container"">$\\{B_k=A_k\sqrt{P}\\}$</span> for which the inner product becomes Hilbert-Schmidt which makes it easier.</p>
<p>The problem is as follows. First, since this appears in Chapter 2 of the lecture notes and is just a statement in passing, I would like to see if there is (1) straightforward and/or (2) transparent proof of this statement. By &quot;transparent&quot; I mean I should not, hopefully, need to rely on obscure facts in linear algebra. Second, this statement seems to be connected to the theory of fixed points of quantum channels (which the lecture notes discuss in Chapter 6). I am still learning about it, but if there is an insight or natural proof using Perron-Frobenius theory (irreducible maps, etc.), I would love to be inspired/enlightened. Last but not least, I am hoping for some intuition: in the case of qubits, this is the case of a completely depolarizing channel, but I am not sure if this intuition generalizes to higher dimensions or arbitrary <span class=""math-container"">$P$</span> (which needs not be diagonal). I guess by absorbing <span class=""math-container"">$P$</span> into the Kraus operators it does look like completely depolarizing channel anyway (though here we don't have yet trace-preserving property), but since the Kraus operators are not guaranteed to be unitary I am not sure if this is valid.</p>
",qc,prove kraus operators form onb replacement map p problem quot passing remark quot https amp nofollow noreferrer lecture notes help colleagues managed find way supposedly elementary fact would like see alternative details explain p let span c space span complex matrices upgrade hilbert space using inner product span align tr b align span p gt 0 span matrix construct orthonormal basis onb span v using inner product get span dd operator basis p claim would like prove onb span defines cp map span span equation dd tr equation although necessary task believe cp map construction maximum kraus rank since maximum rank choi matrix span dd quantum channel impose property would replacement channel outputs constant state proportional span p statement proven drawing pictures using tensor network type language exactly obvious drawn straightforward see easy use different set kraus operator span p inner product becomes makes p problem follows first since appears chapter 2 lecture notes statement passing would like see 1 straightforward 2 transparent proof statement quot transparent quot mean hopefully need rely obscure facts linear algebra second statement seems connected theory fixed points quantum channels lecture notes discuss chapter 6 still learning insight natural proof using theory irreducible maps etc would love last least hoping intuition case qubits case completely depolarizing channel sure intuition generalizes higher dimensions arbitrary span p needs diagonal guess absorbing span p kraus operators look like completely depolarizing channel anyway though yet property since kraus operators guaranteed unitary sure,"[(3, 0.6288028), (8, 0.24224024), (9, 0.028653443), (11, 0.034489557), (15, 0.016466461), (17, 0.024027789), (19, 0.019252393)]"
35923,,2024-02-23 10:33:08,1,141,"<p>I have started to read more about Grover's algorithm to find the binary string <span class=""math-container"">$x'$</span> of <span class=""math-container"">$n$</span> bits for which <span class=""math-container"">$f(x=x')=1$</span> while <span class=""math-container"">$f(x\neq x')=0$</span>, out of a total possibility space of <span class=""math-container"">$N=2^n$</span>. So it works as</p>
<ol>
<li>Prepare one uniform superposition of all posibilities (<span class=""math-container"">$O(1)$</span> with Hadamard gates)</li>
<li>A conditional phase flip gate <span class=""math-container"">$e^{i\pi f(x)}$</span>, that gives a minus sign to <span class=""math-container"">$x'$</span> in the superposition.</li>
<li>A flip around the mean weight with a &quot;diffusion operator&quot;</li>
</ol>
<p>By iterating steps 2 and 3, the weight of x' in the superposition would then keep growing, and achieve 50% probability on <span class=""math-container"">$O(\sqrt N)$</span> iterations.</p>
<p>So how about the following algorithm</p>
<ol>
<li>Prepare two uniform superpositions <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> of all posibilities (<span class=""math-container"">$O(1)$</span> with Hadamard gates)</li>
<li>A conditional phase flip gate <span class=""math-container"">$e^{i\pi f(x)}$</span> to copy <span class=""math-container"">$A$</span>, that gives a minus sign to <span class=""math-container"">$x'$</span> in the superposition. Leave <span class=""math-container"">$B$</span> invariant</li>
<li>Interfere <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> (such that it is destructive for all the non-flipped <span class=""math-container"">$x$</span>), and then all weight goes to <span class=""math-container"">$x'$</span></li>
<li>Read out the interference pattern, scaling only as <span class=""math-container"">$O(n)=O(\log N)$</span> with photodetectors</li>
</ol>
<p>This should in principle work in a single iteration. Why go through all the trouble of iterating with a diffusion operator?. I can imagine that it is hard to interfere qubits directly when thinking of them as spins, however that's only a technical limitation. Supperconducting qubits are just photons, so you should be able to let them interfere with each other in free space at least in principle.</p>
<p>More precisely, we could envision each of the qubits implemented in the manifold spanned by a pair of coherent states with opposite phases ie <span class=""math-container"">$|\uparrow\rangle=|\alpha\rangle$</span> and <span class=""math-container"">$|\downarrow\rangle=|-\alpha\rangle$</span>, then, suppose that <span class=""math-container"">$x'=|\downarrow \downarrow\rangle$</span>, we get <span class=""math-container"">$|A\rangle=-|-\alpha,-\alpha\rangle+|\alpha,-\alpha\rangle+|-\alpha,\alpha\rangle+|\alpha,\alpha\rangle$</span> while <span class=""math-container"">$|B\rangle=|-\alpha,-\alpha\rangle+|\alpha,-\alpha\rangle+|-\alpha,\alpha\rangle+|\alpha,\alpha\rangle$</span></p>
<p>If <span class=""math-container"">$|A\rangle$</span> and <span class=""math-container"">$|B\rangle$</span> are now being emitted simultaneously from two spatially separated optical sources, their interference pattern will be of the form <span class=""math-container"">$|A\rangle+e^{i\phi}|B\rangle$</span>, with <span class=""math-container"">$\phi$</span> spatially dependent. And we can choose it at a point in space where there is a half wavelength mismatch, then <span class=""math-container"">$\phi=\pi$</span>. And at that point, the resulting state will be <span class=""math-container"">$|A\rangle-|B\rangle=-|-\alpha,-\alpha\rangle\propto|\downarrow \downarrow\rangle=|x'\rangle$</span> . It can be read out (the phases) using a homodyne detection scheme for each bit (we can always envision to use an extra spatial dimension or so to avoid different bits to interfere with one another).</p>
",Trivial speedup of Grover to log(N) using interference?,<grovers-algorithm>,1,4,,,"Trivial speedup of Grover to log(N) using interference? <p>I have started to read more about Grover's algorithm to find the binary string <span class=""math-container"">$x'$</span> of <span class=""math-container"">$n$</span> bits for which <span class=""math-container"">$f(x=x')=1$</span> while <span class=""math-container"">$f(x\neq x')=0$</span>, out of a total possibility space of <span class=""math-container"">$N=2^n$</span>. So it works as</p>
<ol>
<li>Prepare one uniform superposition of all posibilities (<span class=""math-container"">$O(1)$</span> with Hadamard gates)</li>
<li>A conditional phase flip gate <span class=""math-container"">$e^{i\pi f(x)}$</span>, that gives a minus sign to <span class=""math-container"">$x'$</span> in the superposition.</li>
<li>A flip around the mean weight with a &quot;diffusion operator&quot;</li>
</ol>
<p>By iterating steps 2 and 3, the weight of x' in the superposition would then keep growing, and achieve 50% probability on <span class=""math-container"">$O(\sqrt N)$</span> iterations.</p>
<p>So how about the following algorithm</p>
<ol>
<li>Prepare two uniform superpositions <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> of all posibilities (<span class=""math-container"">$O(1)$</span> with Hadamard gates)</li>
<li>A conditional phase flip gate <span class=""math-container"">$e^{i\pi f(x)}$</span> to copy <span class=""math-container"">$A$</span>, that gives a minus sign to <span class=""math-container"">$x'$</span> in the superposition. Leave <span class=""math-container"">$B$</span> invariant</li>
<li>Interfere <span class=""math-container"">$A$</span> and <span class=""math-container"">$B$</span> (such that it is destructive for all the non-flipped <span class=""math-container"">$x$</span>), and then all weight goes to <span class=""math-container"">$x'$</span></li>
<li>Read out the interference pattern, scaling only as <span class=""math-container"">$O(n)=O(\log N)$</span> with photodetectors</li>
</ol>
<p>This should in principle work in a single iteration. Why go through all the trouble of iterating with a diffusion operator?. I can imagine that it is hard to interfere qubits directly when thinking of them as spins, however that's only a technical limitation. Supperconducting qubits are just photons, so you should be able to let them interfere with each other in free space at least in principle.</p>
<p>More precisely, we could envision each of the qubits implemented in the manifold spanned by a pair of coherent states with opposite phases ie <span class=""math-container"">$|\uparrow\rangle=|\alpha\rangle$</span> and <span class=""math-container"">$|\downarrow\rangle=|-\alpha\rangle$</span>, then, suppose that <span class=""math-container"">$x'=|\downarrow \downarrow\rangle$</span>, we get <span class=""math-container"">$|A\rangle=-|-\alpha,-\alpha\rangle+|\alpha,-\alpha\rangle+|-\alpha,\alpha\rangle+|\alpha,\alpha\rangle$</span> while <span class=""math-container"">$|B\rangle=|-\alpha,-\alpha\rangle+|\alpha,-\alpha\rangle+|-\alpha,\alpha\rangle+|\alpha,\alpha\rangle$</span></p>
<p>If <span class=""math-container"">$|A\rangle$</span> and <span class=""math-container"">$|B\rangle$</span> are now being emitted simultaneously from two spatially separated optical sources, their interference pattern will be of the form <span class=""math-container"">$|A\rangle+e^{i\phi}|B\rangle$</span>, with <span class=""math-container"">$\phi$</span> spatially dependent. And we can choose it at a point in space where there is a half wavelength mismatch, then <span class=""math-container"">$\phi=\pi$</span>. And at that point, the resulting state will be <span class=""math-container"">$|A\rangle-|B\rangle=-|-\alpha,-\alpha\rangle\propto|\downarrow \downarrow\rangle=|x'\rangle$</span> . It can be read out (the phases) using a homodyne detection scheme for each bit (we can always envision to use an extra spatial dimension or so to avoid different bits to interfere with one another).</p>
",qc,trivial speedup grover log n using interference p started read grover algorithm find binary string span x span n bits span f span f x total possibility space span works ol li prepare one uniform superposition posibilities span 1 hadamard gates li conditional phase flip gate span f x gives minus sign span x li flip around mean weight quot diffusion operator quot p iterating steps 2 3 weight x superposition would keep growing achieve 50 probability span n p following algorithm ol li prepare two uniform superpositions span span b posibilities span 1 hadamard gates li conditional phase flip gate span f x copy span gives minus sign span x superposition leave span b invariant li interfere span span b destructive span x weight goes span x li read interference pattern scaling span n n photodetectors p principle work single iteration go trouble iterating diffusion operator imagine hard interfere qubits directly thinking spins however technical limitation supperconducting qubits photons able let interfere free space least p precisely could envision qubits implemented manifold spanned pair coherent states opposite phases ie span span suppose span get span span p span span emitted simultaneously two spatially separated optical sources interference pattern form span span spatially dependent choose point space half wavelength mismatch span point resulting state span read phases using homodyne detection scheme bit always envision use extra spatial dimension avoid different bits interfere one another,"[(3, 0.28350446), (5, 0.025976844), (7, 0.055646125), (8, 0.078574575), (10, 0.07467886), (13, 0.02215003), (17, 0.025016788), (18, 0.41470066), (19, 0.015230174)]"
35930,35932.0,2024-02-23 15:16:32,1,45,"<p>Is it possible to change the simulator used by the Classic QDK with Python simulation ?
It's reported that Classic QDK supports several simulators (sparse, full-state...). Which one is used when called from Python environment, and is it possible to change it?</p>
<p>I have a simulation which doesn't run because of large number of qubits instantiated (from 25 up to 61). The simulation with C# .NET runs perfectly. But when I use a Python host program, the simulation is simply blocked at qubit instantiation.</p>
<p>So I suppose that C# .NET host uses sparse simulator, while Python uses full-state.</p>
",Microsoft Classic QDK simulator,<programming><simulation><q#>,1,0,,,"Microsoft Classic QDK simulator <p>Is it possible to change the simulator used by the Classic QDK with Python simulation ?
It's reported that Classic QDK supports several simulators (sparse, full-state...). Which one is used when called from Python environment, and is it possible to change it?</p>
<p>I have a simulation which doesn't run because of large number of qubits instantiated (from 25 up to 61). The simulation with C# .NET runs perfectly. But when I use a Python host program, the simulation is simply blocked at qubit instantiation.</p>
<p>So I suppose that C# .NET host uses sparse simulator, while Python uses full-state.</p>
",qc,microsoft classic qdk simulator p possible change simulator used classic qdk python simulation reported classic qdk supports several simulators sparse one used called python environment possible change p simulation run large number qubits instantiated 25 61 simulation c runs perfectly use python host program simulation simply blocked qubit p suppose c host uses sparse simulator python uses,"[(13, 0.07240878), (14, 0.693425), (15, 0.21325886), (17, 0.018053269)]"
78050570,78050588.0,2024-02-23 22:52:58,1,39,"<p>When cloning the <a href=""https://github.com/qbrilliance/qristal"" rel=""nofollow noreferrer"">Qristal repository</a> and trying to build the Docker image with <code>docker/Dockerfile</code>, what is an appropriate setting for <code>$QB_DIR</code> that is on line 27 of the Dockerfile:</p>
<pre><code>WORKDIR $QB_DIR
</code></pre>
",Dockerfile for Qristal: what should be the value of $QB_DIR,<quantum-computing><qristal-sdk>,1,1,,,"Dockerfile for Qristal: what should be the value of $QB_DIR <p>When cloning the <a href=""https://github.com/qbrilliance/qristal"" rel=""nofollow noreferrer"">Qristal repository</a> and trying to build the Docker image with <code>docker/Dockerfile</code>, what is an appropriate setting for <code>$QB_DIR</code> that is on line 27 of the Dockerfile:</p>
<pre><code>WORKDIR $QB_DIR
</code></pre>
",so_new,dockerfile qristal value p cloning https nofollow noreferrer qristal repository trying build docker image code appropriate setting code line 27 dockerfile pre code workdir,"[(0, 0.3523929), (4, 0.18770373), (9, 0.40507406), (17, 0.04789849)]"
36962,,2024-02-26 17:51:21,1,90,"<p>I am using Qiskit's SPSA optimization algorithm to find the ground state energy of various lattices (Fermi-Hubbard model) by running different circuits through it and having the algorithm modify the angles of the gates (these are the parameters).
My files are large and I run them on a computer cluster at my university, but the time needed for the algorithm to converge properly is more than the time allotted for my jobs so they stop prematurely. I save the most recent parameters in each iteration for use in the next run of the program.</p>
<p>Ideally, using the previous parameters should allow the converger to start where it left off in the previous run. Specifically, I pass the array into the &quot;initial_point&quot; variable in the SPSA function given <a href=""https://qiskit-community.github.io/qiskit-algorithms/stubs/qiskit_algorithms.optimizers.SPSA.html"" rel=""nofollow noreferrer"">here</a>. However, whenever I reuse these parameters, the optimizer starts from the beginning and takes the same lengthy amount of time to converge; it seems as if reusing the parameters has no effect on it. I am performing some tests to ensure that the correct parameters are being passed in but am relatively sure that this is not a problem.</p>
<p>I would appreciate advice on how to correctly implement this.</p>
",Reusing Parameters for Multiple Runs with Qiskit's SPSA Optimization,<qiskit><programming><quantum-circuit><vqe><optimization>,1,0,,,"Reusing Parameters for Multiple Runs with Qiskit's SPSA Optimization <p>I am using Qiskit's SPSA optimization algorithm to find the ground state energy of various lattices (Fermi-Hubbard model) by running different circuits through it and having the algorithm modify the angles of the gates (these are the parameters).
My files are large and I run them on a computer cluster at my university, but the time needed for the algorithm to converge properly is more than the time allotted for my jobs so they stop prematurely. I save the most recent parameters in each iteration for use in the next run of the program.</p>
<p>Ideally, using the previous parameters should allow the converger to start where it left off in the previous run. Specifically, I pass the array into the &quot;initial_point&quot; variable in the SPSA function given <a href=""https://qiskit-community.github.io/qiskit-algorithms/stubs/qiskit_algorithms.optimizers.SPSA.html"" rel=""nofollow noreferrer"">here</a>. However, whenever I reuse these parameters, the optimizer starts from the beginning and takes the same lengthy amount of time to converge; it seems as if reusing the parameters has no effect on it. I am performing some tests to ensure that the correct parameters are being passed in but am relatively sure that this is not a problem.</p>
<p>I would appreciate advice on how to correctly implement this.</p>
",qc,reusing parameters multiple runs qiskit spsa optimization p using qiskit spsa optimization algorithm find ground state energy various lattices model running different circuits algorithm modify angles gates parameters files large run computer cluster university time needed algorithm converge properly time allotted jobs stop prematurely save recent parameters iteration use next run p ideally using previous parameters allow converger start left previous run specifically pass array quot quot variable spsa function given https nofollow noreferrer however whenever reuse parameters optimizer starts beginning takes lengthy amount time converge seems reusing parameters effect performing tests ensure correct parameters passed relatively sure p would appreciate advice correctly implement,"[(1, 0.068373874), (4, 0.08113902), (7, 0.03472644), (8, 0.14884214), (9, 0.017977932), (13, 0.053558562), (14, 0.51731116), (17, 0.021660626), (19, 0.05532023)]"
37004,37008.0,2024-02-27 23:58:02,0,81,"<p>In <a href=""https://arxiv.org/pdf/1705.02329.pdf"" rel=""nofollow noreferrer"">this paper</a>, the author considers a four qubit stabilizer circuit shown below. Note that the first four qubits from the top are data qubits and can be in any state (here we just put them in <span class=""math-container"">$\vert 0000\rangle$</span>). The last qubit is the ancilla qubit used for the stabilizer measurement.</p>
<p><a href=""https://i.sstatic.net/9Itxm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9Itxm.png"" alt=""enter image description here"" /></a></p>
<p>The claim is that an error on the ancilla qubit can &quot;propagate to multiple data qubits&quot;. What does that exactly mean?</p>
<p>Concretely, suppose I have an <span class=""math-container"">$X$</span> error after the Hadamard on the ancilla qubit. Then, it appears to do nothing since the state is already in the <span class=""math-container"">$\vert +\rangle$</span> state. If I had a <span class=""math-container"">$Z$</span> error then, the ancilla gets flipped to <span class=""math-container"">$\vert -\rangle$</span> and then we apply the stabilizer measurment. How do I see this as an error on the data qubits?</p>
",Ancilla qubit error spreading to multiple data qubits?,<error-correction><quantum-circuit><stabilizer-code>,1,0,,,"Ancilla qubit error spreading to multiple data qubits? <p>In <a href=""https://arxiv.org/pdf/1705.02329.pdf"" rel=""nofollow noreferrer"">this paper</a>, the author considers a four qubit stabilizer circuit shown below. Note that the first four qubits from the top are data qubits and can be in any state (here we just put them in <span class=""math-container"">$\vert 0000\rangle$</span>). The last qubit is the ancilla qubit used for the stabilizer measurement.</p>
<p><a href=""https://i.sstatic.net/9Itxm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9Itxm.png"" alt=""enter image description here"" /></a></p>
<p>The claim is that an error on the ancilla qubit can &quot;propagate to multiple data qubits&quot;. What does that exactly mean?</p>
<p>Concretely, suppose I have an <span class=""math-container"">$X$</span> error after the Hadamard on the ancilla qubit. Then, it appears to do nothing since the state is already in the <span class=""math-container"">$\vert +\rangle$</span> state. If I had a <span class=""math-container"">$Z$</span> error then, the ancilla gets flipped to <span class=""math-container"">$\vert -\rangle$</span> and then we apply the stabilizer measurment. How do I see this as an error on the data qubits?</p>
",qc,ancilla qubit error spreading multiple data qubits p https nofollow noreferrer paper author considers four qubit stabilizer circuit shown note first four qubits top data qubits state put span last qubit ancilla qubit used stabilizer p https nofollow noreferrer img https enter image description p claim error ancilla qubit quot propagate multiple data qubits quot exactly mean p concretely suppose span x error hadamard ancilla qubit appears nothing since state already span state span z error ancilla gets flipped span apply stabilizer measurment see error data qubits,"[(4, 0.22066553), (5, 0.28771594), (9, 0.048078302), (17, 0.012593644), (18, 0.40239194), (19, 0.026948355)]"
37028,,2024-02-29 14:46:30,0,72,"<p><strong>Description:</strong> I'm currently working on a project that involves running quantum circuits as a hybrid job on the aws tensor network simulator 'tn1'.</p>
<p><strong>Error on the Cloudwatch logs:</strong><code>An error occurred while executing the quantum circuit: 'list' object has no attribute 'measure_all'</code></p>
<p><strong>how i execute circuits:</strong></p>
<pre><code>def execute_quantum_circuit(circuit, shots=1000):
try:
    backend = AWSBraketProvider().get_backend(&quot;TN1&quot;)
    circuit.measure_all()
    job = backend.run(circuit, shots=shots)
    result = job.result()
    counts = result.get_counts()

    return counts
except Exception as e:
    print(f&quot;An error occurred while executing the quantum circuit: {e}&quot;)
    return None
</code></pre>
<p><strong>how I create the the Grover oracle:</strong></p>
<pre><code>def create_grover_oracle(address, num_qubits):
try:
    qr = QuantumRegister(num_qubits)
    oracle_circuit = QuantumCircuit(qr)

    # apply hadamard gates to create a uniform superposition
    oracle_circuit.h(qr)

    # encoding the address
    for i, bit in enumerate(address):
        if bit == '1':
            oracle_circuit.x(i)

    # apply controlled-Z gates to mark the solution(s)
    ancilla = QuantumRegister(1)
    oracle_circuit.add_register(ancilla)
    oracle_circuit.h(ancilla)
    for i, bit in enumerate(address):
        if bit == '1':
            oracle_circuit.cz(i, ancilla[0])

    # multi-controlled-Z gate
    oracle_circuit.h(qr)
    oracle_circuit.mcx(qr[:-1], qr[-1])
    oracle_circuit.h(qr)

    # uncompute the encoding by applying X gates again
    for i, bit in enumerate(address):
        if bit == '1':
            oracle_circuit.x(i)

    # apply hadamard gates again to maintain superposition
    oracle_circuit.h(qr)

    return oracle_circuit
except Exception as e:
    print(f&quot;An error occurred while creating the Grover oracle: {e}&quot;)
    return None
</code></pre>
<p><strong>how I create the diffusion circuit:</strong></p>
<pre><code>def create_diffusion_circuit(num_qubits):
try:
    qr = QuantumRegister(num_qubits)
    diffusion_circuit = QuantumCircuit(qr)

    # apply hadamard gates to create a uniform superposition
    diffusion_circuit.h(qr)

    # apply X gates to prepare for multi-controlled Z gate
    diffusion_circuit.x(qr)

    # multi-controlled Z gate
    diffusion_circuit.h(qr[-1])
    diffusion_circuit.mct(qr[:-1], qr[-1])
    diffusion_circuit.h(qr[-1])

    # apply X gates again
    diffusion_circuit.x(qr)

    # apply hadamard gates again
    diffusion_circuit.h(qr)

    # optimize gate sequences in the diffusion circuit
    optimized_diffusion_circuit = optimize_gates(diffusion_circuit)

    return optimized_diffusion_circuit
</code></pre>
<p><strong>the call functions:</strong></p>
<pre><code>oracle_partition = create_grover_oracle(correct_address, num_qubits=50)
diffusion_circuit = create_diffusion_circuit(num_qubits=50)
counts = execute_quantum_circuit(oracle_partition)
execute_quantum_circuit(diffusion_circuit)
</code></pre>
<p>the optimise circuit def:</p>
<pre><code>def optimize_gates(circuit):
try:
    optimized_circuit = QuantumCircuit(circuit.num_qubits)

    # Iterate through the gates in the circuit
    i = 0
    while i &lt; len(circuit.data) - 1:
        current_gate = circuit.data[i]
        next_gate = circuit.data[i + 1]

        # Check if both gates are instances of Gate
        if isinstance(current_gate[0], Gate) and isinstance(next_gate[0], Gate):
            # Check if the gates are of the same type and act on the same qubits
            if current_gate[0].name == next_gate[0].name and current_gate[1] == next_gate[1]:
                # Combine consecutive gates into a single gate
                combined_gate = current_gate[0].compose(next_gate[0], qubits=current_gate[1])

                # Append the combined gate to the optimized circuit
                optimized_circuit.append(combined_gate, current_gate[1])

                # Move to the gate after the next gate
                i += 2
            else:
                # Append the current gate to the optimized circuit
                optimized_circuit.append(current_gate[0], current_gate[1])

                # Move to the next gate
                i += 1
        else:
            # Append the current gate to the optimized circuit
            optimized_circuit.append(current_gate[0], current_gate[1])

            # Move to the next gate
            i += 1

    # If there's one gate left after the loop, append it to the optimized circuit
    if i == len(circuit.data) - 1:
        last_gate = circuit.data[-1]
        optimized_circuit.append(last_gate[0], last_gate[1])

    return optimized_circuit
</code></pre>
<p><strong>Need assistance:</strong></p>
<p>I would appreciate any insights or guidance on how to properly <strong>measure all the qubits</strong> so i can get the measurement counts, as well as any suggestions for the implementation of grovers algorithm.</p>
<p><strong>P.S.:</strong> I previously was getting 0s in the measurement counts so i reimplemented the circuit defs</p>
",How to Correctly Measure All Qubits in a Quantum Circuit?,<measurement><quantum-circuit><grovers-algorithm><amazon-braket><measurement-based-qc>,0,6,,,"How to Correctly Measure All Qubits in a Quantum Circuit? <p><strong>Description:</strong> I'm currently working on a project that involves running quantum circuits as a hybrid job on the aws tensor network simulator 'tn1'.</p>
<p><strong>Error on the Cloudwatch logs:</strong><code>An error occurred while executing the quantum circuit: 'list' object has no attribute 'measure_all'</code></p>
<p><strong>how i execute circuits:</strong></p>
<pre><code>def execute_quantum_circuit(circuit, shots=1000):
try:
    backend = AWSBraketProvider().get_backend(&quot;TN1&quot;)
    circuit.measure_all()
    job = backend.run(circuit, shots=shots)
    result = job.result()
    counts = result.get_counts()

    return counts
except Exception as e:
    print(f&quot;An error occurred while executing the quantum circuit: {e}&quot;)
    return None
</code></pre>
<p><strong>how I create the the Grover oracle:</strong></p>
<pre><code>def create_grover_oracle(address, num_qubits):
try:
    qr = QuantumRegister(num_qubits)
    oracle_circuit = QuantumCircuit(qr)

    # apply hadamard gates to create a uniform superposition
    oracle_circuit.h(qr)

    # encoding the address
    for i, bit in enumerate(address):
        if bit == '1':
            oracle_circuit.x(i)

    # apply controlled-Z gates to mark the solution(s)
    ancilla = QuantumRegister(1)
    oracle_circuit.add_register(ancilla)
    oracle_circuit.h(ancilla)
    for i, bit in enumerate(address):
        if bit == '1':
            oracle_circuit.cz(i, ancilla[0])

    # multi-controlled-Z gate
    oracle_circuit.h(qr)
    oracle_circuit.mcx(qr[:-1], qr[-1])
    oracle_circuit.h(qr)

    # uncompute the encoding by applying X gates again
    for i, bit in enumerate(address):
        if bit == '1':
            oracle_circuit.x(i)

    # apply hadamard gates again to maintain superposition
    oracle_circuit.h(qr)

    return oracle_circuit
except Exception as e:
    print(f&quot;An error occurred while creating the Grover oracle: {e}&quot;)
    return None
</code></pre>
<p><strong>how I create the diffusion circuit:</strong></p>
<pre><code>def create_diffusion_circuit(num_qubits):
try:
    qr = QuantumRegister(num_qubits)
    diffusion_circuit = QuantumCircuit(qr)

    # apply hadamard gates to create a uniform superposition
    diffusion_circuit.h(qr)

    # apply X gates to prepare for multi-controlled Z gate
    diffusion_circuit.x(qr)

    # multi-controlled Z gate
    diffusion_circuit.h(qr[-1])
    diffusion_circuit.mct(qr[:-1], qr[-1])
    diffusion_circuit.h(qr[-1])

    # apply X gates again
    diffusion_circuit.x(qr)

    # apply hadamard gates again
    diffusion_circuit.h(qr)

    # optimize gate sequences in the diffusion circuit
    optimized_diffusion_circuit = optimize_gates(diffusion_circuit)

    return optimized_diffusion_circuit
</code></pre>
<p><strong>the call functions:</strong></p>
<pre><code>oracle_partition = create_grover_oracle(correct_address, num_qubits=50)
diffusion_circuit = create_diffusion_circuit(num_qubits=50)
counts = execute_quantum_circuit(oracle_partition)
execute_quantum_circuit(diffusion_circuit)
</code></pre>
<p>the optimise circuit def:</p>
<pre><code>def optimize_gates(circuit):
try:
    optimized_circuit = QuantumCircuit(circuit.num_qubits)

    # Iterate through the gates in the circuit
    i = 0
    while i &lt; len(circuit.data) - 1:
        current_gate = circuit.data[i]
        next_gate = circuit.data[i + 1]

        # Check if both gates are instances of Gate
        if isinstance(current_gate[0], Gate) and isinstance(next_gate[0], Gate):
            # Check if the gates are of the same type and act on the same qubits
            if current_gate[0].name == next_gate[0].name and current_gate[1] == next_gate[1]:
                # Combine consecutive gates into a single gate
                combined_gate = current_gate[0].compose(next_gate[0], qubits=current_gate[1])

                # Append the combined gate to the optimized circuit
                optimized_circuit.append(combined_gate, current_gate[1])

                # Move to the gate after the next gate
                i += 2
            else:
                # Append the current gate to the optimized circuit
                optimized_circuit.append(current_gate[0], current_gate[1])

                # Move to the next gate
                i += 1
        else:
            # Append the current gate to the optimized circuit
            optimized_circuit.append(current_gate[0], current_gate[1])

            # Move to the next gate
            i += 1

    # If there's one gate left after the loop, append it to the optimized circuit
    if i == len(circuit.data) - 1:
        last_gate = circuit.data[-1]
        optimized_circuit.append(last_gate[0], last_gate[1])

    return optimized_circuit
</code></pre>
<p><strong>Need assistance:</strong></p>
<p>I would appreciate any insights or guidance on how to properly <strong>measure all the qubits</strong> so i can get the measurement counts, as well as any suggestions for the implementation of grovers algorithm.</p>
<p><strong>P.S.:</strong> I previously was getting 0s in the measurement counts so i reimplemented the circuit defs</p>
",qc,correctly measure qubits quantum circuit p strong description currently working project involves running quantum circuits hybrid job aws tensor network simulator p strong error cloudwatch logs code error occurred executing quantum circuit object attribute p strong execute circuits pre code def circuit try backend awsbraketprovider quot tn1 quot job circuit result counts return counts except exception e print f quot error occurred executing quantum circuit e quot return none p strong create grover oracle pre code def address try qr quantumregister quantumcircuit qr apply hadamard gates create uniform superposition qr encoding address bit enumerate address bit 1 apply gates mark solution ancilla quantumregister 1 ancilla ancilla bit enumerate address bit 1 ancilla 0 gate qr qr qr qr uncompute encoding applying x gates bit enumerate address bit 1 apply hadamard gates maintain superposition qr return except exception e print f quot error occurred creating grover oracle e quot return none p strong create diffusion circuit pre code def try qr quantumregister quantumcircuit qr apply hadamard gates create uniform superposition qr apply x gates prepare z gate qr z gate qr qr qr qr apply x gates qr apply hadamard gates qr optimize gate sequences diffusion circuit return p strong call functions pre code counts p optimise circuit def pre code def circuit try quantumcircuit iterate gates circuit 0 lt len 1 1 check gates instances gate isinstance 0 gate isinstance 0 gate check gates type act qubits 0 0 1 1 combine consecutive gates single gate 0 0 1 append combined gate optimized circuit 1 move gate next gate 2 else append current gate optimized circuit 0 1 move next gate 1 else append current gate optimized circuit 0 1 move next gate 1 one gate left loop append optimized circuit len 1 0 1 return p strong need assistance p would appreciate insights guidance properly strong measure qubits get measurement counts well suggestions implementation grovers p strong previously getting 0s measurement counts reimplemented circuit defs,"[(0, 0.27068084), (2, 0.08813588), (10, 0.017955186), (14, 0.36864087), (17, 0.015866699), (18, 0.19964316), (19, 0.034176946)]"
37062,,2024-03-03 14:40:17,2,107,"<p>I am trying to implement a bp+osd decoder, using the build-in python package from here: <a href=""https://github.com/quantumgizmos/bp_osd"" rel=""nofollow noreferrer"">https://github.com/quantumgizmos/bp_osd</a></p>
<p>One of the parameters for the decoder is &quot;channel_probs&quot;, where one assigns an error probability for each qubit.
In the case of an iid Pauli noise, all probabilities can be chosen to be uniform with the value, of, say, 0.05.
On the other hand, when one considers an iid loss noise, all lost qubits (which assumed to be heralded in measurement) are given an error probability 1, and the rest are 0.</p>
<p>My question is, what do you do if you have both errors? Assigning 1 to all lost qubits and 0.05 to the rest of them doesn't seems to work.  Note that in pymatching, for example, you can also assign a &quot;weight&quot;, and there each lost qubit is weighted 0 whereas all other qubits are weighted 1 (in the simplest case), and the decoder works just fine.</p>
",BP + OSD decoder with both loss and Pauli errors,<error-correction><simulation><noise>,1,2,,,"BP + OSD decoder with both loss and Pauli errors <p>I am trying to implement a bp+osd decoder, using the build-in python package from here: <a href=""https://github.com/quantumgizmos/bp_osd"" rel=""nofollow noreferrer"">https://github.com/quantumgizmos/bp_osd</a></p>
<p>One of the parameters for the decoder is &quot;channel_probs&quot;, where one assigns an error probability for each qubit.
In the case of an iid Pauli noise, all probabilities can be chosen to be uniform with the value, of, say, 0.05.
On the other hand, when one considers an iid loss noise, all lost qubits (which assumed to be heralded in measurement) are given an error probability 1, and the rest are 0.</p>
<p>My question is, what do you do if you have both errors? Assigning 1 to all lost qubits and 0.05 to the rest of them doesn't seems to work.  Note that in pymatching, for example, you can also assign a &quot;weight&quot;, and there each lost qubit is weighted 0 whereas all other qubits are weighted 1 (in the simplest case), and the decoder works just fine.</p>
",qc,bp osd decoder loss pauli errors p trying implement decoder using python package https nofollow noreferrer https p one parameters decoder quot quot one assigns error probability qubit case iid pauli noise probabilities chosen uniform value say hand one considers iid loss noise lost qubits assumed heralded measurement given error probability 1 rest p question errors assigning 1 lost qubits rest seems work note pymatching example also assign quot weight quot lost qubit weighted 0 whereas qubits weighted 1 simplest case decoder works,"[(2, 0.04419004), (3, 0.14646584), (4, 0.07371085), (5, 0.31305814), (8, 0.09788854), (17, 0.046070185), (18, 0.15152733), (19, 0.12560679)]"
37079,,2024-03-04 16:28:14,1,104,"<p>I was plotting the matching graph from the quantum memory experiment (<code>surface_code:rotated_memory_x</code>) with the circuit diagram command from stim, <code>circuit.diagram('matchgraph-3d')</code>.</p>
<p>I noticed there are diagonal edges in the time direction. Can anyone explain this? I don't understand the purpose of these diagonal edges.</p>
<p><a href=""https://i.sstatic.net/4JtAF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4JtAF.png"" alt=""enter image description here"" /></a>Cheers!</p>
","Matching graph from ""surface_code:rotated_memory_x"" diagonal edges in time?",<stim>,1,0,,,"Matching graph from ""surface_code:rotated_memory_x"" diagonal edges in time? <p>I was plotting the matching graph from the quantum memory experiment (<code>surface_code:rotated_memory_x</code>) with the circuit diagram command from stim, <code>circuit.diagram('matchgraph-3d')</code>.</p>
<p>I noticed there are diagonal edges in the time direction. Can anyone explain this? I don't understand the purpose of these diagonal edges.</p>
<p><a href=""https://i.sstatic.net/4JtAF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4JtAF.png"" alt=""enter image description here"" /></a>Cheers!</p>
",qc,matching graph diagonal edges time p plotting matching graph quantum memory experiment code circuit diagram command stim code p noticed diagonal edges time direction anyone explain understand purpose diagonal p https nofollow noreferrer img https enter image description cheers,"[(4, 0.36061332), (9, 0.097239), (13, 0.21878062), (14, 0.265691), (17, 0.053847905)]"
37084,37086.0,2024-03-04 22:18:03,1,69,"<p>I'm trying to implement the <span class=""math-container"">$[\![7,1,3]\!]$</span> Steane code on <code>Stim</code>. My circuit is below:</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit('''
    R 0 1 2 3 4 5 6 7 8 9 10 11 12
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6

    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]
                           
    X_ERROR(1) 0
                           
    REPEAT 3 {
        MPP X0*X2*X4*X6
        MPP X3*X4*X5*X6
        MPP X1*X2*X5*X6
        
        MPP Z0*Z2*Z4*Z6
        MPP Z3*Z4*Z5*Z6
        MPP Z1*Z2*Z5*Z6
                                            
        .
        .  
        '''  
    }
</code></pre>
<p>The idea is that the first part puts my qubits into a logical state by measuring the <span class=""math-container"">$X$</span> stabilizers. I need to do two things.</p>
<ol>
<li><p>Keep the outcomes of the first three MPPs somewhere since these eigenvalues define my logical <span class=""math-container"">$\vert 0\rangle$</span>.</p>
</li>
<li><p>I want to implement a correction based on the stabilizer eigenvalues in the <code>REPEAT</code> section. If all of <code>MPP X0 X2 X4 X6</code>, <code>MPP X3 X4 X5 X6</code> and <code>MPP X1 X2 X5 X6</code> disagree with the answers in 1., then I have a <span class=""math-container"">$Z$</span> error on qubit <span class=""math-container"">$6$</span>. I want to implement a controlled <span class=""math-container"">$Z$</span> gate on qubit <span class=""math-container"">$6$</span> with the control being decided by the aforementioned logic.</p>
</li>
</ol>
<p>What's the best way to do this?</p>
<p>EDIT: Updated circuit based on Craig Gidney's answer.</p>
<pre><code>circuit = stim.Circuit('''
R 0 1 2 3 4 5 6 7 8 9 10 11 12

MPP X0*X2*X4*X6
MPP X3*X4*X5*X6
MPP X1*X2*X5*X6

MPP Z0*Z2*Z4*Z6
MPP Z3*Z4*Z5*Z6
MPP Z1*Z2*Z5*Z6
                       
X_ERROR(1) 0
                       
REPEAT 2 {
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    
    MPP Z0*Z2*Z4*Z6
    MPP Z3*Z4*Z5*Z6
    MPP Z1*Z2*Z5*Z6
                                        
    DETECTOR rec[-6] rec[-12]
    DETECTOR rec[-5] rec[-11]
    DETECTOR rec[-4] rec[-10]
    DETECTOR rec[-3] rec[-9]                                      
    DETECTOR rec[-2] rec[-8]
    DETECTOR rec[-1] rec[-7]
}
''')                                            
</code></pre>
<p>Indeed, I only get one <code>True</code> on the stabilizer <span class=""math-container"">$Z0Z2Z4Z6$</span> in the first round as that's where the error is.</p>
",How to implement a controlled gate in Stim with the following control logic?,<error-correction><stim>,1,0,,,"How to implement a controlled gate in Stim with the following control logic? <p>I'm trying to implement the <span class=""math-container"">$[\![7,1,3]\!]$</span> Steane code on <code>Stim</code>. My circuit is below:</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit('''
    R 0 1 2 3 4 5 6 7 8 9 10 11 12
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6

    DETECTOR rec[-3]
    DETECTOR rec[-2]
    DETECTOR rec[-1]
                           
    X_ERROR(1) 0
                           
    REPEAT 3 {
        MPP X0*X2*X4*X6
        MPP X3*X4*X5*X6
        MPP X1*X2*X5*X6
        
        MPP Z0*Z2*Z4*Z6
        MPP Z3*Z4*Z5*Z6
        MPP Z1*Z2*Z5*Z6
                                            
        .
        .  
        '''  
    }
</code></pre>
<p>The idea is that the first part puts my qubits into a logical state by measuring the <span class=""math-container"">$X$</span> stabilizers. I need to do two things.</p>
<ol>
<li><p>Keep the outcomes of the first three MPPs somewhere since these eigenvalues define my logical <span class=""math-container"">$\vert 0\rangle$</span>.</p>
</li>
<li><p>I want to implement a correction based on the stabilizer eigenvalues in the <code>REPEAT</code> section. If all of <code>MPP X0 X2 X4 X6</code>, <code>MPP X3 X4 X5 X6</code> and <code>MPP X1 X2 X5 X6</code> disagree with the answers in 1., then I have a <span class=""math-container"">$Z$</span> error on qubit <span class=""math-container"">$6$</span>. I want to implement a controlled <span class=""math-container"">$Z$</span> gate on qubit <span class=""math-container"">$6$</span> with the control being decided by the aforementioned logic.</p>
</li>
</ol>
<p>What's the best way to do this?</p>
<p>EDIT: Updated circuit based on Craig Gidney's answer.</p>
<pre><code>circuit = stim.Circuit('''
R 0 1 2 3 4 5 6 7 8 9 10 11 12

MPP X0*X2*X4*X6
MPP X3*X4*X5*X6
MPP X1*X2*X5*X6

MPP Z0*Z2*Z4*Z6
MPP Z3*Z4*Z5*Z6
MPP Z1*Z2*Z5*Z6
                       
X_ERROR(1) 0
                       
REPEAT 2 {
    MPP X0*X2*X4*X6
    MPP X3*X4*X5*X6
    MPP X1*X2*X5*X6
    
    MPP Z0*Z2*Z4*Z6
    MPP Z3*Z4*Z5*Z6
    MPP Z1*Z2*Z5*Z6
                                        
    DETECTOR rec[-6] rec[-12]
    DETECTOR rec[-5] rec[-11]
    DETECTOR rec[-4] rec[-10]
    DETECTOR rec[-3] rec[-9]                                      
    DETECTOR rec[-2] rec[-8]
    DETECTOR rec[-1] rec[-7]
}
''')                                            
</code></pre>
<p>Indeed, I only get one <code>True</code> on the stabilizer <span class=""math-container"">$Z0Z2Z4Z6$</span> in the first round as that's where the error is.</p>
",qc,implement controlled gate stim following control logic p trying implement span steane code code stim circuit pre code circuit r 0 1 2 3 4 5 6 7 8 9 10 11 12 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 detector rec detector rec detector rec 1 0 repeat 3 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp z0 z2 z4 z6 mpp z3 z4 z5 z6 mpp z1 z2 z5 z6 p idea first part puts qubits logical state measuring span x stabilizers need two ol li p keep outcomes first three mpps somewhere since eigenvalues define logical span li p want implement correction based stabilizer eigenvalues code repeat section code mpp x0 x2 x4 x6 code mpp x3 x4 x5 x6 code mpp x1 x2 x5 x6 disagree answers span z error qubit span 6 want implement controlled span z gate qubit span 6 control decided aforementioned p best way p edit updated circuit based craig gidney pre code circuit r 0 1 2 3 4 5 6 7 8 9 10 11 12 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp z0 z2 z4 z6 mpp z3 z4 z5 z6 mpp z1 z2 z5 z6 1 0 repeat 2 mpp x0 x2 x4 x6 mpp x3 x4 x5 x6 mpp x1 x2 x5 x6 mpp z0 z2 z4 z6 mpp z3 z4 z5 z6 mpp z1 z2 z5 z6 detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec detector rec rec p indeed get one code true stabilizer span z0z2z4z6 first round error,"[(3, 0.042973883), (5, 0.10318422), (6, 0.41236302), (12, 0.19291776), (14, 0.071446456), (17, 0.093595915), (18, 0.08305952)]"
37119,,2024-03-06 15:48:35,1,13,"<p>When there are multiple samples corresponding to the same (minimum) energy and with the same probability, how does qiskit pick the final result?</p>
<p>In my experiments, if I check all samples, I can see there are 32 states all having the minimum energy and the same probability,
<a href=""https://i.sstatic.net/czGeD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/czGeD.png"" alt=""enter image description here"" /></a></p>
<p>And the QAOA solver will output results like this, which seems it picks the first one as the final result.</p>
<p><a href=""https://i.sstatic.net/Slp8X.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Slp8X.png"" alt=""enter image description here"" /></a></p>
<p>The question is, how is this order decided? and why qiskit chooses the first one as the final result, even other samples have the same energy and probability?</p>
",How does QAOA choose its result from samples when there are degenerate states,<qiskit><quantum-algorithms>,0,1,,,"How does QAOA choose its result from samples when there are degenerate states <p>When there are multiple samples corresponding to the same (minimum) energy and with the same probability, how does qiskit pick the final result?</p>
<p>In my experiments, if I check all samples, I can see there are 32 states all having the minimum energy and the same probability,
<a href=""https://i.sstatic.net/czGeD.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/czGeD.png"" alt=""enter image description here"" /></a></p>
<p>And the QAOA solver will output results like this, which seems it picks the first one as the final result.</p>
<p><a href=""https://i.sstatic.net/Slp8X.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Slp8X.png"" alt=""enter image description here"" /></a></p>
<p>The question is, how is this order decided? and why qiskit chooses the first one as the final result, even other samples have the same energy and probability?</p>
",qc,qaoa choose result samples degenerate states p multiple samples corresponding minimum energy probability qiskit pick final result p experiments check samples see 32 states minimum energy probability https nofollow noreferrer img https enter image description p qaoa solver output results like seems picks first one final p https nofollow noreferrer img https enter image description p question order decided qiskit chooses first one final result even samples energy probability,"[(4, 0.4321644), (8, 0.17983858), (11, 0.047352463), (13, 0.04893862), (14, 0.11139885), (17, 0.048023574), (18, 0.13040149)]"
37137,,2024-03-07 12:07:04,1,81,"<p>Re: a recent paper on the arXiv, Correlated decoding of logical algorithms with transversal gates (<a href=""https://arxiv.org/abs/2403.03272"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2403.03272</a>). As MWPM (pymatching and stim) cannot handle errors that flip more than two checks, are there any other ways of doing the transversal cnot decoding via modifying the decoding in a clever manner? I found an old paper that alludes to some kind of correlated decoding without the need for hypergraphs (<a href=""https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.2.020341"" rel=""nofollow noreferrer"">https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.2.020341</a>, citation 104 and 113). Can anyone advice on this? Thanks<img src=""https://i.sstatic.net/hy1NS.png"" alt=""enter image description here"" /></p>
",Transversal CNOT implementation on stim,<quantum-gate><error-correction><stim>,0,0,,,"Transversal CNOT implementation on stim <p>Re: a recent paper on the arXiv, Correlated decoding of logical algorithms with transversal gates (<a href=""https://arxiv.org/abs/2403.03272"" rel=""nofollow noreferrer"">https://arxiv.org/abs/2403.03272</a>). As MWPM (pymatching and stim) cannot handle errors that flip more than two checks, are there any other ways of doing the transversal cnot decoding via modifying the decoding in a clever manner? I found an old paper that alludes to some kind of correlated decoding without the need for hypergraphs (<a href=""https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.2.020341"" rel=""nofollow noreferrer"">https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.2.020341</a>, citation 104 and 113). Can anyone advice on this? Thanks<img src=""https://i.sstatic.net/hy1NS.png"" alt=""enter image description here"" /></p>
",qc,transversal cnot implementation stim p recent paper arxiv correlated decoding logical algorithms transversal gates https nofollow noreferrer https mwpm pymatching stim handle errors flip two checks ways transversal cnot decoding via modifying decoding clever manner found old paper alludes kind correlated decoding without need hypergraphs https nofollow noreferrer https citation 104 113 anyone advice thanks img https enter image description,"[(4, 0.29243362), (5, 0.31493938), (7, 0.042821012), (8, 0.21412885), (9, 0.097564325), (17, 0.017216926), (19, 0.018657677)]"
37180,,2024-03-10 10:10:35,1,144,"<p><span class=""math-container"">$\newcommand{\ket}[1]{|#1\rangle}$</span></p>
<p>I have the following quantum circuit:</p>
<p><a href=""https://i.sstatic.net/Qdwbt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qdwbt.png"" alt=""quantum circuit"" /></a></p>
<p>(The inner qubits are both initialized to <span class=""math-container"">$|i\rangle$</span>. <span class=""math-container"">$U$</span> is a arbitrary quantum gate.)</p>
<p>But I am only interested in the outcome of the qubits <span class=""math-container"">$q_0$</span> and <span class=""math-container"">$q_3$</span>.
<strong>Is there a way to reduce this circuit to only 2 qubits?</strong></p>
<p>My first idea was to replace all 2-qubit gates by single qubit operations and once &quot;isolated&quot; remove the inner 2 qubits.
The paper <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/abd7bc"" rel=""nofollow noreferrer"">Constructing a virtual two-qubit gate by sampling single-qubit operations</a> describes a strategy to decompose a two-qubit gate to a sequence of single-qubit operations (with sampling overhead), which leads me to believe that this circuit can be reduced to only 2 qubits.</p>
<p>Does my apprach make sense? Is there a general way to get rid of ancilla qubits?</p>
<hr />
<h3>Edit</h3>
<p><em>Since my question lacked clarity, I now provide my calculation to be more specific in what I want.</em></p>
<p>For my own convenience I reordered the qubits according to the circuit below:</p>
<p><a href=""https://i.sstatic.net/YqYx8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YqYx8.png"" alt=""quantum circuit"" /></a></p>
<p>The <span class=""math-container"">$U$</span> gate is an arbitrary unitary <span class=""math-container"">$U=\left[\begin{matrix}u_{0} &amp; u_{1}\\u_{2} &amp; u_{3}\end{matrix}\right]$</span>.
I represent the combined state of <span class=""math-container"">$q_3$</span> and <span class=""math-container"">$q_0$</span> as <span class=""math-container"">$a\ket{00} + b\ket{01} + c\ket{10} + d\ket{11} =\left[\begin{matrix}a\\b\\c\\d\end{matrix}\right]$</span>, which results in the overall initial state <span class=""math-container"">$\ket{\psi}=\ket{ii}\otimes\left[\begin{matrix}a\\b\\c\\d\end{matrix}\right]$</span>.</p>
<p>I use sympy to calculate the circuit <span class=""math-container"">$C_{2}{\left(Z_{1}\right)} H_{2} C_{2}{\left(U_{0}\right)} \text{CNOT}_{3,2} \text{CNOT}_{1,3}\ket{\psi}$</span></p>
<pre class=""lang-python prettyprint-override""><code>from sympy import *
from sympy.physics.quantum.tensorproduct import TensorProduct
from sympy.physics.quantum.gate import Z, H
from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator

# define variables
a, b, c, d = var('a b c d', complex=True)
u0, u1, u2, u3 = var('u0 u1 u2 u3', complex=True)
u = Matrix([[u0, u1], [u2, u3]])
cx = Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
cz = Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]])

# define state &amp; its density matrix
state = TensorProduct(Matrix([1, I]) / sqrt(2), Matrix([1, I]) / sqrt(2), Matrix([a, b, c, d]))
state_d = state * state.H
# CNOT(q_3, i_0)
op_qc = QuantumCircuit(4)
op_qc.cx(1, 3)
op = Matrix(Operator(op_qc))
t = simplify(op * state_d * op.H)
# CNOT(i_0, i_1)
op = TensorProduct(cx, eye(4))
t = simplify(op * t * op.H)
# CU(i_1, q_0)
op = TensorProduct(eye(2), eye(2), eye(2), eye(2)) / 2 \
    + TensorProduct(eye(2), Z().get_target_matrix(), eye(2), eye(2)) / 2 \
    + TensorProduct(eye(2), eye(2), eye(2), u) / 2 \
    - TensorProduct(eye(2), Z().get_target_matrix(), eye(2), u) / 2
t = simplify(op * t * op.H)
# H(i_1)
op = TensorProduct(eye(2), H().get_target_matrix(), eye(4))
t = simplify(op * t * op.H)
# CZ(i_1, q_3)
op = TensorProduct(eye(2), cz, eye(2))
t = simplify(op * t * op.H)
# trace out qubits i_0 and i_1
r = TensorProduct(Matrix([1, 0, 0, 0]).H, eye(4)) * t * TensorProduct(Matrix([1, 0, 0, 0]), eye(4)) + \
    TensorProduct(Matrix([0, 1, 0, 0]).H, eye(4)) * t * TensorProduct(Matrix([0, 1, 0, 0]), eye(4)) + \
    TensorProduct(Matrix([0, 0, 1, 0]).H, eye(4)) * t * TensorProduct(Matrix([0, 0, 1, 0]), eye(4)) + \
    TensorProduct(Matrix([0, 0, 0, 1]).H, eye(4)) * t * TensorProduct(Matrix([0, 0, 0, 1]), eye(4))
r = simplify(r)
</code></pre>
<p>The resulting density matrix for <span class=""math-container"">$q_3$</span> and <span class=""math-container"">$q_0$</span> is:</p>
<p><span class=""math-container"">$\left[\begin{matrix}0.5 a u_{0} \overline{a} \overline{u_{0}} + 0.5 a u_{0} \overline{b} \overline{u_{1}} + 0.5 a \overline{a} + 0.5 b u_{1} \overline{a} \overline{u_{0}} + 0.5 b u_{1} \overline{b} \overline{u_{1}} &amp; 0.5 a u_{0} \overline{a} \overline{u_{2}} + 0.5 a u_{0} \overline{b} \overline{u_{3}} + 0.5 a \overline{b} + 0.5 b u_{1} \overline{a} \overline{u_{2}} + 0.5 b u_{1} \overline{b} \overline{u_{3}} &amp; 0.5 a u_{0} \overline{c} - 0.5 a \overline{c} \overline{u_{0}} - 0.5 a \overline{d} \overline{u_{1}} + 0.5 b u_{1} \overline{c} &amp; 0.5 a u_{0} \overline{d} - 0.5 a \overline{c} \overline{u_{2}} - 0.5 a \overline{d} \overline{u_{3}} + 0.5 b u_{1} \overline{d}\\0.5 a u_{2} \overline{a} \overline{u_{0}} + 0.5 a u_{2} \overline{b} \overline{u_{1}} + 0.5 b u_{3} \overline{a} \overline{u_{0}} + 0.5 b u_{3} \overline{b} \overline{u_{1}} + 0.5 b \overline{a} &amp; 0.5 a u_{2} \overline{a} \overline{u_{2}} + 0.5 a u_{2} \overline{b} \overline{u_{3}} + 0.5 b u_{3} \overline{a} \overline{u_{2}} + 0.5 b u_{3} \overline{b} \overline{u_{3}} + 0.5 b \overline{b} &amp; 0.5 a u_{2} \overline{c} + 0.5 b u_{3} \overline{c} - 0.5 b \overline{c} \overline{u_{0}} - 0.5 b \overline{d} \overline{u_{1}} &amp; 0.5 a u_{2} \overline{d} + 0.5 b u_{3} \overline{d} - 0.5 b \overline{c} \overline{u_{2}} - 0.5 b \overline{d} \overline{u_{3}}\\- 0.5 c u_{0} \overline{a} + 0.5 c \overline{a} \overline{u_{0}} + 0.5 c \overline{b} \overline{u_{1}} - 0.5 d u_{1} \overline{a} &amp; - 0.5 c u_{0} \overline{b} + 0.5 c \overline{a} \overline{u_{2}} + 0.5 c \overline{b} \overline{u_{3}} - 0.5 d u_{1} \overline{b} &amp; 0.5 c u_{0} \overline{c} \overline{u_{0}} + 0.5 c u_{0} \overline{d} \overline{u_{1}} + 0.5 c \overline{c} + 0.5 d u_{1} \overline{c} \overline{u_{0}} + 0.5 d u_{1} \overline{d} \overline{u_{1}} &amp; 0.5 c u_{0} \overline{c} \overline{u_{2}} + 0.5 c u_{0} \overline{d} \overline{u_{3}} + 0.5 c \overline{d} + 0.5 d u_{1} \overline{c} \overline{u_{2}} + 0.5 d u_{1} \overline{d} \overline{u_{3}}\\- 0.5 c u_{2} \overline{a} - 0.5 d u_{3} \overline{a} + 0.5 d \overline{a} \overline{u_{0}} + 0.5 d \overline{b} \overline{u_{1}} &amp; - 0.5 c u_{2} \overline{b} - 0.5 d u_{3} \overline{b} + 0.5 d \overline{a} \overline{u_{2}} + 0.5 d \overline{b} \overline{u_{3}} &amp; 0.5 c u_{2} \overline{c} \overline{u_{0}} + 0.5 c u_{2} \overline{d} \overline{u_{1}} + 0.5 d u_{3} \overline{c} \overline{u_{0}} + 0.5 d u_{3} \overline{d} \overline{u_{1}} + 0.5 d \overline{c} &amp; 0.5 c u_{2} \overline{c} \overline{u_{2}} + 0.5 c u_{2} \overline{d} \overline{u_{3}} + 0.5 d u_{3} \overline{c} \overline{u_{2}} + 0.5 d u_{3} \overline{d} \overline{u_{3}} + 0.5 d \overline{d}\end{matrix}\right]$</span></p>
<hr />
<p>And here is my calculation for the circuit suggested in the comments:</p>
<p><a href=""https://i.sstatic.net/VCTwv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VCTwv.png"" alt=""quantum circuit"" /></a></p>
<pre class=""lang-python prettyprint-override""><code>from sympy import *
from sympy.physics.quantum.tensorproduct import TensorProduct
from sympy.physics.quantum.gate import Z

a, b, c, d = var('a b c d', complex=True)
u0, u1, u2, u3 = var('u0 u1 u2 u3', complex=True)
cu = Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, u0, u1], [0, 0, u2, u3]])

# define state &amp; its density matrix
state = Matrix([[a], [b], [c], [d]])
state_d = state * state.H
# CU(q_3, q_0)
t = simplify(cu * state_d * cu.H)
# Z(q_3)
op = TensorProduct(Z().get_target_matrix(), eye(2))
r = simplify(op * t * op)
</code></pre>
<p>Result:</p>
<p><span class=""math-container"">$\left[\begin{matrix}a \overline{a} &amp; a \overline{b} &amp; - a \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; - a \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\\b \overline{a} &amp; b \overline{b} &amp; - b \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; - b \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\\- \left(c u_{0} + d u_{1}\right) \overline{a} &amp; - \left(c u_{0} + d u_{1}\right) \overline{b} &amp; \left(c u_{0} + d u_{1}\right) \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; \left(c u_{0} + d u_{1}\right) \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\\- \left(c u_{2} + d u_{3}\right) \overline{a} &amp; - \left(c u_{2} + d u_{3}\right) \overline{b} &amp; \left(c u_{2} + d u_{3}\right) \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; \left(c u_{2} + d u_{3}\right) \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\end{matrix}\right]$</span></p>
",How to find an equivalent circuit without ancilla qubits?,<circuit-construction><quantum-circuit><gate-synthesis>,2,5,,,"How to find an equivalent circuit without ancilla qubits? <p><span class=""math-container"">$\newcommand{\ket}[1]{|#1\rangle}$</span></p>
<p>I have the following quantum circuit:</p>
<p><a href=""https://i.sstatic.net/Qdwbt.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/Qdwbt.png"" alt=""quantum circuit"" /></a></p>
<p>(The inner qubits are both initialized to <span class=""math-container"">$|i\rangle$</span>. <span class=""math-container"">$U$</span> is a arbitrary quantum gate.)</p>
<p>But I am only interested in the outcome of the qubits <span class=""math-container"">$q_0$</span> and <span class=""math-container"">$q_3$</span>.
<strong>Is there a way to reduce this circuit to only 2 qubits?</strong></p>
<p>My first idea was to replace all 2-qubit gates by single qubit operations and once &quot;isolated&quot; remove the inner 2 qubits.
The paper <a href=""https://iopscience.iop.org/article/10.1088/1367-2630/abd7bc"" rel=""nofollow noreferrer"">Constructing a virtual two-qubit gate by sampling single-qubit operations</a> describes a strategy to decompose a two-qubit gate to a sequence of single-qubit operations (with sampling overhead), which leads me to believe that this circuit can be reduced to only 2 qubits.</p>
<p>Does my apprach make sense? Is there a general way to get rid of ancilla qubits?</p>
<hr />
<h3>Edit</h3>
<p><em>Since my question lacked clarity, I now provide my calculation to be more specific in what I want.</em></p>
<p>For my own convenience I reordered the qubits according to the circuit below:</p>
<p><a href=""https://i.sstatic.net/YqYx8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/YqYx8.png"" alt=""quantum circuit"" /></a></p>
<p>The <span class=""math-container"">$U$</span> gate is an arbitrary unitary <span class=""math-container"">$U=\left[\begin{matrix}u_{0} &amp; u_{1}\\u_{2} &amp; u_{3}\end{matrix}\right]$</span>.
I represent the combined state of <span class=""math-container"">$q_3$</span> and <span class=""math-container"">$q_0$</span> as <span class=""math-container"">$a\ket{00} + b\ket{01} + c\ket{10} + d\ket{11} =\left[\begin{matrix}a\\b\\c\\d\end{matrix}\right]$</span>, which results in the overall initial state <span class=""math-container"">$\ket{\psi}=\ket{ii}\otimes\left[\begin{matrix}a\\b\\c\\d\end{matrix}\right]$</span>.</p>
<p>I use sympy to calculate the circuit <span class=""math-container"">$C_{2}{\left(Z_{1}\right)} H_{2} C_{2}{\left(U_{0}\right)} \text{CNOT}_{3,2} \text{CNOT}_{1,3}\ket{\psi}$</span></p>
<pre class=""lang-python prettyprint-override""><code>from sympy import *
from sympy.physics.quantum.tensorproduct import TensorProduct
from sympy.physics.quantum.gate import Z, H
from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator

# define variables
a, b, c, d = var('a b c d', complex=True)
u0, u1, u2, u3 = var('u0 u1 u2 u3', complex=True)
u = Matrix([[u0, u1], [u2, u3]])
cx = Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
cz = Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]])

# define state &amp; its density matrix
state = TensorProduct(Matrix([1, I]) / sqrt(2), Matrix([1, I]) / sqrt(2), Matrix([a, b, c, d]))
state_d = state * state.H
# CNOT(q_3, i_0)
op_qc = QuantumCircuit(4)
op_qc.cx(1, 3)
op = Matrix(Operator(op_qc))
t = simplify(op * state_d * op.H)
# CNOT(i_0, i_1)
op = TensorProduct(cx, eye(4))
t = simplify(op * t * op.H)
# CU(i_1, q_0)
op = TensorProduct(eye(2), eye(2), eye(2), eye(2)) / 2 \
    + TensorProduct(eye(2), Z().get_target_matrix(), eye(2), eye(2)) / 2 \
    + TensorProduct(eye(2), eye(2), eye(2), u) / 2 \
    - TensorProduct(eye(2), Z().get_target_matrix(), eye(2), u) / 2
t = simplify(op * t * op.H)
# H(i_1)
op = TensorProduct(eye(2), H().get_target_matrix(), eye(4))
t = simplify(op * t * op.H)
# CZ(i_1, q_3)
op = TensorProduct(eye(2), cz, eye(2))
t = simplify(op * t * op.H)
# trace out qubits i_0 and i_1
r = TensorProduct(Matrix([1, 0, 0, 0]).H, eye(4)) * t * TensorProduct(Matrix([1, 0, 0, 0]), eye(4)) + \
    TensorProduct(Matrix([0, 1, 0, 0]).H, eye(4)) * t * TensorProduct(Matrix([0, 1, 0, 0]), eye(4)) + \
    TensorProduct(Matrix([0, 0, 1, 0]).H, eye(4)) * t * TensorProduct(Matrix([0, 0, 1, 0]), eye(4)) + \
    TensorProduct(Matrix([0, 0, 0, 1]).H, eye(4)) * t * TensorProduct(Matrix([0, 0, 0, 1]), eye(4))
r = simplify(r)
</code></pre>
<p>The resulting density matrix for <span class=""math-container"">$q_3$</span> and <span class=""math-container"">$q_0$</span> is:</p>
<p><span class=""math-container"">$\left[\begin{matrix}0.5 a u_{0} \overline{a} \overline{u_{0}} + 0.5 a u_{0} \overline{b} \overline{u_{1}} + 0.5 a \overline{a} + 0.5 b u_{1} \overline{a} \overline{u_{0}} + 0.5 b u_{1} \overline{b} \overline{u_{1}} &amp; 0.5 a u_{0} \overline{a} \overline{u_{2}} + 0.5 a u_{0} \overline{b} \overline{u_{3}} + 0.5 a \overline{b} + 0.5 b u_{1} \overline{a} \overline{u_{2}} + 0.5 b u_{1} \overline{b} \overline{u_{3}} &amp; 0.5 a u_{0} \overline{c} - 0.5 a \overline{c} \overline{u_{0}} - 0.5 a \overline{d} \overline{u_{1}} + 0.5 b u_{1} \overline{c} &amp; 0.5 a u_{0} \overline{d} - 0.5 a \overline{c} \overline{u_{2}} - 0.5 a \overline{d} \overline{u_{3}} + 0.5 b u_{1} \overline{d}\\0.5 a u_{2} \overline{a} \overline{u_{0}} + 0.5 a u_{2} \overline{b} \overline{u_{1}} + 0.5 b u_{3} \overline{a} \overline{u_{0}} + 0.5 b u_{3} \overline{b} \overline{u_{1}} + 0.5 b \overline{a} &amp; 0.5 a u_{2} \overline{a} \overline{u_{2}} + 0.5 a u_{2} \overline{b} \overline{u_{3}} + 0.5 b u_{3} \overline{a} \overline{u_{2}} + 0.5 b u_{3} \overline{b} \overline{u_{3}} + 0.5 b \overline{b} &amp; 0.5 a u_{2} \overline{c} + 0.5 b u_{3} \overline{c} - 0.5 b \overline{c} \overline{u_{0}} - 0.5 b \overline{d} \overline{u_{1}} &amp; 0.5 a u_{2} \overline{d} + 0.5 b u_{3} \overline{d} - 0.5 b \overline{c} \overline{u_{2}} - 0.5 b \overline{d} \overline{u_{3}}\\- 0.5 c u_{0} \overline{a} + 0.5 c \overline{a} \overline{u_{0}} + 0.5 c \overline{b} \overline{u_{1}} - 0.5 d u_{1} \overline{a} &amp; - 0.5 c u_{0} \overline{b} + 0.5 c \overline{a} \overline{u_{2}} + 0.5 c \overline{b} \overline{u_{3}} - 0.5 d u_{1} \overline{b} &amp; 0.5 c u_{0} \overline{c} \overline{u_{0}} + 0.5 c u_{0} \overline{d} \overline{u_{1}} + 0.5 c \overline{c} + 0.5 d u_{1} \overline{c} \overline{u_{0}} + 0.5 d u_{1} \overline{d} \overline{u_{1}} &amp; 0.5 c u_{0} \overline{c} \overline{u_{2}} + 0.5 c u_{0} \overline{d} \overline{u_{3}} + 0.5 c \overline{d} + 0.5 d u_{1} \overline{c} \overline{u_{2}} + 0.5 d u_{1} \overline{d} \overline{u_{3}}\\- 0.5 c u_{2} \overline{a} - 0.5 d u_{3} \overline{a} + 0.5 d \overline{a} \overline{u_{0}} + 0.5 d \overline{b} \overline{u_{1}} &amp; - 0.5 c u_{2} \overline{b} - 0.5 d u_{3} \overline{b} + 0.5 d \overline{a} \overline{u_{2}} + 0.5 d \overline{b} \overline{u_{3}} &amp; 0.5 c u_{2} \overline{c} \overline{u_{0}} + 0.5 c u_{2} \overline{d} \overline{u_{1}} + 0.5 d u_{3} \overline{c} \overline{u_{0}} + 0.5 d u_{3} \overline{d} \overline{u_{1}} + 0.5 d \overline{c} &amp; 0.5 c u_{2} \overline{c} \overline{u_{2}} + 0.5 c u_{2} \overline{d} \overline{u_{3}} + 0.5 d u_{3} \overline{c} \overline{u_{2}} + 0.5 d u_{3} \overline{d} \overline{u_{3}} + 0.5 d \overline{d}\end{matrix}\right]$</span></p>
<hr />
<p>And here is my calculation for the circuit suggested in the comments:</p>
<p><a href=""https://i.sstatic.net/VCTwv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VCTwv.png"" alt=""quantum circuit"" /></a></p>
<pre class=""lang-python prettyprint-override""><code>from sympy import *
from sympy.physics.quantum.tensorproduct import TensorProduct
from sympy.physics.quantum.gate import Z

a, b, c, d = var('a b c d', complex=True)
u0, u1, u2, u3 = var('u0 u1 u2 u3', complex=True)
cu = Matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, u0, u1], [0, 0, u2, u3]])

# define state &amp; its density matrix
state = Matrix([[a], [b], [c], [d]])
state_d = state * state.H
# CU(q_3, q_0)
t = simplify(cu * state_d * cu.H)
# Z(q_3)
op = TensorProduct(Z().get_target_matrix(), eye(2))
r = simplify(op * t * op)
</code></pre>
<p>Result:</p>
<p><span class=""math-container"">$\left[\begin{matrix}a \overline{a} &amp; a \overline{b} &amp; - a \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; - a \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\\b \overline{a} &amp; b \overline{b} &amp; - b \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; - b \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\\- \left(c u_{0} + d u_{1}\right) \overline{a} &amp; - \left(c u_{0} + d u_{1}\right) \overline{b} &amp; \left(c u_{0} + d u_{1}\right) \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; \left(c u_{0} + d u_{1}\right) \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\\- \left(c u_{2} + d u_{3}\right) \overline{a} &amp; - \left(c u_{2} + d u_{3}\right) \overline{b} &amp; \left(c u_{2} + d u_{3}\right) \left(\overline{c} \overline{u_{0}} + \overline{d} \overline{u_{1}}\right) &amp; \left(c u_{2} + d u_{3}\right) \left(\overline{c} \overline{u_{2}} + \overline{d} \overline{u_{3}}\right)\end{matrix}\right]$</span></p>
",qc,find equivalent circuit without ancilla qubits p span 1 p following quantum circuit p https nofollow noreferrer img https quantum circuit p inner qubits initialized span span u arbitrary quantum gate p interested outcome qubits span span strong way reduce circuit 2 qubits p first idea replace gates single qubit operations quot isolated quot remove inner 2 qubits paper https nofollow noreferrer constructing virtual gate sampling operations describes strategy decompose gate sequence operations sampling overhead leads believe circuit reduced 2 p apprach make sense general way get rid ancilla qubits hr h3 edit p em since question lacked clarity provide calculation specific p convenience reordered qubits according circuit p https nofollow noreferrer img https quantum circuit p span u gate arbitrary unitary span matrix 0 amp 1 2 amp 3 matrix represent combined state span span span 00 01 10 11 matrix matrix results overall initial state span ii matrix matrix p use sympy calculate circuit span 2 1 2 2 0 cnot cnot pre code sympy import import tensorproduct import z h qiskit import quantumcircuit import operator define variables b c var b c u0 u1 u2 u3 var u1 u2 u3 u matrix u0 u1 u2 u3 cx matrix 1 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 cz matrix 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 define state amp density matrix state tensorproduct matrix 1 sqrt 2 matrix 1 sqrt 2 matrix b c state cnot quantumcircuit 4 1 3 op matrix operator simplify op cnot op tensorproduct cx eye 4 simplify op cu op tensorproduct eye 2 eye 2 eye 2 eye 2 2 tensorproduct eye 2 z eye 2 eye 2 2 tensorproduct eye 2 eye 2 eye 2 u 2 tensorproduct eye 2 z eye 2 u 2 simplify op h op tensorproduct eye 2 h eye 4 simplify op cz op tensorproduct eye 2 cz eye 2 simplify op trace qubits r tensorproduct matrix 1 0 0 0 eye 4 tensorproduct matrix 1 0 0 0 eye 4 tensorproduct matrix 0 1 0 0 eye 4 tensorproduct matrix 0 1 0 0 eye 4 tensorproduct matrix 0 0 1 0 eye 4 tensorproduct matrix 0 0 1 0 eye 4 tensorproduct matrix 0 0 0 1 eye 4 tensorproduct matrix 0 0 0 1 eye 4 r simplify r p resulting density matrix span span p span matrix 0 0 0 b 1 b 1 0 b 1 b 1 amp 0 2 0 b 3 b b 1 2 b 1 b 3 amp 0 c c 0 1 b 1 c amp 0 c 2 3 b 1 2 0 2 b 1 b 3 0 b 3 b 1 b amp 2 2 2 b 3 b 3 2 b 3 b 3 b b amp 2 c b 3 c b c 0 b 1 amp 2 b 3 b c 2 b 3 c 0 c 0 c b 1 1 amp c 0 b c 2 c b 3 1 b amp c 0 c 0 c 0 1 c c 1 c 0 1 1 amp c 0 c 2 c 0 3 c 1 c 2 1 3 c 2 3 0 b 1 amp c 2 b 3 b 2 b 3 amp c 2 c 0 c 2 1 3 c 0 3 1 c amp c 2 c 2 c 2 3 3 c 2 3 3 matrix hr p calculation circuit suggested comments p https nofollow noreferrer img https quantum circuit pre code sympy import import tensorproduct import z b c var b c u0 u1 u2 u3 var u1 u2 u3 cu matrix 1 0 0 0 0 1 0 0 0 0 u0 u1 0 0 u2 u3 define state amp density matrix state matrix b c state cu simplify cu z op tensorproduct z eye 2 r simplify op op p result p span matrix amp b amp c 0 1 amp c 2 3 amp b b amp b c 0 1 amp b c 2 3 c 0 1 amp c 0 1 b amp c 0 1 c 0 1 amp c 0 1 c 2 3 c 2 3 amp c 2 3 b amp c 2 3 c 0 1 amp c 2 3 c 2 3 matrix,"[(0, 0.020596717), (2, 0.47686467), (3, 0.09071679), (4, 0.053995684), (6, 0.015110826), (11, 0.031759284), (15, 0.07577386), (17, 0.1763569), (18, 0.044890568)]"
37193,37229.0,2024-03-11 11:06:47,2,63,"<p>While discussing witnesses, in <a href=""https://arxiv.org/abs/0811.2803"" rel=""nofollow noreferrer"">https://arxiv.org/abs/0811.2803</a> the authors mention (page 16 of the arxiv version, below Eq. (32)) that a necessary condition for a witness <span class=""math-container"">$W$</span> to be optimal is that it touches the set of separable states, meaning there's some separable <span class=""math-container"">$\rho_s$</span> such that <span class=""math-container"">$\operatorname{tr}(\rho_s W)=0$</span>.
They then mention that this condition is <em>not</em> sufficient for optimality, and a witness satisfying this condition is sometimes called &quot;weakly optimal&quot;.</p>
<p>From a geometric perspective, this seems weird to me: I imagine witnesses as hyperplanes in state space separating separable states <span class=""math-container"">$\mathcal C$</span> from the rest, as per the <a href=""https://en.wikipedia.org/wiki/Hyperplane_separation_theorem"" rel=""nofollow noreferrer"">hyperplane separation theorem</a>.
So if a witness corresponds to a hyperplane touching <span class=""math-container"">$\mathcal C$</span>, it seems intuitive that it should be optimal, meaning the plane can't be &quot;made closer&quot; to <span class=""math-container"">$\mathcal C$</span>.
On the other hand, it might just be possible that one can move the plane in a direction &quot;orthogonal&quot; to the one touching <span class=""math-container"">$\mathcal C$</span>. It's just hard to imagine things in such high dimensions.</p>
<p>What are examples of witnesses that are &quot;weakly optimal&quot; in the above sense?</p>
",What are examples of weakly optimal witnesses?,<entanglement><entanglement-witness>,2,6,,,"What are examples of weakly optimal witnesses? <p>While discussing witnesses, in <a href=""https://arxiv.org/abs/0811.2803"" rel=""nofollow noreferrer"">https://arxiv.org/abs/0811.2803</a> the authors mention (page 16 of the arxiv version, below Eq. (32)) that a necessary condition for a witness <span class=""math-container"">$W$</span> to be optimal is that it touches the set of separable states, meaning there's some separable <span class=""math-container"">$\rho_s$</span> such that <span class=""math-container"">$\operatorname{tr}(\rho_s W)=0$</span>.
They then mention that this condition is <em>not</em> sufficient for optimality, and a witness satisfying this condition is sometimes called &quot;weakly optimal&quot;.</p>
<p>From a geometric perspective, this seems weird to me: I imagine witnesses as hyperplanes in state space separating separable states <span class=""math-container"">$\mathcal C$</span> from the rest, as per the <a href=""https://en.wikipedia.org/wiki/Hyperplane_separation_theorem"" rel=""nofollow noreferrer"">hyperplane separation theorem</a>.
So if a witness corresponds to a hyperplane touching <span class=""math-container"">$\mathcal C$</span>, it seems intuitive that it should be optimal, meaning the plane can't be &quot;made closer&quot; to <span class=""math-container"">$\mathcal C$</span>.
On the other hand, it might just be possible that one can move the plane in a direction &quot;orthogonal&quot; to the one touching <span class=""math-container"">$\mathcal C$</span>. It's just hard to imagine things in such high dimensions.</p>
<p>What are examples of witnesses that are &quot;weakly optimal&quot; in the above sense?</p>
",qc,examples weakly optimal witnesses p discussing witnesses https nofollow noreferrer https authors mention page 16 arxiv version eq 32 necessary condition witness span w optimal touches set separable states meaning separable span span tr w mention condition em sufficient optimality witness satisfying condition sometimes called quot weakly optimal quot p geometric perspective seems weird imagine witnesses hyperplanes state space separating separable states span c rest per https nofollow noreferrer hyperplane separation theorem witness corresponds hyperplane touching span c seems intuitive optimal meaning plane ca quot made closer quot span c hand might possible one move plane direction quot orthogonal quot one touching span c hard imagine things high p examples witnesses quot weakly optimal quot sense,"[(3, 0.3563268), (9, 0.5053566), (17, 0.027521012), (19, 0.100242235)]"
37208,,2024-03-12 02:30:12,2,70,"<p>I try to simulate two-qubit erasure error by using CORRELATED_ERROR, ELSE_CORRELATED_ERROR, and an ancilla which is mentioned in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a>. Then I simulate two-qubit erasure error in surface code by following codes.</p>
<pre><code>pro = [0.00625, 0.006289308176100629, 0.006329113924050633, 0.006369426751592357, 0.006410256410256411, 0.006451612903225807, 0.006493506493506495, 0.006535947712418302, 0.006578947368421053, 0.006622516556291391, 0.006666666666666667, 0.006711409395973155, 0.006756756756756757, 0.006802721088435375, 0.006849315068493151, 0.006896551724137932]

circuit = stim.Circuit(f&quot;&quot;&quot;
R 1 2 999
E({pro[0]}) X999 
ELSE_CORRELATED_ERROR({pro[1]}) X2 X999
ELSE_CORRELATED_ERROR({pro[2]}) Y2 X999
ELSE_CORRELATED_ERROR({pro[3]}) Z2 X999
ELSE_CORRELATED_ERROR({pro[4]}) X1 X999
ELSE_CORRELATED_ERROR({pro[5]}) X1 X2 X999
ELSE_CORRELATED_ERROR({pro[6]}) X1 Y2 X999
ELSE_CORRELATED_ERROR({pro[7]}) X1 Z2 X999
ELSE_CORRELATED_ERROR({pro[8]}) Y1 X999
ELSE_CORRELATED_ERROR({pro[9]}) Y1 X2 X999
ELSE_CORRELATED_ERROR({pro[10]}) Y1 Y2 X999
ELSE_CORRELATED_ERROR({pro[11]}) Y1 Z2 X999
ELSE_CORRELATED_ERROR({pro[12]}) Z1 X999
ELSE_CORRELATED_ERROR({pro[13]}) Z1 X2 X999
ELSE_CORRELATED_ERROR({pro[14]}) Z1 Y2 X999
ELSE_CORRELATED_ERROR({pro[15]}) Z1 Z2 X999
M 999
DETECTOR rec[-1]
&quot;&quot;&quot;)
</code></pre>
<p>The pro array is chosen to ensure that the probability of each error mode is 0.00625. And I replace DEPOLARIZE2 error with the noise described in code and expect I will get a higher threshold because it gives information on the specific gate where the loss occurred. However, the result is that I get a lower threshold.<br /></p>
<p>Is there a feasible way to simulate a two-qubit erasure error?</p>
",How do I perform an two-qubit erasure error in stim?,<error-correction><stim>,0,6,,,"How do I perform an two-qubit erasure error in stim? <p>I try to simulate two-qubit erasure error by using CORRELATED_ERROR, ELSE_CORRELATED_ERROR, and an ancilla which is mentioned in <a href=""https://quantumcomputing.stackexchange.com/questions/26582/how-do-i-perform-an-erasure-error-in-stim"">How do I perform an erasure error in stim?</a>. Then I simulate two-qubit erasure error in surface code by following codes.</p>
<pre><code>pro = [0.00625, 0.006289308176100629, 0.006329113924050633, 0.006369426751592357, 0.006410256410256411, 0.006451612903225807, 0.006493506493506495, 0.006535947712418302, 0.006578947368421053, 0.006622516556291391, 0.006666666666666667, 0.006711409395973155, 0.006756756756756757, 0.006802721088435375, 0.006849315068493151, 0.006896551724137932]

circuit = stim.Circuit(f&quot;&quot;&quot;
R 1 2 999
E({pro[0]}) X999 
ELSE_CORRELATED_ERROR({pro[1]}) X2 X999
ELSE_CORRELATED_ERROR({pro[2]}) Y2 X999
ELSE_CORRELATED_ERROR({pro[3]}) Z2 X999
ELSE_CORRELATED_ERROR({pro[4]}) X1 X999
ELSE_CORRELATED_ERROR({pro[5]}) X1 X2 X999
ELSE_CORRELATED_ERROR({pro[6]}) X1 Y2 X999
ELSE_CORRELATED_ERROR({pro[7]}) X1 Z2 X999
ELSE_CORRELATED_ERROR({pro[8]}) Y1 X999
ELSE_CORRELATED_ERROR({pro[9]}) Y1 X2 X999
ELSE_CORRELATED_ERROR({pro[10]}) Y1 Y2 X999
ELSE_CORRELATED_ERROR({pro[11]}) Y1 Z2 X999
ELSE_CORRELATED_ERROR({pro[12]}) Z1 X999
ELSE_CORRELATED_ERROR({pro[13]}) Z1 X2 X999
ELSE_CORRELATED_ERROR({pro[14]}) Z1 Y2 X999
ELSE_CORRELATED_ERROR({pro[15]}) Z1 Z2 X999
M 999
DETECTOR rec[-1]
&quot;&quot;&quot;)
</code></pre>
<p>The pro array is chosen to ensure that the probability of each error mode is 0.00625. And I replace DEPOLARIZE2 error with the noise described in code and expect I will get a higher threshold because it gives information on the specific gate where the loss occurred. However, the result is that I get a lower threshold.<br /></p>
<p>Is there a feasible way to simulate a two-qubit erasure error?</p>
",qc,perform erasure error stim p try simulate erasure error using ancilla mentioned https perform erasure error stim simulate erasure error surface code following pre code pro circuit f quot quot quot r 1 2 999 e pro 0 x999 pro 1 x2 x999 pro 2 y2 x999 pro 3 z2 x999 pro 4 x1 x999 pro 5 x1 x2 x999 pro 6 x1 y2 x999 pro 7 x1 z2 x999 pro 8 y1 x999 pro 9 y1 x2 x999 pro 10 y1 y2 x999 pro 11 y1 z2 x999 pro 12 z1 x999 pro 13 z1 x2 x999 pro 14 z1 y2 x999 pro 15 z1 z2 x999 999 detector rec quot quot quot p pro array chosen ensure probability error mode replace depolarize2 error noise described code expect get higher threshold gives information specific gate loss occurred however result get lower br p feasible way simulate erasure error,"[(5, 0.1132593), (6, 0.15598425), (14, 0.10541119), (17, 0.5675397), (19, 0.05680004)]"
37244,37248.0,2024-03-13 22:45:13,1,53,"<p>In the s orbital of a helium atom there are two entangled electrons. They are entangled because they have different spins.</p>
<p>Suppose we give energy to one electron and let it runs from the atom.</p>
<p>Does entanglement between electrons vanish?</p>
",Does entanglement vanishes when an electron runs from the s orbital?,<entanglement>,1,0,,,"Does entanglement vanishes when an electron runs from the s orbital? <p>In the s orbital of a helium atom there are two entangled electrons. They are entangled because they have different spins.</p>
<p>Suppose we give energy to one electron and let it runs from the atom.</p>
<p>Does entanglement between electrons vanish?</p>
",qc,entanglement vanishes electron runs orbital p orbital helium atom two entangled electrons entangled different p suppose give energy one electron let runs p entanglement electrons vanish,"[(8, 0.5303441), (10, 0.045119934), (17, 0.04048005), (18, 0.37770087)]"
37247,37249.0,2024-03-14 06:55:17,0,59,"<p>I'm studying how to build quantum circuits and understand qubit entanglement. The following are my two confusing questions. I would greatly appreciate any assistance or insights regarding these questions. Thank you.</p>
<ol>
<li><p>Building Quantum Circuits from Matrices vs. Vectors:</p>
<p>Can someone explain the main differences between making quantum circuits from unitary matrices and from quantum state vectors? I think they're pretty similar, but building circuits from the state vector is a special case where all inputs are zero. However, I'm not entirely certain, and I feel like I might be overlooking something.</p>
</li>
<li><p>Detecting Qubit Entanglement from Given Data:</p>
<p>When given a quantum state vector or a unitary matrix representing a quantum operation, is there a reliable method or algorithm to determine which qubits are entangled and to what degree? I'm particularly interested in understanding if it's possible to extract information about qubit entanglement directly from the provided state vector or unitary matrix. Are there established techniques or emerging methodologies that address this challenge? Furthermore, how effective are these methods in practice, especially when dealing with mixed states or containing numerous qubits?</p>
</li>
</ol>
","Synthesizing quantum circuits from unitary matrices vs quantum state vectors, and determining qubit entanglement",<entanglement><quantum-circuit>,1,0,,,"Synthesizing quantum circuits from unitary matrices vs quantum state vectors, and determining qubit entanglement <p>I'm studying how to build quantum circuits and understand qubit entanglement. The following are my two confusing questions. I would greatly appreciate any assistance or insights regarding these questions. Thank you.</p>
<ol>
<li><p>Building Quantum Circuits from Matrices vs. Vectors:</p>
<p>Can someone explain the main differences between making quantum circuits from unitary matrices and from quantum state vectors? I think they're pretty similar, but building circuits from the state vector is a special case where all inputs are zero. However, I'm not entirely certain, and I feel like I might be overlooking something.</p>
</li>
<li><p>Detecting Qubit Entanglement from Given Data:</p>
<p>When given a quantum state vector or a unitary matrix representing a quantum operation, is there a reliable method or algorithm to determine which qubits are entangled and to what degree? I'm particularly interested in understanding if it's possible to extract information about qubit entanglement directly from the provided state vector or unitary matrix. Are there established techniques or emerging methodologies that address this challenge? Furthermore, how effective are these methods in practice, especially when dealing with mixed states or containing numerous qubits?</p>
</li>
</ol>
",qc,synthesizing quantum circuits unitary matrices vs quantum state vectors determining qubit entanglement p studying build quantum circuits understand qubit entanglement following two confusing questions would greatly appreciate assistance insights regarding questions thank ol li p building quantum circuits matrices vectors p someone explain main differences making quantum circuits unitary matrices quantum state vectors think pretty similar building circuits state vector special case inputs zero however entirely certain feel like might overlooking li p detecting qubit entanglement given data p given quantum state vector unitary matrix representing quantum operation reliable method algorithm determine qubits entangled degree particularly interested understanding possible extract information qubit entanglement directly provided state vector unitary matrix established techniques emerging methodologies address challenge furthermore effective methods practice especially dealing mixed states containing numerous qubits,"[(3, 0.07726903), (7, 0.088102706), (8, 0.25698283), (9, 0.03419792), (11, 0.034666233), (13, 0.16524449), (14, 0.15974188), (17, 0.020017106), (18, 0.16289797)]"
37259,,2024-03-14 23:10:35,1,73,"<p>Let <span class=""math-container"">$\rho$</span> be a density matrix over some composite Hilbert space <span class=""math-container"">$\mathcal{H}_S \otimes \mathcal{H}_{\mathcal{E}}$</span>. Is partial trace full trace preserving? I.e., is
<span class=""math-container"">$$\text{Tr}(\text{Tr}_\mathcal{E}(\rho)) = \text{Tr}(\rho).$$</span></p>
",Is $\text{Tr}(\text{Tr}_\mathcal{E}(\rho)) = \text{Tr}(\rho)$?,<linear-algebra><density-matrix>,2,0,,,"Is $\text{Tr}(\text{Tr}_\mathcal{E}(\rho)) = \text{Tr}(\rho)$? <p>Let <span class=""math-container"">$\rho$</span> be a density matrix over some composite Hilbert space <span class=""math-container"">$\mathcal{H}_S \otimes \mathcal{H}_{\mathcal{E}}$</span>. Is partial trace full trace preserving? I.e., is
<span class=""math-container"">$$\text{Tr}(\text{Tr}_\mathcal{E}(\rho)) = \text{Tr}(\rho).$$</span></p>
",qc,tr tr e tr p let span density matrix composite hilbert space span h h e partial trace full trace preserving span tr tr e tr,"[(3, 0.6008961), (11, 0.1669818), (17, 0.22563316)]"
37264,,2024-03-15 04:31:50,2,116,"<p>I am looking for a computationally efficient way to minimize the following function. Let
<span class=""math-container"">$$\Phi(\rho, U) = \text{Tr}_2(U\rho U^\dagger)$$</span>
be a reduced density matrix where <span class=""math-container"">$\rho = \overline{\rho}_1 \otimes \rho_2$</span> is a product density matrix over <span class=""math-container"">$\mathcal{H} = \mathcal{H}_1 \otimes \mathcal{H}_2 \cong \mathbb{C}^2 \otimes \mathbb{C}^2$</span> such that <span class=""math-container"">$\overline{\rho}_1$</span> is pure and <span class=""math-container"">$U \in SU(4)$</span>. The overline is purely to emphasize that <span class=""math-container"">$\overline{\rho}_1$</span> is pure.</p>
<p>Though low dimensional, this reduced density matrix is generally complicated. In particular, given a fixed <span class=""math-container"">$\rho$</span>, I am interested in the minimization problem
<span class=""math-container"">$$1 - \text{Tr}(\Phi(\rho, U)^2). \tag{1}$$</span>
The absolute minimum value of <span class=""math-container"">$(1)$</span> is just the value <span class=""math-container"">$0$</span>. Hence, exactly minimizing <span class=""math-container"">$(1)$</span> would be solving for the (assuming nonzero) set of all <span class=""math-container"">$U \in SU(4)$</span> such that
<span class=""math-container"">$$1 - \text{Tr}(\Phi(U)^2) = 0 \tag{2}$$</span>
where I have dropped the explicit dependence on <span class=""math-container"">$\rho$</span> to emphasize that <span class=""math-container"">$\rho$</span> is fixed. There are many equivalent criterions to <span class=""math-container"">$1 - \text{Tr}(\Phi(\rho, U)^2) = 0$</span>, some of which are special results to <span class=""math-container"">$2 \times 2$</span> matrices:</p>
<ol>
<li><span class=""math-container"">$\Phi(\rho, U)$</span> is rank <span class=""math-container"">$1$</span>,</li>
<li><span class=""math-container"">$\det \Phi(\rho, U) = 0$</span>,</li>
<li><span class=""math-container"">$\text{spec}(\Phi(\rho, U)) = \{0, 1\}$</span>,</li>
<li><span class=""math-container"">$\max \text{spec}(\Phi(\rho, U)) = 1$</span></li>
<li><span class=""math-container"">$\min \text{spec}(\Phi(\rho, U)) = 0$</span>,</li>
<li>...</li>
</ol>
<p>I have been trying to wrap my head around the best way to solving <span class=""math-container"">$(2)$</span>.</p>
","Minimizing $1 - \text{Tr}(\Phi(\rho,U)^2)$",<entanglement><linear-algebra><density-matrix><optimization><entropy>,1,14,,,"Minimizing $1 - \text{Tr}(\Phi(\rho,U)^2)$ <p>I am looking for a computationally efficient way to minimize the following function. Let
<span class=""math-container"">$$\Phi(\rho, U) = \text{Tr}_2(U\rho U^\dagger)$$</span>
be a reduced density matrix where <span class=""math-container"">$\rho = \overline{\rho}_1 \otimes \rho_2$</span> is a product density matrix over <span class=""math-container"">$\mathcal{H} = \mathcal{H}_1 \otimes \mathcal{H}_2 \cong \mathbb{C}^2 \otimes \mathbb{C}^2$</span> such that <span class=""math-container"">$\overline{\rho}_1$</span> is pure and <span class=""math-container"">$U \in SU(4)$</span>. The overline is purely to emphasize that <span class=""math-container"">$\overline{\rho}_1$</span> is pure.</p>
<p>Though low dimensional, this reduced density matrix is generally complicated. In particular, given a fixed <span class=""math-container"">$\rho$</span>, I am interested in the minimization problem
<span class=""math-container"">$$1 - \text{Tr}(\Phi(\rho, U)^2). \tag{1}$$</span>
The absolute minimum value of <span class=""math-container"">$(1)$</span> is just the value <span class=""math-container"">$0$</span>. Hence, exactly minimizing <span class=""math-container"">$(1)$</span> would be solving for the (assuming nonzero) set of all <span class=""math-container"">$U \in SU(4)$</span> such that
<span class=""math-container"">$$1 - \text{Tr}(\Phi(U)^2) = 0 \tag{2}$$</span>
where I have dropped the explicit dependence on <span class=""math-container"">$\rho$</span> to emphasize that <span class=""math-container"">$\rho$</span> is fixed. There are many equivalent criterions to <span class=""math-container"">$1 - \text{Tr}(\Phi(\rho, U)^2) = 0$</span>, some of which are special results to <span class=""math-container"">$2 \times 2$</span> matrices:</p>
<ol>
<li><span class=""math-container"">$\Phi(\rho, U)$</span> is rank <span class=""math-container"">$1$</span>,</li>
<li><span class=""math-container"">$\det \Phi(\rho, U) = 0$</span>,</li>
<li><span class=""math-container"">$\text{spec}(\Phi(\rho, U)) = \{0, 1\}$</span>,</li>
<li><span class=""math-container"">$\max \text{spec}(\Phi(\rho, U)) = 1$</span></li>
<li><span class=""math-container"">$\min \text{spec}(\Phi(\rho, U)) = 0$</span>,</li>
<li>...</li>
</ol>
<p>I have been trying to wrap my head around the best way to solving <span class=""math-container"">$(2)$</span>.</p>
",qc,minimizing 1 tr u p looking computationally efficient way minimize following function let span u tr reduced density matrix span product density matrix span h h h c c span pure span u su 4 overline purely emphasize span p though low dimensional reduced density matrix generally complicated particular given fixed span interested minimization problem span 1 tr u 1 absolute minimum value span 1 value span 0 hence exactly minimizing span 1 would solving assuming nonzero set span u su 4 span 1 tr u 0 2 dropped explicit dependence span emphasize span fixed many equivalent criterions span 1 tr u 0 special results span 2 2 matrices ol li span u rank span 1 li span u 0 li span spec u 0 li span spec u 1 li span spec u 0 li p trying wrap head around best way solving span 2,"[(2, 0.13682573), (3, 0.6613055), (7, 0.11849015), (9, 0.02282587), (11, 0.031942207), (17, 0.027639031)]"
37289,37388.0,2024-03-16 11:17:55,4,204,"<p>Recently I'm reading the <a href=""https://arxiv.org/abs/2308.07915"" rel=""nofollow noreferrer"">paper of Bivariate Bicycle(BB) QLDPC code proposed by IBM</a>. The paper mentioned that:</p>
<blockquote>
<p>The actual distance of each candidate code was computed using the integer linear programming method</p>
</blockquote>
<p>and it refered to <a href=""https://arxiv.org/pdf/1108.5738.pdf"" rel=""nofollow noreferrer"">this paper</a> for the mixed ILP method for computing the exact code distance. This referenced paper primarily discusses ILP for MLE decoding in color codes. I am struggling to understand how the ILP method for MLE decoding can be adapted to compute code distances. Is  there any connection between these two problems?</p>
",Compute the exact minimum distance of a QECC with integer linear programming method,<error-correction>,2,2,,,"Compute the exact minimum distance of a QECC with integer linear programming method <p>Recently I'm reading the <a href=""https://arxiv.org/abs/2308.07915"" rel=""nofollow noreferrer"">paper of Bivariate Bicycle(BB) QLDPC code proposed by IBM</a>. The paper mentioned that:</p>
<blockquote>
<p>The actual distance of each candidate code was computed using the integer linear programming method</p>
</blockquote>
<p>and it refered to <a href=""https://arxiv.org/pdf/1108.5738.pdf"" rel=""nofollow noreferrer"">this paper</a> for the mixed ILP method for computing the exact code distance. This referenced paper primarily discusses ILP for MLE decoding in color codes. I am struggling to understand how the ILP method for MLE decoding can be adapted to compute code distances. Is  there any connection between these two problems?</p>
",qc,compute exact minimum distance qecc integer linear programming method p recently reading https nofollow noreferrer paper bivariate bicycle bb qldpc code proposed ibm paper mentioned blockquote p actual distance candidate code computed using integer linear programming method p refered https nofollow noreferrer paper mixed ilp method computing exact code distance referenced paper primarily discusses ilp mle decoding color codes struggling understand ilp method mle decoding adapted compute code distances connection two problems,"[(3, 0.05950171), (4, 0.07346378), (5, 0.21827032), (7, 0.20961854), (8, 0.32984087), (9, 0.06405902), (17, 0.043434165)]"
37293,37296.0,2024-03-16 19:35:22,1,234,"<p>Suppose I have <span class=""math-container"">$n$</span>-qubit circuit. I have a single-qubit gate (e.g. a Pauli gate) at qubit <span class=""math-container"">$a$</span> and it is controlled by the qubit <span class=""math-container"">$b$</span>.  What is the matrix representation for this controlled gate? The wires <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> don't have to be adjacent so I don't think I can just throw in the Kronecker product with identity. How it would generalize if the base gate is a multi-qubit gate  (e.g. controlled-SWAP) or when it's controlled by multiple qubits (e.g. How do I get a Toffoli gate representation for arbitrary <span class=""math-container"">$n$</span>)?</p>
",What is the formula for the matrix representation of a general controlled gate?,<quantum-gate><quantum-circuit><density-matrix><simulation><matrix-representation>,1,1,,,"What is the formula for the matrix representation of a general controlled gate? <p>Suppose I have <span class=""math-container"">$n$</span>-qubit circuit. I have a single-qubit gate (e.g. a Pauli gate) at qubit <span class=""math-container"">$a$</span> and it is controlled by the qubit <span class=""math-container"">$b$</span>.  What is the matrix representation for this controlled gate? The wires <span class=""math-container"">$a$</span> and <span class=""math-container"">$b$</span> don't have to be adjacent so I don't think I can just throw in the Kronecker product with identity. How it would generalize if the base gate is a multi-qubit gate  (e.g. controlled-SWAP) or when it's controlled by multiple qubits (e.g. How do I get a Toffoli gate representation for arbitrary <span class=""math-container"">$n$</span>)?</p>
",qc,formula matrix representation general controlled gate p suppose span n circuit gate pauli gate qubit span controlled qubit span b matrix representation controlled gate wires span span b adjacent think throw kronecker product identity would generalize base gate gate controlled multiple qubits get toffoli gate representation arbitrary span n,"[(3, 0.32422468), (9, 0.277514), (11, 0.080406174), (14, 0.092922986), (17, 0.022816429), (18, 0.19926879)]"
37323,,2024-03-18 08:38:06,1,20,"<p>I want to identify the type of errors (for example, bit-flip error) occurring in specific hardware of Qiskit, for example, 'ibm_cairo'. But on the Qiskit website, I could only check</p>
<ul>
<li>the error rate for each qubit and each connection, and</li>
<li>the basic gates of that hardware where the error can be applied.</li>
</ul>
<p>It is possible to know the type of errors in specific hardware, and if I can, how can I know that?
Thank you in advance.</p>
",Identifying the type of errors occurring in Qiskit hardware,<qiskit><qiskit-runtime>,0,1,,,"Identifying the type of errors occurring in Qiskit hardware <p>I want to identify the type of errors (for example, bit-flip error) occurring in specific hardware of Qiskit, for example, 'ibm_cairo'. But on the Qiskit website, I could only check</p>
<ul>
<li>the error rate for each qubit and each connection, and</li>
<li>the basic gates of that hardware where the error can be applied.</li>
</ul>
<p>It is possible to know the type of errors in specific hardware, and if I can, how can I know that?
Thank you in advance.</p>
",qc,identifying type errors occurring qiskit hardware p want identify type errors example error occurring specific hardware qiskit example qiskit website could check ul li error rate qubit connection li basic gates hardware error p possible know type errors specific hardware know thank,"[(5, 0.38109112), (7, 0.08319524), (14, 0.5017537), (17, 0.030165289)]"
37379,37389.0,2024-03-20 15:07:16,5,237,"<p>It is known that quantum channels, being CPTP maps, map density operators to density operators. And thus, they can be seen as superoperators. Similar to operators, where eigenstates and eigenvalues can be derived, one can also define the eigen-operators <span class=""math-container"">$\Phi_j$</span> (typically, being a mixed state) and eigenvalues of quantum channels:
<span class=""math-container"">$$\mathbb{N}(\Phi_j)=\lambda_j \Phi_j.$$</span></p>
<p>See page 3 of this <a href=""https://indico.ictp.it/event/9023/material/slides/5.pdf"" rel=""nofollow noreferrer"">lecture note</a> for the deduction. Given these similarities between operators (e.g., Hermitian operators) and quantum channels, the question is what can we say about the properties of their eigendecomposition? Specifically, is the basis of the superoperator <span class=""math-container"">$\{\Phi_j\}$</span> a complete basis? Namely, does <span class=""math-container"">$\sum_j\Phi_j=I$</span> hold? Besides, do the elements in the basis orthogonal to each other? Here, the orthogonality may not be directly followed from the state vector, but maybe something like Hilber-Schmidt orthogonal, i.e., <span class=""math-container"">$\mathrm{tr}(\Phi_i\Phi_j)=\delta_{ij}$</span>.</p>
<p>PS: I would be really grateful if someone could point me to some literature regarding this topic.</p>
<hr />
<p><a href=""https://physics.stackexchange.com/q/807036""><em><strong>Crossposted from Physics.SE</strong></em></a></p>
",What can we say about the eigendecomposition of quantum channels?,<linear-algebra><quantum-operation>,2,5,,,"What can we say about the eigendecomposition of quantum channels? <p>It is known that quantum channels, being CPTP maps, map density operators to density operators. And thus, they can be seen as superoperators. Similar to operators, where eigenstates and eigenvalues can be derived, one can also define the eigen-operators <span class=""math-container"">$\Phi_j$</span> (typically, being a mixed state) and eigenvalues of quantum channels:
<span class=""math-container"">$$\mathbb{N}(\Phi_j)=\lambda_j \Phi_j.$$</span></p>
<p>See page 3 of this <a href=""https://indico.ictp.it/event/9023/material/slides/5.pdf"" rel=""nofollow noreferrer"">lecture note</a> for the deduction. Given these similarities between operators (e.g., Hermitian operators) and quantum channels, the question is what can we say about the properties of their eigendecomposition? Specifically, is the basis of the superoperator <span class=""math-container"">$\{\Phi_j\}$</span> a complete basis? Namely, does <span class=""math-container"">$\sum_j\Phi_j=I$</span> hold? Besides, do the elements in the basis orthogonal to each other? Here, the orthogonality may not be directly followed from the state vector, but maybe something like Hilber-Schmidt orthogonal, i.e., <span class=""math-container"">$\mathrm{tr}(\Phi_i\Phi_j)=\delta_{ij}$</span>.</p>
<p>PS: I would be really grateful if someone could point me to some literature regarding this topic.</p>
<hr />
<p><a href=""https://physics.stackexchange.com/q/807036""><em><strong>Crossposted from Physics.SE</strong></em></a></p>
",qc,say eigendecomposition quantum channels p known quantum channels cptp maps map density operators density operators thus seen superoperators similar operators eigenstates eigenvalues derived one also define span typically mixed state eigenvalues quantum channels span n p see page 3 https nofollow noreferrer lecture note deduction given similarities operators hermitian operators quantum channels question say properties eigendecomposition specifically basis superoperator span complete basis namely span hold besides elements basis orthogonal orthogonality may directly followed state vector maybe something like orthogonal span tr ij p ps would really grateful someone could point literature regarding hr p https em strong crossposted,"[(3, 0.642125), (8, 0.095228374), (9, 0.21821707), (11, 0.032691676), (17, 0.010208917)]"
37487,37500.0,2024-03-27 13:31:17,1,75,"<p>From the Stinespring dilation, we have that the dual or complementary channel can be observed in/expressed with the environment.</p>
<p>Can we reconstruct any channel for environments with <span class=""math-container"">$\text{dim}&gt;1$</span> or does the dimension need to be higher? Also, how would one go forward with doing so?</p>
",What is the smallest environment size that allows to represent every quantum channel in fixed dimensions?,<quantum-operation>,1,2,,,"What is the smallest environment size that allows to represent every quantum channel in fixed dimensions? <p>From the Stinespring dilation, we have that the dual or complementary channel can be observed in/expressed with the environment.</p>
<p>Can we reconstruct any channel for environments with <span class=""math-container"">$\text{dim}&gt;1$</span> or does the dimension need to be higher? Also, how would one go forward with doing so?</p>
",qc,smallest environment size allows represent every quantum channel fixed dimensions p stinespring dilation dual complementary channel observed p reconstruct channel environments span dim gt 1 dimension need higher also would one go forward,"[(1, 0.07301175), (3, 0.7960917), (7, 0.09534412), (17, 0.030727878)]"
37504,,2024-03-28 10:43:31,2,48,"<p>Consider a GHZ-state <span class=""math-container"">$|\psi\rangle =\frac{1}{\sqrt{2}}(|0\rangle^{n}+|1\rangle^n)$</span>, and consider a depolarizing channel that maps a density matrix
<span class=""math-container"">$$\rho\to(1-\lambda)\rho + \frac{\lambda}{2^d}I.$$</span></p>
<p>Now we want to see the effect of the depolarizing channel on the GHZ state. What is the natural way to think about this?
Two options that came to mind:</p>
<ul>
<li>Apply the channel on the state as a whole (with <span class=""math-container"">$d=n$</span>)</li>
<li>Apply the channel on each individual qubit (with <span class=""math-container"">$d=1$</span>)</li>
</ul>
<p>Which of these two (or what other option) best suits depolarizing noise in practice?</p>
<p>Note that I also tried this for a dephasing channel (<span class=""math-container"">$\rho\to(1-\lambda)\rho+\lambda Z\rho Z$</span>), in which case the two options above result in the same resulting state.</p>
",Depolarizing channel on GHZ-state,<density-matrix><decoherence><depolarizing-channel>,1,0,,,"Depolarizing channel on GHZ-state <p>Consider a GHZ-state <span class=""math-container"">$|\psi\rangle =\frac{1}{\sqrt{2}}(|0\rangle^{n}+|1\rangle^n)$</span>, and consider a depolarizing channel that maps a density matrix
<span class=""math-container"">$$\rho\to(1-\lambda)\rho + \frac{\lambda}{2^d}I.$$</span></p>
<p>Now we want to see the effect of the depolarizing channel on the GHZ state. What is the natural way to think about this?
Two options that came to mind:</p>
<ul>
<li>Apply the channel on the state as a whole (with <span class=""math-container"">$d=n$</span>)</li>
<li>Apply the channel on each individual qubit (with <span class=""math-container"">$d=1$</span>)</li>
</ul>
<p>Which of these two (or what other option) best suits depolarizing noise in practice?</p>
<p>Note that I also tried this for a dephasing channel (<span class=""math-container"">$\rho\to(1-\lambda)\rho+\lambda Z\rho Z$</span>), in which case the two options above result in the same resulting state.</p>
",qc,depolarizing channel p consider span 1 2 n consider depolarizing channel maps density matrix span p want see effect depolarizing channel ghz state natural way think two options came mind ul li apply channel state whole span li apply channel individual qubit span p two option best suits depolarizing noise practice p note also tried dephasing channel span z case two options result resulting,"[(3, 0.4602982), (11, 0.026233213), (14, 0.13382643), (17, 0.10011858), (18, 0.2570259), (19, 0.020314284)]"
37557,,2024-04-01 00:46:00,0,172,"<p>I have the code below:</p>
<pre class=""lang-python prettyprint-override""><code>def load_IBMQ(channel,token):
    service = QiskitRuntimeService(channel=channel, token=token)
    #if len(IBMQ.stored_account()) == 0:
      #  IBMQ.save_account(token)
       # IBMQ.load_account()
    #elif IBMQ.active_account() == None:
     #   IBMQ.load_account()
    provider = service.backends(simulator=False, operational=True)#least_busy(operational=True, simulator=False)#IBMQ.get_provider(hub=hub, group=group, project=project)
    print(&quot;provider&quot;, provider)
    return provider
def get_device_info(channel,token,device_name,fields,datetime):
    dirname = './devices/%s'%datetime.date()
    filename = '%s/%s.pckl'%(dirname,device_name)
    _device_info = read_dict(filename=filename)
    if len(_device_info)==0:
        if not os.path.exists(dirname):
            os.makedirs(dirname)
        else:
            subprocess.run(['rm','-r',dirname])
            os.makedirs(dirname)
        provider = load_IBMQ(channel=channel,token=token)
        for x in provider:

            if 'qasm' not in str(x):
                device =x#get_backend(str(x))
                properties = device.properties(datetime=datetime)
                print(&quot;....properties....&quot;, properties)


                num_qubits = device.configuration().n_qubits#len(properties.qubits)
                print('Download device_info for %d-qubit %s'%(num_qubits,x))
                coupling_map = CouplingMap(device.configuration().coupling_map)
                noise_model = NoiseModel.from_backend(device)
                basis_gates = noise_model.basis_gates
                _device_info = {'properties':properties,#device.configuration(),
                'coupling_map':coupling_map,
                'noise_model':noise_model,
                'basis_gates':basis_gates}
                pickle.dump(_device_info, open('%s/%s.pckl'%(dirname,str(x)),'wb'))
            print('-'*50)
        _device_info = read_dict(filename=filename)
    device_info = {}
    for field in fields:


        if field=='device':
            provider = load_IBMQ(channel=channel,token=token)
            #print(device_name)

            device = device_name#provider.get_backend(device_name)
            device_info[field] = device
        else:
            device_info[field] = _device_info[field]
    print(&quot;get_device_info end&quot;)
    return device_info
</code></pre>
<p>I get error</p>
<pre><code>device_info[field] = _device_info[field]
                     ~~~~~~~~~~~~^^^^^^^
KeyError: 'properties'
</code></pre>
<p>How I get properties of real IBM quantum computer like <code>ibm_osaka</code> or others quantum computer in Qiskit SDK 1.0</p>
",How to get properties of real IBM Quantum Computer in Qiskit SDK 1.0?,<qiskit><qiskit-runtime>,1,0,,,"How to get properties of real IBM Quantum Computer in Qiskit SDK 1.0? <p>I have the code below:</p>
<pre class=""lang-python prettyprint-override""><code>def load_IBMQ(channel,token):
    service = QiskitRuntimeService(channel=channel, token=token)
    #if len(IBMQ.stored_account()) == 0:
      #  IBMQ.save_account(token)
       # IBMQ.load_account()
    #elif IBMQ.active_account() == None:
     #   IBMQ.load_account()
    provider = service.backends(simulator=False, operational=True)#least_busy(operational=True, simulator=False)#IBMQ.get_provider(hub=hub, group=group, project=project)
    print(&quot;provider&quot;, provider)
    return provider
def get_device_info(channel,token,device_name,fields,datetime):
    dirname = './devices/%s'%datetime.date()
    filename = '%s/%s.pckl'%(dirname,device_name)
    _device_info = read_dict(filename=filename)
    if len(_device_info)==0:
        if not os.path.exists(dirname):
            os.makedirs(dirname)
        else:
            subprocess.run(['rm','-r',dirname])
            os.makedirs(dirname)
        provider = load_IBMQ(channel=channel,token=token)
        for x in provider:

            if 'qasm' not in str(x):
                device =x#get_backend(str(x))
                properties = device.properties(datetime=datetime)
                print(&quot;....properties....&quot;, properties)


                num_qubits = device.configuration().n_qubits#len(properties.qubits)
                print('Download device_info for %d-qubit %s'%(num_qubits,x))
                coupling_map = CouplingMap(device.configuration().coupling_map)
                noise_model = NoiseModel.from_backend(device)
                basis_gates = noise_model.basis_gates
                _device_info = {'properties':properties,#device.configuration(),
                'coupling_map':coupling_map,
                'noise_model':noise_model,
                'basis_gates':basis_gates}
                pickle.dump(_device_info, open('%s/%s.pckl'%(dirname,str(x)),'wb'))
            print('-'*50)
        _device_info = read_dict(filename=filename)
    device_info = {}
    for field in fields:


        if field=='device':
            provider = load_IBMQ(channel=channel,token=token)
            #print(device_name)

            device = device_name#provider.get_backend(device_name)
            device_info[field] = device
        else:
            device_info[field] = _device_info[field]
    print(&quot;get_device_info end&quot;)
    return device_info
</code></pre>
<p>I get error</p>
<pre><code>device_info[field] = _device_info[field]
                     ~~~~~~~~~~~~^^^^^^^
KeyError: 'properties'
</code></pre>
<p>How I get properties of real IBM quantum computer like <code>ibm_osaka</code> or others quantum computer in Qiskit SDK 1.0</p>
",qc,get properties real ibm quantum computer qiskit sdk p code pre code def channel token service qiskitruntimeservice len 0 token elif none provider print quot provider quot provider return provider def channel token fields datetime dirname filename dirname len dirname dirname else dirname dirname provider x provider str x device str x properties print quot properties quot properties len print x couplingmap device properties open dirname str x print 50 field fields provider print device field device else field field print quot end quot return p get error pre code field field keyerror p get properties real ibm quantum computer like code others quantum computer qiskit sdk,"[(0, 0.33705205), (1, 0.1141585), (6, 0.083242156), (8, 0.051734053), (10, 0.0486551), (14, 0.13445461), (16, 0.029044744), (17, 0.027313849), (19, 0.1733179)]"
37647,37657.0,2024-04-05 17:52:18,4,140,"<p>I feel like this should have been recorded somewhere but I could not find any result in the literature (except in very specific cases). Consider two states <span class=""math-container"">$\rho,\sigma$</span> such that they are <span class=""math-container"">$\epsilon$</span>-close in trace distance:
<span class=""math-container"">\begin{align}
T := \frac{1}{2}||\rho-\sigma||_1 = \epsilon.
\end{align}</span>
In this case I would like to consider these states to describe <span class=""math-container"">$N$</span>-partite qubits so the full dimension is <span class=""math-container"">$2^N$</span>. <span class=""math-container"">$A$</span> be some <span class=""math-container"">$k$</span>-local observable, say <span class=""math-container"">$k$</span>-tensor product of Pauli operators. Is there some good and generic bound (with or without additional promises) on the expectation value of <span class=""math-container"">$A$</span>, i.e.,
<span class=""math-container"">\begin{align}
\text{Tr}(A(\rho-\sigma)) 
\end{align}</span>
is somehow <span class=""math-container"">$\epsilon$</span>-close?</p>
<p>In the context of things that I have seen, this tends to appear in the context of de Finetti theorem or mean-field applications, where <span class=""math-container"">$\sigma$</span> is a product state approximation of <span class=""math-container"">$\rho$</span>. In those cases, there are situations where it is possible to estimate, say, ground state energy (see, e.g., <a href=""https://arxiv.org/abs/1310.0017"" rel=""nofollow noreferrer"">here</a>), but I could not find a more generic result and I am not sure if it is because it is not possible or something else. The exception I found was in the case when I have bosonic or fermionic systems (that obeys canonical (anti-)commutation relations, where Hudson's theorem (see, e.g., Appendix A <a href=""https://arxiv.org/pdf/1708.01266.pdf"" rel=""nofollow noreferrer"">here</a>) implies the above (and becomes exact in the infinite-volume/thermodynamic limit).</p>
<p>If <span class=""math-container"">$\sigma$</span> is fixed to be product state approximation of <span class=""math-container"">$\rho$</span>, then what I am asking boils down to the question of whether there is a &quot;finite de Finetti theorem&quot; for expectation value of observables that becomes exact in the thermodynamic limit?</p>
<p><strong>Remark:</strong> I am aware of the fact that in general, closeness in trace distance does not imply closeness in some information-theoretic quantities of interest: for example, two states close in trace distance can have very large separation in entropy, as Fannes-Audenaert inequality suggests. It is not clear to me if this also applies to local observables in general.</p>
",Bounds on local expectation values for two states close in trace distance,<quantum-state><trace-distance>,1,0,,,"Bounds on local expectation values for two states close in trace distance <p>I feel like this should have been recorded somewhere but I could not find any result in the literature (except in very specific cases). Consider two states <span class=""math-container"">$\rho,\sigma$</span> such that they are <span class=""math-container"">$\epsilon$</span>-close in trace distance:
<span class=""math-container"">\begin{align}
T := \frac{1}{2}||\rho-\sigma||_1 = \epsilon.
\end{align}</span>
In this case I would like to consider these states to describe <span class=""math-container"">$N$</span>-partite qubits so the full dimension is <span class=""math-container"">$2^N$</span>. <span class=""math-container"">$A$</span> be some <span class=""math-container"">$k$</span>-local observable, say <span class=""math-container"">$k$</span>-tensor product of Pauli operators. Is there some good and generic bound (with or without additional promises) on the expectation value of <span class=""math-container"">$A$</span>, i.e.,
<span class=""math-container"">\begin{align}
\text{Tr}(A(\rho-\sigma)) 
\end{align}</span>
is somehow <span class=""math-container"">$\epsilon$</span>-close?</p>
<p>In the context of things that I have seen, this tends to appear in the context of de Finetti theorem or mean-field applications, where <span class=""math-container"">$\sigma$</span> is a product state approximation of <span class=""math-container"">$\rho$</span>. In those cases, there are situations where it is possible to estimate, say, ground state energy (see, e.g., <a href=""https://arxiv.org/abs/1310.0017"" rel=""nofollow noreferrer"">here</a>), but I could not find a more generic result and I am not sure if it is because it is not possible or something else. The exception I found was in the case when I have bosonic or fermionic systems (that obeys canonical (anti-)commutation relations, where Hudson's theorem (see, e.g., Appendix A <a href=""https://arxiv.org/pdf/1708.01266.pdf"" rel=""nofollow noreferrer"">here</a>) implies the above (and becomes exact in the infinite-volume/thermodynamic limit).</p>
<p>If <span class=""math-container"">$\sigma$</span> is fixed to be product state approximation of <span class=""math-container"">$\rho$</span>, then what I am asking boils down to the question of whether there is a &quot;finite de Finetti theorem&quot; for expectation value of observables that becomes exact in the thermodynamic limit?</p>
<p><strong>Remark:</strong> I am aware of the fact that in general, closeness in trace distance does not imply closeness in some information-theoretic quantities of interest: for example, two states close in trace distance can have very large separation in entropy, as Fannes-Audenaert inequality suggests. It is not clear to me if this also applies to local observables in general.</p>
",qc,bounds local expectation values two states close trace distance p feel like recorded somewhere could find result literature except specific cases consider two states span span trace distance span align 1 2 align case would like consider states describe span n qubits full dimension span span span k observable say span k product pauli operators good generic bound without additional promises expectation value span span align tr align somehow span p context things seen tends appear context de finetti theorem applications span product state approximation span cases situations possible estimate say ground state energy see https nofollow noreferrer could find generic result sure possible something else exception found case bosonic fermionic systems obeys canonical commutation relations hudson theorem see appendix https nofollow noreferrer implies becomes exact limit p span fixed product state approximation span asking boils question whether quot finite de finetti theorem quot expectation value observables becomes exact thermodynamic limit p strong remark aware fact general closeness trace distance imply closeness quantities interest example two states close trace distance large separation entropy inequality suggests clear also applies local observables,"[(3, 0.74799126), (4, 0.015404163), (7, 0.14937249), (8, 0.043949213), (17, 0.025631765), (19, 0.01686863)]"
37666,,2024-04-07 06:27:03,0,33,"<p>We know that the color code has an extra element relative toric code . It is color . I want to know what is the role of color ?</p>
",What is the role of color in color code? ( theoritically and exprimentally),<quantum-gate><quantum-state><error-correction><toric-code>,0,1,,,"What is the role of color in color code? ( theoritically and exprimentally) <p>We know that the color code has an extra element relative toric code . It is color . I want to know what is the role of color ?</p>
",qc,role color color code theoritically exprimentally p know color code extra element relative toric code color want know role color,"[(3, 0.15194134), (5, 0.6868206), (9, 0.09633521), (17, 0.056108437)]"
78320664,,2024-04-13 13:04:26,2,183,"<p>I am recieveing the error: ModuleNotFoundError: No module named 'tensorflow_quantum' in google colab when i try importing tensorflow-quantum</p>
<p>I tried installing the package &quot;tensorflow-quantum&quot; over and over again. I also installed it manually by cloning it from github to no avail. Also note that i have read the instructions for installing the package including the python version requirement and followed them to no avail. I tried same process in jupyter-notebook but still get the same error message. Its so frustrating.</p>
",Google Colab Error: ModuleNotFoundError: No module named 'tensorflow_quantum',<tensorflow><jupyter-notebook><google-colaboratory><quantum-computing><tensorflow-quantum>,1,4,,,"Google Colab Error: ModuleNotFoundError: No module named 'tensorflow_quantum' <p>I am recieveing the error: ModuleNotFoundError: No module named 'tensorflow_quantum' in google colab when i try importing tensorflow-quantum</p>
<p>I tried installing the package &quot;tensorflow-quantum&quot; over and over again. I also installed it manually by cloning it from github to no avail. Also note that i have read the instructions for installing the package including the python version requirement and followed them to no avail. I tried same process in jupyter-notebook but still get the same error message. Its so frustrating.</p>
",so_new,google colab error modulenotfounderror module named p recieveing error modulenotfounderror module named google colab try importing p tried installing package quot quot also installed manually cloning github avail also note read instructions installing package including python version requirement followed avail tried process still get error message,"[(0, 0.12891558), (4, 0.2831404), (14, 0.41000554), (17, 0.023141598), (19, 0.15153237)]"
37797,37824.0,2024-04-15 11:15:46,4,180,"<p>It seems like most research regarding stabilizer codes focused on CSS codes, which can be understand as a &quot;tensor product&quot; of two classical linear codes. However, I feel like non-CSS codes tend to render better performance given the same code size. For example, the well-known <span class=""math-container"">$[[5, 1, 3]]$</span> code can correct a single error with only five qubits. If we require the code to be CSS, we then need minimal seven qubits (Steane code) to do the same job (see <a href=""https://quantumcomputing.stackexchange.com/a/37059/23123"">this answer</a> for why <span class=""math-container"">$[[6, 1, 3]]$</span> code cannot be CSS).</p>
<p><strong>What are the main motivations for pursuing CSS codes over general non-CSS codes?</strong> I can imagine that CSS codes might make decoding easier as we are able to decode X and Z errors separately, but what else can we gain from the CSS codes, as it is suboptimal compared with the non-CSS codes?</p>
",What are the main motivations for pursuing CSS codes over general non-CSS codes?,<error-correction><stabilizer-code>,1,1,,,"What are the main motivations for pursuing CSS codes over general non-CSS codes? <p>It seems like most research regarding stabilizer codes focused on CSS codes, which can be understand as a &quot;tensor product&quot; of two classical linear codes. However, I feel like non-CSS codes tend to render better performance given the same code size. For example, the well-known <span class=""math-container"">$[[5, 1, 3]]$</span> code can correct a single error with only five qubits. If we require the code to be CSS, we then need minimal seven qubits (Steane code) to do the same job (see <a href=""https://quantumcomputing.stackexchange.com/a/37059/23123"">this answer</a> for why <span class=""math-container"">$[[6, 1, 3]]$</span> code cannot be CSS).</p>
<p><strong>What are the main motivations for pursuing CSS codes over general non-CSS codes?</strong> I can imagine that CSS codes might make decoding easier as we are able to decode X and Z errors separately, but what else can we gain from the CSS codes, as it is suboptimal compared with the non-CSS codes?</p>
",qc,main motivations pursuing css codes general codes p seems like research regarding stabilizer codes focused css codes understand quot tensor product quot two classical linear codes however feel like codes tend render better performance given code size example span 5 1 3 code correct single error five qubits require code css need minimal seven qubits steane code job see https answer span 6 1 3 code css p strong main motivations pursuing css codes general codes imagine css codes might make decoding easier able decode x z errors separately else gain css codes suboptimal compared codes,"[(1, 0.01995208), (3, 0.08881669), (5, 0.536011), (6, 0.06290422), (7, 0.07605293), (8, 0.09025973), (13, 0.06935907), (17, 0.010330793), (19, 0.045155782)]"
37841,,2024-04-17 11:35:31,1,71,"<p>This question is probably too obvious, so sorry beforehand.</p>
<p>We know that the generalized Pauli elements <span class=""math-container"">$P\in \mathcal{P}_d \setminus {\mathrm{Id}_d}$</span> in Sylvesters representation, hence not Hermitian, constitute a basis for <span class=""math-container"">$\mathfrak{sl}_d$</span>, the special Lie algebra of dimension <span class=""math-container"">$d$</span>, which is a matrix Lie algebra of all traceless matrices with determinant 1.</p>
<p>Now, how would I express a matrix <span class=""math-container"">$M$</span> within this algebra in this basis? The question may be too obvious, but since the trace vanishes for <span class=""math-container"">$M$</span> and <span class=""math-container"">$P$</span> it vanishes for <span class=""math-container"">$MP$</span> too, since <span class=""math-container"">$M$</span> is invertible as well. But the Hilbert Schmidt inner product, which would be the inner product of this space I guess, since it is a sub vector space of the <span class=""math-container"">$\mathfrak{gl}_d$</span>, is precisely the trace <span class=""math-container"">$Tr(P^\dagger M)$</span> which should be zero, since <span class=""math-container"">$\mathfrak{sl}_d$</span> should be a <span class=""math-container"">$*$</span>-algebra and therefore <span class=""math-container"">$P^\dagger$</span> should also be part of this algebra.</p>
<p>How would i then write <span class=""math-container"">$M$</span> in this basis?</p>
",How to express a traceless matrix in Pauli basis,<textbook-and-exercises><linear-algebra>,0,2,,,"How to express a traceless matrix in Pauli basis <p>This question is probably too obvious, so sorry beforehand.</p>
<p>We know that the generalized Pauli elements <span class=""math-container"">$P\in \mathcal{P}_d \setminus {\mathrm{Id}_d}$</span> in Sylvesters representation, hence not Hermitian, constitute a basis for <span class=""math-container"">$\mathfrak{sl}_d$</span>, the special Lie algebra of dimension <span class=""math-container"">$d$</span>, which is a matrix Lie algebra of all traceless matrices with determinant 1.</p>
<p>Now, how would I express a matrix <span class=""math-container"">$M$</span> within this algebra in this basis? The question may be too obvious, but since the trace vanishes for <span class=""math-container"">$M$</span> and <span class=""math-container"">$P$</span> it vanishes for <span class=""math-container"">$MP$</span> too, since <span class=""math-container"">$M$</span> is invertible as well. But the Hilbert Schmidt inner product, which would be the inner product of this space I guess, since it is a sub vector space of the <span class=""math-container"">$\mathfrak{gl}_d$</span>, is precisely the trace <span class=""math-container"">$Tr(P^\dagger M)$</span> which should be zero, since <span class=""math-container"">$\mathfrak{sl}_d$</span> should be a <span class=""math-container"">$*$</span>-algebra and therefore <span class=""math-container"">$P^\dagger$</span> should also be part of this algebra.</p>
<p>How would i then write <span class=""math-container"">$M$</span> in this basis?</p>
",qc,express traceless matrix pauli basis p question probably obvious sorry p know generalized pauli elements span p id sylvesters representation hence hermitian constitute basis span sl special lie algebra dimension span matrix lie algebra traceless matrices determinant p would express matrix span within algebra basis question may obvious since trace vanishes span span p vanishes span mp since span invertible well hilbert schmidt inner product would inner product space guess since sub vector space span gl precisely trace span tr zero since span sl span therefore span also part p would write span basis,"[(3, 0.9286291), (7, 0.019074738), (11, 0.039197136), (17, 0.011361663)]"
37848,,2024-04-17 20:12:42,2,65,"<p>I read that (paraphrasing, see below) &quot;antidegradable channels have zero capacity because of the no-cloning theorem&quot;. Is there a formal derivation of the capacity of an antidegradable channel that uses the no-cloning theorem as one of its steps?</p>
<p>For context, here is the proof I'm familiar with:</p>
<p>Let <span class=""math-container"">$|\psi\rangle_{RA}\in RA$</span> be an initial bipartite state, and say that the channel <span class=""math-container"">$\mathcal{N}$</span> has isometric extension <span class=""math-container"">$V_{\mathcal{N}}: A \rightarrow BE$</span>. Define the state <span class=""math-container"">$|\phi\rangle_{RBE}:= I_R\otimes V_{\mathcal{N}}|\psi\rangle_{RA}$</span>. If <span class=""math-container"">$\mathcal{N}$</span> is antidegradable, then there exists an antidegrading map <span class=""math-container"">$\mathcal{T}$</span> with isometric extension <span class=""math-container"">$V_{\mathcal{T}}: E \rightarrow B'E'$</span> such that <span class=""math-container"">$\rho_{B} = \rho_{B'}$</span>. Then the identity
<span class=""math-container"">$$
I(R\rangle B)_\phi = \frac{1}{2}[I(R\!:\!B)_\phi - I(R\!:\!E)_\phi]
$$</span>
along with the use of <span class=""math-container"">$V_{\mathcal{T}}^\dagger$</span> gives <span class=""math-container"">$I(R\rangle B)_\phi=0$</span>, where <span class=""math-container"">$I(R\rangle B)_\phi:= -H(R|B)_\phi$</span> is the coherent information. This implies the desired result.</p>
<p>In this proof, by applying <span class=""math-container"">$V_{\mathcal{T}}$</span> there may be two subsystems <span class=""math-container"">$B, B'$</span> containing the same reduced state and that is perfectly valid by the problem definition - it is not a proof by contradiction. Instead, this scenario implies that the state <span class=""math-container"">$\rho_B$</span> (loosely) cannot contain quantum information about <span class=""math-container"">$R$</span>. I can't see how no-cloning can be used to make such an information theoretic claim.</p>
<hr />
<p>Edit: For more context, I think the statement I saw was this quote from (<a href=""https://arxiv.org/abs/1407.8160"" rel=""nofollow noreferrer"">Karumanchi, 2016</a>):</p>
<blockquote>
<p>It is well-known that the quantum capacity of antidegradable channels is zero, by the familiar cloning argument: Namely, if an anti-degradable channel were to have positive quantum capacity, F can apply the degrading map followed by the same decoder as B and thus A would be transmitting the same quantum information to B and F . This is in contradiction to the no-cloning theorem as observed in [3].</p>
</blockquote>
<p>The part I don't understand is: &quot;A would be transmitting the same quantum information to B and F&quot;. An antidegradable channel still definitely allows me to prepare two copies of the same transmitted state. And so, intuitively this should mean that there was no quantum information in that state. But I can't figure out how no-cloning converts that intuition into an actual capacity value.</p>
<p>Ref [3] in that quote points to (<a href=""https://arxiv.org/abs/quant-ph/9701015"" rel=""nofollow noreferrer"">Bennett, 1997</a>), where they analyze the <em>erasure channel</em> and argue that by no cloning, quantum capacity must be zero for erasure probability greater than 1/2. In contrast with antidegradable channels, this argument (which uses no-cloning to create a contradiction) is perfectly clear to me. Indeed, the authors specifically mention <em>avoiding</em> no-cloning arguments in analyzing the capacity of a dephasing channel.</p>
",Does no-cloning imply zero capacity of antidegradable channels?,<communication><no-cloning-theorem><channel-capacity><coherent-information>,0,1,,,"Does no-cloning imply zero capacity of antidegradable channels? <p>I read that (paraphrasing, see below) &quot;antidegradable channels have zero capacity because of the no-cloning theorem&quot;. Is there a formal derivation of the capacity of an antidegradable channel that uses the no-cloning theorem as one of its steps?</p>
<p>For context, here is the proof I'm familiar with:</p>
<p>Let <span class=""math-container"">$|\psi\rangle_{RA}\in RA$</span> be an initial bipartite state, and say that the channel <span class=""math-container"">$\mathcal{N}$</span> has isometric extension <span class=""math-container"">$V_{\mathcal{N}}: A \rightarrow BE$</span>. Define the state <span class=""math-container"">$|\phi\rangle_{RBE}:= I_R\otimes V_{\mathcal{N}}|\psi\rangle_{RA}$</span>. If <span class=""math-container"">$\mathcal{N}$</span> is antidegradable, then there exists an antidegrading map <span class=""math-container"">$\mathcal{T}$</span> with isometric extension <span class=""math-container"">$V_{\mathcal{T}}: E \rightarrow B'E'$</span> such that <span class=""math-container"">$\rho_{B} = \rho_{B'}$</span>. Then the identity
<span class=""math-container"">$$
I(R\rangle B)_\phi = \frac{1}{2}[I(R\!:\!B)_\phi - I(R\!:\!E)_\phi]
$$</span>
along with the use of <span class=""math-container"">$V_{\mathcal{T}}^\dagger$</span> gives <span class=""math-container"">$I(R\rangle B)_\phi=0$</span>, where <span class=""math-container"">$I(R\rangle B)_\phi:= -H(R|B)_\phi$</span> is the coherent information. This implies the desired result.</p>
<p>In this proof, by applying <span class=""math-container"">$V_{\mathcal{T}}$</span> there may be two subsystems <span class=""math-container"">$B, B'$</span> containing the same reduced state and that is perfectly valid by the problem definition - it is not a proof by contradiction. Instead, this scenario implies that the state <span class=""math-container"">$\rho_B$</span> (loosely) cannot contain quantum information about <span class=""math-container"">$R$</span>. I can't see how no-cloning can be used to make such an information theoretic claim.</p>
<hr />
<p>Edit: For more context, I think the statement I saw was this quote from (<a href=""https://arxiv.org/abs/1407.8160"" rel=""nofollow noreferrer"">Karumanchi, 2016</a>):</p>
<blockquote>
<p>It is well-known that the quantum capacity of antidegradable channels is zero, by the familiar cloning argument: Namely, if an anti-degradable channel were to have positive quantum capacity, F can apply the degrading map followed by the same decoder as B and thus A would be transmitting the same quantum information to B and F . This is in contradiction to the no-cloning theorem as observed in [3].</p>
</blockquote>
<p>The part I don't understand is: &quot;A would be transmitting the same quantum information to B and F&quot;. An antidegradable channel still definitely allows me to prepare two copies of the same transmitted state. And so, intuitively this should mean that there was no quantum information in that state. But I can't figure out how no-cloning converts that intuition into an actual capacity value.</p>
<p>Ref [3] in that quote points to (<a href=""https://arxiv.org/abs/quant-ph/9701015"" rel=""nofollow noreferrer"">Bennett, 1997</a>), where they analyze the <em>erasure channel</em> and argue that by no cloning, quantum capacity must be zero for erasure probability greater than 1/2. In contrast with antidegradable channels, this argument (which uses no-cloning to create a contradiction) is perfectly clear to me. Indeed, the authors specifically mention <em>avoiding</em> no-cloning arguments in analyzing the capacity of a dephasing channel.</p>
",qc,imply zero capacity antidegradable channels p read paraphrasing see quot antidegradable channels zero capacity theorem quot formal derivation capacity antidegradable channel uses theorem one steps p context proof familiar p let span ra ra initial bipartite state say channel span n isometric extension span n define state span rbe n ra span n antidegradable exists antidegrading map span isometric extension span e b e span b b identity span b 1 2 b e along use span gives span b span b coherent information implies desired p proof applying span may two subsystems span b b containing reduced state perfectly valid problem definition proof contradiction instead scenario implies state span loosely contain quantum information span r ca see used make information theoretic hr p edit context think statement saw quote https nofollow noreferrer karumanchi 2016 blockquote p quantum capacity antidegradable channels zero familiar cloning argument namely channel positive quantum capacity f apply degrading map followed decoder b thus would transmitting quantum information b f contradiction theorem observed 3 p part understand quot would transmitting quantum information b f quot antidegradable channel still definitely allows prepare two copies transmitted state intuitively mean quantum information state ca figure converts intuition actual capacity p ref 3 quote points https nofollow noreferrer bennett 1997 analyze em erasure channel argue cloning quantum capacity must zero erasure probability greater contrast antidegradable channels argument uses create contradiction perfectly clear indeed authors specifically mention em avoiding arguments analyzing capacity dephasing,"[(3, 0.63880247), (8, 0.01953582), (9, 0.16544515), (10, 0.014416517), (17, 0.033371463), (18, 0.10839294), (19, 0.019490967)]"
37849,,2024-04-17 22:02:14,2,18,"<p>I am attempting to use a quantum algorithm, like a QAOA, to solve an optimization problem. I saw that qPCA can be used to simplify datasets and make them easier to analyze. Can quantum optimization be used on a dataset that is reduced by qPCA? If the qPCA is extracting only the largest eigenvalues, which I believe are points with the highest energy, to be looked at by the optimization algorithm, which is trying to find the energy minimums, would using a qPCA before an optimization algorithm actually be a detriment to the results? In other words, is it okay to only look at the highest energy values when trying to find the minimum? Otherwise, can qPCA perhaps be used in the opposite way, to extract only minimums for the optimization algorithm to look at?</p>
",Can dimensionality reduction be used to simplify data before using an optimization algorithm?,<quantum-algorithms><optimization><qaoa>,0,0,,,"Can dimensionality reduction be used to simplify data before using an optimization algorithm? <p>I am attempting to use a quantum algorithm, like a QAOA, to solve an optimization problem. I saw that qPCA can be used to simplify datasets and make them easier to analyze. Can quantum optimization be used on a dataset that is reduced by qPCA? If the qPCA is extracting only the largest eigenvalues, which I believe are points with the highest energy, to be looked at by the optimization algorithm, which is trying to find the energy minimums, would using a qPCA before an optimization algorithm actually be a detriment to the results? In other words, is it okay to only look at the highest energy values when trying to find the minimum? Otherwise, can qPCA perhaps be used in the opposite way, to extract only minimums for the optimization algorithm to look at?</p>
",qc,dimensionality reduction used simplify data using optimization algorithm p attempting use quantum algorithm like qaoa solve optimization problem saw qpca used simplify datasets make easier analyze quantum optimization used dataset reduced qpca qpca extracting largest eigenvalues believe points highest energy looked optimization algorithm trying find energy minimums would using qpca optimization algorithm actually detriment results words okay look highest energy values trying find minimum otherwise qpca perhaps used opposite way extract minimums optimization algorithm look,"[(1, 0.21328309), (7, 0.24248353), (8, 0.09044694), (9, 0.02709312), (14, 0.20933288), (17, 0.044401594), (18, 0.17120011)]"
37915,,2024-04-22 12:43:49,0,20,"<p>How can I use the OrbitalOptimuzationVQE class in qiskit? I want to find the ground state energy if different molecules using OOVQE but I cannot import the orbital optimization vqe class from qiskit. I believe it is no longer active. Is there any other way I can perform OOVQE to find ground state energies?</p>
",Using Orbital Optimization VQE,<vqe>,0,2,,,"Using Orbital Optimization VQE <p>How can I use the OrbitalOptimuzationVQE class in qiskit? I want to find the ground state energy if different molecules using OOVQE but I cannot import the orbital optimization vqe class from qiskit. I believe it is no longer active. Is there any other way I can perform OOVQE to find ground state energies?</p>
",qc,using orbital optimization vqe p use orbitaloptimuzationvqe class qiskit want find ground state energy different molecules using oovqe import orbital optimization vqe class qiskit believe longer active way perform oovqe find ground state energies,"[(0, 0.057394296), (1, 0.24675), (6, 0.08933728), (8, 0.21772946), (14, 0.25214303), (17, 0.06390167), (18, 0.068817616)]"
37994,,2024-04-26 20:02:39,5,74,"<p>It is well known that <span class=""math-container"">$\|\mathcal{E} \circ \mathcal{F} - \mathcal{E}\|_\lozenge \leq \|\mathcal{F} - \mathcal{I}\|_\lozenge$</span>.</p>
<p>What if I have <span class=""math-container"">$\|\mathcal{A} \circ \mathcal{E} \circ \mathcal{F} - \mathcal{A} \circ \mathcal{E}\|_\lozenge$</span>? Does this obey</p>
<p><span class=""math-container"">$$\|\mathcal{A} \circ \mathcal{E} \circ \mathcal{F} - \mathcal{A} \circ \mathcal{E}\|_\lozenge \leq \|\mathcal{A} \circ \mathcal{F} - \mathcal{A} \circ \mathcal{I}\|_\lozenge$$</span></p>
<p>Here I am concerned only with CPTP maps.</p>
",Does monotonicity of diamond distance hold for intermediate channels?,<quantum-operation><diamond-norm>,1,0,,,"Does monotonicity of diamond distance hold for intermediate channels? <p>It is well known that <span class=""math-container"">$\|\mathcal{E} \circ \mathcal{F} - \mathcal{E}\|_\lozenge \leq \|\mathcal{F} - \mathcal{I}\|_\lozenge$</span>.</p>
<p>What if I have <span class=""math-container"">$\|\mathcal{A} \circ \mathcal{E} \circ \mathcal{F} - \mathcal{A} \circ \mathcal{E}\|_\lozenge$</span>? Does this obey</p>
<p><span class=""math-container"">$$\|\mathcal{A} \circ \mathcal{E} \circ \mathcal{F} - \mathcal{A} \circ \mathcal{E}\|_\lozenge \leq \|\mathcal{A} \circ \mathcal{F} - \mathcal{A} \circ \mathcal{I}\|_\lozenge$$</span></p>
<p>Here I am concerned only with CPTP maps.</p>
",qc,monotonicity diamond distance hold intermediate channels p well known span e f e f p span e f e obey p span e f e f p concerned cptp,"[(3, 0.5745356), (10, 0.2478194), (17, 0.17181644)]"
38036,38037.0,2024-04-29 15:05:25,2,54,"<blockquote>
<p><strong>Question:</strong> Given states <span class=""math-container"">$\rho,\omega\in\mathbb C^{n\times n}$</span> and <span class=""math-container"">$\varepsilon&gt;0$</span> such that <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\omega$</span> are <span class=""math-container"">$\varepsilon$</span>-close in trace norm does there exist a channel <span class=""math-container"">$\Phi$</span> with <span class=""math-container"">$\Phi(\rho)=\omega$</span> such that <span class=""math-container"">$\Phi$</span> is <span class=""math-container"">$\varepsilon$</span>-close to the identity, say, in diamond norm?
Or maybe if <span class=""math-container"">$\varepsilon$</span> is too small a bound does this maybe hold for a larger channel-distance bound (e.g., <span class=""math-container"">$2\varepsilon$</span> or <span class=""math-container"">$\sqrt\varepsilon$</span>)?</p>
</blockquote>
<p>One motivation behind this question could be that it is true for pure states:</p>
<blockquote>
<p>Given any <span class=""math-container"">$\phi,\psi\in\mathbb C^n$</span>, <span class=""math-container"">$\|\phi\|=\|\psi\|=1$</span> there exists <span class=""math-container"">$U\in\mathbb C^{n\times n}$</span> unitary such that <span class=""math-container"">$U|\phi\rangle\langle\phi|U^*=|\psi\rangle\langle\psi|$</span> and, more importantly, <span class=""math-container"">$$\|U(\cdot)U^*-{\rm id}\|_\diamond\leq\sqrt2\|\,|\phi\rangle\langle\phi|-|\psi\rangle\langle\psi|\,\|_1\tag{1}$$</span>
so if the pure states are <span class=""math-container"">$\varepsilon$</span>-close together, then the unitary channel can be chosen <span class=""math-container"">$\varepsilon\sqrt2$</span>-close to the identity.</p>
</blockquote>
<p>(This bound can probably be made even tighter but for our purpose that's good enough).
While I don't have a reference at hand containing (1) this is not too difficult to show in a constructive manner by restricting the problem to the 2-dimensional subspace <span class=""math-container"">${\rm span}\{\phi e^{i\alpha},\psi\}$</span>—where <span class=""math-container"">$\alpha$</span> is chosen such that <span class=""math-container"">$\Re(e^{i\alpha}\langle\psi|\phi\rangle)=|\langle\psi|\phi\rangle|$</span>—<a href=""https://math.stackexchange.com/a/1884021"">and then defining the unitary just on there</a>. From this one readily computes the eigenvalues of <span class=""math-container"">$U$</span> to be <span class=""math-container"">$1$</span> and <span class=""math-container"">$|\langle\phi|\psi\rangle|\pm i\sqrt{1-|\langle\phi|\psi\rangle|^2}$</span> meaning <span class=""math-container"">$\|U-{\bf1}\|_\infty=\sqrt{2-2|\langle\phi|\psi\rangle|}$</span>.
Finally, for unitary channels the diamond norm distance is known to simplify considerably (cf. Proposition 18 in <a href=""https://doi.org/10.1063/1.5019322"" rel=""nofollow noreferrer"">this paper</a> / <a href=""https://arxiv.org/abs/1612.00401"" rel=""nofollow noreferrer"">arXiv</a>) to the point that <span class=""math-container"">$$\|U(\cdot)U^*-{\rm id}\|_\diamond\leq2\|U-{\bf1}\|_\infty\leq 2\sqrt{2(1-|\langle\phi|\psi\rangle|^2)}=\sqrt2\|\,|\phi\rangle\langle\phi|-|\psi\rangle\langle\psi|\,\|_1
$$</span>
where the last step is due to the well-known <a href=""https://www.quantiki.org/wiki/trace-distance"" rel=""nofollow noreferrer"">trace distance identity for pure states</a>, cf. also Eq.(1.1.86) in <a href=""https://doi.org/10.1017/9781316848142"" rel=""nofollow noreferrer"">Watrous’ book</a> <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/TQI.pdf"" rel=""nofollow noreferrer"">(alt link)</a>.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",If states are close together does there always exist a channel close to the identity mapping one to the other?,<quantum-operation><density-matrix><trace-distance><diamond-norm>,1,0,,,"If states are close together does there always exist a channel close to the identity mapping one to the other? <blockquote>
<p><strong>Question:</strong> Given states <span class=""math-container"">$\rho,\omega\in\mathbb C^{n\times n}$</span> and <span class=""math-container"">$\varepsilon&gt;0$</span> such that <span class=""math-container"">$\rho$</span> and <span class=""math-container"">$\omega$</span> are <span class=""math-container"">$\varepsilon$</span>-close in trace norm does there exist a channel <span class=""math-container"">$\Phi$</span> with <span class=""math-container"">$\Phi(\rho)=\omega$</span> such that <span class=""math-container"">$\Phi$</span> is <span class=""math-container"">$\varepsilon$</span>-close to the identity, say, in diamond norm?
Or maybe if <span class=""math-container"">$\varepsilon$</span> is too small a bound does this maybe hold for a larger channel-distance bound (e.g., <span class=""math-container"">$2\varepsilon$</span> or <span class=""math-container"">$\sqrt\varepsilon$</span>)?</p>
</blockquote>
<p>One motivation behind this question could be that it is true for pure states:</p>
<blockquote>
<p>Given any <span class=""math-container"">$\phi,\psi\in\mathbb C^n$</span>, <span class=""math-container"">$\|\phi\|=\|\psi\|=1$</span> there exists <span class=""math-container"">$U\in\mathbb C^{n\times n}$</span> unitary such that <span class=""math-container"">$U|\phi\rangle\langle\phi|U^*=|\psi\rangle\langle\psi|$</span> and, more importantly, <span class=""math-container"">$$\|U(\cdot)U^*-{\rm id}\|_\diamond\leq\sqrt2\|\,|\phi\rangle\langle\phi|-|\psi\rangle\langle\psi|\,\|_1\tag{1}$$</span>
so if the pure states are <span class=""math-container"">$\varepsilon$</span>-close together, then the unitary channel can be chosen <span class=""math-container"">$\varepsilon\sqrt2$</span>-close to the identity.</p>
</blockquote>
<p>(This bound can probably be made even tighter but for our purpose that's good enough).
While I don't have a reference at hand containing (1) this is not too difficult to show in a constructive manner by restricting the problem to the 2-dimensional subspace <span class=""math-container"">${\rm span}\{\phi e^{i\alpha},\psi\}$</span>—where <span class=""math-container"">$\alpha$</span> is chosen such that <span class=""math-container"">$\Re(e^{i\alpha}\langle\psi|\phi\rangle)=|\langle\psi|\phi\rangle|$</span>—<a href=""https://math.stackexchange.com/a/1884021"">and then defining the unitary just on there</a>. From this one readily computes the eigenvalues of <span class=""math-container"">$U$</span> to be <span class=""math-container"">$1$</span> and <span class=""math-container"">$|\langle\phi|\psi\rangle|\pm i\sqrt{1-|\langle\phi|\psi\rangle|^2}$</span> meaning <span class=""math-container"">$\|U-{\bf1}\|_\infty=\sqrt{2-2|\langle\phi|\psi\rangle|}$</span>.
Finally, for unitary channels the diamond norm distance is known to simplify considerably (cf. Proposition 18 in <a href=""https://doi.org/10.1063/1.5019322"" rel=""nofollow noreferrer"">this paper</a> / <a href=""https://arxiv.org/abs/1612.00401"" rel=""nofollow noreferrer"">arXiv</a>) to the point that <span class=""math-container"">$$\|U(\cdot)U^*-{\rm id}\|_\diamond\leq2\|U-{\bf1}\|_\infty\leq 2\sqrt{2(1-|\langle\phi|\psi\rangle|^2)}=\sqrt2\|\,|\phi\rangle\langle\phi|-|\psi\rangle\langle\psi|\,\|_1
$$</span>
where the last step is due to the well-known <a href=""https://www.quantiki.org/wiki/trace-distance"" rel=""nofollow noreferrer"">trace distance identity for pure states</a>, cf. also Eq.(1.1.86) in <a href=""https://doi.org/10.1017/9781316848142"" rel=""nofollow noreferrer"">Watrous’ book</a> <a href=""https://cs.uwaterloo.ca/%7Ewatrous/TQI/TQI.pdf"" rel=""nofollow noreferrer"">(alt link)</a>.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",qc,states close together always exist channel close identity mapping one blockquote p strong question given states span n span gt 0 span span span trace norm exist channel span span span span identity say diamond norm maybe span small bound maybe hold larger bound span span p one motivation behind question could true pure states blockquote p given span span exists span n unitary span importantly span id 1 pure states span together unitary channel chosen span p bound probably made even tighter purpose good enough reference hand containing 1 difficult show constructive manner restricting problem subspace span span span chosen span https defining unitary one readily computes eigenvalues span u span 1 span meaning span finally unitary channels diamond norm distance known simplify considerably cf proposition 18 https nofollow noreferrer paper https nofollow noreferrer arxiv point span id 2 last step due https nofollow noreferrer trace distance identity pure states cf also eq https nofollow noreferrer watrous book https nofollow noreferrer alt link hr p em q amp style question meant contribution https list counterexamples quantum information,"[(3, 0.7963909), (4, 0.10241999), (8, 0.020433972), (9, 0.032998934), (17, 0.02425673)]"
38046,38048.0,2024-04-30 02:49:43,2,322,"<p>When I try to run the circuit below:</p>
<pre><code>from qiskit.circuit.library import TwoLocal 
from math import pi

reference_circuit = TwoLocal(2, &quot;rx&quot;, &quot;cz&quot;, entanglement=&quot;linear&quot;, reps=1) theta_list = [pi / 2, pi / 3, pi / 3, pi / 2]

reference_circuit = reference_circuit.bind_parameters(theta_list)

reference_circuit.decompose().draw(&quot;mpl&quot;)
</code></pre>
<p>I get an error that says: <code>'TwoLocal' object has no attribute 'bind_parameters'</code>. This code was working perfectly fine sometime ago but now it keeps throwing error.</p>
",Error when binding parameters to a quantum circuit,<qiskit><programming>,1,0,,,"Error when binding parameters to a quantum circuit <p>When I try to run the circuit below:</p>
<pre><code>from qiskit.circuit.library import TwoLocal 
from math import pi

reference_circuit = TwoLocal(2, &quot;rx&quot;, &quot;cz&quot;, entanglement=&quot;linear&quot;, reps=1) theta_list = [pi / 2, pi / 3, pi / 3, pi / 2]

reference_circuit = reference_circuit.bind_parameters(theta_list)

reference_circuit.decompose().draw(&quot;mpl&quot;)
</code></pre>
<p>I get an error that says: <code>'TwoLocal' object has no attribute 'bind_parameters'</code>. This code was working perfectly fine sometime ago but now it keeps throwing error.</p>
",qc,error binding parameters quantum circuit p try run circuit pre code import twolocal math import pi twolocal 2 quot rx quot quot cz quot quot linear quot pi 2 pi 3 pi 3 pi 2 quot mpl quot p get error says code object attribute code working perfectly fine sometime ago keeps throwing,"[(0, 0.5009958), (5, 0.05377262), (6, 0.09985087), (14, 0.10772932), (17, 0.019056568), (19, 0.21596003)]"
38051,38063.0,2024-04-30 10:59:31,0,164,"<p>Anyone have any idea how I can implement a depolarizing noise channel for qutrits using cirq? Say using the kraus operators within a class inheriting from cirq.Gate or so?</p>
",How to implement a depolarizing noise channel for qutrits using cirq?,<quantum-state><programming><cirq>,1,0,,,"How to implement a depolarizing noise channel for qutrits using cirq? <p>Anyone have any idea how I can implement a depolarizing noise channel for qutrits using cirq? Say using the kraus operators within a class inheriting from cirq.Gate or so?</p>
",qc,implement depolarizing noise channel qutrits using cirq p anyone idea implement depolarizing noise channel qutrits using cirq say using kraus operators within class inheriting,"[(3, 0.14245686), (9, 0.1439201), (14, 0.5691769), (17, 0.1375469)]"
38076,,2024-05-01 11:47:00,0,36,"<p>I recently read <a href=""https://arxiv.org/pdf/quant-ph/0403025"" rel=""nofollow noreferrer"">Kitaev's paper on magic state distillation</a>. I want to verify whether the circuit for the [5,1,3] encoder can map a single qubit state T_0 to the logical state T_1 in the encoded space. I denote the density matrix of the output state of the quantum circuit as A, and the density matrix of the logical state T_1 in the encoded space as B. The result shows that A and B have completely identical diagonal elements, and the corresponding off-diagonal elements of A and B are different but have equal magnitudes. How should we interpret this result? Can I consider that the single qubit state T_0 has been successfully mapped to the logical state T_1 in the encoded space?Thank you very much
Below are the quantum circuits, density matrices A and B, and their respective local elements.</p>
<p><a href=""https://i.sstatic.net/pMxb0sfg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pMxb0sfg.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/6Up6CtBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6Up6CtBM.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/kErfFdLb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/kErfFdLb.png"" alt=""enter image description here"" /></a></p>
",Two Quantum State Density Matrices with Unequal Off-Diagonal Elements but Equal Magnitudes,<quantum-state><quantum-circuit><magic-states><state-distillation>,1,2,,,"Two Quantum State Density Matrices with Unequal Off-Diagonal Elements but Equal Magnitudes <p>I recently read <a href=""https://arxiv.org/pdf/quant-ph/0403025"" rel=""nofollow noreferrer"">Kitaev's paper on magic state distillation</a>. I want to verify whether the circuit for the [5,1,3] encoder can map a single qubit state T_0 to the logical state T_1 in the encoded space. I denote the density matrix of the output state of the quantum circuit as A, and the density matrix of the logical state T_1 in the encoded space as B. The result shows that A and B have completely identical diagonal elements, and the corresponding off-diagonal elements of A and B are different but have equal magnitudes. How should we interpret this result? Can I consider that the single qubit state T_0 has been successfully mapped to the logical state T_1 in the encoded space?Thank you very much
Below are the quantum circuits, density matrices A and B, and their respective local elements.</p>
<p><a href=""https://i.sstatic.net/pMxb0sfg.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/pMxb0sfg.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/6Up6CtBM.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6Up6CtBM.png"" alt=""enter image description here"" /></a>
<a href=""https://i.sstatic.net/kErfFdLb.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/kErfFdLb.png"" alt=""enter image description here"" /></a></p>
",qc,two quantum state density matrices unequal elements equal magnitudes p recently read https nofollow noreferrer kitaev paper magic state distillation want verify whether circuit encoder map single qubit state logical state encoded space denote density matrix output state quantum circuit density matrix logical state encoded space result shows b completely identical diagonal elements corresponding elements b different equal magnitudes interpret result consider single qubit state successfully mapped logical state encoded space thank much quantum circuits density matrices b respective local p https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description https nofollow noreferrer img https enter image description,"[(3, 0.17917524), (4, 0.45765927), (5, 0.09983868), (11, 0.09245394), (17, 0.025431557), (18, 0.14410953)]"
38081,38086.0,2024-05-01 13:55:01,1,67,"<p>In <a href=""https://www.cs.umd.edu/class/spring2024/cmsc858G/QECCbook-2024-ch1-8.pdf"" rel=""nofollow noreferrer"">this book</a>, Theorem 2.7 has the QECC conditions. I attach a snippet here</p>
<blockquote>
<p>Theorem 2.7 (QECC Conditions). <span class=""math-container"">$(Q, \mathcal{E})$</span> is a <span class=""math-container"">$Q E C C$</span> iff <span class=""math-container"">$\forall|\psi\rangle,|\phi\rangle \in Q, \forall E_a, E_b \in \mathcal{E}$</span>,
<span class=""math-container"">$$
\left\langle\psi\left|E_a^{\dagger} E_b\right| \phi\right\rangle=C_{a b}\langle\psi \mid \phi\rangle .
$$</span></p>
</blockquote>
<p>The proof includes the following</p>
<blockquote>
<p>Taking the adjoint of the equation and putting in <span class=""math-container"">$|\phi\rangle=|\psi\rangle$</span>, we find that <span class=""math-container"">$C_{a b}^{\dagger}=C_{b a}^*$</span>, i.e., the matrix <span class=""math-container"">$C$</span> is Hermitian. Therefore <span class=""math-container"">$C_{a b}$</span> is diagonalizable, and by choosing an appropriate spanning set <span class=""math-container"">$\{F_a\}$</span> for <span class=""math-container"">$\mathcal{E}$</span> we can actually diagonalize <span class=""math-container"">$C_{a b}$</span>.</p>
</blockquote>
<p>I don't understand if <span class=""math-container"">$C_{ab}$</span> is a matrix or a number. The author states multiple times in the proof that <span class=""math-container"">$C_{ab}$</span> is diagonalizable, has eigenvalues etc. but the statement of the theorem seems to suggest it is just a number. How is <span class=""math-container"">$C_{ab}$</span> a matrix in the statement of the theorem and how is it related to <span class=""math-container"">$C$</span> that is referred to in the proof?</p>
","In the QECC condition $\langle\psi|E_a^\dagger E_b|\phi\rangle=C_{ab}\langle\psi|\phi\rangle$, what is $C_{ab}$?",<error-correction><textbook-and-exercises><linear-algebra>,2,0,,,"In the QECC condition $\langle\psi|E_a^\dagger E_b|\phi\rangle=C_{ab}\langle\psi|\phi\rangle$, what is $C_{ab}$? <p>In <a href=""https://www.cs.umd.edu/class/spring2024/cmsc858G/QECCbook-2024-ch1-8.pdf"" rel=""nofollow noreferrer"">this book</a>, Theorem 2.7 has the QECC conditions. I attach a snippet here</p>
<blockquote>
<p>Theorem 2.7 (QECC Conditions). <span class=""math-container"">$(Q, \mathcal{E})$</span> is a <span class=""math-container"">$Q E C C$</span> iff <span class=""math-container"">$\forall|\psi\rangle,|\phi\rangle \in Q, \forall E_a, E_b \in \mathcal{E}$</span>,
<span class=""math-container"">$$
\left\langle\psi\left|E_a^{\dagger} E_b\right| \phi\right\rangle=C_{a b}\langle\psi \mid \phi\rangle .
$$</span></p>
</blockquote>
<p>The proof includes the following</p>
<blockquote>
<p>Taking the adjoint of the equation and putting in <span class=""math-container"">$|\phi\rangle=|\psi\rangle$</span>, we find that <span class=""math-container"">$C_{a b}^{\dagger}=C_{b a}^*$</span>, i.e., the matrix <span class=""math-container"">$C$</span> is Hermitian. Therefore <span class=""math-container"">$C_{a b}$</span> is diagonalizable, and by choosing an appropriate spanning set <span class=""math-container"">$\{F_a\}$</span> for <span class=""math-container"">$\mathcal{E}$</span> we can actually diagonalize <span class=""math-container"">$C_{a b}$</span>.</p>
</blockquote>
<p>I don't understand if <span class=""math-container"">$C_{ab}$</span> is a matrix or a number. The author states multiple times in the proof that <span class=""math-container"">$C_{ab}$</span> is diagonalizable, has eigenvalues etc. but the statement of the theorem seems to suggest it is just a number. How is <span class=""math-container"">$C_{ab}$</span> a matrix in the statement of the theorem and how is it related to <span class=""math-container"">$C$</span> that is referred to in the proof?</p>
",qc,qecc condition ab ab p https nofollow noreferrer book theorem qecc conditions attach snippet blockquote p theorem qecc conditions span q e span q e c c iff span q e span b p proof includes following blockquote p taking adjoint equation putting span find span b b matrix span c hermitian therefore span b diagonalizable choosing appropriate spanning set span span e actually diagonalize span b p understand span ab matrix number author states multiple times proof span ab diagonalizable eigenvalues etc statement theorem seems suggest number span ab matrix statement theorem related span c referred proof,"[(3, 0.70854604), (9, 0.17843558), (10, 0.03794954), (11, 0.024961142), (17, 0.048579082)]"
38131,38150.0,2024-05-03 19:58:17,2,55,"<p>I want to show that antidegradable channels have zero coherent information, based on Exercise 13.5.6 in [<a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">1</a>]. So the solution should use the following relationship: For Hilbert spaces <span class=""math-container"">$R, B, E$</span>, a pure state <span class=""math-container"">$|\phi\rangle_{RBE} \in RBE$</span> obeys (Exercise 11.6.6 in [<a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">1</a>]):
<span class=""math-container"">$$
I(R\rangle B)_\phi = \frac{1}{2}(I(R:B)_\phi - I(R:E)_\phi) \tag{1}
$$</span>
where <span class=""math-container"">$I(\cdot \rangle \cdot)$</span> denotes coherent information.</p>
<hr />
<p>My work so far:</p>
<p>Given an antidegradable channel <span class=""math-container"">$\mathcal{N}$</span> with isometric extension <span class=""math-container"">$V: A \rightarrow BE$</span>, we start with an entangled state <span class=""math-container"">$|\psi\rangle_{RA} \in RA$</span> and apply <span class=""math-container"">$V$</span> to system <span class=""math-container"">$A$</span>, resulting in <span class=""math-container"">$|\phi\rangle_{RBE}$</span>. Then we use antidegradability to show that <span class=""math-container"">$I(R\rangle B)_\phi = 0$</span> in (1).</p>
<p>Say that <span class=""math-container"">$U: E\rightarrow B' E'$</span> is the isometric extension of our antidegradable <span class=""math-container"">$\mathcal{N}$</span>. Antidegradability means that for reduced states
<span class=""math-container"">$$\rho_E = \text{tr}_{RB}|\phi\rangle\langle \phi|_{RBE}\quad\text{  and  } \quad\rho_B = \text{tr}_{RE}|\phi\rangle\langle \phi|_{RBE},$$</span>
<span class=""math-container"">$U$</span> always obeys <span class=""math-container"">$\text{tr}_{E'}(U \rho_E U^\dagger) = \rho_B'$</span>. Applying the isometric extension of the antidegrading map to <span class=""math-container"">$|\phi\rangle_{RBE}$</span> prepares the state
<span class=""math-container"">$$
|\chi\rangle_{RBB'E'}:= (I_{RB}\otimes U)|\phi\rangle_{RBE}
$$</span></p>
<p>With this we can compute
<span class=""math-container"">\begin{align}
I(R:B)_\phi - I(R:E)_\phi &amp;\leq  I(R:B)_\phi - I(R:B')_\chi \qquad\qquad\qquad\qquad \text{data processing inequality} \tag{1}
\\&amp;= H(B)_\phi - H(RB)_\phi + H(RB')_\chi - H(B')_\chi
\\&amp;= - H(RB)_\phi + H(RB')_\chi \qquad\qquad\qquad\qquad \text{by antidegradability}
\\&amp;= -H(E)_\phi + H(BE')_\chi \qquad\qquad\qquad\qquad\, \text{entropy equal across bipartitions}
\end{align}</span></p>
<p>Then I do not know how to proceed. I thought maybe one could argue that applying the map <span class=""math-container"">$V^\dagger: E'B' \rightarrow E$</span> to subsystem <span class=""math-container"">$E'B$</span> should recover a state with entropy <span class=""math-container"">$H(E)$</span>, since <span class=""math-container"">$\rho_B = \rho_{B'}$</span> (using antidegradability). But <span class=""math-container"">$V^\dagger$</span> isn't necessarily an isometry and so I can't make sense of applying it to the system <span class=""math-container"">$BE'$</span> in this way.</p>
<hr />
<p>[<a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">1</a> Wilde, Mark. <em>From Classical to Quantum Shannon Theory</em> (2016). <a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">arXiv:1106.1445</a></p>
",Prove that the coherent information of an antidegradable channel is equal to zero,<information-theory><channel-capacity><coherent-information>,1,0,,,"Prove that the coherent information of an antidegradable channel is equal to zero <p>I want to show that antidegradable channels have zero coherent information, based on Exercise 13.5.6 in [<a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">1</a>]. So the solution should use the following relationship: For Hilbert spaces <span class=""math-container"">$R, B, E$</span>, a pure state <span class=""math-container"">$|\phi\rangle_{RBE} \in RBE$</span> obeys (Exercise 11.6.6 in [<a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">1</a>]):
<span class=""math-container"">$$
I(R\rangle B)_\phi = \frac{1}{2}(I(R:B)_\phi - I(R:E)_\phi) \tag{1}
$$</span>
where <span class=""math-container"">$I(\cdot \rangle \cdot)$</span> denotes coherent information.</p>
<hr />
<p>My work so far:</p>
<p>Given an antidegradable channel <span class=""math-container"">$\mathcal{N}$</span> with isometric extension <span class=""math-container"">$V: A \rightarrow BE$</span>, we start with an entangled state <span class=""math-container"">$|\psi\rangle_{RA} \in RA$</span> and apply <span class=""math-container"">$V$</span> to system <span class=""math-container"">$A$</span>, resulting in <span class=""math-container"">$|\phi\rangle_{RBE}$</span>. Then we use antidegradability to show that <span class=""math-container"">$I(R\rangle B)_\phi = 0$</span> in (1).</p>
<p>Say that <span class=""math-container"">$U: E\rightarrow B' E'$</span> is the isometric extension of our antidegradable <span class=""math-container"">$\mathcal{N}$</span>. Antidegradability means that for reduced states
<span class=""math-container"">$$\rho_E = \text{tr}_{RB}|\phi\rangle\langle \phi|_{RBE}\quad\text{  and  } \quad\rho_B = \text{tr}_{RE}|\phi\rangle\langle \phi|_{RBE},$$</span>
<span class=""math-container"">$U$</span> always obeys <span class=""math-container"">$\text{tr}_{E'}(U \rho_E U^\dagger) = \rho_B'$</span>. Applying the isometric extension of the antidegrading map to <span class=""math-container"">$|\phi\rangle_{RBE}$</span> prepares the state
<span class=""math-container"">$$
|\chi\rangle_{RBB'E'}:= (I_{RB}\otimes U)|\phi\rangle_{RBE}
$$</span></p>
<p>With this we can compute
<span class=""math-container"">\begin{align}
I(R:B)_\phi - I(R:E)_\phi &amp;\leq  I(R:B)_\phi - I(R:B')_\chi \qquad\qquad\qquad\qquad \text{data processing inequality} \tag{1}
\\&amp;= H(B)_\phi - H(RB)_\phi + H(RB')_\chi - H(B')_\chi
\\&amp;= - H(RB)_\phi + H(RB')_\chi \qquad\qquad\qquad\qquad \text{by antidegradability}
\\&amp;= -H(E)_\phi + H(BE')_\chi \qquad\qquad\qquad\qquad\, \text{entropy equal across bipartitions}
\end{align}</span></p>
<p>Then I do not know how to proceed. I thought maybe one could argue that applying the map <span class=""math-container"">$V^\dagger: E'B' \rightarrow E$</span> to subsystem <span class=""math-container"">$E'B$</span> should recover a state with entropy <span class=""math-container"">$H(E)$</span>, since <span class=""math-container"">$\rho_B = \rho_{B'}$</span> (using antidegradability). But <span class=""math-container"">$V^\dagger$</span> isn't necessarily an isometry and so I can't make sense of applying it to the system <span class=""math-container"">$BE'$</span> in this way.</p>
<hr />
<p>[<a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">1</a> Wilde, Mark. <em>From Classical to Quantum Shannon Theory</em> (2016). <a href=""https://arxiv.org/abs/1106.1445"" rel=""nofollow noreferrer"">arXiv:1106.1445</a></p>
",qc,prove coherent information antidegradable channel equal zero p want show antidegradable channels zero coherent information based exercise https nofollow noreferrer 1 solution use following relationship hilbert spaces span r b e pure state span rbe rbe obeys exercise https nofollow noreferrer 1 span b 1 2 r b r e 1 span denotes coherent hr p work far p given antidegradable channel span n isometric extension span v start entangled state span ra ra apply span v system span resulting span rbe use antidegradability show span b 0 1 p say span u b e isometric extension antidegradable span n antidegradability means reduced states span tr rb rbe tr rbe span u always obeys span tr e u applying isometric extension antidegrading map span rbe prepares state span rbb e rb u rbe p compute span align r b r e amp r b r b data processing inequality 1 amp h b h rb h rb h b amp h rb h rb antidegradability amp e h entropy equal across bipartitions align p know proceed thought maybe one could argue applying map span e b e subsystem span e b recover state entropy span h e since span b using antidegradability span necessarily isometry ca make sense applying system span hr p https nofollow noreferrer 1 wilde mark em classical quantum shannon theory 2016 https nofollow noreferrer,"[(2, 0.012531389), (3, 0.73735017), (4, 0.055251054), (11, 0.034324504), (15, 0.043794528), (17, 0.015653923), (18, 0.10051881)]"
38197,38214.0,2024-05-08 06:14:41,5,337,"<p>In a recent experimental <a href=""https://arxiv.org/pdf/2404.02280"" rel=""noreferrer"">paper</a>, Microsoft with IonQ claimed that they demonstrated the &quot;repeated error correction&quot; with both the <span class=""math-container"">$[[7, 1, 3]]$</span> Steane code and the <span class=""math-container"">$[[12, 2, 4]]$</span> &quot;Carbon&quot; code, both of which are <strong>self-dual CSS codes</strong>.</p>
<p>I am particularly interested in the stabilizer description of the <strong>Carbon code</strong>, as the code reminds me the recent related work in the <a href=""https://arxiv.org/pdf/2403.16054"" rel=""noreferrer"">many-hypercube codes</a> or the <a href=""https://arxiv.org/pdf/2402.09606"" rel=""noreferrer"">concatenated C4/C6 code</a>. However, I didn't find any explicit description of the code in the original paper.</p>
<p>Does anyone know what on earth the Carbon code looks like? Or is there a way that we could speculate the stabilizer set of the code with the parameter <span class=""math-container"">$[[12, 2, 4]]$</span> and its self-dual property?</p>
","Stabilizers of the [[12, 2, 4]] ""Carbon"" code",<error-correction><stabilizer-code>,2,0,,,"Stabilizers of the [[12, 2, 4]] ""Carbon"" code <p>In a recent experimental <a href=""https://arxiv.org/pdf/2404.02280"" rel=""noreferrer"">paper</a>, Microsoft with IonQ claimed that they demonstrated the &quot;repeated error correction&quot; with both the <span class=""math-container"">$[[7, 1, 3]]$</span> Steane code and the <span class=""math-container"">$[[12, 2, 4]]$</span> &quot;Carbon&quot; code, both of which are <strong>self-dual CSS codes</strong>.</p>
<p>I am particularly interested in the stabilizer description of the <strong>Carbon code</strong>, as the code reminds me the recent related work in the <a href=""https://arxiv.org/pdf/2403.16054"" rel=""noreferrer"">many-hypercube codes</a> or the <a href=""https://arxiv.org/pdf/2402.09606"" rel=""noreferrer"">concatenated C4/C6 code</a>. However, I didn't find any explicit description of the code in the original paper.</p>
<p>Does anyone know what on earth the Carbon code looks like? Or is there a way that we could speculate the stabilizer set of the code with the parameter <span class=""math-container"">$[[12, 2, 4]]$</span> and its self-dual property?</p>
",qc,stabilizers 12 2 4 carbon code p recent experimental https noreferrer paper microsoft ionq claimed demonstrated quot repeated error correction quot span 7 1 3 steane code span 12 2 4 quot carbon quot code strong css codes p particularly interested stabilizer description strong carbon code code reminds recent related work https noreferrer codes https noreferrer concatenated code however find explicit description code original p anyone know earth carbon code looks like way could speculate stabilizer set code parameter span 12 2 4 property,"[(3, 0.024913233), (4, 0.12051003), (5, 0.30369908), (6, 0.14155062), (7, 0.13632725), (9, 0.19498362), (11, 0.012649085), (17, 0.012480676), (19, 0.051547274)]"
38206,,2024-05-08 14:26:42,5,162,"<p>I am interested in the theory of implementing logical gates on quantum error correcting codes. From a practical view, transversal gates are very attractive. I have a question about transversal gates.</p>
<p><strong>Background</strong></p>
<p>Here on stack exchange, I find many statements such as &quot;Stabilizer code <span class=""math-container"">$\mathcal{G}$</span> is a CSS code if and only if <span class=""math-container"">$\mathcal{G}$</span> has transversal CNOT.&quot;(copied from a very nice answer to <a href=""https://quantumcomputing.stackexchange.com/questions/15432/css-code-in-disguise"">this question</a>). These kind of statements are also to be found in other posts, for example <a href=""https://quantumcomputing.stackexchange.com/questions/15301/transversal-logical-gate-for-stabilizer-or-at-least-steane-code"">here</a>. Also, places like the <a href=""https://errorcorrectionzoo.org/c/qubit_css#citation-20"" rel=""noreferrer"">error correction zoo page for CSS codes</a> just write &quot;All CSS codes admit transversal Pauli and CNOT gates&quot; (In the section &quot;Transversal gates&quot;).</p>
<p>What is in these two situation meant by transversal CNOT is - if I understand correctly - the following: If you have two copies <span class=""math-container"">$\mathcal{C}_1$</span>, <span class=""math-container"">$\mathcal{C}_2$</span> of a <span class=""math-container"">$[[n,k,d]]$</span>-CSS code <span class=""math-container"">$\mathcal{C}$</span> with physical qubits <span class=""math-container"">$q_1, \dots , q_n$</span> and apply CNOT between <span class=""math-container"">$q_1$</span> in the first code and <span class=""math-container"">$q_1$</span> in the second code and same for <span class=""math-container"">$q_2, \dots , q_n$</span>, then</p>
<ul>
<li>this preserves the code space. This is because an <span class=""math-container"">$X$</span> type stabiliser <span class=""math-container"">$S_X \otimes id$</span> of <span class=""math-container"">$\mathcal{C}_1$</span> gets mapped to <span class=""math-container"">$S_X \otimes S_X$</span>, that is, the same <span class=""math-container"">$X$</span>-type stabiliser on both codes, and <span class=""math-container"">$id \otimes S_X$</span> get mapped to <span class=""math-container"">$id \otimes S_X$</span>. So the <span class=""math-container"">$X$</span> type stabilisers for the two codes together are exactly preserved. Similar reasoning holds for the <span class=""math-container"">$Z$</span>-type stabilisers.</li>
<li>this, with the same reasoning as for the stabilisers, performs a logical CNOT between the logical qubits. Namely, if we say <span class=""math-container"">$\bar{X}_1, \dots , \bar{X}_k$</span> are independent choices logical <span class=""math-container"">$X$</span> operators that are products of <span class=""math-container"">$X$</span> and <span class=""math-container"">$id$</span> on the physical qubits, then applying all these CNOT gates on the physical qubits of the two codes will transform <span class=""math-container"">$\bar{X}_i \otimes \bar{id}$</span> to <span class=""math-container"">$\bar{X}_i \otimes \bar{X}_i$</span> for <span class=""math-container"">$i = 1 \dots k$</span> and similarly <span class=""math-container"">$\bar{id} \otimes \bar{X}_i$</span> gets transformed to <span class=""math-container"">$\bar{id} \otimes \bar{X}_i$</span>. So what this operation did is, it applied all of the gates <span class=""math-container"">$CNOT_1, \dots , CNOT_k$</span> if my reasoning is correct.</li>
</ul>
<p><strong>My question</strong></p>
<p>My question is the following: Can I do more &quot;targeted&quot; CNOT gates on CSS codes. For example, the toric code encodes two logical qubits <span class=""math-container"">$q_1$</span> and <span class=""math-container"">$q_2$</span>. Can I transversally apply a CNOT between two copies of the toric code, but only the CNOT between one qubit in the first code and one in the second one? Here a very informal drawing:</p>
<p><a href=""https://i.sstatic.net/mdpGTmeD.jpg"" rel=""noreferrer""><img src=""https://i.sstatic.net/mdpGTmeD.jpg"" alt=""enter image description here"" /></a></p>
<p>One naïve idea would be to apply CNOT between qubits involved in the corresponding logical <span class=""math-container"">$X$</span> operator, but for the toric code, it doesn't seem to preserve the stabiliser group.</p>
<p>So very concretely, my questions are:</p>
<ul>
<li>Very practically and hands-on: Can I transversally apply the &quot;single&quot; CNOT on the toric code transversally? It would be totally fine if transversality here does not mean &quot;a product of physical CNOTs between the two code patches&quot; but the less restrictive &quot;a product of physical one-qubit gates and physical two-qubit gates between the patches&quot;.</li>
<li>More generally, for CSS code, is there any theory on which logical CNOTs one can actually do transversally? Is there more hiding behind the narrative that &quot;CSS codes have transversal CNOT&quot; than what I elaborated above? Is there a theory of which transversal CNOTs are possible on CSS codes? For example, for color codes, one often reads that 2D color codes can implement the Clifford group transversally. I completely see how that is true for color codes that encode only one qubit, but not for color codes with more than one logical qubit.</li>
</ul>
",Transversal CNOTs on CSS codes with multiple logical qubits,<error-correction><logical-gates><css>,2,1,,,"Transversal CNOTs on CSS codes with multiple logical qubits <p>I am interested in the theory of implementing logical gates on quantum error correcting codes. From a practical view, transversal gates are very attractive. I have a question about transversal gates.</p>
<p><strong>Background</strong></p>
<p>Here on stack exchange, I find many statements such as &quot;Stabilizer code <span class=""math-container"">$\mathcal{G}$</span> is a CSS code if and only if <span class=""math-container"">$\mathcal{G}$</span> has transversal CNOT.&quot;(copied from a very nice answer to <a href=""https://quantumcomputing.stackexchange.com/questions/15432/css-code-in-disguise"">this question</a>). These kind of statements are also to be found in other posts, for example <a href=""https://quantumcomputing.stackexchange.com/questions/15301/transversal-logical-gate-for-stabilizer-or-at-least-steane-code"">here</a>. Also, places like the <a href=""https://errorcorrectionzoo.org/c/qubit_css#citation-20"" rel=""noreferrer"">error correction zoo page for CSS codes</a> just write &quot;All CSS codes admit transversal Pauli and CNOT gates&quot; (In the section &quot;Transversal gates&quot;).</p>
<p>What is in these two situation meant by transversal CNOT is - if I understand correctly - the following: If you have two copies <span class=""math-container"">$\mathcal{C}_1$</span>, <span class=""math-container"">$\mathcal{C}_2$</span> of a <span class=""math-container"">$[[n,k,d]]$</span>-CSS code <span class=""math-container"">$\mathcal{C}$</span> with physical qubits <span class=""math-container"">$q_1, \dots , q_n$</span> and apply CNOT between <span class=""math-container"">$q_1$</span> in the first code and <span class=""math-container"">$q_1$</span> in the second code and same for <span class=""math-container"">$q_2, \dots , q_n$</span>, then</p>
<ul>
<li>this preserves the code space. This is because an <span class=""math-container"">$X$</span> type stabiliser <span class=""math-container"">$S_X \otimes id$</span> of <span class=""math-container"">$\mathcal{C}_1$</span> gets mapped to <span class=""math-container"">$S_X \otimes S_X$</span>, that is, the same <span class=""math-container"">$X$</span>-type stabiliser on both codes, and <span class=""math-container"">$id \otimes S_X$</span> get mapped to <span class=""math-container"">$id \otimes S_X$</span>. So the <span class=""math-container"">$X$</span> type stabilisers for the two codes together are exactly preserved. Similar reasoning holds for the <span class=""math-container"">$Z$</span>-type stabilisers.</li>
<li>this, with the same reasoning as for the stabilisers, performs a logical CNOT between the logical qubits. Namely, if we say <span class=""math-container"">$\bar{X}_1, \dots , \bar{X}_k$</span> are independent choices logical <span class=""math-container"">$X$</span> operators that are products of <span class=""math-container"">$X$</span> and <span class=""math-container"">$id$</span> on the physical qubits, then applying all these CNOT gates on the physical qubits of the two codes will transform <span class=""math-container"">$\bar{X}_i \otimes \bar{id}$</span> to <span class=""math-container"">$\bar{X}_i \otimes \bar{X}_i$</span> for <span class=""math-container"">$i = 1 \dots k$</span> and similarly <span class=""math-container"">$\bar{id} \otimes \bar{X}_i$</span> gets transformed to <span class=""math-container"">$\bar{id} \otimes \bar{X}_i$</span>. So what this operation did is, it applied all of the gates <span class=""math-container"">$CNOT_1, \dots , CNOT_k$</span> if my reasoning is correct.</li>
</ul>
<p><strong>My question</strong></p>
<p>My question is the following: Can I do more &quot;targeted&quot; CNOT gates on CSS codes. For example, the toric code encodes two logical qubits <span class=""math-container"">$q_1$</span> and <span class=""math-container"">$q_2$</span>. Can I transversally apply a CNOT between two copies of the toric code, but only the CNOT between one qubit in the first code and one in the second one? Here a very informal drawing:</p>
<p><a href=""https://i.sstatic.net/mdpGTmeD.jpg"" rel=""noreferrer""><img src=""https://i.sstatic.net/mdpGTmeD.jpg"" alt=""enter image description here"" /></a></p>
<p>One naïve idea would be to apply CNOT between qubits involved in the corresponding logical <span class=""math-container"">$X$</span> operator, but for the toric code, it doesn't seem to preserve the stabiliser group.</p>
<p>So very concretely, my questions are:</p>
<ul>
<li>Very practically and hands-on: Can I transversally apply the &quot;single&quot; CNOT on the toric code transversally? It would be totally fine if transversality here does not mean &quot;a product of physical CNOTs between the two code patches&quot; but the less restrictive &quot;a product of physical one-qubit gates and physical two-qubit gates between the patches&quot;.</li>
<li>More generally, for CSS code, is there any theory on which logical CNOTs one can actually do transversally? Is there more hiding behind the narrative that &quot;CSS codes have transversal CNOT&quot; than what I elaborated above? Is there a theory of which transversal CNOTs are possible on CSS codes? For example, for color codes, one often reads that 2D color codes can implement the Clifford group transversally. I completely see how that is true for color codes that encode only one qubit, but not for color codes with more than one logical qubit.</li>
</ul>
",qc,transversal cnots css codes multiple logical qubits p interested theory implementing logical gates quantum error correcting codes practical view transversal gates attractive question transversal p strong background p stack exchange find many statements quot stabilizer code span g css code span g transversal quot copied nice answer https question kind statements also found posts example https also places like https noreferrer error correction zoo page css codes write quot css codes admit transversal pauli cnot gates quot section quot transversal gates quot p two situation meant transversal cnot understand correctly following two copies span c span c span n k code span c physical qubits span apply cnot span first code span second code span ul li preserves code space span x type stabiliser span id span c gets mapped span span x stabiliser codes span id get mapped span id span x type stabilisers two codes together exactly preserved similar reasoning holds span z li reasoning stabilisers performs logical cnot logical qubits namely say span x x independent choices logical span x operators products span x span id physical qubits applying cnot gates physical qubits two codes transform span x id span x x span 1 k similarly span id x gets transformed span id x operation applied gates span reasoning p strong question p question following quot targeted quot cnot gates css codes example toric code encodes two logical qubits span span transversally apply cnot two copies toric code cnot one qubit first code one second one informal drawing p https noreferrer img https enter image description p one naïve idea would apply cnot qubits involved corresponding logical span x operator toric code seem preserve stabiliser p concretely questions ul li practically transversally apply quot single quot cnot toric code transversally would totally fine transversality mean quot product physical cnots two code patches quot less restrictive quot product physical gates physical gates patches quot li generally css code theory logical cnots one actually transversally hiding behind narrative quot css codes transversal cnot quot elaborated theory transversal cnots possible css codes example color codes one often reads 2d color codes implement clifford group transversally completely see true color codes encode one qubit color codes one logical,"[(3, 0.22382157), (4, 0.0253575), (5, 0.33971673), (9, 0.28186846), (10, 0.03839253), (17, 0.034615956), (19, 0.0558719)]"
38217,38219.0,2024-05-09 07:23:53,0,51,"<p>I am simulating a surface code where the edges in the syndrome graph change slightly from shot to shot based on erasures that occur in the circuit <em>(i.e. I have a syndrome graph corresponding to the case of no erasures and only Pauli errors and for every shot some of the edges are replaced with edges corresponding to an erasure in that position)</em>.</p>
<p>In order to save time, I would like to generate the <code>pymatching.Matching</code> object once and then modify it for every shot, replacing/adding relevant edges.</p>
<p>I had two ideas how to go about this but both cause some issues:</p>
<ol>
<li>Create a <code>copy.copy</code> of the <code>Matching</code> object. This does not work since a shallow copy does not copy the matching graph and adding an edge to the copy also adds it to the original. <code>copy.deepcopy</code> does not work either, however, since it throws an error (<code>TypeError: cannot pickle 'pymatching._cpp_pymatching.MatchingGraph' object</code>).<br />
<em>(Additionally: I am not quite sure but I guess this method has the potential to be almost as slow as or even slower than loading the <code>Matching</code> object from a modified <code>stim.DetectorErrorModel</code> every time?)</em></li>
<li>Before adding an edge, check if that edge already exists and replace the new edges with the original edges after every shot. This does not work, since I cannot find a <code>remove_edge</code> function, which would be necessary if the edge to be added was not in the syndrome graph to begin with. <br />
A workaround might be to set the weight of this edge to the maximum value (and the probability to 0) but that does not seem very elegant, especially since later shots would potentially have to deal with a steadily growing number of &quot;ghost edges&quot; with maximal weights, that would connect otherwise disjunct parts of the syndrome graph.</li>
</ol>
<p>Am I missing something? Is there another (reasonably fast) way to get a deepcopy or to completely remove edges from the matching graph?</p>
",Remove edges from PyMatching matching graph / Copy Matching object,<error-correction><simulation><stim><pymatching>,1,0,,,"Remove edges from PyMatching matching graph / Copy Matching object <p>I am simulating a surface code where the edges in the syndrome graph change slightly from shot to shot based on erasures that occur in the circuit <em>(i.e. I have a syndrome graph corresponding to the case of no erasures and only Pauli errors and for every shot some of the edges are replaced with edges corresponding to an erasure in that position)</em>.</p>
<p>In order to save time, I would like to generate the <code>pymatching.Matching</code> object once and then modify it for every shot, replacing/adding relevant edges.</p>
<p>I had two ideas how to go about this but both cause some issues:</p>
<ol>
<li>Create a <code>copy.copy</code> of the <code>Matching</code> object. This does not work since a shallow copy does not copy the matching graph and adding an edge to the copy also adds it to the original. <code>copy.deepcopy</code> does not work either, however, since it throws an error (<code>TypeError: cannot pickle 'pymatching._cpp_pymatching.MatchingGraph' object</code>).<br />
<em>(Additionally: I am not quite sure but I guess this method has the potential to be almost as slow as or even slower than loading the <code>Matching</code> object from a modified <code>stim.DetectorErrorModel</code> every time?)</em></li>
<li>Before adding an edge, check if that edge already exists and replace the new edges with the original edges after every shot. This does not work, since I cannot find a <code>remove_edge</code> function, which would be necessary if the edge to be added was not in the syndrome graph to begin with. <br />
A workaround might be to set the weight of this edge to the maximum value (and the probability to 0) but that does not seem very elegant, especially since later shots would potentially have to deal with a steadily growing number of &quot;ghost edges&quot; with maximal weights, that would connect otherwise disjunct parts of the syndrome graph.</li>
</ol>
<p>Am I missing something? Is there another (reasonably fast) way to get a deepcopy or to completely remove edges from the matching graph?</p>
",qc,remove edges pymatching matching graph copy matching object p simulating surface code edges syndrome graph change slightly shot shot based erasures occur circuit em syndrome graph corresponding case erasures pauli errors every shot edges replaced edges corresponding erasure position p order save time would like generate code object modify every shot relevant p two ideas go cause issues ol li create code code matching object work since shallow copy copy matching graph adding edge copy also adds original code work either however since throws error code typeerror pickle object br em additionally quite sure guess method potential almost slow even slower loading code matching object modified code every time li adding edge check edge already exists replace new edges original edges every shot work since find code function would necessary edge added syndrome graph begin br workaround might set weight edge maximum value probability 0 seem elegant especially since later shots would potentially deal steadily growing number quot ghost edges quot maximal weights would connect otherwise disjunct parts syndrome p missing something another reasonably fast way get deepcopy completely remove edges matching graph,"[(5, 0.11507164), (8, 0.08434668), (13, 0.32385615), (14, 0.36928177), (17, 0.0597082), (18, 0.016367087), (19, 0.024875443)]"
38312,,2024-05-15 15:27:57,1,40,"<p>Suppose I have a 30 qbit system, due to computational complexity, I can't find the density matrix of the system. But is it possible to find the partial trace of the  a sub-system of 2 qubits out of 30 without explicitly finding the density matrix?</p>
",Finding partial trace in CIRQ,<cirq>,0,3,,,"Finding partial trace in CIRQ <p>Suppose I have a 30 qbit system, due to computational complexity, I can't find the density matrix of the system. But is it possible to find the partial trace of the  a sub-system of 2 qubits out of 30 without explicitly finding the density matrix?</p>
",qc,finding partial trace cirq p suppose 30 qbit system due computational complexity ca find density matrix system possible find partial trace 2 qubits 30 without explicitly finding density matrix,"[(3, 0.2845329), (7, 0.2139327), (11, 0.1964133), (13, 0.049212392), (16, 0.03451235), (17, 0.07807319), (18, 0.13886948)]"
38323,,2024-05-16 03:20:26,3,170,"<p>I'm currently trying to implement the depolarizing channel on qiskit. But, as I see in my calculation it doesn't match with the qiskit aer_noise.</p>
<p>So, for the Depolarizing Channel we got :
<span class=""math-container"">$$
\mathcal{E}(\rho) = (1 - p) \rho + p \frac{I}{2}
$$</span></p>
<p>Ant the choi matrix equation is:
<span class=""math-container"">$$
\Lambda_\mathcal{E} = (\mathcal{I} \otimes \mathcal{E})(|\Phi\rangle \langle \Phi|)
$$</span>
So, this is the tricky part where i get lost, I know that the Choi matrix got the Channel acting in every ketbra on the base, so in this case, for a one qubit i got:
<span class=""math-container"">$$
\mathcal{E}(|0\rangle \langle 1|) = (1-p) |0\rangle \langle 1| + p/2 (|0\rangle \langle 0| + |1\rangle \langle 1|)
$$</span>
<span class=""math-container"">$$
\mathcal{E}(|1\rangle \langle 0|) = (1-p) |1\rangle \langle 0| + p/2 (|0\rangle \langle 0| + |1\rangle \langle 1|)
$$</span>
<span class=""math-container"">$$
\mathcal{E}(|0\rangle \langle 0|) = (1-p/2) (|0\rangle \langle 0|) + p/2 (|1\rangle \langle 1|)
$$</span>
<span class=""math-container"">$$
\mathcal{E}(|1\rangle \langle 1|) = (1-p/2) (|1\rangle \langle 1|) + p/2 (|0\rangle \langle 0|)
$$</span></p>
<p>Sho, the Choi matrix for this channel would be
<span class=""math-container"">$$ \Lambda_\mathcal{E}=
\begin{pmatrix}
1 - \frac{p}{2} &amp; 0 &amp; \frac{p}{2} &amp; 1 - p \\
0 &amp; \frac{p}{2} &amp; 0 &amp; \frac{p}{2} \\
\frac{p}{2} &amp; 0 &amp; \frac{p}{2} &amp; 0 \\
1 - p &amp; \frac{p}{2} &amp; 0 &amp; 1 - \frac{p}{2}
\end{pmatrix}
$$</span>.
However, if I use the qiskit funciton aer.get_noise and later use the Choi(noise) i get the form :
<span class=""math-container"">$$ \Lambda_\mathcal{E}=
\begin{pmatrix}
1 - \frac{p}{2} &amp; 0 &amp; 0 &amp; 1 - p \\
0 &amp; \frac{p}{2} &amp; 0 &amp; 0\\
0 &amp; 0 &amp; \frac{p}{2} &amp; 0 \\
1 - p &amp; 0 &amp; 0 &amp; 1 - \frac{p}{2}
\end{pmatrix}
$$</span>.</p>
<p>Can someone help me to understand why is the second form? Thanks.</p>
",Why is the Choi matrix I get for the depolarizing channel $\mathcal{E}(\rho) = (1 - p) \rho + p \frac{I}{2}$ different from what it shold be?,<qiskit><kraus-representation><quantum-process-tomography><depolarizing-channel>,1,1,,,"Why is the Choi matrix I get for the depolarizing channel $\mathcal{E}(\rho) = (1 - p) \rho + p \frac{I}{2}$ different from what it shold be? <p>I'm currently trying to implement the depolarizing channel on qiskit. But, as I see in my calculation it doesn't match with the qiskit aer_noise.</p>
<p>So, for the Depolarizing Channel we got :
<span class=""math-container"">$$
\mathcal{E}(\rho) = (1 - p) \rho + p \frac{I}{2}
$$</span></p>
<p>Ant the choi matrix equation is:
<span class=""math-container"">$$
\Lambda_\mathcal{E} = (\mathcal{I} \otimes \mathcal{E})(|\Phi\rangle \langle \Phi|)
$$</span>
So, this is the tricky part where i get lost, I know that the Choi matrix got the Channel acting in every ketbra on the base, so in this case, for a one qubit i got:
<span class=""math-container"">$$
\mathcal{E}(|0\rangle \langle 1|) = (1-p) |0\rangle \langle 1| + p/2 (|0\rangle \langle 0| + |1\rangle \langle 1|)
$$</span>
<span class=""math-container"">$$
\mathcal{E}(|1\rangle \langle 0|) = (1-p) |1\rangle \langle 0| + p/2 (|0\rangle \langle 0| + |1\rangle \langle 1|)
$$</span>
<span class=""math-container"">$$
\mathcal{E}(|0\rangle \langle 0|) = (1-p/2) (|0\rangle \langle 0|) + p/2 (|1\rangle \langle 1|)
$$</span>
<span class=""math-container"">$$
\mathcal{E}(|1\rangle \langle 1|) = (1-p/2) (|1\rangle \langle 1|) + p/2 (|0\rangle \langle 0|)
$$</span></p>
<p>Sho, the Choi matrix for this channel would be
<span class=""math-container"">$$ \Lambda_\mathcal{E}=
\begin{pmatrix}
1 - \frac{p}{2} &amp; 0 &amp; \frac{p}{2} &amp; 1 - p \\
0 &amp; \frac{p}{2} &amp; 0 &amp; \frac{p}{2} \\
\frac{p}{2} &amp; 0 &amp; \frac{p}{2} &amp; 0 \\
1 - p &amp; \frac{p}{2} &amp; 0 &amp; 1 - \frac{p}{2}
\end{pmatrix}
$$</span>.
However, if I use the qiskit funciton aer.get_noise and later use the Choi(noise) i get the form :
<span class=""math-container"">$$ \Lambda_\mathcal{E}=
\begin{pmatrix}
1 - \frac{p}{2} &amp; 0 &amp; 0 &amp; 1 - p \\
0 &amp; \frac{p}{2} &amp; 0 &amp; 0\\
0 &amp; 0 &amp; \frac{p}{2} &amp; 0 \\
1 - p &amp; 0 &amp; 0 &amp; 1 - \frac{p}{2}
\end{pmatrix}
$$</span>.</p>
<p>Can someone help me to understand why is the second form? Thanks.</p>
",qc,choi matrix get depolarizing channel e 1 p p 2 different shold p currently trying implement depolarizing channel qiskit see calculation match qiskit p depolarizing channel got span e 1 p p 2 p ant choi matrix equation span e e tricky part get lost know choi matrix got channel acting every ketbra base case one qubit got span e span e span e span e p sho choi matrix channel would span e pmatrix 1 p 2 amp 0 amp p 2 amp 1 p 0 amp p 2 amp 0 amp p 2 p 2 amp 0 amp p 2 amp 0 1 p amp p 2 amp 0 amp 1 p 2 pmatrix however use qiskit funciton later use choi noise get form span e pmatrix 1 p 2 amp 0 amp 0 amp 1 p 0 amp p 2 amp 0 amp 0 amp 0 amp p 2 amp 0 1 p amp 0 amp 0 amp 1 p 2 pmatrix p someone help understand second form,"[(2, 0.23049676), (3, 0.1731104), (14, 0.10728048), (15, 0.45777288), (17, 0.0304366)]"
38435,,2024-05-22 11:49:17,0,56,"<p>I am trying to parallelise the function: <code>matching.decode_to_edges_array()</code> to somewhat batch decode, but I am consistently running into the same problem:</p>
<p><code>TypeError: cannot pickle 'pymatching._cpp_pymatching.MatchingGraph' object</code> .</p>
<p>Any help will be much appreciated! I also want to ask if anyone knows why the batch decode equivalent is not available for this function, it would have been very useful for any sort of correlated decoder. What is the technical reason for not being able to batch decode to edges?</p>
<p>Thanks!</p>
",Parallelizing decode_to_edges_array (PyMatching),<error-correction><stim><pymatching>,1,0,,,"Parallelizing decode_to_edges_array (PyMatching) <p>I am trying to parallelise the function: <code>matching.decode_to_edges_array()</code> to somewhat batch decode, but I am consistently running into the same problem:</p>
<p><code>TypeError: cannot pickle 'pymatching._cpp_pymatching.MatchingGraph' object</code> .</p>
<p>Any help will be much appreciated! I also want to ask if anyone knows why the batch decode equivalent is not available for this function, it would have been very useful for any sort of correlated decoder. What is the technical reason for not being able to batch decode to edges?</p>
<p>Thanks!</p>
",qc,parallelizing pymatching p trying parallelise function code somewhat batch decode consistently running problem p code typeerror pickle object p help much appreciated also want ask anyone knows batch decode equivalent available function would useful sort correlated decoder technical reason able batch decode edges p thanks,"[(0, 0.093713254), (5, 0.17420794), (8, 0.31574872), (13, 0.32000336), (16, 0.065820955), (17, 0.027405519)]"
38440,,2024-05-22 18:00:43,4,90,"<p>I came across the following exercise (2.73) in Nielsen &amp; Chuang and am trying to understand it intuitively.</p>
<p>Here is my reasoning of what is going on:</p>
<p>The purpose of this exercise:</p>
<p>Let’s say we are given a density matrix, <span class=""math-container"">$\rho$</span>. We are finding a way to decompose it into an ensemble of pure states. One way would be to decompose it into its eigenvectors, and the corresponding probabilities are the eigenvalues. However, in this exercise, we are finding a more general approach to decomposing the density matrix into any ensemble of pure states, but the ensemble of pure states must span the vector space that the eigenvectors span.</p>
<p>How?</p>
<p>1). We take an arbitrary state vector, <span class=""math-container"">$|\psi\rangle$</span>, with the condition that it must be in the support of <span class=""math-container"">$\rho$</span>. The support of <span class=""math-container"">$\rho$</span> is the vector space that <span class=""math-container"">$\rho$</span> lives in.</p>
<p>2). We take the inverse of the density matrix, which inverts the eigenvalues (or probabilities) for each eigenvector of the density matrix. This inversion leaves us with low probabilities for eigenvectors that account for most of <span class=""math-container"">$\rho$</span>, and high probabilities for eigenvectors that don’t contribute to <span class=""math-container"">$\rho$</span> as much</p>
<p>3). Now, we take the expectation of our arbitrary state, <span class=""math-container"">$|\psi\rangle$</span>, with the inverted density matrix. To understand this expectation, let’s think about the expectation value if we left out all the eigenvalues. We would calculate the inner product of <span class=""math-container"">$|\psi\rangle$</span> with each eigenvector, and the result should be one because the eigenvectors span the vector space, so a linear combination of them should return exactly <span class=""math-container"">$|\psi\rangle$</span>. Now, if we include the eigenvalues (not inverted), the result will tell us which direction (combination of eigenvector) <span class=""math-container"">$|\psi\rangle$</span> most closely aligns with, by adding together eigenvalues for all the different directions weighted by the inner product with that eigenvector. This just tells how much of our system represented by our density matrix is in the state <span class=""math-container"">$|\psi\rangle$</span>, or the probability that our system is in the state <span class=""math-container"">$|\psi\rangle$</span>.</p>
<p>Where is the flaw in my reasoning? And what is the correct explanation of what is going on in this exercise?</p>
<p><a href=""https://i.sstatic.net/0bfyDObC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0bfyDObC.png"" alt=""enter image description here"" /></a></p>
",Why do minimal ensemble decompositions for $\rho$ contain $|\psi⟩\in{\rm supp}(\rho)$ with probability $1/\langle\psi|\rho^{-1}|\psi⟩?$,<textbook-and-exercises><density-matrix><nielsen-and-chuang>,2,0,,,"Why do minimal ensemble decompositions for $\rho$ contain $|\psi⟩\in{\rm supp}(\rho)$ with probability $1/\langle\psi|\rho^{-1}|\psi⟩?$ <p>I came across the following exercise (2.73) in Nielsen &amp; Chuang and am trying to understand it intuitively.</p>
<p>Here is my reasoning of what is going on:</p>
<p>The purpose of this exercise:</p>
<p>Let’s say we are given a density matrix, <span class=""math-container"">$\rho$</span>. We are finding a way to decompose it into an ensemble of pure states. One way would be to decompose it into its eigenvectors, and the corresponding probabilities are the eigenvalues. However, in this exercise, we are finding a more general approach to decomposing the density matrix into any ensemble of pure states, but the ensemble of pure states must span the vector space that the eigenvectors span.</p>
<p>How?</p>
<p>1). We take an arbitrary state vector, <span class=""math-container"">$|\psi\rangle$</span>, with the condition that it must be in the support of <span class=""math-container"">$\rho$</span>. The support of <span class=""math-container"">$\rho$</span> is the vector space that <span class=""math-container"">$\rho$</span> lives in.</p>
<p>2). We take the inverse of the density matrix, which inverts the eigenvalues (or probabilities) for each eigenvector of the density matrix. This inversion leaves us with low probabilities for eigenvectors that account for most of <span class=""math-container"">$\rho$</span>, and high probabilities for eigenvectors that don’t contribute to <span class=""math-container"">$\rho$</span> as much</p>
<p>3). Now, we take the expectation of our arbitrary state, <span class=""math-container"">$|\psi\rangle$</span>, with the inverted density matrix. To understand this expectation, let’s think about the expectation value if we left out all the eigenvalues. We would calculate the inner product of <span class=""math-container"">$|\psi\rangle$</span> with each eigenvector, and the result should be one because the eigenvectors span the vector space, so a linear combination of them should return exactly <span class=""math-container"">$|\psi\rangle$</span>. Now, if we include the eigenvalues (not inverted), the result will tell us which direction (combination of eigenvector) <span class=""math-container"">$|\psi\rangle$</span> most closely aligns with, by adding together eigenvalues for all the different directions weighted by the inner product with that eigenvector. This just tells how much of our system represented by our density matrix is in the state <span class=""math-container"">$|\psi\rangle$</span>, or the probability that our system is in the state <span class=""math-container"">$|\psi\rangle$</span>.</p>
<p>Where is the flaw in my reasoning? And what is the correct explanation of what is going on in this exercise?</p>
<p><a href=""https://i.sstatic.net/0bfyDObC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0bfyDObC.png"" alt=""enter image description here"" /></a></p>
",qc,minimal ensemble decompositions contain supp probability p came across following exercise nielsen amp chuang trying understand p reasoning going p purpose exercise p let say given density matrix span finding way decompose ensemble pure states one way would decompose eigenvectors corresponding probabilities eigenvalues however exercise finding general approach decomposing density matrix ensemble pure states ensemble pure states must span vector space eigenvectors p p 1 take arbitrary state vector span condition must support span support span vector space span lives p 2 take inverse density matrix inverts eigenvalues probabilities eigenvector density matrix inversion leaves us low probabilities eigenvectors account span high probabilities eigenvectors contribute span much p 3 take expectation arbitrary state span inverted density matrix understand expectation let think expectation value left eigenvalues would calculate inner product span eigenvector result one eigenvectors span vector space linear combination return exactly span include eigenvalues inverted result tell us direction combination eigenvector span closely aligns adding together eigenvalues different directions weighted inner product eigenvector tells much system represented density matrix state span probability system state span p flaw reasoning correct explanation going exercise p https nofollow noreferrer img https enter image description,"[(3, 0.77461106), (4, 0.06254104), (7, 0.0206385), (11, 0.07236316), (13, 0.028185075), (17, 0.021585532)]"
38459,,2024-05-23 17:47:01,1,127,"<p>I'm working on a portfolio optimization problem using Qiskit and I'm encountering an error when trying to solve a quadratic program using MinimumEigenOptimizer with SamplingVQE. Any insights on what might be causing this error or how to fix it would be greatly appreciated!</p>
<p>Here's the code I'm using:</p>
<pre><code>from qiskit_algorithms import SamplingVQE
from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2 as Sampler
from qiskit.circuit.library import RealAmplitudes
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_algorithms.optimizers import SLSQP
import numpy as np
import datetime

num_assets = 30
seed = 123

# Generate expected return and covariance matrix from (random) time-series
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()

q = 0.5  # set risk factor
budget = num_assets // 2  # set budget
penalty = num_assets  # set parameter to scale the budget penalty term

portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()

service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(operational=True, simulator=False)
session = Session(service=service, backend=backend)

ansatz = RealAmplitudes(qp.get_num_binary_vars(), reps=3)
pm = generate_preset_pass_manager(backend=backend, optimization_level=2)
isa_circuit = pm.run(ansatz)

vqe = SamplingVQE(sampler=Sampler(session=session), ansatz= isa_circuit, optimizer=SLSQP())  
optimizer = MinimumEigenOptimizer(vqe)
result = optimizer.solve(qp)
print(result)
</code></pre>
<p>When I run this code, I get the following error:</p>
<pre><code>TypeError: run() takes 2 positional arguments but 3 were given
</code></pre>
<p>Here's the full traceback:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/sampling_vqe.py:318, in SamplingVQE._get_evaluate_energy.&lt;locals&gt;.evaluate_energy(parameters)
    315 parameters = np.reshape(parameters, (-1, num_parameters)).tolist()
    316 batch_size = len(parameters)
--&gt; 318 estimator_result = estimator.run(
    319     batch_size * [ansatz], batch_size * [operator], parameters
    320 ).result()
    321 values = estimator_result.values
    323 if self.callback is not None:

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/primitives/primitive_job.py:51, in PrimitiveJob.result(self)
     49 def result(self) -&gt; ResultT:
     50     self._check_submitted()
---&gt; 51     return self._future.result()

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:437, in Future.result(self, timeout)
    435     raise CancelledError()
    436 elif self._state == FINISHED:
--&gt; 437     return self.__get_result()
    439 self._condition.wait(timeout)
    441 if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:389, in Future.__get_result(self)
    387 if self._exception:
    388     try:
--&gt; 389         raise self._exception
    390     finally:
    391         # Break a reference cycle with the exception in self._exception
    392         self = None

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/thread.py:57, in _WorkItem.run(self)
     54     return
     56 try:
---&gt; 57     result = self.fn(*self.args, **self.kwargs)
     58 except BaseException as exc:
     59     self.future.set_exception(exc)

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/diagonal_estimator.py:117, in _DiagonalEstimator._call(self, circuits, observables, parameter_values, **run_options)
    110 def _call(
    111     self,
    112     circuits: Sequence[int],
   ...
    115     **run_options,
    116 ) -&gt; _DiagonalEstimatorResult:
--&gt; 117     job = self.sampler.run(
    118         [self._circuits[i] for i in circuits],
    119         parameter_values,
    120         **run_options,
    121     )
    122     sampler_result = job.result()
    123     samples = sampler_result.quasi_dists

TypeError: run() takes 2 positional arguments but 3 were given
<span class=""math-container"">```</span>
</code></pre>
",Portfolio Optimization with VQE,<qiskit><vqe><optimization><qiskit-runtime>,1,1,,,"Portfolio Optimization with VQE <p>I'm working on a portfolio optimization problem using Qiskit and I'm encountering an error when trying to solve a quadratic program using MinimumEigenOptimizer with SamplingVQE. Any insights on what might be causing this error or how to fix it would be greatly appreciated!</p>
<p>Here's the code I'm using:</p>
<pre><code>from qiskit_algorithms import SamplingVQE
from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2 as Sampler
from qiskit.circuit.library import RealAmplitudes
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_algorithms.optimizers import SLSQP
import numpy as np
import datetime

num_assets = 30
seed = 123

# Generate expected return and covariance matrix from (random) time-series
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()

q = 0.5  # set risk factor
budget = num_assets // 2  # set budget
penalty = num_assets  # set parameter to scale the budget penalty term

portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()

service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(operational=True, simulator=False)
session = Session(service=service, backend=backend)

ansatz = RealAmplitudes(qp.get_num_binary_vars(), reps=3)
pm = generate_preset_pass_manager(backend=backend, optimization_level=2)
isa_circuit = pm.run(ansatz)

vqe = SamplingVQE(sampler=Sampler(session=session), ansatz= isa_circuit, optimizer=SLSQP())  
optimizer = MinimumEigenOptimizer(vqe)
result = optimizer.solve(qp)
print(result)
</code></pre>
<p>When I run this code, I get the following error:</p>
<pre><code>TypeError: run() takes 2 positional arguments but 3 were given
</code></pre>
<p>Here's the full traceback:</p>
<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/sampling_vqe.py:318, in SamplingVQE._get_evaluate_energy.&lt;locals&gt;.evaluate_energy(parameters)
    315 parameters = np.reshape(parameters, (-1, num_parameters)).tolist()
    316 batch_size = len(parameters)
--&gt; 318 estimator_result = estimator.run(
    319     batch_size * [ansatz], batch_size * [operator], parameters
    320 ).result()
    321 values = estimator_result.values
    323 if self.callback is not None:

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit/primitives/primitive_job.py:51, in PrimitiveJob.result(self)
     49 def result(self) -&gt; ResultT:
     50     self._check_submitted()
---&gt; 51     return self._future.result()

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:437, in Future.result(self, timeout)
    435     raise CancelledError()
    436 elif self._state == FINISHED:
--&gt; 437     return self.__get_result()
    439 self._condition.wait(timeout)
    441 if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/_base.py:389, in Future.__get_result(self)
    387 if self._exception:
    388     try:
--&gt; 389         raise self._exception
    390     finally:
    391         # Break a reference cycle with the exception in self._exception
    392         self = None

File ~/opt/anaconda3/lib/python3.8/concurrent/futures/thread.py:57, in _WorkItem.run(self)
     54     return
     56 try:
---&gt; 57     result = self.fn(*self.args, **self.kwargs)
     58 except BaseException as exc:
     59     self.future.set_exception(exc)

File ~/opt/anaconda3/lib/python3.8/site-packages/qiskit_algorithms/minimum_eigensolvers/diagonal_estimator.py:117, in _DiagonalEstimator._call(self, circuits, observables, parameter_values, **run_options)
    110 def _call(
    111     self,
    112     circuits: Sequence[int],
   ...
    115     **run_options,
    116 ) -&gt; _DiagonalEstimatorResult:
--&gt; 117     job = self.sampler.run(
    118         [self._circuits[i] for i in circuits],
    119         parameter_values,
    120         **run_options,
    121     )
    122     sampler_result = job.result()
    123     samples = sampler_result.quasi_dists

TypeError: run() takes 2 positional arguments but 3 were given
<span class=""math-container"">```</span>
</code></pre>
",qc,portfolio optimization vqe p working portfolio optimization problem using qiskit encountering error trying solve quadratic program using minimumeigenoptimizer samplingvqe insights might causing error fix would greatly appreciated p code using pre code import samplingvqe import portfoliooptimization import randomdataprovider import minimumeigenoptimizer import qiskitruntimeservice session samplerv2 sampler import realamplitudes import import slsqp import numpy np import datetime 30 seed 123 generate expected return covariance matrix random stocks quot ticker quot range data randomdataprovider 2016 1 1 2016 1 30 mu sigma q set risk factor budget 2 set budget penalty set parameter scale budget penalty term portfolio portfoliooptimization qp service qiskitruntimeservice quot quot backend session session ansatz realamplitudes pm ansatz vqe samplingvqe optimizer minimumeigenoptimizer vqe result qp print result p run code get following error pre code typeerror run takes 2 positional arguments 3 given p full traceback pre code typeerror traceback recent call last file lt locals gt parameters 315 parameters parameters 316 len parameters gt 318 319 ansatz operator parameters 320 321 values 323 none file self 49 def result self gt resultt 50 gt 51 return file self timeout 435 raise cancellederror 436 elif finished gt 437 return 439 timeout 441 cancelled file self 387 388 try gt 389 raise 390 finally 391 break reference cycle exception 392 self none file self 54 return 56 try gt 57 result 58 except baseexception exc 59 exc file self circuits observables 110 def 111 self 112 circuits sequence int 115 116 gt gt 117 job 118 circuits 119 120 121 122 123 samples typeerror run takes 2 positional arguments 3 given span,"[(0, 0.8240581), (6, 0.018979724), (12, 0.01128227), (14, 0.014120455), (17, 0.08726437), (19, 0.03423403)]"
38513,,2024-05-28 02:40:35,2,93,"<p>I'm working on a portfolio optimization problem using Qiskit and I'm encountering an error when trying to solve a quadratic program using MinimumEigenOptimizer with SamplingVQE (V1 Primitives). Any insights on what might be causing this error or how to fix it would be greatly appreciated!</p>
<p>When I run the code below, I get the following error:</p>
<pre><code>AlgorithmError: 'The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits.'
</code></pre>
<p>Here's the code I'm using:</p>
<pre><code>from qiskit_algorithms import SamplingVQE
from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2 as Sampler
from qiskit.circuit.library import RealAmplitudes
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_algorithms.optimizers import SLSQP
import numpy as np
import datetime

num_assets = 30
seed = 123

# Generate expected return and covariance matrix from (random) time-series
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()

q = 0.5  # set risk factor
budget = num_assets // 2  # set budget
penalty = num_assets  # set parameter to scale the budget penalty term

portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()

service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(operational=True, simulator=False)
session = Session(service=service, backend=backend)

ansatz = RealAmplitudes(qp.get_num_binary_vars(), reps=3)
pm = generate_preset_pass_manager(backend=backend, optimization_level=2)
isa_circuit = pm.run(ansatz)

vqe = SamplingVQE(sampler=Sampler(session=session), ansatz= isa_circuit, optimizer=SLSQP())  
optimizer = MinimumEigenOptimizer(vqe)
result = optimizer.solve(qp)
print(result)
</code></pre>
",Portfolio Optimization with VQE (Qiskit),<qiskit><vqe><optimization><qiskit-runtime>,0,0,,,"Portfolio Optimization with VQE (Qiskit) <p>I'm working on a portfolio optimization problem using Qiskit and I'm encountering an error when trying to solve a quadratic program using MinimumEigenOptimizer with SamplingVQE (V1 Primitives). Any insights on what might be causing this error or how to fix it would be greatly appreciated!</p>
<p>When I run the code below, I get the following error:</p>
<pre><code>AlgorithmError: 'The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits.'
</code></pre>
<p>Here's the code I'm using:</p>
<pre><code>from qiskit_algorithms import SamplingVQE
from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_finance.data_providers import RandomDataProvider
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2 as Sampler
from qiskit.circuit.library import RealAmplitudes
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_algorithms.optimizers import SLSQP
import numpy as np
import datetime

num_assets = 30
seed = 123

# Generate expected return and covariance matrix from (random) time-series
stocks = [(&quot;TICKER%s&quot; % i) for i in range(num_assets)]
data = RandomDataProvider(
    tickers=stocks,
    start=datetime.datetime(2016, 1, 1),
    end=datetime.datetime(2016, 1, 30),
    seed=seed,
)
data.run()
mu = data.get_period_return_mean_vector()
sigma = data.get_period_return_covariance_matrix()

q = 0.5  # set risk factor
budget = num_assets // 2  # set budget
penalty = num_assets  # set parameter to scale the budget penalty term

portfolio = PortfolioOptimization(
    expected_returns=mu, covariances=sigma, risk_factor=q, budget=budget
)
qp = portfolio.to_quadratic_program()

service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)
backend = service.least_busy(operational=True, simulator=False)
session = Session(service=service, backend=backend)

ansatz = RealAmplitudes(qp.get_num_binary_vars(), reps=3)
pm = generate_preset_pass_manager(backend=backend, optimization_level=2)
isa_circuit = pm.run(ansatz)

vqe = SamplingVQE(sampler=Sampler(session=session), ansatz= isa_circuit, optimizer=SLSQP())  
optimizer = MinimumEigenOptimizer(vqe)
result = optimizer.solve(qp)
print(result)
</code></pre>
",qc,portfolio optimization vqe qiskit p working portfolio optimization problem using qiskit encountering error trying solve quadratic program using minimumeigenoptimizer samplingvqe v1 primitives insights might causing error fix would greatly appreciated p run code get following error pre code algorithmerror number qubits ansatz match operator ansatz allow setting number qubits using p code using pre code import samplingvqe import portfoliooptimization import randomdataprovider import minimumeigenoptimizer import qiskitruntimeservice session samplerv2 sampler import realamplitudes import import slsqp import numpy np import datetime 30 seed 123 generate expected return covariance matrix random stocks quot ticker quot range data randomdataprovider 2016 1 1 2016 1 30 mu sigma q set risk factor budget 2 set budget penalty set parameter scale budget penalty term portfolio portfoliooptimization qp service qiskitruntimeservice quot quot backend session session ansatz realamplitudes pm ansatz vqe samplingvqe optimizer minimumeigenoptimizer vqe result qp print result,"[(0, 0.7417766), (11, 0.01304319), (17, 0.21476689), (19, 0.029271726)]"
38532,38539.0,2024-05-29 06:57:45,2,218,"<p>Although there has been discussions on this<a href=""https://quantumcomputing.stackexchange.com/questions/12884/what-is-the-pseudo-threshold-of-a-qecc-using-stabilizer-formalism"">1</a>, I still have some questions.
I will firstly summarize my understanding of these concepts, threshold, pseudo-threshold (please correct if I am wrong), breakeven and present my questions. Assume we have a consistent noise model:</p>
<ol>
<li>Threshold. This is usually defined for a family of codes. Roughly speaking, it is the value below which, increasing the code size decreases the logical error rate. For code concatenation, we plot the logical error rate vs physical error rate for various level of concatenation and find the minimum value of <span class=""math-container"">$p$</span> of intersection. For the surface code, we increase size of the code patch <span class=""math-container"">$L$</span> and find the intersection.</li>
<li>Pseudo-threshold. This is defined for a single code. It is the point at which logical error rate &lt; physical error rate.</li>
<li>Breakeven. I'm not very sure about this, but I guess it is, on the experimental side, a full cycle of QECC is performed before the qubits decohere?</li>
</ol>
<p>My questions:</p>
<ol>
<li>Definition of &quot;break-even&quot;?</li>
<li>I can't find proper definitions of threshold and pseudo-threshold in the literature. I would like to formulate them in some way, could anyone help?</li>
<li>It seems to me the definition of pseudo-threshold is a more natural definition, and it guarantees QECC will work better than no-QECC. I don't understand why we need &quot;threshold&quot; as defined above, to me it only shows the family of code is kinda &quot;good&quot;. In a lot of the cases at the threshold point, logical error rate &gt; physical error rate, which is presumably not what we want. Then the defn doesn't quite make sense.</li>
<li>For example, usually in the surface code, we see plots having curves with different <span class=""math-container"">$L$</span> intersecting at a single point. However, is there any theoretical guarantee they have to intersect at one point? I can't see an obvious reason.</li>
<li>Any relationship between threshold and pseudo-threshold?</li>
</ol>
",Definition of threshold/pseudothreshold/breakeven in QECC,<error-correction><fault-tolerance>,2,1,,,"Definition of threshold/pseudothreshold/breakeven in QECC <p>Although there has been discussions on this<a href=""https://quantumcomputing.stackexchange.com/questions/12884/what-is-the-pseudo-threshold-of-a-qecc-using-stabilizer-formalism"">1</a>, I still have some questions.
I will firstly summarize my understanding of these concepts, threshold, pseudo-threshold (please correct if I am wrong), breakeven and present my questions. Assume we have a consistent noise model:</p>
<ol>
<li>Threshold. This is usually defined for a family of codes. Roughly speaking, it is the value below which, increasing the code size decreases the logical error rate. For code concatenation, we plot the logical error rate vs physical error rate for various level of concatenation and find the minimum value of <span class=""math-container"">$p$</span> of intersection. For the surface code, we increase size of the code patch <span class=""math-container"">$L$</span> and find the intersection.</li>
<li>Pseudo-threshold. This is defined for a single code. It is the point at which logical error rate &lt; physical error rate.</li>
<li>Breakeven. I'm not very sure about this, but I guess it is, on the experimental side, a full cycle of QECC is performed before the qubits decohere?</li>
</ol>
<p>My questions:</p>
<ol>
<li>Definition of &quot;break-even&quot;?</li>
<li>I can't find proper definitions of threshold and pseudo-threshold in the literature. I would like to formulate them in some way, could anyone help?</li>
<li>It seems to me the definition of pseudo-threshold is a more natural definition, and it guarantees QECC will work better than no-QECC. I don't understand why we need &quot;threshold&quot; as defined above, to me it only shows the family of code is kinda &quot;good&quot;. In a lot of the cases at the threshold point, logical error rate &gt; physical error rate, which is presumably not what we want. Then the defn doesn't quite make sense.</li>
<li>For example, usually in the surface code, we see plots having curves with different <span class=""math-container"">$L$</span> intersecting at a single point. However, is there any theoretical guarantee they have to intersect at one point? I can't see an obvious reason.</li>
<li>Any relationship between threshold and pseudo-threshold?</li>
</ol>
",qc,definition qecc p although discussions https 1 still questions firstly summarize understanding concepts threshold please correct wrong breakeven present questions assume consistent noise model ol li threshold usually defined family codes roughly speaking value increasing code size decreases logical error rate code concatenation plot logical error rate vs physical error rate various level concatenation find minimum value span p intersection surface code increase size code patch span l find li defined single code point logical error rate lt physical error li breakeven sure guess experimental side full cycle qecc performed qubits decohere p questions ol li definition quot quot li ca find proper definitions threshold literature would like formulate way could anyone help li seems definition natural definition guarantees qecc work better understand need quot threshold quot defined shows family code kinda quot good quot lot cases threshold point logical error rate gt physical error rate presumably want defn quite make li example usually surface code see plots curves different span l intersecting single point however theoretical guarantee intersect one point ca see obvious li relationship threshold,"[(0, 0.020975001), (3, 0.10051089), (5, 0.37971243), (7, 0.26921013), (8, 0.09914112), (13, 0.0126925055), (17, 0.078982934), (19, 0.038096994)]"
38535,,2024-05-29 08:08:46,0,120,"<p>Suppose we have a very simple stim circuit</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit('''
    X_ERROR(0.125) 0
    X_ERROR(0.25) 1
    DEPOLARIZE2(0.6) 0 1
    M 0 1
    DETECTOR rec[-2]
    DETECTOR rec[-1]
''')
</code></pre>
<p>And we can see that four possible errors will cause the joint flip of <code>D0</code> and <code>D1</code> detectors, as shown in the <code>explain_detecor_error_model_errors</code> module:</p>
<pre><code>ExplainedError {
    dem_error_terms: D0 D1
    CircuitErrorLocation {
        flipped_pauli_product: X0*X1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
    CircuitErrorLocation {
        flipped_pauli_product: X0*Y1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
    CircuitErrorLocation {
        flipped_pauli_product: Y0*X1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
    CircuitErrorLocation {
        flipped_pauli_product: Y0*Y1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
}
</code></pre>
<p>In the meantime, the weights of error mechanisms indicate by running <code>print(circuit.detector_error_model())</code></p>
<pre><code>error(0.275) D0
error(0.2) D0 D1
error(0.35) D1
</code></pre>
<p>I am wondering why the weight of <code>D0</code> <code>D1</code> is 0.2, other than 0.6/15*4 since the only error location that could possibly cause the joint flip of <code>D0</code> and <code>D1</code> will be <code>DEPOLARIZE2(0.6) 0 1</code>, and 4/15 of the possible error configurations will trigger the detector flip.</p>
",Calculating the weights of error mechanisms in stim,<stim>,1,0,,,"Calculating the weights of error mechanisms in stim <p>Suppose we have a very simple stim circuit</p>
<pre class=""lang-python prettyprint-override""><code>circuit = stim.Circuit('''
    X_ERROR(0.125) 0
    X_ERROR(0.25) 1
    DEPOLARIZE2(0.6) 0 1
    M 0 1
    DETECTOR rec[-2]
    DETECTOR rec[-1]
''')
</code></pre>
<p>And we can see that four possible errors will cause the joint flip of <code>D0</code> and <code>D1</code> detectors, as shown in the <code>explain_detecor_error_model_errors</code> module:</p>
<pre><code>ExplainedError {
    dem_error_terms: D0 D1
    CircuitErrorLocation {
        flipped_pauli_product: X0*X1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
    CircuitErrorLocation {
        flipped_pauli_product: X0*Y1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
    CircuitErrorLocation {
        flipped_pauli_product: Y0*X1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
    CircuitErrorLocation {
        flipped_pauli_product: Y0*Y1
        Circuit location stack trace:
            (after 0 TICKs)
            at instruction #3 (DEPOLARIZE2) in the circuit
            at targets #1 to #2 of the instruction
            resolving to DEPOLARIZE2(0.6) 0 1
    }
}
</code></pre>
<p>In the meantime, the weights of error mechanisms indicate by running <code>print(circuit.detector_error_model())</code></p>
<pre><code>error(0.275) D0
error(0.2) D0 D1
error(0.35) D1
</code></pre>
<p>I am wondering why the weight of <code>D0</code> <code>D1</code> is 0.2, other than 0.6/15*4 since the only error location that could possibly cause the joint flip of <code>D0</code> and <code>D1</code> will be <code>DEPOLARIZE2(0.6) 0 1</code>, and 4/15 of the possible error configurations will trigger the detector flip.</p>
",qc,calculating weights error mechanisms stim p suppose simple stim circuit pre code circuit 0 1 depolarize2 0 1 0 1 detector rec detector rec p see four possible errors cause joint flip code d0 code d1 detectors shown code module pre code explainederror d0 d1 circuiterrorlocation x0 x1 circuit location stack trace 0 ticks instruction 3 depolarize2 circuit targets 1 2 instruction resolving depolarize2 0 1 circuiterrorlocation x0 y1 circuit location stack trace 0 ticks instruction 3 depolarize2 circuit targets 1 2 instruction resolving depolarize2 0 1 circuiterrorlocation y0 x1 circuit location stack trace 0 ticks instruction 3 depolarize2 circuit targets 1 2 instruction resolving depolarize2 0 1 circuiterrorlocation y0 y1 circuit location stack trace 0 ticks instruction 3 depolarize2 circuit targets 1 2 instruction resolving depolarize2 0 1 p meantime weights error mechanisms indicate running code print pre code error d0 error d0 d1 error d1 p wondering weight code d0 code d1 4 since error location could possibly cause joint flip code d0 code d1 code depolarize2 0 1 possible error configurations trigger detector,"[(2, 0.11831072), (5, 0.063929096), (6, 0.3319463), (14, 0.46121892), (17, 0.023742886)]"
38610,,2024-06-03 12:27:37,0,12,"<p>In this paper: <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.93.080502"" rel=""nofollow noreferrer"">https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.93.080502</a>, the authors use input
states <span class=""math-container"">$\{HH; VH;
DV; LH; LV; VV;HV;HA;HL; LL; LA; DA; DR; VA; VL;
DH\}$</span> and measurements <span class=""math-container"">$\{HH;HV;VH;VV;
HD;HL; VL; VD; DD; RL; RD; DR;DV;RV;DH;RH\}$</span> to do process tomography of a Controlled-NOT Gate, see ref[21] of the paper.  Here,</p>
<pre><code>H = [1;0];
V = [0;1];
D = 1/sqrt(2)*(H+V);
R = 1/sqrt(2)*(H-i*V);
A = 1/sqrt(2)*(H-V);
L = 1/sqrt(2)*(H+i*V);
</code></pre>
<p>It is said that there are an infinite number of such bases, so there is
substantial flexibility in choosing tomographic input and
measurement settings. We know there are 36 pairwise combinations of <span class=""math-container"">$\{H,V,R,D,A,L\}$</span>,
so how do I know the input states and measurements configurations chosen from this set (36 pairwise combinations) are tomography complete?</p>
",How do I know a set of input states and measurements configurations is tomography complete?,<quantum-process-tomography>,0,0,,,"How do I know a set of input states and measurements configurations is tomography complete? <p>In this paper: <a href=""https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.93.080502"" rel=""nofollow noreferrer"">https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.93.080502</a>, the authors use input
states <span class=""math-container"">$\{HH; VH;
DV; LH; LV; VV;HV;HA;HL; LL; LA; DA; DR; VA; VL;
DH\}$</span> and measurements <span class=""math-container"">$\{HH;HV;VH;VV;
HD;HL; VL; VD; DD; RL; RD; DR;DV;RV;DH;RH\}$</span> to do process tomography of a Controlled-NOT Gate, see ref[21] of the paper.  Here,</p>
<pre><code>H = [1;0];
V = [0;1];
D = 1/sqrt(2)*(H+V);
R = 1/sqrt(2)*(H-i*V);
A = 1/sqrt(2)*(H-V);
L = 1/sqrt(2)*(H+i*V);
</code></pre>
<p>It is said that there are an infinite number of such bases, so there is
substantial flexibility in choosing tomographic input and
measurement settings. We know there are 36 pairwise combinations of <span class=""math-container"">$\{H,V,R,D,A,L\}$</span>,
so how do I know the input states and measurements configurations chosen from this set (36 pairwise combinations) are tomography complete?</p>
",qc,know set input states measurements configurations tomography complete p paper https nofollow noreferrer https authors use input states span hh vh dv lh lv vv hv ha hl la da dr va vl measurements span hh hv vh vv hd hl vl vd dd rl rd dr dv rv dh process tomography gate see ref 21 paper pre code h 1 0 v 0 1 2 r 2 v 2 l 2 v p said infinite number bases substantial flexibility choosing tomographic input measurement settings know 36 pairwise combinations span h v r know input states measurements configurations chosen set 36 pairwise combinations tomography complete,"[(2, 0.117296696), (3, 0.30848882), (7, 0.28540596), (14, 0.25279748), (15, 0.022775916), (17, 0.011774943)]"
38647,38685.0,2024-06-05 15:23:29,2,98,"<p>I've heard before that there are 2d-local unitary operations that transform color code stabilizers into two sets of surface code stabilizers. Globally this would presumably do things like transform a color code into a folded surface code, or a toric color code into two toric surface codes.</p>
<p>What are the 2d-local operations that do this? Give an actual 2d-local circuit.</p>
",Locally transforming a color code into two surface codes,<surface-code><color-code>,1,1,,,"Locally transforming a color code into two surface codes <p>I've heard before that there are 2d-local unitary operations that transform color code stabilizers into two sets of surface code stabilizers. Globally this would presumably do things like transform a color code into a folded surface code, or a toric color code into two toric surface codes.</p>
<p>What are the 2d-local operations that do this? Give an actual 2d-local circuit.</p>
",qc,locally transforming color code two surface codes p heard unitary operations transform color code stabilizers two sets surface code stabilizers globally would presumably things like transform color code folded surface code toric color code two toric surface p operations give actual,"[(5, 0.5870725), (7, 0.13722213), (14, 0.22152208), (17, 0.05029568)]"
38654,38655.0,2024-06-06 12:25:41,2,63,"<p>One of the reasons why BB84 is usually considered safe is due to the <em>no-cloning</em> principle. However, as far as I know imperfect cloning of quantum states is possible. I've been thinking about a potential attack on the BB84 where Eve makes imperfect copies of the states of qubits sent by Alice, and then measures the imperfect copies.</p>
<p>I see imperfect cloning as an operation described with a unitary operator <span class=""math-container"">$U$</span> which acts in the following way:<br />
<span class=""math-container"">$U \vert \psi \rangle \vert 0 \rangle \rightarrow \vert \psi \rangle \vert \psi^{\prime} \rangle$</span>
where <span class=""math-container"">$\psi$</span> and <span class=""math-container"">$\psi^{\prime}$</span> are at least somewhat similar, i.e. <span class=""math-container"">$\langle \psi \vert \psi^{\prime} \rangle$</span> &gt; 0.5.<br />
Cannot think of a reason why such operator should not exist.</p>
<p>Obviously, Eve cannot retrieve the entire key in this way but I guess even if she gains knowledge about a significant percentage of the key this can considerably facilitate other attacks (even if just some classical brute force attack). And since she measures the copies, she will be able to remain undetected. Moreover - the more similar the copy is to the original state, the more information Eve should be able to gain but I suppose as long as there is virtually <strong>any</strong> correlation between the copy and the original state, Eve should be able to retrieve <em>some</em> information about the qubits sent by Alice, therefore weakening the protocol's security.</p>
<p>I am aware that a proof of BB84's security exists and hence I reason that such an attack cannot be possible. However, I am not sure why it is the case. I am wondering whether there is some kind of limitation that you cannot get any information about a state at all without influencing it, but this seems like a very strong statement and I don't know how to show it. Or is there some other reason?</p>
<p>I've read all results of the searches <em>no-cloning</em>, <em>no-cloning theorem</em> and <em>BB84 attack</em> but, surprisingly, to no avail. I will be grateful for any insights.</p>
",How to show that BB84 is safe against imperfect cloning?,<bb84><no-cloning-theorem><cloning>,1,0,,,"How to show that BB84 is safe against imperfect cloning? <p>One of the reasons why BB84 is usually considered safe is due to the <em>no-cloning</em> principle. However, as far as I know imperfect cloning of quantum states is possible. I've been thinking about a potential attack on the BB84 where Eve makes imperfect copies of the states of qubits sent by Alice, and then measures the imperfect copies.</p>
<p>I see imperfect cloning as an operation described with a unitary operator <span class=""math-container"">$U$</span> which acts in the following way:<br />
<span class=""math-container"">$U \vert \psi \rangle \vert 0 \rangle \rightarrow \vert \psi \rangle \vert \psi^{\prime} \rangle$</span>
where <span class=""math-container"">$\psi$</span> and <span class=""math-container"">$\psi^{\prime}$</span> are at least somewhat similar, i.e. <span class=""math-container"">$\langle \psi \vert \psi^{\prime} \rangle$</span> &gt; 0.5.<br />
Cannot think of a reason why such operator should not exist.</p>
<p>Obviously, Eve cannot retrieve the entire key in this way but I guess even if she gains knowledge about a significant percentage of the key this can considerably facilitate other attacks (even if just some classical brute force attack). And since she measures the copies, she will be able to remain undetected. Moreover - the more similar the copy is to the original state, the more information Eve should be able to gain but I suppose as long as there is virtually <strong>any</strong> correlation between the copy and the original state, Eve should be able to retrieve <em>some</em> information about the qubits sent by Alice, therefore weakening the protocol's security.</p>
<p>I am aware that a proof of BB84's security exists and hence I reason that such an attack cannot be possible. However, I am not sure why it is the case. I am wondering whether there is some kind of limitation that you cannot get any information about a state at all without influencing it, but this seems like a very strong statement and I don't know how to show it. Or is there some other reason?</p>
<p>I've read all results of the searches <em>no-cloning</em>, <em>no-cloning theorem</em> and <em>BB84 attack</em> but, surprisingly, to no avail. I will be grateful for any insights.</p>
",qc,show bb84 safe imperfect cloning p one reasons bb84 usually considered safe due em principle however far know imperfect cloning quantum states possible thinking potential attack bb84 eve makes imperfect copies states qubits sent alice measures imperfect p see imperfect cloning operation described unitary operator span u acts following way br span u 0 span span least somewhat similar span gt br think reason operator p obviously eve retrieve entire key way guess even gains knowledge significant percentage key considerably facilitate attacks even classical brute force attack since measures copies able remain undetected moreover similar copy original state information eve able gain suppose long virtually strong correlation copy original state eve able retrieve em information qubits sent alice therefore weakening protocol p aware proof bb84 security exists hence reason attack possible however sure case wondering whether kind limitation get information state without influencing seems like strong statement know show reason p read results searches em em theorem em bb84 attack surprisingly avail grateful,"[(3, 0.16019218), (8, 0.42561868), (11, 0.019115357), (13, 0.031773902), (17, 0.019845594), (18, 0.33591565)]"
38660,38666.0,2024-06-06 19:33:42,1,75,"<p>In the John Watrous condensed TQI lecture notes, an alternative proof of the Alberti's Theorem is given. He use an auxiliary lemma that states;</p>
<p><strong>Lemma 4.9</strong>. Let <span class=""math-container"">$P \in Pos(X)$</span>. It holds that <span class=""math-container"">$${inf}_{R\in PD(x)} \langle R,P\rangle\langle R^{-1},P\rangle = (Tr(P))^2  $$</span>.</p>
<p>Where <span class=""math-container"">$Pos(x)$</span> means positive semidefinite and <span class=""math-container"">$PD(x)$</span> means positive definite.</p>
<p>He begins the proof stating that since <span class=""math-container"">$R = I$</span>(identity) is positive definite, then is clear that <span class=""math-container"">$\langle R,P]\rangle\langle R^{-1},P\rangle \leq (Tr(P))^2$</span>. Then, for the opposite, '<span class=""math-container"">$\geq$</span>', he states that, given <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> real numbers <span class=""math-container"">$\alpha^2 + \beta^2 \geq 2\alpha\beta$</span> and therefore <span class=""math-container"">$\alpha\beta^{-1} + \beta\alpha^{-1} \geq 2$</span>, assuming a spectral decomposition for <span class=""math-container"">$R$</span> and making use of the Hilbert-Schmidt product.
<span class=""math-container"">$$R = \sum_{1}^{n} \lambda_i u_i u_{i}^{*}$$</span></p>
<p><span class=""math-container"">$$ \langle R,P\rangle\langle R^{-1},P\rangle = \sum_{i,j = 1}^{n} \lambda_i \lambda^{-1}_{j} (u_i^{*} P u_i)(u_j^{ *} P u_j) = \sum_i^{n} (u_i^{ *} P u_i)^{2} + \sum_i^{n}\sum_j^{n} (\lambda_i\lambda_j^{-1} + \lambda_j\lambda_i^{-1}) (u_i^{ *} P u_i)(u_j^{ *} P u_j)  $$</span></p>
<p>In the last equation, in the last equality, i couldn't figure out what manipulation he used to achieve such equation. I've tried to find it for some time and i didn't reach anywhere close. How can he go from this <span class=""math-container"">$$\sum_{i,j = 1}^{n} \lambda_i \lambda^{-1}_{j} (u_i^{*} P u_i)(u_j^{ *} P u_j)$$</span>
to this
<span class=""math-container"">$$\sum_i^{n} (u_i^{ *} P u_i)^{2} + \sum_i^{n}\sum_j^{n} (\lambda_i\lambda_j^{-1} + \lambda_j\lambda_i^{-1}) (u_i^{ *} P u_i)(u_j^{ *} P u_j)$$</span></p>
<p>A print of his notes follows<a href=""https://i.sstatic.net/tCEIET5y.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/tCEIET5y.png"" alt=""Screenshot of the John Watrous TQI-notes"" /></a></p>
",Clarification about the Alberti's Theorem proof given by Watrous in his condensed lecture notes,<textbook-and-exercises><linear-algebra>,1,1,,,"Clarification about the Alberti's Theorem proof given by Watrous in his condensed lecture notes <p>In the John Watrous condensed TQI lecture notes, an alternative proof of the Alberti's Theorem is given. He use an auxiliary lemma that states;</p>
<p><strong>Lemma 4.9</strong>. Let <span class=""math-container"">$P \in Pos(X)$</span>. It holds that <span class=""math-container"">$${inf}_{R\in PD(x)} \langle R,P\rangle\langle R^{-1},P\rangle = (Tr(P))^2  $$</span>.</p>
<p>Where <span class=""math-container"">$Pos(x)$</span> means positive semidefinite and <span class=""math-container"">$PD(x)$</span> means positive definite.</p>
<p>He begins the proof stating that since <span class=""math-container"">$R = I$</span>(identity) is positive definite, then is clear that <span class=""math-container"">$\langle R,P]\rangle\langle R^{-1},P\rangle \leq (Tr(P))^2$</span>. Then, for the opposite, '<span class=""math-container"">$\geq$</span>', he states that, given <span class=""math-container"">$\alpha$</span> and <span class=""math-container"">$\beta$</span> real numbers <span class=""math-container"">$\alpha^2 + \beta^2 \geq 2\alpha\beta$</span> and therefore <span class=""math-container"">$\alpha\beta^{-1} + \beta\alpha^{-1} \geq 2$</span>, assuming a spectral decomposition for <span class=""math-container"">$R$</span> and making use of the Hilbert-Schmidt product.
<span class=""math-container"">$$R = \sum_{1}^{n} \lambda_i u_i u_{i}^{*}$$</span></p>
<p><span class=""math-container"">$$ \langle R,P\rangle\langle R^{-1},P\rangle = \sum_{i,j = 1}^{n} \lambda_i \lambda^{-1}_{j} (u_i^{*} P u_i)(u_j^{ *} P u_j) = \sum_i^{n} (u_i^{ *} P u_i)^{2} + \sum_i^{n}\sum_j^{n} (\lambda_i\lambda_j^{-1} + \lambda_j\lambda_i^{-1}) (u_i^{ *} P u_i)(u_j^{ *} P u_j)  $$</span></p>
<p>In the last equation, in the last equality, i couldn't figure out what manipulation he used to achieve such equation. I've tried to find it for some time and i didn't reach anywhere close. How can he go from this <span class=""math-container"">$$\sum_{i,j = 1}^{n} \lambda_i \lambda^{-1}_{j} (u_i^{*} P u_i)(u_j^{ *} P u_j)$$</span>
to this
<span class=""math-container"">$$\sum_i^{n} (u_i^{ *} P u_i)^{2} + \sum_i^{n}\sum_j^{n} (\lambda_i\lambda_j^{-1} + \lambda_j\lambda_i^{-1}) (u_i^{ *} P u_i)(u_j^{ *} P u_j)$$</span></p>
<p>A print of his notes follows<a href=""https://i.sstatic.net/tCEIET5y.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/tCEIET5y.png"" alt=""Screenshot of the John Watrous TQI-notes"" /></a></p>
",qc,clarification alberti theorem proof given watrous condensed lecture notes p john watrous condensed tqi lecture notes alternative proof alberti theorem given use auxiliary lemma states p strong lemma let span p pos x holds span inf pd x r tr p p span pos x means positive semidefinite span pd x means positive p begins proof stating since span r identity positive definite clear span r p tr p opposite span states given span span real numbers span therefore span 2 assuming spectral decomposition span r making use product span r 1 n p span r j 1 n j p p n p 2 n n p p p last equation last equality could figure manipulation used achieve equation tried find time reach anywhere close go span j 1 n j p p span n p 2 n n p p p print notes follows https nofollow noreferrer img https screenshot john watrous,"[(3, 0.75655544), (4, 0.053457282), (9, 0.0458638), (10, 0.0349483), (11, 0.021474767), (15, 0.049498368), (17, 0.011562266), (19, 0.025855187)]"
38692,,2024-06-09 02:26:35,5,132,"<p>To define a quantum error correction code, first one needs to model noise, such as Pauli noise, dephasing noise, etc.</p>
<p>Then according to the noise, look for the code space, stabilizer, and logical operators.</p>
<p>The whole process is really hard and the performance of defined codes may not be that good.</p>
<p>So I want to know if there is any machine learning method for finding quantum error correction codes. Given the settings of our noise, the algorithm searches for a good QEC code automatically with a high distance and <span class=""math-container"">$p_{th}$</span>, and low consumed physical qubits.</p>
",Is there any machine learning method for finding quantum error correction codes?,<error-correction><machine-learning>,1,2,,,"Is there any machine learning method for finding quantum error correction codes? <p>To define a quantum error correction code, first one needs to model noise, such as Pauli noise, dephasing noise, etc.</p>
<p>Then according to the noise, look for the code space, stabilizer, and logical operators.</p>
<p>The whole process is really hard and the performance of defined codes may not be that good.</p>
<p>So I want to know if there is any machine learning method for finding quantum error correction codes. Given the settings of our noise, the algorithm searches for a good QEC code automatically with a high distance and <span class=""math-container"">$p_{th}$</span>, and low consumed physical qubits.</p>
",qc,machine learning method finding quantum error correction codes p define quantum error correction code first one needs model noise pauli noise dephasing noise p according noise look code space stabilizer logical p whole process really hard performance defined codes may p want know machine learning method finding quantum error correction codes given settings noise algorithm searches good qec code automatically high distance span th low consumed physical,"[(5, 0.5687234), (8, 0.37351385), (14, 0.03743219), (17, 0.017948216)]"
38710,,2024-06-10 21:36:13,2,42,"<p>I can't afford a IBM full access account, and can't learn an entire programming language with only ten minutes of run time a month.</p>
<p>Are the qiskit lessons on YouTube/ github transferable given that I import the proper resources in my python environment?</p>
<p>Are any useful libraries/toolboxes designed for qiskit useable on qiskit aer, and vice versa?</p>
<p>Id hope so, as I'm a newbie to programming as a whole, and dont feel like scavenging the internet for resources to help me learn said languages. Id like to learn qiskit first, then pay for an account so i can do custom projects on quantum hardware.</p>
<p>Id appreciate any insight, thanks in advance.</p>
",Are qiskit and qiskit aer identical or very similar in syntax?,<qiskit><programming>,0,3,,,"Are qiskit and qiskit aer identical or very similar in syntax? <p>I can't afford a IBM full access account, and can't learn an entire programming language with only ten minutes of run time a month.</p>
<p>Are the qiskit lessons on YouTube/ github transferable given that I import the proper resources in my python environment?</p>
<p>Are any useful libraries/toolboxes designed for qiskit useable on qiskit aer, and vice versa?</p>
<p>Id hope so, as I'm a newbie to programming as a whole, and dont feel like scavenging the internet for resources to help me learn said languages. Id like to learn qiskit first, then pay for an account so i can do custom projects on quantum hardware.</p>
<p>Id appreciate any insight, thanks in advance.</p>
",qc,qiskit qiskit aer identical similar syntax p ca afford ibm full access account ca learn entire programming language ten minutes run time p qiskit lessons github transferable given import proper resources python environment p useful designed qiskit useable qiskit aer vice versa p id hope newbie programming whole dont feel like scavenging internet resources help learn said languages id like learn qiskit first pay account custom projects quantum p id appreciate insight thanks,"[(0, 0.15139353), (8, 0.38997126), (13, 0.10405886), (14, 0.207437), (17, 0.058281362), (18, 0.08686007)]"
38713,38714.0,2024-06-11 06:41:25,2,236,"<p>In the CHSH game where Alice and Bob share one EPR the optimal strategy is to measure the following observables <span class=""math-container"">$A_0=Z,A_1=X,B_0=1/\sqrt{2}(X+Z),B_1=1/\sqrt{2}(X-Z)$</span> depending on their question. We can see that the optimal strategy is projective measurement instead of general measurement. For other nonlocal games does it suffice to consider only projective measurement to get a optimal strategy?</p>
<p>For example in <a href=""https://doi.org/10.1016/0375-9601(95)00214-n"" rel=""nofollow noreferrer"">this paper</a> equation (3) only the projective measurement of dimension 4 is considered for CHSH games sharing a general state.</p>
<p>In the QCQI section 2.2.8 it is proved that any general measurement can be changed into a projective measurement where an auxiliary bit is introduced, so the dimension of the operator is enlarged. To get an optimal strategy, do we need to search the projective measurement in the enlarged Hilbert space?</p>
",Why are only projective measurements considered in nonlocal games to get optimal strategy?,<measurement><projection-operator><non-locality><nonlocal-games>,1,0,,,"Why are only projective measurements considered in nonlocal games to get optimal strategy? <p>In the CHSH game where Alice and Bob share one EPR the optimal strategy is to measure the following observables <span class=""math-container"">$A_0=Z,A_1=X,B_0=1/\sqrt{2}(X+Z),B_1=1/\sqrt{2}(X-Z)$</span> depending on their question. We can see that the optimal strategy is projective measurement instead of general measurement. For other nonlocal games does it suffice to consider only projective measurement to get a optimal strategy?</p>
<p>For example in <a href=""https://doi.org/10.1016/0375-9601(95)00214-n"" rel=""nofollow noreferrer"">this paper</a> equation (3) only the projective measurement of dimension 4 is considered for CHSH games sharing a general state.</p>
<p>In the QCQI section 2.2.8 it is proved that any general measurement can be changed into a projective measurement where an auxiliary bit is introduced, so the dimension of the operator is enlarged. To get an optimal strategy, do we need to search the projective measurement in the enlarged Hilbert space?</p>
",qc,projective measurements considered nonlocal games get optimal strategy p chsh game alice bob share one epr optimal strategy measure following observables span 2 2 depending question see optimal strategy projective measurement instead general measurement nonlocal games suffice consider projective measurement get optimal strategy p example https 95 nofollow noreferrer paper equation 3 projective measurement dimension 4 considered chsh games sharing general p qcqi section proved general measurement changed projective measurement auxiliary bit introduced dimension operator enlarged get optimal strategy need search projective measurement enlarged hilbert space,"[(2, 0.089731485), (3, 0.40647793), (4, 0.046326376), (12, 0.011776299), (17, 0.0327422), (18, 0.41132015)]"
38735,38758.0,2024-06-12 18:43:16,6,839,"<p>The surface code comes in both odd-distance and even-distance forms. Color codes always seem to come in odd-distance. Presumably this is due to the fact that the X and Z observables overlap at the boundary of a color code, and they must anticommute, forcing an odd boundary length. But is this <em>actually</em> a constraint, or are there ways to get nice even-distance color codes? What if implicit assumptions are dropped, like planar vs toric topology or the usage of two-color-type boundaries instead of pauli-type boundaries?</p>
<p><a href=""https://i.sstatic.net/49k3TaLj.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/49k3TaLj.png"" alt=""enter image description here"" /></a></p>
",Are there even distance color codes?,<color-code>,4,0,,,"Are there even distance color codes? <p>The surface code comes in both odd-distance and even-distance forms. Color codes always seem to come in odd-distance. Presumably this is due to the fact that the X and Z observables overlap at the boundary of a color code, and they must anticommute, forcing an odd boundary length. But is this <em>actually</em> a constraint, or are there ways to get nice even-distance color codes? What if implicit assumptions are dropped, like planar vs toric topology or the usage of two-color-type boundaries instead of pauli-type boundaries?</p>
<p><a href=""https://i.sstatic.net/49k3TaLj.png"" rel=""noreferrer""><img src=""https://i.sstatic.net/49k3TaLj.png"" alt=""enter image description here"" /></a></p>
",qc,even distance color codes p surface code comes forms color codes always seem come presumably due fact x z observables overlap boundary color code must anticommute forcing odd boundary length em actually constraint ways get nice color codes implicit assumptions dropped like planar vs toric topology usage boundaries instead boundaries p https noreferrer img https enter image description,"[(4, 0.13118508), (5, 0.32287005), (7, 0.26912), (10, 0.019076545), (11, 0.017631), (13, 0.1101595), (14, 0.10943087), (17, 0.018463396)]"
38741,,2024-06-12 22:03:58,0,56,"<p>The following code is a simple repetition code (for two qubits and one ancilla) for detecting Z errors:</p>
<pre><code>eps = 0.1

circuit = stim.Circuit()
circuit.append(&quot;RX&quot;, [0,1,2])

circuit.append(&quot;DEPOLARIZE2&quot;, [0,2], eps)
circuit.append(&quot;CNOT&quot;, [2,0])
circuit.append(&quot;CNOT&quot;, [2,1])

circuit.append(&quot;MRX&quot;, [2])
circuit.append(&quot;DETECTOR&quot;, [stim.target_rec(-1)])


circuit.append(&quot;CNOT&quot;, [2,0])
circuit.append(&quot;CNOT&quot;, [2,1])

circuit.append(&quot;MRX&quot;, [2])
circuit.append(&quot;DETECTOR&quot;, [stim.target_rec(-2),stim.target_rec(-1)])
</code></pre>
<p><a href=""https://i.sstatic.net/wKUZQkY8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wKUZQkY8.png"" alt=""enter image description here"" /></a></p>
<p>Errors on detections are different from the ones I expect to get from a transferring depolarzing2 to z2_error model [e----&gt;(12/15 * e)]. In other words, I would expect to get error 4*e/15 for each detection D0, D1, and {D0D1}. I am wondering what I am missing.</p>
",detector_error_model with stim,<stim>,0,4,,,"detector_error_model with stim <p>The following code is a simple repetition code (for two qubits and one ancilla) for detecting Z errors:</p>
<pre><code>eps = 0.1

circuit = stim.Circuit()
circuit.append(&quot;RX&quot;, [0,1,2])

circuit.append(&quot;DEPOLARIZE2&quot;, [0,2], eps)
circuit.append(&quot;CNOT&quot;, [2,0])
circuit.append(&quot;CNOT&quot;, [2,1])

circuit.append(&quot;MRX&quot;, [2])
circuit.append(&quot;DETECTOR&quot;, [stim.target_rec(-1)])


circuit.append(&quot;CNOT&quot;, [2,0])
circuit.append(&quot;CNOT&quot;, [2,1])

circuit.append(&quot;MRX&quot;, [2])
circuit.append(&quot;DETECTOR&quot;, [stim.target_rec(-2),stim.target_rec(-1)])
</code></pre>
<p><a href=""https://i.sstatic.net/wKUZQkY8.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/wKUZQkY8.png"" alt=""enter image description here"" /></a></p>
<p>Errors on detections are different from the ones I expect to get from a transferring depolarzing2 to z2_error model [e----&gt;(12/15 * e)]. In other words, I would expect to get error 4*e/15 for each detection D0, D1, and {D0D1}. I am wondering what I am missing.</p>
",qc,stim p following code simple repetition code two qubits one ancilla detecting z errors pre code eps circuit quot rx quot quot depolarize2 quot eps quot cnot quot quot cnot quot quot mrx quot 2 quot detector quot quot cnot quot quot cnot quot quot mrx quot 2 quot detector quot p https nofollow noreferrer img https enter image description p errors detections different ones expect get transferring depolarzing2 model e gt e words would expect get error 4 detection d0 d1 d0d1 wondering,"[(4, 0.3024296), (5, 0.2122856), (6, 0.09627056), (8, 0.06445093), (17, 0.02744859), (19, 0.29540852)]"
38762,38763.0,2024-06-14 07:19:12,1,93,"<p>There are many posts to this question from Nielson and Chuang's Quantum Computation and Quantum Information Exercise 1.2 page 57. It is required to prove that if a hypothetical device exists, which could distinguish between two non-orthogonal quantum states <span class=""math-container"">$|\psi\rangle$</span>  or <span class=""math-container"">$|\phi\rangle$</span>  and correctly output the answer, we could create a device that cloned the states <span class=""math-container"">$|\psi\rangle$</span>  and <span class=""math-container"">$|\phi\rangle$</span> , contradicting the no-cloning theorem.</p>
<p>I propose an algorithm that will clone any state.</p>
<ol>
<li>Take <span class=""math-container"">$|\psi\rangle$</span>  and <span class=""math-container"">$|\psi'\rangle$</span>  as basis, with <span class=""math-container"">$|\psi'\rangle$</span>  being orthogonal to <span class=""math-container"">$|\psi\rangle$</span> .</li>
<li>Measure a new qubit with this basis.</li>
<li>If the result is <span class=""math-container"">$|\psi\rangle$</span> , then we are done. If the result is <span class=""math-container"">$|\psi'\rangle$</span> , then use the X gate to get <span class=""math-container"">$|\psi\rangle$</span>  as the result.</li>
<li>Repeat this for all other qubits taking those qubits and their orthogonal qubit as the basis.</li>
</ol>
<p>I suspect that changing the basis is a problem, but I am not able to pinpoint what exactly is the problem. I am quite new to quantum computing and even anything quantum in general. So, I require easy-to-understand explanations.</p>
<p>In other answers, cloning <span class=""math-container"">$|\psi\rangle$</span>  is considered trivial if we identify which one of the qubits is <span class=""math-container"">$|\psi\rangle$</span> . But this is not trivial to me, we only know that this qubit is <span class=""math-container"">$|\psi\rangle$</span>  and not <span class=""math-container"">$|\phi\rangle$</span>  but we didn't know the states of <span class=""math-container"">$|\psi\rangle$</span>  and <span class=""math-container"">$|\phi\rangle$</span>  from the beginning. We only know that out of two unknown non-orthogonal states, our test qubit is <span class=""math-container"">$|\psi\rangle$</span> , and <span class=""math-container"">$|\phi\rangle$</span>  is the other one. So how can we clone a qubit if nothing is known about it?</p>
",No-cloning theorem and distinguishing between two non-orthogonal quantum states revisited revisited,<quantum-state><nielsen-and-chuang><no-cloning-theorem><cloning>,2,0,,,"No-cloning theorem and distinguishing between two non-orthogonal quantum states revisited revisited <p>There are many posts to this question from Nielson and Chuang's Quantum Computation and Quantum Information Exercise 1.2 page 57. It is required to prove that if a hypothetical device exists, which could distinguish between two non-orthogonal quantum states <span class=""math-container"">$|\psi\rangle$</span>  or <span class=""math-container"">$|\phi\rangle$</span>  and correctly output the answer, we could create a device that cloned the states <span class=""math-container"">$|\psi\rangle$</span>  and <span class=""math-container"">$|\phi\rangle$</span> , contradicting the no-cloning theorem.</p>
<p>I propose an algorithm that will clone any state.</p>
<ol>
<li>Take <span class=""math-container"">$|\psi\rangle$</span>  and <span class=""math-container"">$|\psi'\rangle$</span>  as basis, with <span class=""math-container"">$|\psi'\rangle$</span>  being orthogonal to <span class=""math-container"">$|\psi\rangle$</span> .</li>
<li>Measure a new qubit with this basis.</li>
<li>If the result is <span class=""math-container"">$|\psi\rangle$</span> , then we are done. If the result is <span class=""math-container"">$|\psi'\rangle$</span> , then use the X gate to get <span class=""math-container"">$|\psi\rangle$</span>  as the result.</li>
<li>Repeat this for all other qubits taking those qubits and their orthogonal qubit as the basis.</li>
</ol>
<p>I suspect that changing the basis is a problem, but I am not able to pinpoint what exactly is the problem. I am quite new to quantum computing and even anything quantum in general. So, I require easy-to-understand explanations.</p>
<p>In other answers, cloning <span class=""math-container"">$|\psi\rangle$</span>  is considered trivial if we identify which one of the qubits is <span class=""math-container"">$|\psi\rangle$</span> . But this is not trivial to me, we only know that this qubit is <span class=""math-container"">$|\psi\rangle$</span>  and not <span class=""math-container"">$|\phi\rangle$</span>  but we didn't know the states of <span class=""math-container"">$|\psi\rangle$</span>  and <span class=""math-container"">$|\phi\rangle$</span>  from the beginning. We only know that out of two unknown non-orthogonal states, our test qubit is <span class=""math-container"">$|\psi\rangle$</span> , and <span class=""math-container"">$|\phi\rangle$</span>  is the other one. So how can we clone a qubit if nothing is known about it?</p>
",qc,theorem distinguishing two quantum states revisited revisited p many posts question nielson chuang quantum computation quantum information exercise page required prove hypothetical device exists could distinguish two quantum states span span correctly output answer could create device cloned states span span contradicting p propose algorithm clone ol li take span span basis span orthogonal span li measure new qubit li result span done result span use x gate get span li repeat qubits taking qubits orthogonal qubit p suspect changing basis problem able pinpoint exactly problem quite new quantum computing even anything quantum general require p answers cloning span considered trivial identify one qubits span trivial know qubit span span know states span span beginning know two unknown states test qubit span span one clone qubit nothing known,"[(3, 0.38942778), (7, 0.050224733), (8, 0.16243608), (17, 0.081776254), (18, 0.30662915)]"
38776,,2024-06-14 21:26:05,0,31,"<p>Suppose I have 4 qubits and I have the density matrix on qubits 1, 3 and I want to take the tensor product with the identity on the 2nd and 4th qubits for example. What is the fastest way to code this? I can think of writing a large swap operation but I wanted to see if there is a better way of implementing this.</p>
",Take kronecker product of non-adjacent qubits,<quantum-state><linear-algebra>,0,5,,,"Take kronecker product of non-adjacent qubits <p>Suppose I have 4 qubits and I have the density matrix on qubits 1, 3 and I want to take the tensor product with the identity on the 2nd and 4th qubits for example. What is the fastest way to code this? I can think of writing a large swap operation but I wanted to see if there is a better way of implementing this.</p>
",qc,take kronecker product qubits p suppose 4 qubits density matrix qubits 1 3 want take tensor product identity 2nd 4th qubits example fastest way code think writing large swap operation wanted see better way implementing,"[(2, 0.105726294), (8, 0.07870539), (11, 0.08638011), (14, 0.297786), (17, 0.031315934), (18, 0.3961071)]"
38790,,2024-06-15 15:24:41,0,234,"<p>I am quite new to qiskit and i am trying to build a qaoa for portfolio optimization, but i get this error and i am not able to resolve this issue: ValueError: The number of qubits of the circuit (127) does not match the number of qubits of the ()-th observable (4).</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService, Session
from qiskit.primitives import BackendEstimatorV2
from qiskit import QuantumCircuit, transpile
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
import numpy as np

# Load your IBM Quantum account
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)

# Select the least busy backend
backend = service.least_busy(operational=True, simulator=False)
print(f&quot;Selected backend: {backend.name}&quot;)

num_assets = 4  # Number of assets (qubits)
q2 = 0.5  # Risk factor

# Create a quantum circuit for QAOA with num_assets qubits
qc = QuantumCircuit(num_assets, num_assets)

# Apply Hadamard gates to all qubits
qc.h(range(num_assets))

# Define QAOA parameters for multiple layers (reps)
gamma = [Parameter(f'γ{i}') for i in range(3)]
beta = [Parameter(f'β{i}') for i in range(3)]

# Apply parameterized gates with entangling gates (beta and gamma angles)
for i in range(3):  # Number of repetitions (layers)
    for qubit in range(num_assets):
        qc.rz(gamma[i], qubit)
    for qubit in range(num_assets):
        qc.rx(beta[i], qubit)
    for qubit in range(num_assets - 1):
        qc.cz(qubit, qubit + 1)

# Bind parameters with specific values
param_values = {gamma[i]: 2 * q2 for i in range(3)}
param_values.update({beta[i]: np.pi / 2 for i in range(3)})

# Assign the parameters to the circuit
qc = qc.assign_parameters(param_values)

# Add measurements at the end for each qubit
qc.measure(range(num_assets), range(num_assets))

# Transpile the circuit for the selected backend with an initial layout that matches num_assets
initial_layout = list(range(num_assets))
qc_transpiled = transpile(qc, backend=backend, initial_layout=initial_layout, optimization_level=1)

# Define the observable correctly matching the number of qubits in the circuit
observable = SparsePauliOp.from_list([(&quot;Z&quot; * num_assets, 1.0)])  # Ensure this matches num_assets

# Create a session for the Estimator and run it
with Session(service=service, backend=backend) as session:
    estimator = BackendEstimatorV2(backend=backend)
    job = estimator.run([(qc_transpiled, observable)])
    result = job.result()

# Print the result
print(result)
</code></pre>
<p>ValueError: The number of qubits of the circuit (127) does not match the number of qubits of the ()-th observable (4).</p>
",ValueError: The number of qubits of the circuit (127) does not match the number of qubits of the ()-th observable (4),<qiskit><qaoa>,1,0,,,"ValueError: The number of qubits of the circuit (127) does not match the number of qubits of the ()-th observable (4) <p>I am quite new to qiskit and i am trying to build a qaoa for portfolio optimization, but i get this error and i am not able to resolve this issue: ValueError: The number of qubits of the circuit (127) does not match the number of qubits of the ()-th observable (4).</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService, Session
from qiskit.primitives import BackendEstimatorV2
from qiskit import QuantumCircuit, transpile
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp
import numpy as np

# Load your IBM Quantum account
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;)

# Select the least busy backend
backend = service.least_busy(operational=True, simulator=False)
print(f&quot;Selected backend: {backend.name}&quot;)

num_assets = 4  # Number of assets (qubits)
q2 = 0.5  # Risk factor

# Create a quantum circuit for QAOA with num_assets qubits
qc = QuantumCircuit(num_assets, num_assets)

# Apply Hadamard gates to all qubits
qc.h(range(num_assets))

# Define QAOA parameters for multiple layers (reps)
gamma = [Parameter(f'γ{i}') for i in range(3)]
beta = [Parameter(f'β{i}') for i in range(3)]

# Apply parameterized gates with entangling gates (beta and gamma angles)
for i in range(3):  # Number of repetitions (layers)
    for qubit in range(num_assets):
        qc.rz(gamma[i], qubit)
    for qubit in range(num_assets):
        qc.rx(beta[i], qubit)
    for qubit in range(num_assets - 1):
        qc.cz(qubit, qubit + 1)

# Bind parameters with specific values
param_values = {gamma[i]: 2 * q2 for i in range(3)}
param_values.update({beta[i]: np.pi / 2 for i in range(3)})

# Assign the parameters to the circuit
qc = qc.assign_parameters(param_values)

# Add measurements at the end for each qubit
qc.measure(range(num_assets), range(num_assets))

# Transpile the circuit for the selected backend with an initial layout that matches num_assets
initial_layout = list(range(num_assets))
qc_transpiled = transpile(qc, backend=backend, initial_layout=initial_layout, optimization_level=1)

# Define the observable correctly matching the number of qubits in the circuit
observable = SparsePauliOp.from_list([(&quot;Z&quot; * num_assets, 1.0)])  # Ensure this matches num_assets

# Create a session for the Estimator and run it
with Session(service=service, backend=backend) as session:
    estimator = BackendEstimatorV2(backend=backend)
    job = estimator.run([(qc_transpiled, observable)])
    result = job.result()

# Print the result
print(result)
</code></pre>
<p>ValueError: The number of qubits of the circuit (127) does not match the number of qubits of the ()-th observable (4).</p>
",qc,valueerror number qubits circuit 127 match number qubits observable 4 p quite new qiskit trying build qaoa portfolio optimization get error able resolve issue valueerror number qubits circuit 127 match number qubits observable 4 pre code import qiskitruntimeservice session import backendestimatorv2 qiskit import quantumcircuit transpile import parameter import sparsepauliop import numpy np load ibm quantum account service qiskitruntimeservice quot quot select least busy backend backend print f quot selected backend quot 4 number assets qubits q2 risk factor create quantum circuit qaoa qubits qc quantumcircuit apply hadamard gates qubits range define qaoa parameters multiple layers reps gamma parameter f γ range 3 beta parameter f β range 3 apply parameterized gates entangling gates beta gamma angles range 3 number repetitions layers qubit range gamma qubit qubit range beta qubit qubit range 1 qubit qubit 1 bind parameters specific values gamma 2 q2 range 3 beta 2 range 3 assign parameters circuit qc add measurements end qubit range range transpile circuit selected backend initial layout matches list range transpile qc define observable correctly matching number qubits circuit observable quot z quot ensure matches create session estimator run session session estimator backendestimatorv2 job observable result print result print result p valueerror number qubits circuit 127 match number qubits observable 4,"[(0, 0.5172536), (6, 0.026523056), (14, 0.322815), (17, 0.012884427), (18, 0.04939573), (19, 0.06593885)]"
38900,38901.0,2024-06-24 19:10:57,0,133,"<p>I am struggling with the inverse function of qiskit.
<a href=""https://www.youtube.com/watch?v=SiPF2SVb7xc"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=SiPF2SVb7xc</a>
The inverse function works for the example shown in the video but it is not working for the circuit I am testing it below as shown:</p>
<pre><code>qc = QuantumCircuit(5)
for i in range(2):
    qc.h(i+1)
    
for i in range(2):
    qc.swap(i+1, i+2+1)
    
for i in range(2):
    qc.h(i+1)

qc.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/9PDoc1KN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9PDoc1KN.png"" alt=""enter image description here"" /></a></p>
<pre><code>qc.inverse()
qc.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/jtZvASmF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jtZvASmF.png"" alt=""enter image description here"" /></a></p>
<p>It would be really great help if someone can explain me what I am doing wrong.</p>
",inverse function in qiskit not generating inverted circuits,<qiskit><programming>,1,0,,,"inverse function in qiskit not generating inverted circuits <p>I am struggling with the inverse function of qiskit.
<a href=""https://www.youtube.com/watch?v=SiPF2SVb7xc"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=SiPF2SVb7xc</a>
The inverse function works for the example shown in the video but it is not working for the circuit I am testing it below as shown:</p>
<pre><code>qc = QuantumCircuit(5)
for i in range(2):
    qc.h(i+1)
    
for i in range(2):
    qc.swap(i+1, i+2+1)
    
for i in range(2):
    qc.h(i+1)

qc.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/9PDoc1KN.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/9PDoc1KN.png"" alt=""enter image description here"" /></a></p>
<pre><code>qc.inverse()
qc.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/jtZvASmF.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/jtZvASmF.png"" alt=""enter image description here"" /></a></p>
<p>It would be really great help if someone can explain me what I am doing wrong.</p>
",qc,inverse function qiskit generating inverted circuits p struggling inverse function qiskit https nofollow noreferrer https inverse function works example shown video working circuit testing shown pre code qc quantumcircuit 5 range 2 range 2 range 2 p https nofollow noreferrer img https enter image description pre code p https nofollow noreferrer img https enter image description p would really great help someone explain,"[(0, 0.27921465), (4, 0.60924274), (14, 0.09144114), (17, 0.017568147)]"
38953,,2024-06-28 21:39:15,4,92,"<p>I am working on implementing QPE for calculating the ground state energy of a small molecule like H2 or HeH+. I've written some code that is getting results within about 10% accuracy, but I'm not entirely sure it is correct or why the accuracy is not better. Here is the code:</p>
<pre><code>def get_qubit_op(dist):
    molecule = MoleculeInfo(
        symbols=[&quot;H&quot;, &quot;H&quot;],
        coords=([0.0, 0.0, 0.0], [dist, 0.0, 0.0]),
        multiplicity = 1,
        charge = 0,
    )

    driver = PySCFDriver.from_molecule(molecule)
    problem = driver.run()

    num_particles = problem.num_particles
    num_spatial_orbitals = problem.num_spatial_orbitals
    mapper = ParityMapper(num_particles=num_particles)
    qubit_op = mapper.map(problem.second_q_ops()[0])
    
    return qubit_op, num_particles, num_spatial_orbitals, problem, mapper

def exact_solver(qubit_op, problem):
    sol = NumPyMinimumEigensolver().compute_minimum_eigenvalue(qubit_op)
    result = problem.interpret(sol)
    return result

for dist in np.arange(0.5, 1.7, 0.1):
    (qubit_op, num_particles, num_spatial_orbitals, problem, mapper) = get_qubit_op(dist)
    
    # Calculate exact eigenvalues with NumPyEigensolver for reference
    result = exact_solver(qubit_op, problem)
    exact_energy = result.total_energies[0].real
    #print(f&quot;Exact ground state energy: {exact_energy - problem.nuclear_repulsion_energy} Hartree&quot;)
    
    num_qubits = qubit_op.num_qubits
    
    # Set up the QPE circuit
    n_ancillas = 12  # Number of ancilla qubits for phase estimation
    qc = QuantumCircuit(n_ancillas + num_qubits, n_ancillas)
    qc.x(n_ancillas) # For Hartree-Fock initial state
    qc.h(range(n_ancillas))
    
    # Apply the controlled unitary operations
    for i in range(n_ancillas):
        evolution_gate = PauliEvolutionGate(qubit_op, time = 2 ** i)
        qc.append(evolution_gate.control(), [i] + list(range(n_ancillas, n_ancillas + num_qubits)))
    
    qc.append(QFT(n_ancillas, inverse=True), range(n_ancillas))
    qc.measure(range(n_ancillas), range(n_ancillas))

    # Execute the circuit
    sampler = StatevectorSampler()
    shots = 10000
    job_sampler = sampler.run([qc], shots=shots)
    result_sampler = job_sampler.result()
    counts = result_sampler[0].data.c.get_counts()
    
    # Assuming counts is a dictionary with bitstrings as keys and counts as values
    energies = []
    probabilities = []
    total_counts = sum(counts.values())
    
    for bitstring, count in counts.items():
        phase = int(bitstring, 2) / 2 ** n_ancillas
        evolution_time = 1
        energy = -1 * (phase * (2 * np.pi) / evolution_time)
        probabilities.append(count / total_counts)
        energies.append(energy)
    
    # Calculate expected value of energy
    expected_energy = sum(p * e for p, e in zip(probabilities, energies))
    
    #print(&quot;Expected ground state energy: &quot;, expected_energy)
    print(f&quot;Distance: {round(dist,2)} | Exact Energy: {round(exact_energy - problem.nuclear_repulsion_energy,14)} | QPE Energy: {round(expected_energy,14)} | Error: {round((expected_energy - (exact_energy - problem.nuclear_repulsion_energy))/expected_energy*100,2)}&quot;)
</code></pre>
<p>You can use these installs and imports, maybe in a venv or google colab:</p>
<pre><code># %pip install qiskit[visualization]==1.0.2
# %pip install qiskit_aer
# %pip install qiskit_ibm_runtime
# %pip install qiskit_algorithms
# %pip install qiskit_nature
# %pip install matplotlib
# %pip install pylatexenc
# %pip install pyscf

import numpy as np
from qiskit_aer import AerSimulator
from qiskit import QuantumCircuit, transpile
from qiskit.circuit import QuantumRegister, ClassicalRegister
from qiskit.circuit.library import QFT
from qiskit.quantum_info import Pauli
from qiskit_algorithms.minimum_eigensolvers import NumPyMinimumEigensolver
from qiskit_algorithms import NumPyEigensolver
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.mappers import ParityMapper
from qiskit.circuit.library import QFT, PauliEvolutionGate
from qiskit.quantum_info import Statevector, Operator, SparsePauliOp
from qiskit.primitives import StatevectorSampler, PrimitiveJob
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit.quantum_info import Operator
</code></pre>
<p>A few things I'm unsure of:</p>
<ol>
<li><p>This differs quite a bit from the approach given by Classiq here (<a href=""https://github.com/Classiq/classiq-library/blob/main/applications/chemistry/qpe_for_molecules/qpe_for_molecules.ipynb"" rel=""nofollow noreferrer"">https://github.com/Classiq/classiq-library/blob/main/applications/chemistry/qpe_for_molecules/qpe_for_molecules.ipynb</a>) in that I am not normalizing the matrix beforehand, and I am calculating the final energy from the phases differently (by summing the product of the probabilities and estimated energies). While it seems better to not normalize beforehand in one sense - you don't necessarily need to calculate the eigenvalues on a classical computer before doing it redundantly on the quantum computer - I'm not sure why this method is working compared to theirs.</p>
</li>
<li><p>The values I am getting are still somewhat far from the correct value. Below are the energies I obtained by running the above code. In some cases the error is high, such as 7.5%. Changing the number of ancillary qubits or shots does not seem to improve this.</p>
</li>
</ol>
<pre><code>Distance: 0.5 | Exact Energy: -2.11351421631063 | QPE Energy: -2.14500905415295 | Error: 1.47
Distance: 0.6 | Exact Energy: -1.99824802506954 | QPE Energy: -2.08107319510811 | Error: 3.98
Distance: 0.7 | Exact Energy: -1.89215689823735 | QPE Energy: -1.96451734649451 | Error: 3.68
Distance: 0.8 | Exact Energy: -1.7956191803271  | QPE Energy: -1.79854492039149 | Error: 0.16
Distance: 0.9 | Exact Energy: -1.70853496009999 | QPE Energy: -1.81276538248943 | Error: 5.75
Distance: 1.0 | Exact Energy: -1.63032754115262 | QPE Energy: -1.73071413072813 | Error: 5.8
Distance: 1.1 | Exact Energy: -1.56026313671453 | QPE Energy: -1.61435002971302 | Error: 3.35
Distance: 1.2 | Exact Energy: -1.49772175540526 | QPE Energy: -1.54652737014784 | Error: 3.16
Distance: 1.3 | Exact Energy: -1.44224565944964 | QPE Energy: -1.50579143653899 | Error: 4.22
Distance: 1.4 | Exact Energy: -1.39345197137396 | QPE Energy: -1.49800663743854 | Error: 6.98
Distance: 1.5 | Exact Energy: -1.35093416075141 | QPE Energy: -1.46044481687598 | Error: 7.5
Distance: 1.6 | Exact Energy: -1.31420848585817 | QPE Energy: -1.4036941238416  | Error: 6.38
</code></pre>
<p>I appreciate the help fixing this algorithm implementation.</p>
",Quantum Phase Estimation for Chemical Hamiltonian,<qiskit><hamiltonian-simulation><quantum-phase-estimation><chemistry>,0,0,,,"Quantum Phase Estimation for Chemical Hamiltonian <p>I am working on implementing QPE for calculating the ground state energy of a small molecule like H2 or HeH+. I've written some code that is getting results within about 10% accuracy, but I'm not entirely sure it is correct or why the accuracy is not better. Here is the code:</p>
<pre><code>def get_qubit_op(dist):
    molecule = MoleculeInfo(
        symbols=[&quot;H&quot;, &quot;H&quot;],
        coords=([0.0, 0.0, 0.0], [dist, 0.0, 0.0]),
        multiplicity = 1,
        charge = 0,
    )

    driver = PySCFDriver.from_molecule(molecule)
    problem = driver.run()

    num_particles = problem.num_particles
    num_spatial_orbitals = problem.num_spatial_orbitals
    mapper = ParityMapper(num_particles=num_particles)
    qubit_op = mapper.map(problem.second_q_ops()[0])
    
    return qubit_op, num_particles, num_spatial_orbitals, problem, mapper

def exact_solver(qubit_op, problem):
    sol = NumPyMinimumEigensolver().compute_minimum_eigenvalue(qubit_op)
    result = problem.interpret(sol)
    return result

for dist in np.arange(0.5, 1.7, 0.1):
    (qubit_op, num_particles, num_spatial_orbitals, problem, mapper) = get_qubit_op(dist)
    
    # Calculate exact eigenvalues with NumPyEigensolver for reference
    result = exact_solver(qubit_op, problem)
    exact_energy = result.total_energies[0].real
    #print(f&quot;Exact ground state energy: {exact_energy - problem.nuclear_repulsion_energy} Hartree&quot;)
    
    num_qubits = qubit_op.num_qubits
    
    # Set up the QPE circuit
    n_ancillas = 12  # Number of ancilla qubits for phase estimation
    qc = QuantumCircuit(n_ancillas + num_qubits, n_ancillas)
    qc.x(n_ancillas) # For Hartree-Fock initial state
    qc.h(range(n_ancillas))
    
    # Apply the controlled unitary operations
    for i in range(n_ancillas):
        evolution_gate = PauliEvolutionGate(qubit_op, time = 2 ** i)
        qc.append(evolution_gate.control(), [i] + list(range(n_ancillas, n_ancillas + num_qubits)))
    
    qc.append(QFT(n_ancillas, inverse=True), range(n_ancillas))
    qc.measure(range(n_ancillas), range(n_ancillas))

    # Execute the circuit
    sampler = StatevectorSampler()
    shots = 10000
    job_sampler = sampler.run([qc], shots=shots)
    result_sampler = job_sampler.result()
    counts = result_sampler[0].data.c.get_counts()
    
    # Assuming counts is a dictionary with bitstrings as keys and counts as values
    energies = []
    probabilities = []
    total_counts = sum(counts.values())
    
    for bitstring, count in counts.items():
        phase = int(bitstring, 2) / 2 ** n_ancillas
        evolution_time = 1
        energy = -1 * (phase * (2 * np.pi) / evolution_time)
        probabilities.append(count / total_counts)
        energies.append(energy)
    
    # Calculate expected value of energy
    expected_energy = sum(p * e for p, e in zip(probabilities, energies))
    
    #print(&quot;Expected ground state energy: &quot;, expected_energy)
    print(f&quot;Distance: {round(dist,2)} | Exact Energy: {round(exact_energy - problem.nuclear_repulsion_energy,14)} | QPE Energy: {round(expected_energy,14)} | Error: {round((expected_energy - (exact_energy - problem.nuclear_repulsion_energy))/expected_energy*100,2)}&quot;)
</code></pre>
<p>You can use these installs and imports, maybe in a venv or google colab:</p>
<pre><code># %pip install qiskit[visualization]==1.0.2
# %pip install qiskit_aer
# %pip install qiskit_ibm_runtime
# %pip install qiskit_algorithms
# %pip install qiskit_nature
# %pip install matplotlib
# %pip install pylatexenc
# %pip install pyscf

import numpy as np
from qiskit_aer import AerSimulator
from qiskit import QuantumCircuit, transpile
from qiskit.circuit import QuantumRegister, ClassicalRegister
from qiskit.circuit.library import QFT
from qiskit.quantum_info import Pauli
from qiskit_algorithms.minimum_eigensolvers import NumPyMinimumEigensolver
from qiskit_algorithms import NumPyEigensolver
from qiskit_nature.second_q.drivers import PySCFDriver
from qiskit_nature.second_q.mappers import ParityMapper
from qiskit.circuit.library import QFT, PauliEvolutionGate
from qiskit.quantum_info import Statevector, Operator, SparsePauliOp
from qiskit.primitives import StatevectorSampler, PrimitiveJob
from qiskit_nature.second_q.formats.molecule_info import MoleculeInfo
from qiskit_nature.second_q.transformers import FreezeCoreTransformer
from qiskit.quantum_info import Operator
</code></pre>
<p>A few things I'm unsure of:</p>
<ol>
<li><p>This differs quite a bit from the approach given by Classiq here (<a href=""https://github.com/Classiq/classiq-library/blob/main/applications/chemistry/qpe_for_molecules/qpe_for_molecules.ipynb"" rel=""nofollow noreferrer"">https://github.com/Classiq/classiq-library/blob/main/applications/chemistry/qpe_for_molecules/qpe_for_molecules.ipynb</a>) in that I am not normalizing the matrix beforehand, and I am calculating the final energy from the phases differently (by summing the product of the probabilities and estimated energies). While it seems better to not normalize beforehand in one sense - you don't necessarily need to calculate the eigenvalues on a classical computer before doing it redundantly on the quantum computer - I'm not sure why this method is working compared to theirs.</p>
</li>
<li><p>The values I am getting are still somewhat far from the correct value. Below are the energies I obtained by running the above code. In some cases the error is high, such as 7.5%. Changing the number of ancillary qubits or shots does not seem to improve this.</p>
</li>
</ol>
<pre><code>Distance: 0.5 | Exact Energy: -2.11351421631063 | QPE Energy: -2.14500905415295 | Error: 1.47
Distance: 0.6 | Exact Energy: -1.99824802506954 | QPE Energy: -2.08107319510811 | Error: 3.98
Distance: 0.7 | Exact Energy: -1.89215689823735 | QPE Energy: -1.96451734649451 | Error: 3.68
Distance: 0.8 | Exact Energy: -1.7956191803271  | QPE Energy: -1.79854492039149 | Error: 0.16
Distance: 0.9 | Exact Energy: -1.70853496009999 | QPE Energy: -1.81276538248943 | Error: 5.75
Distance: 1.0 | Exact Energy: -1.63032754115262 | QPE Energy: -1.73071413072813 | Error: 5.8
Distance: 1.1 | Exact Energy: -1.56026313671453 | QPE Energy: -1.61435002971302 | Error: 3.35
Distance: 1.2 | Exact Energy: -1.49772175540526 | QPE Energy: -1.54652737014784 | Error: 3.16
Distance: 1.3 | Exact Energy: -1.44224565944964 | QPE Energy: -1.50579143653899 | Error: 4.22
Distance: 1.4 | Exact Energy: -1.39345197137396 | QPE Energy: -1.49800663743854 | Error: 6.98
Distance: 1.5 | Exact Energy: -1.35093416075141 | QPE Energy: -1.46044481687598 | Error: 7.5
Distance: 1.6 | Exact Energy: -1.31420848585817 | QPE Energy: -1.4036941238416  | Error: 6.38
</code></pre>
<p>I appreciate the help fixing this algorithm implementation.</p>
",qc,quantum phase estimation chemical hamiltonian p working implementing qpe calculating ground state energy small molecule like h2 written code getting results within 10 accuracy entirely sure correct accuracy better code pre code def dist molecule moleculeinfo quot h quot quot h quot dist multiplicity 1 charge 0 driver molecule problem mapper paritymapper 0 return problem mapper def problem sol numpyminimumeigensolver result sol return result dist problem mapper dist calculate exact eigenvalues numpyeigensolver reference result problem 0 print f quot exact ground state energy hartree quot set qpe circuit 12 number ancilla qubits phase estimation qc quantumcircuit initial state range apply controlled unitary operations range paulievolutiongate time 2 list range qft range range range execute circuit sampler statevectorsampler shots 10000 qc counts 0 assuming counts dictionary bitstrings keys counts values energies probabilities sum bitstring count phase int bitstring 2 2 1 energy phase 2 count energy calculate expected value energy sum p e p e zip probabilities energies print quot expected ground state energy quot print f quot distance round exact energy round qpe energy round error round quot p use installs imports maybe venv google colab pre code pip install qiskit visualization pip install pip install pip install pip install pip install matplotlib pip install pylatexenc pip install pyscf import numpy np import aersimulator qiskit import quantumcircuit transpile import quantumregister classicalregister import qft import pauli import numpyminimumeigensolver import numpyeigensolver import pyscfdriver import paritymapper import qft paulievolutiongate import statevector operator sparsepauliop import statevectorsampler primitivejob import moleculeinfo import freezecoretransformer import operator p things unsure ol li p differs quite bit approach given classiq https nofollow noreferrer https normalizing matrix beforehand calculating final energy phases differently summing product probabilities estimated energies seems better normalize beforehand one sense necessarily need calculate eigenvalues classical computer redundantly quantum computer sure method working compared li p values getting still somewhat far correct value energies obtained running code cases error high changing number ancillary qubits shots seem improve pre code distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error distance exact energy qpe energy error p appreciate help fixing algorithm,"[(0, 0.33748955), (1, 0.028622696), (2, 0.020393608), (5, 0.046208892), (7, 0.16368157), (8, 0.13049065), (9, 0.012490898), (14, 0.033291332), (17, 0.16958275), (18, 0.021100989), (19, 0.03307318)]"
38982,38984.0,2024-07-02 09:58:41,1,59,"<p>I am reading through Daniel Gottesmans <a href=""https://www.cs.umd.edu/class/spring2024/cmsc858G/"" rel=""nofollow noreferrer"">surviving as a quantum computer in a classical world</a>. On page 36, he presents the following theorem:</p>
<blockquote>
<p>Theorem 2.7 (QECC Conditions). <span class=""math-container"">$(Q, \mathcal{E})$</span> is a <span class=""math-container"">$Q E C C$</span> iff <span class=""math-container"">$\forall|\psi\rangle,|\phi\rangle \in Q, \forall E_a, E_b \in \mathcal{E}$</span>,
<span class=""math-container"">$$
\left\langle\psi\left|E_a^{\dagger} E_b\right| \phi\right\rangle=C_{a b}\langle\psi \mid \phi\rangle .
$$</span></p>
</blockquote>
<p>It then goes onto state that by taking the adjoint of both sides of the equation, you get <span class=""math-container"">$C_{ab}^\dagger=C_{ba}^*$</span>, showing that <span class=""math-container"">$C$</span> is self-adjoint, after you set <span class=""math-container"">$|\psi \rangle =|\phi \rangle$</span>.</p>
<p>All I am getting is</p>
<p><span class=""math-container"">$$
(C_{a b}\langle\psi| \psi\rangle) ^\dagger = \langle \psi| E_{a}^\dagger E_{b} | \psi \rangle)^\dagger = \langle \psi|( E_{a}^\dagger E_{b})^\dagger | \psi \rangle = \langle \psi| E_{b}^\dagger E_{a} | \psi \rangle = C_{ba}\langle \psi| \psi \rangle
$$</span></p>
<p>I am totally lost on how he is taking the adjoint of both sides and getting that result. Maybe I'm just being stupid, or it's been a while since I've worked with this formalism, but I am unsure of how the adjoint is being applied in this instance.</p>
<p>Here is a similar question, but I think it's more  focused on what <span class=""math-container"">$C$</span> actually is, as opposed to this result.</p>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/38081/in-the-qecc-condition-langle-psie-a-dagger-e-b-phi-rangle-c-ab-langle-psi"">In the QECC condition $\langle\psi|E_a^\dagger E_b|\phi\rangle=C_{ab}\langle\psi|\phi\rangle$, what is $C_{ab}$?</a></p>
<p>Edit: It's a typo in the book. Should read <span class=""math-container"">$C_{ab}=C_{ba}^*$</span></p>
",How is $(\langle \psi| E_{a}^\dagger E_{b} | \psi \rangle)^\dagger = C_{ba}^*\langle \psi| \psi \rangle $,<error-correction>,1,0,,,"How is $(\langle \psi| E_{a}^\dagger E_{b} | \psi \rangle)^\dagger = C_{ba}^*\langle \psi| \psi \rangle $ <p>I am reading through Daniel Gottesmans <a href=""https://www.cs.umd.edu/class/spring2024/cmsc858G/"" rel=""nofollow noreferrer"">surviving as a quantum computer in a classical world</a>. On page 36, he presents the following theorem:</p>
<blockquote>
<p>Theorem 2.7 (QECC Conditions). <span class=""math-container"">$(Q, \mathcal{E})$</span> is a <span class=""math-container"">$Q E C C$</span> iff <span class=""math-container"">$\forall|\psi\rangle,|\phi\rangle \in Q, \forall E_a, E_b \in \mathcal{E}$</span>,
<span class=""math-container"">$$
\left\langle\psi\left|E_a^{\dagger} E_b\right| \phi\right\rangle=C_{a b}\langle\psi \mid \phi\rangle .
$$</span></p>
</blockquote>
<p>It then goes onto state that by taking the adjoint of both sides of the equation, you get <span class=""math-container"">$C_{ab}^\dagger=C_{ba}^*$</span>, showing that <span class=""math-container"">$C$</span> is self-adjoint, after you set <span class=""math-container"">$|\psi \rangle =|\phi \rangle$</span>.</p>
<p>All I am getting is</p>
<p><span class=""math-container"">$$
(C_{a b}\langle\psi| \psi\rangle) ^\dagger = \langle \psi| E_{a}^\dagger E_{b} | \psi \rangle)^\dagger = \langle \psi|( E_{a}^\dagger E_{b})^\dagger | \psi \rangle = \langle \psi| E_{b}^\dagger E_{a} | \psi \rangle = C_{ba}\langle \psi| \psi \rangle
$$</span></p>
<p>I am totally lost on how he is taking the adjoint of both sides and getting that result. Maybe I'm just being stupid, or it's been a while since I've worked with this formalism, but I am unsure of how the adjoint is being applied in this instance.</p>
<p>Here is a similar question, but I think it's more  focused on what <span class=""math-container"">$C$</span> actually is, as opposed to this result.</p>
<p><a href=""https://quantumcomputing.stackexchange.com/questions/38081/in-the-qecc-condition-langle-psie-a-dagger-e-b-phi-rangle-c-ab-langle-psi"">In the QECC condition $\langle\psi|E_a^\dagger E_b|\phi\rangle=C_{ab}\langle\psi|\phi\rangle$, what is $C_{ab}$?</a></p>
<p>Edit: It's a typo in the book. Should read <span class=""math-container"">$C_{ab}=C_{ba}^*$</span></p>
",qc,b ba p reading daniel gottesmans https nofollow noreferrer surviving quantum computer classical world page 36 presents following theorem blockquote p theorem qecc conditions span q e span q e c c iff span q e span b p goes onto state taking adjoint sides equation get span ab ba showing span c set span p getting p span b b b b ba p totally lost taking adjoint sides getting result maybe stupid since worked formalism unsure adjoint applied p similar question think focused span c actually opposed p https qecc condition ab ab p edit typo book read span ab ba,"[(1, 0.035291538), (3, 0.6515035), (4, 0.051335316), (7, 0.05789745), (9, 0.07298692), (10, 0.034142073), (15, 0.06530642), (17, 0.03036107)]"
38989,38993.0,2024-07-02 14:39:53,2,142,"<p>Let's consider that each qubit in the lab faces a single-qubit depolarizing channel <span class=""math-container"">$\mathcal{N}(\rho)=(1-p) \rho + p \mathbb{I}/2$</span>.</p>
<p>Is there a theoretical result indicating the largest value of <span class=""math-container"">$p$</span> such that quantum error-correction can completely suppress the effect of the noise asymptotically (by encoding the qubit in logical qubits composed of sufficiently many physical qubits).</p>
<p>In different terms: is the maximum theoretical threshold to fight depolarizing noise known?</p>
<p>I am assuming that the implementation of error-correction is noiseless here.</p>
",Highest theoretical threshold to fight single-qubit depolarizing noise for noiseless error-correction,<error-correction>,3,0,,,"Highest theoretical threshold to fight single-qubit depolarizing noise for noiseless error-correction <p>Let's consider that each qubit in the lab faces a single-qubit depolarizing channel <span class=""math-container"">$\mathcal{N}(\rho)=(1-p) \rho + p \mathbb{I}/2$</span>.</p>
<p>Is there a theoretical result indicating the largest value of <span class=""math-container"">$p$</span> such that quantum error-correction can completely suppress the effect of the noise asymptotically (by encoding the qubit in logical qubits composed of sufficiently many physical qubits).</p>
<p>In different terms: is the maximum theoretical threshold to fight depolarizing noise known?</p>
<p>I am assuming that the implementation of error-correction is noiseless here.</p>
",qc,highest theoretical threshold fight depolarizing noise noiseless p let consider qubit lab faces depolarizing channel span n p p theoretical result indicating largest value span p quantum completely suppress effect noise asymptotically encoding qubit logical qubits composed sufficiently many physical qubits p different terms maximum theoretical threshold fight depolarizing noise known p assuming implementation noiseless,"[(3, 0.27006236), (5, 0.23503588), (7, 0.0683974), (8, 0.21441785), (9, 0.12989408), (17, 0.07964693)]"
39001,,2024-07-03 01:22:12,1,97,"<p>I am trying to simulate the Steane code with circuit level noise using stim. I would like to use pymatching to correct errors. My circuit has detectors but does not include any logical observables to feed into this decoder. I saw that the Getting Started page had a section on adding a logical observable to the repetition code using: &quot;OBSERVABLE_INCLUDE(0) rec[-1]&quot; but I'm not sure how simply adding the last measurement to observable 0 tracks the parity of the left-most data qubit throughout all rounds of the sample. Could someone explain how this works? How can I adapt this to my Steane code circuit?</p>
",How does OBSERVABLE_INCLUDE work?,<stim>,1,0,,,"How does OBSERVABLE_INCLUDE work? <p>I am trying to simulate the Steane code with circuit level noise using stim. I would like to use pymatching to correct errors. My circuit has detectors but does not include any logical observables to feed into this decoder. I saw that the Getting Started page had a section on adding a logical observable to the repetition code using: &quot;OBSERVABLE_INCLUDE(0) rec[-1]&quot; but I'm not sure how simply adding the last measurement to observable 0 tracks the parity of the left-most data qubit throughout all rounds of the sample. Could someone explain how this works? How can I adapt this to my Steane code circuit?</p>
",qc,work p trying simulate steane code circuit level noise using stim would like use pymatching correct errors circuit detectors include logical observables feed decoder saw getting started page section adding logical observable repetition code using quot 0 rec quot sure simply adding last measurement observable 0 tracks parity data qubit throughout rounds sample could someone explain works adapt steane code circuit,"[(0, 0.02113633), (2, 0.031796727), (5, 0.34009856), (6, 0.023991501), (13, 0.08027352), (14, 0.43709), (17, 0.017667819), (19, 0.04595032)]"
39025,,2024-07-05 02:22:49,0,29,"<p>Is there any way to encode toric code with stim with desired error such as erasure error and z error? I have seen their documentation on surface code but that is already encoded. Is there any good resources that might help me?</p>
",Toric Code with stim?,<surface-code><topological-quantum-computing><toric-code>,0,0,,,"Toric Code with stim? <p>Is there any way to encode toric code with stim with desired error such as erasure error and z error? I have seen their documentation on surface code but that is already encoded. Is there any good resources that might help me?</p>
",qc,toric code stim p way encode toric code stim desired error erasure error z error seen documentation surface code already encoded good resources might help,"[(5, 0.54643476), (8, 0.3203404), (17, 0.1264779)]"
39066,,2024-07-09 08:53:09,0,66,"<p>In circuit QED, we construct the hamiltonian of a circuit following Devoret's procedure.</p>
<p>We start from a classical treatment, in which we impose Kirchhoff's voltage laws on fundamental loops and construct the lagrangian in such a way that it returns Kirchhoff's current laws on independent nodes as equations of motion. Once the lagrangian has been constructed, we can move on to the hamiltonian and then quantize the system.</p>
<p>Therefore, the first step is to build the classical theory, and then quantize it (as it is done for the LC circuit, for example).</p>
<p>However, is there a classical theory, if there is a Josephson junction in the circuit? Is it correct to start with a classical treatment, if there is a junction in the circuit, as if it were a classical circuit element, or is it a formal extension of the procedure?</p>
<p>Typically, we do this way even in this case. Now, does the classical lagrangian, that we obtain in such a case, describe a real classical system, at least in some regime, that we want to quantize? Shouldn't current and phase be operators? Is there a regime in which all Kirchhoff's laws hold classically, that justify the first step of the procedure even in this case?</p>
",Circuit quantization procedure,<circuit-qed>,1,1,,,"Circuit quantization procedure <p>In circuit QED, we construct the hamiltonian of a circuit following Devoret's procedure.</p>
<p>We start from a classical treatment, in which we impose Kirchhoff's voltage laws on fundamental loops and construct the lagrangian in such a way that it returns Kirchhoff's current laws on independent nodes as equations of motion. Once the lagrangian has been constructed, we can move on to the hamiltonian and then quantize the system.</p>
<p>Therefore, the first step is to build the classical theory, and then quantize it (as it is done for the LC circuit, for example).</p>
<p>However, is there a classical theory, if there is a Josephson junction in the circuit? Is it correct to start with a classical treatment, if there is a junction in the circuit, as if it were a classical circuit element, or is it a formal extension of the procedure?</p>
<p>Typically, we do this way even in this case. Now, does the classical lagrangian, that we obtain in such a case, describe a real classical system, at least in some regime, that we want to quantize? Shouldn't current and phase be operators? Is there a regime in which all Kirchhoff's laws hold classically, that justify the first step of the procedure even in this case?</p>
",qc,circuit quantization procedure p circuit qed construct hamiltonian circuit following devoret p start classical treatment impose kirchhoff voltage laws fundamental loops construct lagrangian way returns kirchhoff current laws independent nodes equations motion lagrangian constructed move hamiltonian quantize p therefore first step build classical theory quantize done lc circuit example p however classical theory josephson junction circuit correct start classical treatment junction circuit classical circuit element formal extension procedure p typically way even case classical lagrangian obtain case describe real classical system least regime want quantize current phase operators regime kirchhoff laws hold classically justify first step procedure even case,"[(1, 0.13170445), (3, 0.06817281), (4, 0.012886674), (8, 0.10752136), (9, 0.13256378), (13, 0.05703821), (14, 0.45057344), (17, 0.03831249)]"
39080,39081.0,2024-07-09 18:13:29,1,31,"<p>I don't know anymore how can I retrieve old jobs from qiskit via the jupyter notebook. When I try to use the commands</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService()
job = service.job(&quot;JOB_ID&quot;)
</code></pre>
<p>I get the error message</p>
<pre><code>RequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'
</code></pre>
<p>This is the first time I encounter this error. I used to access without problems from the notebook using my already saved credentials, but apparently many things have changed recently and now I cannot access anymore to the past jobs.</p>
<p>How can Ifix this?</p>
",Retrieve old jobs from IBM qcs after later qiskit changes,<qiskit><ibm-quantum-devices>,1,0,,,"Retrieve old jobs from IBM qcs after later qiskit changes <p>I don't know anymore how can I retrieve old jobs from qiskit via the jupyter notebook. When I try to use the commands</p>
<pre><code>from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService()
job = service.job(&quot;JOB_ID&quot;)
</code></pre>
<p>I get the error message</p>
<pre><code>RequestsApiError: '401 Client Error: Unauthorized for url: https://auth.quantum-computing.ibm.com/api/users/loginWithToken. Login failed., Error code: 3446.'
</code></pre>
<p>This is the first time I encounter this error. I used to access without problems from the notebook using my already saved credentials, but apparently many things have changed recently and now I cannot access anymore to the past jobs.</p>
<p>How can Ifix this?</p>
",qc,retrieve old jobs ibm qcs later qiskit changes p know anymore retrieve old jobs qiskit via jupyter notebook try use commands pre code import qiskitruntimeservice service qiskitruntimeservice job quot quot p get error message pre code requestsapierror client error unauthorized url https login error code 3446 p first time encounter error used access without problems notebook using already saved credentials apparently many things changed recently access anymore past p ifix,"[(0, 0.28226158), (9, 0.07684334), (14, 0.42911768), (17, 0.065832324), (19, 0.14377488)]"
39103,39115.0,2024-07-11 13:41:54,0,90,"<p>When I tried to use Stim and PyMatching to decode errors in a Rotated Planar code, I noticed that, <strong>Regardedless of the code distance</strong>, <code>predictions.shape</code>, as well as the shape of <code>observable_flips</code>, is always <code>(n_shots, 1)</code>,</p>
<p>So I refered to the docs, which says the second dimension parameter is num_fault_ids.</p>
<p>So what is exactly the <code>fault_id</code>? <code>matching.py</code> offers such explanations:</p>
<blockquote>
<pre><code>    fault_ids: set[int] or int, optional
        The indices of any self-inverse faults which are flipped when the edge is flipped, and which should be tracked.
        This could correspond to the IDs of physical Pauli errors that occur when this
        edge flips (physical frame changes). Alternatively,
        this attribute can be used to store the IDs of any logical observables that are
        flipped when an error occurs on an edge (logical frame changes). In earlier versions of PyMatching, this
        attribute was instead named `qubit_id` (since for CSS codes and physical frame changes, there can be
        a one-to-one correspondence between each fault ID and physical qubit ID). For backward
        compatibility, `qubit_id` can still be used instead of `fault_ids` as a keyword argument.
        By default None
</code></pre>
</blockquote>
<p>However these explanations brings me more questions. As I have learned, the decoder is fed  with syndrome information (from stabilizer measurement results), and yields the most probable error pattern (which physical qubit has suffered from X/Z errors.) But the PyMatching decoder just gives <strong>a</strong> 0/1, and compares it with observable_flips.</p>
<p><strong>So here is my question:</strong></p>
<ol>
<li>What is the meaning of <code>fault_id</code> in surface codes? And why <code>num_fault_ids</code> is always <code>1</code> in rotated codes? Is it an <em>observable flip</em> or something?</li>
<li>If it corresponds to an <em>observable flip</em>, then how does the PyMatching gets it? The decoding algorithm should only use the decoding graph to tell us <em>which qubits went wrong</em>, how does it predict <strong>whether there is a logical change</strong>? And why it can be used to evaluate the correctness of the decoder?</li>
</ol>
<p>Here is an example with a simple distance-3 rotated planar code and only one shot.</p>
<pre class=""lang-python prettyprint-override""><code>import stim
import pymatching
import numpy as np  

def decode_error(circuit:stim.Circuit):
    n_shots = 1
    # sample circuit.
    sampler = circuit.compile_detector_sampler()
    detection_events, observable_flips = sampler.sample(n_shots, separate_observables=True)
    
    # configure decoder
    detector_error_model = circuit.detector_error_model(decompose_errors=True)
    matcher = pymatching.Matching.from_detector_error_model(detector_error_model)
    print(detector_error_model)
    print(matcher.edges())

    # run decoder
    predictions = matcher.decode_batch(detection_events)

    print(detection_events)
    print(&quot;predictions shape:&quot;,predictions.shape)
    print(&quot;predictions=&quot;,predictions)
    print(observable_flips)

    for shot in range(n_shots):
        if np.array_equal(predictions[shot], observable_flips[shot]):
            print(&quot;decode correct&quot;)

        
if __name__=='__main__':
    d=3
    round=d*d;  
    noise=0.1
    
    circuit = stim.Circuit.generated(
        &quot;surface_code:rotated_memory_z&quot;,
        rounds=round,
        distance=d,
        before_round_data_depolarization=noise)

    decode_error(circuit)
</code></pre>
<p>and it gets such outputs:</p>
<pre><code>predictions shape: (1, 1)
predictions= [[0]]
</code></pre>
<p>For a single round code, the <code>matcher.edges()</code> is:</p>
<pre><code>[(0, None, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (0, 1, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (1, 2, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (1, None, {'fault_ids': {0}, 'weight': 1.9509992185627845, 'error_probability': 0.12444444444444444}), (2, None, {'fault_ids': set(), 'weight': 1.9509992185627845, 'error_probability': 0.12444444444444444}), (2, 3, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (3, None, {'fault_ids': {0}, 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667})]
</code></pre>
",`predictions` and `fault_ids` in Stim and PyMatching for surface code decoding,<error-correction><stim><pymatching>,1,0,,,"`predictions` and `fault_ids` in Stim and PyMatching for surface code decoding <p>When I tried to use Stim and PyMatching to decode errors in a Rotated Planar code, I noticed that, <strong>Regardedless of the code distance</strong>, <code>predictions.shape</code>, as well as the shape of <code>observable_flips</code>, is always <code>(n_shots, 1)</code>,</p>
<p>So I refered to the docs, which says the second dimension parameter is num_fault_ids.</p>
<p>So what is exactly the <code>fault_id</code>? <code>matching.py</code> offers such explanations:</p>
<blockquote>
<pre><code>    fault_ids: set[int] or int, optional
        The indices of any self-inverse faults which are flipped when the edge is flipped, and which should be tracked.
        This could correspond to the IDs of physical Pauli errors that occur when this
        edge flips (physical frame changes). Alternatively,
        this attribute can be used to store the IDs of any logical observables that are
        flipped when an error occurs on an edge (logical frame changes). In earlier versions of PyMatching, this
        attribute was instead named `qubit_id` (since for CSS codes and physical frame changes, there can be
        a one-to-one correspondence between each fault ID and physical qubit ID). For backward
        compatibility, `qubit_id` can still be used instead of `fault_ids` as a keyword argument.
        By default None
</code></pre>
</blockquote>
<p>However these explanations brings me more questions. As I have learned, the decoder is fed  with syndrome information (from stabilizer measurement results), and yields the most probable error pattern (which physical qubit has suffered from X/Z errors.) But the PyMatching decoder just gives <strong>a</strong> 0/1, and compares it with observable_flips.</p>
<p><strong>So here is my question:</strong></p>
<ol>
<li>What is the meaning of <code>fault_id</code> in surface codes? And why <code>num_fault_ids</code> is always <code>1</code> in rotated codes? Is it an <em>observable flip</em> or something?</li>
<li>If it corresponds to an <em>observable flip</em>, then how does the PyMatching gets it? The decoding algorithm should only use the decoding graph to tell us <em>which qubits went wrong</em>, how does it predict <strong>whether there is a logical change</strong>? And why it can be used to evaluate the correctness of the decoder?</li>
</ol>
<p>Here is an example with a simple distance-3 rotated planar code and only one shot.</p>
<pre class=""lang-python prettyprint-override""><code>import stim
import pymatching
import numpy as np  

def decode_error(circuit:stim.Circuit):
    n_shots = 1
    # sample circuit.
    sampler = circuit.compile_detector_sampler()
    detection_events, observable_flips = sampler.sample(n_shots, separate_observables=True)
    
    # configure decoder
    detector_error_model = circuit.detector_error_model(decompose_errors=True)
    matcher = pymatching.Matching.from_detector_error_model(detector_error_model)
    print(detector_error_model)
    print(matcher.edges())

    # run decoder
    predictions = matcher.decode_batch(detection_events)

    print(detection_events)
    print(&quot;predictions shape:&quot;,predictions.shape)
    print(&quot;predictions=&quot;,predictions)
    print(observable_flips)

    for shot in range(n_shots):
        if np.array_equal(predictions[shot], observable_flips[shot]):
            print(&quot;decode correct&quot;)

        
if __name__=='__main__':
    d=3
    round=d*d;  
    noise=0.1
    
    circuit = stim.Circuit.generated(
        &quot;surface_code:rotated_memory_z&quot;,
        rounds=round,
        distance=d,
        before_round_data_depolarization=noise)

    decode_error(circuit)
</code></pre>
<p>and it gets such outputs:</p>
<pre><code>predictions shape: (1, 1)
predictions= [[0]]
</code></pre>
<p>For a single round code, the <code>matcher.edges()</code> is:</p>
<pre><code>[(0, None, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (0, 1, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (1, 2, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (1, None, {'fault_ids': {0}, 'weight': 1.9509992185627845, 'error_probability': 0.12444444444444444}), (2, None, {'fault_ids': set(), 'weight': 1.9509992185627845, 'error_probability': 0.12444444444444444}), (2, 3, {'fault_ids': set(), 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667}), (3, None, {'fault_ids': {0}, 'weight': 2.6390573296152584, 'error_probability': 0.06666666666666667})]
</code></pre>
",qc,predictions stim pymatching surface code decoding p tried use stim pymatching decode errors rotated planar code noticed strong regardedless code distance code well shape code always code 1 p refered docs says second dimension parameter p exactly code code offers explanations blockquote pre code set int int optional indices faults flipped edge flipped tracked could correspond ids physical pauli errors occur edge flips physical frame changes alternatively attribute used store ids logical observables flipped error occurs edge logical frame changes earlier versions pymatching attribute instead named since css codes physical frame changes correspondence fault id physical qubit id backward compatibility still used instead keyword argument default none p however explanations brings questions learned decoder fed syndrome information stabilizer measurement results yields probable error pattern physical qubit suffered errors pymatching decoder gives strong compares p strong question ol li meaning code surface codes code always code 1 rotated codes em observable flip something li corresponds em observable flip pymatching gets decoding algorithm use decoding graph tell us em qubits went wrong predict strong whether logical change used evaluate correctness decoder p example simple rotated planar code one pre code import stim import pymatching import numpy np def circuit 1 sample circuit sampler configure decoder matcher print print run decoder predictions print print quot predictions shape quot print quot quot predictions print shot range predictions shot shot print quot decode correct quot circuit quot quot circuit p gets outputs pre code predictions shape 1 1 0 p single round code code pre code 0 none set 0 1 set 1 2 set 1 none 0 2 none set 2 3 set 3 none 0,"[(0, 0.1708021), (2, 0.06173052), (5, 0.27538723), (9, 0.054152966), (13, 0.048292417), (14, 0.24586537), (17, 0.04064696), (19, 0.10267627)]"
39105,,2024-07-11 14:55:37,1,92,"<p>When using Shor's algorithm to try to factor 33 I expect the period found to be 10,  however when I run it using qiskit and qasm simulator I keep getting 5 and 10 appearing as the most common periods and cannot figure out why 5 is showing up (beside maybe weird rounding when converting phase, not sure but this is my best guess). Most of the actual Shor section I got from a qiskit walkthrough of Shor's but it was for factoring 15.</p>
<p>Here is the code:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np
from qiskit import QuantumCircuit, Aer, transpile
from qiskit.visualization import plot_histogram
from math import gcd
from numpy.random import randint
import pandas as pd
from fractions import Fraction
print(&quot;Imports Successful&quot;)
</code></pre>
<pre><code>def c_amod33(a, power):
    &quot;&quot;&quot;Controlled multiplication by a mod 33&quot;&quot;&quot;
    # List of valid 'a' values for mod 33 
    valid_a_values = [5, 7, 8, 10, 13, 14, 16, 17, 19, 20, 23, 25, 26, 28, 29, 31, 32]
    if a not in valid_a_values:
        raise ValueError(f&quot;'a' must be one of {valid_a_values}&quot;)
</code></pre>
<pre><code>    U = QuantumCircuit(6)  # Assume 6 qubits for values up to 33
    
    for _ in range(power):
        if a == 5:
            #U.swap(3, 4)
            #U.swap(2, 3)
            #U.swap(1, 2)
            #U.swap(0, 1)
            U.swap(0, 1)
            U.swap(1, 2)
            U.swap(2, 3)
            U.swap(3, 4)
        if a in [5]:
            for q in range(6):
                U.x(q)
 
    U = U.to_gate()
    U.name = f&quot;{a}^{power} mod 33&quot;
    c_U = U.control()
    return c_U
</code></pre>
<pre><code>n_count = 12
a = 5
</code></pre>
<pre><code>def qft_dagger(n):
    &quot;&quot;&quot;n-qubit QFTdagger the first n qubits in circ&quot;&quot;&quot;
    qc = QuantumCircuit(n)
    # Don't forget the Swaps!
    for qubit in range(n//2):
        qc.swap(qubit, n-qubit-1)
    for j in range(n):
        for m in range(j):
            qc.cp(-np.pi/float(2**(j-m)), m, j)
        qc.h(j)
    qc.name = &quot;QFT†&quot;
    return qc
</code></pre>
<pre><code># Create QuantumCircuit with n_count counting qubits
# plus 6 qubits for U to act on

qc = QuantumCircuit(n_count + 6, n_count+6)

# Initialize counting qubits
# in state |+&gt;
for q in range(n_count):
    qc.h(q)

# And auxiliary register in state |1&gt;
qc.x(n_count)

# Step dividing line
qc.barrier()

# Do controlled-U operations
for q in range(n_count):
    qc.append(c_amod33(a, 2**q),
             [q] + [i+n_count for i in range(6)])
    
# Step dividing line
qc.barrier()

# Measure storage register
for i in range(12, 18):
    qc.measure(i, i)
    
# Step dividing line
qc.barrier()

# Do inverse-QFT
qc.append(qft_dagger(n_count), range(n_count))

# Step dividing line
qc.barrier()

# Measure circuit
qc.measure(range(n_count), range(n_count))
qc.draw(output=&quot;mpl&quot;, fold=-1)  # -1 means 'do not fold'
</code></pre>
<pre><code>aer_sim = Aer.get_backend('qasm_simulator')
t_qc = transpile(qc, aer_sim)
counts = aer_sim.run(t_qc).result().get_counts()
plot_histogram(counts)
</code></pre>
<pre><code>rows, measured_phases = [], []
for output in counts:
    output_trimmed = output[6:]
    decimal = int(output_trimmed, 2)  # Convert (base 2) string to decimal
    phase = decimal/(2**n_count)  # Find corresponding eigenvalue
    measured_phases.append(phase)
    # Add these values to the rows in our table:
    rows.append([f&quot;{output_trimmed}(bin) = {decimal:&gt;3}(dec)&quot;,
                 f&quot;{decimal}/{2**n_count} = {phase:.2f}&quot;])
# Print the rows in a table
headers=[&quot;Register Output&quot;, &quot;Phase&quot;]
df = pd.DataFrame(rows, columns=headers)
print(df)
</code></pre>
<pre><code>def continued_fraction(x, max_terms):
    &quot;&quot;&quot;Generate the continued fraction representation of x up to the given max_terms.&quot;&quot;&quot;
    cf = []
    for _ in range(max_terms):
        n = int(x)
        cf.append(n)
        x -= n
        #if x == 0:
        if abs(x) &lt; 1e-10:
            break
        x = 1 / x
    return cf
</code></pre>
<pre><code>def fraction_from_continued_fraction(cf):
    &quot;&quot;&quot;Convert a continued fraction list to a Fraction.&quot;&quot;&quot;
    if not cf:
        return Fraction(0)
    frac = Fraction(cf[-1])
    for a in reversed(cf[:-1]):
        frac = a + 1 / frac
    return frac
</code></pre>
<pre><code>rows = []
for phase in measured_phases:
    # Get the continued fraction representation
    cf = continued_fraction(phase, 33)
    # Convert continued fraction to a fraction
    frac = fraction_from_continued_fraction(cf)
    # Limit denominator 
    frac = frac.limit_denominator(33)
    
    rows.append([phase,
                 f&quot;{frac.numerator}/{frac.denominator}&quot;,
                 frac.denominator])
</code></pre>
<pre><code># Print as a table
headers = [&quot;Phase&quot;, &quot;Fraction&quot;, &quot;Guess for r&quot;]
df = pd.DataFrame(rows, columns=headers)
print(df)
</code></pre>
<pre><code># Calculate the frequency of each value in the &quot;Guess for r&quot; column
frequency_df = df['Guess for r'].value_counts().reset_index()
frequency_df.columns = ['Guess for r', 'Frequency']


# Print the frequency DataFrame
print(&quot;\nFrequency of 'Guess for r' values:&quot;)
print(frequency_df)
</code></pre>
<p>Thanks in advanced!</p>
",Why when using Shor's Algorithm to factor 33 am I getting 5 as a period half of the time?,<shors-algorithm><factorization>,1,0,,,"Why when using Shor's Algorithm to factor 33 am I getting 5 as a period half of the time? <p>When using Shor's algorithm to try to factor 33 I expect the period found to be 10,  however when I run it using qiskit and qasm simulator I keep getting 5 and 10 appearing as the most common periods and cannot figure out why 5 is showing up (beside maybe weird rounding when converting phase, not sure but this is my best guess). Most of the actual Shor section I got from a qiskit walkthrough of Shor's but it was for factoring 15.</p>
<p>Here is the code:</p>
<pre><code>import matplotlib.pyplot as plt
import numpy as np
from qiskit import QuantumCircuit, Aer, transpile
from qiskit.visualization import plot_histogram
from math import gcd
from numpy.random import randint
import pandas as pd
from fractions import Fraction
print(&quot;Imports Successful&quot;)
</code></pre>
<pre><code>def c_amod33(a, power):
    &quot;&quot;&quot;Controlled multiplication by a mod 33&quot;&quot;&quot;
    # List of valid 'a' values for mod 33 
    valid_a_values = [5, 7, 8, 10, 13, 14, 16, 17, 19, 20, 23, 25, 26, 28, 29, 31, 32]
    if a not in valid_a_values:
        raise ValueError(f&quot;'a' must be one of {valid_a_values}&quot;)
</code></pre>
<pre><code>    U = QuantumCircuit(6)  # Assume 6 qubits for values up to 33
    
    for _ in range(power):
        if a == 5:
            #U.swap(3, 4)
            #U.swap(2, 3)
            #U.swap(1, 2)
            #U.swap(0, 1)
            U.swap(0, 1)
            U.swap(1, 2)
            U.swap(2, 3)
            U.swap(3, 4)
        if a in [5]:
            for q in range(6):
                U.x(q)
 
    U = U.to_gate()
    U.name = f&quot;{a}^{power} mod 33&quot;
    c_U = U.control()
    return c_U
</code></pre>
<pre><code>n_count = 12
a = 5
</code></pre>
<pre><code>def qft_dagger(n):
    &quot;&quot;&quot;n-qubit QFTdagger the first n qubits in circ&quot;&quot;&quot;
    qc = QuantumCircuit(n)
    # Don't forget the Swaps!
    for qubit in range(n//2):
        qc.swap(qubit, n-qubit-1)
    for j in range(n):
        for m in range(j):
            qc.cp(-np.pi/float(2**(j-m)), m, j)
        qc.h(j)
    qc.name = &quot;QFT†&quot;
    return qc
</code></pre>
<pre><code># Create QuantumCircuit with n_count counting qubits
# plus 6 qubits for U to act on

qc = QuantumCircuit(n_count + 6, n_count+6)

# Initialize counting qubits
# in state |+&gt;
for q in range(n_count):
    qc.h(q)

# And auxiliary register in state |1&gt;
qc.x(n_count)

# Step dividing line
qc.barrier()

# Do controlled-U operations
for q in range(n_count):
    qc.append(c_amod33(a, 2**q),
             [q] + [i+n_count for i in range(6)])
    
# Step dividing line
qc.barrier()

# Measure storage register
for i in range(12, 18):
    qc.measure(i, i)
    
# Step dividing line
qc.barrier()

# Do inverse-QFT
qc.append(qft_dagger(n_count), range(n_count))

# Step dividing line
qc.barrier()

# Measure circuit
qc.measure(range(n_count), range(n_count))
qc.draw(output=&quot;mpl&quot;, fold=-1)  # -1 means 'do not fold'
</code></pre>
<pre><code>aer_sim = Aer.get_backend('qasm_simulator')
t_qc = transpile(qc, aer_sim)
counts = aer_sim.run(t_qc).result().get_counts()
plot_histogram(counts)
</code></pre>
<pre><code>rows, measured_phases = [], []
for output in counts:
    output_trimmed = output[6:]
    decimal = int(output_trimmed, 2)  # Convert (base 2) string to decimal
    phase = decimal/(2**n_count)  # Find corresponding eigenvalue
    measured_phases.append(phase)
    # Add these values to the rows in our table:
    rows.append([f&quot;{output_trimmed}(bin) = {decimal:&gt;3}(dec)&quot;,
                 f&quot;{decimal}/{2**n_count} = {phase:.2f}&quot;])
# Print the rows in a table
headers=[&quot;Register Output&quot;, &quot;Phase&quot;]
df = pd.DataFrame(rows, columns=headers)
print(df)
</code></pre>
<pre><code>def continued_fraction(x, max_terms):
    &quot;&quot;&quot;Generate the continued fraction representation of x up to the given max_terms.&quot;&quot;&quot;
    cf = []
    for _ in range(max_terms):
        n = int(x)
        cf.append(n)
        x -= n
        #if x == 0:
        if abs(x) &lt; 1e-10:
            break
        x = 1 / x
    return cf
</code></pre>
<pre><code>def fraction_from_continued_fraction(cf):
    &quot;&quot;&quot;Convert a continued fraction list to a Fraction.&quot;&quot;&quot;
    if not cf:
        return Fraction(0)
    frac = Fraction(cf[-1])
    for a in reversed(cf[:-1]):
        frac = a + 1 / frac
    return frac
</code></pre>
<pre><code>rows = []
for phase in measured_phases:
    # Get the continued fraction representation
    cf = continued_fraction(phase, 33)
    # Convert continued fraction to a fraction
    frac = fraction_from_continued_fraction(cf)
    # Limit denominator 
    frac = frac.limit_denominator(33)
    
    rows.append([phase,
                 f&quot;{frac.numerator}/{frac.denominator}&quot;,
                 frac.denominator])
</code></pre>
<pre><code># Print as a table
headers = [&quot;Phase&quot;, &quot;Fraction&quot;, &quot;Guess for r&quot;]
df = pd.DataFrame(rows, columns=headers)
print(df)
</code></pre>
<pre><code># Calculate the frequency of each value in the &quot;Guess for r&quot; column
frequency_df = df['Guess for r'].value_counts().reset_index()
frequency_df.columns = ['Guess for r', 'Frequency']


# Print the frequency DataFrame
print(&quot;\nFrequency of 'Guess for r' values:&quot;)
print(frequency_df)
</code></pre>
<p>Thanks in advanced!</p>
",qc,using shor algorithm factor 33 getting 5 period half time p using shor algorithm try factor 33 expect period found 10 however run using qiskit qasm simulator keep getting 5 10 appearing common periods figure 5 showing beside maybe weird rounding converting phase sure best guess actual shor section got qiskit walkthrough shor factoring p code pre code import plt import numpy np qiskit import quantumcircuit aer transpile import math import gcd import randint import pandas pd fractions import fraction print quot imports successful quot pre code def power quot quot quot controlled multiplication mod 33 quot quot quot list valid values mod 33 5 7 8 10 13 14 16 17 19 20 23 25 26 28 29 31 32 raise valueerror f quot must one quot pre code u quantumcircuit 6 assume 6 qubits values 33 range power 5 3 4 2 3 1 2 0 1 0 1 1 2 2 3 3 4 5 q range 6 q u f quot power mod 33 quot return pre code 12 5 pre code def n quot quot quot qftdagger first n qubits circ quot quot quot qc quantumcircuit n forget swaps qubit range qubit j range n range j 2 j j quot quot return qc pre code create quantumcircuit counting qubits plus 6 qubits u act qc quantumcircuit 6 initialize counting qubits state gt q range q auxiliary register state gt step dividing line operations q range 2 q q range 6 step dividing line measure storage register range 12 18 step dividing line range step dividing line measure circuit range range quot mpl quot means fold pre code transpile qc counts counts pre code rows output counts output 6 decimal int 2 convert base 2 string decimal phase 2 find corresponding eigenvalue phase add values rows table f quot bin decimal gt 3 dec quot f quot decimal 2 phase quot print rows table quot register output quot quot phase quot df rows print df pre code def x quot quot quot generate continued fraction representation x given quot quot quot cf range n int x n x n x 0 abs x lt break x 1 x return cf pre code def cf quot quot quot convert continued fraction list quot quot quot cf return fraction 0 frac fraction cf reversed cf frac 1 frac return frac pre code rows phase get continued fraction representation cf phase 33 convert continued fraction fraction frac cf limit denominator frac 33 phase f quot quot pre code print table headers quot phase quot quot fraction quot quot guess r quot df rows print df pre code calculate frequency value quot guess r quot column df r r print frequency dataframe print quot r values quot print p thanks advanced,"[(0, 0.3553787), (2, 0.06238666), (3, 0.010415666), (6, 0.08959844), (7, 0.06051686), (8, 0.055687074), (10, 0.04498095), (17, 0.013241597), (18, 0.037204567), (19, 0.27037215)]"
39123,,2024-07-12 10:32:23,1,57,"<h1>What's the idea?</h1>
<p>I'm trying to embed the prime factorization problem into the form of a PUBO. To do so, let <span class=""math-container"">$p$</span> and <span class=""math-container"">$q$</span> be two real positive numbers. We can represent these two numbers as binary numbers, which itself can be represented as vectors, <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span>, where <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span> both have <span class=""math-container"">$k$</span> elements. I define a new vector <span class=""math-container"">$\pmb{x}$</span> by concatenating <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span> as follows:</p>
<p><span class=""math-container"">$$p_i \in \{ 0,1\}$$</span>
<span class=""math-container"">$$q_i \in \{ 0,1\}$$</span></p>
<p><span class=""math-container"">$$ \pmb{x} = (p_1, \ldots, p_k, q_1, \ldots, q_{k})^T$$</span></p>
<p>Now I define the following matrix <span class=""math-container"">$Q$</span>:</p>
<p><span class=""math-container"">$$Q = \sigma_x \otimes \alpha$$</span></p>
<p>where <span class=""math-container"">$\alpha$</span> is a <span class=""math-container"">$k \times k$</span> matrix that its elements are defined like this:</p>
<p><span class=""math-container"">$$\alpha_{ij} = 2^{2k - (i+j)}$$</span>
and
<span class=""math-container"">$$
\sigma_x = 
\begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{pmatrix}
$$</span></p>
<p>This formulation, allows us to make <span class=""math-container"">$Q$</span> in a way that the product of numbers <span class=""math-container"">$p$</span> and <span class=""math-container"">$q$</span> is equal to the expression <span class=""math-container"">$\frac{1}{2}\pmb{x}^T Q \pmb{x}$</span>:</p>
<p><span class=""math-container"">$$\frac{1}{2}\pmb{x}^T Q \pmb{x} = pq$$</span></p>
<p>Now, I can also do this for <span class=""math-container"">$(pq)^2$</span>:</p>
<p><span class=""math-container"">$$\frac{1}{4}\pmb{x}^T Q \pmb{x}\pmb{x}^T Q \pmb{x} = (pq)^2$$</span></p>
<p>Now coming back to our original problem, we want to find the <span class=""math-container"">$p$</span> and <span class=""math-container"">$q$</span> so that:</p>
<p><span class=""math-container"">$$pq = N$$</span></p>
<p>To do so, we can convert it into this optimization problem:</p>
<p><span class=""math-container"">$$\min_{p,q} f(p,q) = \min_{p,q} (N-pq)^2$$</span></p>
<p>and using the PUBO form, we can convert <span class=""math-container"">$f$</span> to:</p>
<p><span class=""math-container"">$$f(p,q) = N^2+ (pq)^2 - 2 N pq$$</span>
<span class=""math-container"">$$f(p,q) = N^2+ \frac{1}{4}\pmb{x}^T Q \pmb{x}\pmb{x}^T Q \pmb{x} - N \pmb{x}^T Q \pmb{x}$$</span></p>
<p>Of course, this approach assumes that <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span> have the same length of bits. To generalize this, we can simply move the separation point of vector <span class=""math-container"">$\pmb{x}$</span> from middle, one step at the time to get different lengths. This converts the complexity of the problem into:</p>
<p><span class=""math-container"">$$O(N \log(N))$$</span></p>
<p>To solve this PUBO, I've tried simulated annealing and it works:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm


def beta(N):
    pauli_x = np.array([[0, 1], [1, 0]])

    def matrix_values(i, j):
        return 2**(2*N - (i+1)- (j+1))
    matrix = np.fromfunction(matrix_values, (N, N))

    # tensor product of pauli_x and matrix
    matrix = np.kron(pauli_x, matrix)
    
    return matrix

def preprocess(p, q):
    binary_p = bin(p)[2:]
    binary_q = bin(q)[2:]

    # do a padding to make the length of binary_p and binary_q equal
    if len(binary_p) &lt; len(binary_q):
        binary_p = '0'*(len(binary_q) - len(binary_p)) + binary_p
    elif len(binary_q) &lt; len(binary_p):
        binary_q = '0'*(len(binary_p) - len(binary_q)) + binary_q

    x = np.array(list(binary_p+binary_q), dtype=int)

    return x


def simulated_annealing(B, pq, n_iterations=1000, T_start=100, T_end=0.1):
    # Initialize
    x = np.random.choice([0, 1], size=len(B))
    x[-1] = 1  # q must be odd
    x[len(x)//2] = 1  # p must be odd

    T = T_start
    energies = []
    best_x = x.copy()
    best_H = float('inf')

    # Initial energy calculation
    xBx = x @ B @ x
    H = pq**2 + xBx**2 // 4 - pq * xBx

    # Create tqdm progress bar
    pbar = tqdm(range(n_iterations))
    
    for i in pbar:
        # Generate new state
        j = np.random.randint(0, len(x))
        x_new = x.copy()
        x_new[j] = 1 - x_new[j]  # Flip the bit
        
        # Calculate energy difference efficiently
        delta_xBx = 0
        for k in range(len(x)):
            delta_xBx += B[j, k] * (x_new[j] - x[j]) * (x[k] + x_new[k])
        

        xBx_new = xBx + delta_xBx
        H_new = pq**2 + xBx_new**2 // 4 - pq * xBx_new
        
        # Calculate energy difference efficiently using vector operations
        delta_x = x_new - x
        delta_xBx = 2 * (delta_x @ B @ x) + (delta_x @ B @ delta_x)
        
        xBx_new = xBx + delta_xBx
        H_new = pq**2 + xBx_new**2 // 4 - pq * xBx_new

        # Calculate energy difference
        delta_H = (H_new - H) / pq**2
        
        # Decide whether to accept the new state
        if delta_H &lt; 0 or np.random.random() &lt; np.exp(-delta_H / T):
            x = x_new
            H = H_new
            xBx = xBx_new
        
        # Cool down
        T = T_start * (T_end / T_start) ** (i / (n_iterations - 1))
        energies.append(H)

        # Update best state
        if H &lt; best_H:
            best_x = x.copy()
            best_H = H
        if best_H == 0:
            break
        # Update tqdm description with current best_H
        pbar.set_description(f&quot;Best H: {best_H:.4e}&quot;)

    energies = np.array(energies)

    return best_x, best_H, energies

p , q = 241, 251
pq = p*q
L = (np.floor(np.log2(float(pq))).astype(int)) //2 + 1

B = beta(L)

x, H, energies = simulated_annealing(B, pq, n_iterations=10_000, T_start=1e-1, T_end=1e-5)


# get back the values of p and q
p_o = int(''.join(map(str, x[:L])), 2)
q_o = int(''.join(map(str, x[L:])), 2)
print(H)
print(p_o, q_o)

plt.plot(energies, color='b', linestyle='-', label='Energy')
plt.yscale('symlog')
plt.xscale('symlog')
plt.xlabel('Iteration')
plt.ylabel('Energy')
plt.hlines(0,xmin=0, xmax=1.4*len(energies), color='black', linestyle='--', label='Optimal Solution')
plt.xlim(0, 1.4*len(energies))
plt.legend(loc = 'center left')
plt.show()
</code></pre>
<p><a href=""https://i.sstatic.net/vTulNtco.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/vTulNtco.png"" alt=""enter image description here"" /></a></p>
<p>Note that my code assumes the same length of bits for both numbers, but as mentioned before, it can be generalized pretty easily. This code successfully factors the number 60491 to 241 and 251.</p>
<h1>What's the catch?</h1>
<p>The catch is that the simulated annealing is not a good way of optimization for large <span class=""math-container"">$N$</span>. There are far better Ising machines for these types of tasks, but the problem is the fact that they are designed to work with QUBOs, not PUBOs. But now, I tell my suggestion:</p>
<p><em><strong>We should be able to solve this using a modified version of the Simulated Bifurcation algorithm.</strong></em></p>
<p>It is highly parallelizable, and it reaches to the solution in orders of magnitude less time. I also think there are tons of other optimizations in the embedding itself. Plus, I believe we should be able to combine this approach with classical algorithms such as Sieve of Eratosthenes. Please tell what you think about my approach. Any comment would be greatly appreciated.</p>
",A highly space-efficient embedding of prime factorization problem using the Ising model,<simulation><qubo><ising-model><factorization><embedding>,1,5,,,"A highly space-efficient embedding of prime factorization problem using the Ising model <h1>What's the idea?</h1>
<p>I'm trying to embed the prime factorization problem into the form of a PUBO. To do so, let <span class=""math-container"">$p$</span> and <span class=""math-container"">$q$</span> be two real positive numbers. We can represent these two numbers as binary numbers, which itself can be represented as vectors, <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span>, where <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span> both have <span class=""math-container"">$k$</span> elements. I define a new vector <span class=""math-container"">$\pmb{x}$</span> by concatenating <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span> as follows:</p>
<p><span class=""math-container"">$$p_i \in \{ 0,1\}$$</span>
<span class=""math-container"">$$q_i \in \{ 0,1\}$$</span></p>
<p><span class=""math-container"">$$ \pmb{x} = (p_1, \ldots, p_k, q_1, \ldots, q_{k})^T$$</span></p>
<p>Now I define the following matrix <span class=""math-container"">$Q$</span>:</p>
<p><span class=""math-container"">$$Q = \sigma_x \otimes \alpha$$</span></p>
<p>where <span class=""math-container"">$\alpha$</span> is a <span class=""math-container"">$k \times k$</span> matrix that its elements are defined like this:</p>
<p><span class=""math-container"">$$\alpha_{ij} = 2^{2k - (i+j)}$$</span>
and
<span class=""math-container"">$$
\sigma_x = 
\begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{pmatrix}
$$</span></p>
<p>This formulation, allows us to make <span class=""math-container"">$Q$</span> in a way that the product of numbers <span class=""math-container"">$p$</span> and <span class=""math-container"">$q$</span> is equal to the expression <span class=""math-container"">$\frac{1}{2}\pmb{x}^T Q \pmb{x}$</span>:</p>
<p><span class=""math-container"">$$\frac{1}{2}\pmb{x}^T Q \pmb{x} = pq$$</span></p>
<p>Now, I can also do this for <span class=""math-container"">$(pq)^2$</span>:</p>
<p><span class=""math-container"">$$\frac{1}{4}\pmb{x}^T Q \pmb{x}\pmb{x}^T Q \pmb{x} = (pq)^2$$</span></p>
<p>Now coming back to our original problem, we want to find the <span class=""math-container"">$p$</span> and <span class=""math-container"">$q$</span> so that:</p>
<p><span class=""math-container"">$$pq = N$$</span></p>
<p>To do so, we can convert it into this optimization problem:</p>
<p><span class=""math-container"">$$\min_{p,q} f(p,q) = \min_{p,q} (N-pq)^2$$</span></p>
<p>and using the PUBO form, we can convert <span class=""math-container"">$f$</span> to:</p>
<p><span class=""math-container"">$$f(p,q) = N^2+ (pq)^2 - 2 N pq$$</span>
<span class=""math-container"">$$f(p,q) = N^2+ \frac{1}{4}\pmb{x}^T Q \pmb{x}\pmb{x}^T Q \pmb{x} - N \pmb{x}^T Q \pmb{x}$$</span></p>
<p>Of course, this approach assumes that <span class=""math-container"">$\pmb{p}$</span> and <span class=""math-container"">$\pmb{q}$</span> have the same length of bits. To generalize this, we can simply move the separation point of vector <span class=""math-container"">$\pmb{x}$</span> from middle, one step at the time to get different lengths. This converts the complexity of the problem into:</p>
<p><span class=""math-container"">$$O(N \log(N))$$</span></p>
<p>To solve this PUBO, I've tried simulated annealing and it works:</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm


def beta(N):
    pauli_x = np.array([[0, 1], [1, 0]])

    def matrix_values(i, j):
        return 2**(2*N - (i+1)- (j+1))
    matrix = np.fromfunction(matrix_values, (N, N))

    # tensor product of pauli_x and matrix
    matrix = np.kron(pauli_x, matrix)
    
    return matrix

def preprocess(p, q):
    binary_p = bin(p)[2:]
    binary_q = bin(q)[2:]

    # do a padding to make the length of binary_p and binary_q equal
    if len(binary_p) &lt; len(binary_q):
        binary_p = '0'*(len(binary_q) - len(binary_p)) + binary_p
    elif len(binary_q) &lt; len(binary_p):
        binary_q = '0'*(len(binary_p) - len(binary_q)) + binary_q

    x = np.array(list(binary_p+binary_q), dtype=int)

    return x


def simulated_annealing(B, pq, n_iterations=1000, T_start=100, T_end=0.1):
    # Initialize
    x = np.random.choice([0, 1], size=len(B))
    x[-1] = 1  # q must be odd
    x[len(x)//2] = 1  # p must be odd

    T = T_start
    energies = []
    best_x = x.copy()
    best_H = float('inf')

    # Initial energy calculation
    xBx = x @ B @ x
    H = pq**2 + xBx**2 // 4 - pq * xBx

    # Create tqdm progress bar
    pbar = tqdm(range(n_iterations))
    
    for i in pbar:
        # Generate new state
        j = np.random.randint(0, len(x))
        x_new = x.copy()
        x_new[j] = 1 - x_new[j]  # Flip the bit
        
        # Calculate energy difference efficiently
        delta_xBx = 0
        for k in range(len(x)):
            delta_xBx += B[j, k] * (x_new[j] - x[j]) * (x[k] + x_new[k])
        

        xBx_new = xBx + delta_xBx
        H_new = pq**2 + xBx_new**2 // 4 - pq * xBx_new
        
        # Calculate energy difference efficiently using vector operations
        delta_x = x_new - x
        delta_xBx = 2 * (delta_x @ B @ x) + (delta_x @ B @ delta_x)
        
        xBx_new = xBx + delta_xBx
        H_new = pq**2 + xBx_new**2 // 4 - pq * xBx_new

        # Calculate energy difference
        delta_H = (H_new - H) / pq**2
        
        # Decide whether to accept the new state
        if delta_H &lt; 0 or np.random.random() &lt; np.exp(-delta_H / T):
            x = x_new
            H = H_new
            xBx = xBx_new
        
        # Cool down
        T = T_start * (T_end / T_start) ** (i / (n_iterations - 1))
        energies.append(H)

        # Update best state
        if H &lt; best_H:
            best_x = x.copy()
            best_H = H
        if best_H == 0:
            break
        # Update tqdm description with current best_H
        pbar.set_description(f&quot;Best H: {best_H:.4e}&quot;)

    energies = np.array(energies)

    return best_x, best_H, energies

p , q = 241, 251
pq = p*q
L = (np.floor(np.log2(float(pq))).astype(int)) //2 + 1

B = beta(L)

x, H, energies = simulated_annealing(B, pq, n_iterations=10_000, T_start=1e-1, T_end=1e-5)


# get back the values of p and q
p_o = int(''.join(map(str, x[:L])), 2)
q_o = int(''.join(map(str, x[L:])), 2)
print(H)
print(p_o, q_o)

plt.plot(energies, color='b', linestyle='-', label='Energy')
plt.yscale('symlog')
plt.xscale('symlog')
plt.xlabel('Iteration')
plt.ylabel('Energy')
plt.hlines(0,xmin=0, xmax=1.4*len(energies), color='black', linestyle='--', label='Optimal Solution')
plt.xlim(0, 1.4*len(energies))
plt.legend(loc = 'center left')
plt.show()
</code></pre>
<p><a href=""https://i.sstatic.net/vTulNtco.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/vTulNtco.png"" alt=""enter image description here"" /></a></p>
<p>Note that my code assumes the same length of bits for both numbers, but as mentioned before, it can be generalized pretty easily. This code successfully factors the number 60491 to 241 and 251.</p>
<h1>What's the catch?</h1>
<p>The catch is that the simulated annealing is not a good way of optimization for large <span class=""math-container"">$N$</span>. There are far better Ising machines for these types of tasks, but the problem is the fact that they are designed to work with QUBOs, not PUBOs. But now, I tell my suggestion:</p>
<p><em><strong>We should be able to solve this using a modified version of the Simulated Bifurcation algorithm.</strong></em></p>
<p>It is highly parallelizable, and it reaches to the solution in orders of magnitude less time. I also think there are tons of other optimizations in the embedding itself. Plus, I believe we should be able to combine this approach with classical algorithms such as Sieve of Eratosthenes. Please tell what you think about my approach. Any comment would be greatly appreciated.</p>
",qc,highly embedding prime factorization problem using ising model h1 idea p trying embed prime factorization problem form pubo let span p span q two real positive numbers represent two numbers binary numbers represented vectors span p span q span p span q span k elements define new vector span x concatenating span p span q follows p span span p span x k p define following matrix span q p span q p span span k k matrix elements defined like p span ij 2k span pmatrix 0 amp 1 1 amp 0 pmatrix p formulation allows us make span q way product numbers span p span q equal expression span 1 2 x q x p span 1 2 x q x pq p also span pq p span 1 4 x q x x q x pq p coming back original problem want find span p span q p span pq n p convert optimization problem p span p q f p q p q p using pubo form convert span f p span f p q pq 2 n pq span f p q 1 4 x q x x q x n x q x p course approach assumes span p span q length bits generalize simply move separation point vector span x middle one step time get different lengths converts complexity problem p span n n p solve pubo tried simulated annealing works pre code import numpy np import plt tqdm import tqdm def beta n 0 1 1 0 def j return 2 2 n matrix n n tensor product matrix matrix matrix return matrix def preprocess p q bin p 2 bin q 2 padding make length equal len lt len 0 len len elif len lt len 0 len len x list return x def b pq initialize x 0 1 b x 1 q must odd x len x 1 p must odd energies float initial energy calculation xbx x b x h pq 2 xbx 2 4 pq xbx create tqdm progress bar pbar tqdm range pbar generate new state j 0 len x j 1 j flip bit calculate energy difference efficiently 0 k range len x b j k j x j x k k xbx pq 2 2 4 pq calculate energy difference efficiently using vector operations x 2 b x b xbx pq 2 2 4 pq calculate energy difference h pq 2 decide whether accept new state lt 0 lt x h xbx cool 1 h update best state h lt h 0 break update tqdm description current f quot best h quot energies energies return energies p q 241 251 pq p q l float pq int 1 b beta l x h energies b pq get back values p q int map str x l 2 int map str x l 2 print h print energies b 0 len energies solution 0 len energies loc left p https nofollow noreferrer img https enter image description p note code assumes length bits numbers mentioned generalized pretty easily code successfully factors number 60491 241 h1 catch p catch simulated annealing good way optimization large span n far better ising machines types tasks problem fact designed work qubos pubos tell suggestion p em strong able solve using modified version simulated bifurcation p highly parallelizable reaches solution orders magnitude less time also think tons optimizations embedding plus believe able combine approach classical algorithms sieve eratosthenes please tell think approach comment would greatly,"[(0, 0.16953285), (1, 0.06662538), (2, 0.09068073), (3, 0.19255091), (4, 0.023888132), (8, 0.057143033), (10, 0.28870592), (11, 0.014330431), (13, 0.06735697), (15, 0.011456119), (17, 0.01002451)]"
39130,,2024-07-12 18:31:45,4,105,"<p>I am reading (and quoting) <a href=""https://www.cs.umd.edu/%7Eamchilds/qa/qa.pdf"" rel=""nofollow noreferrer"">Andrew Child's notes</a>, and I'm trying to understand the HSP for abelian groups, and in particular why the quantum algorithm doesn't shed any light on a potential classical algorithm.</p>
<p>The quantum algorithm prepares the superposition <span class=""math-container"">$\frac{1}{\sqrt{|G|}}\sum_{x \in G}|x\rangle$</span>, then computes the function in the second register <span class=""math-container"">$\frac{1}{\sqrt{|G|}}\sum_{x \in G}|x\rangle|f(x) \rangle$</span>. Discarding the second register gives a coset state <span class=""math-container"">$|x+H\rangle = \frac{1}{\sqrt{|H|}}\sum_{h \in H}|x+h\rangle$</span> since <span class=""math-container"">$f(x)$</span> is identical on cosets of <span class=""math-container"">$H$</span>. Apply the QFT over <span class=""math-container"">$G$</span> to obtain <span class=""math-container"">$|\widehat{x+H}\rangle = \sqrt{\frac{|H|}{|G|}}\sum_{y \in \hat{G}}\chi_y(x)\chi_y(H)|y\rangle = \sqrt{\frac{|H|}{|G|}}\sum_{y: \chi_y(H)=1}\chi_y(x)|y\rangle$</span> where <span class=""math-container"">$\chi_y(H)=\frac{1}{|H|}\sum_{h \in H}\chi_y(h)$</span>.</p>
<p>Next we measure in the computational basis to obtain a character <span class=""math-container"">$\chi_y$</span> that is trivial on the hidden subgroup <span class=""math-container"">$H$</span>. Thus we only need to focus on elements <span class=""math-container"">$g$</span> such that <span class=""math-container"">$\chi_y(g)=1$</span>. This is <span class=""math-container"">$\ker \chi_y = \{g \in G| \chi_y(g)=1\}$</span>. Taking sufficiently many intersections of such kernels yields <span class=""math-container"">$H$</span> with high probability.</p>
<p>In Simon's problem (the HSP with <span class=""math-container"">$G=(\mathbb{Z}/2\mathbb{Z})^n$</span> and <span class=""math-container"">$H=\{0,s\}$</span> for some <span class=""math-container"">$s \in G$</span>) it's possible to show that any classical algorithm must make exponentially many (in <span class=""math-container"">$n$</span>) queries to the hiding function. A proof relies on having a large number of trivially intersecting subgroups of <span class=""math-container"">$G$</span>.</p>
<p>He also states &quot;The gist of the argument is that, since the set <span class=""math-container"">$S$</span> is unstructured, we can do no better than querying random group elements so long as we do not know two elements <span class=""math-container"">$x,y$</span> for which <span class=""math-container"">$f(x) = f(y)$</span>.&quot;</p>
<p>For the case <span class=""math-container"">$G=\mathbb{Z}/N\mathbb{Z}$</span>, <span class=""math-container"">$H=\mathbb{Z}/r\mathbb{Z}$</span>, <span class=""math-container"">$S=(\mathbb{Z}/N\mathbb{Z})^\times$</span> (factoring) are there not a large number of trivially intersecting subgroups, so that the above argument does not apply, and we can't rule out a classical algorithm? It also seems like one could equip <span class=""math-container"">$S$</span> with more structure by embedding it into a field like <span class=""math-container"">$\mathbb{C}$</span> or <span class=""math-container"">$\mathbb{F}_q$</span>.</p>
",Why doesn't Shor's algorithm suggest a fast classical algorithm?,<shors-algorithm><hidden-subgroup-problem><factorization>,0,3,,,"Why doesn't Shor's algorithm suggest a fast classical algorithm? <p>I am reading (and quoting) <a href=""https://www.cs.umd.edu/%7Eamchilds/qa/qa.pdf"" rel=""nofollow noreferrer"">Andrew Child's notes</a>, and I'm trying to understand the HSP for abelian groups, and in particular why the quantum algorithm doesn't shed any light on a potential classical algorithm.</p>
<p>The quantum algorithm prepares the superposition <span class=""math-container"">$\frac{1}{\sqrt{|G|}}\sum_{x \in G}|x\rangle$</span>, then computes the function in the second register <span class=""math-container"">$\frac{1}{\sqrt{|G|}}\sum_{x \in G}|x\rangle|f(x) \rangle$</span>. Discarding the second register gives a coset state <span class=""math-container"">$|x+H\rangle = \frac{1}{\sqrt{|H|}}\sum_{h \in H}|x+h\rangle$</span> since <span class=""math-container"">$f(x)$</span> is identical on cosets of <span class=""math-container"">$H$</span>. Apply the QFT over <span class=""math-container"">$G$</span> to obtain <span class=""math-container"">$|\widehat{x+H}\rangle = \sqrt{\frac{|H|}{|G|}}\sum_{y \in \hat{G}}\chi_y(x)\chi_y(H)|y\rangle = \sqrt{\frac{|H|}{|G|}}\sum_{y: \chi_y(H)=1}\chi_y(x)|y\rangle$</span> where <span class=""math-container"">$\chi_y(H)=\frac{1}{|H|}\sum_{h \in H}\chi_y(h)$</span>.</p>
<p>Next we measure in the computational basis to obtain a character <span class=""math-container"">$\chi_y$</span> that is trivial on the hidden subgroup <span class=""math-container"">$H$</span>. Thus we only need to focus on elements <span class=""math-container"">$g$</span> such that <span class=""math-container"">$\chi_y(g)=1$</span>. This is <span class=""math-container"">$\ker \chi_y = \{g \in G| \chi_y(g)=1\}$</span>. Taking sufficiently many intersections of such kernels yields <span class=""math-container"">$H$</span> with high probability.</p>
<p>In Simon's problem (the HSP with <span class=""math-container"">$G=(\mathbb{Z}/2\mathbb{Z})^n$</span> and <span class=""math-container"">$H=\{0,s\}$</span> for some <span class=""math-container"">$s \in G$</span>) it's possible to show that any classical algorithm must make exponentially many (in <span class=""math-container"">$n$</span>) queries to the hiding function. A proof relies on having a large number of trivially intersecting subgroups of <span class=""math-container"">$G$</span>.</p>
<p>He also states &quot;The gist of the argument is that, since the set <span class=""math-container"">$S$</span> is unstructured, we can do no better than querying random group elements so long as we do not know two elements <span class=""math-container"">$x,y$</span> for which <span class=""math-container"">$f(x) = f(y)$</span>.&quot;</p>
<p>For the case <span class=""math-container"">$G=\mathbb{Z}/N\mathbb{Z}$</span>, <span class=""math-container"">$H=\mathbb{Z}/r\mathbb{Z}$</span>, <span class=""math-container"">$S=(\mathbb{Z}/N\mathbb{Z})^\times$</span> (factoring) are there not a large number of trivially intersecting subgroups, so that the above argument does not apply, and we can't rule out a classical algorithm? It also seems like one could equip <span class=""math-container"">$S$</span> with more structure by embedding it into a field like <span class=""math-container"">$\mathbb{C}$</span> or <span class=""math-container"">$\mathbb{F}_q$</span>.</p>
",qc,shor algorithm suggest fast classical algorithm p reading quoting https nofollow noreferrer andrew child notes trying understand hsp abelian groups particular quantum algorithm shed light potential classical p quantum algorithm prepares superposition span 1 x g computes function second register span 1 x g x discarding second register gives coset state span 1 h h since span f x identical cosets span h apply qft span g obtain span g x h h x span h 1 h h h p next measure computational basis obtain character span trivial hidden subgroup span h thus need focus elements span g span g span g g taking sufficiently many intersections kernels yields span h high p simon problem hsp span z z span 0 span g possible show classical algorithm must make exponentially many span n queries hiding function proof relies large number trivially intersecting subgroups span g p also states quot gist argument since set span unstructured better querying random group elements long know two elements span x span f x f quot p case span z z span z z span z z factoring large number trivially intersecting subgroups argument apply ca rule classical algorithm also seems like one could equip span structure embedding field like span c span f,"[(1, 0.044760764), (3, 0.629863), (7, 0.052770775), (8, 0.07273855), (10, 0.11829909), (13, 0.027066022), (17, 0.01260837), (18, 0.017389195), (19, 0.011034527)]"
39135,39165.0,2024-07-13 04:26:40,2,111,"<p>I am stuck with a problem while trying to run the code on quantum hardware. What I have learned through video lectures is that you can save the job id when you run job on hardware and from job id retreive the results because quantum HW sometimes takes a lot of time due to big queues. But in the below code, when I use <code> m3_mitigator.cals_from_system(final_maps)</code>  , it calls the actual hardware, which may take up a lot of time. Not sure how to deal in this case? Any suggestions would be great help.</p>
<pre><code>  m3_mitigator = mthree.M3Mitigation(backend)

  final_maps = final_measurement_mapping(pt_circs)
        
  m3_mitigator.cals_from_system(final_maps)  # Here, the CODE is sending job to the HW

  max_shots = 100000
  
  job = backend.run(pt_circs, shots = max_shots)
  print(job.job_id())         # I will save it to some csv file and later retrieve results
</code></pre>
<p><strong>Edit 1</strong></p>
<p>I just realized, I am doing one more mistake. I have to somehow apply the <code>correction</code> also. Should I apply corrections after retreiveing results from <code>job_id</code>? Thank you for great and kind help.</p>
",How to save and retrieve results of m3_mitigator.cals_from_system API,<qiskit><programming>,1,0,,,"How to save and retrieve results of m3_mitigator.cals_from_system API <p>I am stuck with a problem while trying to run the code on quantum hardware. What I have learned through video lectures is that you can save the job id when you run job on hardware and from job id retreive the results because quantum HW sometimes takes a lot of time due to big queues. But in the below code, when I use <code> m3_mitigator.cals_from_system(final_maps)</code>  , it calls the actual hardware, which may take up a lot of time. Not sure how to deal in this case? Any suggestions would be great help.</p>
<pre><code>  m3_mitigator = mthree.M3Mitigation(backend)

  final_maps = final_measurement_mapping(pt_circs)
        
  m3_mitigator.cals_from_system(final_maps)  # Here, the CODE is sending job to the HW

  max_shots = 100000
  
  job = backend.run(pt_circs, shots = max_shots)
  print(job.job_id())         # I will save it to some csv file and later retrieve results
</code></pre>
<p><strong>Edit 1</strong></p>
<p>I just realized, I am doing one more mistake. I have to somehow apply the <code>correction</code> also. Should I apply corrections after retreiveing results from <code>job_id</code>? Thank you for great and kind help.</p>
",qc,save retrieve results api p stuck problem trying run code quantum hardware learned video lectures save job id run job hardware job id retreive results quantum hw sometimes takes lot time due big queues code use code calls actual hardware may take lot time sure deal case suggestions would great pre code backend code sending job hw 100000 job shots print save csv file later retrieve results p strong edit 1 p realized one mistake somehow apply code correction also apply corrections retreiveing results code thank great kind,"[(5, 0.018557554), (8, 0.1738394), (14, 0.58903986), (17, 0.021147745), (19, 0.19571093)]"
39151,,2024-07-14 19:57:58,1,37,"<p>I'm calculating the mutual information between two 1 qubit subsystems in a quantum state using Python. Theoretically, mutual information should always be non-negative. However, I'm encountering very small negative values (on the order of 10^-8) in my results. I suspect these might be due to numerical precision issues, but I'm not entirely sure how to address them.</p>
<ol>
<li>Thresholding: I tried setting very small negative values to zero,
but I would prefer a more rigorous solution.</li>
<li>Higher PrecisionCalculations: Using the decimal module for higher precision, but it
didn't completely resolve the issue.</li>
</ol>
<p>Is this small negative value likely due to numerical precision errors inherent in floating-point arithmetic in Python? How can I modify my calculations to avoid these small negative values rigorously? Is there a better way to handle this within the floating-point limitations? Are there any best practices for handling such precision issues in quantum information calculations?</p>
<p>Additional Info:</p>
<p>I'm using NumPy for numerical calculations.
The density matrices are Hermitian, positive semi definite and normalized.
The small negative values appear sporadically and are typically very close to zero.</p>
","Why is my mutual information negative in Python, and how can I accommodate that?",<programming><density-matrix><mutual-information>,0,5,,,"Why is my mutual information negative in Python, and how can I accommodate that? <p>I'm calculating the mutual information between two 1 qubit subsystems in a quantum state using Python. Theoretically, mutual information should always be non-negative. However, I'm encountering very small negative values (on the order of 10^-8) in my results. I suspect these might be due to numerical precision issues, but I'm not entirely sure how to address them.</p>
<ol>
<li>Thresholding: I tried setting very small negative values to zero,
but I would prefer a more rigorous solution.</li>
<li>Higher PrecisionCalculations: Using the decimal module for higher precision, but it
didn't completely resolve the issue.</li>
</ol>
<p>Is this small negative value likely due to numerical precision errors inherent in floating-point arithmetic in Python? How can I modify my calculations to avoid these small negative values rigorously? Is there a better way to handle this within the floating-point limitations? Are there any best practices for handling such precision issues in quantum information calculations?</p>
<p>Additional Info:</p>
<p>I'm using NumPy for numerical calculations.
The density matrices are Hermitian, positive semi definite and normalized.
The small negative values appear sporadically and are typically very close to zero.</p>
",qc,mutual information negative python accommodate p calculating mutual information two 1 qubit subsystems quantum state using python theoretically mutual information always however encountering small negative values order results suspect might due numerical precision issues entirely sure address ol li thresholding tried setting small negative values zero would prefer rigorous li higher precisioncalculations using decimal module higher precision completely resolve p small negative value likely due numerical precision errors inherent arithmetic python modify calculations avoid small negative values rigorously better way handle within limitations best practices handling precision issues quantum information calculations p additional info p using numpy numerical calculations density matrices hermitian positive semi definite normalized small negative values appear sporadically typically close,"[(3, 0.12884401), (7, 0.21768403), (8, 0.1770048), (11, 0.03668109), (13, 0.06679638), (14, 0.33091095), (17, 0.04088693)]"
39167,,2024-07-16 11:38:20,1,76,"<p>Recently, I've been looking into quantum error correction codes as tensor networks. I collected the following &quot;facts&quot; (which may be wrong, if so, please feel free to correct me on them).</p>
<p>A <span class=""math-container"">$[[n, k, d]]$</span> code can recover any <span class=""math-container"">$t = (d-1)/2$</span> errors or, equivalently, any <span class=""math-container"">$d-1$</span> erasure errors. This is equivalent to there being an isometry from the erased qubits plus the logical ones to the remaining qubits according to <a href=""https://arxiv.org/abs/2009.10329"" rel=""nofollow noreferrer"">Farrelly et al</a>.</p>
<p>Can this be used to &quot;easily&quot; determine the code distance <span class=""math-container"">$d$</span> of a code obtained by contraction of multiple individual codes? Specifically, if I take a bunch of perfect tensors (i.e. <span class=""math-container"">$[[5, 1, 3]]$</span> codes) as nodes in a tensor network and contract some of their legs to obtain a new code, can I find its distance from how many physical logical legs at most the network can be seen as an isometry to the remaining legs? This would mean I could find the number of correctable erasure errors <span class=""math-container"">$d-1$</span> and thus the code distance.</p>
<p>Here's a visualization of what I mean. Each of the nodes is a <span class=""math-container"">$[[5, 1, 3]]$</span> code, the logical leg pointing out of the screen and the physical legs ordered counterclockwise. Because these are perfect tensors, grouping up to two physical legs together with the logical leg as &quot;input legs&quot; and the rest as &quot;output&quot; legs will result in an isometry. Based on this reasoning, I would claim that the code given by the network in the drawing is a <span class=""math-container"">$[[9, 3, 3]]$</span> code. In the case of two erasure errors, I illustrated which legs can be viewed as input and output of each node as an isometry. Then, the full network just concatenates isometries and is thus an isometry itself.</p>
<p><a href=""https://i.sstatic.net/6HQbIILB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6HQbIILB.png"" alt=""2"" /></a></p>
<p>Does this method work? Is it true that we can find <span class=""math-container"">$d$</span> by finding the maximal number of arbitrary physical legs which can be grouped with the logical legs to get an isometry?</p>
",Code distance and existence of isometry in tensor networks,<error-correction><tensor-networks>,0,1,,,"Code distance and existence of isometry in tensor networks <p>Recently, I've been looking into quantum error correction codes as tensor networks. I collected the following &quot;facts&quot; (which may be wrong, if so, please feel free to correct me on them).</p>
<p>A <span class=""math-container"">$[[n, k, d]]$</span> code can recover any <span class=""math-container"">$t = (d-1)/2$</span> errors or, equivalently, any <span class=""math-container"">$d-1$</span> erasure errors. This is equivalent to there being an isometry from the erased qubits plus the logical ones to the remaining qubits according to <a href=""https://arxiv.org/abs/2009.10329"" rel=""nofollow noreferrer"">Farrelly et al</a>.</p>
<p>Can this be used to &quot;easily&quot; determine the code distance <span class=""math-container"">$d$</span> of a code obtained by contraction of multiple individual codes? Specifically, if I take a bunch of perfect tensors (i.e. <span class=""math-container"">$[[5, 1, 3]]$</span> codes) as nodes in a tensor network and contract some of their legs to obtain a new code, can I find its distance from how many physical logical legs at most the network can be seen as an isometry to the remaining legs? This would mean I could find the number of correctable erasure errors <span class=""math-container"">$d-1$</span> and thus the code distance.</p>
<p>Here's a visualization of what I mean. Each of the nodes is a <span class=""math-container"">$[[5, 1, 3]]$</span> code, the logical leg pointing out of the screen and the physical legs ordered counterclockwise. Because these are perfect tensors, grouping up to two physical legs together with the logical leg as &quot;input legs&quot; and the rest as &quot;output&quot; legs will result in an isometry. Based on this reasoning, I would claim that the code given by the network in the drawing is a <span class=""math-container"">$[[9, 3, 3]]$</span> code. In the case of two erasure errors, I illustrated which legs can be viewed as input and output of each node as an isometry. Then, the full network just concatenates isometries and is thus an isometry itself.</p>
<p><a href=""https://i.sstatic.net/6HQbIILB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6HQbIILB.png"" alt=""2"" /></a></p>
<p>Does this method work? Is it true that we can find <span class=""math-container"">$d$</span> by finding the maximal number of arbitrary physical legs which can be grouped with the logical legs to get an isometry?</p>
",qc,code distance existence isometry tensor networks p recently looking quantum error correction codes tensor networks collected following quot facts quot may wrong please feel free correct p span n k code recover span errors equivalently span erasure errors equivalent isometry erased qubits plus logical ones remaining qubits according https nofollow noreferrer farrelly et al p used quot easily quot determine code distance span code obtained contraction multiple individual codes specifically take bunch perfect tensors span 5 1 3 codes nodes tensor network contract legs obtain new code find distance many physical logical legs network seen isometry remaining legs would mean could find number correctable erasure errors span thus code p visualization mean nodes span 5 1 3 code logical leg pointing screen physical legs ordered counterclockwise perfect tensors grouping two physical legs together logical leg quot input legs quot rest quot output quot legs result isometry based reasoning would claim code given network drawing span 9 3 3 code case two erasure errors illustrated legs viewed input output node isometry full network concatenates isometries thus isometry p https nofollow noreferrer img https 2 p method work true find span finding maximal number arbitrary physical legs grouped logical legs get isometry,"[(3, 0.25525975), (4, 0.047505535), (5, 0.18602711), (6, 0.03765398), (8, 0.100140944), (9, 0.1578578), (13, 0.041592088), (14, 0.08404654), (17, 0.02693217), (19, 0.062477607)]"
39183,,2024-07-17 19:25:20,1,38,"<p>We're familiar with Clifford gates for qubits, which have attracted a lot of attention and research effort. Clifford circuits normalize Pauli strings, i.e., under conjugation, Clifford circuits map Pauli strings to other Pauli strings. This enables efficient classical simulations of Clifford circuits.</p>
<p>It's natural to think about Clifford gates for higher-dimensional representations of SU(2). Say, for example, we have a collection of spin-1 degrees of freedom. These still have a notion of Pauli string where each Pauli <span class=""math-container"">$X, Y, Z$</span> now has dimension 3. My questions are</p>
<ol>
<li>Have the generating sets for normalizers of higher-spin Pauli groups been worked out?</li>
<li>Have these &quot;higher dimensional Clifford circuits&quot; attracted much interest? They'd probably be interesting from the perspective of many-body theorists (my area of specialty) but I haven't heard anything about them.</li>
</ol>
<p>Any references you could point me towards which address these subjects would be very helpful. Thanks in advance.</p>
",Higher spin Clifford gates,<resource-request><clifford-group><pauli-group>,0,1,,,"Higher spin Clifford gates <p>We're familiar with Clifford gates for qubits, which have attracted a lot of attention and research effort. Clifford circuits normalize Pauli strings, i.e., under conjugation, Clifford circuits map Pauli strings to other Pauli strings. This enables efficient classical simulations of Clifford circuits.</p>
<p>It's natural to think about Clifford gates for higher-dimensional representations of SU(2). Say, for example, we have a collection of spin-1 degrees of freedom. These still have a notion of Pauli string where each Pauli <span class=""math-container"">$X, Y, Z$</span> now has dimension 3. My questions are</p>
<ol>
<li>Have the generating sets for normalizers of higher-spin Pauli groups been worked out?</li>
<li>Have these &quot;higher dimensional Clifford circuits&quot; attracted much interest? They'd probably be interesting from the perspective of many-body theorists (my area of specialty) but I haven't heard anything about them.</li>
</ol>
<p>Any references you could point me towards which address these subjects would be very helpful. Thanks in advance.</p>
",qc,higher spin clifford gates p familiar clifford gates qubits attracted lot attention research effort clifford circuits normalize pauli strings conjugation clifford circuits map pauli strings pauli strings enables efficient classical simulations clifford p natural think clifford gates representations su 2 say example collection degrees freedom still notion pauli string pauli span x z dimension questions ol li generating sets normalizers pauli groups worked li quot higher dimensional clifford circuits quot attracted much interest probably interesting perspective theorists area specialty heard anything p references could point towards address subjects would helpful thanks,"[(3, 0.19267228), (7, 0.24606577), (9, 0.46653107), (10, 0.011951103), (15, 0.012044151), (17, 0.04709069), (19, 0.022151615)]"
39185,39186.0,2024-07-18 06:19:21,2,255,"<p>I am trying to migrate my code to the latest version of <code>qiskit&gt;=1.0</code>. Below is the sample code I made using the <a href=""https://github.com/Qiskit/qiskit-ibm-runtime"" rel=""nofollow noreferrer""><code>qiskit-ibm-runtime</code> package</a>.
Although the code is hopefully working fine, it has two <code>run</code>, which is kind of strange. Also, there is something new called a <code>sampler</code>. Is this sampler the same as <code>backend.run</code> in previous versions? Also, there is something new called <code>generate_preset_pass_manager</code>. Is this same as <code>transpile</code> in previous versions? The code is as below:</p>
<pre><code>from qiskit import QuantumCircuit, transpile, assemble
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
# https://github.com/Qiskit/qiskit-ibm-runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

# Save an IBM Cloud account.
QiskitRuntimeService.save_account(channel=&quot;ibm_quantum&quot;, token=&quot;Add_your_key&quot;, overwrite=True)


# Read default credentials from disk
service = QiskitRuntimeService(channel = 'ibm_quantum', instance=&quot;ibm-q/open/main&quot;)

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
print(qc.draw())

# Optimize problem for quantum execution
backend = service.least_busy(operational=True, simulator=False)
pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(qc)

sampler = Sampler(mode=backend)
sampler.options.default_shots = 100000
job = sampler.run([isa_circuit])
print(f&quot;Job ID is {job.job_id()}&quot;)
pub_result = job.result()[0]
print(f&quot;Counts for the meas output register: {pub_result.data.meas.get_counts()}&quot;)
</code></pre>
",generate_preset_pass_manager and Sampler API usage in IBM-Qiskit,<qiskit><programming>,1,0,,,"generate_preset_pass_manager and Sampler API usage in IBM-Qiskit <p>I am trying to migrate my code to the latest version of <code>qiskit&gt;=1.0</code>. Below is the sample code I made using the <a href=""https://github.com/Qiskit/qiskit-ibm-runtime"" rel=""nofollow noreferrer""><code>qiskit-ibm-runtime</code> package</a>.
Although the code is hopefully working fine, it has two <code>run</code>, which is kind of strange. Also, there is something new called a <code>sampler</code>. Is this sampler the same as <code>backend.run</code> in previous versions? Also, there is something new called <code>generate_preset_pass_manager</code>. Is this same as <code>transpile</code> in previous versions? The code is as below:</p>
<pre><code>from qiskit import QuantumCircuit, transpile, assemble
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
# https://github.com/Qiskit/qiskit-ibm-runtime
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

# Save an IBM Cloud account.
QiskitRuntimeService.save_account(channel=&quot;ibm_quantum&quot;, token=&quot;Add_your_key&quot;, overwrite=True)


# Read default credentials from disk
service = QiskitRuntimeService(channel = 'ibm_quantum', instance=&quot;ibm-q/open/main&quot;)

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
print(qc.draw())

# Optimize problem for quantum execution
backend = service.least_busy(operational=True, simulator=False)
pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(qc)

sampler = Sampler(mode=backend)
sampler.options.default_shots = 100000
job = sampler.run([isa_circuit])
print(f&quot;Job ID is {job.job_id()}&quot;)
pub_result = job.result()[0]
print(f&quot;Counts for the meas output register: {pub_result.data.meas.get_counts()}&quot;)
</code></pre>
",qc,sampler api usage p trying migrate code latest version code qiskit gt sample code made using https nofollow noreferrer code package although code hopefully working fine two code run kind strange also something new called code sampler sampler code previous versions also something new called code code transpile previous versions code pre code qiskit import quantumcircuit transpile assemble import https import qiskitruntimeservice samplerv2 sampler save ibm cloud account quot quot quot quot read default credentials disk service qiskitruntimeservice channel quot quot qc quantumcircuit 2 0 0 1 print optimize problem quantum execution backend pm qc sampler sampler 100000 job print f quot job id quot 0 print f quot counts meas output register quot,"[(0, 0.50971895), (2, 0.03029841), (4, 0.044745993), (8, 0.09198396), (14, 0.12686713), (17, 0.014030777), (19, 0.18121576)]"
39222,,2024-07-19 21:30:21,0,55,"<p>It is an old paper but I'm trying to understand one of their argument. They say that if</p>
<p><span class=""math-container"">$$U|u\rangle |a\rangle = |u\rangle |a^\prime\rangle \ \ \ \mathrm{and} \ \ \ U|v\rangle |a\rangle = |v\rangle |a^{\prime\prime}\rangle$$</span></p>
<p>then since <span class=""math-container"">$U$</span> is unitary</p>
<p><span class=""math-container"">$$ \langle u|v\rangle  = \langle a| \langle u|v\rangle |a\rangle = \langle a^{\prime}| \langle u|v\rangle |a^{\prime\prime} \rangle$$</span></p>
<p>This is Equation (4).</p>
<p>The first equality is simple: <span class=""math-container"">$\langle u|v\rangle  = \langle a| (\langle u|v\rangle |a\rangle)$</span>, since <span class=""math-container"">$\langle a|a\rangle = 1$</span>.</p>
<p>Then, <span class=""math-container"">$\langle a| \langle u|v\rangle |a\rangle = \langle a| \langle u| U^* U |v\rangle |a\rangle = \langle a| \langle u| U^* |v\rangle |a^{\prime\prime}\rangle$</span>.</p>
<p>The last step should be <span class=""math-container"">$\langle a| \langle u| U^* = (U |a \rangle |u \rangle)^*$</span>. I do not see how to conclude from here. The Hermitian transpose on the Kronecker product of two matrices does not commute the matrices.</p>
<p>Where is my error?</p>
",Quantum Cryptography without Bell's Theorem -- Brassard - Bennett - Mermin,<textbook-and-exercises><linear-algebra><terminology-and-notation><qkd>,1,1,,,"Quantum Cryptography without Bell's Theorem -- Brassard - Bennett - Mermin <p>It is an old paper but I'm trying to understand one of their argument. They say that if</p>
<p><span class=""math-container"">$$U|u\rangle |a\rangle = |u\rangle |a^\prime\rangle \ \ \ \mathrm{and} \ \ \ U|v\rangle |a\rangle = |v\rangle |a^{\prime\prime}\rangle$$</span></p>
<p>then since <span class=""math-container"">$U$</span> is unitary</p>
<p><span class=""math-container"">$$ \langle u|v\rangle  = \langle a| \langle u|v\rangle |a\rangle = \langle a^{\prime}| \langle u|v\rangle |a^{\prime\prime} \rangle$$</span></p>
<p>This is Equation (4).</p>
<p>The first equality is simple: <span class=""math-container"">$\langle u|v\rangle  = \langle a| (\langle u|v\rangle |a\rangle)$</span>, since <span class=""math-container"">$\langle a|a\rangle = 1$</span>.</p>
<p>Then, <span class=""math-container"">$\langle a| \langle u|v\rangle |a\rangle = \langle a| \langle u| U^* U |v\rangle |a\rangle = \langle a| \langle u| U^* |v\rangle |a^{\prime\prime}\rangle$</span>.</p>
<p>The last step should be <span class=""math-container"">$\langle a| \langle u| U^* = (U |a \rangle |u \rangle)^*$</span>. I do not see how to conclude from here. The Hermitian transpose on the Kronecker product of two matrices does not commute the matrices.</p>
<p>Where is my error?</p>
",qc,quantum cryptography without bell theorem brassard bennett mermin p old paper trying understand one argument say p span p since span u unitary p span p equation 4 p first equality simple span since span 1 p span u p last step span u see conclude hermitian transpose kronecker product two matrices commute p error,"[(3, 0.7421053), (5, 0.036562175), (8, 0.09530307), (17, 0.019203357), (18, 0.10405728)]"
39276,39278.0,2024-07-24 22:49:32,1,120,"<p>I'm looking for open-source code that implements lattice surgery merging and splitting between two rotated surface code logical qubits in STIM (for d=3 or above).</p>
<p>Whilst there are some excellent explanations on this site (thank you users Craig Gidney and &quot;control freak&quot;), I'm struggling to correctly implement lattice surgery in STIM. Mostly, this is because of the complexity and finickiness of implementing the merge and split operations and ensuring I introduce/remove detectors appropriately. It does not help that I am new to QEC either. What I'm looking for seems to be a fairly textbook situation - which is why I hope there's open source code out there (or perhaps a very detailed step-by-step explanation).</p>
<p>Ideally, I'd like to use code to modify the error rates of seam operations to understand how that affects (for example) logical qubit teleportation using lattice surgery.</p>
<p>Thank you.</p>
",Open-source code for Lattice Surgery in STIM,<stim><lattice-surgery>,1,0,,,"Open-source code for Lattice Surgery in STIM <p>I'm looking for open-source code that implements lattice surgery merging and splitting between two rotated surface code logical qubits in STIM (for d=3 or above).</p>
<p>Whilst there are some excellent explanations on this site (thank you users Craig Gidney and &quot;control freak&quot;), I'm struggling to correctly implement lattice surgery in STIM. Mostly, this is because of the complexity and finickiness of implementing the merge and split operations and ensuring I introduce/remove detectors appropriately. It does not help that I am new to QEC either. What I'm looking for seems to be a fairly textbook situation - which is why I hope there's open source code out there (or perhaps a very detailed step-by-step explanation).</p>
<p>Ideally, I'd like to use code to modify the error rates of seam operations to understand how that affects (for example) logical qubit teleportation using lattice surgery.</p>
<p>Thank you.</p>
",qc,code lattice surgery stim p looking code implements lattice surgery merging splitting two rotated surface code logical qubits stim p whilst excellent explanations site thank users craig gidney quot control freak quot struggling correctly implement lattice surgery stim mostly complexity finickiness implementing merge split operations ensuring detectors appropriately help new qec either looking seems fairly textbook situation hope open source code perhaps detailed explanation p ideally like use code modify error rates seam operations understand affects example logical qubit teleportation using lattice p thank,"[(5, 0.26782596), (7, 0.06149608), (8, 0.110103555), (9, 0.104875885), (13, 0.11324062), (14, 0.082948856), (16, 0.10773451), (17, 0.027872857), (18, 0.09240048), (19, 0.03026848)]"
39289,39363.0,2024-07-25 08:22:41,2,68,"<p>For a fixed fermion-qubit mapping, basis, active space, and geometry, is the electronic structure Hamiltonian uniquely defined?</p>
<p>I would think so, since</p>
<ul>
<li>for a given basis the one- and two-body integrals in the second quantized representation of the Hamiltonian should be unambiguously defined</li>
<li>for a given mapping the translation to Pauli strings should be unambiguously defined.
This assumes that there is a consistent naming in the community and we all understand the exact same transformation by the name 'Jordan-Wigner' for example.</li>
</ul>
<p>However, this assumption is not consistent with two points:</p>
<ul>
<li>Constructing a molecular Hamiltonian using pennylane <code>qchem.molecular_hamiltonian</code> with different methods, eg. 'pyscf' and 'dhf' does not give the same Hamiltonian (ignoring some differences in the last digits). The Pauli strings are the same and the absolut values of coefficients are the same, but some terms differ in the sign. So, the one- and two-body terms are not clearly defined by the basis and geometry? Why?</li>
<li>There are pennylane datasets for molecular Hamiltonians calculated with the Jordan-Wigner mapping (<a href=""https://pennylane.ai/datasets/qchem/n2-molecule"" rel=""nofollow noreferrer"">eg</a>). This Hamiltonian has the same number of terms and acts on the same number of qubits as the one constructed using <code>qchem.molecular_hamiltonian</code> but otherwise is different.</li>
</ul>
<p>Where do these differences come from? How are the datasets constructed?</p>
<p><strong>Edit:</strong> On the second problem
The two Hamiltonians are equivalent when rounding the coefficients and the eigenspectrum to the 4th decimal. My mistake was forgetting to add the conversion factor between Angstrom (datasets) and Atomic Units (pennylane).</p>
",Is a molecular Hamiltonian defined uniquely? or Where do differences in pennylane Hamiltonians come from?,<pennylane><hamiltonian>,1,0,,,"Is a molecular Hamiltonian defined uniquely? or Where do differences in pennylane Hamiltonians come from? <p>For a fixed fermion-qubit mapping, basis, active space, and geometry, is the electronic structure Hamiltonian uniquely defined?</p>
<p>I would think so, since</p>
<ul>
<li>for a given basis the one- and two-body integrals in the second quantized representation of the Hamiltonian should be unambiguously defined</li>
<li>for a given mapping the translation to Pauli strings should be unambiguously defined.
This assumes that there is a consistent naming in the community and we all understand the exact same transformation by the name 'Jordan-Wigner' for example.</li>
</ul>
<p>However, this assumption is not consistent with two points:</p>
<ul>
<li>Constructing a molecular Hamiltonian using pennylane <code>qchem.molecular_hamiltonian</code> with different methods, eg. 'pyscf' and 'dhf' does not give the same Hamiltonian (ignoring some differences in the last digits). The Pauli strings are the same and the absolut values of coefficients are the same, but some terms differ in the sign. So, the one- and two-body terms are not clearly defined by the basis and geometry? Why?</li>
<li>There are pennylane datasets for molecular Hamiltonians calculated with the Jordan-Wigner mapping (<a href=""https://pennylane.ai/datasets/qchem/n2-molecule"" rel=""nofollow noreferrer"">eg</a>). This Hamiltonian has the same number of terms and acts on the same number of qubits as the one constructed using <code>qchem.molecular_hamiltonian</code> but otherwise is different.</li>
</ul>
<p>Where do these differences come from? How are the datasets constructed?</p>
<p><strong>Edit:</strong> On the second problem
The two Hamiltonians are equivalent when rounding the coefficients and the eigenspectrum to the 4th decimal. My mistake was forgetting to add the conversion factor between Angstrom (datasets) and Atomic Units (pennylane).</p>
",qc,molecular hamiltonian defined uniquely differences pennylane hamiltonians come p fixed mapping basis active space geometry electronic structure hamiltonian uniquely defined p would think since ul li given basis integrals second quantized representation hamiltonian unambiguously defined li given mapping translation pauli strings unambiguously defined assumes consistent naming community understand exact transformation name p however assumption consistent two points ul li constructing molecular hamiltonian using pennylane code different methods eg give hamiltonian ignoring differences last digits pauli strings absolut values coefficients terms differ sign terms clearly defined basis geometry li pennylane datasets molecular hamiltonians calculated mapping https nofollow noreferrer eg hamiltonian number terms acts number qubits one constructed using code otherwise p differences come datasets constructed p strong edit second problem two hamiltonians equivalent rounding coefficients eigenspectrum 4th decimal mistake forgetting add conversion factor angstrom datasets atomic units pennylane,"[(0, 0.08489178), (1, 0.07767692), (3, 0.29038867), (7, 0.10973904), (8, 0.11749947), (9, 0.2463241), (13, 0.04270068), (17, 0.029896343)]"
39355,39356.0,2024-07-29 08:10:33,2,188,"<p>I am familiar with the surface code, which encodes one logical qubit and the logical X and Z operators are horizontal and vertical lines of X and Z physical gates respectively.</p>
<p>However, the toric code encodes two logical qubits. What are the logical <span class=""math-container"">$X_1, X_2, Z_1$</span> and <span class=""math-container"">$Z_2$</span>? On Wikipedia, only two logical operators are <a href=""https://en.wikipedia.org/wiki/Toric_code#/media/File:ToricCodeTorus.png"" rel=""nofollow noreferrer"">highlighted</a> but we need two more.</p>
",What are the logical X and Z operators of the two qubits of the toric code?,<error-correction><stabilizer-code><toric-code>,2,0,,,"What are the logical X and Z operators of the two qubits of the toric code? <p>I am familiar with the surface code, which encodes one logical qubit and the logical X and Z operators are horizontal and vertical lines of X and Z physical gates respectively.</p>
<p>However, the toric code encodes two logical qubits. What are the logical <span class=""math-container"">$X_1, X_2, Z_1$</span> and <span class=""math-container"">$Z_2$</span>? On Wikipedia, only two logical operators are <a href=""https://en.wikipedia.org/wiki/Toric_code#/media/File:ToricCodeTorus.png"" rel=""nofollow noreferrer"">highlighted</a> but we need two more.</p>
",qc,logical x z operators two qubits toric code p familiar surface code encodes one logical qubit logical x z operators horizontal vertical lines x z physical gates p however toric code encodes two logical qubits logical span span wikipedia two logical operators https nofollow noreferrer highlighted need two,"[(5, 0.59283453), (9, 0.2839626), (10, 0.074816935), (17, 0.04506467)]"
39374,,2024-07-30 08:30:28,0,43,"<p>To implement the Splitting method in an architecture using Stim and PyMatching for resource estimation at low error rates ( <span class=""math-container"">$10^{-6}$</span> ), where Monte Carlo simulation is ineffective, I recently found a <a href=""https://doi.org/10.1103/PhysRevResearch.6.013177"" rel=""nofollow noreferrer"">relevant paper</a> and its <a href=""https://github.com/dpwinter/qsample"" rel=""nofollow noreferrer"">associated GitHub repository</a>. This paper utilizes an importance sampling method. I would like to inquire if there is a class in Stim that supports this approach.</p>
<p>Thank you!</p>
",Resource Estimation with Stim,<stim><pymatching>,0,3,,,"Resource Estimation with Stim <p>To implement the Splitting method in an architecture using Stim and PyMatching for resource estimation at low error rates ( <span class=""math-container"">$10^{-6}$</span> ), where Monte Carlo simulation is ineffective, I recently found a <a href=""https://doi.org/10.1103/PhysRevResearch.6.013177"" rel=""nofollow noreferrer"">relevant paper</a> and its <a href=""https://github.com/dpwinter/qsample"" rel=""nofollow noreferrer"">associated GitHub repository</a>. This paper utilizes an importance sampling method. I would like to inquire if there is a class in Stim that supports this approach.</p>
<p>Thank you!</p>
",qc,resource estimation stim p implement splitting method architecture using stim pymatching resource estimation low error rates span monte carlo simulation ineffective recently found https nofollow noreferrer relevant paper https nofollow noreferrer associated github repository paper utilizes importance sampling method would like inquire class stim supports p thank,"[(3, 0.020003295), (4, 0.17727968), (5, 0.12100557), (7, 0.12593067), (8, 0.32717755), (11, 0.026632357), (14, 0.17727219), (17, 0.02209514)]"
39410,,2024-08-01 15:13:43,1,63,"<p>How do I implement those two gates in the new version of Qiskit? I have used RY and PhaseShift resp. but I don't know if it's correct or not.</p>
",Implementation of U3 and U1 gate in Qiskit-1.0,<quantum-gate><superconducting-quantum-computing>,1,0,,,"Implementation of U3 and U1 gate in Qiskit-1.0 <p>How do I implement those two gates in the new version of Qiskit? I have used RY and PhaseShift resp. but I don't know if it's correct or not.</p>
",qc,implementation u3 u1 gate p implement two gates new version qiskit used ry phaseshift resp know correct,"[(4, 0.80353373), (11, 0.06140492), (17, 0.12513319)]"
39422,39423.0,2024-08-02 09:19:43,2,58,"<p>Given some quantum channel—or, more generally, some positive linear map—<span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> one usually calls <span class=""math-container"">$\Phi$</span> a <em>pure operation</em> if for all <span class=""math-container"">$\rho\geq 0$</span> pure (rank 1), <span class=""math-container"">$\Phi(\rho)$</span> is pure, as well. For example, every unitary channel or, more generally, every completely positive map of Kraus rank 1 is pure. Based on this let us ask the following question:</p>
<blockquote>
<p>If <span class=""math-container"">$\Phi$</span> is a pure operation, is <span class=""math-container"">${\rm id}_k\otimes\Phi$</span> a pure operation for all <span class=""math-container"">$k\in\mathbb N$</span>, as well?</p>
</blockquote>
<p>To return to the example, if <span class=""math-container"">$\Phi$</span> has Kraus rank 1, then the same is true for <span class=""math-container"">${\rm id}\otimes\Phi$</span> so in this case the statement in question holds.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",Is the extension of a pure operation also a pure operation?,<quantum-operation>,1,0,,,"Is the extension of a pure operation also a pure operation? <p>Given some quantum channel—or, more generally, some positive linear map—<span class=""math-container"">$\Phi:\mathbb C^{n\times n}\to\mathbb C^{n\times n}$</span> one usually calls <span class=""math-container"">$\Phi$</span> a <em>pure operation</em> if for all <span class=""math-container"">$\rho\geq 0$</span> pure (rank 1), <span class=""math-container"">$\Phi(\rho)$</span> is pure, as well. For example, every unitary channel or, more generally, every completely positive map of Kraus rank 1 is pure. Based on this let us ask the following question:</p>
<blockquote>
<p>If <span class=""math-container"">$\Phi$</span> is a pure operation, is <span class=""math-container"">${\rm id}_k\otimes\Phi$</span> a pure operation for all <span class=""math-container"">$k\in\mathbb N$</span>, as well?</p>
</blockquote>
<p>To return to the example, if <span class=""math-container"">$\Phi$</span> has Kraus rank 1, then the same is true for <span class=""math-container"">${\rm id}\otimes\Phi$</span> so in this case the statement in question holds.</p>
<hr />
<p><em>(This is a Q&amp;A style question meant as a contribution to the <a href=""https://quantumcomputing.stackexchange.com/q/37800"">list of counterexamples in quantum information</a>)</em></p>
",qc,extension pure operation also pure operation p given quantum generally positive linear span n n one usually calls span em pure operation span 0 pure rank 1 span pure well example every unitary channel generally every completely positive map kraus rank 1 pure based let us ask following question blockquote p span pure operation span id pure operation span n well p return example span kraus rank 1 true span id case statement question hr p em q amp style question meant contribution https list counterexamples quantum information,"[(0, 0.023646105), (2, 0.021458998), (3, 0.8748192), (11, 0.038093302), (15, 0.013862431), (17, 0.026532259)]"
39433,39434.0,2024-08-04 11:22:38,2,41,"<p>I am following Section 4.6.1 of Mark Wilde's <a href=""https://arxiv.org/pdf/1106.1445"" rel=""nofollow noreferrer"">book</a>. The preparation map goes from a trivial input Hilbert space <span class=""math-container"">$\mathbb{C}$</span> to some output Hilbert space <span class=""math-container"">$\mathcal{H}_A$</span>. Let it prepare the state <span class=""math-container"">$\vert 0\rangle\langle 0\vert$</span>. Then, it has a single Kraus operator <span class=""math-container"">$\{ \vert 0\rangle\}$</span>.</p>
<p>The Choi state of the channel is obtained by acting the the channel on one half of a maximally entangled state. What is the maximally entangled state for the trivial Hilbert space <span class=""math-container"">$\mathbb{C}$</span> which I should use as input to the channel in order to construct its Choi state?</p>
<p>I also tried thinking in terms of <a href=""https://quantumcomputing.stackexchange.com/questions/5804/how-does-the-vectorization-map-relate-to-the-choi-and-kraus-representations-of-a/5816#5816"">vectorization</a> but I'm not sure how to vectorize the Kraus operator here (since it is already a vector!).</p>
","In the Choi of the state preparation map, what is the maximally entangled state with the trivial space $\mathbb{C}$?",<quantum-operation><kraus-representation><state-preparation>,2,0,,,"In the Choi of the state preparation map, what is the maximally entangled state with the trivial space $\mathbb{C}$? <p>I am following Section 4.6.1 of Mark Wilde's <a href=""https://arxiv.org/pdf/1106.1445"" rel=""nofollow noreferrer"">book</a>. The preparation map goes from a trivial input Hilbert space <span class=""math-container"">$\mathbb{C}$</span> to some output Hilbert space <span class=""math-container"">$\mathcal{H}_A$</span>. Let it prepare the state <span class=""math-container"">$\vert 0\rangle\langle 0\vert$</span>. Then, it has a single Kraus operator <span class=""math-container"">$\{ \vert 0\rangle\}$</span>.</p>
<p>The Choi state of the channel is obtained by acting the the channel on one half of a maximally entangled state. What is the maximally entangled state for the trivial Hilbert space <span class=""math-container"">$\mathbb{C}$</span> which I should use as input to the channel in order to construct its Choi state?</p>
<p>I also tried thinking in terms of <a href=""https://quantumcomputing.stackexchange.com/questions/5804/how-does-the-vectorization-map-relate-to-the-choi-and-kraus-representations-of-a/5816#5816"">vectorization</a> but I'm not sure how to vectorize the Kraus operator here (since it is already a vector!).</p>
",qc,choi state preparation map maximally entangled state trivial space c p following section mark wilde https nofollow noreferrer book preparation map goes trivial input hilbert space span c output hilbert space span h let prepare state span single kraus operator span p choi state channel obtained acting channel one half maximally entangled state maximally entangled state trivial hilbert space span c use input channel order construct choi state p also tried thinking terms https 5816 vectorization sure vectorize kraus operator since already vector,"[(3, 0.6344533), (4, 0.05306037), (13, 0.08136792), (17, 0.016056744), (18, 0.21321377)]"
39522,,2024-08-12 16:51:57,1,118,"<p>I've been reading the <a href=""https://www.uio.no/studier/emner/matnat/math/MAT4430/v22/lecture-notes/lecture4.pdf"" rel=""nofollow noreferrer"">following</a> lecture notes in which two isomorphisms are defined:</p>
<ul>
<li>vectorization: <span class=""math-container"">$\text{vec}:B(H_A,H_B)\to H_A\otimes H_B$</span> and</li>
<li>the Choi-Jamiołkowski isomorphism: <span class=""math-container"">$C:B(B(H_A), B(H_B )) \to B(H_A \otimes H_B )$</span>
where <span class=""math-container"">$H_A, H_B$</span> are Hilbert spaces and <span class=""math-container"">$B(H)$</span> is the space of bounded linear operators on the Hilbert space <span class=""math-container"">$H.$</span></li>
</ul>
<p>The graphical representation for <span class=""math-container"">$\text{vec}(A)$</span> is drawn on page 4, and reproduced here for convenience:</p>
<p><a href=""https://i.sstatic.net/7J3LhveK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7J3LhveK.png"" alt=""this"" /></a></p>
<p>I think I understand it, but I'm struggling to draw a similarly intuitive picture of <span class=""math-container"">$C(L)$</span> for <span class=""math-container"">$L\in B(B(H_A), B(H_B))$</span></p>
<p>I'm aware that they are effectively equivalent, but I'd like to draw a diagram that would let me see immediately e.g. the identity listed as Lemma 1.3: <span class=""math-container"">$C(L) = (id_A\otimes L) (\omega_{d_A})$</span>  (for <span class=""math-container"">$\omega_{d_A}$</span> the density matrix describing the <span class=""math-container"">$d_A$</span> dimensional maximally entangled state, or generalized Bell state) as well as similar such calculations.</p>
<p>Put simply, if <span class=""math-container"">$\text{vec}(A)$</span> is given by the picture above, what is <span class=""math-container"">$C(L)?$</span></p>
",Explicit graphical calculus representation of Choi-Jamiołkowski isomorphism?,<linear-algebra><tensor-networks><zx-calculus>,1,4,,,"Explicit graphical calculus representation of Choi-Jamiołkowski isomorphism? <p>I've been reading the <a href=""https://www.uio.no/studier/emner/matnat/math/MAT4430/v22/lecture-notes/lecture4.pdf"" rel=""nofollow noreferrer"">following</a> lecture notes in which two isomorphisms are defined:</p>
<ul>
<li>vectorization: <span class=""math-container"">$\text{vec}:B(H_A,H_B)\to H_A\otimes H_B$</span> and</li>
<li>the Choi-Jamiołkowski isomorphism: <span class=""math-container"">$C:B(B(H_A), B(H_B )) \to B(H_A \otimes H_B )$</span>
where <span class=""math-container"">$H_A, H_B$</span> are Hilbert spaces and <span class=""math-container"">$B(H)$</span> is the space of bounded linear operators on the Hilbert space <span class=""math-container"">$H.$</span></li>
</ul>
<p>The graphical representation for <span class=""math-container"">$\text{vec}(A)$</span> is drawn on page 4, and reproduced here for convenience:</p>
<p><a href=""https://i.sstatic.net/7J3LhveK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/7J3LhveK.png"" alt=""this"" /></a></p>
<p>I think I understand it, but I'm struggling to draw a similarly intuitive picture of <span class=""math-container"">$C(L)$</span> for <span class=""math-container"">$L\in B(B(H_A), B(H_B))$</span></p>
<p>I'm aware that they are effectively equivalent, but I'd like to draw a diagram that would let me see immediately e.g. the identity listed as Lemma 1.3: <span class=""math-container"">$C(L) = (id_A\otimes L) (\omega_{d_A})$</span>  (for <span class=""math-container"">$\omega_{d_A}$</span> the density matrix describing the <span class=""math-container"">$d_A$</span> dimensional maximally entangled state, or generalized Bell state) as well as similar such calculations.</p>
<p>Put simply, if <span class=""math-container"">$\text{vec}(A)$</span> is given by the picture above, what is <span class=""math-container"">$C(L)?$</span></p>
",qc,explicit graphical calculus representation isomorphism p reading https nofollow noreferrer following lecture notes two isomorphisms defined ul li vectorization span vec b li isomorphism span c b b b b span hilbert spaces span b h space bounded linear operators hilbert space span p graphical representation span vec drawn page 4 reproduced convenience p https nofollow noreferrer img https p think understand struggling draw similarly intuitive picture span c l span b b b p aware effectively equivalent like draw diagram would let see immediately identity listed lemma span c l l span density matrix describing span dimensional maximally entangled state generalized bell state well similar p put simply span vec given picture span c l,"[(3, 0.69229203), (4, 0.15060759), (9, 0.057150416), (10, 0.030616898), (13, 0.02412446), (17, 0.010895375), (18, 0.033183713)]"
39544,,2024-08-13 18:59:05,1,44,"<p>This <a href=""https://arxiv.org/abs/2103.16726"" rel=""nofollow noreferrer"">paper</a> mentions the volume of qubit in equation (9) given by:
<span class=""math-container"">$$Q_0=U*C_1*T_o*n_p^{(2/3)}*(v_q)^{(2/3)}$$</span>
where</p>
<ul>
<li><span class=""math-container"">$Q_0$</span> is the heat entering the chamber</li>
<li><span class=""math-container"">$U$</span> is the heat transfer coefficient</li>
<li><span class=""math-container"">$C_1$</span> is a geometric constant. (For a cube, C_1=6; for a
sphere, <span class=""math-container"">$C_1=\sqrt{36\pi}$</span>)</li>
<li><span class=""math-container"">$n_p$</span> is the number of qubits</li>
<li><span class=""math-container"">$v_q$</span> is the volume required to house a qubit when all connections and other geometric constraints are taken into account.</li>
</ul>
<p>Are there any numerical values commonly used for <span class=""math-container"">$v_q$</span>? Otherwise, is there any approximation that can be used to assess its value roughly?</p>
<p>Unfortunately, this value as well as the value of the power used by a qubit  are not reported in the literature but they are fundamental to calculate the energy consumed by quantum chips.</p>
",Numerical values for the volume of qubits,<quantum-gate><quantum-algorithms>,0,2,,,"Numerical values for the volume of qubits <p>This <a href=""https://arxiv.org/abs/2103.16726"" rel=""nofollow noreferrer"">paper</a> mentions the volume of qubit in equation (9) given by:
<span class=""math-container"">$$Q_0=U*C_1*T_o*n_p^{(2/3)}*(v_q)^{(2/3)}$$</span>
where</p>
<ul>
<li><span class=""math-container"">$Q_0$</span> is the heat entering the chamber</li>
<li><span class=""math-container"">$U$</span> is the heat transfer coefficient</li>
<li><span class=""math-container"">$C_1$</span> is a geometric constant. (For a cube, C_1=6; for a
sphere, <span class=""math-container"">$C_1=\sqrt{36\pi}$</span>)</li>
<li><span class=""math-container"">$n_p$</span> is the number of qubits</li>
<li><span class=""math-container"">$v_q$</span> is the volume required to house a qubit when all connections and other geometric constraints are taken into account.</li>
</ul>
<p>Are there any numerical values commonly used for <span class=""math-container"">$v_q$</span>? Otherwise, is there any approximation that can be used to assess its value roughly?</p>
<p>Unfortunately, this value as well as the value of the power used by a qubit  are not reported in the literature but they are fundamental to calculate the energy consumed by quantum chips.</p>
",qc,numerical values volume qubits p https nofollow noreferrer paper mentions volume qubit equation 9 given span ul li span heat entering chamber li span u heat transfer coefficient li span geometric constant cube sphere span li span number qubits li span volume required house qubit connections geometric constraints taken p numerical values commonly used span otherwise approximation used assess value roughly p unfortunately value well value power used qubit reported literature fundamental calculate energy consumed quantum,"[(3, 0.2417071), (6, 0.013459953), (7, 0.6399334), (17, 0.01668403), (18, 0.08624439)]"
39605,39613.0,2024-08-19 13:25:26,2,72,"<p><strong>Disclaimer:</strong> I am not sure about whether my question is suitable for here, but I will ask it anyway.</p>
<p>I am making research about quantum cryptography, so I start reading a book. In one paragraph, it is said that</p>
<blockquote>
<p>Ordinary computers operate at a relatively macroscopic level, and at
that level quantum laws and classical laws are almost indistinguishable.It did not therefore matter that scientists had generally thought of
ordinary computers in terms of classical physics. However, at the
microscopic level the two sets of laws diverge, and at this level only the laws of quantum physics hold true.</p>
</blockquote>
<p>I am confused here, because I know that laws of quantum and classical physics are very different. Can you please enlighten me about the sentence &quot;at that level quantum laws and classical laws are almost indistinguishable&quot;.</p>
<p>I could not understand how quantum laws hold in macroscopic level.</p>
",How quantum laws hold on macroscopic level in classical computers?,<classical-computing><decoherence><foundations>,1,0,,,"How quantum laws hold on macroscopic level in classical computers? <p><strong>Disclaimer:</strong> I am not sure about whether my question is suitable for here, but I will ask it anyway.</p>
<p>I am making research about quantum cryptography, so I start reading a book. In one paragraph, it is said that</p>
<blockquote>
<p>Ordinary computers operate at a relatively macroscopic level, and at
that level quantum laws and classical laws are almost indistinguishable.It did not therefore matter that scientists had generally thought of
ordinary computers in terms of classical physics. However, at the
microscopic level the two sets of laws diverge, and at this level only the laws of quantum physics hold true.</p>
</blockquote>
<p>I am confused here, because I know that laws of quantum and classical physics are very different. Can you please enlighten me about the sentence &quot;at that level quantum laws and classical laws are almost indistinguishable&quot;.</p>
<p>I could not understand how quantum laws hold in macroscopic level.</p>
",qc,quantum laws hold macroscopic level classical computers p strong disclaimer sure whether question suitable ask p making research quantum cryptography start reading book one paragraph said blockquote p ordinary computers operate relatively macroscopic level level quantum laws classical laws almost therefore matter scientists generally thought ordinary computers terms classical physics however microscopic level two sets laws diverge level laws quantum physics hold p confused know laws quantum classical physics different please enlighten sentence quot level quantum laws classical laws almost indistinguishable quot p could understand quantum laws hold macroscopic,"[(1, 0.13096909), (8, 0.51604885), (9, 0.12062424), (14, 0.01344209), (17, 0.19205007), (19, 0.025256258)]"
39610,,2024-08-19 16:31:52,0,62,"<p>I'm trying to simulate error correction with the <a href=""https://doi.org/10.1103/PRXQuantum.5.010342"" rel=""nofollow noreferrer"">Floquet Color Code</a>. On the torus, this code has two logical qubits. For efficiency, I'm want to simulate two commuting logical operators at the same time - a product of Pauli Xs along the x direction of the torus and along the y direction. <strong>However, I find that the logical error rate for the x direction is different when I simulate the y logical at the same time compared to when I simulate the x logical alone.</strong></p>
<p>The two stim files are available <a href=""https://www.dropbox.com/scl/fo/9a3871a3a11x1cg4u9exn/AMCcS-9h8bGiamOpd3D5UZo?rlkey=fqlbincp3b3s3karm8o70rno2&amp;st=z95ul3qj&amp;dl=0"" rel=""nofollow noreferrer"">here</a> - note they are identical up to the logical measurement of the y operator at the end and OBSERVABLE_INCLUDE instructions for y. This is the code I'm using to determine the logical error rates:</p>
<pre><code>import stim
import pymatching
import numpy as np

filename = 'x_y_logical.stim' # or 'x_logical.stim'
circ = stim.Circuit.from_file(filename)
shots = 1000000

model = circ.detector_error_model(decompose_errors=True)
matching = pymatching.Matching.from_detector_error_model(model)
sampler = circ.compile_detector_sampler()
syndrome, actual_observables = sampler.sample(shots=shots, separate_observables=True)

predicted_observables = matching.decode_batch(syndrome)
num_errors = np.sum(predicted_observables != actual_observables, axis=0)

log_err_rate = num_errors / shots
print(&quot;logical error_rate&quot;, log_err_rate)
</code></pre>
<p>When run on x_y together the result is approximately [0.189516 0.207379], and for x alone it is [0.197398].</p>
",Simulating error correction of multiple commuting logical operators with stim and pymatching,<error-correction><stim><pymatching>,0,7,,,"Simulating error correction of multiple commuting logical operators with stim and pymatching <p>I'm trying to simulate error correction with the <a href=""https://doi.org/10.1103/PRXQuantum.5.010342"" rel=""nofollow noreferrer"">Floquet Color Code</a>. On the torus, this code has two logical qubits. For efficiency, I'm want to simulate two commuting logical operators at the same time - a product of Pauli Xs along the x direction of the torus and along the y direction. <strong>However, I find that the logical error rate for the x direction is different when I simulate the y logical at the same time compared to when I simulate the x logical alone.</strong></p>
<p>The two stim files are available <a href=""https://www.dropbox.com/scl/fo/9a3871a3a11x1cg4u9exn/AMCcS-9h8bGiamOpd3D5UZo?rlkey=fqlbincp3b3s3karm8o70rno2&amp;st=z95ul3qj&amp;dl=0"" rel=""nofollow noreferrer"">here</a> - note they are identical up to the logical measurement of the y operator at the end and OBSERVABLE_INCLUDE instructions for y. This is the code I'm using to determine the logical error rates:</p>
<pre><code>import stim
import pymatching
import numpy as np

filename = 'x_y_logical.stim' # or 'x_logical.stim'
circ = stim.Circuit.from_file(filename)
shots = 1000000

model = circ.detector_error_model(decompose_errors=True)
matching = pymatching.Matching.from_detector_error_model(model)
sampler = circ.compile_detector_sampler()
syndrome, actual_observables = sampler.sample(shots=shots, separate_observables=True)

predicted_observables = matching.decode_batch(syndrome)
num_errors = np.sum(predicted_observables != actual_observables, axis=0)

log_err_rate = num_errors / shots
print(&quot;logical error_rate&quot;, log_err_rate)
</code></pre>
<p>When run on x_y together the result is approximately [0.189516 0.207379], and for x alone it is [0.197398].</p>
",qc,simulating error correction multiple commuting logical operators stim pymatching p trying simulate error correction https nofollow noreferrer floquet color code torus code two logical qubits efficiency want simulate two commuting logical operators time product pauli xs along x direction torus along direction strong however find logical error rate x direction different simulate logical time compared simulate x logical p two stim files available https amp amp nofollow noreferrer note identical logical measurement operator end instructions code using determine logical error rates pre code import stim import pymatching import numpy np filename circ filename shots 1000000 model matching model sampler syndrome syndrome shots print quot logical quot p run together result approximately x alone,"[(0, 0.101540044), (4, 0.063160434), (5, 0.40545848), (10, 0.033991084), (14, 0.08568423), (15, 0.024841022), (17, 0.22725414), (19, 0.04778166)]"
39626,39627.0,2024-08-20 19:13:36,1,171,"<p>I want to get the operator-sum representation of the two-qubit depolarizing channel
<span class=""math-container"">$$ \mathcal{E}(\rho) = (1-\lambda)\rho + \frac{\lambda I}{4}$$</span>
Using <span class=""math-container"">$\frac{I}{2} = \frac{\rho +X\rho X +Y\rho Y +Z\rho Z}{4}$</span> and <span class=""math-container"">$\frac{I}{4}=\frac{I}{2}\otimes \frac{I}{2}$</span>, I can get
<span class=""math-container"">$$\frac{I}{4} = \frac{(\rho +X\rho X +Y\rho Y +Z\rho Z)\otimes(\rho +X\rho X +Y\rho Y +Z\rho Z)}{16} $$</span>
Then I get terms like <span class=""math-container"">$(X\rho X) \otimes (X\rho X)$</span> and so on but for the operator sum representation, I need terms like <span class=""math-container"">$(X\otimes X)\rho (X\otimes X)$</span> and so on. But I don't understand how to go from <span class=""math-container"">$(X\rho X) \otimes (X\rho X)$</span> to <span class=""math-container"">$(X\otimes X)\rho (X\otimes X)$</span>. Is there some property of the tensor product I need to use here?</p>
<p>Edit: I am following this <a href=""https://quantumcomputing.stackexchange.com/a/28031/16345"">https://quantumcomputing.stackexchange.com/a/28031/16345</a></p>
",What is the operator-sum representation of the two-qubit depolarizing channel?,<textbook-and-exercises><quantum-operation><kraus-representation><depolarizing-channel>,1,2,,,"What is the operator-sum representation of the two-qubit depolarizing channel? <p>I want to get the operator-sum representation of the two-qubit depolarizing channel
<span class=""math-container"">$$ \mathcal{E}(\rho) = (1-\lambda)\rho + \frac{\lambda I}{4}$$</span>
Using <span class=""math-container"">$\frac{I}{2} = \frac{\rho +X\rho X +Y\rho Y +Z\rho Z}{4}$</span> and <span class=""math-container"">$\frac{I}{4}=\frac{I}{2}\otimes \frac{I}{2}$</span>, I can get
<span class=""math-container"">$$\frac{I}{4} = \frac{(\rho +X\rho X +Y\rho Y +Z\rho Z)\otimes(\rho +X\rho X +Y\rho Y +Z\rho Z)}{16} $$</span>
Then I get terms like <span class=""math-container"">$(X\rho X) \otimes (X\rho X)$</span> and so on but for the operator sum representation, I need terms like <span class=""math-container"">$(X\otimes X)\rho (X\otimes X)$</span> and so on. But I don't understand how to go from <span class=""math-container"">$(X\rho X) \otimes (X\rho X)$</span> to <span class=""math-container"">$(X\otimes X)\rho (X\otimes X)$</span>. Is there some property of the tensor product I need to use here?</p>
<p>Edit: I am following this <a href=""https://quantumcomputing.stackexchange.com/a/28031/16345"">https://quantumcomputing.stackexchange.com/a/28031/16345</a></p>
",qc,representation depolarizing channel p want get representation depolarizing channel span e 4 using span 2 x z 4 span 4 2 2 get span 4 x z x z 16 get terms like span x x operator sum representation need terms like span x x understand go span x x span x x property tensor product need use p edit following https https,"[(3, 0.6189769), (4, 0.0583248), (6, 0.09693117), (10, 0.20030057), (17, 0.023092978)]"
39628,39629.0,2024-08-21 02:09:28,1,81,"<p>I have been under the impression that fault-tolerant universal quantum computation with nonvanishing thresholds requires at least two-dimensional connectivity of gates, not merely one-dimensional connectivity. However, this <a href=""https://arxiv.org/pdf/quant-ph/9903099"" rel=""nofollow noreferrer"">1999 paper</a> by Gottesman seems to challenge my belief.</p>
<p>Am I interpreting this correctly? If I lay out qubits on a line and I'm only allowed to perform faulty nearest-neighbor and next-nearest gates and local measurements of ancillas, can I perform universal quantum computation fault-tolerantly with a nonvanishing threshold?</p>
<hr />
<p>I am still trying to understand the details of the construction.</p>
<p>In particular, I believe Gottesman argues that repeatedly concatenating a quantum error correcting code can nevertheless be done through local measurements of ancillas, many SWAP gates, and nearest-neighbor and next-nearest-neighbor gates along a line. To my understanding, the number of qubits are exponentially growing with the number of levels of concatenation, causing exponentially growing time delays when slowly shuffling qubits to measure stabilizer at a given level of concatenation. However, despite this, the recursive formulas for error rate at a given level of concatenation still give rise to a threshold.</p>
",Can fault tolerant computation be performed in $1$d with strictly local gates?,<error-correction><fault-tolerance>,1,0,,,"Can fault tolerant computation be performed in $1$d with strictly local gates? <p>I have been under the impression that fault-tolerant universal quantum computation with nonvanishing thresholds requires at least two-dimensional connectivity of gates, not merely one-dimensional connectivity. However, this <a href=""https://arxiv.org/pdf/quant-ph/9903099"" rel=""nofollow noreferrer"">1999 paper</a> by Gottesman seems to challenge my belief.</p>
<p>Am I interpreting this correctly? If I lay out qubits on a line and I'm only allowed to perform faulty nearest-neighbor and next-nearest gates and local measurements of ancillas, can I perform universal quantum computation fault-tolerantly with a nonvanishing threshold?</p>
<hr />
<p>I am still trying to understand the details of the construction.</p>
<p>In particular, I believe Gottesman argues that repeatedly concatenating a quantum error correcting code can nevertheless be done through local measurements of ancillas, many SWAP gates, and nearest-neighbor and next-nearest-neighbor gates along a line. To my understanding, the number of qubits are exponentially growing with the number of levels of concatenation, causing exponentially growing time delays when slowly shuffling qubits to measure stabilizer at a given level of concatenation. However, despite this, the recursive formulas for error rate at a given level of concatenation still give rise to a threshold.</p>
",qc,fault tolerant computation performed 1 strictly local gates p impression universal quantum computation nonvanishing thresholds requires least connectivity gates merely connectivity however https nofollow noreferrer 1999 paper gottesman seems challenge p interpreting correctly lay qubits line allowed perform faulty gates local measurements ancillas perform universal quantum computation nonvanishing threshold hr p still trying understand details p particular believe gottesman argues repeatedly concatenating quantum error correcting code nevertheless done local measurements ancillas many swap gates gates along line understanding number qubits exponentially growing number levels concatenation causing exponentially growing time delays slowly shuffling qubits measure stabilizer given level concatenation however despite recursive formulas error rate given level concatenation still give rise,"[(1, 0.052644532), (5, 0.29037282), (7, 0.054886993), (8, 0.04102436), (9, 0.409089), (11, 0.027577287), (17, 0.12322223)]"
39706,,2024-08-29 13:18:18,2,78,"<p>I am interested in the evolution of a subsystem Y entangled with another subsystem X.</p>
<p>X and Y are initially in a pure product state. They undergo some global joint evolution E (not necessarily unitary), after which they are entangled with each other. Then, some projective measurement M (which is left completely unspecified in my problem) is applied on X.</p>
<p>I would need to know if the overall evolution of Y, following the joint evolution E and the projective measurement M on X, is necessarily non-unitary. (Could the answer depend on whether the projective measurement is read or left unread?)</p>
","When performing a projective measurement on a subsystem X entangled with another system Y, can the evolution of Y be unitary?",<entanglement><measurement><quantum-operation><unitary>,1,0,,,"When performing a projective measurement on a subsystem X entangled with another system Y, can the evolution of Y be unitary? <p>I am interested in the evolution of a subsystem Y entangled with another subsystem X.</p>
<p>X and Y are initially in a pure product state. They undergo some global joint evolution E (not necessarily unitary), after which they are entangled with each other. Then, some projective measurement M (which is left completely unspecified in my problem) is applied on X.</p>
<p>I would need to know if the overall evolution of Y, following the joint evolution E and the projective measurement M on X, is necessarily non-unitary. (Could the answer depend on whether the projective measurement is read or left unread?)</p>
",qc,performing projective measurement subsystem x entangled another system evolution unitary p interested evolution subsystem entangled another subsystem p x initially pure product state undergo global joint evolution e necessarily unitary entangled projective measurement left completely unspecified problem applied p would need know overall evolution following joint evolution e projective measurement x necessarily could answer depend whether projective measurement read left unread,"[(1, 0.14578691), (3, 0.468848), (10, 0.106392436), (17, 0.026725333), (18, 0.24978682)]"
39709,,2024-08-29 17:10:11,3,56,"<p>Consider a fixed qubit channel <span class=""math-container"">$\mathcal{N}$</span> and some QECC that prepares a logical state <span class=""math-container"">$|\psi_L\rangle$</span> of <span class=""math-container"">$k$</span> logical qubits using <span class=""math-container"">$n$</span> physical qubits. After transmitting data through the channels, the probability of correctly decoding (and thus recovering <span class=""math-container"">$|\psi_L\rangle$</span> at the output of the decoder) is <span class=""math-container"">$p_{err}$</span> - assume operations are implemented perfectly.</p>
<p>Assume that I have some kind of scalable QECC scheme, so that I can express <span class=""math-container"">$p_{err}$</span> as a funtion of <span class=""math-container"">$n$</span> and <span class=""math-container"">$k$</span>.</p>
<p>My question is, what does the tuple <span class=""math-container"">$(n, \frac{k}{n}, p_{err})$</span> tell us about any sort of capacity of the channel <span class=""math-container"">$\mathcal{N}$</span>?</p>
<hr />
<p>My thoughts so far:</p>
<ol>
<li>This setup implies <span class=""math-container"">$\frac{1}{2} \lVert \psi_L - \mathcal{D} \circ \mathcal{N}^{\otimes n} \circ \mathcal{E}(\psi_L)\rVert_1 \leq p_{err}$</span>, so the tuple does describe a code with rate <span class=""math-container"">$Q=k/n$</span> and error <span class=""math-container"">$\epsilon=p_{err}$</span> (using definitions/notation from Wilde's textbook)</li>
<li>But this doesn't seem to actually tell us about the quantum capacity of the channel, since we have no way of taking the error to zero in general</li>
<li>The closest I got was using some ideas from (<a href=""https://arxiv.org/abs/1504.04617"" rel=""nofollow noreferrer"">Tomamichel et al, 2015</a>), that <span class=""math-container"">$(n, k/n, p_{err})$</span> gives a lower bound for the boundary of an achievable region of rates <span class=""math-container"">$\hat{R}_\mathcal{N}(n, p_{err}) := \max \{R: (n, R, p_{err})\text{ is achievable}\}$</span> (where &quot;achievable&quot; just means that tuple describes a code).</li>
</ol>
<p>I would like to know if (3) is the strongest statement we can make about <span class=""math-container"">$\mathcal{N}$</span> in this scenario, or if there are other capacities that I missed that are bounded once we achieve this tuple.</p>
",The relationship between QEC decoding error and capacity,<error-correction><communication><channel-capacity>,0,2,,,"The relationship between QEC decoding error and capacity <p>Consider a fixed qubit channel <span class=""math-container"">$\mathcal{N}$</span> and some QECC that prepares a logical state <span class=""math-container"">$|\psi_L\rangle$</span> of <span class=""math-container"">$k$</span> logical qubits using <span class=""math-container"">$n$</span> physical qubits. After transmitting data through the channels, the probability of correctly decoding (and thus recovering <span class=""math-container"">$|\psi_L\rangle$</span> at the output of the decoder) is <span class=""math-container"">$p_{err}$</span> - assume operations are implemented perfectly.</p>
<p>Assume that I have some kind of scalable QECC scheme, so that I can express <span class=""math-container"">$p_{err}$</span> as a funtion of <span class=""math-container"">$n$</span> and <span class=""math-container"">$k$</span>.</p>
<p>My question is, what does the tuple <span class=""math-container"">$(n, \frac{k}{n}, p_{err})$</span> tell us about any sort of capacity of the channel <span class=""math-container"">$\mathcal{N}$</span>?</p>
<hr />
<p>My thoughts so far:</p>
<ol>
<li>This setup implies <span class=""math-container"">$\frac{1}{2} \lVert \psi_L - \mathcal{D} \circ \mathcal{N}^{\otimes n} \circ \mathcal{E}(\psi_L)\rVert_1 \leq p_{err}$</span>, so the tuple does describe a code with rate <span class=""math-container"">$Q=k/n$</span> and error <span class=""math-container"">$\epsilon=p_{err}$</span> (using definitions/notation from Wilde's textbook)</li>
<li>But this doesn't seem to actually tell us about the quantum capacity of the channel, since we have no way of taking the error to zero in general</li>
<li>The closest I got was using some ideas from (<a href=""https://arxiv.org/abs/1504.04617"" rel=""nofollow noreferrer"">Tomamichel et al, 2015</a>), that <span class=""math-container"">$(n, k/n, p_{err})$</span> gives a lower bound for the boundary of an achievable region of rates <span class=""math-container"">$\hat{R}_\mathcal{N}(n, p_{err}) := \max \{R: (n, R, p_{err})\text{ is achievable}\}$</span> (where &quot;achievable&quot; just means that tuple describes a code).</li>
</ol>
<p>I would like to know if (3) is the strongest statement we can make about <span class=""math-container"">$\mathcal{N}$</span> in this scenario, or if there are other capacities that I missed that are bounded once we achieve this tuple.</p>
",qc,relationship qec decoding error capacity p consider fixed qubit channel span n qecc prepares logical state span span k logical qubits using span n physical qubits transmitting data channels probability correctly decoding thus recovering span output decoder span err assume operations implemented p assume kind scalable qecc scheme express span err funtion span n span k p question tuple span n k n err tell us sort capacity channel span n hr p thoughts far ol li setup implies span 1 2 n n e err tuple describe code rate span error span err using wilde textbook li seem actually tell us quantum capacity channel since way taking error zero general li closest got using ideas https nofollow noreferrer tomamichel et al 2015 span n err gives lower bound boundary achievable region rates span r n n err r n r err achievable quot achievable quot means tuple describes code p would like know 3 strongest statement make span n scenario capacities missed bounded achieve,"[(3, 0.5455811), (5, 0.14990039), (9, 0.18329561), (10, 0.0711514), (17, 0.016850647), (19, 0.032362286)]"
39714,39719.0,2024-08-30 20:40:41,3,55,"<p>From this <a href=""https://errorcorrectionzoo.org/c/quantum_divisible#citation-4"" rel=""nofollow noreferrer"">site</a> and this <a href=""https://quantumcomputing.stackexchange.com/questions/26701/example-css-codes-and-the-properties-doubly-even-and-self-dual"">post</a>, doubly even codes have transversal <span class=""math-container"">$S$</span>.</p>
<p>Based on <a href=""https://arthurpesah.me/blog/2023-12-25-transversal-gates/"" rel=""nofollow noreferrer"">this post</a>, surface codes don't have transversal <span class=""math-container"">$S$</span> gates. We can check the boundary stabilizers of surface codes are not doubly even, so surface codes are generally not doubly even and don't have transversal <span class=""math-container"">$S$</span>.</p>
<p><strong>However, what if we go to the toric codes which seems to be doubly even? What's the logical effect of transversal <span class=""math-container"">$S$</span> gates?</strong></p>
","Are toric codes (surface codes) doubly even, therefore have transversal $S$?",<surface-code><logical-gates><toric-code>,1,0,,,"Are toric codes (surface codes) doubly even, therefore have transversal $S$? <p>From this <a href=""https://errorcorrectionzoo.org/c/quantum_divisible#citation-4"" rel=""nofollow noreferrer"">site</a> and this <a href=""https://quantumcomputing.stackexchange.com/questions/26701/example-css-codes-and-the-properties-doubly-even-and-self-dual"">post</a>, doubly even codes have transversal <span class=""math-container"">$S$</span>.</p>
<p>Based on <a href=""https://arthurpesah.me/blog/2023-12-25-transversal-gates/"" rel=""nofollow noreferrer"">this post</a>, surface codes don't have transversal <span class=""math-container"">$S$</span> gates. We can check the boundary stabilizers of surface codes are not doubly even, so surface codes are generally not doubly even and don't have transversal <span class=""math-container"">$S$</span>.</p>
<p><strong>However, what if we go to the toric codes which seems to be doubly even? What's the logical effect of transversal <span class=""math-container"">$S$</span> gates?</strong></p>
",qc,toric codes surface codes doubly even therefore transversal p https nofollow noreferrer site https post doubly even codes transversal span p based https nofollow noreferrer post surface codes transversal span gates check boundary stabilizers surface codes doubly even surface codes generally doubly even transversal span p strong however go toric codes seems doubly even logical effect transversal span gates,"[(3, 0.05260792), (4, 0.048179984), (5, 0.48673615), (9, 0.3526185), (17, 0.057322785)]"
39722,39723.0,2024-09-01 22:13:39,2,198,"<p>Given two arbitrary states, <span class=""math-container"">$|\psi\rangle\ \text{and}\ |\phi\rangle$</span> that are possibly unknown to the preparer, is there a way to prepare the superposition <span class=""math-container"">$|\psi\rangle+|\phi\rangle$</span> of them? (If it's generally impossible, would demanding orthogonality between them help?)</p>
",How to prepare a superposed state?,<quantum-state><quantum-algorithms><quantum-circuit><state-preparation>,1,3,,,"How to prepare a superposed state? <p>Given two arbitrary states, <span class=""math-container"">$|\psi\rangle\ \text{and}\ |\phi\rangle$</span> that are possibly unknown to the preparer, is there a way to prepare the superposition <span class=""math-container"">$|\psi\rangle+|\phi\rangle$</span> of them? (If it's generally impossible, would demanding orthogonality between them help?)</p>
",qc,prepare superposed state p given two arbitrary states span possibly unknown preparer way prepare superposition span generally impossible would demanding orthogonality help,"[(13, 0.09925586), (17, 0.13546775), (18, 0.7576032)]"
39727,,2024-09-03 06:31:17,2,65,"<p>I am currently understanding on the proof of Area Law in paper &quot;Rigorous RG algorithms and area laws for low energy eigenstates in 1D&quot; (<a href=""https://arxiv.org/abs/1602.08828"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1602.08828</a>). In terms of the AGSP constrution, we are required to do the truncation on some subregions containing O(n) qubits. In Corollary 4.6, the paper claim that the norm of the truncated hamiltonian has norm <span class=""math-container"">$O(\ell + t)$</span>, which would be a constant in the latter part of the paper by setting <span class=""math-container"">$\ell, t$</span> be a constant. But I am confused why the norm would not be <span class=""math-container"">$O(\ell + t + \epsilon_{J_L} + \epsilon_{J_M} + \epsilon_{J_R})$</span>, in which case the norm would not be <span class=""math-container"">$O(1)$</span> by setting <span class=""math-container"">$\ell, t$</span> constant.</p>
",Truncation techniques in the proof of Area Law,<entanglement><hamiltonian>,0,3,,,"Truncation techniques in the proof of Area Law <p>I am currently understanding on the proof of Area Law in paper &quot;Rigorous RG algorithms and area laws for low energy eigenstates in 1D&quot; (<a href=""https://arxiv.org/abs/1602.08828"" rel=""nofollow noreferrer"">https://arxiv.org/abs/1602.08828</a>). In terms of the AGSP constrution, we are required to do the truncation on some subregions containing O(n) qubits. In Corollary 4.6, the paper claim that the norm of the truncated hamiltonian has norm <span class=""math-container"">$O(\ell + t)$</span>, which would be a constant in the latter part of the paper by setting <span class=""math-container"">$\ell, t$</span> be a constant. But I am confused why the norm would not be <span class=""math-container"">$O(\ell + t + \epsilon_{J_L} + \epsilon_{J_M} + \epsilon_{J_R})$</span>, in which case the norm would not be <span class=""math-container"">$O(1)$</span> by setting <span class=""math-container"">$\ell, t$</span> constant.</p>
",qc,truncation techniques proof area law p currently understanding proof area law paper quot rigorous rg algorithms area laws low energy eigenstates 1d quot https nofollow noreferrer https terms agsp constrution required truncation subregions containing n qubits corollary paper claim norm truncated hamiltonian norm span would constant latter part paper setting span constant confused norm would span case norm would span 1 setting span,"[(1, 0.037083), (3, 0.38336596), (8, 0.052795053), (9, 0.40003133), (15, 0.038587518), (17, 0.02957428), (18, 0.023350421), (19, 0.033178944)]"
39751,,2024-09-05 20:40:59,1,69,"<p>I am going over <a href=""https://doi.org/10.1145/3528416.3530237"" rel=""nofollow noreferrer"">this paper</a> by Lao, and I am trying to understand how they count the two-qubit errors that induce logical errors.</p>
<p>I am looking at the middle-type injection, which looks like this:</p>
<p><a href=""https://i.sstatic.net/HlIa6HTOm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HlIa6HTOm.png"" alt=""injection patch"" /></a> <a href=""https://i.sstatic.net/ED3NV5LZm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ED3NV5LZm.png"" alt=""injection circuit"" /></a></p>
<p>Now, they count which two-qubit errors change the logical operators. I understand I can do it by one of two methods:</p>
<ol>
<li>The first is by propagating each possible error to the beginning of the circuit and checking whether it changes the value of the logical operators at that point. For example, <span class=""math-container"">$\color{blue}{X_c X_t}$</span> error on the blue CNOT will propagate to be an <span class=""math-container"">$X_5$</span> error, which changes the injected qubit state.</li>
<li>The second is propagating the error to the end of the circuit and checking whether it will be detected on the next cycle. Here, the <span class=""math-container"">$\color{blue}{X_c X_t}$</span> error will propagate to flip both <span class=""math-container"">$Z_2$</span> and <span class=""math-container"">$Z_3$</span> stabilizers and also <span class=""math-container"">$X$</span> error on D5. This will not be corrected on the next circuit because no stabilizers will be flipped.</li>
</ol>
<p>I tried to do it for some errors and failed to understand, for example, the error <span class=""math-container"">$\color{red} {I_c Z_t}$</span> on the red gate which they do not count as an undetectable logical error:</p>
<ul>
<li>when propagated to the start it becomes <span class=""math-container"">$Z$</span> error on D5 and flips stabilizer X1. Why is this not changing the value of the logical operator? Or maybe it is detected and discarded? If so, how is it detected, considering X1 is not deterministic?</li>
<li>when propagated to the end, it becomes <span class=""math-container"">$Z$</span> error on D5, and flips X4. Since X4 is not deterministic and it is the first time we measure it, how can we detect it?</li>
</ul>
<p>Is there a way to think about it that does not demand going over all the possible two-qubit errors? Is there a way to see why all the black CNOT won't create any logical error without going over all of their errors one by one?</p>
",Understanding errors in rotated surface code magic state injection,<error-correction><state-injection-model>,0,0,,,"Understanding errors in rotated surface code magic state injection <p>I am going over <a href=""https://doi.org/10.1145/3528416.3530237"" rel=""nofollow noreferrer"">this paper</a> by Lao, and I am trying to understand how they count the two-qubit errors that induce logical errors.</p>
<p>I am looking at the middle-type injection, which looks like this:</p>
<p><a href=""https://i.sstatic.net/HlIa6HTOm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/HlIa6HTOm.png"" alt=""injection patch"" /></a> <a href=""https://i.sstatic.net/ED3NV5LZm.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/ED3NV5LZm.png"" alt=""injection circuit"" /></a></p>
<p>Now, they count which two-qubit errors change the logical operators. I understand I can do it by one of two methods:</p>
<ol>
<li>The first is by propagating each possible error to the beginning of the circuit and checking whether it changes the value of the logical operators at that point. For example, <span class=""math-container"">$\color{blue}{X_c X_t}$</span> error on the blue CNOT will propagate to be an <span class=""math-container"">$X_5$</span> error, which changes the injected qubit state.</li>
<li>The second is propagating the error to the end of the circuit and checking whether it will be detected on the next cycle. Here, the <span class=""math-container"">$\color{blue}{X_c X_t}$</span> error will propagate to flip both <span class=""math-container"">$Z_2$</span> and <span class=""math-container"">$Z_3$</span> stabilizers and also <span class=""math-container"">$X$</span> error on D5. This will not be corrected on the next circuit because no stabilizers will be flipped.</li>
</ol>
<p>I tried to do it for some errors and failed to understand, for example, the error <span class=""math-container"">$\color{red} {I_c Z_t}$</span> on the red gate which they do not count as an undetectable logical error:</p>
<ul>
<li>when propagated to the start it becomes <span class=""math-container"">$Z$</span> error on D5 and flips stabilizer X1. Why is this not changing the value of the logical operator? Or maybe it is detected and discarded? If so, how is it detected, considering X1 is not deterministic?</li>
<li>when propagated to the end, it becomes <span class=""math-container"">$Z$</span> error on D5, and flips X4. Since X4 is not deterministic and it is the first time we measure it, how can we detect it?</li>
</ul>
<p>Is there a way to think about it that does not demand going over all the possible two-qubit errors? Is there a way to see why all the black CNOT won't create any logical error without going over all of their errors one by one?</p>
",qc,understanding errors rotated surface code magic state injection p going https nofollow noreferrer paper lao trying understand count errors induce logical p looking injection looks like p https nofollow noreferrer img https injection patch https nofollow noreferrer img https injection circuit p count errors change logical operators understand one two methods ol li first propagating possible error beginning circuit checking whether changes value logical operators point example span blue error blue cnot propagate span error changes injected qubit li second propagating error end circuit checking whether detected next cycle span blue error propagate flip span span stabilizers also span x error d5 corrected next circuit stabilizers p tried errors failed understand example error span red red gate count undetectable logical error ul li propagated start becomes span z error d5 flips stabilizer x1 changing value logical operator maybe detected discarded detected considering x1 deterministic li propagated end becomes span z error d5 flips x4 since x4 deterministic first time measure detect p way think demand going possible errors way see black cnot wo create logical error without going errors one one,"[(3, 0.065420695), (4, 0.2172198), (5, 0.5385422), (6, 0.016243704), (17, 0.051342614), (18, 0.110453434)]"
39771,39772.0,2024-09-08 18:55:07,3,333,"<p>When working with <span class=""math-container"">$n$</span>-qubit systems, we can use the Kronecker product <span class=""math-container"">$\otimes$</span> to build corresponding bigger Hilbert spaces. For example:</p>
<p><span class=""math-container"">$$\begin{bmatrix} \alpha \\ \beta \end{bmatrix} \otimes  \begin{bmatrix} \gamma \\ \delta \end{bmatrix} = \begin{bmatrix} \alpha\gamma  \\ \alpha \delta  \\ \beta\gamma \\ \beta \delta  \end{bmatrix},$$</span></p>
<p>and we can keep building up from that. However, I was wondering if it is possible to write <span class=""math-container"">$\begin{bmatrix} \alpha \\ \beta \end{bmatrix}$</span> as a Kronecker product itself? Intuitively I'd write something like <span class=""math-container"">$\begin{bmatrix} \alpha \end{bmatrix} \otimes  \begin{bmatrix} \beta \end{bmatrix}$</span>, although if I use the formal <a href=""https://en.wikipedia.org/wiki/Kronecker_product"" rel=""nofollow noreferrer"">definition</a> then the result would be <span class=""math-container"">$\begin{bmatrix} \alpha \beta \end{bmatrix}$</span>, which is still a <span class=""math-container"">$1\times1$</span> matrix and not what I expect. I can hand-wavily say that when when I'm building a bigger Hilbert space out of <span class=""math-container"">$\begin{bmatrix} \alpha \end{bmatrix}$</span> and <span class=""math-container"">$\begin{bmatrix} \beta \end{bmatrix}$</span>, they each need to go on a different dimension because each one lives on its own Hilbert space, but how do I justify that mathematically?</p>
",What is the Kronecker product of two 1D vectors?,<linear-algebra><hilbert-space>,2,1,,,"What is the Kronecker product of two 1D vectors? <p>When working with <span class=""math-container"">$n$</span>-qubit systems, we can use the Kronecker product <span class=""math-container"">$\otimes$</span> to build corresponding bigger Hilbert spaces. For example:</p>
<p><span class=""math-container"">$$\begin{bmatrix} \alpha \\ \beta \end{bmatrix} \otimes  \begin{bmatrix} \gamma \\ \delta \end{bmatrix} = \begin{bmatrix} \alpha\gamma  \\ \alpha \delta  \\ \beta\gamma \\ \beta \delta  \end{bmatrix},$$</span></p>
<p>and we can keep building up from that. However, I was wondering if it is possible to write <span class=""math-container"">$\begin{bmatrix} \alpha \\ \beta \end{bmatrix}$</span> as a Kronecker product itself? Intuitively I'd write something like <span class=""math-container"">$\begin{bmatrix} \alpha \end{bmatrix} \otimes  \begin{bmatrix} \beta \end{bmatrix}$</span>, although if I use the formal <a href=""https://en.wikipedia.org/wiki/Kronecker_product"" rel=""nofollow noreferrer"">definition</a> then the result would be <span class=""math-container"">$\begin{bmatrix} \alpha \beta \end{bmatrix}$</span>, which is still a <span class=""math-container"">$1\times1$</span> matrix and not what I expect. I can hand-wavily say that when when I'm building a bigger Hilbert space out of <span class=""math-container"">$\begin{bmatrix} \alpha \end{bmatrix}$</span> and <span class=""math-container"">$\begin{bmatrix} \beta \end{bmatrix}$</span>, they each need to go on a different dimension because each one lives on its own Hilbert space, but how do I justify that mathematically?</p>
",qc,kronecker product two 1d vectors p working span n systems use kronecker product span build corresponding bigger hilbert spaces example p span bmatrix bmatrix bmatrix bmatrix bmatrix bmatrix p keep building however wondering possible write span bmatrix bmatrix kronecker product intuitively write something like span bmatrix bmatrix bmatrix bmatrix although use formal https nofollow noreferrer definition result would span bmatrix bmatrix still span matrix expect say building bigger hilbert space span bmatrix bmatrix span bmatrix bmatrix need go different dimension one lives hilbert space justify mathematically,"[(3, 0.44780943), (4, 0.045617096), (8, 0.1686976), (10, 0.014099399), (15, 0.2974218), (17, 0.024729583)]"
39793,39798.0,2024-09-10 23:33:21,0,94,"<p>Suppose there are three quantum registers and one classical register.</p>
<ol>
<li>Operand A: 3-qubit</li>
<li>Operand B: 3-qubit</li>
<li>Results C: 6-qubit</li>
<li>Results D: 6-bit</li>
</ol>
<p>The operand A is deterministic (user input), and the operand B is bruteforcer, while the result C is output buffer.</p>
<p>Since A is user input, the bit initializer is just using NOT gate depends on user preference.</p>
<p>In another hand, B is bruteforcer which the bit initializer is Hadamard gate that setted up for all qubits (3-qubit).</p>
<p>Suppose there is blackbox oracle (operator) that receive both operands as inputs and returning 6-qubit.</p>
<p>How do I get the highest probability of minimum binary value from such 6-qubit output that will be stored in 6-bit classical register (through measurement)?</p>
<p>We know that, minimum binary value of 6-qubit is <code>|000000&gt;</code>, but is it the highest probability?</p>
",Get Minimum Binary Value from Arbitrary Blackbox Oracle Result,<quantum-algorithms>,1,1,,,"Get Minimum Binary Value from Arbitrary Blackbox Oracle Result <p>Suppose there are three quantum registers and one classical register.</p>
<ol>
<li>Operand A: 3-qubit</li>
<li>Operand B: 3-qubit</li>
<li>Results C: 6-qubit</li>
<li>Results D: 6-bit</li>
</ol>
<p>The operand A is deterministic (user input), and the operand B is bruteforcer, while the result C is output buffer.</p>
<p>Since A is user input, the bit initializer is just using NOT gate depends on user preference.</p>
<p>In another hand, B is bruteforcer which the bit initializer is Hadamard gate that setted up for all qubits (3-qubit).</p>
<p>Suppose there is blackbox oracle (operator) that receive both operands as inputs and returning 6-qubit.</p>
<p>How do I get the highest probability of minimum binary value from such 6-qubit output that will be stored in 6-bit classical register (through measurement)?</p>
<p>We know that, minimum binary value of 6-qubit is <code>|000000&gt;</code>, but is it the highest probability?</p>
",qc,get minimum binary value arbitrary blackbox oracle result p suppose three quantum registers one classical ol li operand li operand b li results c li results p operand deterministic user input operand b bruteforcer result c output p since user input bit initializer using gate depends user p another hand b bruteforcer bit initializer hadamard gate setted qubits p suppose blackbox oracle operator receive operands inputs returning p get highest probability minimum binary value output stored classical register measurement p know minimum binary value code gt highest probability,"[(7, 0.18825838), (10, 0.068303466), (14, 0.3926311), (17, 0.044225175), (18, 0.30485904)]"
39887,,2024-09-18 09:47:29,1,43,"<p>In stim:</p>
<ol>
<li>Can I select a different error channel based on the measurement results of heralded erasure errors?</li>
</ol>
<p>For example:</p>
<pre><code>R 0 1

HERALDED_PAULI_CHANNEL_1(0.1, 0, 0, 0) 0

if rec[-1] == 1:
#error channel 1
PAULI_CHANNEL_2(pix1, piy1, piz1, pxi1, pxx1, pxy1, pxz1, pyi1, pyx1, pyy1, pyz1, pzi1, pzx1, pzy1, pzz1) 0 1

elif rec[-1] == 0:
#error channel 2
PAULI_CHANNEL_2(pix2, piy2, piz2, pxi2, pxx2, pxy2, pxz2, pyi2, pyx2, pyy2, pyz2, pzi2, pzx2, pzy2, pzz2) 0 1
</code></pre>
<ol start=""2"">
<li>How can I reformulate the weight of error mechanism(the probability of the error) in <code>circuit.detector_error_model()</code> based on the measurement results from a single sampler?</li>
</ol>
<p>Referring to the previously mentioned example, if the measurement results of heralded erasure error are confirmed as true, I will revise the probability of all error mechanisms about error channel 1 to be 0.5; if they are false, no revision will take place.</p>
<p>If I am able to accomplish that, how can I achieve the same in Sinter?</p>
",Select different error channel and reformulate the weight of error mechanism based on the measurement results,<stim>,1,0,,,"Select different error channel and reformulate the weight of error mechanism based on the measurement results <p>In stim:</p>
<ol>
<li>Can I select a different error channel based on the measurement results of heralded erasure errors?</li>
</ol>
<p>For example:</p>
<pre><code>R 0 1

HERALDED_PAULI_CHANNEL_1(0.1, 0, 0, 0) 0

if rec[-1] == 1:
#error channel 1
PAULI_CHANNEL_2(pix1, piy1, piz1, pxi1, pxx1, pxy1, pxz1, pyi1, pyx1, pyy1, pyz1, pzi1, pzx1, pzy1, pzz1) 0 1

elif rec[-1] == 0:
#error channel 2
PAULI_CHANNEL_2(pix2, piy2, piz2, pxi2, pxx2, pxy2, pxz2, pyi2, pyx2, pyy2, pyz2, pzi2, pzx2, pzy2, pzz2) 0 1
</code></pre>
<ol start=""2"">
<li>How can I reformulate the weight of error mechanism(the probability of the error) in <code>circuit.detector_error_model()</code> based on the measurement results from a single sampler?</li>
</ol>
<p>Referring to the previously mentioned example, if the measurement results of heralded erasure error are confirmed as true, I will revise the probability of all error mechanisms about error channel 1 to be 0.5; if they are false, no revision will take place.</p>
<p>If I am able to accomplish that, how can I achieve the same in Sinter?</p>
",qc,select different error channel reformulate weight error mechanism based measurement results p stim ol li select different error channel based measurement results heralded erasure errors p example pre code r 0 1 0 0 0 0 rec 1 error channel 1 pix1 piy1 piz1 pxi1 pxx1 pxy1 pxz1 pyi1 pyx1 pyy1 pyz1 pzi1 pzx1 pzy1 pzz1 0 1 elif rec 0 error channel 2 pix2 piy2 piz2 pxi2 pxx2 pxy2 pxz2 pyi2 pyx2 pyy2 pyz2 pzi2 pzx2 pzy2 pzz2 0 1 ol 2 li reformulate weight error mechanism probability error code based measurement results single sampler p referring previously mentioned example measurement results heralded erasure error confirmed true revise probability error mechanisms error channel 1 false revision take p able accomplish achieve sinter,"[(0, 0.032788083), (2, 0.17340878), (3, 0.15772611), (5, 0.4051872), (6, 0.04990789), (14, 0.08048069), (17, 0.07982387), (19, 0.01936973)]"
39928,39956.0,2024-09-21 14:59:53,1,65,"<p>According to help from Microsoft Learn, the binding of <code>Qubit[]</code> array to its equivalent ket vector representation is such that the qubit with index 0 becomes the rightmost qubit in the ket vector representation. So we expect that the output of the following Q# program be <span class=""math-container"">$|001\rangle$</span>, but this is not the case.</p>
<pre><code>namespace Quantum.Demo {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Measurement;

    @EntryPoint()
    operation CreateStateVector001() : Unit {
        use qba = Qubit[3];

        // initializing qubits
        Reset(qba[2]);
        Reset(qba[1]);
        X(qba[0]);  // The LSB becomes a 1

        // Display the state of the qubits
        DumpMachine();

        // Reset all qubits before releasing them
        ResetAll(qba);
    }
}
</code></pre>
<p>Please help me understand why.</p>
",Probable bug in DumpMachine() Quantum API function of Microsoft Quantum Platform,<programming><q#><state-preparation>,1,0,,,"Probable bug in DumpMachine() Quantum API function of Microsoft Quantum Platform <p>According to help from Microsoft Learn, the binding of <code>Qubit[]</code> array to its equivalent ket vector representation is such that the qubit with index 0 becomes the rightmost qubit in the ket vector representation. So we expect that the output of the following Q# program be <span class=""math-container"">$|001\rangle$</span>, but this is not the case.</p>
<pre><code>namespace Quantum.Demo {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Measurement;

    @EntryPoint()
    operation CreateStateVector001() : Unit {
        use qba = Qubit[3];

        // initializing qubits
        Reset(qba[2]);
        Reset(qba[1]);
        X(qba[0]);  // The LSB becomes a 1

        // Display the state of the qubits
        DumpMachine();

        // Reset all qubits before releasing them
        ResetAll(qba);
    }
}
</code></pre>
<p>Please help me understand why.</p>
",qc,probable bug dumpmachine quantum api function microsoft quantum platform p according help microsoft learn binding code qubit array equivalent ket vector representation qubit index 0 becomes rightmost qubit ket vector representation expect output following q program span pre code namespace open open open entrypoint operation createstatevector001 unit use qba qubit 3 initializing qubits reset qba 2 reset qba 1 x qba 0 lsb becomes 1 display state qubits dumpmachine reset qubits releasing resetall qba p please help understand,"[(2, 0.08792783), (10, 0.03961663), (11, 0.052491836), (13, 0.1645463), (14, 0.29278588), (16, 0.03663302), (17, 0.23655736), (18, 0.087905146)]"
39936,39938.0,2024-09-22 11:23:42,2,138,"<p>I have:</p>
<ol>
<li>Two 8-qubit multiplication operands</li>
<li>One 8-qubit multiplication result</li>
<li>One 1-qubit aux</li>
</ol>
<p>I initialize all operands in superposition with Hadamard gate, then I marked expected result which is <code>180</code> or <code>1011 0100</code> in binary with <code>Multi-Controlled Z</code>. Then the last, <code>Diffuser</code> is performed for amplify expected result. And then <code>measure_all()</code> quantum register.</p>
<p><a href=""https://i.sstatic.net/0kumi14C.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0kumi14C.png"" alt=""enter image description here"" /></a></p>
<p>Filtering amplitude (shot) greater than 1, got following result:</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th>index</th>
<th>A</th>
<th>B</th>
<th>Result</th>
<th>Aux</th>
<th>Shots</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>6</td>
<td>43</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>33</td>
<td>9</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>7</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>98</td>
<td>7</td>
<td>13</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>51</td>
<td>7</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>34</td>
<td>13</td>
<td>8</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>107</td>
<td>4</td>
<td>14</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>13</td>
<td>244</td>
<td>4</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>8</td>
<td>108</td>
<td>49</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>15</td>
<td>184</td>
<td>14</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>10</td>
<td>72</td>
<td>67</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>10</td>
<td>3</td>
<td>11</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>12</td>
<td>75</td>
<td>72</td>
<td>8</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>13</td>
<td>72</td>
<td>98</td>
<td>10</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>14</td>
<td>11</td>
<td>58</td>
<td>7</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>15</td>
<td>38</td>
<td>54</td>
<td>8</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table></div>
<p>As you see, I didn't see expected result which is <code>180</code>. Even, multiplication result seems not reflect with its operands which are the factors except at <code>index 2</code> where <code>0*7=0</code>.</p>
<p>Here is the following code:</p>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister,
from qiskit.circuit.library import HRSCumulativeMultiplier,

# Define quantum registers
first_operand = QuantumRegister(n_bit, 'operand_a')
second_operand = QuantumRegister(n_bit, 'operand_b')
multiplication_result = QuantumRegister(n_bit, 'result')
aux = QuantumRegister(1, 'aux')

qc = QuantumCircuit(first_operand, second_operand, multiplication_result, aux)

# All Superposition
qc.h(first_operand)
qc.h(second_operand)
# qc.barrier()

expected_result = '10110100' # 180 in decimal
print(f'Expected: {expected_result}')

# Multiplier
multiplier = HRSCumulativeMultiplier(num_state_qubits=n_bit, num_result_qubits=n_bit)
qc.append(multiplier, qargs=list(first_operand) + list(second_operand) + list(multiplication_result) + list(aux))
qc.barrier()

for i, v in enumerate(expected_result[::-1]):
  if v == '0':
    qc.x(multiplication_result[i])
qc.barrier()

qc.h(multiplication_result[-1])
qc.mcx(multiplication_result[:-1], multiplication_result[-1])
qc.h(multiplication_result[-1])
qc.barrier()

for i, v in enumerate(expected_result[::-1]):
  if v == '0':
    qc.x(multiplication_result[i])
qc.barrier()

# Diffuser
qc.h(first_operand)
qc.h(second_operand)
qc.h(multiplication_result)
qc.h(aux)
# qc.barrier()
qc.x(first_operand)
qc.x(second_operand)
qc.x(multiplication_result)
qc.x(aux)
qc.barrier()
qc.h(aux)
qc.mcx(list(range(n_bit*3)), aux)
qc.h(aux)
qc.barrier()
qc.x(first_operand)
qc.x(second_operand)
qc.x(multiplication_result)
qc.x(aux)
# qc.barrier()
qc.h(first_operand)
qc.h(second_operand)
qc.h(multiplication_result)
qc.h(aux)

qc.measure_all()

display(qc.draw('mpl'))
</code></pre>
<p>And here is the raw output for shots greater than 2:</p>
<pre><code>{'1000000010000011000101011': 2,
 '1000010010000010000100001': 2,
 '1000000000000000000000111': 2,
 '0000011010110001000000111': 2,
 '0000001110000001000110011': 2,
 '0000010000010001000001101': 2,
 '1000011100110101100000100': 2,
 '0000001000000110111110100': 2,
 '1000000010110110000110001': 2,
 '1000011100000111110111000': 2,
 '0000000000100100001000011': 2,
 '0000010110000101000000011': 2,
 '1000010000100101101001000': 2,
 '1000010100100100001100010': 2,
 '1000001110000101100111010': 2,
 '0000010000010011000110110': 2}
</code></pre>
<p>I expect, it supposed to return the factors of <code>180</code> like <code>2*90</code>, <code>4*45</code>, and so on...</p>
",HRSCumulativeMultiplier Factorization didn't give expected result,<qiskit><factorization>,2,0,,,"HRSCumulativeMultiplier Factorization didn't give expected result <p>I have:</p>
<ol>
<li>Two 8-qubit multiplication operands</li>
<li>One 8-qubit multiplication result</li>
<li>One 1-qubit aux</li>
</ol>
<p>I initialize all operands in superposition with Hadamard gate, then I marked expected result which is <code>180</code> or <code>1011 0100</code> in binary with <code>Multi-Controlled Z</code>. Then the last, <code>Diffuser</code> is performed for amplify expected result. And then <code>measure_all()</code> quantum register.</p>
<p><a href=""https://i.sstatic.net/0kumi14C.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0kumi14C.png"" alt=""enter image description here"" /></a></p>
<p>Filtering amplitude (shot) greater than 1, got following result:</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th>index</th>
<th>A</th>
<th>B</th>
<th>Result</th>
<th>Aux</th>
<th>Shots</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>6</td>
<td>43</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>33</td>
<td>9</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>7</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>98</td>
<td>7</td>
<td>13</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>51</td>
<td>7</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>34</td>
<td>13</td>
<td>8</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>107</td>
<td>4</td>
<td>14</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>13</td>
<td>244</td>
<td>4</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>8</td>
<td>108</td>
<td>49</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>15</td>
<td>184</td>
<td>14</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>10</td>
<td>72</td>
<td>67</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>10</td>
<td>3</td>
<td>11</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>12</td>
<td>75</td>
<td>72</td>
<td>8</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>13</td>
<td>72</td>
<td>98</td>
<td>10</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>14</td>
<td>11</td>
<td>58</td>
<td>7</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>15</td>
<td>38</td>
<td>54</td>
<td>8</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table></div>
<p>As you see, I didn't see expected result which is <code>180</code>. Even, multiplication result seems not reflect with its operands which are the factors except at <code>index 2</code> where <code>0*7=0</code>.</p>
<p>Here is the following code:</p>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister,
from qiskit.circuit.library import HRSCumulativeMultiplier,

# Define quantum registers
first_operand = QuantumRegister(n_bit, 'operand_a')
second_operand = QuantumRegister(n_bit, 'operand_b')
multiplication_result = QuantumRegister(n_bit, 'result')
aux = QuantumRegister(1, 'aux')

qc = QuantumCircuit(first_operand, second_operand, multiplication_result, aux)

# All Superposition
qc.h(first_operand)
qc.h(second_operand)
# qc.barrier()

expected_result = '10110100' # 180 in decimal
print(f'Expected: {expected_result}')

# Multiplier
multiplier = HRSCumulativeMultiplier(num_state_qubits=n_bit, num_result_qubits=n_bit)
qc.append(multiplier, qargs=list(first_operand) + list(second_operand) + list(multiplication_result) + list(aux))
qc.barrier()

for i, v in enumerate(expected_result[::-1]):
  if v == '0':
    qc.x(multiplication_result[i])
qc.barrier()

qc.h(multiplication_result[-1])
qc.mcx(multiplication_result[:-1], multiplication_result[-1])
qc.h(multiplication_result[-1])
qc.barrier()

for i, v in enumerate(expected_result[::-1]):
  if v == '0':
    qc.x(multiplication_result[i])
qc.barrier()

# Diffuser
qc.h(first_operand)
qc.h(second_operand)
qc.h(multiplication_result)
qc.h(aux)
# qc.barrier()
qc.x(first_operand)
qc.x(second_operand)
qc.x(multiplication_result)
qc.x(aux)
qc.barrier()
qc.h(aux)
qc.mcx(list(range(n_bit*3)), aux)
qc.h(aux)
qc.barrier()
qc.x(first_operand)
qc.x(second_operand)
qc.x(multiplication_result)
qc.x(aux)
# qc.barrier()
qc.h(first_operand)
qc.h(second_operand)
qc.h(multiplication_result)
qc.h(aux)

qc.measure_all()

display(qc.draw('mpl'))
</code></pre>
<p>And here is the raw output for shots greater than 2:</p>
<pre><code>{'1000000010000011000101011': 2,
 '1000010010000010000100001': 2,
 '1000000000000000000000111': 2,
 '0000011010110001000000111': 2,
 '0000001110000001000110011': 2,
 '0000010000010001000001101': 2,
 '1000011100110101100000100': 2,
 '0000001000000110111110100': 2,
 '1000000010110110000110001': 2,
 '1000011100000111110111000': 2,
 '0000000000100100001000011': 2,
 '0000010110000101000000011': 2,
 '1000010000100101101001000': 2,
 '1000010100100100001100010': 2,
 '1000001110000101100111010': 2,
 '0000010000010011000110110': 2}
</code></pre>
<p>I expect, it supposed to return the factors of <code>180</code> like <code>2*90</code>, <code>4*45</code>, and so on...</p>
",qc,hrscumulativemultiplier factorization give expected result p ol li two multiplication operands li one multiplication result li one aux p initialize operands superposition hadamard gate marked expected result code 180 code 1011 0100 binary code z last code diffuser performed amplify expected result code quantum p https nofollow noreferrer img https enter image description p filtering amplitude shot greater 1 got following result div table thead tr th index th th b th result th aux th shots tbody tr td 0 td 6 td 43 td 1 td 1 td 2 tr td 1 td 4 td 33 td 9 td 1 td 2 tr td 2 td 0 td 7 td 0 td 1 td 2 tr td 3 td 98 td 7 td 13 td 0 td 2 tr td 4 td 2 td 51 td 7 td 0 td 2 tr td 5 td 34 td 13 td 8 td 0 td 2 tr td 6 td 107 td 4 td 14 td 1 td 2 tr td 7 td 13 td 244 td 4 td 0 td 2 tr td 8 td 108 td 49 td 1 td 1 td 2 tr td 9 td 15 td 184 td 14 td 1 td 2 tr td 10 td 72 td 67 td 0 td 0 td 2 tr td 11 td 10 td 3 td 11 td 0 td 2 tr td 12 td 75 td 72 td 8 td 1 td 2 tr td 13 td 72 td 98 td 10 td 1 td 2 tr td 14 td 11 td 58 td 7 td 1 td 2 tr td 15 td 38 td 54 td 8 td 0 td 2 p see see expected result code 180 even multiplication result seems reflect operands factors except code index 2 code 0 p following code pre code qiskit import quantumcircuit quantumregister import hrscumulativemultiplier define quantum registers quantumregister quantumregister quantumregister aux quantumregister 1 qc quantumcircuit aux superposition 180 decimal print multiplier multiplier hrscumulativemultiplier multiplier list list list aux v enumerate v 0 v enumerate v 0 diffuser aux aux aux list range 3 aux aux aux aux display p raw output shots greater 2 pre code 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 p expect supposed return factors code 180 like code 2 90 code 4 45,"[(0, 0.17287846), (2, 0.1507949), (4, 0.036697056), (6, 0.122033514), (17, 0.47911248), (18, 0.038132794)]"
39948,,2024-09-23 08:40:37,1,86,"<p>Let <span class=""math-container"">$ U_{fj} $</span> unitary matrix that amplify imaginary part:</p>
<p>For example:</p>
<ol>
<li><span class=""math-container"">$ \begin{pmatrix} 0 + 0.707j \\ 0.707 + 0j \end{pmatrix} \rightarrow \begin{pmatrix} 0 + 1j \\ 0 + 0j \end{pmatrix} $</span></li>
<li><span class=""math-container"">$ \begin{pmatrix} 0.707 + 0j \\ 0 + 0.707j \end{pmatrix} \rightarrow \begin{pmatrix} 0 + 0j \\ 0 + 1j \end{pmatrix} $</span></li>
<li><span class=""math-container"">$ \begin{pmatrix} 0 + 0.707j \\ 0 + 0.707j \end{pmatrix} \rightarrow \begin{pmatrix} 0 + 0.707j \\ 0 + 0.707j \end{pmatrix} $</span></li>
<li>Else, keep real part</li>
</ol>
<p><span class=""math-container"">$ \begin{pmatrix} 0.707 + 0j \\ 0.707 + 0j \end{pmatrix} \rightarrow \begin{pmatrix} 0.707 + 0j \\ 0.707 + 0j \end{pmatrix} $</span></p>
<p>Basically, I want to measure imaginary part or real part. I just realized that one qubit is basically list of complex number with two elements, and complex number basically vector with two elements (real part and imaginary part). Hence, one qubit contains 4 classical states at a moment.</p>
<p>If real part treated as variabel A, and imaginary part variabel B. Then there is relationship between this table:</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th>var_a(real)</th>
<th>var_b(imag)</th>
<th>statevec (1-qubit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>[ 0.707+0.707j, 0+0j ]</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>[ 0.707+0j, 0+0.707j ]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[ 0+0.707j, 0.707+0j ]</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[ 0+0j, 0.707+0.707j ]</td>
</tr>
</tbody>
</table></div>
<p>Suppose there is arbitrary state vector with unknown state. I want to measure its imaginary part, if it's containing real part then the real value must be absorbed into imaginary part equally so when it's measured, I can see clearly the imaginary part (in this case I'm measuring variabel B).</p>
<p>So, how to measure imaginary part in an unknown statevector of a qubit? Will the unitary matrix is irreversible? I mean when performed again, it's undoing into previous state (back to the &quot;before amplification&quot;).</p>
","Universal unitary matrix (logic gate) that amplify imaginary part and nullify real part, and vice versa",<measurement><unitarity><logical-gates>,1,3,,,"Universal unitary matrix (logic gate) that amplify imaginary part and nullify real part, and vice versa <p>Let <span class=""math-container"">$ U_{fj} $</span> unitary matrix that amplify imaginary part:</p>
<p>For example:</p>
<ol>
<li><span class=""math-container"">$ \begin{pmatrix} 0 + 0.707j \\ 0.707 + 0j \end{pmatrix} \rightarrow \begin{pmatrix} 0 + 1j \\ 0 + 0j \end{pmatrix} $</span></li>
<li><span class=""math-container"">$ \begin{pmatrix} 0.707 + 0j \\ 0 + 0.707j \end{pmatrix} \rightarrow \begin{pmatrix} 0 + 0j \\ 0 + 1j \end{pmatrix} $</span></li>
<li><span class=""math-container"">$ \begin{pmatrix} 0 + 0.707j \\ 0 + 0.707j \end{pmatrix} \rightarrow \begin{pmatrix} 0 + 0.707j \\ 0 + 0.707j \end{pmatrix} $</span></li>
<li>Else, keep real part</li>
</ol>
<p><span class=""math-container"">$ \begin{pmatrix} 0.707 + 0j \\ 0.707 + 0j \end{pmatrix} \rightarrow \begin{pmatrix} 0.707 + 0j \\ 0.707 + 0j \end{pmatrix} $</span></p>
<p>Basically, I want to measure imaginary part or real part. I just realized that one qubit is basically list of complex number with two elements, and complex number basically vector with two elements (real part and imaginary part). Hence, one qubit contains 4 classical states at a moment.</p>
<p>If real part treated as variabel A, and imaginary part variabel B. Then there is relationship between this table:</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th>var_a(real)</th>
<th>var_b(imag)</th>
<th>statevec (1-qubit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>[ 0.707+0.707j, 0+0j ]</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>[ 0.707+0j, 0+0.707j ]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>[ 0+0.707j, 0.707+0j ]</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>[ 0+0j, 0.707+0.707j ]</td>
</tr>
</tbody>
</table></div>
<p>Suppose there is arbitrary state vector with unknown state. I want to measure its imaginary part, if it's containing real part then the real value must be absorbed into imaginary part equally so when it's measured, I can see clearly the imaginary part (in this case I'm measuring variabel B).</p>
<p>So, how to measure imaginary part in an unknown statevector of a qubit? Will the unitary matrix is irreversible? I mean when performed again, it's undoing into previous state (back to the &quot;before amplification&quot;).</p>
",qc,universal unitary matrix logic gate amplify imaginary part nullify real part vice versa p let span fj unitary matrix amplify imaginary part p example ol li span pmatrix 0 0j pmatrix pmatrix 0 1j 0 0j pmatrix li span pmatrix 0j 0 pmatrix pmatrix 0 0j 0 1j pmatrix li span pmatrix 0 0 pmatrix pmatrix 0 0 pmatrix li else keep real part p span pmatrix 0j 0j pmatrix pmatrix 0j 0j pmatrix p basically want measure imaginary part real part realized one qubit basically list complex number two elements complex number basically vector two elements real part imaginary part hence one qubit contains 4 classical states p real part treated variabel imaginary part variabel relationship table div table thead tr th real th imag th statevec tbody tr td 0 td 0 td tr td 0 td 1 td tr td 1 td 0 td tr td 1 td 1 td p suppose arbitrary state vector unknown state want measure imaginary part containing real part real value must absorbed imaginary part equally measured see clearly imaginary part case measuring variabel b p measure imaginary part unknown statevector qubit unitary matrix irreversible mean performed undoing previous state back quot amplification quot,"[(2, 0.1148333), (3, 0.044684593), (7, 0.33005682), (14, 0.04100798), (15, 0.12845668), (17, 0.12009006), (18, 0.2018196), (19, 0.01119882)]"
39958,,2024-09-24 13:27:41,0,38,"<p>In the ADAPT-VQE algorithm (see <a href=""https://arxiv.org/pdf/1812.11173"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1812.11173</a>), step (5) involves measuring commutators of the Hamiltonian with each operator in the operator pool to get the gradient of the energy with regards to an operator parameter:</p>
<p><span class=""math-container"">$\frac{\partial E^{(n)}}{\partial\theta_N} = \langle \psi^{(n)} | [\hat{H},\hat{A}_N] | \psi^{(n)} \rangle $</span></p>
<p>I am unsure how this equality comes about; Why is the gradient of the energy with regards to <span class=""math-container"">$\theta_N$</span> equal to expectation value of that commutator?</p>
<p><strong>Attempt at solution:</strong></p>
<p>Starting from the stationary Schrödinger equation for <span class=""math-container"">$\psi^{(n)}$</span>, we take a inner product from the left with <span class=""math-container"">$\psi^{(n)}$</span>:</p>
<p><span class=""math-container"">$ \hat{H}|\psi^{(n)}\rangle = E^{(n)}|\psi^{(n)}\rangle \Rightarrow \langle\psi^{(n)}|\hat{H}|\psi^{(n)}\rangle = E^{(n)}$</span></p>
<p>Take the derivate with regards to <span class=""math-container"">$\theta_N$</span>:</p>
<p><span class=""math-container"">$\frac{\partial E^{(n)}}{\partial\theta_N} = \frac{\partial}{\partial\theta_N}\langle\psi^{(n)}|\hat{H}|\psi^{(n)}\rangle$</span></p>
<p>If the right-hand side can somehow be rewritten further, one would be able to get to the desired result, but I am unsure how to proceed from here.</p>
",Gradient of energy in ADAPT-VQE algorithm,<vqe>,1,0,,,"Gradient of energy in ADAPT-VQE algorithm <p>In the ADAPT-VQE algorithm (see <a href=""https://arxiv.org/pdf/1812.11173"" rel=""nofollow noreferrer"">https://arxiv.org/pdf/1812.11173</a>), step (5) involves measuring commutators of the Hamiltonian with each operator in the operator pool to get the gradient of the energy with regards to an operator parameter:</p>
<p><span class=""math-container"">$\frac{\partial E^{(n)}}{\partial\theta_N} = \langle \psi^{(n)} | [\hat{H},\hat{A}_N] | \psi^{(n)} \rangle $</span></p>
<p>I am unsure how this equality comes about; Why is the gradient of the energy with regards to <span class=""math-container"">$\theta_N$</span> equal to expectation value of that commutator?</p>
<p><strong>Attempt at solution:</strong></p>
<p>Starting from the stationary Schrödinger equation for <span class=""math-container"">$\psi^{(n)}$</span>, we take a inner product from the left with <span class=""math-container"">$\psi^{(n)}$</span>:</p>
<p><span class=""math-container"">$ \hat{H}|\psi^{(n)}\rangle = E^{(n)}|\psi^{(n)}\rangle \Rightarrow \langle\psi^{(n)}|\hat{H}|\psi^{(n)}\rangle = E^{(n)}$</span></p>
<p>Take the derivate with regards to <span class=""math-container"">$\theta_N$</span>:</p>
<p><span class=""math-container"">$\frac{\partial E^{(n)}}{\partial\theta_N} = \frac{\partial}{\partial\theta_N}\langle\psi^{(n)}|\hat{H}|\psi^{(n)}\rangle$</span></p>
<p>If the right-hand side can somehow be rewritten further, one would be able to get to the desired result, but I am unsure how to proceed from here.</p>
",qc,gradient energy algorithm p algorithm see https nofollow noreferrer https step 5 involves measuring commutators hamiltonian operator operator pool get gradient energy regards operator parameter p span n n h n p unsure equality comes gradient energy regards span equal expectation value commutator p strong attempt solution p starting stationary schrödinger equation span n take inner product left span n p span h n n n n h n n p take derivate regards span p span n n h n p side somehow rewritten one would able get desired result unsure proceed,"[(0, 0.10854514), (3, 0.5269311), (4, 0.09006332), (7, 0.12815334), (15, 0.053022537), (17, 0.046875942), (18, 0.04498217)]"
39967,,2024-09-25 07:08:01,0,41,"<p>I want to find two operands of multiplication result of <code>180</code>. In another word, finding integer factors of <code>180</code>.</p>
<p>I'm using <code>Grover</code>'s Search Algorithm, where the oracle is <code>HRSCumulativeMultiplier</code>. I iterate oracle and diffuser 5 times. In this picture below, I'm just displaying first iteration for the sake of display convenience.</p>
<p><a href=""https://i.sstatic.net/4asxpOvL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4asxpOvL.png"" alt=""enter image description here"" /></a></p>
<p>Here is the code:</p>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit.circuit.library import HRSCumulativeMultiplier
from qiskit.visualization import plot_histogram

expected_result = '10110100' # 180 in decimal
n_bit = 8
expected_result = expected_result.zfill(n_bit*2) # the length must be two times of n_bit
print(f'Expected: {expected_result}')

# function to mark output
def mark_output(expected_result, n_bit):
    n_bit *= 2 # must be two times for output register

    qc = QuantumCircuit(n_bit, name=' Mark Output')

    for i, v in enumerate(expected_result[::-1]):
      if v == '0':
        qc.x(i)
    qc.barrier()

    qc.h(n_bit-1)
    qc.mcx(list(range(n_bit-1)), n_bit-1)
    qc.h(n_bit-1)
    qc.barrier()

    for i, v in enumerate(expected_result[::-1]):
      if v == '0':
        qc.x(i)

    return qc

# function for diffuser
def diffuser(n):
  qc = QuantumCircuit(n, name=' Diffuser')
  qc.h(range(n))

  # qc.barrier()
  qc.x(range(n))
  qc.barrier()
  qc.h(n-1)
  qc.mcx(list(range(n-1)),n-1)
  qc.h(n-1)
  qc.barrier()
  qc.x(range(n))
  # qc.barrier()
  qc.h(range(n))

  return qc

# multiplier gate
multiplier = HRSCumulativeMultiplier(num_state_qubits=n_bit)

# Define quantum registers
first_operand = QuantumRegister(n_bit, 'operand_a')
second_operand = QuantumRegister(n_bit, 'operand_b')
multiplication_result = QuantumRegister(2*n_bit, 'result')
aux = QuantumRegister(1, 'aux')

first_meas = ClassicalRegister(n_bit,'a_m')
second_meas = ClassicalRegister(n_bit,'b_m')

qc = QuantumCircuit(first_operand, second_operand, multiplication_result, aux, first_meas, second_meas)

# initialize operands in superposition
qc.h(first_operand)
qc.h(second_operand)

# iterate to apply oracle+diffuser
for i in range(5): # iterate grover 5 times,
    qc.append(multiplier, qargs=list(first_operand) + list(second_operand) + list(multiplication_result) + list(aux))
    qc.append(mark_output(expected_result, n_bit),multiplication_result)
    qc.append(multiplier.inverse(), qargs=list(first_operand) + list(second_operand) + list(multiplication_result) + list(aux))
    qc.append(diffuser(2*n_bit),range(2*n_bit))

    if i == 0:
      display(qc.draw('mpl'))

qc.barrier()
qc.measure(first_operand,first_meas)
qc.measure(second_operand,second_meas)
</code></pre>
<p>Here is the transpilation code:</p>
<pre><code>#@title Transpile the Circuit

from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from time import time

# If you did not previously save your credentials, use the following line instead:
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token='CENCORED')

backend = service.least_busy(simulator=False, operational=True)

# Convert to an ISA circuit and layout-mapped observables.
'''
Optimization Level: More optimized less depth circuit will be generated so the noise will be reduced, but more transpilation time.
0: No optimization
1: Light
2: Medium
3: High
'''
optimization_level = 3
pm = generate_preset_pass_manager(backend=backend, optimization_level=optimization_level)
start_time = time()
isa_qc = pm.run(qc)
end_time = time() - start_time

# Save transpilation time and its optimization level to .txt
with open('transpilation_time_find180.txt', 'w') as f:
  f.write(f&quot;Optimization Level: {optimization_level}\n&quot;)
  f.write(f&quot;Transpilation Time: {end_time} seconds\n&quot;)
  print(f&quot;Optimization Level: {optimization_level}&quot;)
  print(f&quot;Transpilation Time: {end_time} seconds&quot;)
</code></pre>
<p>Outputting:</p>
<pre><code>Optimization Level: 3
Transpilation Time: 825.7853915691376 seconds
</code></pre>
<p>And here is the error of actual execution:</p>
<pre><code>---------------------------------------------------------------------------

RuntimeJobFailureError                    Traceback (most recent call last)

&lt;ipython-input-33-e9e712c29796&gt; in &lt;cell line: 3&gt;()
      1 sampler = Sampler(backend)
      2 job = sampler.run([isa_qc], shots=2**14)
----&gt; 3 results = job.result()

/usr/local/lib/python3.10/dist-packages/qiskit_ibm_runtime/runtime_job_v2.py in result(self, timeout, decoder)
    136             if self._reason_code == 1305:
    137                 raise RuntimeJobMaxTimeoutError(error_message)
--&gt; 138             raise RuntimeJobFailureError(f&quot;Unable to retrieve job result. {error_message}&quot;)
    139         if self._status == &quot;CANCELLED&quot;:
    140             raise RuntimeInvalidStateError(

RuntimeJobFailureError: 'Unable to retrieve job result. Error code 1520; The instruction cost per qubit exceeds the system limit . -- Split circuits/pubs into multiple jobs. -- https://ibm.biz/error_codes#1520'
</code></pre>
<p>I know that I should have run the job in a batch. But, I only have one job which is finding factorization of <code>180</code>. I did read the <a href=""https://docs.quantum.ibm.com/guides/run-jobs-batch#partition"" rel=""nofollow noreferrer"">docs</a>. But I have no clue how to convert my job into a batch, since it's problem specific.</p>
<p>Is it possible that the iteration of <code>Grover</code> is causing this error hence the iteration must be splitted instead of serially in a single quantum circuit?</p>
",RuntimeJobFailureError: 'Unable to retrieve job result. Error code 1520; The instruction cost per qubit exceeds the system limit,<qiskit><programming><ibm-q-experience><qiskit-runtime>,0,0,,,"RuntimeJobFailureError: 'Unable to retrieve job result. Error code 1520; The instruction cost per qubit exceeds the system limit <p>I want to find two operands of multiplication result of <code>180</code>. In another word, finding integer factors of <code>180</code>.</p>
<p>I'm using <code>Grover</code>'s Search Algorithm, where the oracle is <code>HRSCumulativeMultiplier</code>. I iterate oracle and diffuser 5 times. In this picture below, I'm just displaying first iteration for the sake of display convenience.</p>
<p><a href=""https://i.sstatic.net/4asxpOvL.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/4asxpOvL.png"" alt=""enter image description here"" /></a></p>
<p>Here is the code:</p>
<pre><code>from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit.circuit.library import HRSCumulativeMultiplier
from qiskit.visualization import plot_histogram

expected_result = '10110100' # 180 in decimal
n_bit = 8
expected_result = expected_result.zfill(n_bit*2) # the length must be two times of n_bit
print(f'Expected: {expected_result}')

# function to mark output
def mark_output(expected_result, n_bit):
    n_bit *= 2 # must be two times for output register

    qc = QuantumCircuit(n_bit, name=' Mark Output')

    for i, v in enumerate(expected_result[::-1]):
      if v == '0':
        qc.x(i)
    qc.barrier()

    qc.h(n_bit-1)
    qc.mcx(list(range(n_bit-1)), n_bit-1)
    qc.h(n_bit-1)
    qc.barrier()

    for i, v in enumerate(expected_result[::-1]):
      if v == '0':
        qc.x(i)

    return qc

# function for diffuser
def diffuser(n):
  qc = QuantumCircuit(n, name=' Diffuser')
  qc.h(range(n))

  # qc.barrier()
  qc.x(range(n))
  qc.barrier()
  qc.h(n-1)
  qc.mcx(list(range(n-1)),n-1)
  qc.h(n-1)
  qc.barrier()
  qc.x(range(n))
  # qc.barrier()
  qc.h(range(n))

  return qc

# multiplier gate
multiplier = HRSCumulativeMultiplier(num_state_qubits=n_bit)

# Define quantum registers
first_operand = QuantumRegister(n_bit, 'operand_a')
second_operand = QuantumRegister(n_bit, 'operand_b')
multiplication_result = QuantumRegister(2*n_bit, 'result')
aux = QuantumRegister(1, 'aux')

first_meas = ClassicalRegister(n_bit,'a_m')
second_meas = ClassicalRegister(n_bit,'b_m')

qc = QuantumCircuit(first_operand, second_operand, multiplication_result, aux, first_meas, second_meas)

# initialize operands in superposition
qc.h(first_operand)
qc.h(second_operand)

# iterate to apply oracle+diffuser
for i in range(5): # iterate grover 5 times,
    qc.append(multiplier, qargs=list(first_operand) + list(second_operand) + list(multiplication_result) + list(aux))
    qc.append(mark_output(expected_result, n_bit),multiplication_result)
    qc.append(multiplier.inverse(), qargs=list(first_operand) + list(second_operand) + list(multiplication_result) + list(aux))
    qc.append(diffuser(2*n_bit),range(2*n_bit))

    if i == 0:
      display(qc.draw('mpl'))

qc.barrier()
qc.measure(first_operand,first_meas)
qc.measure(second_operand,second_meas)
</code></pre>
<p>Here is the transpilation code:</p>
<pre><code>#@title Transpile the Circuit

from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from time import time

# If you did not previously save your credentials, use the following line instead:
service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;, token='CENCORED')

backend = service.least_busy(simulator=False, operational=True)

# Convert to an ISA circuit and layout-mapped observables.
'''
Optimization Level: More optimized less depth circuit will be generated so the noise will be reduced, but more transpilation time.
0: No optimization
1: Light
2: Medium
3: High
'''
optimization_level = 3
pm = generate_preset_pass_manager(backend=backend, optimization_level=optimization_level)
start_time = time()
isa_qc = pm.run(qc)
end_time = time() - start_time

# Save transpilation time and its optimization level to .txt
with open('transpilation_time_find180.txt', 'w') as f:
  f.write(f&quot;Optimization Level: {optimization_level}\n&quot;)
  f.write(f&quot;Transpilation Time: {end_time} seconds\n&quot;)
  print(f&quot;Optimization Level: {optimization_level}&quot;)
  print(f&quot;Transpilation Time: {end_time} seconds&quot;)
</code></pre>
<p>Outputting:</p>
<pre><code>Optimization Level: 3
Transpilation Time: 825.7853915691376 seconds
</code></pre>
<p>And here is the error of actual execution:</p>
<pre><code>---------------------------------------------------------------------------

RuntimeJobFailureError                    Traceback (most recent call last)

&lt;ipython-input-33-e9e712c29796&gt; in &lt;cell line: 3&gt;()
      1 sampler = Sampler(backend)
      2 job = sampler.run([isa_qc], shots=2**14)
----&gt; 3 results = job.result()

/usr/local/lib/python3.10/dist-packages/qiskit_ibm_runtime/runtime_job_v2.py in result(self, timeout, decoder)
    136             if self._reason_code == 1305:
    137                 raise RuntimeJobMaxTimeoutError(error_message)
--&gt; 138             raise RuntimeJobFailureError(f&quot;Unable to retrieve job result. {error_message}&quot;)
    139         if self._status == &quot;CANCELLED&quot;:
    140             raise RuntimeInvalidStateError(

RuntimeJobFailureError: 'Unable to retrieve job result. Error code 1520; The instruction cost per qubit exceeds the system limit . -- Split circuits/pubs into multiple jobs. -- https://ibm.biz/error_codes#1520'
</code></pre>
<p>I know that I should have run the job in a batch. But, I only have one job which is finding factorization of <code>180</code>. I did read the <a href=""https://docs.quantum.ibm.com/guides/run-jobs-batch#partition"" rel=""nofollow noreferrer"">docs</a>. But I have no clue how to convert my job into a batch, since it's problem specific.</p>
<p>Is it possible that the iteration of <code>Grover</code> is causing this error hence the iteration must be splitted instead of serially in a single quantum circuit?</p>
",qc,runtimejobfailureerror retrieve job result error code 1520 instruction cost per qubit exceeds system limit p want find two operands multiplication result code 180 another word finding integer factors code 180 p using code grover search algorithm oracle code hrscumulativemultiplier iterate oracle diffuser 5 times picture displaying first iteration sake display p https nofollow noreferrer img https enter image description p code pre code qiskit import quantumcircuit quantumregister classicalregister transpile import hrscumulativemultiplier import 180 decimal 8 2 length must two times print function mark output def 2 must two times output register qc quantumcircuit mark output v enumerate v 0 list range v enumerate v 0 return qc function diffuser def diffuser n qc quantumcircuit n diffuser range n range n list range range n range n return qc multiplier gate multiplier hrscumulativemultiplier define quantum registers quantumregister quantumregister quantumregister 2 aux quantumregister 1 classicalregister classicalregister qc quantumcircuit aux initialize operands superposition iterate apply range 5 iterate grover 5 times multiplier list list list aux list list list aux diffuser 2 range 2 0 display p transpilation code pre code title transpile circuit import qiskitruntimeservice samplerv2 sampler import time import time previously save credentials use following line instead service qiskitruntimeservice quot quot backend convert isa circuit optimization level optimized less depth circuit generated noise reduced transpilation time 0 optimization 1 light 2 medium 3 high 3 pm time qc time save transpilation time optimization level open w f f quot optimization level quot f quot transpilation time quot print f quot optimization level quot print f quot transpilation time seconds quot p outputting pre code optimization level 3 transpilation time seconds p error actual execution pre code runtimejobfailureerror traceback recent call last lt gt lt cell line 3 gt 1 sampler sampler backend 2 job 14 gt 3 results result self timeout decoder 136 1305 137 raise runtimejobmaxtimeouterror gt 138 raise runtimejobfailureerror f quot unable retrieve job result quot 139 quot cancelled quot 140 raise runtimeinvalidstateerror runtimejobfailureerror retrieve job result error code 1520 instruction cost per qubit exceeds system limit split multiple jobs https 1520 p know run job batch one job finding factorization code 180 read https partition nofollow noreferrer docs clue convert job batch since problem p possible iteration code grover causing error hence iteration must splitted instead serially single quantum circuit,"[(0, 0.56134444), (1, 0.018091511), (2, 0.021438105), (4, 0.045283098), (6, 0.016608922), (7, 0.039852593), (10, 0.017802725), (14, 0.09550905), (17, 0.02683593), (18, 0.033216424), (19, 0.12377899)]"
39968,,2024-09-25 09:56:06,1,129,"<p>I am trying to solve this problem: <a href=""https://pennylane.ai/challenges/intro_to_pennylane/"" rel=""nofollow noreferrer"">https://pennylane.ai/challenges/intro_to_pennylane/</a></p>
<p>Here is what I got so far:</p>
<pre><code>def W(params):
 # Put your code here
    num_wires = len(params[0])  
    for i in range(num_wires):
        qml.RY(params[0, i], wires=i)  
        if i &lt; num_wires - 1:
            qml.CNOT(wires=[i, i+1])  
    qml.CNOT(wires=[0, num_wires-1]) 

def S(g, x, num_wires):
# Put your code here
    for i in range(num_wires):
        qml.exp(qml.Hermitian(g.matrix, wires=[i]), coeff=x)

dev = qml.device(&quot;default.qubit&quot;, wires=3)
@qml.qnode(dev, expansion_strategy = &quot;device&quot;)

def quantum_model(param_set, g, x):
# Put your code here
    num_wires = len(param_set[0][0])
    for i, params in enumerate(param_set):
        W(params)  
        S(g, x, num_wires)  

    return qml.probs(wires=0)  
</code></pre>
<p>The error I get is Failure message: Runtime Error: Failed to execute run() function: 'function' object has no attribute 'shape'. Thank you for helping!</p>
",PennyLane Certificate Challenge,<pennylane>,1,0,,,"PennyLane Certificate Challenge <p>I am trying to solve this problem: <a href=""https://pennylane.ai/challenges/intro_to_pennylane/"" rel=""nofollow noreferrer"">https://pennylane.ai/challenges/intro_to_pennylane/</a></p>
<p>Here is what I got so far:</p>
<pre><code>def W(params):
 # Put your code here
    num_wires = len(params[0])  
    for i in range(num_wires):
        qml.RY(params[0, i], wires=i)  
        if i &lt; num_wires - 1:
            qml.CNOT(wires=[i, i+1])  
    qml.CNOT(wires=[0, num_wires-1]) 

def S(g, x, num_wires):
# Put your code here
    for i in range(num_wires):
        qml.exp(qml.Hermitian(g.matrix, wires=[i]), coeff=x)

dev = qml.device(&quot;default.qubit&quot;, wires=3)
@qml.qnode(dev, expansion_strategy = &quot;device&quot;)

def quantum_model(param_set, g, x):
# Put your code here
    num_wires = len(param_set[0][0])
    for i, params in enumerate(param_set):
        W(params)  
        S(g, x, num_wires)  

    return qml.probs(wires=0)  
</code></pre>
<p>The error I get is Failure message: Runtime Error: Failed to execute run() function: 'function' object has no attribute 'shape'. Thank you for helping!</p>
",qc,pennylane certificate challenge p trying solve problem https nofollow noreferrer https p got far pre code def w params put code len params 0 range params 0 lt 1 0 def g x put code range dev quot quot dev quot device quot def g x put code len 0 0 params enumerate w params g x return p error get failure message runtime error failed execute run function object attribute thank helping,"[(0, 0.64365625), (2, 0.07311114), (4, 0.076247536), (8, 0.054388035), (10, 0.06517028), (17, 0.013973408), (19, 0.0716744)]"
39981,40046.0,2024-09-27 16:53:35,0,105,"<p>Referring to this thesis (download at bottom of page): <a href=""https://repository.tudelft.nl/record/uuid:649f5fe9-0266-4be2-a3a5-4b5ffd13073e"" rel=""nofollow noreferrer"">https://repository.tudelft.nl/record/uuid:649f5fe9-0266-4be2-a3a5-4b5ffd13073e</a></p>
<p>In section 4.2, I understood things quite well up to Table 4.1. After that, the author introduces a protocol to simplify the erasure correction by repositioning the lost qubit during syndrome measurement. Although I mechanically understand the process itself and have a rough grasp of how this is working (though not fully comprehend it), some questions remain:</p>
<ol>
<li><p>How can we just reposition the lost qubit? Aren't stabilizers made
for the particular encoding? Would cycling the logical qubit
positions still make things work fine?</p>
</li>
<li><p>The author doesn't seem to have rigorously proved this mechanism in
this paper. Has it been done in some other paper (seems unlikely as
there's no reference), or is this just too trivial to prove?</p>
</li>
<li><p>MOST IMPORTANTLY, is this a general protocol that will work for all
stabilizer QEC codes? Like if, for the [[7,1,3]] (Steane) code, I
use K = (k mod 7) + 1 and rework Table 4.2 (pretty simple if I just
think of it as D1 loss and find the errors), will it work?</p>
</li>
</ol>
<p>I really need the last question answered for my work - please help guys. Thanks in advance!</p>
<p>PS. The paper uses [[5,1,3]] code. Here are some pics for easier access.
<a href=""https://i.sstatic.net/kEBoBAab.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/kEBoBAab.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/xVaj5lei.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xVaj5lei.png"" alt=""enter image description here"" /></a></p>
",Erasure Error Correction Protocol in Kah Jen Wo's Thesis,<error-correction><stabilizer-code><quantum-networks>,1,0,,,"Erasure Error Correction Protocol in Kah Jen Wo's Thesis <p>Referring to this thesis (download at bottom of page): <a href=""https://repository.tudelft.nl/record/uuid:649f5fe9-0266-4be2-a3a5-4b5ffd13073e"" rel=""nofollow noreferrer"">https://repository.tudelft.nl/record/uuid:649f5fe9-0266-4be2-a3a5-4b5ffd13073e</a></p>
<p>In section 4.2, I understood things quite well up to Table 4.1. After that, the author introduces a protocol to simplify the erasure correction by repositioning the lost qubit during syndrome measurement. Although I mechanically understand the process itself and have a rough grasp of how this is working (though not fully comprehend it), some questions remain:</p>
<ol>
<li><p>How can we just reposition the lost qubit? Aren't stabilizers made
for the particular encoding? Would cycling the logical qubit
positions still make things work fine?</p>
</li>
<li><p>The author doesn't seem to have rigorously proved this mechanism in
this paper. Has it been done in some other paper (seems unlikely as
there's no reference), or is this just too trivial to prove?</p>
</li>
<li><p>MOST IMPORTANTLY, is this a general protocol that will work for all
stabilizer QEC codes? Like if, for the [[7,1,3]] (Steane) code, I
use K = (k mod 7) + 1 and rework Table 4.2 (pretty simple if I just
think of it as D1 loss and find the errors), will it work?</p>
</li>
</ol>
<p>I really need the last question answered for my work - please help guys. Thanks in advance!</p>
<p>PS. The paper uses [[5,1,3]] code. Here are some pics for easier access.
<a href=""https://i.sstatic.net/kEBoBAab.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/kEBoBAab.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.sstatic.net/xVaj5lei.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/xVaj5lei.png"" alt=""enter image description here"" /></a></p>
",qc,erasure error correction protocol kah jen wo thesis p referring thesis download bottom page https nofollow noreferrer https p section understood things quite well table author introduces protocol simplify erasure correction repositioning lost qubit syndrome measurement although mechanically understand process rough grasp working though fully comprehend questions remain ol li p reposition lost qubit stabilizers made particular encoding would cycling logical qubit positions still make things work fine li p author seem rigorously proved mechanism paper done paper seems unlikely reference trivial prove li p importantly general protocol work stabilizer qec codes like steane code use k k mod 7 1 rework table pretty simple think d1 loss find errors work p really need last question answered work please help guys thanks advance p ps paper uses code pics easier access https nofollow noreferrer img https enter image description p https nofollow noreferrer img https enter image description,"[(3, 0.045779154), (4, 0.26234266), (5, 0.17836827), (6, 0.017157296), (8, 0.33403727), (9, 0.094892405), (13, 0.037121292), (17, 0.022286601)]"
39989,,2024-09-28 12:53:19,3,73,"<p>In the BB84 QKD or similar protocol, we know that eavesdropping or interception during secret key generation can be detected, prompting both parties to discard the transaction and attempt a new one. However, what if, as a hacker, my goal is to continuously intercept their communication, preventing them from ever successfully generating a secret key? Wouldn't this result in a denial-of-service (DoS) attack? And what fallback methods are available in such a situation apart from switching back to existing asymmetric encryption?</p>
",DOS attacks on QKD Systesm,<cryptography><qkd><bb84>,1,0,,,"DOS attacks on QKD Systesm <p>In the BB84 QKD or similar protocol, we know that eavesdropping or interception during secret key generation can be detected, prompting both parties to discard the transaction and attempt a new one. However, what if, as a hacker, my goal is to continuously intercept their communication, preventing them from ever successfully generating a secret key? Wouldn't this result in a denial-of-service (DoS) attack? And what fallback methods are available in such a situation apart from switching back to existing asymmetric encryption?</p>
",qc,dos attacks qkd systesm p bb84 qkd similar protocol know eavesdropping interception secret key generation detected prompting parties discard transaction attempt new one however hacker goal continuously intercept communication preventing ever successfully generating secret key would result dos attack fallback methods available situation apart switching back existing asymmetric encryption,"[(7, 0.07622066), (8, 0.30746034), (11, 0.043340802), (17, 0.40500373), (18, 0.16491984)]"
40022,,2024-10-03 06:41:20,0,31,"<p>I'm wondering if it's possible to do the following (in Qiskit):</p>
<ul>
<li>Preparing a superposition of three states</li>
<li>Setting the amplitude of each state to a particular value</li>
<li>Carrying out a specific number of measurements in said system</li>
</ul>
<p>Would be very very grateful if someone could give me a hand with what the code should look like - thanks!</p>
",Qiskit: Superposition of Three States with Unequal Amplitudes,<qiskit><quantum-state><measurement><superposition>,1,0,,,"Qiskit: Superposition of Three States with Unequal Amplitudes <p>I'm wondering if it's possible to do the following (in Qiskit):</p>
<ul>
<li>Preparing a superposition of three states</li>
<li>Setting the amplitude of each state to a particular value</li>
<li>Carrying out a specific number of measurements in said system</li>
</ul>
<p>Would be very very grateful if someone could give me a hand with what the code should look like - thanks!</p>
",qc,qiskit superposition three states unequal amplitudes p wondering possible following qiskit ul li preparing superposition three states li setting amplitude state particular value li carrying specific number measurements said system p would grateful someone could give hand code look like thanks,"[(7, 0.18403988), (14, 0.3035416), (17, 0.025574915), (18, 0.45855308), (19, 0.024643825)]"
40047,,2024-10-06 17:52:58,4,142,"<p>I'm following <a href=""https://pymatching.readthedocs.io/en/stable/toric-code-example.html"" rel=""nofollow noreferrer"">this</a> toric code tutorial, where they constructed the <span class=""math-container"">$X$</span>-logicals matrix using the <a href=""https://en.wikipedia.org/wiki/K%C3%BCnneth_theorem"" rel=""nofollow noreferrer"">Künneth theorem</a>.</p>
<p>I'm confused about why they specifically used <span class=""math-container"">$X$</span>-logicals when only <span class=""math-container"">$Z$</span> errors were allowed to occur.</p>
<p>I used the following code to create the <span class=""math-container"">$Z$</span>-logicals matrix manually.</p>
<pre class=""lang-python prettyprint-override""><code>def toric_code_z_logicals(L):
    n_qubits = 2 * L * L  # Total number of qubits in the toric code lattice
    matrix = dok_matrix((2, n_qubits), dtype=int)  # Two logical Z operators

    # Logical Z Operator 1: Mark every L-th qubit starting from the first qubit
    logical1_indices = [i * L for i in range(L)]

    # Logical Z Operator 2: Mark all qubits in the last row of the lattice
    logical2_start = n_qubits - L  # Starting index of the last row
    logical2_indices = [logical2_start + i for i in range(L)]

    # Fill in the matrix for the two logical Z operators
    for idx in logical1_indices:
        matrix[0, idx] = 1
    for idx in logical2_indices:
        matrix[1, idx] = 1

    return matrix.todense()
</code></pre>
<p>I tried using <span class=""math-container"">$Z$</span>-logicals instead but ended up with the following graph that looks like a bell curve when plotting the physical vs logical error graph using physical errors up to one.
<a href=""https://i.sstatic.net/F0rKINbV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F0rKINbV.png"" alt=""enter image description here"" /></a></p>
",Why are $X$-logicals used when only $Z$ errors are allowed in logical error calculation instead of $Z$-logicals?,<error-correction><pymatching><toric-code>,1,4,,,"Why are $X$-logicals used when only $Z$ errors are allowed in logical error calculation instead of $Z$-logicals? <p>I'm following <a href=""https://pymatching.readthedocs.io/en/stable/toric-code-example.html"" rel=""nofollow noreferrer"">this</a> toric code tutorial, where they constructed the <span class=""math-container"">$X$</span>-logicals matrix using the <a href=""https://en.wikipedia.org/wiki/K%C3%BCnneth_theorem"" rel=""nofollow noreferrer"">Künneth theorem</a>.</p>
<p>I'm confused about why they specifically used <span class=""math-container"">$X$</span>-logicals when only <span class=""math-container"">$Z$</span> errors were allowed to occur.</p>
<p>I used the following code to create the <span class=""math-container"">$Z$</span>-logicals matrix manually.</p>
<pre class=""lang-python prettyprint-override""><code>def toric_code_z_logicals(L):
    n_qubits = 2 * L * L  # Total number of qubits in the toric code lattice
    matrix = dok_matrix((2, n_qubits), dtype=int)  # Two logical Z operators

    # Logical Z Operator 1: Mark every L-th qubit starting from the first qubit
    logical1_indices = [i * L for i in range(L)]

    # Logical Z Operator 2: Mark all qubits in the last row of the lattice
    logical2_start = n_qubits - L  # Starting index of the last row
    logical2_indices = [logical2_start + i for i in range(L)]

    # Fill in the matrix for the two logical Z operators
    for idx in logical1_indices:
        matrix[0, idx] = 1
    for idx in logical2_indices:
        matrix[1, idx] = 1

    return matrix.todense()
</code></pre>
<p>I tried using <span class=""math-container"">$Z$</span>-logicals instead but ended up with the following graph that looks like a bell curve when plotting the physical vs logical error graph using physical errors up to one.
<a href=""https://i.sstatic.net/F0rKINbV.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/F0rKINbV.png"" alt=""enter image description here"" /></a></p>
",qc,x used z errors allowed logical error calculation instead z p following https nofollow noreferrer toric code tutorial constructed span x matrix using https c3 nofollow noreferrer künneth theorem p confused specifically used span x span z errors allowed p used following code create span z matrix pre code def l 2 l l total number qubits toric code lattice matrix 2 two logical z operators logical z operator 1 mark every qubit starting first qubit l range l logical z operator 2 mark qubits last row lattice l starting index last row range l fill matrix two logical z operators idx matrix 0 idx 1 idx matrix 1 idx 1 return p tried using span z instead ended following graph looks like bell curve plotting physical vs logical error graph using physical errors one https nofollow noreferrer img https enter image description,"[(0, 0.16624515), (2, 0.058128092), (3, 0.13861988), (4, 0.16977836), (5, 0.32071218), (10, 0.018655613), (11, 0.041778486), (16, 0.014177062), (17, 0.015580308), (18, 0.055624988)]"
40048,,2024-10-06 23:23:59,1,86,"<p>I am trying to do decoding in presence of measurement error and bit-flip error for the repetition code. In the PyMatching version 0.2.2 <a href=""https://pypi.org/project/PyMatching/0.2.3/"" rel=""nofollow noreferrer"">https://pypi.org/project/PyMatching/0.2.3/</a> it mentions that</p>
<blockquote>
<p>To decode instead in the presence of measurement errors, each stabiliser measurement is repeated <code>L</code> times, and decoding then takes place over a 3D matching graph (see Section IV B of this paper), which can be constructed directly from the check matrix <code>H</code> using:</p>
</blockquote>
<pre><code>m = Matching(H, repetitions=L)
</code></pre>
<blockquote>
<p>and then decoded from an <code>m</code> by <code>L</code> numpy array syndrome <code>z</code> using:</p>
</blockquote>
<pre><code>c = m.decode(z)
</code></pre>
<p>I tried this for an example case with <code>H</code> as the repetition code syndrome</p>
<pre><code>import numpy as np
from pymatching import *

N = 10 # number of qubits
H = np.zeros((N-1,N),dtype = int)
for i in range(N-1):
    H[i,i] = 1
    H[i,i+1] = 1
</code></pre>
<p>and syndrome histroy</p>
<pre><code>z = array([[0, 1, 1, 0, 0, 0, 0, 0, 0],
   [0, 1, 1, 0, 0, 1, 0, 0, 0],
   [1, 1, 1, 0, 0, 1, 1, 1, 0],
   [1, 0, 0, 0, 1, 0, 1, 0, 0],
   [1, 0, 0, 0, 1, 1, 0, 1, 1],
   [1, 0, 0, 0, 0, 0, 1, 1, 1],
   [1, 0, 0, 0, 0, 1, 1, 1, 1],
   [1, 0, 0, 0, 0, 1, 1, 0, 0],
   [1, 0, 0, 0, 0, 0, 0, 0, 1],
   [1, 0, 0, 0, 0, 0, 0, 0, 0]])
</code></pre>
<p>but I am not getting the correct corrections. The weird thing is, even if I take no measurement error and bit-flip error and just repeat the syndrome, I get the wrong results so I think, I am doing something incorrect. Please help me with this.</p>
",MWPM decoding with PyMatching in presence of measurement error,<error-correction><stabilizer-code><fault-tolerance><pymatching>,1,0,,,"MWPM decoding with PyMatching in presence of measurement error <p>I am trying to do decoding in presence of measurement error and bit-flip error for the repetition code. In the PyMatching version 0.2.2 <a href=""https://pypi.org/project/PyMatching/0.2.3/"" rel=""nofollow noreferrer"">https://pypi.org/project/PyMatching/0.2.3/</a> it mentions that</p>
<blockquote>
<p>To decode instead in the presence of measurement errors, each stabiliser measurement is repeated <code>L</code> times, and decoding then takes place over a 3D matching graph (see Section IV B of this paper), which can be constructed directly from the check matrix <code>H</code> using:</p>
</blockquote>
<pre><code>m = Matching(H, repetitions=L)
</code></pre>
<blockquote>
<p>and then decoded from an <code>m</code> by <code>L</code> numpy array syndrome <code>z</code> using:</p>
</blockquote>
<pre><code>c = m.decode(z)
</code></pre>
<p>I tried this for an example case with <code>H</code> as the repetition code syndrome</p>
<pre><code>import numpy as np
from pymatching import *

N = 10 # number of qubits
H = np.zeros((N-1,N),dtype = int)
for i in range(N-1):
    H[i,i] = 1
    H[i,i+1] = 1
</code></pre>
<p>and syndrome histroy</p>
<pre><code>z = array([[0, 1, 1, 0, 0, 0, 0, 0, 0],
   [0, 1, 1, 0, 0, 1, 0, 0, 0],
   [1, 1, 1, 0, 0, 1, 1, 1, 0],
   [1, 0, 0, 0, 1, 0, 1, 0, 0],
   [1, 0, 0, 0, 1, 1, 0, 1, 1],
   [1, 0, 0, 0, 0, 0, 1, 1, 1],
   [1, 0, 0, 0, 0, 1, 1, 1, 1],
   [1, 0, 0, 0, 0, 1, 1, 0, 0],
   [1, 0, 0, 0, 0, 0, 0, 0, 1],
   [1, 0, 0, 0, 0, 0, 0, 0, 0]])
</code></pre>
<p>but I am not getting the correct corrections. The weird thing is, even if I take no measurement error and bit-flip error and just repeat the syndrome, I get the wrong results so I think, I am doing something incorrect. Please help me with this.</p>
",qc,mwpm decoding pymatching presence measurement error p trying decoding presence measurement error error repetition code pymatching version https nofollow noreferrer https mentions blockquote p decode instead presence measurement errors stabiliser measurement repeated code l times decoding takes place 3d matching graph see section iv b paper constructed directly check matrix code h using pre code matching h blockquote p decoded code code l numpy array syndrome code z using pre code c z p tried example case code h repetition code syndrome pre code import numpy np pymatching import n 10 number qubits h n dtype int range h 1 h 1 p syndrome histroy pre code z array 0 1 1 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0 0 1 1 1 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 1 0 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 p getting correct corrections weird thing even take measurement error error repeat syndrome get wrong results think something incorrect please help,"[(0, 0.14240773), (2, 0.48890904), (5, 0.21433851), (6, 0.017941505), (9, 0.053294823), (13, 0.039941438), (17, 0.027667921)]"
79060676,79072024.0,2024-10-07 05:26:33,1,126,"<p>A couple of years ago, the Microsoft Quantum Development Kit was introduced for Visual Studio 2022.  However, the <a href=""https://marketplace.visualstudio.com/items?itemName=quantum.DevKit"" rel=""nofollow noreferrer"">published link</a> now returns a Page Not Found message, and searching through the Visual Studio Marketplace does not bring up any relevant tools.</p>
<p>Doing a Google search for the QDK returns results only for the VS Code extension/tools.</p>
<p>Has Microsoft discontinued QDK and Q# support for the full version of Visual Studio?  Is VS Code the only option now?</p>
",Are Q# and the Microsoft Quantum Development Kit available for Visual Studio 2022?,<visual-studio><quantum-computing><q#><qdk>,1,0,,,"Are Q# and the Microsoft Quantum Development Kit available for Visual Studio 2022? <p>A couple of years ago, the Microsoft Quantum Development Kit was introduced for Visual Studio 2022.  However, the <a href=""https://marketplace.visualstudio.com/items?itemName=quantum.DevKit"" rel=""nofollow noreferrer"">published link</a> now returns a Page Not Found message, and searching through the Visual Studio Marketplace does not bring up any relevant tools.</p>
<p>Doing a Google search for the QDK returns results only for the VS Code extension/tools.</p>
<p>Has Microsoft discontinued QDK and Q# support for the full version of Visual Studio?  Is VS Code the only option now?</p>
",so_new,q microsoft quantum development kit available visual studio 2022 p couple years ago microsoft quantum development kit introduced visual studio however https nofollow noreferrer published link returns page found message searching visual studio marketplace bring relevant p google search qdk returns results vs code p microsoft discontinued qdk q support full version visual studio vs code option,"[(4, 0.12556131), (7, 0.12032303), (8, 0.26050004), (10, 0.04106736), (12, 0.24792719), (13, 0.035539385), (14, 0.10785057), (17, 0.0591306)]"
40071,40096.0,2024-10-09 12:47:41,1,44,"<p>I'm doing exercises 5.2.6 and 5.2.7 in Quantum Information Theory by Wilde. In 5.2.6, it asks us to show that an isometric extension of the erasure channel is
<span class=""math-container"">\begin{align}
U &amp;\overset{a}{=} \sqrt{1-\epsilon}(|0\rangle_B\langle0|_A+|1\rangle_B\langle1|_A \otimes|e\rangle_E)+\sqrt{\epsilon}|e\rangle_B\langle0|_A\otimes |0\rangle_E + \sqrt{\epsilon}|e\rangle_B\langle1|_A\otimes |1\rangle_E\\
&amp;\overset{b}{=}\sqrt{1-\epsilon}I_{A\to B} \otimes |e\rangle_E + \sqrt{\epsilon}I_{A\to E} \otimes |e\rangle_B.
\end{align}</span>
The Kraus representations of the erasure channel are given before, and by the connection between the isometric extension and Kraus representation, we have the equality <span class=""math-container"">$a$</span>. Then I have the following question:</p>
<p>To show the equality <span class=""math-container"">$b$</span> holds, I found that
<span class=""math-container"">\begin{align}
|0\rangle_B\langle0|_A+|1\rangle_B\langle1|_A = I_{A\to B},\\
\langle0|_A\otimes |0\rangle_E +\langle1|_A\otimes |1\rangle_E = I_{A\to E}.
\end{align}</span>
But this gives <span class=""math-container"">$\sqrt{1-\epsilon}I_{A\to B} \otimes |e\rangle_E + \sqrt{\epsilon}|e\rangle_B I_{A\to E} $</span>, while obviously <span class=""math-container"">$|e\rangle_B I_{A\to E} \neq  I_{A\to E} \otimes |e\rangle_B$</span>. Why is that?</p>
",About the isometric extension of the erasure channel,<quantum-state><textbook-and-exercises><linear-algebra>,1,0,,,"About the isometric extension of the erasure channel <p>I'm doing exercises 5.2.6 and 5.2.7 in Quantum Information Theory by Wilde. In 5.2.6, it asks us to show that an isometric extension of the erasure channel is
<span class=""math-container"">\begin{align}
U &amp;\overset{a}{=} \sqrt{1-\epsilon}(|0\rangle_B\langle0|_A+|1\rangle_B\langle1|_A \otimes|e\rangle_E)+\sqrt{\epsilon}|e\rangle_B\langle0|_A\otimes |0\rangle_E + \sqrt{\epsilon}|e\rangle_B\langle1|_A\otimes |1\rangle_E\\
&amp;\overset{b}{=}\sqrt{1-\epsilon}I_{A\to B} \otimes |e\rangle_E + \sqrt{\epsilon}I_{A\to E} \otimes |e\rangle_B.
\end{align}</span>
The Kraus representations of the erasure channel are given before, and by the connection between the isometric extension and Kraus representation, we have the equality <span class=""math-container"">$a$</span>. Then I have the following question:</p>
<p>To show the equality <span class=""math-container"">$b$</span> holds, I found that
<span class=""math-container"">\begin{align}
|0\rangle_B\langle0|_A+|1\rangle_B\langle1|_A = I_{A\to B},\\
\langle0|_A\otimes |0\rangle_E +\langle1|_A\otimes |1\rangle_E = I_{A\to E}.
\end{align}</span>
But this gives <span class=""math-container"">$\sqrt{1-\epsilon}I_{A\to B} \otimes |e\rangle_E + \sqrt{\epsilon}|e\rangle_B I_{A\to E} $</span>, while obviously <span class=""math-container"">$|e\rangle_B I_{A\to E} \neq  I_{A\to E} \otimes |e\rangle_B$</span>. Why is that?</p>
",qc,isometric extension erasure channel p exercises quantum information theory wilde asks us show isometric extension erasure channel span align u amp amp b b e align kraus representations erasure channel given connection isometric extension kraus representation equality span following question p show equality span b holds found span align b e align gives span b e obviously span e e,"[(3, 0.72037894), (13, 0.030592082), (15, 0.14715175), (17, 0.09921824)]"
40079,,2024-10-09 20:00:15,1,61,"<p>I'm considering the repetition code in presence of measurement and qubit error as discussed in SEC IV B of <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""nofollow noreferrer"">this paper</a>. I am trying to use pymatching for the syndrome decoding using mwvp in presence of qubit error, so it should work but it doesn't. First, I defined the basis setup</p>
<pre><code>import numpy as np
from pymatching import Matching
N = 10 # num of qubits
H = np.zeros((N-1,N), dtype = int) # check-matrix

for i in range(N-1):
    H[i,i] = 1
    H[i,(i+1)] = 1
</code></pre>
<p>Consider the following syndrome measurement :</p>
<pre><code>L = 10
z = np.array([[0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
              [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
              [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
              [1, 1, 1, 0, 0, 0, 0, 0, 0, 1],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
              [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
              [1, 1, 1, 1, 1, 1, 1, 0, 0, 0]])
</code></pre>
<p>Here <code>z[:,i]</code> represents the syndrome measurements at time <span class=""math-container"">$t = i$</span>. The decoding can be done as follow:</p>
<pre><code>m = Matching(H, repetitions=L)
c = m.decode(z)
np.array([0, 0, 0, 0, 1, 1, 0, 0, 1, 0], dtype=uint8)
</code></pre>
<p>but the corrections are incorrect. On the other hand, if I just take the final syndrome at <span class=""math-container"">$t = L$</span> then</p>
<pre><code>m = Matching(H)
z = z[:,-1]
c = m.decode(z)
np.array([0, 1, 1, 0, 0, 1, 0, 0, 0, 0], dtype=uint8)
</code></pre>
<p>which in fact the correct correction operators. I want to know why does the repetition approach gives the wrong result, and way to improve upon that. Thanks</p>
",PyMatching in presence of qubit error for the repetition code,<error-correction><stabilizer-code><fault-tolerance><pymatching><minimum-weight-perfect-matching>,1,0,,,"PyMatching in presence of qubit error for the repetition code <p>I'm considering the repetition code in presence of measurement and qubit error as discussed in SEC IV B of <a href=""https://arxiv.org/abs/quant-ph/0110143"" rel=""nofollow noreferrer"">this paper</a>. I am trying to use pymatching for the syndrome decoding using mwvp in presence of qubit error, so it should work but it doesn't. First, I defined the basis setup</p>
<pre><code>import numpy as np
from pymatching import Matching
N = 10 # num of qubits
H = np.zeros((N-1,N), dtype = int) # check-matrix

for i in range(N-1):
    H[i,i] = 1
    H[i,(i+1)] = 1
</code></pre>
<p>Consider the following syndrome measurement :</p>
<pre><code>L = 10
z = np.array([[0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
              [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
              [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
              [1, 1, 1, 0, 0, 0, 0, 0, 0, 1],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
              [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
              [1, 1, 1, 1, 1, 1, 1, 0, 0, 0]])
</code></pre>
<p>Here <code>z[:,i]</code> represents the syndrome measurements at time <span class=""math-container"">$t = i$</span>. The decoding can be done as follow:</p>
<pre><code>m = Matching(H, repetitions=L)
c = m.decode(z)
np.array([0, 0, 0, 0, 1, 1, 0, 0, 1, 0], dtype=uint8)
</code></pre>
<p>but the corrections are incorrect. On the other hand, if I just take the final syndrome at <span class=""math-container"">$t = L$</span> then</p>
<pre><code>m = Matching(H)
z = z[:,-1]
c = m.decode(z)
np.array([0, 1, 1, 0, 0, 1, 0, 0, 0, 0], dtype=uint8)
</code></pre>
<p>which in fact the correct correction operators. I want to know why does the repetition approach gives the wrong result, and way to improve upon that. Thanks</p>
",qc,pymatching presence qubit error repetition code p considering repetition code presence measurement qubit error discussed sec iv b https nofollow noreferrer paper trying use pymatching syndrome decoding using mwvp presence qubit error work first defined basis setup pre code import numpy np pymatching import matching n 10 num qubits h n dtype int range h 1 h 1 p consider following syndrome measurement pre code l 10 z 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 0 0 0 p code z represents syndrome measurements time span decoding done follow pre code matching h c z 0 0 0 0 1 1 0 0 1 0 p corrections incorrect hand take final syndrome span l pre code matching h z z c z 0 1 1 0 0 1 0 0 0 0 p fact correct correction operators want know repetition approach gives wrong result way improve upon thanks,"[(0, 0.09032468), (2, 0.5682188), (3, 0.060333606), (4, 0.022487488), (5, 0.17067938), (6, 0.015293793), (9, 0.03784181), (17, 0.03429185)]"
40088,,2024-10-10 17:15:43,1,38,"<p>I am new to quantum computing, though I am by now familiar with certain jargon but have miles to go before I gain a foothold on the subject. I have been trying very hard to understand and interpret the output for portfolio optimization of VQE.</p>
<p>To begin with, I am comfortable executing program of Qiskit. I specifically require help with interpreting the output of VQE and QAOA in the following program (<a href=""https://qiskit-community.github.io/qiskit-finance/tutorials/01_portfolio_optimization.html"" rel=""nofollow noreferrer"">Qiskit PO</a>)
Optimal: selection [1. 0. 0. 1.], value -0.0149</p>
<p><a href=""https://i.sstatic.net/oTBm0tJA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/oTBm0tJA.png"" alt=""The image contains the output displayed from the link for the program from IMB's official site"" /></a></p>
<p>I believe the first column is the asset combination that should be present in the portfolio, the decimal values that we see in the middle column are the energy values, and we are looking at the lowest energy level as the answer. I am not able to understand the third column. <strong>Could someone help?</strong></p>
",Interpretation of output for Portfolio optimization program,<vqe><optimization><qaoa><quantum-computing-for-finance>,1,0,,,"Interpretation of output for Portfolio optimization program <p>I am new to quantum computing, though I am by now familiar with certain jargon but have miles to go before I gain a foothold on the subject. I have been trying very hard to understand and interpret the output for portfolio optimization of VQE.</p>
<p>To begin with, I am comfortable executing program of Qiskit. I specifically require help with interpreting the output of VQE and QAOA in the following program (<a href=""https://qiskit-community.github.io/qiskit-finance/tutorials/01_portfolio_optimization.html"" rel=""nofollow noreferrer"">Qiskit PO</a>)
Optimal: selection [1. 0. 0. 1.], value -0.0149</p>
<p><a href=""https://i.sstatic.net/oTBm0tJA.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/oTBm0tJA.png"" alt=""The image contains the output displayed from the link for the program from IMB's official site"" /></a></p>
<p>I believe the first column is the asset combination that should be present in the portfolio, the decimal values that we see in the middle column are the energy values, and we are looking at the lowest energy level as the answer. I am not able to understand the third column. <strong>Could someone help?</strong></p>
",qc,interpretation output portfolio optimization program p new quantum computing though familiar certain jargon miles go gain foothold subject trying hard understand interpret output portfolio optimization p begin comfortable executing program qiskit specifically require help interpreting output vqe qaoa following program https nofollow noreferrer qiskit po optimal selection 1 0 0 1 value p https nofollow noreferrer img https image contains output displayed link program imb official site p believe first column asset combination present portfolio decimal values see middle column energy values looking lowest energy level answer able understand third column strong could someone help,"[(2, 0.045289233), (4, 0.22630474), (8, 0.41381878), (12, 0.011043606), (13, 0.121032886), (14, 0.082528725), (17, 0.098555386)]"
40162,40163.0,2024-10-21 08:46:37,2,127,"<p>Given a stablizer expression (parity check matrix) of a quantum error correction code, how to obtain its system Hamitonian? I am not sure whether this is correct: for toric code, its Hamitonian is just to substract all the stabilizer. Assume the stabilizer for toric code is <span class=""math-container"">$A_s=\otimes_j \sigma^Z_j$</span> and <span class=""math-container"">$B_p=\otimes_j \sigma^X_j$</span> on the loop of lattice and dual lattice, the system Hamitonian is <span class=""math-container"">$H = -\sum_sA_s -\sum_p B_p$</span>. Refer to <a href=""https://arxiv.org/abs/quant-ph/9707021"" rel=""nofollow noreferrer"">1</a></p>
<p>If my understanding for toric code is correct, is the approach correct for all quantum error correction codes?</p>
",Stablizer expression(parity check matrix) to system Hamitonian for a quantum error correction code,<error-correction><stabilizer-code><surface-code>,1,0,,,"Stablizer expression(parity check matrix) to system Hamitonian for a quantum error correction code <p>Given a stablizer expression (parity check matrix) of a quantum error correction code, how to obtain its system Hamitonian? I am not sure whether this is correct: for toric code, its Hamitonian is just to substract all the stabilizer. Assume the stabilizer for toric code is <span class=""math-container"">$A_s=\otimes_j \sigma^Z_j$</span> and <span class=""math-container"">$B_p=\otimes_j \sigma^X_j$</span> on the loop of lattice and dual lattice, the system Hamitonian is <span class=""math-container"">$H = -\sum_sA_s -\sum_p B_p$</span>. Refer to <a href=""https://arxiv.org/abs/quant-ph/9707021"" rel=""nofollow noreferrer"">1</a></p>
<p>If my understanding for toric code is correct, is the approach correct for all quantum error correction codes?</p>
",qc,stablizer expression parity check matrix system hamitonian quantum error correction code p given stablizer expression parity check matrix quantum error correction code obtain system hamitonian sure whether correct toric code hamitonian substract stabilizer assume stabilizer toric code span span loop lattice dual lattice system hamitonian span h refer https nofollow noreferrer 1 p understanding toric code correct approach correct quantum error correction codes,"[(1, 0.09052083), (3, 0.1695419), (5, 0.41567904), (7, 0.21073964), (11, 0.027462063), (16, 0.032295205), (17, 0.05169844)]"
40202,,2024-10-24 08:28:42,0,71,"<p>Let <span class=""math-container"">$\sigma_{XA}= \sum_x p_X(x)  \Pi_x \otimes \Phi_A $</span>  where <span class=""math-container"">$\Pi_x$</span> is the projector onto <span class=""math-container"">$x$</span> and <span class=""math-container"">$\Phi$</span> is a pure state. The output state after applying the depolarizing channel <span class=""math-container"">$D_p$</span> is
<span class=""math-container"">$$\omega_{XB}= (id \otimes D_p)(\sigma_{XA}) = \sum_x p_X(x) \Pi_x \otimes ((1-p) \Phi + p \tau),$$</span>
where <span class=""math-container"">$\tau$</span> denotes the maximally mixed state.
Consider the output of the completely randomizing channel <span class=""math-container"">$\rho_{XB} = \sum_x p_X(x) \Pi_x \otimes \tau_B$</span>.
Now according to eq. 20.111 in Wilde's quantum information theory book by the concavity of the entropy, that is
<span class=""math-container"">$$H(\sum_x p_X(x) \rho^x)\geq \sum_x p_X(x) H(\rho^x),$$</span>
it holds that the
<span class=""math-container"">$$H(B)_{\omega} =H(Tr_X \omega_{XB})= H(\sum_x p_X(x) ((1-p) \Phi + p \tau)) \leq H(B)_{\rho} = H(Tr_X \rho_{XB})= H(\sum_x p_X(x) \tau) $$</span>
How does one derive the latter upper bound via the concavity of the entropy?</p>
",How does the upper bound on the entropy of the depolarizing channel follow from the concavity of von Neumann entropy?,<quantum-state><textbook-and-exercises><entropy>,0,6,,,"How does the upper bound on the entropy of the depolarizing channel follow from the concavity of von Neumann entropy? <p>Let <span class=""math-container"">$\sigma_{XA}= \sum_x p_X(x)  \Pi_x \otimes \Phi_A $</span>  where <span class=""math-container"">$\Pi_x$</span> is the projector onto <span class=""math-container"">$x$</span> and <span class=""math-container"">$\Phi$</span> is a pure state. The output state after applying the depolarizing channel <span class=""math-container"">$D_p$</span> is
<span class=""math-container"">$$\omega_{XB}= (id \otimes D_p)(\sigma_{XA}) = \sum_x p_X(x) \Pi_x \otimes ((1-p) \Phi + p \tau),$$</span>
where <span class=""math-container"">$\tau$</span> denotes the maximally mixed state.
Consider the output of the completely randomizing channel <span class=""math-container"">$\rho_{XB} = \sum_x p_X(x) \Pi_x \otimes \tau_B$</span>.
Now according to eq. 20.111 in Wilde's quantum information theory book by the concavity of the entropy, that is
<span class=""math-container"">$$H(\sum_x p_X(x) \rho^x)\geq \sum_x p_X(x) H(\rho^x),$$</span>
it holds that the
<span class=""math-container"">$$H(B)_{\omega} =H(Tr_X \omega_{XB})= H(\sum_x p_X(x) ((1-p) \Phi + p \tau)) \leq H(B)_{\rho} = H(Tr_X \rho_{XB})= H(\sum_x p_X(x) \tau) $$</span>
How does one derive the latter upper bound via the concavity of the entropy?</p>
",qc,upper bound entropy depolarizing channel follow concavity von neumann entropy p let span xa x span projector onto span x span pure state output state applying depolarizing channel span span xb id xa x p span denotes maximally mixed state consider output completely randomizing channel span xb x according eq wilde quantum information theory book concavity entropy span h x x h holds span h b xb h x p h b h xb h x one derive latter upper bound via concavity entropy,"[(3, 0.70429856), (10, 0.122161254), (15, 0.13020791), (17, 0.04140876)]"
40207,40208.0,2024-10-24 19:23:00,2,133,"<p>I am trying to run my below code on FakeSherbrooke() system, but I am getting an error as shown below:
<code>The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits</code>.</p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.providers.aer import AerSimulator

from qiskit.utils import QuantumInstance
from qiskit.providers.fake_provider import FakeSherbrooke
from qiskit.algorithms import VQE
# backend = Aer.get_backend('qasm_simulator')
# backend = AerSimulator()
backend = FakeSherbrooke()
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Really not sure why I am getting this error and how to resolve it. This code is using <code>qiskit== 0.46</code>.
I also tested the <code>qiskit==1.0</code> version of the above code and I still get this error.</p>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_aer import AerSimulator

import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2

from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aer.primitives import Estimator as Estimator
from qiskit_ibm_runtime.fake_provider import  FakeSherbrooke

backend = AerSimulator()
# backend = FakeSherbrooke()

Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]

H_op = SparsePauliOp.from_operator(Hamiltonian)

ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)

pm = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    basis_gates=None,
    seed_transpiler=28
)
ansatz_opt = pm.run(ansatz)

optimizer = COBYLA(maxiter= 1500)

estimator = Estimator(
    run_options = {&quot;shots&quot;: 1024, &quot;seed&quot;: 28},
)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)

vqe = VQE(
    estimator=estimator,
    ansatz=ansatz_opt,
    optimizer=optimizer,
    initial_point=initial_point_values
)

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Any way to correct this error?</p>
",The number of qubits of the ansatz does not match the operator,<qiskit><programming><vqe>,1,0,,,"The number of qubits of the ansatz does not match the operator <p>I am trying to run my below code on FakeSherbrooke() system, but I am getting an error as shown below:
<code>The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using num_qubits</code>.</p>
<pre><code>from qiskit import transpile
from qiskit import Aer
import numpy as np
from qiskit.opflow import MatrixOp
from qiskit.circuit.library import EfficientSU2
from qiskit.algorithms.optimizers import COBYLA
from qiskit.providers.aer import AerSimulator

from qiskit.utils import QuantumInstance
from qiskit.providers.fake_provider import FakeSherbrooke
from qiskit.algorithms import VQE
# backend = Aer.get_backend('qasm_simulator')
# backend = AerSimulator()
backend = FakeSherbrooke()
Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]
H_op = MatrixOp(Hamiltonian).to_pauli_op()
ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)
ansatz_opt = transpile(circuits=ansatz,
                            backend = backend,
                            optimization_level =3)
optimizer = COBYLA(maxiter= 1500)
quantum_instance = QuantumInstance(backend= backend,
                                        shots= 1024,     # default is 1024   # changing the number of shots to 32M
                                        seed_simulator= 28,    ##
                                        seed_transpiler= 28,
                                        basis_gates= None,
                                        optimization_level=2)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)
vqe = VQE(ansatz=ansatz_opt,
        optimizer= optimizer,
        quantum_instance=quantum_instance,
        initial_point=initial_point_values
        )

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Really not sure why I am getting this error and how to resolve it. This code is using <code>qiskit== 0.46</code>.
I also tested the <code>qiskit==1.0</code> version of the above code and I still get this error.</p>
<pre><code>from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

from qiskit_aer import AerSimulator

import numpy as np

from qiskit.quantum_info import SparsePauliOp
from qiskit.circuit.library import EfficientSU2

from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import COBYLA

from qiskit_aer.primitives import Estimator as Estimator
from qiskit_ibm_runtime.fake_provider import  FakeSherbrooke

backend = AerSimulator()
# backend = FakeSherbrooke()

Hamiltonian = [
    [ 4.07981221, -3.6713615 ,  1.3943662 , -1.05164319],
    [-3.6713615 ,  5.88262911, -4.14084507,  1.37558685],
    [ 1.3943662 , -4.14084507,  5.83098592, -3.54929577],
    [-1.05164319,  1.37558685, -3.54929577,  3.79812207]
]

H_op = SparsePauliOp.from_operator(Hamiltonian)

ansatz = EfficientSU2(num_qubits=2,
                    entanglement= 'linear',
                    reps= 5,
                    skip_final_rotation_layer= True)

pm = generate_preset_pass_manager(
    optimization_level=3,
    backend=backend,
    basis_gates=None,
    seed_transpiler=28
)
ansatz_opt = pm.run(ansatz)

optimizer = COBYLA(maxiter= 1500)

estimator = Estimator(
    run_options = {&quot;shots&quot;: 1024, &quot;seed&quot;: 28},
)

initial_point_values = 2*np.pi*np.random.rand(ansatz_opt.num_parameters)

vqe = VQE(
    estimator=estimator,
    ansatz=ansatz_opt,
    optimizer=optimizer,
    initial_point=initial_point_values
)

result = vqe.compute_minimum_eigenvalue(H_op)
print(result)
</code></pre>
<p>Any way to correct this error?</p>
",qc,number qubits ansatz match operator p trying run code fakesherbrooke system getting error shown code number qubits ansatz match operator ansatz allow setting number qubits using pre code qiskit import transpile qiskit import aer import numpy np import matrixop import efficientsu2 import cobyla import aersimulator import quantuminstance import fakesherbrooke import vqe backend backend aersimulator backend fakesherbrooke hamiltonian matrixop hamiltonian ansatz efficientsu2 5 true transpile backend backend optimizer cobyla 1500 quantuminstance backend 1024 default 1024 changing number shots 32m 28 28 none 2 vqe vqe optimizer result print result p really sure getting error resolve code using code also tested code version code still get pre code import import aersimulator import numpy np import sparsepauliop import efficientsu2 import vqe import cobyla import estimator estimator import fakesherbrooke backend aersimulator backend fakesherbrooke hamiltonian hamiltonian ansatz efficientsu2 5 true pm ansatz optimizer cobyla 1500 estimator estimator quot shots quot 1024 quot seed quot 28 2 vqe vqe result print result p way correct error,"[(0, 0.84651834), (1, 0.022624645), (12, 0.025401415), (16, 0.027052997), (17, 0.056164283), (19, 0.021358494)]"
40254,,2024-10-30 18:31:52,0,23,"<p>I am trying to simulate some simple dynamical decoupling sequences on AerSimulator with custom noise. Right now, I have <a href=""https://i.sstatic.net/H3HoRDlO.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/H3HoRDlO.png"" alt=""qc sequence"" /></a> for the qc with DD, and <span class=""math-container"">$R_Y$</span> removed for the qc without DD</p>
<p>Then I implemented the noise model only on the 'id' gate with noise_model.add_all_qubit_quantum_error(error, ['id']) and have tried different error types like
depolarizing error, thermal relaxation, amplitude damping and phase damping error</p>
<p>However, when I do the simulation with <code>AerSimulator().run(qc, shots=8000, noise_model=noise_model).result()</code> with the qc with and without DD, I saw no difference in .get_counts and the two circuit showed identical result (for all the noise models).</p>
<p>Is there any reason why this implementation would not work? Is it due to me not using the correct noise for DD to work?</p>
<p>edit:
Here is my code</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_histogram
from qiskit_aer import noise
from qiskit_aer import AerSimulator

qc_no_dd = QuantumCircuit(1, 1)
qc_no_dd.rx(np.pi/2, 0)
qc_no_dd.barrier()
for i in range(6):
    qc_no_dd.id(0)
    qc_no_dd.id(0)
qc_no_dd.barrier()
qc_no_dd.rx(np.pi/2, 0)
qc_no_dd.measure(0, 0)

qc_dd = QuantumCircuit(1,1)
qc_dd.rx(np.pi/2, 0)
qc_dd.barrier()
for i in range(6):
    qc_dd.id(0)
    qc_dd.ry(-np.pi,0)
    qc_dd.id(0)
qc_dd.barrier()
qc_dd.rx(np.pi/2, 0)

qc_dd.measure(0, 0)

error = noise.depolarizing_error(0.03, 1)

noise_model = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error(error, ['id'])
simulator_aer = AerSimulator()

result_no_dd = simulator_aer.run(qc_no_dd, shots=8000, noise_model=noise_model).result()
result_dd = AerSimulator().run(qc_dd, shots=8000, noise_model=noise_model).result()

counts_no_dd = result_no_dd.get_counts()
counts_dd = result_dd.get_counts()

plot_histogram([counts_no_dd, counts_dd], legend=[&quot;no dd&quot;, &quot;dd&quot;], color=[&quot;red&quot;, &quot;blue&quot;])
</code></pre>
<p>I got ~1200 &quot;0&quot; and 6800 &quot;1&quot; for histogram result</p>
",Simulating effect of DD with AerSimulator,<qiskit>,0,2,,,"Simulating effect of DD with AerSimulator <p>I am trying to simulate some simple dynamical decoupling sequences on AerSimulator with custom noise. Right now, I have <a href=""https://i.sstatic.net/H3HoRDlO.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/H3HoRDlO.png"" alt=""qc sequence"" /></a> for the qc with DD, and <span class=""math-container"">$R_Y$</span> removed for the qc without DD</p>
<p>Then I implemented the noise model only on the 'id' gate with noise_model.add_all_qubit_quantum_error(error, ['id']) and have tried different error types like
depolarizing error, thermal relaxation, amplitude damping and phase damping error</p>
<p>However, when I do the simulation with <code>AerSimulator().run(qc, shots=8000, noise_model=noise_model).result()</code> with the qc with and without DD, I saw no difference in .get_counts and the two circuit showed identical result (for all the noise models).</p>
<p>Is there any reason why this implementation would not work? Is it due to me not using the correct noise for DD to work?</p>
<p>edit:
Here is my code</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.visualization import plot_histogram
from qiskit_aer import noise
from qiskit_aer import AerSimulator

qc_no_dd = QuantumCircuit(1, 1)
qc_no_dd.rx(np.pi/2, 0)
qc_no_dd.barrier()
for i in range(6):
    qc_no_dd.id(0)
    qc_no_dd.id(0)
qc_no_dd.barrier()
qc_no_dd.rx(np.pi/2, 0)
qc_no_dd.measure(0, 0)

qc_dd = QuantumCircuit(1,1)
qc_dd.rx(np.pi/2, 0)
qc_dd.barrier()
for i in range(6):
    qc_dd.id(0)
    qc_dd.ry(-np.pi,0)
    qc_dd.id(0)
qc_dd.barrier()
qc_dd.rx(np.pi/2, 0)

qc_dd.measure(0, 0)

error = noise.depolarizing_error(0.03, 1)

noise_model = noise.NoiseModel()
noise_model.add_all_qubit_quantum_error(error, ['id'])
simulator_aer = AerSimulator()

result_no_dd = simulator_aer.run(qc_no_dd, shots=8000, noise_model=noise_model).result()
result_dd = AerSimulator().run(qc_dd, shots=8000, noise_model=noise_model).result()

counts_no_dd = result_no_dd.get_counts()
counts_dd = result_dd.get_counts()

plot_histogram([counts_no_dd, counts_dd], legend=[&quot;no dd&quot;, &quot;dd&quot;], color=[&quot;red&quot;, &quot;blue&quot;])
</code></pre>
<p>I got ~1200 &quot;0&quot; and 6800 &quot;1&quot; for histogram result</p>
",qc,simulating effect dd aersimulator p trying simulate simple dynamical decoupling sequences aersimulator custom noise right https nofollow noreferrer img https qc sequence qc dd span removed qc without dd p implemented noise model gate error tried different error types like depolarizing error thermal relaxation amplitude damping phase damping error p however simulation code aersimulator qc qc without dd saw difference two circuit showed identical result noise models p reason implementation would work due using correct noise dd work p edit code pre code import numpy np qiskit import quantumcircuit import import noise import aersimulator quantumcircuit 1 1 0 range 6 0 0 0 0 0 quantumcircuit 0 range 6 0 0 0 0 0 error 1 error aersimulator aersimulator quot dd quot quot dd quot quot red quot quot blue quot p got quot 0 quot 6800 quot 1 quot histogram result,"[(0, 0.24484242), (2, 0.12357037), (4, 0.07281543), (5, 0.066441074), (6, 0.022406114), (8, 0.025787063), (9, 0.08127086), (14, 0.1726871), (17, 0.087288514), (19, 0.10218263)]"
40281,,2024-11-02 03:57:21,2,70,"<p>Let <span class=""math-container"">$\mathcal E$</span> be a set of errors that can be corrected by a QECC <span class=""math-container"">$\mathcal C$</span>. If <span class=""math-container"">$C$</span> is degenerate, then there are two distinct errors <span class=""math-container"">$E_1, E_2 \in \mathcal E$</span> such that <span class=""math-container"">$E_1 |\psi \rangle = E_2 |\psi \rangle$</span> for all <span class=""math-container"">$| \psi \rangle$</span> in <span class=""math-container"">$\mathcal C$</span>. Since <span class=""math-container"">$\mathcal E$</span> is a vector space, <span class=""math-container"">$E_1 - E_2 = E \in \mathcal E$</span> so the code should be able to correct this error. However, <span class=""math-container"">$E |\psi\rangle = 0$</span> for all codewords, so how can this be corrected?</p>
",How can correcting a basis for the set of errors be enough in a degenerate code,<error-correction>,1,3,,,"How can correcting a basis for the set of errors be enough in a degenerate code <p>Let <span class=""math-container"">$\mathcal E$</span> be a set of errors that can be corrected by a QECC <span class=""math-container"">$\mathcal C$</span>. If <span class=""math-container"">$C$</span> is degenerate, then there are two distinct errors <span class=""math-container"">$E_1, E_2 \in \mathcal E$</span> such that <span class=""math-container"">$E_1 |\psi \rangle = E_2 |\psi \rangle$</span> for all <span class=""math-container"">$| \psi \rangle$</span> in <span class=""math-container"">$\mathcal C$</span>. Since <span class=""math-container"">$\mathcal E$</span> is a vector space, <span class=""math-container"">$E_1 - E_2 = E \in \mathcal E$</span> so the code should be able to correct this error. However, <span class=""math-container"">$E |\psi\rangle = 0$</span> for all codewords, so how can this be corrected?</p>
",qc,correcting basis set errors enough degenerate code p let span e set errors corrected qecc span c span c degenerate two distinct errors span e span span span c since span e vector space span e e code able correct error however span e 0 codewords corrected,"[(2, 0.022012427), (3, 0.6646767), (5, 0.23263088), (17, 0.07728963)]"
40290,40293.0,2024-11-03 08:29:54,2,49,"<p>In Gidney's <a href=""https://doi.org/10.48550/arXiv.2409.17595"" rel=""nofollow noreferrer"">paper</a> on &quot;magic state cultivation&quot; he examines injection with distances of <span class=""math-container"">$d_1 = 3$</span> and <span class=""math-container"">$d_1 = 5$</span>. As shown in both Figure 1 and Figure 2, there is a marked improvement between these distances, with <span class=""math-container"">$d_1 = 5$</span> achieving an error rate of <span class=""math-container"">$10^{-9}$</span>, which is within a few orders of magnitude of the threshold needed for practical applications.</p>
<p>I was curious whether increasing this distance further could lead to even better fidelity, reaching the region I marked with a green circle in the Figure below. Are there any challenges in doing so? If so, would this be sufficient for practical applications?</p>
<p>Additionally, as shown in Figure 16, the error rate in those regions can be dominated by the escape and memory rounds, so assume that <span class=""math-container"">$d_2$</span> also increase to reduce the error rate in these rounds.</p>
<p><a href=""https://i.sstatic.net/VCh4iFst.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VCh4iFst.png"" alt=""cost of cultivation"" /></a></p>
",Cultivation with higher injection distance,<error-correction><magic-states>,1,0,,,"Cultivation with higher injection distance <p>In Gidney's <a href=""https://doi.org/10.48550/arXiv.2409.17595"" rel=""nofollow noreferrer"">paper</a> on &quot;magic state cultivation&quot; he examines injection with distances of <span class=""math-container"">$d_1 = 3$</span> and <span class=""math-container"">$d_1 = 5$</span>. As shown in both Figure 1 and Figure 2, there is a marked improvement between these distances, with <span class=""math-container"">$d_1 = 5$</span> achieving an error rate of <span class=""math-container"">$10^{-9}$</span>, which is within a few orders of magnitude of the threshold needed for practical applications.</p>
<p>I was curious whether increasing this distance further could lead to even better fidelity, reaching the region I marked with a green circle in the Figure below. Are there any challenges in doing so? If so, would this be sufficient for practical applications?</p>
<p>Additionally, as shown in Figure 16, the error rate in those regions can be dominated by the escape and memory rounds, so assume that <span class=""math-container"">$d_2$</span> also increase to reduce the error rate in these rounds.</p>
<p><a href=""https://i.sstatic.net/VCh4iFst.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/VCh4iFst.png"" alt=""cost of cultivation"" /></a></p>
",qc,cultivation higher injection distance p gidney https nofollow noreferrer paper quot magic state cultivation quot examines injection distances span 3 span 5 shown figure 1 figure 2 marked improvement distances span 5 achieving error rate span within orders magnitude threshold needed practical p curious whether increasing distance could lead even better fidelity reaching region marked green circle figure challenges would sufficient practical applications p additionally shown figure 16 error rate regions dominated escape memory rounds assume span also increase reduce error rate p https nofollow noreferrer img https cost cultivation,"[(3, 0.14100702), (4, 0.23872039), (5, 0.2083353), (6, 0.07038189), (8, 0.16264665), (13, 0.075042464), (17, 0.036994398), (18, 0.022791602), (19, 0.042829897)]"
40343,40344.0,2024-11-07 16:39:59,2,41,"<p>I am trying to understand how Qiskit's gates work by comparing the outputs of a simple circuit with numpy matrix algebra.</p>
<p>If I start with two qubits and apply a rotation gate to each of them, I get:</p>
<pre><code>import numpy as np
import qiskit as qk
from qiskit.quantum_info.operators import Operator
from qiskit_aer import StatevectorSimulator

xlist = np.array([5,3])
x = xlist/np.linalg.norm(xlist)
y = 1/np.sqrt(2)*np.array([1,1])

circuit = qk.QuantumCircuit(2,1)
circuit.initialize(x, [0])
circuit.initialize(y, [1])

# apply rotations
theta = 0.313
H0 = np.array([[np.cos(theta), np.sin(theta)], [np.sin(theta), -np.cos(theta)]])
H1 = np.array([[-np.cos(theta), np.sin(theta)], [np.sin(theta), np.cos(theta)]])
circuit.unitary(Operator(H0), [0], label='H0')
circuit.unitary(Operator(H1), [1], label='H1')

simulator = StatevectorSimulator()
job = qk.transpile(circuit, simulator)  # execute circuit on qasm simulator
result = simulator.run(job,shots=128).result()  # results from the job
out_state = result.get_statevector()
print(out_state)
circuit.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/6HF8f0bB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6HF8f0bB.png"" alt=""circuit"" /></a></p>
<p>The final state is</p>
<pre><code>Statevector([-0.44330692+0.j,  0.10259143+0.j,  0.86755107+0.j,
             -0.2007713 +0.j],
            dims=(2, 2))
</code></pre>
<p>I'm trying to replicate this result by using numpy's functions:</p>
<pre><code>x1 = np.array([[5],[3]])
x1 = x1/np.linalg.norm(x1)
y1 = 1/np.sqrt(2)*np.array([[1],[1]])
z1 = np.kron(x1, y1)
z1 = z1/np.linalg.norm(z1)

cx = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])
z1 = np.matmul(cx, z1)  # entangled state??

# define 4x4 rotation matrix
rotate1 = np.zeros((4, 4))
rotate1[0:2, 0:2] = H0
rotate1[2:4, 2:4] = H1

# apply rotation
print(np.matmul(rotate1, z1))
</code></pre>
<p>The final state is</p>
<pre><code>[[ 0.68889981]
 [-0.15942728]
 [-0.46485927]
 [ 0.53282817]]
</code></pre>
<p>Why does this not agree with the Qiskit result?  I'm not sure what I'm missing.  I know that <code>z1 = np.matmul(cx, z1)</code> gives a result that agrees with the circuit output (when there are no <code>H0</code> and <code>H1</code> gates).</p>
",Comparing Qiskit gates with numpy functions,<qiskit><programming>,1,0,,,"Comparing Qiskit gates with numpy functions <p>I am trying to understand how Qiskit's gates work by comparing the outputs of a simple circuit with numpy matrix algebra.</p>
<p>If I start with two qubits and apply a rotation gate to each of them, I get:</p>
<pre><code>import numpy as np
import qiskit as qk
from qiskit.quantum_info.operators import Operator
from qiskit_aer import StatevectorSimulator

xlist = np.array([5,3])
x = xlist/np.linalg.norm(xlist)
y = 1/np.sqrt(2)*np.array([1,1])

circuit = qk.QuantumCircuit(2,1)
circuit.initialize(x, [0])
circuit.initialize(y, [1])

# apply rotations
theta = 0.313
H0 = np.array([[np.cos(theta), np.sin(theta)], [np.sin(theta), -np.cos(theta)]])
H1 = np.array([[-np.cos(theta), np.sin(theta)], [np.sin(theta), np.cos(theta)]])
circuit.unitary(Operator(H0), [0], label='H0')
circuit.unitary(Operator(H1), [1], label='H1')

simulator = StatevectorSimulator()
job = qk.transpile(circuit, simulator)  # execute circuit on qasm simulator
result = simulator.run(job,shots=128).result()  # results from the job
out_state = result.get_statevector()
print(out_state)
circuit.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/6HF8f0bB.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/6HF8f0bB.png"" alt=""circuit"" /></a></p>
<p>The final state is</p>
<pre><code>Statevector([-0.44330692+0.j,  0.10259143+0.j,  0.86755107+0.j,
             -0.2007713 +0.j],
            dims=(2, 2))
</code></pre>
<p>I'm trying to replicate this result by using numpy's functions:</p>
<pre><code>x1 = np.array([[5],[3]])
x1 = x1/np.linalg.norm(x1)
y1 = 1/np.sqrt(2)*np.array([[1],[1]])
z1 = np.kron(x1, y1)
z1 = z1/np.linalg.norm(z1)

cx = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])
z1 = np.matmul(cx, z1)  # entangled state??

# define 4x4 rotation matrix
rotate1 = np.zeros((4, 4))
rotate1[0:2, 0:2] = H0
rotate1[2:4, 2:4] = H1

# apply rotation
print(np.matmul(rotate1, z1))
</code></pre>
<p>The final state is</p>
<pre><code>[[ 0.68889981]
 [-0.15942728]
 [-0.46485927]
 [ 0.53282817]]
</code></pre>
<p>Why does this not agree with the Qiskit result?  I'm not sure what I'm missing.  I know that <code>z1 = np.matmul(cx, z1)</code> gives a result that agrees with the circuit output (when there are no <code>H0</code> and <code>H1</code> gates).</p>
",qc,comparing qiskit gates numpy functions p trying understand qiskit gates work comparing outputs simple circuit numpy matrix p start two qubits apply rotation gate get pre code import numpy np import qiskit qk import operator import statevectorsimulator xlist x xlist 2 circuit x 0 1 apply rotations theta h0 theta theta theta theta h1 theta theta theta theta operator h0 0 operator h1 1 simulator statevectorsimulator job circuit simulator execute circuit qasm simulator result job results job print p https nofollow noreferrer img https circuit p final state pre code statevector 2 2 p trying replicate result using numpy functions pre code x1 5 3 x1 x1 y1 2 1 1 z1 x1 y1 z1 z1 cx 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 z1 cx z1 entangled state define 4x4 rotation matrix rotate1 4 4 rotate1 h0 rotate1 h1 apply rotation print rotate1 z1 p final state pre code p agree qiskit result sure missing know code z1 cx z1 gives result agrees circuit output code h0 code h1 gates,"[(0, 0.5186071), (2, 0.17901477), (4, 0.059663728), (6, 0.028637616), (7, 0.016975401), (9, 0.05139759), (17, 0.08811303), (18, 0.048722774)]"
40360,40361.0,2024-11-09 22:43:28,1,32,"<p>I built this Qiskit Circuit and I need help to access inside U3 gates parameters defined by Qiskit itself. Here's my code:</p>
<pre><code>import qiskit
import numpy as np
import math
from scipy.linalg import expm as expMatrix # Added after a comment

N_features=2

N_QUBITS=math.ceil(np.log2(N_features)+1) #Circuit number of QuBits
QUBITS=[i for i in range(N_QUBITS)]

qc = QuantumCircuit(N_QUBITS)
qc.h(QUBITS)

tx = np.random.rand(N_features)
tw = np.random.rand(N_features)
sigmaE = np.diag(tx)*tw.T

matrix_pauli_x=np.array([[0,1],[1,0]]) # Pauli x
matrix_pauli_y=np.array([[0,-1j],[1j,0]]) # Pauli y
matrix_pauli_z=np.array([[1,0],[0,-1]]) # Pauli z
sigmaQ=matrix_pauli_x+matrix_pauli_y+matrix_pauli_z 
  
#Unitary Operator
U=np.matrix(expMatrix(1j*np.kron(sigmaQ,sigmaE)))
qc.unitary(U,QUBITS)
display(qc.draw(&quot;mpl&quot;))

tqc=transpile(qc, optimization_level=3, basis_gates=[&quot;u3&quot;, &quot;cx&quot;], seed_transpiler=1)
display(tqc.draw(&quot;mpl&quot;))
</code></pre>
<p>The outputs:
<a href=""https://i.sstatic.net/51OOQSgH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/51OOQSgH.png"" alt=""Quantum Circuit Generated by Qiskit"" /></a>
<a href=""https://i.sstatic.net/eAk042qv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eAk042qv.png"" alt=""Transpiled Quantum Circuit"" /></a></p>
<p>I need to access the complete range of the parameters inside the U3 gates <strong>after</strong> the transpilation without looking one by one. Is it possible?</p>
",Is there a way to access all inside U3 gate parameters in Qiskit Transpiled Quantum Circuit without looking one by one?,<qiskit><quantum-circuit>,1,0,,,"Is there a way to access all inside U3 gate parameters in Qiskit Transpiled Quantum Circuit without looking one by one? <p>I built this Qiskit Circuit and I need help to access inside U3 gates parameters defined by Qiskit itself. Here's my code:</p>
<pre><code>import qiskit
import numpy as np
import math
from scipy.linalg import expm as expMatrix # Added after a comment

N_features=2

N_QUBITS=math.ceil(np.log2(N_features)+1) #Circuit number of QuBits
QUBITS=[i for i in range(N_QUBITS)]

qc = QuantumCircuit(N_QUBITS)
qc.h(QUBITS)

tx = np.random.rand(N_features)
tw = np.random.rand(N_features)
sigmaE = np.diag(tx)*tw.T

matrix_pauli_x=np.array([[0,1],[1,0]]) # Pauli x
matrix_pauli_y=np.array([[0,-1j],[1j,0]]) # Pauli y
matrix_pauli_z=np.array([[1,0],[0,-1]]) # Pauli z
sigmaQ=matrix_pauli_x+matrix_pauli_y+matrix_pauli_z 
  
#Unitary Operator
U=np.matrix(expMatrix(1j*np.kron(sigmaQ,sigmaE)))
qc.unitary(U,QUBITS)
display(qc.draw(&quot;mpl&quot;))

tqc=transpile(qc, optimization_level=3, basis_gates=[&quot;u3&quot;, &quot;cx&quot;], seed_transpiler=1)
display(tqc.draw(&quot;mpl&quot;))
</code></pre>
<p>The outputs:
<a href=""https://i.sstatic.net/51OOQSgH.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/51OOQSgH.png"" alt=""Quantum Circuit Generated by Qiskit"" /></a>
<a href=""https://i.sstatic.net/eAk042qv.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/eAk042qv.png"" alt=""Transpiled Quantum Circuit"" /></a></p>
<p>I need to access the complete range of the parameters inside the U3 gates <strong>after</strong> the transpilation without looking one by one. Is it possible?</p>
",qc,way access inside u3 gate parameters qiskit transpiled quantum circuit without looking one one p built qiskit circuit need help access inside u3 gates parameters defined qiskit code pre code import qiskit import numpy np import math import expm expmatrix added comment circuit number qubits range qc quantumcircuit qubits tx tw sigmae tx pauli x 0 pauli 0 pauli z unitary operator expmatrix 1j sigmaq sigmae u qubits display quot mpl quot qc quot u3 quot quot cx quot display quot mpl quot p outputs https nofollow noreferrer img https quantum circuit generated qiskit https nofollow noreferrer img https transpiled quantum circuit p need access complete range parameters inside u3 gates strong transpilation without looking one one possible,"[(0, 0.22808516), (2, 0.031140221), (4, 0.1486402), (5, 0.11461726), (14, 0.37351847), (17, 0.029650565), (19, 0.073226355)]"
40397,,2024-11-12 18:45:50,2,164,"<p>Suppose I am given a <span class=""math-container"">$n$</span>-qubits statevector <span class=""math-container"">$|\psi\rangle$</span> and a single-qubit parametric gate <span class=""math-container"">$G_i(\theta)$</span> to be applied on qubit <span class=""math-container"">$i$</span>. I want to implement from scratch a Python function to apply the parametric gate (using its symbolic representation) to the quantum state (written as a <span class=""math-container"">$n$</span>-dim symbolic tensor) and return the result.</p>
<p>Let's consider an explicit example: take <span class=""math-container"">$|\psi\rangle = |000\rangle$</span> and <span class=""math-container"">$G_i(\theta) = RX_i(\theta)$</span> where the <span class=""math-container"">$X$</span>-axis rotation gate is defined as
<span class=""math-container"">$$
RX(\theta) =
\begin{pmatrix}
\cos(\theta/2) &amp; -i \sin(\theta/2)\\
-i \sin(\theta/2) &amp; \cos(\theta/2)\\
\end{pmatrix}
$$</span>
A possible working implementation, based on <code>numpy</code> multi-dimensional arrays, would be the following:</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np
from sympy import Symbol, cos, sin, I

num_qubits = 3
shape = (2,) * num_qubits
psi = np.array([1,0,0,0,0,0,0,0]).reshape(shape)

theta = Symbol('t')
rx = np.array([[cos(theta/2), -I*sin(theta/2)],
               [-I*sin(theta/2), cos(theta/2)]])

def apply_1q_gate(state, gate, i):
    td = np.tensordot(gate, state, axes=(1, 0))
    reverse = list(range(len(state.shape)))[::-1]
    result = np.moveaxis(td, 0, i).transpose(*reverse)
    return result
</code></pre>
<p>However, this function operates using <code>numpy</code> arrays with <code>dtype=object</code>, which is extremely unnatural and inefficient since it is optimized for numerical computation. I was wandering whether it is possible to implement an equivalent function working for instance with <code>sympy</code> symbolic expressions.</p>
<p><strong>NOTE</strong>: the <code>sympy.tensor.array</code> module (see <a href=""https://docs.sympy.org/latest/modules/tensor/array.html"" rel=""nofollow noreferrer"">here</a>) may be useful!</p>
",Apply parametric gate to quantum state in symbolic tensor representation,<quantum-gate><quantum-state><linear-algebra><sympy>,1,0,,,"Apply parametric gate to quantum state in symbolic tensor representation <p>Suppose I am given a <span class=""math-container"">$n$</span>-qubits statevector <span class=""math-container"">$|\psi\rangle$</span> and a single-qubit parametric gate <span class=""math-container"">$G_i(\theta)$</span> to be applied on qubit <span class=""math-container"">$i$</span>. I want to implement from scratch a Python function to apply the parametric gate (using its symbolic representation) to the quantum state (written as a <span class=""math-container"">$n$</span>-dim symbolic tensor) and return the result.</p>
<p>Let's consider an explicit example: take <span class=""math-container"">$|\psi\rangle = |000\rangle$</span> and <span class=""math-container"">$G_i(\theta) = RX_i(\theta)$</span> where the <span class=""math-container"">$X$</span>-axis rotation gate is defined as
<span class=""math-container"">$$
RX(\theta) =
\begin{pmatrix}
\cos(\theta/2) &amp; -i \sin(\theta/2)\\
-i \sin(\theta/2) &amp; \cos(\theta/2)\\
\end{pmatrix}
$$</span>
A possible working implementation, based on <code>numpy</code> multi-dimensional arrays, would be the following:</p>
<pre class=""lang-python prettyprint-override""><code>import numpy as np
from sympy import Symbol, cos, sin, I

num_qubits = 3
shape = (2,) * num_qubits
psi = np.array([1,0,0,0,0,0,0,0]).reshape(shape)

theta = Symbol('t')
rx = np.array([[cos(theta/2), -I*sin(theta/2)],
               [-I*sin(theta/2), cos(theta/2)]])

def apply_1q_gate(state, gate, i):
    td = np.tensordot(gate, state, axes=(1, 0))
    reverse = list(range(len(state.shape)))[::-1]
    result = np.moveaxis(td, 0, i).transpose(*reverse)
    return result
</code></pre>
<p>However, this function operates using <code>numpy</code> arrays with <code>dtype=object</code>, which is extremely unnatural and inefficient since it is optimized for numerical computation. I was wandering whether it is possible to implement an equivalent function working for instance with <code>sympy</code> symbolic expressions.</p>
<p><strong>NOTE</strong>: the <code>sympy.tensor.array</code> module (see <a href=""https://docs.sympy.org/latest/modules/tensor/array.html"" rel=""nofollow noreferrer"">here</a>) may be useful!</p>
",qc,apply parametric gate quantum state symbolic tensor representation p suppose given span n statevector span parametric gate span applied qubit span want implement scratch python function apply parametric gate using symbolic representation quantum state written span n symbolic tensor return p let consider explicit example take span span span x rotation gate defined span rx pmatrix amp amp pmatrix possible working implementation based code numpy arrays would following pre code import numpy np sympy import symbol cos sin 3 shape 2 psi shape theta symbol rx cos sin sin cos def state gate td gate state 1 0 reverse list range len result td 0 reverse return result p however function operates using code numpy arrays code extremely unnatural inefficient since optimized numerical computation wandering whether possible implement equivalent function working instance code sympy symbolic p strong note code module see https nofollow noreferrer may useful,"[(0, 0.2226665), (2, 0.085816555), (3, 0.15691906), (9, 0.11686631), (10, 0.010975783), (11, 0.03335747), (14, 0.23330602), (15, 0.038907405), (17, 0.030215036), (18, 0.07027606)]"
40399,40400.0,2024-11-13 07:14:01,1,32,"<p>How to obtain <span class=""math-container"">$U$</span> for the amplitude dampening channel?</p>
<p>The behaviour of the amplitude damping channel on the system can be represented by <span class=""math-container"">$U$</span>, a unitary matrix which has the following effect:</p>
<ul>
<li><span class=""math-container"">$U|00\rangle = |00\rangle$</span></li>
<li><span class=""math-container"">$U|11\rangle = |11 \rangle$</span></li>
<li><span class=""math-container"">$U|01\rangle = \sqrt{1-p}|01\rangle + i \sqrt{p}|10\rangle$</span></li>
<li><span class=""math-container"">$U|10\rangle = i\sqrt{p}|01\rangle + \sqrt{1-p}|10\rangle$</span></li>
</ul>
<p>We can then apparently write <span class=""math-container"">$U$</span> as follows: <span class=""math-container"">$$U = |00\rangle \langle 00| + \sqrt{1-p} |01\rangle \langle 01| + i \sqrt{p}|01\rangle \langle 10| + i\sqrt{p}|10\rangle \langle 01| + \sqrt{1-p}|10\rangle \langle 10| + |11\rangle \langle 11|$$</span></p>
<p>I see that each ket of the right hand side of the above four equations is being multiplied by the bra of the state being multiplied by <span class=""math-container"">$U$</span> left hand side, but I don't understand then why they are added together. I partially understand intuitively it is to give the correct positions in the matrix, but I don't understand mathematically how we obtain this result.</p>
","How to obtain $U$, representing the action of the amplitude dampening channel?",<quantum-operation><unitarity>,1,0,,,"How to obtain $U$, representing the action of the amplitude dampening channel? <p>How to obtain <span class=""math-container"">$U$</span> for the amplitude dampening channel?</p>
<p>The behaviour of the amplitude damping channel on the system can be represented by <span class=""math-container"">$U$</span>, a unitary matrix which has the following effect:</p>
<ul>
<li><span class=""math-container"">$U|00\rangle = |00\rangle$</span></li>
<li><span class=""math-container"">$U|11\rangle = |11 \rangle$</span></li>
<li><span class=""math-container"">$U|01\rangle = \sqrt{1-p}|01\rangle + i \sqrt{p}|10\rangle$</span></li>
<li><span class=""math-container"">$U|10\rangle = i\sqrt{p}|01\rangle + \sqrt{1-p}|10\rangle$</span></li>
</ul>
<p>We can then apparently write <span class=""math-container"">$U$</span> as follows: <span class=""math-container"">$$U = |00\rangle \langle 00| + \sqrt{1-p} |01\rangle \langle 01| + i \sqrt{p}|01\rangle \langle 10| + i\sqrt{p}|10\rangle \langle 01| + \sqrt{1-p}|10\rangle \langle 10| + |11\rangle \langle 11|$$</span></p>
<p>I see that each ket of the right hand side of the above four equations is being multiplied by the bra of the state being multiplied by <span class=""math-container"">$U$</span> left hand side, but I don't understand then why they are added together. I partially understand intuitively it is to give the correct positions in the matrix, but I don't understand mathematically how we obtain this result.</p>
",qc,obtain u representing action amplitude dampening channel p obtain span u amplitude dampening channel p behaviour amplitude damping channel system represented span u unitary matrix following effect ul li span li span li span p li span p p apparently write span u follows span u p p p see ket right hand side four equations multiplied bra state multiplied span u left hand side understand added together partially understand intuitively give correct positions matrix understand mathematically obtain,"[(3, 0.7018797), (7, 0.059532635), (9, 0.07387124), (11, 0.021915473), (17, 0.024960134), (18, 0.11604809)]"
40405,40407.0,2024-11-13 18:47:36,0,46,"<p>I am trying to understand Qiskit's control gates.  For example, the <a href=""https://qiskit.qotlabs.org/api/qiskit/qiskit.circuit.library.CRYGate"" rel=""nofollow noreferrer"">CRY gate</a> requires an input as the control state (<code>ctrl_state</code>).</p>
<p>If I use two qubits in a simple circuit, I can define <code>ctrl_state='1'</code> or <code>ctrl_state='0'</code>.  What is the difference between the two options, and how do their <a href=""https://qiskit.qotlabs.org/api/qiskit/qiskit.circuit.library.CRYGate"" rel=""nofollow noreferrer"">matrix representations</a> differ?</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit_aer import StatevectorSimulator
import numpy as np

x0 = 0.86
x1 = 0.45
x2 = 0.11
x3 = 0.81
xlist = np.array([x0, x1, x2, x3])
xlist = xlist/np.linalg.norm(xlist)  # initial state
theta1 = 0.254

circ = QuantumCircuit(2)
circ.prepare_state(Statevector(xlist), [0, 1])
circ.cry(theta1, 0, 1, ctrl_state='0')
# circ.cry(theta2, 0, 1, ctrl_state='1')

simulator = StatevectorSimulator()
job = qk.transpile(circ, simulator)  # execute circuit on qasm simulator
result = simulator.run(job,shots=128).result()  # results from the job
out_state = result.get_statevector()
print(np.array(out_state))
circ.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/0kJvjSIC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0kJvjSIC.png"" alt=""circuit"" /></a></p>
",What is the control state for a Controlled-RY gate?,<qiskit><quantum-gate>,2,2,,,"What is the control state for a Controlled-RY gate? <p>I am trying to understand Qiskit's control gates.  For example, the <a href=""https://qiskit.qotlabs.org/api/qiskit/qiskit.circuit.library.CRYGate"" rel=""nofollow noreferrer"">CRY gate</a> requires an input as the control state (<code>ctrl_state</code>).</p>
<p>If I use two qubits in a simple circuit, I can define <code>ctrl_state='1'</code> or <code>ctrl_state='0'</code>.  What is the difference between the two options, and how do their <a href=""https://qiskit.qotlabs.org/api/qiskit/qiskit.circuit.library.CRYGate"" rel=""nofollow noreferrer"">matrix representations</a> differ?</p>
<pre><code>from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit_aer import StatevectorSimulator
import numpy as np

x0 = 0.86
x1 = 0.45
x2 = 0.11
x3 = 0.81
xlist = np.array([x0, x1, x2, x3])
xlist = xlist/np.linalg.norm(xlist)  # initial state
theta1 = 0.254

circ = QuantumCircuit(2)
circ.prepare_state(Statevector(xlist), [0, 1])
circ.cry(theta1, 0, 1, ctrl_state='0')
# circ.cry(theta2, 0, 1, ctrl_state='1')

simulator = StatevectorSimulator()
job = qk.transpile(circ, simulator)  # execute circuit on qasm simulator
result = simulator.run(job,shots=128).result()  # results from the job
out_state = result.get_statevector()
print(np.array(out_state))
circ.draw(output='mpl')
</code></pre>
<p><a href=""https://i.sstatic.net/0kJvjSIC.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/0kJvjSIC.png"" alt=""circuit"" /></a></p>
",qc,control state gate p trying understand qiskit control gates example https nofollow noreferrer cry gate requires input control state code p use two qubits simple circuit define code 1 code 0 difference two options https nofollow noreferrer matrix representations differ pre code qiskit import quantumcircuit import statevector import statevectorsimulator import numpy np x0 x1 x2 x3 xlist x0 x1 x2 x3 xlist xlist initial state theta1 circ quantumcircuit 2 statevector xlist 0 1 theta1 0 1 0 theta2 0 1 1 simulator statevectorsimulator job circ simulator execute circuit qasm simulator result job results job print p https nofollow noreferrer img https circuit,"[(0, 0.4054348), (2, 0.12278411), (4, 0.19463934), (10, 0.07038599), (14, 0.10530151), (17, 0.042192224), (18, 0.057989072)]"
40448,40452.0,2024-11-18 13:03:18,3,62,"<p>The examples of the surface code threshold in Stim all use an optimal syndrome extraction circuit. These measure the CNOT gates in an N or Z pattern and this is known to be fault tolerant.</p>
<p>Suppose I build a syndrome extraction circuit in a non-optimal way by measuring each stabilizer sequentially instead. After d rounds, I record the results and use PyMatching to decode - all in the usual way. The only difference is that I did not interleave and parallelize the CNOT gates of the stabilizers.</p>
<p>Since I am still using Stim, there's no idling error - the only errors inserted are before measurements/resets or after Clifford gates.</p>
<p>Should I still see a threshold? I currently do not and in fact, I see a higher logical error rate for higher distance codes. The best performing code is d=3. Is this expected to see for suboptimal syndrome extraction circuits or have I made a mistake with my Stim code?</p>
",Does the syndrome extraction circuit determine the threshold for the surface code?,<error-correction><stim><surface-code>,1,2,,,"Does the syndrome extraction circuit determine the threshold for the surface code? <p>The examples of the surface code threshold in Stim all use an optimal syndrome extraction circuit. These measure the CNOT gates in an N or Z pattern and this is known to be fault tolerant.</p>
<p>Suppose I build a syndrome extraction circuit in a non-optimal way by measuring each stabilizer sequentially instead. After d rounds, I record the results and use PyMatching to decode - all in the usual way. The only difference is that I did not interleave and parallelize the CNOT gates of the stabilizers.</p>
<p>Since I am still using Stim, there's no idling error - the only errors inserted are before measurements/resets or after Clifford gates.</p>
<p>Should I still see a threshold? I currently do not and in fact, I see a higher logical error rate for higher distance codes. The best performing code is d=3. Is this expected to see for suboptimal syndrome extraction circuits or have I made a mistake with my Stim code?</p>
",qc,syndrome extraction circuit determine threshold surface code p examples surface code threshold stim use optimal syndrome extraction circuit measure cnot gates n z pattern known fault p suppose build syndrome extraction circuit way measuring stabilizer sequentially instead rounds record results use pymatching decode usual way difference interleave parallelize cnot gates p since still using stim idling error errors inserted clifford p still see threshold currently fact see higher logical error rate higher distance codes best performing code expected see suboptimal syndrome extraction circuits made mistake stim code,"[(3, 0.019248005), (5, 0.4844674), (14, 0.4214827), (17, 0.07294417)]"
40453,,2024-11-18 18:36:42,1,24,"<p>With NoiseModel in Qiskit we can add damping terms, for example through <code>thermal_relaxation_error</code>. I'd like to know if there is a way to simulate Rabi oscillation at the circuit level (i.e. plotting the qubit excitation probability as a function of a rotation angle with some decoherence occurring).</p>
<p>For instance, if I implement something like:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit.circuit import Parameter
from qiskit_aer.noise import (
    NoiseModel,
    thermal_relaxation_error,
)

# --- Noise Model ---
T1 = 100e3 # ns
T2 = 200e3 # ns
time_ry = 200e3
errors_ry = [
    thermal_relaxation_error(T1, T2, time_ry)
]
noise_thermal = NoiseModel(basis_gates=['ry'])
noise_thermal.add_quantum_error(thermal_relaxation_error(T1, T2, time_ry), 'ry', [0])
sim_noisy = AerSimulator(noise_model=noise_thermal)
passmanager = generate_preset_pass_manager(
    optimization_level=0, backend=sim_noisy
)

# --- Circuit ---
circuit = QuantumCircuit(1, 1)
theta = Parameter('theta')
circuit.ry(theta, 0)
circuit.measure(0, 0)

circuit_transpiled = passmanager.run(circuit)
nshots = 4000
# Run and get counts
res = []
for th in np.linspace(0, 2*np.pi, 100):
    passmanager = generate_preset_pass_manager(
        optimization_level=0, backend=sim_noisy
    )
    circuit_transpiled = passmanager.run(circuit.assign_parameters({theta: th}))
    result_noisy = sim_noisy.run(circuit_transpiled, shots = nshots).result()

    counts_noisy = result_noisy.get_counts(0)
    if '1' not in counts_noisy:
        counts_noisy['1'] = 0
    res.append(counts_noisy['1'] / nshots)
plt.plot(res)
</code></pre>
<p>I get an oscillation between 0 and some value (the longer the gate time, the smaller the value), but this is not the Rabi evolution I would expect (i.e. the oscillation is not damped and it does not converge to 0.5). I know there are better ways to simulate Rabi oscillation (QuTiP), but doing this in Qiskit at the <code>QuantumCircuit</code> level would be a powerful tool to add some other gates after the time evolution and see what happens.</p>
<p>A QuTiP example that reproduces the behaviour I'd like to achieve with Qiskit is the following:</p>
<pre><code>import numpy as np
from scqubits import Transmon
from qutip import mesolve, ket2dm, Qobj
import matplotlib.pyplot as plt

tmon = Transmon(EJ = 10, EC = 0.2, ng = 0, ncut = 11)
H = tmon.hamiltonian(energy_esys=True)
H = Qobj(H) * 2 * np.pi
evals, ekets = H.eigenstates()
psi_g, psi_e = ekets[0], ekets[1]  # basis(2, 0)
sx = psi_g * psi_e.dag() + psi_e * psi_g.dag()
sz = psi_g * psi_g.dag() - psi_e * psi_e.dag()

Trabi = 100  # us
decay_rate = 1 / Trabi
c_op_list = []
c_op_list.append(np.sqrt(decay_rate) * ekets[0] * ekets[1].dag())

H0 = 0.5 * (evals[1] - evals[0]) * sz
psi_g = ekets[0]  # basis(2, 0)
psi_e = ekets[1]  # basis(2, 1)
rabi_power = 0.5
Hd = rabi_power * sx
Heff = [H0, [Hd, &quot;sin(wd*t)&quot;]]
args = {&quot;wd&quot;: (tmon.E01() * 2 * np.pi)}
psi0 = psi_g
tlist = np.linspace(0.0, Trabi, 201)
result = mesolve(Heff, psi0, tlist, [c_op_list], [ket2dm(psi_e)], args=args)
plt.plot(tlist, result.expect[0])
</code></pre>
<p>Is there a way to achieve it?</p>
<p>Thanks</p>
","In Qiskit, is it possible to simulate a Rabi oscillation at the Circuit level through NoiseModel?",<qiskit><simulation><hamiltonian-simulation><noise><qutip>,1,0,,,"In Qiskit, is it possible to simulate a Rabi oscillation at the Circuit level through NoiseModel? <p>With NoiseModel in Qiskit we can add damping terms, for example through <code>thermal_relaxation_error</code>. I'd like to know if there is a way to simulate Rabi oscillation at the circuit level (i.e. plotting the qubit excitation probability as a function of a rotation angle with some decoherence occurring).</p>
<p>For instance, if I implement something like:</p>
<pre><code>import numpy as np
from qiskit import QuantumCircuit
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_aer import AerSimulator
from qiskit.circuit import Parameter
from qiskit_aer.noise import (
    NoiseModel,
    thermal_relaxation_error,
)

# --- Noise Model ---
T1 = 100e3 # ns
T2 = 200e3 # ns
time_ry = 200e3
errors_ry = [
    thermal_relaxation_error(T1, T2, time_ry)
]
noise_thermal = NoiseModel(basis_gates=['ry'])
noise_thermal.add_quantum_error(thermal_relaxation_error(T1, T2, time_ry), 'ry', [0])
sim_noisy = AerSimulator(noise_model=noise_thermal)
passmanager = generate_preset_pass_manager(
    optimization_level=0, backend=sim_noisy
)

# --- Circuit ---
circuit = QuantumCircuit(1, 1)
theta = Parameter('theta')
circuit.ry(theta, 0)
circuit.measure(0, 0)

circuit_transpiled = passmanager.run(circuit)
nshots = 4000
# Run and get counts
res = []
for th in np.linspace(0, 2*np.pi, 100):
    passmanager = generate_preset_pass_manager(
        optimization_level=0, backend=sim_noisy
    )
    circuit_transpiled = passmanager.run(circuit.assign_parameters({theta: th}))
    result_noisy = sim_noisy.run(circuit_transpiled, shots = nshots).result()

    counts_noisy = result_noisy.get_counts(0)
    if '1' not in counts_noisy:
        counts_noisy['1'] = 0
    res.append(counts_noisy['1'] / nshots)
plt.plot(res)
</code></pre>
<p>I get an oscillation between 0 and some value (the longer the gate time, the smaller the value), but this is not the Rabi evolution I would expect (i.e. the oscillation is not damped and it does not converge to 0.5). I know there are better ways to simulate Rabi oscillation (QuTiP), but doing this in Qiskit at the <code>QuantumCircuit</code> level would be a powerful tool to add some other gates after the time evolution and see what happens.</p>
<p>A QuTiP example that reproduces the behaviour I'd like to achieve with Qiskit is the following:</p>
<pre><code>import numpy as np
from scqubits import Transmon
from qutip import mesolve, ket2dm, Qobj
import matplotlib.pyplot as plt

tmon = Transmon(EJ = 10, EC = 0.2, ng = 0, ncut = 11)
H = tmon.hamiltonian(energy_esys=True)
H = Qobj(H) * 2 * np.pi
evals, ekets = H.eigenstates()
psi_g, psi_e = ekets[0], ekets[1]  # basis(2, 0)
sx = psi_g * psi_e.dag() + psi_e * psi_g.dag()
sz = psi_g * psi_g.dag() - psi_e * psi_e.dag()

Trabi = 100  # us
decay_rate = 1 / Trabi
c_op_list = []
c_op_list.append(np.sqrt(decay_rate) * ekets[0] * ekets[1].dag())

H0 = 0.5 * (evals[1] - evals[0]) * sz
psi_g = ekets[0]  # basis(2, 0)
psi_e = ekets[1]  # basis(2, 1)
rabi_power = 0.5
Hd = rabi_power * sx
Heff = [H0, [Hd, &quot;sin(wd*t)&quot;]]
args = {&quot;wd&quot;: (tmon.E01() * 2 * np.pi)}
psi0 = psi_g
tlist = np.linspace(0.0, Trabi, 201)
result = mesolve(Heff, psi0, tlist, [c_op_list], [ket2dm(psi_e)], args=args)
plt.plot(tlist, result.expect[0])
</code></pre>
<p>Is there a way to achieve it?</p>
<p>Thanks</p>
",qc,qiskit possible simulate rabi oscillation circuit level noisemodel p noisemodel qiskit add damping terms example code like know way simulate rabi oscillation circuit level plotting qubit excitation probability function rotation angle decoherence occurring p instance implement something like pre code import numpy np qiskit import quantumcircuit import import aersimulator import parameter import noisemodel noise model t1 100e3 ns t2 200e3 ns 200e3 t1 t2 noisemodel t1 t2 0 aersimulator passmanager circuit circuit quantumcircuit 1 1 theta parameter theta 0 0 0 circuit nshots 4000 run get counts res th 0 2 100 passmanager theta th shots nshots 0 1 1 0 1 nshots res p get oscillation 0 value longer gate time smaller value rabi evolution would expect oscillation damped converge know better ways simulate rabi oscillation qutip qiskit code quantumcircuit level would powerful tool add gates time evolution see p qutip example reproduces behaviour like achieve qiskit following pre code import numpy np scqubits import transmon qutip import mesolve ket2dm qobj import plt tmon transmon ej 10 ec ng 0 ncut 11 h h qobj h 2 evals ekets ekets 0 ekets 1 basis 2 0 sx sz trabi 100 us 1 trabi ekets 0 ekets 1 h0 evals 1 evals 0 sz ekets 0 basis 2 0 ekets 1 basis 2 1 hd sx heff h0 hd quot sin wd quot args quot wd quot 2 psi0 tlist trabi 201 result mesolve heff psi0 tlist ket2dm tlist 0 p way achieve p thanks,"[(0, 0.22198758), (1, 0.011405903), (2, 0.15694301), (11, 0.016417228), (14, 0.54774064), (17, 0.019731196), (19, 0.018823072)]"
40463,,2024-11-19 15:35:21,3,84,"<blockquote>
<p>Q:<span class=""math-container"">$$H=\frac{1}{\sqrt{2}}(|0\rangle\langle0|+|1\rangle\langle 0|+|0\rangle\langle 1|-|1\rangle\langle 1|)$$</span>
Show that
<span class=""math-container"">$$ H^{\otimes N}=\frac{1}{\sqrt{2^N}}\sum_{x,y\in\{0,1\}^N}(-1)^{x\cdot y}|x\rangle\langle y| $$</span></p>
</blockquote>
<p>By induction, we get that
<span class=""math-container"">$$\begin{aligned}H^{\otimes (N+1)}&amp;=\bigg(\frac{1}{2^{\frac{n}{2}}}\sum_{x,y}(-1)^{x,y}|x\rangle\langle y|\bigg)\otimes\bigg(\frac{1}{\sqrt{2}}(|0\rangle\langle0|+|1\rangle\langle 0|+|0\rangle\langle 1|-|1\rangle\langle 1|)\bigg)\\
&amp;=\frac{1}{2^{\frac{n+1}{2}}}\sum_{x,y}(-1)^{\overline{x0}\cdot\overline{y0}}|x0\rangle\langle y0|+(-1)^{\overline{x1}\cdot\overline{y0}}|x1\rangle\langle y0|+(-1)^{\overline{x0}\cdot\overline{y1}}|x0\rangle\langle y1|+(-1)^{\overline{x1}\cdot\overline{y1}}|x1\rangle\langle y1|
\\&amp;=\frac{1}{2^{\frac{n+1}{2}}}\sum_{x',y'\in\{0,1\}^{N+1}}(-1)^{x'\cdot y'}|x'\rangle\langle y'|\end{aligned}$$</span></p>
<p>But I'm not sure that this step is right
<span class=""math-container"">$$ |xi\rangle\langle yj|=|x\rangle\langle y|\otimes|i\rangle\langle j|\qquad i,j=0,1
$$</span></p>
<hr />
<p>Updated</p>
<p>So at last we just need to prove this equation, which is for any vector <span class=""math-container"">$|mn\rangle=|m\rangle\otimes|n\rangle$</span>
<span class=""math-container"">$$
\bigg(|x\rangle\otimes|j\rangle\bigg)\bigg(\langle y|\otimes\langle i|\bigg)|mn\rangle = \bigg(|x\rangle\langle y|\otimes|i\rangle\langle j|\bigg)|mn\rangle
$$</span>
In fact <span class=""math-container"">$$\begin{aligned}
\text{LHS} &amp; = \langle yi | mn \rangle \bigg(|x\rangle\otimes|j\rangle\bigg)\\
\text{RHS} &amp; =  \bigg(|x\rangle\langle y|\otimes|i\rangle\langle j|\bigg)\bigg(|m\rangle\otimes|n\rangle\bigg)\\
&amp;\qquad \text{using definition of tensor product}(A \otimes B) (C \otimes D) = AC \otimes BD\\
&amp; = \bigg( \langle y | m\rangle | x \rangle \bigg) \otimes \bigg( \langle i | n\rangle | j \rangle \bigg)
\end{aligned}$$</span></p>
<p>It's obvious that <span class=""math-container"">$\langle yi | mn \rangle =1$</span> iff <span class=""math-container"">$y=m$</span> and <span class=""math-container"">$i=n$</span> which means that <span class=""math-container"">$\langle y | m \rangle =1$</span> and <span class=""math-container"">$\langle i | n \rangle =1$</span>.</p>
",Proof of Hadamard transform on $N$ qubits,<quantum-gate>,0,7,,,"Proof of Hadamard transform on $N$ qubits <blockquote>
<p>Q:<span class=""math-container"">$$H=\frac{1}{\sqrt{2}}(|0\rangle\langle0|+|1\rangle\langle 0|+|0\rangle\langle 1|-|1\rangle\langle 1|)$$</span>
Show that
<span class=""math-container"">$$ H^{\otimes N}=\frac{1}{\sqrt{2^N}}\sum_{x,y\in\{0,1\}^N}(-1)^{x\cdot y}|x\rangle\langle y| $$</span></p>
</blockquote>
<p>By induction, we get that
<span class=""math-container"">$$\begin{aligned}H^{\otimes (N+1)}&amp;=\bigg(\frac{1}{2^{\frac{n}{2}}}\sum_{x,y}(-1)^{x,y}|x\rangle\langle y|\bigg)\otimes\bigg(\frac{1}{\sqrt{2}}(|0\rangle\langle0|+|1\rangle\langle 0|+|0\rangle\langle 1|-|1\rangle\langle 1|)\bigg)\\
&amp;=\frac{1}{2^{\frac{n+1}{2}}}\sum_{x,y}(-1)^{\overline{x0}\cdot\overline{y0}}|x0\rangle\langle y0|+(-1)^{\overline{x1}\cdot\overline{y0}}|x1\rangle\langle y0|+(-1)^{\overline{x0}\cdot\overline{y1}}|x0\rangle\langle y1|+(-1)^{\overline{x1}\cdot\overline{y1}}|x1\rangle\langle y1|
\\&amp;=\frac{1}{2^{\frac{n+1}{2}}}\sum_{x',y'\in\{0,1\}^{N+1}}(-1)^{x'\cdot y'}|x'\rangle\langle y'|\end{aligned}$$</span></p>
<p>But I'm not sure that this step is right
<span class=""math-container"">$$ |xi\rangle\langle yj|=|x\rangle\langle y|\otimes|i\rangle\langle j|\qquad i,j=0,1
$$</span></p>
<hr />
<p>Updated</p>
<p>So at last we just need to prove this equation, which is for any vector <span class=""math-container"">$|mn\rangle=|m\rangle\otimes|n\rangle$</span>
<span class=""math-container"">$$
\bigg(|x\rangle\otimes|j\rangle\bigg)\bigg(\langle y|\otimes\langle i|\bigg)|mn\rangle = \bigg(|x\rangle\langle y|\otimes|i\rangle\langle j|\bigg)|mn\rangle
$$</span>
In fact <span class=""math-container"">$$\begin{aligned}
\text{LHS} &amp; = \langle yi | mn \rangle \bigg(|x\rangle\otimes|j\rangle\bigg)\\
\text{RHS} &amp; =  \bigg(|x\rangle\langle y|\otimes|i\rangle\langle j|\bigg)\bigg(|m\rangle\otimes|n\rangle\bigg)\\
&amp;\qquad \text{using definition of tensor product}(A \otimes B) (C \otimes D) = AC \otimes BD\\
&amp; = \bigg( \langle y | m\rangle | x \rangle \bigg) \otimes \bigg( \langle i | n\rangle | j \rangle \bigg)
\end{aligned}$$</span></p>
<p>It's obvious that <span class=""math-container"">$\langle yi | mn \rangle =1$</span> iff <span class=""math-container"">$y=m$</span> and <span class=""math-container"">$i=n$</span> which means that <span class=""math-container"">$\langle y | m \rangle =1$</span> and <span class=""math-container"">$\langle i | n \rangle =1$</span>.</p>
",qc,proof hadamard transform n qubits blockquote p q span 1 2 show span n 1 x p induction get span aligned amp 1 n 2 x x 1 2 amp 1 2 x x0 y0 x1 y0 x0 y1 x1 y1 amp 1 2 x aligned p sure step right span hr p updated p last need prove equation vector span span fact span aligned lhs amp yi mn rhs amp amp using definition tensor product b c ac amp x j aligned p obvious span yi mn iff span span means span span n,"[(0, 0.01342612), (2, 0.09599421), (3, 0.40039134), (6, 0.03770464), (10, 0.1767093), (15, 0.22350506), (17, 0.05090207)]"
40492,40495.0,2024-11-22 15:38:27,2,83,"<p>I am testing the STIM's default implementation of repetition code with different values for the distance and rounds. It seems to me the logical error rate is independent from the distance, which I did not expect. The following code is adapted from the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">introductory tutorial of STIM</a>:</p>
<pre><code>import numpy as np
import stim
import pymatching
import pandas as pd
import matplotlib.pyplot as plt

def calculate_logical_error_probability(circuit, num_shots=10_000_000):
    # Compile the circuit for sampling
    sampler = circuit.compile_detector_sampler()
    
    # Sample the circuit
    samples, observables = sampler.sample(num_shots, separate_observables=True)

    # Create a pymatching Matching object from the circuit
    matching = pymatching.Matching.from_stim_circuit(circuit)
    
    # Decode the samples
    corrections = matching.decode_batch(samples)
    
    # Calculate the logical error rate
    logical_errors = np.any(corrections, axis=1)
    logical_error_rate = np.mean(logical_errors)
    
    return logical_error_rate



def calculate_logical_error_rates(rounds_list, distance_list, error_probability, num_shots=10_000_000):

    # Initialize an empty list to store the results
    results = []

    # Loop over the parameters and calculate the logical error probability
    for rounds in rounds_list:
        for distance in distance_list:
            circuit = stim.Circuit.generated(
                &quot;repetition_code:memory&quot;,
                rounds=rounds,
                distance=distance,
                before_round_data_depolarization=error_probability,
                before_measure_flip_probability=error_probability)
            
            logical_error_rate = calculate_logical_error_probability(circuit, num_shots)
            row = {'rounds': rounds, 'distance': distance, 'logical_error_rate': logical_error_rate}
            results.append(row)
            print(row)

    # Create a DataFrame from the results
    df_results = pd.DataFrame(results)
    return df_results


def plot_logical_error_rates(df_results):
    plt.figure(figsize=(10, 6))
    
    for distance in df_results['distance'].unique():
        subset = df_results[df_results['distance'] == distance]
        plt.plot(subset['rounds'], subset['logical_error_rate'], label=f'Distance {distance}')
    
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('Rounds')
    plt.ylabel('Logical Error Rate')
    plt.title('Logical Error Rate vs Rounds for Different Distances')
    plt.legend()
    plt.grid(True)
    plt.show()


# Define the parameters
rounds_list = [10, 40]
distance_list = [3, 5, 7, 9]
error_probability = 0.001

# Call the method and print the results
df_results = calculate_logical_error_rates(rounds_list, distance_list, error_probability)
plot_logical_error_rates(df_results)
</code></pre>
<p>The resulting plot is the following. Can you explain if that is the expected behavior and why? I suspect there might be an error in my adaptation of the tutorial, still cannot spot exactly where.</p>
<p><a href=""https://i.sstatic.net/80xLBbTK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/80xLBbTK.png"" alt=""Plot of the logical error as a function of the code distance"" /></a></p>
",logical error probability independent from distance in STIM default repetition code,<stim>,2,0,,,"logical error probability independent from distance in STIM default repetition code <p>I am testing the STIM's default implementation of repetition code with different values for the distance and rounds. It seems to me the logical error rate is independent from the distance, which I did not expect. The following code is adapted from the <a href=""https://github.com/quantumlib/Stim/blob/main/doc/getting_started.ipynb"" rel=""nofollow noreferrer"">introductory tutorial of STIM</a>:</p>
<pre><code>import numpy as np
import stim
import pymatching
import pandas as pd
import matplotlib.pyplot as plt

def calculate_logical_error_probability(circuit, num_shots=10_000_000):
    # Compile the circuit for sampling
    sampler = circuit.compile_detector_sampler()
    
    # Sample the circuit
    samples, observables = sampler.sample(num_shots, separate_observables=True)

    # Create a pymatching Matching object from the circuit
    matching = pymatching.Matching.from_stim_circuit(circuit)
    
    # Decode the samples
    corrections = matching.decode_batch(samples)
    
    # Calculate the logical error rate
    logical_errors = np.any(corrections, axis=1)
    logical_error_rate = np.mean(logical_errors)
    
    return logical_error_rate



def calculate_logical_error_rates(rounds_list, distance_list, error_probability, num_shots=10_000_000):

    # Initialize an empty list to store the results
    results = []

    # Loop over the parameters and calculate the logical error probability
    for rounds in rounds_list:
        for distance in distance_list:
            circuit = stim.Circuit.generated(
                &quot;repetition_code:memory&quot;,
                rounds=rounds,
                distance=distance,
                before_round_data_depolarization=error_probability,
                before_measure_flip_probability=error_probability)
            
            logical_error_rate = calculate_logical_error_probability(circuit, num_shots)
            row = {'rounds': rounds, 'distance': distance, 'logical_error_rate': logical_error_rate}
            results.append(row)
            print(row)

    # Create a DataFrame from the results
    df_results = pd.DataFrame(results)
    return df_results


def plot_logical_error_rates(df_results):
    plt.figure(figsize=(10, 6))
    
    for distance in df_results['distance'].unique():
        subset = df_results[df_results['distance'] == distance]
        plt.plot(subset['rounds'], subset['logical_error_rate'], label=f'Distance {distance}')
    
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('Rounds')
    plt.ylabel('Logical Error Rate')
    plt.title('Logical Error Rate vs Rounds for Different Distances')
    plt.legend()
    plt.grid(True)
    plt.show()


# Define the parameters
rounds_list = [10, 40]
distance_list = [3, 5, 7, 9]
error_probability = 0.001

# Call the method and print the results
df_results = calculate_logical_error_rates(rounds_list, distance_list, error_probability)
plot_logical_error_rates(df_results)
</code></pre>
<p>The resulting plot is the following. Can you explain if that is the expected behavior and why? I suspect there might be an error in my adaptation of the tutorial, still cannot spot exactly where.</p>
<p><a href=""https://i.sstatic.net/80xLBbTK.png"" rel=""nofollow noreferrer""><img src=""https://i.sstatic.net/80xLBbTK.png"" alt=""Plot of the logical error as a function of the code distance"" /></a></p>
",qc,logical error probability independent distance stim default repetition code p testing stim default implementation repetition code different values distance rounds seems logical error rate independent distance expect following code adapted https nofollow noreferrer introductory tutorial stim pre code import numpy np import stim import pymatching import pandas pd import plt def circuit compile circuit sampling sampler sample circuit samples observables create pymatching matching object circuit matching circuit decode samples corrections samples calculate logical error rate corrections return def initialize empty list store results results loop parameters calculate logical error probability rounds distance circuit quot memory quot circuit row rounds distance row print row create dataframe results results return def 10 6 distance subset distance subset subset distance error rate error rate vs rounds different distances true define parameters 10 40 3 5 7 9 call method print results p resulting plot following explain expected behavior suspect might error adaptation tutorial still spot exactly p https nofollow noreferrer img https plot logical error function code distance,"[(0, 0.22013727), (4, 0.08135116), (5, 0.28569582), (6, 0.04332565), (14, 0.26196998), (17, 0.091915965), (19, 0.014816624)]"
40502,,2024-11-23 17:30:05,1,25,"<p>The GHZ game involves three non-communicating players, Alice, Bob, and Carol. They each receive a bit, <span class=""math-container"">$r,s,t$</span> with the guarantee that <span class=""math-container"">$r\oplus s\oplus t=0$</span> (i.e. with the guarantee that there are an even number of 1s). Their goal is to output <span class=""math-container"">$a,b,c$</span> respectively so <span class=""math-container"">$a\oplus b\oplus c=r\vee s\vee t$</span>. The winning conditions are summarized in the table below:</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th><span class=""math-container"">$rst$</span></th>
<th><span class=""math-container"">$a\oplus b\oplus c$</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>011</td>
<td>1</td>
</tr>
<tr>
<td>101</td>
<td>1</td>
</tr>
<tr>
<td>110</td>
<td>1</td>
</tr>
</tbody>
</table></div>
<p>A strategy which works is for them to share the entangled state <span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(|000\rangle+|111\rangle\right).$$</span> If they see a <span class=""math-container"">$0$</span>, they apply the <span class=""math-container"">$X$</span>-gate. If they see a <span class=""math-container"">$1$</span>, they apply a <span class=""math-container"">$Y$</span>-gate. It can be shown that this is a winning strategy since after applying the respective gates, we end up with a superposition of states with the required parities.</p>
<p>However, they could have also done this with the state <span class=""math-container"">$$\frac{1}{2}\left(|000\rangle-|011\rangle-|101\rangle-|110\rangle\right),$$</span> and applying a Hadamard on <span class=""math-container"">$r,s,t=1$</span> and doing nothing otherwise.</p>
<p>I am aware that in order to determine when a three qubit state <span class=""math-container"">$|\psi\rangle$</span> can yield a winning strategy has something to do with correlations they satisfy, but I have no idea what this means really. What I know is that the gate Alice applies to the state <span class=""math-container"">$|\psi\rangle$</span> is a function of the bit <span class=""math-container"">$r$</span> she receives. Call it <span class=""math-container"">$M_r$</span>. Similarly, the gates Bob, Carol apply can be called <span class=""math-container"">$M_s,M_t$</span>. Thus the net effect on the state is <span class=""math-container"">$M_{rst}=M_r\otimes M_s\otimes M_t$</span>. The goal is that this gate should be such that <span class=""math-container"">$$M_{rst}|\psi\rangle$$</span> should result in a superposition state where the parity of each state is even in the event <span class=""math-container"">$r=s=t=0$</span> and in a superposition state where the parity of each state should be odd in the other events. But how can I use this to impose restrictions on the allowed &quot;GHZ states&quot; <span class=""math-container"">$|\psi\rangle$</span> if <span class=""math-container"">$M_r,M_s,M_t$</span> are just arbitrary gates?</p>
",What states are valid GHZ game states?,<entanglement><nonlocal-games><ghz-state>,1,1,,,"What states are valid GHZ game states? <p>The GHZ game involves three non-communicating players, Alice, Bob, and Carol. They each receive a bit, <span class=""math-container"">$r,s,t$</span> with the guarantee that <span class=""math-container"">$r\oplus s\oplus t=0$</span> (i.e. with the guarantee that there are an even number of 1s). Their goal is to output <span class=""math-container"">$a,b,c$</span> respectively so <span class=""math-container"">$a\oplus b\oplus c=r\vee s\vee t$</span>. The winning conditions are summarized in the table below:</p>
<div class=""s-table-container""><table class=""s-table"">
<thead>
<tr>
<th><span class=""math-container"">$rst$</span></th>
<th><span class=""math-container"">$a\oplus b\oplus c$</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>011</td>
<td>1</td>
</tr>
<tr>
<td>101</td>
<td>1</td>
</tr>
<tr>
<td>110</td>
<td>1</td>
</tr>
</tbody>
</table></div>
<p>A strategy which works is for them to share the entangled state <span class=""math-container"">$$\frac{1}{\sqrt{2}}\left(|000\rangle+|111\rangle\right).$$</span> If they see a <span class=""math-container"">$0$</span>, they apply the <span class=""math-container"">$X$</span>-gate. If they see a <span class=""math-container"">$1$</span>, they apply a <span class=""math-container"">$Y$</span>-gate. It can be shown that this is a winning strategy since after applying the respective gates, we end up with a superposition of states with the required parities.</p>
<p>However, they could have also done this with the state <span class=""math-container"">$$\frac{1}{2}\left(|000\rangle-|011\rangle-|101\rangle-|110\rangle\right),$$</span> and applying a Hadamard on <span class=""math-container"">$r,s,t=1$</span> and doing nothing otherwise.</p>
<p>I am aware that in order to determine when a three qubit state <span class=""math-container"">$|\psi\rangle$</span> can yield a winning strategy has something to do with correlations they satisfy, but I have no idea what this means really. What I know is that the gate Alice applies to the state <span class=""math-container"">$|\psi\rangle$</span> is a function of the bit <span class=""math-container"">$r$</span> she receives. Call it <span class=""math-container"">$M_r$</span>. Similarly, the gates Bob, Carol apply can be called <span class=""math-container"">$M_s,M_t$</span>. Thus the net effect on the state is <span class=""math-container"">$M_{rst}=M_r\otimes M_s\otimes M_t$</span>. The goal is that this gate should be such that <span class=""math-container"">$$M_{rst}|\psi\rangle$$</span> should result in a superposition state where the parity of each state is even in the event <span class=""math-container"">$r=s=t=0$</span> and in a superposition state where the parity of each state should be odd in the other events. But how can I use this to impose restrictions on the allowed &quot;GHZ states&quot; <span class=""math-container"">$|\psi\rangle$</span> if <span class=""math-container"">$M_r,M_s,M_t$</span> are just arbitrary gates?</p>
",qc,states valid ghz game states p ghz game involves three players alice bob carol receive bit span r guarantee span guarantee even number 1s goal output span b c respectively span winning conditions summarized table div table thead tr th span rst th span c tbody tr td 000 td 0 tr td 011 td 1 tr td 101 td 1 tr td 110 td 1 p strategy works share entangled state span 1 2 see span 0 apply span x see span 1 apply span shown winning strategy since applying respective gates end superposition states required p however could also done state span 1 2 applying hadamard span r nothing p aware order determine three qubit state span yield winning strategy something correlations satisfy idea means really know gate alice applies state span function bit span r receives call span similarly gates bob carol apply called span thus net effect state span rst goal gate span rst result superposition state parity state even event span superposition state parity state odd events use impose restrictions allowed quot ghz states quot span span arbitrary gates,"[(2, 0.040234637), (3, 0.27603576), (5, 0.024486098), (9, 0.015634134), (17, 0.10511034), (18, 0.50459355), (19, 0.016594343)]"
